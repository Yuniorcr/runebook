<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="95f12ecc4c931b6cd52c7c8712c089eb1f901958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array of objects.</source>
          <target state="translated">&lt;code&gt;Vector&lt;/code&gt; 클래스는 객체의 가변 길이 배열을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4aeeb9de325145d9de793fc5e171c818d3209bca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a &lt;code&gt;Vector&lt;/code&gt; can grow or shrink as needed to accommodate adding and removing items after the &lt;code&gt;Vector&lt;/code&gt; has been created.</source>
          <target state="translated">&lt;code&gt;Vector&lt;/code&gt; 클래스는 객체의 가변 길이 배열을 구현합니다. 배열과 마찬가지로 정수 인덱스를 사용하여 액세스 할 수있는 구성 요소가 포함되어 있습니다. 그러나 &lt;code&gt;Vector&lt;/code&gt; 를 만든 후 항목을 추가하거나 제거 할 수 있도록 &lt;code&gt;Vector&lt;/code&gt; 크기가 필요에 따라 커지거나 줄어들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a2a2d34e6edf9a736c688c4e496fc8f413e787d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Vectors&lt;/code&gt; of &lt;code&gt;Object&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;Vector&lt;/code&gt; 의 &lt;code&gt;Vectors&lt;/code&gt; 의 &lt;code&gt;Object&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="c51ed8f23325be7432bcd95a2fad8327dd3a6c7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vector&lt;/code&gt; of column identifiers.</source>
          <target state="translated">열 식별자 의 &lt;code&gt;Vector&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef38f50778470be314c350ac1236d4ae66252c2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VetoableChangeSupport&lt;/code&gt; associated with this &lt;code&gt;BeanContextChildSupport&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VetoableChangeSupport&lt;/code&gt; 는 이와 관련 &lt;code&gt;BeanContextChildSupport&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a05157c7add57e69ed4b84eda43d3b9471dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Void&lt;/code&gt; class is an uninstantiable placeholder class to hold a reference to the &lt;code&gt;Class&lt;/code&gt; object representing the Java keyword void.</source>
          <target state="translated">&lt;code&gt;Void&lt;/code&gt; 클래스에 대한 참조를 유지하는 uninstantiable 자리 클래스입니다 &lt;code&gt;Class&lt;/code&gt; 자바를 나타내는 개체가 무효 키워드.</target>
        </trans-unit>
        <trans-unit id="b7201fbe9821d111b8e7310e2e9e5f50d2f9f0fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WebRowSetImpl&lt;/code&gt; provides the standard reference implementation, which may be extended if required.</source>
          <target state="translated">&lt;code&gt;WebRowSetImpl&lt;/code&gt; 는 필요하다면 연장 될 수도 표준 참조 구현을 제공한다.</target>
        </trans-unit>
        <trans-unit id="9727e0ed3037aaa46ce224bd1fe010383f3480c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Window&lt;/code&gt; and its subcomponents can be made displayable again by rebuilding the native resources with a subsequent call to &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;show&lt;/code&gt;. The states of the recreated &lt;code&gt;Window&lt;/code&gt; and its subcomponents will be identical to the states of these objects at the point where the &lt;code&gt;Window&lt;/code&gt; was disposed (not accounting for additional modifications between those actions).</source>
          <target state="translated">&lt;code&gt;Window&lt;/code&gt; 와 그 하위 구성 요소에 대한 후속 호출 네이티브 자원을 재 구축하여 다시 표시 가능하게 할 수 있습니다 &lt;code&gt;pack&lt;/code&gt; 또는 &lt;code&gt;show&lt;/code&gt; . 다시 생성 된 &lt;code&gt;Window&lt;/code&gt; 및 해당 하위 구성 요소의 상태는 &lt;code&gt;Window&lt;/code&gt; 가 삭제 된 시점의 이러한 개체 상태와 동일합니다 (해당 작업 간의 추가 수정은 고려하지 않음).</target>
        </trans-unit>
        <trans-unit id="9e95df5176a50ee550434605ecd3ba4571d76304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Window&lt;/code&gt; class and the &lt;code&gt;Applet&lt;/code&gt; class are the validate roots in AWT. Swing introduces more validate roots.</source>
          <target state="translated">&lt;code&gt;Window&lt;/code&gt; 클래스와 &lt;code&gt;Applet&lt;/code&gt; 클래스는 AWT의 유효성을 뿌리입니다. Swing은 더 많은 검증 루트를 도입합니다.</target>
        </trans-unit>
        <trans-unit id="dcf547c8c4952ee62719999861c70718ea329248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Window&lt;/code&gt; meets the requirements outlined in the &lt;a href=&quot;#isFocusableWindow()&quot;&gt;&lt;code&gt;isFocusableWindow()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;Window&lt;/code&gt; 에서 설명한 요건 충족 &lt;a href=&quot;#isFocusableWindow()&quot;&gt; &lt;code&gt;isFocusableWindow()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="704045f5a2599d8a137d2e74c9f85efdab2b97d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Window&lt;/code&gt;'s &lt;code&gt;autoRequestFocus&lt;/code&gt; property is of the &lt;code&gt;true&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;Window&lt;/code&gt; 의 &lt;code&gt;autoRequestFocus&lt;/code&gt; 의 속성이다 &lt;code&gt;true&lt;/code&gt; 가치.</target>
        </trans-unit>
        <trans-unit id="26d20b795a509ccf345f4880f86bffc5ff46ea07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Writer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Writer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77fb3bff5f49c42c2161c3e19062b5010a06389f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Writer&lt;/code&gt; methods to write text throw &lt;code&gt;IOException&lt;/code&gt; if the text cannot be encoded using the specified charset.</source>
          <target state="translated">지정된 문자 세트를 사용하여 텍스트를 인코딩 할 수없는 경우 텍스트를 작성 하는 &lt;code&gt;Writer&lt;/code&gt; 메소드에서 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5df6357d2d9dd77291511c1a5a3bbe7008f4a76d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Writer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Writer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d0b59a3f7afdfb200daf7c7684da04108a0ed23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XAConnection&lt;/code&gt; interface is derived from the &lt;code&gt;PooledConnection&lt;/code&gt; interface, so what applies to a pooled connection also applies to a connection that is part of a distributed transaction. A transaction manager in the middle tier handles everything transparently. The only change in application code is that an application cannot do anything that would interfere with the transaction manager's handling of the transaction. Specifically, an application cannot call the methods &lt;code&gt;Connection.commit&lt;/code&gt; or &lt;code&gt;Connection.rollback&lt;/code&gt;, and it cannot set the connection to be in auto-commit mode (that is, it cannot call &lt;code&gt;Connection.setAutoCommit(true)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;XAConnection&lt;/code&gt; 의 인터페이스는에서 파생 &lt;code&gt;PooledConnection&lt;/code&gt; 풀 된 접속에 적용 것 또한 분산 트랜잭션의 일부인 연결에 적용 있도록 인터페이스를 제공합니다. 중간 계층의 트랜잭션 관리자는 모든 것을 투명하게 처리합니다. 응용 프로그램 코드의 유일한 변경 사항은 응용 프로그램이 트랜잭션 관리자의 트랜잭션 처리를 방해하는 작업을 수행 할 수 없다는 것입니다. 특히 애플리케이션은 &lt;code&gt;Connection.commit&lt;/code&gt; 또는 &lt;code&gt;Connection.rollback&lt;/code&gt; 메서드를 호출 할 수 없으며 연결을 자동 커밋 모드로 설정할 수 없습니다 (즉, &lt;code&gt;Connection.setAutoCommit(true)&lt;/code&gt; 호출 할 수 없음 ).</target>
        </trans-unit>
        <trans-unit id="2fdc5e90dac380c583a94ac10964401cbc1bff2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XMLDecoder&lt;/code&gt; class is used to read XML documents created using the &lt;code&gt;XMLEncoder&lt;/code&gt; and is used just like the &lt;code&gt;ObjectInputStream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XMLDecoder&lt;/code&gt; 의 클래스는 사용하여 만든 XML 문서를 읽는 데 사용되는 &lt;code&gt;XMLEncoder&lt;/code&gt; 그냥 같이 사용 &lt;code&gt;ObjectInputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c73680d790e9f555b97eb4fbffb24cd26c3ccca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XMLDecoder&lt;/code&gt; class is used to read XML documents created using the &lt;code&gt;XMLEncoder&lt;/code&gt; and is used just like the &lt;code&gt;ObjectInputStream&lt;/code&gt;. For example, one can use the following fragment to read the first object defined in an XML document written by the &lt;code&gt;XMLEncoder&lt;/code&gt; class:</source>
          <target state="translated">&lt;code&gt;XMLDecoder&lt;/code&gt; 의 클래스는 사용하여 만든 XML 문서를 읽는 데 사용되는 &lt;code&gt;XMLEncoder&lt;/code&gt; 그냥 같이 사용 &lt;code&gt;ObjectInputStream&lt;/code&gt; . 예를 들어, 다음 조각을 사용하여 &lt;code&gt;XMLEncoder&lt;/code&gt; 클래스가 작성한 XML 문서에 정의 된 첫 번째 오브젝트를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b40fba744abf8f8cdfdbf7823211e024611a2005" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XMLEncoder&lt;/code&gt; class is a complementary alternative to the &lt;code&gt;ObjectOutputStream&lt;/code&gt; and can used to generate a textual representation of a &lt;em&gt;JavaBean&lt;/em&gt; in the same way that the &lt;code&gt;ObjectOutputStream&lt;/code&gt; can be used to create binary representation of &lt;code&gt;Serializable&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;XMLEncoder&lt;/code&gt; 클래스에 상보 대안 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 로 와의 텍스트 표현을 생성하기 위해 사용될 수 &lt;em&gt;자바빈&lt;/em&gt; 것과 같은 방식 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 로는 이진 표현을 생성하는데 사용될 수있다 &lt;code&gt;Serializable&lt;/code&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="bc93ab4e94e8fd32e113d65a55be49ef42b7d783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XMLEncoder&lt;/code&gt; class is a complementary alternative to the &lt;code&gt;ObjectOutputStream&lt;/code&gt; and can used to generate a textual representation of a &lt;em&gt;JavaBean&lt;/em&gt; in the same way that the &lt;code&gt;ObjectOutputStream&lt;/code&gt; can be used to create binary representation of &lt;code&gt;Serializable&lt;/code&gt; objects. For example, the following fragment can be used to create a textual representation the supplied &lt;em&gt;JavaBean&lt;/em&gt; and all its properties:</source>
          <target state="translated">&lt;code&gt;XMLEncoder&lt;/code&gt; 클래스에 상보 대안 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 로 와의 텍스트 표현을 생성하기 위해 사용될 수 &lt;em&gt;자바빈&lt;/em&gt; 것과 같은 방식 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 로는 이진 표현을 생성하는데 사용될 수있다 &lt;code&gt;Serializable&lt;/code&gt; 개체. 예를 들어, 다음 조각을 사용하여 제공된 &lt;em&gt;JavaBean&lt;/em&gt; 및 모든 해당 특성 의 텍스트 표현을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="baee72131905882a77a0b4ca9b76ace184c77c99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XMLEncoder&lt;/code&gt; class provides a default denotation for &lt;em&gt;JavaBean&lt;/em&gt;s in which they are represented as XML documents complying with version 1.0 of the XML specification and the UTF-8 character encoding of the Unicode/ISO 10646 character set. The XML documents produced by the &lt;code&gt;XMLEncoder&lt;/code&gt; class are:</source>
          <target state="translated">&lt;code&gt;XMLEncoder&lt;/code&gt; 클래스에 대한 기본 명시 적 의미합니다 &lt;em&gt;자바 빈즈&lt;/em&gt; 의 그들이 XML 사양 및 유니 코드 / ISO 10646 문자 세트의 UTF-8 문자 인코딩의 버전 1.0을 준수하는 XML 문서로 표현되는합니다. &lt;code&gt;XMLEncoder&lt;/code&gt; 클래스에 의해 생성 된 XML 문서 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="773745b0980b73ae3cf7133fbf0740a9e51a6976" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XMLStreamReader&lt;/code&gt; or &lt;code&gt;XMLEventReader&lt;/code&gt; used to construct this &lt;code&gt;StAXSource&lt;/code&gt; is queried to determine the system identifier of the XML source.</source>
          <target state="translated">&lt;code&gt;XMLStreamReader&lt;/code&gt; 또는 &lt;code&gt;XMLEventReader&lt;/code&gt; 의 이 구성하는데 사용 &lt;code&gt;StAXSource&lt;/code&gt; 의은 XML 소스의 시스템 식별자를 결정하기 위해 조회된다.</target>
        </trans-unit>
        <trans-unit id="5e8ba5718ccb5dddefc8fcb9ef5b222f271f2b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XPathEvaluationResult&lt;/code&gt; interface represents the result of the evaluation of an XPath expression within the context of a particular node.</source>
          <target state="translated">&lt;code&gt;XPathEvaluationResult&lt;/code&gt; 의 인터페이스는 특정 노드의 문맥 내의 XPath 식의 평가 결과를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="7979524a823b2b3c2152adeae36a863101800820" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XPathEvaluationResult&lt;/code&gt; interface represents the result of the evaluation of an XPath expression within the context of a particular node. The evaluation of an XPath expression can result in various result types as defined in XML Path Language (XPath) Version 1.0.</source>
          <target state="translated">&lt;code&gt;XPathEvaluationResult&lt;/code&gt; 의 인터페이스는 특정 노드의 문맥 내의 XPath 식의 평가 결과를 나타낸다. XPath 표현식을 평가하면 XPath (XML Path Language) 버전 1.0에 정의 된 다양한 결과 유형이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="864adcf3b012bbba70056106a86d52bf42863eff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XPathFactory&lt;/code&gt; builtin system-default implementation is only required to support the &lt;a href=&quot;#DEFAULT_OBJECT_MODEL_URI&quot;&gt;&lt;code&gt;default object model&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;../../../org/w3c/dom/package-summary&quot;&gt;W3C DOM&lt;/a&gt;, but may support additional object models.</source>
          <target state="translated">&lt;code&gt;XPathFactory&lt;/code&gt; 를 내장 시스템 디폴트의 구현 만 지원하는 데 필요한 &lt;a href=&quot;#DEFAULT_OBJECT_MODEL_URI&quot;&gt; &lt;code&gt;default object model&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../../../org/w3c/dom/package-summary&quot;&gt;W3C DOM을&lt;/a&gt; 하지만, 추가적인 객체 모델을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1579758fa332f4ff09bb6a3a0a884344e634c7db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XPathVariableResolver&lt;/code&gt; and the XPath evaluator must adhere to a contract that cannot be directly enforced by the API. Although variables may be mutable, that is, an application may wish to evaluate the same XPath expression more than once with different variable values, in the course of evaluating any single XPath expression, a variable's value &lt;strong&gt;&lt;em&gt;must&lt;/em&gt;&lt;/strong&gt; not change.</source>
          <target state="translated">&lt;code&gt;XPathVariableResolver&lt;/code&gt; 에 와의 XPath 평가자는 직접 API에 의해 강제 될 수없는 계약을 준수해야합니다. 변수는 변경할 수 있지만, 즉, 응용 프로그램이 단일 XPath 식을 평가하는 과정에서 다른 변수의 값을 두 번 이상 같은 XPath 식을 평가하실 수 있습니다 변수의 값이 &lt;strong&gt;&lt;em&gt;있어야&lt;/em&gt;&lt;/strong&gt; 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc6626b4ce56edf5eec0e4e7f1f6d83d431a9d81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[ ]&lt;/code&gt; characters are a</source>
          <target state="translated">&lt;code&gt;[ ]&lt;/code&gt; 문자가됩니다</target>
        </trans-unit>
        <trans-unit id="a2448ee443a37bfe2270b1cc58275c79e860c644" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aCommand&lt;/code&gt; will be set in the delivered event if specified.</source>
          <target state="translated">&lt;code&gt;aCommand&lt;/code&gt; 이 지정된 경우 전달 된 경우에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7c55d0ff61eb4e937c515821a0807c8069fecf30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aCondition&lt;/code&gt; can be one of:</source>
          <target state="translated">&lt;code&gt;aCondition&lt;/code&gt; 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cbec44aca0eff7c0fd9d646cfb96819a5b4c572f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accumulator&lt;/code&gt; function must be an &lt;a href=&quot;package-summary#Associativity&quot;&gt;associative&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;accumulator&lt;/code&gt; 함수가 있어야 &lt;a href=&quot;package-summary#Associativity&quot;&gt;연관&lt;/a&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="4185fd67e39e58987d681ed4e049cb9068cef055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;action&lt;/code&gt; argument is of the same format as the &lt;code&gt;eventPropertyName&lt;/code&gt; argument where the last property name identifies either a method name or writable property.</source>
          <target state="translated">&lt;code&gt;action&lt;/code&gt; 인자들은 동일 형식이다 &lt;code&gt;eventPropertyName&lt;/code&gt; 를의 인수 여기서 마지막 속성 이름을 식별하는 방법 이름 또는 속성 중 쓰기.</target>
        </trans-unit>
        <trans-unit id="31404f4484a67d5901851525c58dad6c4c563d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;agentmain&lt;/code&gt; method has one of two possible signatures. The JVM first attempts to invoke the following method on the agent class:</source>
          <target state="translated">&lt;code&gt;agentmain&lt;/code&gt; 의 방법은 두 가지 중 하나의 서명이있다. JVM은 먼저 에이전트 클래스에서 다음 메소드를 호출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="cc78d234a40aa6ddd38f2300973ad58dbc9f2403" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;agentmain&lt;/code&gt; method should do any necessary initialization required to start the agent and return. If the agent cannot be started, for example the agent class cannot be loaded, the agent class does not define a conformant &lt;code&gt;agentmain&lt;/code&gt; method, or the &lt;code&gt;agentmain&lt;/code&gt; method throws an uncaught exception or error, the JVM will abort.</source>
          <target state="translated">&lt;code&gt;agentmain&lt;/code&gt; 의 방법은 에이전트와 반환을 시작하는 데 필요한 필요한 초기화를해야한다. 에이전트를 시작할 수없는 경우 (예 : 에이전트 클래스를로드 할 수 없거나 에이전트 클래스가 준수 &lt;code&gt;agentmain&lt;/code&gt; 메서드를 정의하지 않거나 &lt;code&gt;agentmain&lt;/code&gt; 메서드가 포착되지 않은 예외 또는 오류를 발생시키는 경우) JVM이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="e39ec8f12fac3e1235b57830cba8b781dedf715e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;agentmain&lt;/code&gt; method should do any necessary initialization required to start the agent. When startup is complete the method should return. If the agent cannot be started (for example, because the agent class cannot be loaded, or because the agent class does not have a conformant &lt;code&gt;agentmain&lt;/code&gt; method), the JVM will not abort. If the &lt;code&gt;agentmain&lt;/code&gt; method throws an uncaught exception it will be ignored (but may be logged by the JVM for troubleshooting purposes).</source>
          <target state="translated">&lt;code&gt;agentmain&lt;/code&gt; 의 방법은 에이전트를 시작하는 데 필요한 필요한 초기화를해야한다. 시작이 완료되면 메서드가 반환되어야합니다. 에이전트를 시작할 수없는 경우 (예 : 에이전트 클래스를로드 할 수 없거나 에이전트 클래스에 적합한 &lt;code&gt;agentmain&lt;/code&gt; 메서드 가 없기 때문에 ) JVM이 중단되지 않습니다. 는 IF &lt;code&gt;agentmain&lt;/code&gt; 메소드가 캐치되지 않는 예외를 throw는 무시됩니다 (그러나 문제 해결을 목적으로 JVM에 의해 기록 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="4200792e507990527888853e33e39555b27217a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attribute&lt;/code&gt; parameter identifies the attribute to be read and takes the form:</source>
          <target state="translated">&lt;code&gt;attribute&lt;/code&gt; 매개 변수를 식별 속성 읽고 형식을 취한다 :</target>
        </trans-unit>
        <trans-unit id="e13622be0932a01b09ea0231195ad9dee2d891a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attribute&lt;/code&gt; parameter identifies the attribute to be set and takes the form:</source>
          <target state="translated">&lt;code&gt;attribute&lt;/code&gt; 파라미터를 식별하는 속성을 설정 및 형태를 취한다 :</target>
        </trans-unit>
        <trans-unit id="9300dec972e233c14dfee6f24a1437eb62d16c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attributes&lt;/code&gt; parameter identifies the attributes to be read and takes the form:</source>
          <target state="translated">는 &lt;code&gt;attributes&lt;/code&gt; 의 속성을 읽을 수 있도록 매개 변수를 식별 및 형태를 취한다 :</target>
        </trans-unit>
        <trans-unit id="e891f2a34d3ff9a18061c78c854c7a39d310fd9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attributes&lt;/code&gt;&lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal. This is: they are both &lt;code&gt;null&lt;/code&gt;, or they have the same length and for each node that exists in one map there is a node that exists in the other map and is equal, although not necessarily at the same index.</source>
          <target state="translated">&lt;code&gt;attributes&lt;/code&gt; &lt;code&gt;NamedNodeMaps&lt;/code&gt; 은 동일하다. 이것은 둘 다 &lt;code&gt;null&lt;/code&gt; 이거나 길이가 같고 한 맵에 존재하는 각 노드에 대해 반드시 동일한 인덱스에있는 것은 아니지만 다른 맵에 존재하고 동일한 노드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ec10680a515404dcea83dc93b34a00ae544957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is an optional array of file &lt;a href=&quot;../file/attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the file.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 파일의 선택적인 배열 매개 변수 &lt;a href=&quot;../file/attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 파일을 만들 때 원자 적으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="aa73d718a6e84fdffc4666766b8c6f4155f86290" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the link. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 매개 변수는 선택 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;attributes&lt;/code&gt; &lt;/a&gt; 링크를 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 발생을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5d11588e62ee6ecee510a144a13ae053b7ded0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the link. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 매개 변수는 선택 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;attributes&lt;/code&gt; &lt;/a&gt; 링크를 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 항목을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9611129a94268b694e7f0a6870f3b072a950a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when a new file is created.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 새 파일이 생성 될 때 원자 적으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9a59843ac8ffdbb8b27a7af904c73b09addfd665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the directory. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 디렉터리를 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 발생을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1530cb7be2e1a90d2e32e41b80f5181fbd3c409a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the directory. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 디렉터리를 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 항목을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a2eafb0f18e2c0f90cfaa47597137720724d74ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the file. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 파일을 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 발생을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="09484803eed7eb220bb9cee3c89264c72f6e5064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the file. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored. When no file attributes are specified, then the resulting file may have more restrictive access permissions to files created by the &lt;a href=&quot;../../io/file#createTempFile(java.lang.String,java.lang.String,java.io.File)&quot;&gt;&lt;code&gt;File.createTempFile(String,String,File)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 파일을 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 발생을 제외한 모든 속성이 무시됩니다. 파일 속성이 지정되지 않은 경우 결과 파일은 &lt;a href=&quot;../../io/file#createTempFile(java.lang.String,java.lang.String,java.io.File)&quot;&gt; &lt;code&gt;File.createTempFile(String,String,File)&lt;/code&gt; &lt;/a&gt; 메서드로 생성 된 파일에 대해 더 제한적인 액세스 권한을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad9b07c9e2205e3502079d33de386fcf7c13ff4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the file. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 파일을 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 항목을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3d4f30d19e092c8b774921588c985e988e8af3fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the file. Each attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored. When no file attributes are specified, then the resulting file may have more restrictive access permissions to files created by the &lt;a href=&quot;../../io/file#createTempFile-java.lang.String-java.lang.String-java.io.File-&quot;&gt;&lt;code&gt;File.createTempFile(String,String,File)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 파일을 만들 때 원자 적으로 설정합니다. 각 속성은 &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 항목을 제외한 모든 속성이 무시됩니다. 파일 속성을 지정하지 않으면 결과 파일에 &lt;a href=&quot;../../io/file#createTempFile-java.lang.String-java.lang.String-java.io.File-&quot;&gt; &lt;code&gt;File.createTempFile(String,String,File)&lt;/code&gt; &lt;/a&gt; 메소드로 작성된 파일에 대한 액세스가 더 제한적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b269fdea6c6d809695550b9428ade177ba1ea0ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the nonexistent directories. Each file attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 존재하지 않는 디렉토리를 만들 때 원자 적으로 설정합니다. 각 파일 속성은 &lt;a href=&quot;attribute/fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 발생을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eac58af08c25e30b8096bbec06d65d5969d2351b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; parameter is optional &lt;a href=&quot;attribute/fileattribute&quot;&gt;&lt;code&gt;file-attributes&lt;/code&gt;&lt;/a&gt; to set atomically when creating the nonexistent directories. Each file attribute is identified by its &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 에 선택적 매개 변수 &lt;a href=&quot;attribute/fileattribute&quot;&gt; &lt;code&gt;file-attributes&lt;/code&gt; &lt;/a&gt; 존재하지 않는 디렉토리를 만들 때 원자 적으로 설정합니다. 각 파일 속성은 &lt;a href=&quot;attribute/fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 동일한 이름의 속성이 둘 이상 배열에 포함 된 경우 마지막 항목을 제외한 모든 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9310f8ddf2f2e1abe2704763c0d8698944c86a52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;available&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt; always returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;available&lt;/code&gt; 클래스에 대한 방법 &lt;code&gt;InputStream&lt;/code&gt; 항상 반환 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07e935be2d00da600d82b1459bdd0645c167a8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;available&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; always returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 의 &lt;code&gt;available&lt;/code&gt; 메서드는 항상 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2a223f99a73adb8d4155acdcdbe953d90137df1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;available&lt;/code&gt; method of the underlying stream returns zero, indicating that further input requests would block.</source>
          <target state="translated">기본 스트림 의 &lt;code&gt;available&lt;/code&gt; 메소드는 추가 입력 요청이 차단됨을 나타내는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c19d6f589a03480c7507cbcf9ea41e93f9410bd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같은 경우, 구현 고유의 디폴트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="29ad9363012d93283f3d04ff689ea4b529ac1006" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;backlog&lt;/code&gt; argument must be a positive value greater than 0. If the value passed if equal or less than 0, then the default value will be assumed.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; 값이 같거나 0보다 작은 경우, 디폴트 값이 가정 될 경우 전달 된 경우 인수는 0보다 큰 양의 값이 커야합니다.</target>
        </trans-unit>
        <trans-unit id="b04fd34021527ffa6eec03ad117996148e622e5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;backlog&lt;/code&gt; parameter is the maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. If the &lt;code&gt;backlog&lt;/code&gt; parameter has the value &lt;code&gt;0&lt;/code&gt;, or a negative value, then an implementation specific default is used.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; 매개 변수는 소켓에 대기중인 연결의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. 경우] &lt;code&gt;backlog&lt;/code&gt; 파라미터 값을 가지고 &lt;code&gt;0&lt;/code&gt; 또는 음의 값을 다음의 특정 구현 기본값을 사용한다.</target>
        </trans-unit>
        <trans-unit id="9758dfb7f206fee802af2ff421e244af4ed6b224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;beginIndex&lt;/code&gt; and &lt;code&gt;endIndex&lt;/code&gt; parameters specify the subsequence of name elements. The name that is &lt;em&gt;closest&lt;/em&gt; to the root in the directory hierarchy has index &lt;code&gt;0&lt;/code&gt;. The name that is &lt;em&gt;farthest&lt;/em&gt; from the root has index &lt;a href=&quot;#getNameCount()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-1&lt;/code&gt;. The returned &lt;code&gt;Path&lt;/code&gt; object has the name elements that begin at &lt;code&gt;beginIndex&lt;/code&gt; and extend to the element at index &lt;code&gt;
 endIndex-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;beginIndex&lt;/code&gt; 의 및 &lt;code&gt;endIndex&lt;/code&gt; 에 매개 변수 이름 요소의 서브 순서를 지정합니다. 디렉토리 계층 구조에서 루트에 &lt;em&gt;가장 가까운&lt;/em&gt; 이름 에는 인덱스 &lt;code&gt;0&lt;/code&gt; 이 있습니다. 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 이름의 인덱스 &lt;a href=&quot;#getNameCount()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-1&lt;/code&gt; 입니다. 반환 된 &lt;code&gt;Path&lt;/code&gt; 객체에는 &lt;code&gt;beginIndex&lt;/code&gt; 에서 시작하여 &lt;code&gt; endIndex-1&lt;/code&gt; 인덱스의 요소까지 확장 되는 이름 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="038e82ed2e83821157222aec4b1425ddc2acdb2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;beginIndex&lt;/code&gt; and &lt;code&gt;endIndex&lt;/code&gt; parameters specify the subsequence of name elements. The name that is &lt;em&gt;closest&lt;/em&gt; to the root in the directory hierarchy has index &lt;code&gt;0&lt;/code&gt;. The name that is &lt;em&gt;farthest&lt;/em&gt; from the root has index &lt;a href=&quot;path#getNameCount--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-1&lt;/code&gt;. The returned &lt;code&gt;Path&lt;/code&gt; object has the name elements that begin at &lt;code&gt;beginIndex&lt;/code&gt; and extend to the element at index &lt;code&gt;endIndex-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;beginIndex&lt;/code&gt; 의 및 &lt;code&gt;endIndex&lt;/code&gt; 에 매개 변수 이름 요소의 서브 순서를 지정합니다. 디렉토리 계층에서 루트에 &lt;em&gt;가장 가까운&lt;/em&gt; 이름 은 인덱스 &lt;code&gt;0&lt;/code&gt; 입니다. 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 이름 은 인덱스 &lt;a href=&quot;path#getNameCount--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-1&lt;/code&gt; 입니다. 반환 된 &lt;code&gt;Path&lt;/code&gt; 객체는 &lt;code&gt;beginIndex&lt;/code&gt; 에서 시작하고 &lt;code&gt;endIndex-1&lt;/code&gt; 인덱스의 요소로 확장 되는 이름 요소를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="23cf20e6e7ba36d73ecb53fccee07162da8d920d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;body&lt;/code&gt; handle must not be &lt;code&gt;null&lt;/code&gt;; its type must be of the form &lt;code&gt;(V A...)V&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is non-&lt;code&gt;void&lt;/code&gt;, or else &lt;code&gt;(A...)void&lt;/code&gt;. (In the &lt;code&gt;void&lt;/code&gt; case, we assign the type &lt;code&gt;void&lt;/code&gt; to the name &lt;code&gt;V&lt;/code&gt;, and we will write &lt;code&gt;(V A...)V&lt;/code&gt; with the understanding that a &lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt; is quietly dropped from the parameter list, leaving &lt;code&gt;(A...)V&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 핸들이 아니어야 &lt;code&gt;null&lt;/code&gt; ; 유형은 &lt;code&gt;(V A...)V&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 아니거나 &lt;code&gt;(A...)void&lt;/code&gt; 입니다. 합니다 (에서 &lt;code&gt;void&lt;/code&gt; 의 경우, 우리는 형식 지정 &lt;code&gt;void&lt;/code&gt; 이름으로 &lt;code&gt;V&lt;/code&gt; 를 , 우리는 쓸 것 &lt;code&gt;(V A...)V&lt;/code&gt; 것을 이해 &lt;code&gt;void&lt;/code&gt; 형 &lt;code&gt;V&lt;/code&gt; 가 조용히 떠나, 매개 변수 목록에서 삭제 &lt;code&gt;(A...)V&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="87c334e233d7c15dbce8f02769f49f0543984685" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;body&lt;/code&gt; handle must not be &lt;code&gt;null&lt;/code&gt;; its type must be of the form &lt;code&gt;(V I A...)V&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is non-&lt;code&gt;void&lt;/code&gt;, or else &lt;code&gt;(I A...)void&lt;/code&gt;. (In the &lt;code&gt;void&lt;/code&gt; case, we assign the type &lt;code&gt;void&lt;/code&gt; to the name &lt;code&gt;V&lt;/code&gt;, and we will write &lt;code&gt;(V I A...)V&lt;/code&gt; with the understanding that a &lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt; is quietly dropped from the parameter list, leaving &lt;code&gt;(I A...)V&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 핸들이 아니어야 &lt;code&gt;null&lt;/code&gt; ; 유형은 &lt;code&gt;(V I A...)V&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 아니거나 &lt;code&gt;(I A...)void&lt;/code&gt; 입니다. 합니다 (에서 &lt;code&gt;void&lt;/code&gt; 의 경우, 우리는 형식 지정 &lt;code&gt;void&lt;/code&gt; 이름으로 &lt;code&gt;V&lt;/code&gt; 를 , 우리는 쓸 것 &lt;code&gt;(V I A...)V&lt;/code&gt; 것을 이해 &lt;code&gt;void&lt;/code&gt; 형 &lt;code&gt;V&lt;/code&gt; 가 조용히 떠나 매개 변수 목록에서 삭제 &lt;code&gt;(I A...)V&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1e3ecb1f1c113d7459558edaafd1c22e159c798c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;body&lt;/code&gt; handle must not be &lt;code&gt;null&lt;/code&gt;; its type must be of the form &lt;code&gt;(V T A...)V&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is non-&lt;code&gt;void&lt;/code&gt;, or else &lt;code&gt;(T A...)void&lt;/code&gt;. (In the &lt;code&gt;void&lt;/code&gt; case, we assign the type &lt;code&gt;void&lt;/code&gt; to the name &lt;code&gt;V&lt;/code&gt;, and we will write &lt;code&gt;(V T A...)V&lt;/code&gt; with the understanding that a &lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt; is quietly dropped from the parameter list, leaving &lt;code&gt;(T A...)V&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 핸들이 아니어야 &lt;code&gt;null&lt;/code&gt; ; 형식은 &lt;code&gt;(V T A...)V&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 아니거나 &lt;code&gt;(T A...)void&lt;/code&gt; 입니다. (에서 &lt;code&gt;void&lt;/code&gt; 의 경우, 우리는 형식 지정 &lt;code&gt;void&lt;/code&gt; 이름으로 &lt;code&gt;V&lt;/code&gt; 를 , 우리는 쓸 것 &lt;code&gt;(V T A...)V&lt;/code&gt; 것을 이해 &lt;code&gt;void&lt;/code&gt; 형 &lt;code&gt;V&lt;/code&gt; 가 조용히 떠나 매개 변수 목록에서 삭제 &lt;code&gt;(T A...)V&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2607bcf7e52a949a9098498708e7ed0874e36f9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; parameter is the class bytes of a valid class file (as defined by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the same package as the lookup class.</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; 매개 변수 (에 의해 정의 된 클래스가 유효한 클래스 파일의 바이트 &lt;em&gt;Java 가상 머신 사양&lt;/em&gt; 조회 클래스와 같은 패키지에 클래스 이름).</target>
        </trans-unit>
        <trans-unit id="ce830a6dc99fa048ff691c489beb4b6f9e5a2ab8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;caller&lt;/code&gt; parameter must be a &lt;code&gt;WebRowSet&lt;/code&gt; object whose &lt;code&gt;XmlWriter&lt;/code&gt; field contains a reference to this &lt;code&gt;XmlWriter&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;caller&lt;/code&gt; 파라미터는 여야 &lt;code&gt;WebRowSet&lt;/code&gt; 그 목적 &lt;code&gt;XmlWriter&lt;/code&gt; 를 필드이 참조 포함 &lt;code&gt;XmlWriter&lt;/code&gt; 를의 개체.</target>
        </trans-unit>
        <trans-unit id="549d3c0cc45d126bfe6b339f4e7d396df73338b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cause&lt;/code&gt; is not initialized.</source>
          <target state="translated">&lt;code&gt;cause&lt;/code&gt; 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0fdf3dc80a013dc8c4afe2a38389db91bc45e47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cert.provider.x509v1&lt;/code&gt; property is set to a default implementation for X.509 such as:</source>
          <target state="translated">&lt;code&gt;cert.provider.x509v1&lt;/code&gt; 속성은 X.509 등의 기본 구현으로 설정됩니다 :</target>
        </trans-unit>
        <trans-unit id="51472b90fccbf1d42ba6001caf6f52c8f72d01a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;changeFlags&lt;/code&gt; parameter of any &lt;code&gt;HierarchyEvent&lt;/code&gt; instance takes one of the following values:</source>
          <target state="translated">&lt;code&gt;HierarchyEvent&lt;/code&gt; 인스턴스 의 &lt;code&gt;changeFlags&lt;/code&gt; 매개 변수 는 다음 값 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7e2379eb6107205000a967e604f084a77bb6b353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;changeListener&lt;/code&gt; is the listener we add to the model.</source>
          <target state="translated">&lt;code&gt;changeListener&lt;/code&gt; 입니다은 우리가 모델에 추가하는 청취자입니다.</target>
        </trans-unit>
        <trans-unit id="312b7fe1366e0a3c03057bcb7caeef6dc182a366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; data type (and therefore the value that a &lt;code&gt;Character&lt;/code&gt; object encapsulates) are based on the original Unicode specification, which defined characters as fixed-width 16-bit entities. The Unicode Standard has since been changed to allow for characters whose representation requires more than 16 bits. The range of legal &lt;em&gt;code point&lt;/em&gt;s is now U+0000 to U+10FFFF, known as &lt;em&gt;Unicode scalar value&lt;/em&gt;. (Refer to the &lt;a href=&quot;http://www.unicode.org/reports/tr27/#notation&quot;&gt;&lt;i&gt; definition&lt;/i&gt;&lt;/a&gt; of the U+</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 데이터 유형 (및 따라서 것을 값 &lt;code&gt;Character&lt;/code&gt; 오브젝트 캡슐화)이 고정 폭 16 비트 엔티티와 같은 문자를 정의 일본어 유니 코드 규격에 기초한다. 16 비트보다 많은 표현이 필요한 문자를 허용하도록 유니 코드 표준이 변경되었습니다. 유효한 &lt;em&gt;코드 포인트&lt;/em&gt; 의 범위 는 이제 &lt;em&gt;유니 코드 스칼라 값으로&lt;/em&gt; 알려진 U + 0000 ~ U + 10FFFF 입니다. ( U + 의 &lt;a href=&quot;http://www.unicode.org/reports/tr27/#notation&quot;&gt;&lt;i&gt;정의&lt;/i&gt;&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="159881b528b95151218ddcf06070876dc2535a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checkAccess&lt;/code&gt; method of the parent thread group is called with no arguments; this may result in a security exception.</source>
          <target state="translated">부모 스레드 그룹 의 &lt;code&gt;checkAccess&lt;/code&gt; 메소드는 인수없이 호출됩니다. 보안 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98813f94bb2ecfd8b901aa13def3a342737037f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checkImage&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; calls its peer's &lt;code&gt;checkImage&lt;/code&gt; method to calculate the flags. If this component does not yet have a peer, the component's toolkit's &lt;code&gt;checkImage&lt;/code&gt; method is called instead.</source>
          <target state="translated">그만큼 &lt;code&gt;checkImage&lt;/code&gt; &lt;code&gt;Component&lt;/code&gt; checkImage 메소드는 해당 피어의 &lt;code&gt;checkImage&lt;/code&gt; 메소드를 호출 하여 플래그를 계산합니다. 이 구성 요소에 아직 피어가 &lt;code&gt;checkImage&lt;/code&gt; 구성 요소의 도구 키트의 checkImage 메서드가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e8a72d273e2359cf1503e1f34724cc9c2dc1f67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checkPermission&lt;/code&gt; method that takes a context object in addition to a permission makes access decisions based on that context, rather than on that of the current execution thread. Code within a different context can thus call that method, passing the permission and the previously-saved context object. A sample call, using the SecurityManager &lt;code&gt;sm&lt;/code&gt; obtained as in the previous example, is the following:</source>
          <target state="translated">&lt;code&gt;checkPermission&lt;/code&gt; 권한 이외에 컨텍스트 오브젝트를 사용 방법은 오히려 현재 실행 스레드의보다 그 문맥에 따라 액세스를 판정합니다. 따라서 다른 컨텍스트 내의 코드는 해당 메서드를 호출하여 권한과 이전에 저장된 컨텍스트 개체를 전달할 수 있습니다. 이전 예제에서 얻은 SecurityManager &lt;code&gt;sm&lt;/code&gt; 을 사용한 샘플 호출 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc365efffcfa5fe96ee6d3621be5f1681a395b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;childNodes&lt;/code&gt;&lt;code&gt;NodeLists&lt;/code&gt; are equal. This is: they are both &lt;code&gt;null&lt;/code&gt;, or they have the same length and contain equal nodes at the same index. Note that normalization can affect equality; to avoid this, nodes should be normalized before being compared.</source>
          <target state="translated">&lt;code&gt;childNodes&lt;/code&gt; 에 &lt;code&gt;NodeLists&lt;/code&gt; 는 동일하다. 이것은 둘 다 &lt;code&gt;null&lt;/code&gt; 이거나 길이가 같고 동일한 인덱스에 동일한 노드를 포함합니다. 정규화는 동등성에 영향을 미칠 수 있습니다. 이를 방지하려면 비교하기 전에 노드를 정규화해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a5d909660d723c346a03d0f41bd75687e11de0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; handle will be passed one or two additional leading arguments. The first is the exception thrown during the execution of the &lt;code&gt;target&lt;/code&gt; handle, or &lt;code&gt;null&lt;/code&gt; if no exception was thrown. The second is the result of the execution of the &lt;code&gt;target&lt;/code&gt; handle, or, if it throws an exception, a &lt;code&gt;null&lt;/code&gt;, zero, or &lt;code&gt;false&lt;/code&gt; value of the required type is supplied as a placeholder. The second argument is not present if the &lt;code&gt;target&lt;/code&gt; handle has a &lt;code&gt;void&lt;/code&gt; return type. (Note that, except for argument type conversions, combinators represent &lt;code&gt;void&lt;/code&gt; values in parameter lists by omitting the corresponding paradoxical arguments, not by inserting &lt;code&gt;null&lt;/code&gt; or zero values.)</source>
          <target state="translated">&lt;code&gt;cleanup&lt;/code&gt; 핸들은 하나 개 또는 두 개의 추가 주요 인수를 전달됩니다. 첫 번째는 &lt;code&gt;target&lt;/code&gt; 핸들을 실행하는 동안 발생한 예외 이거나 예외가 발생하지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다. 두 번째는 &lt;code&gt;target&lt;/code&gt; 핸들 의 실행 결과 이거나 예외가 발생하는 경우 &lt;code&gt;null&lt;/code&gt; , 0 또는 &lt;code&gt;false&lt;/code&gt; 경우 필요한 유형 false 값이 자리 표시 자로 제공됩니다. &lt;code&gt;target&lt;/code&gt; 핸들에 &lt;code&gt;void&lt;/code&gt; 반환 유형 이있는 경우 두 번째 인수는 존재하지 않습니다 . (인수 유형 변환을 제외하고 결합자는 &lt;code&gt;void&lt;/code&gt; 를 나타냅니다. 자는 해당 역설적 인수를 생략하여 매개 변수 목록의 값을 &lt;code&gt;null&lt;/code&gt; 또는 0 값.)</target>
        </trans-unit>
        <trans-unit id="8a37143162f383e40541a3c536a0bad8cdbdac3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clear&lt;/code&gt; method sets calendar field(s) undefined. &lt;code&gt;GregorianCalendar&lt;/code&gt; uses the following default value for each calendar field if its value is undefined.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; 방법 세트 달력 필드 (들) 정의되지 않은. &lt;code&gt;GregorianCalendar&lt;/code&gt; 는 값이 정의되지 않은 경우 각 달력 필드에 다음 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23c5d3ad8f50c87806bd51026f62bd3f83bef13e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clientProperty&lt;/code&gt; dictionary is not intended to support large scale extensions to JComponent nor should be it considered an alternative to subclassing when designing a new component.</source>
          <target state="translated">그만큼 &lt;code&gt;clientProperty&lt;/code&gt; 의의 사전 JComponent 에의 대규모 확장 기능을 지원하는 것은 아니다 않으며 새로운 구성 요소를 설계 할 때 서브 클래스에 대한 대안을 생각해야한다.</target>
        </trans-unit>
        <trans-unit id="eca26951481b1fa79d4de62013b67d4d4f363ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clockSequence&lt;/code&gt; value is only meaningful in a time-based UUID, which has version type 1. If this UUID is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">&lt;code&gt;clockSequence&lt;/code&gt; 의 값이 UUID 다음이 방법에 UnsupportedOperationException을 발생 시간 기반 UUID 없으면 버전 타입 1 시간 기반 UUID, 만 의미가있다.</target>
        </trans-unit>
        <trans-unit id="17c69f5047e8b8edc7675c7afa6d967e75c7e9a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;CipherInputStream&lt;/code&gt; calls the &lt;code&gt;close&lt;/code&gt; method of its underlying input stream.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; 방법 &lt;code&gt;CipherInputStream&lt;/code&gt; 를는 부르는 &lt;code&gt;close&lt;/code&gt; 는 기본 입력 스트림의 방법.</target>
        </trans-unit>
        <trans-unit id="8d16e59d74dedefbb9dca52dccbe54c8fd4fa9e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls its &lt;code&gt;flush&lt;/code&gt; method, and then calls the &lt;code&gt;close&lt;/code&gt; method of its underlying output stream.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; 방법 &lt;code&gt;FilterOutputStream&lt;/code&gt; 그 호출 &lt;code&gt;flush&lt;/code&gt; 메소드를 호출하고 &lt;code&gt;close&lt;/code&gt; 해당 기본 스트림의 출력 방법.</target>
        </trans-unit>
        <trans-unit id="7e09c5caa8f665f3b57f5f5f897465a41503642c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does nothing.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 의 &lt;code&gt;close&lt;/code&gt; 메소드 는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8a4c592a0ecb263805a474537d609748a764ffc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt; does nothing.</source>
          <target state="translated">&lt;code&gt;OutputStream&lt;/code&gt; 의 &lt;code&gt;close&lt;/code&gt; 메소드 는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2531be3b89a10105b22c29564d26639ca4a592a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; corresponds to a hex &lt;code&gt;String&lt;/code&gt; as understood by &lt;code&gt;Color.decode&lt;/code&gt;. For example, one of the &lt;code&gt;name-color&lt;/code&gt; pairs is &lt;code&gt;
 &quot;desktop&quot;-&quot;#005C5C&quot;&lt;/code&gt;. This corresponds to the &lt;code&gt;
 SystemColor&lt;/code&gt; field &lt;code&gt;desktop&lt;/code&gt;, with a color value of &lt;code&gt;new Color(0x005C5C)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;color&lt;/code&gt; 헥스에 해당 &lt;code&gt;String&lt;/code&gt; 에 의해 이해되는 &lt;code&gt;Color.decode&lt;/code&gt; . 예를 들어 &lt;code&gt;name-color&lt;/code&gt; 쌍 중 하나 는 &lt;code&gt; &quot;desktop&quot;-&quot;#005C5C&quot;&lt;/code&gt; 입니다. 이것은 &lt;code&gt; SystemColor&lt;/code&gt; 필드에 해당합니다. &lt;code&gt;desktop&lt;/code&gt; 색상 값이 &lt;code&gt;new Color(0x005C5C)&lt;/code&gt; desktop에 .</target>
        </trans-unit>
        <trans-unit id="272a141fe34e23fe1ed9cd1611d645995f50e5bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combine&lt;/code&gt; method investigates the two input arrays of ProtectionDomains and returns a single array containing the updated ProtectionDomains. In the simplest case, the &lt;code&gt;combine&lt;/code&gt; method merges the two stacks into one. In more complex cases, the &lt;code&gt;combine&lt;/code&gt; method returns a modified stack of ProtectionDomains. The modification may have added new ProtectionDomains, removed certain ProtectionDomains, or simply updated existing ProtectionDomains. Re-ordering and other optimizations to the ProtectionDomains are also permitted. Typically the &lt;code&gt;combine&lt;/code&gt; method bases its updates on the information encapsulated in the &lt;code&gt;DomainCombiner&lt;/code&gt;.</source>
          <target state="translated">은 &lt;code&gt;combine&lt;/code&gt; 방식 조사한다 ProtectionDomain는 두 입력 배열 및 업데이트 된 ProtectionDomain 함유 한 배열을 반환한다. 가장 간단한 경우, &lt;code&gt;combine&lt;/code&gt; 메소드는 두 스택을 하나로 병합합니다. 더 복잡한 경우, &lt;code&gt;combine&lt;/code&gt; 메서드는 수정 된 ProtectionDomain 스택을 반환합니다. 수정으로 새 ProtectionDomain이 추가되었거나 특정 ProtectionDomain이 제거되었거나 기존 ProtectionDomain이 단순히 업데이트되었을 수 있습니다. ProtectionDomain에 대한 재정렬 및 ​​기타 최적화도 허용됩니다. 일반적으로 &lt;code&gt;combine&lt;/code&gt; 메소드는 &lt;code&gt;DomainCombiner&lt;/code&gt; 에 캡슐화 된 정보를 기반으로 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="44c35d21bf67cf9c4f42525ec0fe6621b0e16aaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;command&lt;/code&gt; property may not be needed if the &lt;code&gt;RowSet&lt;/code&gt; object gets its data from a source that does not support commands, such as a spreadsheet or other tabular file. Thus, this property is optional and may be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">다음의 경우 &lt;code&gt;command&lt;/code&gt; 속성이 필요하지 않을 수 있습니다. &lt;code&gt;RowSet&lt;/code&gt; 객체가 같은 스프레드 시트 나 다른 테이블 형식의 파일로 명령을 지원하지 않는 소스로부터 데이터를 가져옵니다. 따라서이 속성은 선택 사항이며 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="928da17633454632f0bf287b021e570d64611c36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;completed&lt;/code&gt; argument to the &lt;a href=&quot;#end(boolean)&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; method tells whether or not the I/O operation actually completed, that is, whether it had any effect that would be visible to the invoker. In the case of an operation that reads bytes, for example, this argument should be &lt;code&gt;true&lt;/code&gt; if, and only if, some bytes were actually transferred into the invoker's target buffer.</source>
          <target state="translated">&lt;code&gt;completed&lt;/code&gt; 받는 인수 &lt;a href=&quot;#end(boolean)&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드에 는 I / O 작업이 실제로 완료되었는지 여부, 즉 호출자에게 표시되는 효과가 있는지 여부를 알려줍니다. 예를 들어 바이트를 읽는 작업의 경우이 인수는 일부 바이트가 실제로 호출자의 대상 버퍼로 전송 된 경우에만 &lt;code&gt;true&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7a90cfbc00ca33b6d145e6807e96aa2002b85303" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;completed&lt;/code&gt; argument to the &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; method tells whether or not the I/O operation actually completed, that is, whether it had any effect that would be visible to the invoker. In the case of an operation that reads bytes, for example, this argument should be &lt;code&gt;true&lt;/code&gt; if, and only if, some bytes were actually transferred into the invoker's target buffer.</source>
          <target state="translated">&lt;code&gt;completed&lt;/code&gt; 받는 인수 &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드는 호출자에게 표시하는 어떤 효과를 가지고 있는지 여부를 I / O 작업이 실제로, 즉, 완료 여부를 알려줍니다. 예를 들어, 바이트를 읽는 작업의 경우, 일부 바이트가 실제로 호출자의 대상 버퍼로 전송 된 경우에만 이 인수가 &lt;code&gt;true&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="a5d94cf564353166be1db9cb4e8271b8ded55663" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;components&lt;/code&gt; array.</source>
          <target state="translated">그만큼 &lt;code&gt;components&lt;/code&gt; 어레이.</target>
        </trans-unit>
        <trans-unit id="15e9d479711030667ddbf21dea87568e74553c2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contains&lt;/code&gt; and &lt;code&gt;intersects&lt;/code&gt; methods consider the interior of a &lt;code&gt;Shape&lt;/code&gt; to be the area it encloses as if it were filled. This means that these methods consider unclosed shapes to be implicitly closed for the purpose of determining if a shape contains or intersects a rectangle or if a shape contains a point.</source>
          <target state="translated">은 &lt;code&gt;contains&lt;/code&gt; 하고 &lt;code&gt;intersects&lt;/code&gt; 방법은 내부 고려 &lt;code&gt;Shape&lt;/code&gt; 그것을가 작성하는 것처럼 둘러싸는 영역이 될 수 있습니다. 즉, 이러한 메서드는 모양이 사각형을 포함하거나 교차하는지 또는 모양에 점이 포함되어 있는지 확인하기 위해 닫히지 않은 모양이 암시 적으로 닫힌 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="3114ba8be141b590dba202ffb1a396b416bb2f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contentPane&lt;/code&gt; fills the entire viewable area, minus the &lt;code&gt;menuBar&lt;/code&gt;, if present.</source>
          <target state="translated">&lt;code&gt;contentPane&lt;/code&gt; 전체 가시 영역을 채우고, 마이너스 &lt;code&gt;menuBar&lt;/code&gt; 존재하는 경우.</target>
        </trans-unit>
        <trans-unit id="f41c89acf8d6260cc4c3edf1c8a3be1a487a118d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;countMatches&lt;/code&gt; operation can be invoked as follows:</source>
          <target state="translated">&lt;code&gt;countMatches&lt;/code&gt; 의 다음과 같은 작업을 호출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="72616ce87a153d98c6a948602b30731bd218fc29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createMBeanServer&lt;/code&gt; permission implies the &lt;code&gt;newMBeanServer&lt;/code&gt; permission.</source>
          <target state="translated">&lt;code&gt;createMBeanServer&lt;/code&gt; 의 권한은 의미 &lt;code&gt;newMBeanServer&lt;/code&gt; 권한을.</target>
        </trans-unit>
        <trans-unit id="367254891eef16003973d17f79d44e07bdd79f5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;d.width&lt;/code&gt; and &lt;code&gt;d.height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d.width&lt;/code&gt; 및 &lt;code&gt;d.height&lt;/code&gt; 가 이전 호출에 의해 지정된 하나 적은 최소 크기 이하인 경우 값이 자동으로 확대된다 &lt;code&gt;setMinimumSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdee408adddec1cc773279770c4eb9ef77c9c337" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is always a legal UTF-16 sequence.</source>
          <target state="translated">그만큼 &lt;code&gt;data&lt;/code&gt; 항상 법적 UTF-16 순서입니다.</target>
        </trans-unit>
        <trans-unit id="f4549daee89cce421917747661b9b9dbdbc5d4cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deregister&lt;/code&gt; method is intended only to be used by JDBC Drivers and not by applications. JDBC drivers are recommended to not implement &lt;code&gt;DriverAction&lt;/code&gt; in a public class. If there are active connections to the database at the time that the &lt;code&gt;deregister&lt;/code&gt; method is called, it is implementation specific as to whether the connections are closed or allowed to continue. Once this method is called, it is implementation specific as to whether the driver may limit the ability to create new connections to the database, invoke other &lt;code&gt;Driver&lt;/code&gt; methods or throw a &lt;code&gt;SQLException&lt;/code&gt;. Consult your JDBC driver's documentation for additional information on its behavior.</source>
          <target state="translated">&lt;code&gt;deregister&lt;/code&gt; 메소드는 것입니다 JDBC 드라이버가 아닌 응용 프로그램에서 사용 할 수 있습니다. JDBC 드라이버는 공용 클래스에서 &lt;code&gt;DriverAction&lt;/code&gt; 을 구현하지 않는 것이 좋습니다 . &lt;code&gt;deregister&lt;/code&gt; 메서드가 호출 될 때 데이터베이스에 대한 활성 연결이있는 경우 연결이 닫혔는지 또는 계속할 수 있는지에 대한 구현에 따라 다릅니다. 이 메서드가 호출되면 드라이버가 데이터베이스에 대한 새 연결을 생성하고 다른 &lt;code&gt;Driver&lt;/code&gt; 호출하는 기능을 제한 할 수 있는지 여부는 구현에 따라 다릅니다. 하거나 메서드를 하거나 &lt;code&gt;SQLException&lt;/code&gt; 을 발생 . 동작에 대한 추가 정보는 JDBC 드라이버의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b8e66ca8dcc60e252a66649960d4c45b1465623" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;descriptor&lt;/code&gt; can contain entries that will define the values returned by certain methods of this class, as explained in the &lt;a href=&quot;package-summary#constraints&quot;&gt; package description&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;descriptor&lt;/code&gt; 에서 설명한 바와 같이,이 클래스의 특정 방법에 의해 리턴 된 값을 정의 할 수있는 항목을 포함 &lt;a href=&quot;package-summary#constraints&quot;&gt;패키지 안내&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e74408bd8afc062ff7d9cfe3aab2c13ea6f53b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dest&lt;/code&gt; argument refers to an object that is not an array.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 인수 배열이 아닌 오브젝트를 지칭한다.</target>
        </trans-unit>
        <trans-unit id="8294f1f3beefad7591b5cc3ea0551866cab7aae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;destPos&lt;/code&gt; argument is negative.</source>
          <target state="translated">&lt;code&gt;destPos&lt;/code&gt; 가의 인수가 부의이다.</target>
        </trans-unit>
        <trans-unit id="71160060862e661265f3fd734b0330aa232357eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;detail&lt;/code&gt; attribute inherited from &lt;code&gt;UIEvent&lt;/code&gt; indicates the number of times a mouse button has been pressed and released over the same screen location during a user action. The attribute value is 1 when the user begins this action and increments by 1 for each full sequence of pressing and releasing. If the user moves the mouse between the mousedown and mouseup the value will be set to 0, indicating that no click is occurring.</source>
          <target state="translated">&lt;code&gt;detail&lt;/code&gt; 로부터 상속 속성 &lt;code&gt;UIEvent&lt;/code&gt; 마우스 버튼을 누르고 사용자 동작 중에 동일 화면 위에 위치 해제 된 횟수를 나타낸다. 사용자가이 작업을 시작할 때 속성 값은 1이고 눌렀다 놓기의 전체 시퀀스마다 1 씩 증가합니다. 사용자가 mousedown과 mouseup 사이에서 마우스를 움직이면 값이 0으로 설정되어 클릭이 발생하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2a960f617370308fb92badef083ce1edd73bfd82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;digest&lt;/code&gt; method can be called once for a given number of updates. After &lt;code&gt;digest&lt;/code&gt; has been called, the MessageDigest object is reset to its initialized state.</source>
          <target state="translated">&lt;code&gt;digest&lt;/code&gt; 방법은 업데이트 주어진 수에 대해 한 번 호출 할 수 있습니다. &lt;code&gt;digest&lt;/code&gt; 가 호출 된 후 MessageDigest 객체는 초기화 된 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e1dde7d27adbf8e6cef3b9bbcdbc4cbcc2ad96bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;double&lt;/code&gt; format can represent all consecutive integers in the range -2&lt;sup&gt;53&lt;/sup&gt; to 2&lt;sup&gt;53&lt;/sup&gt;. If the pipeline has more than 2&lt;sup&gt;53&lt;/sup&gt; values, the divisor in the average computation will saturate at 2&lt;sup&gt;53&lt;/sup&gt;, leading to additional numerical errors.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 형식은 범위의 모든 연속적인 정수를 나타낼 수 -2 &lt;sup&gt;(53)&lt;/sup&gt; 2 &lt;sup&gt;(53)&lt;/sup&gt; . 파이프 라인에 2 &lt;sup&gt;53&lt;/sup&gt; 개 이상의 값이있는 경우 평균 계산의 제수가 2 &lt;sup&gt;53&lt;/sup&gt; 에서 포화 되어 추가적인 수치 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cad4be16e75ad0f3392aac98141ceaed42bece6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;double&lt;/code&gt; value that is closer than any other to</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 가까이있는 다른보다 값</target>
        </trans-unit>
        <trans-unit id="1e3ae85b07a531401bb2890e79fc22f20146cf1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;draw3DRect&lt;/code&gt; and &lt;code&gt;fill3DRect&lt;/code&gt; methods were implemented in terms of the &lt;code&gt;drawLine&lt;/code&gt; and &lt;code&gt;fillRect&lt;/code&gt; methods in the &lt;code&gt;Graphics&lt;/code&gt; class which would predicate their behavior upon the current &lt;code&gt;Stroke&lt;/code&gt; and &lt;code&gt;Paint&lt;/code&gt; objects in a &lt;code&gt;Graphics2D&lt;/code&gt; context. This class overrides those implementations with versions that use the current &lt;code&gt;Color&lt;/code&gt; exclusively, overriding the current &lt;code&gt;Paint&lt;/code&gt; and which uses &lt;code&gt;fillRect&lt;/code&gt; to describe the exact same behavior as the preexisting methods regardless of the setting of the current &lt;code&gt;Stroke&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;draw3DRect&lt;/code&gt; 와 &lt;code&gt;fill3DRect&lt;/code&gt; 방법의 측면에서 구현 된 &lt;code&gt;drawLine&lt;/code&gt; 와 &lt;code&gt;fillRect&lt;/code&gt; 할 의 방법 &lt;code&gt;Graphics&lt;/code&gt; 현재에 자신의 행동을 술어 것이다 클래스 &lt;code&gt;Stroke&lt;/code&gt; 및 &lt;code&gt;Paint&lt;/code&gt; A의 객체 &lt;code&gt;Graphics2D&lt;/code&gt; 문맥. 이 클래스는 현재 &lt;code&gt;Color&lt;/code&gt; 를 독점적으로 사용하는 버전으로 이러한 구현을 재정의하고 현재 &lt;code&gt;Paint&lt;/code&gt; 를 재정의하고 &lt;code&gt;fillRect&lt;/code&gt; 를 사용 하여 현재의 설정에 관계없이 기존 메서드와 똑같은 동작을 설명합니다. &lt;code&gt;Stroke&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f02492238ec3eeb18bc396353d14b09af775519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dstOffset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;charsequence#length()&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;dstOffset&lt;/code&gt; 의 인수보다 더 큰 수 또는 동일해야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;charsequence#length()&quot;&gt;길이&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="99457e6b4813c6110cd28c3bdc215ba87cac93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dstOffset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;stringbuffer#length--&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;dstOffset&lt;/code&gt; 의 인수보다 크거나 동일해야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;stringbuffer#length--&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="cf3f3c8673cb205a88acf65cbe9d481cc7bd21e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dstOffset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;stringbuilder#length--&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;dstOffset&lt;/code&gt; 의 인수보다 크거나 동일해야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;stringbuilder#length--&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="57b48e0bd69c0d96f6dab5758abac0f4d57b113a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encoded&lt;/code&gt; argument is illegal if it:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;encoded&lt;/code&gt; 인수가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f825d64728b91255aebca414eb9e4365aeec903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;endOfInput&lt;/code&gt; parameter advises this method as to whether the invoker can provide further input beyond that contained in the given input buffer. If there is a possibility of providing additional input then the invoker should pass &lt;code&gt;false&lt;/code&gt; for this parameter; if there is no possibility of providing further input then the invoker should pass &lt;code&gt;true&lt;/code&gt;. It is not erroneous, and in fact it is quite common, to pass &lt;code&gt;false&lt;/code&gt; in one invocation and later discover that no further input was actually available. It is critical, however, that the final invocation of this method in a sequence of invocations always pass &lt;code&gt;true&lt;/code&gt; so that any remaining undecoded input will be treated as being malformed.</source>
          <target state="translated">&lt;code&gt;endOfInput&lt;/code&gt; 의 파라미터는 호출자가 주어진 입력 버퍼에 포함 된 것을 넘어 추가 입력을 제공 할 수 있는지에이 방법을 조언한다. 추가 입력을 제공 할 가능성이있는 경우 호출자는 이 매개 변수에 대해 &lt;code&gt;false&lt;/code&gt; 를 전달해야합니다 . 추가 입력을 제공 할 가능성이 없으면 호출자는 &lt;code&gt;true&lt;/code&gt; 를 전달해야 합니다 . 한 번의 호출로 &lt;code&gt;false&lt;/code&gt; 을 전달 하고 나중에 더 이상 입력이 실제로 불가능하다는 것을 발견하는 것은 잘못이 아니며 실제로는 매우 일반적 입니다. 그러나 일련의 호출에서이 메소드의 최종 호출은 항상 &lt;code&gt;true&lt;/code&gt; 를 전달 하여 디코딩되지 않은 나머지 입력이 변형 된 것으로 처리되도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="fabf47fc50497b896963aa9019b8b35e3fbde409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;endOfInput&lt;/code&gt; parameter advises this method as to whether the invoker can provide further input beyond that contained in the given input buffer. If there is a possibility of providing additional input then the invoker should pass &lt;code&gt;false&lt;/code&gt; for this parameter; if there is no possibility of providing further input then the invoker should pass &lt;code&gt;true&lt;/code&gt;. It is not erroneous, and in fact it is quite common, to pass &lt;code&gt;false&lt;/code&gt; in one invocation and later discover that no further input was actually available. It is critical, however, that the final invocation of this method in a sequence of invocations always pass &lt;code&gt;true&lt;/code&gt; so that any remaining unencoded input will be treated as being malformed.</source>
          <target state="translated">&lt;code&gt;endOfInput&lt;/code&gt; 의 파라미터는 호출자가 주어진 입력 버퍼에 포함 된 것을 넘어 추가 입력을 제공 할 수 있는지에이 방법을 조언한다. 추가 입력을 제공 할 가능성이있는 경우 호출자는 이 매개 변수에 대해 &lt;code&gt;false&lt;/code&gt; 를 전달해야합니다 . 추가 입력을 제공 할 가능성이 없으면 호출자는 &lt;code&gt;true&lt;/code&gt; 를 전달해야 합니다 . 한 번의 호출로 &lt;code&gt;false&lt;/code&gt; 을 전달 하고 나중에 더 이상 입력이 실제로 불가능하다는 것을 발견하는 것은 잘못이 아니며 실제로는 매우 일반적 입니다. 그러나 일련의 호출에서이 메소드의 최종 호출은 항상 &lt;code&gt;true&lt;/code&gt; 를 전달 하여 인코딩되지 않은 나머지 입력이 변형 된 것으로 처리되도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ec11602184cb13ced71453ae56dda30935562022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entities&lt;/code&gt;&lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal.</source>
          <target state="translated">&lt;code&gt;entities&lt;/code&gt; &lt;code&gt;NamedNodeMaps&lt;/code&gt; 동일하다.</target>
        </trans-unit>
        <trans-unit id="ec561af054842027cb5a40ad05b4b5c7e68a8699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; argument is valid only for the duration of the invocation. Using &lt;code&gt;entry&lt;/code&gt; after the call returns results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;entry&lt;/code&gt; 인수는 호출의 기간 동안 유효합니다. &lt;code&gt;entry&lt;/code&gt; 사용호출 후 을 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="759ffc9229118351f3a52e836520820e1dc112e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method for an enumeration class just does a test for identical objects (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">열거 클래스 의 &lt;code&gt;equals()&lt;/code&gt; 메소드는 동일한 객체 ( &lt;code&gt;==&lt;/code&gt; )를 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="b29ad1a11acf214b8866d6a3f630b101a0ca3675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals&lt;/code&gt; method for class &lt;code&gt;Object&lt;/code&gt; implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, this method returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; refer to the same object (&lt;code&gt;x == y&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 클래스 의 &lt;code&gt;equals&lt;/code&gt; 메소드는 객체에 대해 가장 구별 가능한 등가 관계를 구현합니다. 즉, null 이외의 &lt;code&gt;true&lt;/code&gt; 조치 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 경우 ,이 메소드는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 같은 객체를 참조하는 경우에 한해 true를 돌려줍니다 ( &lt;code&gt;x == y&lt;/code&gt; 의 값이 &lt;code&gt;true&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="387966673ba7ec974b34376b9ba2a99dc7f3ff88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals&lt;/code&gt; method implements an equivalence relation on non-null object references:</source>
          <target state="translated">는 &lt;code&gt;equals&lt;/code&gt; 방법의 구현을 null 이외의 객체 참조에서의 동치 관계를 :</target>
        </trans-unit>
        <trans-unit id="5611c44255183f5d91cb4e6ea30bca9c8f5bc511" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;estimateDepth&lt;/code&gt; specifies the estimate number of stack frames this &lt;code&gt;StackWalker&lt;/code&gt; will traverse that the &lt;code&gt;StackWalker&lt;/code&gt; could use as a hint for the buffer size.</source>
          <target state="translated">&lt;code&gt;estimateDepth&lt;/code&gt; 는 이 스택 프레임의 추정치 번호 지정 &lt;code&gt;StackWalker&lt;/code&gt; 가 것을 통과한다 &lt;code&gt;StackWalker&lt;/code&gt; 을 버퍼 크기에 대한 힌트로서 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="542970e582dd284bb20814dd3b131537943f85a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eventPropertyName&lt;/code&gt; string is used to extract a value from the incoming event object that is passed to the target method. The common case is the target method takes no arguments, in which case a value of null should be used for the &lt;code&gt;eventPropertyName&lt;/code&gt;. Alternatively if you want the incoming event object passed directly to the target method use the empty string. The format of the &lt;code&gt;eventPropertyName&lt;/code&gt; string is a sequence of methods or properties where each method or property is applied to the value returned by the preceding method starting from the incoming event object. The syntax is: &lt;code&gt;propertyName{.propertyName}*&lt;/code&gt; where &lt;code&gt;propertyName&lt;/code&gt; matches a method or property. For example, to extract the &lt;code&gt;point&lt;/code&gt; property from a &lt;code&gt;MouseEvent&lt;/code&gt;, you could use either &lt;code&gt;&quot;point&quot;&lt;/code&gt; or &lt;code&gt;&quot;getPoint&quot;&lt;/code&gt; as the &lt;code&gt;eventPropertyName&lt;/code&gt;. To extract the &quot;text&quot; property from a &lt;code&gt;MouseEvent&lt;/code&gt; with a &lt;code&gt;JLabel&lt;/code&gt; source use any of the following as &lt;code&gt;eventPropertyName&lt;/code&gt;: &lt;code&gt;&quot;source.text&quot;&lt;/code&gt;, &lt;code&gt;&quot;getSource.text&quot; &quot;getSource.getText&quot;&lt;/code&gt; or &lt;code&gt;&quot;source.getText&quot;&lt;/code&gt;. If a method can not be found, or an exception is generated as part of invoking a method a &lt;code&gt;RuntimeException&lt;/code&gt; will be thrown at dispatch time. For example, if the incoming event object is null, and &lt;code&gt;eventPropertyName&lt;/code&gt; is non-null and not empty, a &lt;code&gt;RuntimeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;eventPropertyName&lt;/code&gt; 를의 문자열이 상기 타겟 메소드로 전달받는 이벤트 객체의 값을 추출하는 데 사용된다. 일반적인 경우는 target 메서드가 인수를받지 않는 경우이며,이 경우 &lt;code&gt;eventPropertyName&lt;/code&gt; 에 null 값을 사용해야합니다 . 또는 들어오는 이벤트 개체를 대상 메서드에 직접 전달하려면 빈 문자열을 사용하십시오. &lt;code&gt;eventPropertyName&lt;/code&gt; 문자열 의 형식은 각 메서드 또는 속성이 들어오는 이벤트 개체에서 시작하여 이전 메서드에서 반환 된 값에 적용되는 메서드 또는 속성의 시퀀스입니다. 구문은 다음과 같습니다. &lt;code&gt;propertyName{.propertyName}*&lt;/code&gt; 여기서 &lt;code&gt;propertyName&lt;/code&gt; 은 메서드 또는 속성과 일치합니다. 예를 들어, &lt;code&gt;point&lt;/code&gt; 을 추출하려면 &lt;code&gt;MouseEvent&lt;/code&gt; 의 속성에서 &lt;code&gt;&quot;point&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;getPoint&quot;&lt;/code&gt; 를 &lt;code&gt;eventPropertyName&lt;/code&gt; 으로 사용할 수 있습니다 . a로부터 &quot;텍스트&quot;속성 추출하려면 &lt;code&gt;MouseEvent&lt;/code&gt; 로모그래퍼 &lt;code&gt;JLabel&lt;/code&gt; 소스 사용으로 다음 중 하나 &lt;code&gt;eventPropertyName&lt;/code&gt; 를 : &lt;code&gt;&quot;source.text&quot;&lt;/code&gt; , &lt;code&gt;&quot;getSource.text&quot; &quot;getSource.getText&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;source.getText&quot;&lt;/code&gt; . 메소드를 찾을 수 없거나 메소드 호출의 일부로 예외가 생성되면 디스패치 시간에 &lt;code&gt;RuntimeException&lt;/code&gt; 이 발생합니다. 예를 들어 수신 이벤트 객체가 null 인 경우 &lt;code&gt;eventPropertyName&lt;/code&gt; 은 null이 아니고 비어 있지 않습니다. &lt;code&gt;RuntimeException&lt;/code&gt; throw됩니다.</target>
        </trans-unit>
        <trans-unit id="979f15807ff26fd3232fc39f57a589f6474444ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eventPropertyName&lt;/code&gt; string is used to extract a value from the incoming event object that is passed to the target method. The common case is the target method takes no arguments, in which case a value of null should be used for the &lt;code&gt;eventPropertyName&lt;/code&gt;. Alternatively if you want the incoming event object passed directly to the target method use the empty string. The format of the &lt;code&gt;eventPropertyName&lt;/code&gt; string is a sequence of methods or properties where each method or property is applied to the value returned by the preceding method starting from the incoming event object. The syntax is: &lt;code&gt;propertyName{.propertyName}*&lt;/code&gt; where &lt;code&gt;propertyName&lt;/code&gt; matches a method or property. For example, to extract the &lt;code&gt;point&lt;/code&gt; property from a &lt;code&gt;MouseEvent&lt;/code&gt;, you could use either &lt;code&gt;&quot;point&quot;&lt;/code&gt; or &lt;code&gt;&quot;getPoint&quot;&lt;/code&gt; as the &lt;code&gt;eventPropertyName&lt;/code&gt;. To extract the &quot;text&quot; property from a &lt;code&gt;MouseEvent&lt;/code&gt; with a &lt;code&gt;JLabel&lt;/code&gt; source use any of the following as &lt;code&gt;eventPropertyName&lt;/code&gt;: &lt;code&gt;&quot;source.text&quot;&lt;/code&gt;, &lt;code&gt;&quot;getSource.text&quot;&lt;/code&gt;&lt;code&gt;&quot;getSource.getText&quot;&lt;/code&gt; or &lt;code&gt;&quot;source.getText&quot;&lt;/code&gt;. If a method can not be found, or an exception is generated as part of invoking a method a &lt;code&gt;RuntimeException&lt;/code&gt; will be thrown at dispatch time. For example, if the incoming event object is null, and &lt;code&gt;eventPropertyName&lt;/code&gt; is non-null and not empty, a &lt;code&gt;RuntimeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;eventPropertyName&lt;/code&gt; 를의 문자열이 상기 타겟 메소드로 전달받는 이벤트 객체의 값을 추출하는 데 사용된다. 일반적인 경우는 대상 메소드가 인수를 사용하지 않으며,이 경우 &lt;code&gt;eventPropertyName&lt;/code&gt; 에 null 값을 사용해야합니다 . 또는 수신 이벤트 오브젝트를 대상 메소드에 직접 전달하려면 빈 문자열을 사용하십시오. &lt;code&gt;eventPropertyName&lt;/code&gt; 문자열 의 형식은 각 메소드 또는 특성이 수신 이벤트 오브젝트에서 시작하여 앞의 메소드가 리턴 한 값에 적용되는 일련의 메소드 또는 특성입니다. 구문은 다음과 같습니다. &lt;code&gt;propertyName{.propertyName}*&lt;/code&gt; 여기서 &lt;code&gt;propertyName&lt;/code&gt; 은 메소드 또는 특성과 일치합니다. 예를 들어 &lt;code&gt;point&lt;/code&gt; 을 추출하려면 &lt;code&gt;MouseEvent&lt;/code&gt; 의 속성에서 &lt;code&gt;&quot;point&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;getPoint&quot;&lt;/code&gt; 를 &lt;code&gt;eventPropertyName&lt;/code&gt; 으로 사용할 수 있습니다 . a로부터 &quot;텍스트&quot;속성 추출하려면 &lt;code&gt;MouseEvent&lt;/code&gt; 로모그래퍼 &lt;code&gt;JLabel&lt;/code&gt; 소스 사용으로 다음 중 하나 &lt;code&gt;eventPropertyName&lt;/code&gt; 를 : &lt;code&gt;&quot;source.text&quot;&lt;/code&gt; , &lt;code&gt;&quot;getSource.text&quot;&lt;/code&gt; &lt;code&gt;&quot;getSource.getText&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;source.getText&quot;&lt;/code&gt; . 메소드를 찾을 수 없거나 메소드 호출의 일부로 예외가 생성되면 디스패치시 &lt;code&gt;RuntimeException&lt;/code&gt; 이 발생합니다. 예를 들어, 수신 이벤트 오브젝트가 널이고 &lt;code&gt;eventPropertyName&lt;/code&gt; null이 아니고 비어 있지 않은 경우, &lt;code&gt;RuntimeException&lt;/code&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="11b7dfa61c07755540a7b91b193348ac328193f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method executes an SQL statement and indicates the form of the first result. You must then use the methods &lt;code&gt;getResultSet&lt;/code&gt; or &lt;code&gt;getUpdateCount&lt;/code&gt; to retrieve the result, and &lt;code&gt;getMoreResults&lt;/code&gt; to move to any subsequent result(s).</source>
          <target state="translated">는 &lt;code&gt;execute&lt;/code&gt; 방법은 SQL 문을 실행하고, 결과의 첫 번째 형태를 나타낸다. 그런 다음 &lt;code&gt;getResultSet&lt;/code&gt; 또는 &lt;code&gt;getUpdateCount&lt;/code&gt; 메소드를 사용하여 결과를 검색하고 &lt;code&gt;getMoreResults&lt;/code&gt; 를 사용하여 후속 결과로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="05464faee96a489e25104ce5867b437da02b7e6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method finds a method whose name is the same as the &lt;code&gt;methodName&lt;/code&gt; property, and invokes the method on the target.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 방법은 그 이름과 동일한 방법 발견 &lt;code&gt;methodName&lt;/code&gt; 로의 속성을, 상기 대상에서 메소드를 호출한다.</target>
        </trans-unit>
        <trans-unit id="881d0e5738f41f203ab7920ce95659722dd4768f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method finds a method whose name is the same as the &lt;code&gt;methodName&lt;/code&gt; property, and invokes the method on the target. When the target's class defines many methods with the given name the implementation should choose the most specific method using the algorithm specified in the Java Language Specification (15.11). The dynamic class of the target and arguments are used in place of the compile-time type information and, like the &lt;a href=&quot;../../../java.base/java/lang/reflect/method&quot;&gt;&lt;code&gt;Method&lt;/code&gt;&lt;/a&gt; class itself, conversion between primitive values and their associated wrapper classes is handled internally.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 방법은 그 이름과 동일한 방법 발견 &lt;code&gt;methodName&lt;/code&gt; 로의 속성을, 상기 대상에서 메소드를 호출한다. 대상의 클래스가 주어진 이름으로 많은 메소드를 정의 할 때 구현은 Java 언어 사양 (15.11)에 지정된 알고리즘을 사용하여 가장 구체적인 메소드를 선택해야합니다. 대상 및 인수의 동적 클래스는 컴파일 타임 유형 정보 대신 사용되며 &lt;a href=&quot;../../../java.base/java/lang/reflect/method&quot;&gt; &lt;code&gt;Method&lt;/code&gt; &lt;/a&gt; 클래스 자체 와 마찬가지로 기본 값과 관련 래퍼 클래스 간의 변환은 내부적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="7b4b06ad05dfb91d784c6607e33529a4e06af587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method finds a method whose name is the same as the &lt;code&gt;methodName&lt;/code&gt; property, and invokes the method on the target. When the target's class defines many methods with the given name the implementation should choose the most specific method using the algorithm specified in the Java Language Specification (15.11). The dynamic class of the target and arguments are used in place of the compile-time type information and, like the &lt;a href=&quot;../lang/reflect/method&quot;&gt;&lt;code&gt;Method&lt;/code&gt;&lt;/a&gt; class itself, conversion between primitive values and their associated wrapper classes is handled internally.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 방법은 그 이름과 동일한 방법 발견 &lt;code&gt;methodName&lt;/code&gt; 로의 속성을, 상기 대상에서 메소드를 호출한다. 대상의 클래스가 주어진 이름으로 많은 메소드를 정의 할 때 구현시 Java 언어 사양 (15.11)에 지정된 알고리즘을 사용하여 가장 구체적인 메소드를 선택해야합니다. 대상 및 인수의 동적 클래스는 컴파일 타임 유형 정보 대신 사용되며 &lt;a href=&quot;../lang/reflect/method&quot;&gt; &lt;code&gt;Method&lt;/code&gt; &lt;/a&gt; 클래스 자체 와 같이 기본 값과 관련 래퍼 클래스 간의 변환이 내부적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8ad6c0c213db0ee82bf11ddff27fdf95642bb749" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method may use the following properties to create a connection for reading data: url, data source name, user name, password, transaction isolation, and type map. The &lt;code&gt;execute&lt;/code&gt; method may use the following properties to create a statement to execute a command: command, read only, maximum field size, maximum rows, escape processing, and query timeout.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; URL, 데이터 소스 이름, 사용자 이름, 암호, 트랜잭션 격리 및 형태 맵 : 방법은 읽기 데이터에 대한 연결을 만들려면 다음 속성을 사용할 수 있습니다. &lt;code&gt;execute&lt;/code&gt; 만, 최대 필드 크기, 최대 행, 이스케이프 처리, 쿼리 시간 제한을 읽고 명령 방법은 명령을 실행하기 위해 문을 작성하려면 다음과 같은 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e86b01e43a8878ea8710bd314038dcf77ab8f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method returns a &lt;code&gt;boolean&lt;/code&gt; to indicate the form of the first result. You must call either the method &lt;code&gt;getResultSet&lt;/code&gt; or &lt;code&gt;getUpdateCount&lt;/code&gt; to retrieve the result; you must call &lt;code&gt;getMoreResults&lt;/code&gt; to move to any subsequent result(s).</source>
          <target state="translated">는 &lt;code&gt;execute&lt;/code&gt; 메소드가 복귀에게 &lt;code&gt;boolean&lt;/code&gt; 첫번째 결과의 형태를 나타 내기 위해. 결과를 검색하려면 &lt;code&gt;getResultSet&lt;/code&gt; 또는 &lt;code&gt;getUpdateCount&lt;/code&gt; 메소드를 호출해야합니다 . 후속 결과로 이동하려면 &lt;code&gt;getMoreResults&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="721571d52ff7950b67b214b688c61b64a75961c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;executor&lt;/code&gt; parameter is an &lt;code&gt;ExecutorService&lt;/code&gt; that creates new threads as needed to execute tasks that are submitted to handle I/O events and dispatch completion results for operations initiated on asynchronous channels in the group. It may reuse previously constructed threads when they are available.</source>
          <target state="translated">&lt;code&gt;executor&lt;/code&gt; 매개 변수는있다 &lt;code&gt;ExecutorService&lt;/code&gt; 를 I / 그룹의 비동기 채널에서 시작된 작업에 대한 O 이벤트 및 발송 완료 결과를 처리하기 위해 제출 된 작업을 실행하기 위해 필요에 따라 새 스레드를 생성합니다. 사용 가능한 경우 이전에 구성된 스레드를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec1467cb33e94fd2c0bb533c599fa01ae6a0656e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;executor&lt;/code&gt; parameter is an &lt;code&gt;ExecutorService&lt;/code&gt; that executes tasks submitted to dispatch completion results for operations initiated on asynchronous channels in the group.</source>
          <target state="translated">&lt;code&gt;executor&lt;/code&gt; 매개 변수는이다 &lt;code&gt;ExecutorService&lt;/code&gt; 를 실행하는 작업은 그룹에서 비동기 채널을 개시 조작에 송출 완료 결과 제출있다.</target>
        </trans-unit>
        <trans-unit id="340e8f3277e0a9554138eaf4e4d1386486ab2daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;executor&lt;/code&gt; parameter is the &lt;a href=&quot;../../util/concurrent/executorservice&quot;&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; to which tasks are submitted to handle I/O events and dispatch completion results for operations initiated on resulting channel. The nature of these tasks is highly implementation specific and so care should be taken when configuring the &lt;code&gt;Executor&lt;/code&gt;. Minimally it should support an unbounded work queue and should not run tasks on the caller thread of the &lt;a href=&quot;../../util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; method. Shutting down the executor service while the channel is open results in unspecified behavior.</source>
          <target state="translated">&lt;code&gt;executor&lt;/code&gt; 매개 변수는있다 &lt;a href=&quot;../../util/concurrent/executorservice&quot;&gt; &lt;code&gt;ExecutorService&lt;/code&gt; 에&lt;/a&gt; 작업이 I / 채널을 결과에 시작한 작업 O 이벤트 및 발송 완료 결과를 처리하기 위해 제출되는. 이러한 작업의 특성은 구현에 따라 다르므로 &lt;code&gt;Executor&lt;/code&gt; 를 구성 할 때주의해야합니다 . 최소한 제한되지 않은 작업 대기열을 지원해야하며 &lt;a href=&quot;../../util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt; &lt;code&gt;execute&lt;/code&gt; &lt;/a&gt; 메서드 의 호출자 스레드에서 작업을 실행해서는 안됩니다 . 채널이 열려있는 동안 실행기 서비스를 종료하면 지정되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f3b206390268e595a7543c9f72d6571233bef9fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;executor&lt;/code&gt; parameter is the &lt;a href=&quot;../../util/concurrent/executorservice&quot;&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; to which tasks are submitted to handle I/O events and dispatch completion results for operations initiated on resulting channel. The nature of these tasks is highly implementation specific and so care should be taken when configuring the &lt;code&gt;Executor&lt;/code&gt;. Minimally it should support an unbounded work queue and should not run tasks on the caller thread of the &lt;a href=&quot;../../util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; method. Shutting down the executor service while the channel is open results in unspecified behavior.</source>
          <target state="translated">&lt;code&gt;executor&lt;/code&gt; 매개 변수는있다 &lt;a href=&quot;../../util/concurrent/executorservice&quot;&gt; &lt;code&gt;ExecutorService&lt;/code&gt; 에&lt;/a&gt; 작업이 I / 채널을 결과에 시작한 작업 O 이벤트 및 발송 완료 결과를 처리하기 위해 제출되는. 이러한 작업의 특성은 구현에 따라 다르므로 &lt;code&gt;Executor&lt;/code&gt; 를 구성 할 때는주의를 기울여야합니다 . 최소한 무제한 작업 대기열을 지원해야하며 &lt;a href=&quot;../../util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt; &lt;code&gt;execute&lt;/code&gt; &lt;/a&gt; 메소드 의 호출자 스레드에서 태스크를 실행하지 않아야합니다 . 채널이 열린 상태에서 실행기 서비스를 종료하면 지정되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a348a5e6c50ba5a16fcb50db730eca7f5277712" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been called and the security manager has permitted the exit operation to take place.</source>
          <target state="translated">&lt;code&gt;Runtime&lt;/code&gt; 클래스 의 &lt;code&gt;exit&lt;/code&gt; 메소드 가 호출되었으며 보안 관리자가 엑시트 조작을 허용했습니다.</target>
        </trans-unit>
        <trans-unit id="54da7fdc8d08868a250106136d8727592f95e4ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extraExports&lt;/code&gt; parameter is the map of additional packages to export. The &lt;code&gt;extraOpens&lt;/code&gt; parameter is the map of additional packages to open. In both cases, the map key is the fully-qualified name of the package as defined in section 6.5.3 of</source>
          <target state="translated">&lt;code&gt;extraExports&lt;/code&gt; 의 매개 변수는 수출 추가 패키지의지도입니다. &lt;code&gt;extraOpens&lt;/code&gt; 의 매개 변수는 열 추가 패키지의지도입니다. 두 경우 모두 맵 키는 섹션 6.5.3에 정의 된 패키지의 정규화 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7fa94cd8aa6c313051f5bdb81ee487e8d422730c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extraProvides&lt;/code&gt; parameter is the additional service providers for the module to provide. The map key is the service type. The map value is the non-empty list of implementation types, each of which is a member of the module and an implementation of the service.</source>
          <target state="translated">&lt;code&gt;extraProvides&lt;/code&gt; 의 매개 변수는 모듈이 제공하기위한 추가 서비스 제공 업체입니다. 맵 키는 서비스 유형입니다. 맵 값은 구현 유형의 비어 있지 않은 목록이며, 각각은 모듈의 구성원이며 서비스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="676f7c17aac8c78e797db6e7abb083ffd0ff7492" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failure&lt;/code&gt; callback is invoked when the RMI runtime is unable to create a &lt;code&gt;ServerSocket&lt;/code&gt; via the &lt;code&gt;RMISocketFactory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;failure&lt;/code&gt; RMI 런타임이 만들 수 없을 때 콜백이 호출 &lt;code&gt;ServerSocket&lt;/code&gt; 의 비아 &lt;code&gt;RMISocketFactory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="969956ed69e8a6235531b9a7241b70965fe5c99b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failure&lt;/code&gt; callback is invoked when the RMI runtime is unable to create a &lt;code&gt;ServerSocket&lt;/code&gt; via the &lt;code&gt;RMISocketFactory&lt;/code&gt;. An &lt;code&gt;RMIFailureHandler&lt;/code&gt; is registered via a call to &lt;code&gt;RMISocketFacotry.setFailureHandler&lt;/code&gt;. If no failure handler is installed, the default behavior is to attempt to re-create the ServerSocket.</source>
          <target state="translated">&lt;code&gt;failure&lt;/code&gt; RMI 런타임이 만들 수 없을 때 콜백이 호출 &lt;code&gt;ServerSocket&lt;/code&gt; 의 비아 &lt;code&gt;RMISocketFactory&lt;/code&gt; . &lt;code&gt;RMIFailureHandler&lt;/code&gt; 는 의 호출에 의해 등록되어 &lt;code&gt;RMISocketFacotry.setFailureHandler&lt;/code&gt; . 실패 핸들러가 설치되지 않은 경우 기본 동작은 ServerSocket을 다시 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a61775a7139e096b9fd0be3d2ad7ac6f1c956f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; parameter is used to specify the &lt;a href=&quot;../../net/protocolfamily&quot;&gt;&lt;code&gt;ProtocolFamily&lt;/code&gt;&lt;/a&gt;. If the datagram channel is to be used for IP multicasting then this should correspond to the address type of the multicast groups that this channel will join.</source>
          <target state="translated">&lt;code&gt;family&lt;/code&gt; 매개 변수가 지정하는 데 사용됩니다 &lt;a href=&quot;../../net/protocolfamily&quot;&gt; &lt;code&gt;ProtocolFamily&lt;/code&gt; 을&lt;/a&gt; . 데이터 그램 채널을 IP 멀티 캐스팅에 사용하려면이 채널이 참가할 멀티 캐스트 그룹의 주소 유형에 해당해야합니다.</target>
        </trans-unit>
        <trans-unit id="f08c1804c0526409a1ecb2988cff36a97dc47de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;handback&lt;/code&gt; parameters may be null if and only if they are null in a listener to be removed.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;handback&lt;/code&gt; 들이 제거 될 수신기에서 널이다 경우만 파라미터 널이 될 수있다.</target>
        </trans-unit>
        <trans-unit id="e2e6442675b7f51f69f821df5212aa778b1fe932" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filtering()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, such as downstream of a &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. For example, given a stream of &lt;code&gt;Employee&lt;/code&gt;, to accumulate the employees in each department that have a salary above a certain threshold:</source>
          <target state="translated">&lt;code&gt;filtering()&lt;/code&gt; 등의 다운 스트림으로, 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 예를 들어, 특정 임계 값을 초과하는 급여를 가진 각 부서의 직원을 누적하려면 &lt;code&gt;Employee&lt;/code&gt; 스트림이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e696db23567885b82ff4f03850097e84169fd88a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated and will be removed.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않으며 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="097d5634e76c7fdc3a50dea30921ddef17371844" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated and will be removed. It is implemented as a no-op. Subclasses that override &lt;code&gt;finalize&lt;/code&gt; in order to perform cleanup should be modified to use alternative cleanup mechanisms and remove the overriding &lt;code&gt;finalize&lt;/code&gt; method. The recommended cleanup for compressor is to explicitly call &lt;code&gt;end&lt;/code&gt; method when it is no longer in use. If the &lt;code&gt;end&lt;/code&gt; is not invoked explicitly the resource of the compressor will be released when the instance becomes unreachable,</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않으며 제거됩니다. 그것은 no-op으로 구현됩니다. &lt;code&gt;finalize&lt;/code&gt; 를 재정의하는 하위 클래스정리를 수행하기 위해 대체 정리 메커니즘을 사용하고 재정의하는 &lt;code&gt;finalize&lt;/code&gt; 메서드를 제거하도록 수정해야합니다 . 압축기에 권장되는 정리 는 더 이상 사용하지 않을 때 명시 적으로 &lt;code&gt;end&lt;/code&gt; 메서드를 호출 하는 것입니다. 는 IF &lt;code&gt;end&lt;/code&gt; 압축기의 자원이 인스턴스가 도달 될 때 해제됩니다 명시 적으로 호출되지 않습니다,</target>
        </trans-unit>
        <trans-unit id="47b79383bcae3e922204d5ea86fccfb170bfe2e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated and will be removed. It is implemented as a no-op. Subclasses that override &lt;code&gt;finalize&lt;/code&gt; in order to perform cleanup should be modified to use alternative cleanup mechanisms and to remove the overriding &lt;code&gt;finalize&lt;/code&gt; method. The recommended cleanup for ZipFile object is to explicitly invoke &lt;code&gt;close&lt;/code&gt; method when it is no longer in use, or use try-with-resources. If the &lt;code&gt;close&lt;/code&gt; is not invoked explicitly the resources held by this object will be released when the instance becomes unreachable.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않으며 제거됩니다. 그것은 no-op으로 구현됩니다. &lt;code&gt;finalize&lt;/code&gt; 를 재정의하는 하위 클래스 정리를 수행하기 위해 대체 정리 메커니즘을 사용하고 재정의하는 &lt;code&gt;finalize&lt;/code&gt; 메서드 를 제거하도록 수정해야합니다 . ZipFile 객체에 대해 권장되는 정리 는 더 이상 사용하지 않을 때 &lt;code&gt;close&lt;/code&gt; 메서드 를 명시 적으로 호출 하거나 try-with-resources를 사용하는 것입니다. 경우 &lt;code&gt;close&lt;/code&gt; 명시 적으로 호출되지 인스턴스에 연결할 수있게되면이 객체가 보관 유지 자원이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="7f87f25a450e774218ae842f94ecc4f8e21a6230" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated and will be removed. It is implemented as a no-op. Subclasses that override &lt;code&gt;finalize&lt;/code&gt; in order to perform cleanup should be modified to use alternative cleanup mechanisms and to remove the overriding &lt;code&gt;finalize&lt;/code&gt; method. The recommended cleanup for compressor is to explicitly call &lt;code&gt;end&lt;/code&gt; method when it is no longer in use. If the &lt;code&gt;end&lt;/code&gt; is not invoked explicitly the resource of the compressor will be released when the instance becomes unreachable.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않으며 제거됩니다. 그것은 no-op으로 구현됩니다. 정리를 수행하기 위해 &lt;code&gt;finalize&lt;/code&gt; 를 재정의하는 하위 클래스는 대체 정리 메커니즘을 사용하고 재정의를 제거하도록 수정해야합니다. &lt;code&gt;finalize&lt;/code&gt; 메서드 . 압축기에 권장되는 정리 는 더 이상 사용하지 않을 때 명시 적으로 &lt;code&gt;end&lt;/code&gt; 메서드를 호출 하는 것입니다. 경우 &lt;code&gt;end&lt;/code&gt; 명시 적으로 호출되지 인스턴스가 도달 될 때 압축기의 자원이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="a5781f1fe78b11db626c54005d97fda3c5e9dc2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated and will be removed. Subclasses that override &lt;code&gt;finalize&lt;/code&gt; in order to perform cleanup should be modified to use alternative cleanup mechanisms and to remove the overriding &lt;code&gt;finalize&lt;/code&gt; method. When overriding the &lt;code&gt;finalize&lt;/code&gt; method, its implementation must explicitly ensure that &lt;code&gt;super.finalize()&lt;/code&gt; is invoked as described in &lt;a href=&quot;../lang/object#finalize()&quot;&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;&lt;/a&gt;. See the specification for &lt;a href=&quot;../lang/object#finalize()&quot;&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;&lt;/a&gt; for further information about migration options.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않으며 제거됩니다. 정리를 수행하기 위해 &lt;code&gt;finalize&lt;/code&gt; 를 재정의하는 하위 클래스는 대체 정리 메커니즘을 사용하고 재정의하는 &lt;code&gt;finalize&lt;/code&gt; 메서드 를 제거하도록 수정해야합니다 . &lt;code&gt;finalize&lt;/code&gt; 메서드를 재정의 할 때 구현은 &lt;a href=&quot;../lang/object#finalize()&quot;&gt; &lt;code&gt;Object.finalize()&lt;/code&gt; &lt;/a&gt; 설명 된대로 &lt;code&gt;super.finalize()&lt;/code&gt; 가 호출 되도록 명시 적으로 확인해야합니다. . 마이그레이션 옵션에 대한 자세한 내용은 &lt;a href=&quot;../lang/object#finalize()&quot;&gt; &lt;code&gt;Object.finalize()&lt;/code&gt; &lt;/a&gt; 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a42af659e94273af1e3e71c3f847d665f87c7926" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="301938edcbcee8912bd33f8f0d3d67fd77b6a355" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated. Subclasses that override &lt;code&gt;finalize&lt;/code&gt; in order to perform cleanup should be modified to use alternative cleanup mechanisms and to remove the overriding &lt;code&gt;finalize&lt;/code&gt; method. When overriding the &lt;code&gt;finalize&lt;/code&gt; method, its implementation must explicitly ensure that &lt;code&gt;super.finalize()&lt;/code&gt; is invoked as described in &lt;a href=&quot;../../../../java.base/java/lang/object#finalize()&quot;&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;&lt;/a&gt;. See the specification for &lt;a href=&quot;../../../../java.base/java/lang/object#finalize()&quot;&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;&lt;/a&gt; for further information about migration options.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않습니다. 정리를 수행하기 위해 &lt;code&gt;finalize&lt;/code&gt; 를 재정의하는 하위 클래스는 대체 정리 메커니즘을 사용하고 재정의하는 &lt;code&gt;finalize&lt;/code&gt; 메서드 를 제거하도록 수정해야합니다 . &lt;code&gt;finalize&lt;/code&gt; 메서드를 재정의 할 때 구현은 &lt;a href=&quot;../../../../java.base/java/lang/object#finalize()&quot;&gt; &lt;code&gt;Object.finalize()&lt;/code&gt; &lt;/a&gt; 설명 된대로 &lt;code&gt;super.finalize()&lt;/code&gt; 가 호출 되는지 명시 적으로 확인해야합니다 . 마이그레이션 옵션에 대한 자세한 내용은 &lt;a href=&quot;../../../../java.base/java/lang/object#finalize()&quot;&gt; &lt;code&gt;Object.finalize()&lt;/code&gt; &lt;/a&gt; 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf6ab10b27945f3cea37844915cc05f3c74248d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method has been deprecated. Subclasses that override &lt;code&gt;finalize&lt;/code&gt; in order to perform cleanup should be modified to use alternative cleanup mechanisms and to remove the overriding &lt;code&gt;finalize&lt;/code&gt; method. When overriding the &lt;code&gt;finalize&lt;/code&gt; method, its implementation must explicitly ensure that &lt;code&gt;super.finalize()&lt;/code&gt; is invoked as described in &lt;a href=&quot;../../../java.base/java/lang/object#finalize()&quot;&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;&lt;/a&gt;. See the specification for &lt;a href=&quot;../../../java.base/java/lang/object#finalize()&quot;&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;&lt;/a&gt; for further information about migration options.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 방법은 더 이상 사용되지 않습니다. 정리를 수행하기 위해 &lt;code&gt;finalize&lt;/code&gt; 를 재정의하는 하위 클래스는 대체 정리 메커니즘을 사용하고 재정의하는 &lt;code&gt;finalize&lt;/code&gt; 메서드 를 제거하도록 수정해야합니다 . &lt;code&gt;finalize&lt;/code&gt; 메서드를 재정의 할 때 구현은 &lt;a href=&quot;../../../java.base/java/lang/object#finalize()&quot;&gt; &lt;code&gt;Object.finalize()&lt;/code&gt; &lt;/a&gt; 설명 된대로 &lt;code&gt;super.finalize()&lt;/code&gt; 가 호출 되는지 명시 적으로 확인해야합니다 . 마이그레이션 옵션에 대한 자세한 내용은 &lt;a href=&quot;../../../java.base/java/lang/object#finalize()&quot;&gt; &lt;code&gt;Object.finalize()&lt;/code&gt; &lt;/a&gt; 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="acfa3270c433f7fbeb166904731784b7ab01474e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method is never invoked more than once by a Java virtual machine for any given object.</source>
          <target state="translated">지정된 객체에 대해 Java 가상 머신 이 &lt;code&gt;finalize&lt;/code&gt; 메소드를 두 번 이상 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36550a7fe4b3770df4940e5d45c14dff3f4cb361" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method of class &lt;code&gt;Object&lt;/code&gt; performs no special action; it simply returns normally. Subclasses of &lt;code&gt;Object&lt;/code&gt; may override this definition.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 클래스 의 &lt;code&gt;finalize&lt;/code&gt; 메소드는 특별한 조치를 수행하지 않습니다. 단순히 정상적으로 돌아옵니다. &lt;code&gt;Object&lt;/code&gt; 의 서브 클래스 가이 정의를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="290eeab6379b679af729a0f7d139a6b6afebf8ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findSystemClass&lt;/code&gt; method in class &lt;code&gt;ClassLoader&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;findSystemClass&lt;/code&gt; 의 클래스의 메소드 &lt;code&gt;ClassLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b78d49371e443cbd3adbfb51ffc64676bde68d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMap()&lt;/code&gt; operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream.</source>
          <target state="translated">&lt;code&gt;flatMap()&lt;/code&gt; 연산은 스트림의 요소 일대 변환을 적용하고 새로운 스트림으로 생성 된 소자를 평탄화하는 효과를 갖는다.</target>
        </trans-unit>
        <trans-unit id="296d9a4aaa513be61985bb6776a603e7a0774231" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMapping()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, such as downstream of a &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. For example, given a stream of &lt;code&gt;Order&lt;/code&gt;, to accumulate the set of line items for each customer:</source>
          <target state="translated">&lt;code&gt;flatMapping()&lt;/code&gt; 다단계 환원에 사용될 때 수집 이러한 하류로서 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 예를 들어 &lt;code&gt;Order&lt;/code&gt; 스트림이 주어지면 각 고객에 대한 광고 항목 집합을 누적하려면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ee0bb92de803847414b86012236c4f48f3910542" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush()&lt;/code&gt; method does nothing.</source>
          <target state="translated">그만큼 &lt;code&gt;flush()&lt;/code&gt; 메소드는 아무것도 실시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9794be29838cb64627abe081d7728e6987d9e44a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;DataOutputStream&lt;/code&gt; calls the &lt;code&gt;flush&lt;/code&gt; method of its underlying output stream.</source>
          <target state="translated">&lt;code&gt;flush&lt;/code&gt; 방법 &lt;code&gt;DataOutputStream&lt;/code&gt; 정렬 부르는 &lt;code&gt;flush&lt;/code&gt; 의 기본이되는 출력 스트림의 방법을.</target>
        </trans-unit>
        <trans-unit id="195ffa6218dd9b603f2e4ca8f61c877be833e3ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls the &lt;code&gt;flush&lt;/code&gt; method of its underlying output stream.</source>
          <target state="translated">&lt;code&gt;flush&lt;/code&gt; 의 방법을 &lt;code&gt;FilterOutputStream&lt;/code&gt; 부르는 &lt;code&gt;flush&lt;/code&gt; 의 기본이되는 출력 스트림의 방법을.</target>
        </trans-unit>
        <trans-unit id="68aa9823b85500f33061dc1eb4258756e15e005f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt; does nothing.</source>
          <target state="translated">&lt;code&gt;OutputStream&lt;/code&gt; 의 &lt;code&gt;flush&lt;/code&gt; 메소드 는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="708bb18e269a3b497919640ccb7a50b14533bedd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forName&lt;/code&gt; method in class &lt;code&gt;Class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forName&lt;/code&gt; 을 용 의 메소드 &lt;code&gt;Class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e830c12e2148cec99c8883588bf6d4b50000667" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forward&lt;/code&gt; flag specifies the order that certificates will be passed to the &lt;a href=&quot;#check(java.security.cert.Certificate)&quot;&gt;&lt;code&gt;check&lt;/code&gt;&lt;/a&gt; method (forward or reverse).</source>
          <target state="translated">&lt;code&gt;forward&lt;/code&gt; 플래그는 인증서가 전달되는 순서를 지정&lt;a href=&quot;#check(java.security.cert.Certificate)&quot;&gt; &lt;code&gt;check&lt;/code&gt; &lt;/a&gt; (순방향 또는 역방향) 방법.</target>
        </trans-unit>
        <trans-unit id="4c26146099bd6b8ccdb37b5c47095892a4be4161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forward&lt;/code&gt; flag specifies the order that certificates will be passed to the &lt;a href=&quot;#check(java.security.cert.Certificate,java.util.Collection)&quot;&gt;&lt;code&gt;check&lt;/code&gt;&lt;/a&gt; method (forward or reverse). A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt;&lt;b&gt;must&lt;/b&gt; support reverse checking and &lt;b&gt;may&lt;/b&gt; support forward checking.</source>
          <target state="translated">&lt;code&gt;forward&lt;/code&gt; 플래그는 인증서가 전달 될 순서 지정 &lt;a href=&quot;#check(java.security.cert.Certificate,java.util.Collection)&quot;&gt; &lt;code&gt;check&lt;/code&gt; &lt;/a&gt; (순방향 또는 역방향) 방법. &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; &lt;b&gt;해야&lt;/b&gt; 역 검사를 지원하고 &lt;b&gt;있습니다&lt;/b&gt; 방향의 체크를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8de3dc96d234b55e125cd365d4c69d5d74e9de59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forward&lt;/code&gt; flag specifies the order that certificates will be passed to the &lt;a href=&quot;certpathchecker#check-java.security.cert.Certificate-&quot;&gt;&lt;code&gt;check&lt;/code&gt;&lt;/a&gt; method (forward or reverse).</source>
          <target state="translated">&lt;code&gt;forward&lt;/code&gt; 플래그는 인증서가 전달 될 순서 지정 &lt;a href=&quot;certpathchecker#check-java.security.cert.Certificate-&quot;&gt; &lt;code&gt;check&lt;/code&gt; &lt;/a&gt; (순방향 또는 역방향) 방법.</target>
        </trans-unit>
        <trans-unit id="7f3a1ac72ca4c5a5aab4a7ea8026300ca9e9a65d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forward&lt;/code&gt; flag specifies the order that certificates will be passed to the &lt;a href=&quot;pkixcertpathchecker#check-java.security.cert.Certificate-java.util.Collection-&quot;&gt;&lt;code&gt;check&lt;/code&gt;&lt;/a&gt; method (forward or reverse). A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt;&lt;b&gt;must&lt;/b&gt; support reverse checking and &lt;b&gt;may&lt;/b&gt; support forward checking.</source>
          <target state="translated">&lt;code&gt;forward&lt;/code&gt; 플래그는 인증서가 전달 될 순서 지정 &lt;a href=&quot;pkixcertpathchecker#check-java.security.cert.Certificate-java.util.Collection-&quot;&gt; &lt;code&gt;check&lt;/code&gt; &lt;/a&gt; (순방향 또는 역방향) 방법. &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 의가&lt;b&gt;있어야&lt;/b&gt; 역 검사를 지원하고 &lt;b&gt;있습니다&lt;/b&gt; 방향의 체크를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c29abf69126019dfa340a81cfcd7917ddb6a1954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fractionalDigits&lt;/code&gt; parameter allows the output of the fractional second to be controlled. Specifying zero will cause no fractional digits to be output. From 1 to 9 will output an increasing number of digits, using zero right-padding if necessary. The special value -1 is used to output as many digits as necessary to avoid any trailing zeroes.</source>
          <target state="translated">&lt;code&gt;fractionalDigits&lt;/code&gt; 소수 제의 출력을 가능 매개 변수를 제어한다. 0을 지정하면 소수 자릿수가 출력되지 않습니다. 1에서 9까지는 필요한 경우 오른쪽 패딩을 사용하여 자릿수를 증가시킵니다. 특수 값 -1은 후행 0을 피하기 위해 필요한만큼의 숫자를 출력하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b74f2d1a70560572c42c19ad803e17b40cd8b5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get/putClientProperty&lt;/code&gt; methods provide access to a small per-instance hashtable. Callers can use get/putClientProperty to annotate components that were created by another module. For example, a layout manager might store per child constraints this way. For example:</source>
          <target state="translated">그만큼 &lt;code&gt;get/putClientProperty&lt;/code&gt; 방법은 작은 인스턴스마다 해시 테이블에 대한 액세스를 제공합니다. 호출자는 get / putClientProperty를 사용하여 다른 모듈에서 만든 구성 요소에 주석을 달 수 있습니다. 예를 들어, 레이아웃 관리자는 이러한 방식으로 하위 제약 조건을 저장할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="854b032e913f227ca9315dfb23f41c9eee3500bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getAWTEventListeners&lt;/code&gt; method of &lt;code&gt;Toolkit&lt;/code&gt; can return a mixture of &lt;code&gt;AWTEventListener&lt;/code&gt; and &lt;code&gt;AWTEventListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Toolkit&lt;/code&gt; 의 &lt;code&gt;getAWTEventListeners&lt;/code&gt; 메소드 는 &lt;code&gt;AWTEventListener&lt;/code&gt; 의 혼합을 리턴 할 수 있습니다. 및 &lt;code&gt;AWTEventListenerProxy&lt;/code&gt; 객체 .</target>
        </trans-unit>
        <trans-unit id="23ff0ed130fbcc2ffd5daaf1ed441144839e0f30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getBundle&lt;/code&gt; factory methods with no &lt;code&gt;Control&lt;/code&gt; parameter locate and load resource bundles from &lt;a href=&quot;spi/resourcebundleprovider&quot;&gt;service providers&lt;/a&gt;. It may continue the search as if calling &lt;a href=&quot;../lang/module#getResourceAsStream(java.lang.String)&quot;&gt;&lt;code&gt;Module.getResourceAsStream(String)&lt;/code&gt;&lt;/a&gt; to find the named resource from a given module and calling &lt;a href=&quot;../lang/classloader#getResourceAsStream(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getResourceAsStream(String)&lt;/code&gt;&lt;/a&gt;; refer to the specification of the &lt;code&gt;getBundle&lt;/code&gt; method for details. Only non-encapsulated resource bundles of &quot;&lt;code&gt;java.class&lt;/code&gt;&quot; or &quot;&lt;code&gt;java.properties&lt;/code&gt;&quot; format are searched.</source>
          <target state="translated">&lt;code&gt;getBundle&lt;/code&gt; 는 아니오 팩토리 메소드 &lt;code&gt;Control&lt;/code&gt; 매개 변수를 찾아서에서 부하 자원 번들 &lt;a href=&quot;spi/resourcebundleprovider&quot;&gt;서비스 제공&lt;/a&gt; . 지정된 모듈에서 명명 된 리소스를 찾기 위해 &lt;a href=&quot;../lang/module#getResourceAsStream(java.lang.String)&quot;&gt; &lt;code&gt;Module.getResourceAsStream(String)&lt;/code&gt; &lt;/a&gt; 을 호출하고 &lt;a href=&quot;../lang/classloader#getResourceAsStream(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getResourceAsStream(String)&lt;/code&gt; &lt;/a&gt; 호출하는 것처럼 검색을 계속할 수 있습니다 . 자세한 내용 은 &lt;code&gt;getBundle&lt;/code&gt; 메소드 의 사양을 참조 하십시오. &quot; &lt;code&gt;java.class&lt;/code&gt; 의 캡슐화되지 않은 자원 번들 만 &quot;또는 &quot; &lt;code&gt;java.properties&lt;/code&gt; &quot;형식 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="dd64d876b826e032eea9ddf5b6c247d57ce3fd4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and &lt;code&gt;
 getMinimalDaysInFirstWeek()&lt;/code&gt; values are initialized using locale-dependent resources when constructing a &lt;code&gt;
 GregorianCalendar&lt;/code&gt;. &lt;a id=&quot;iso8601_compatible_setting&quot;&gt;The week determination is compatible&lt;/a&gt; with the ISO 8601 standard when &lt;code&gt;
 getFirstDayOfWeek()&lt;/code&gt; is &lt;code&gt;MONDAY&lt;/code&gt; and &lt;code&gt;
 getMinimalDaysInFirstWeek()&lt;/code&gt; is 4, which values are used in locales where the standard is preferred. These values can explicitly be set by calling &lt;a href=&quot;calendar#setFirstDayOfWeek(int)&quot;&gt;&lt;code&gt;setFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;calendar#setMinimalDaysInFirstWeek(int)&quot;&gt;&lt;code&gt;setMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; 및 &lt;code&gt; getMinimalDaysInFirstWeek()&lt;/code&gt; 값이 생성 할 때, 로케일 따라 자원을 이용하여 초기화 &lt;code&gt; GregorianCalendar&lt;/code&gt; . &lt;code&gt; getFirstDayOfWeek()&lt;/code&gt; 가 다음 과 같은 경우 &lt;a id=&quot;iso8601_compatible_setting&quot;&gt;주 결정은&lt;/a&gt; ISO 8601 표준과 호환 됩니다. &lt;code&gt;MONDAY&lt;/code&gt; 이고 &lt;code&gt; getMinimalDaysInFirstWeek()&lt;/code&gt; 가 4 일 되며, 표준이 선호되는 로케일에서 값이 사용됩니다. 이 값은 명시 적으로 호출하여 설정할 수 있습니다 &lt;a href=&quot;calendar#setFirstDayOfWeek(int)&quot;&gt; &lt;code&gt;setFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;calendar#setMinimalDaysInFirstWeek(int)&quot;&gt; &lt;code&gt;setMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0f3e1d9782b5c32d63d7b0cc83ee2c191412bb87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; values are initialized using locale-dependent resources when constructing a &lt;code&gt;GregorianCalendar&lt;/code&gt;. &lt;a name=&quot;iso8601_compatible_setting&quot;&gt;The week determination is compatible&lt;/a&gt; with the ISO 8601 standard when &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; is &lt;code&gt;MONDAY&lt;/code&gt; and &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is 4, which values are used in locales where the standard is preferred. These values can explicitly be set by calling &lt;a href=&quot;calendar#setFirstDayOfWeek-int-&quot;&gt;&lt;code&gt;setFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;calendar#setMinimalDaysInFirstWeek-int-&quot;&gt;&lt;code&gt;setMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; 및 &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; 값이 생성 할 때, 로케일 따라 자원을 이용하여 초기화 &lt;code&gt;GregorianCalendar&lt;/code&gt; . &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; 가 &lt;code&gt;MONDAY&lt;/code&gt; 이고 &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; 가 4 인 경우 &lt;a name=&quot;iso8601_compatible_setting&quot;&gt;주 결정은&lt;/a&gt; ISO 8601 표준과 호환 됩니다. 이 값은 표준이 선호되는 로케일에서 사용됩니다. 이 값은 &lt;a href=&quot;calendar#setFirstDayOfWeek-int-&quot;&gt; &lt;code&gt;setFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;calendar#setMinimalDaysInFirstWeek-int-&quot;&gt; &lt;code&gt;setMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; 를 호출하여 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56523d844e395cab10ecde9ba8b570825460b5cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getInstance&lt;/code&gt; factory method of the &lt;code&gt;Cipher&lt;/code&gt; engine class follows these rules in order to instantiate a provider's implementation of &lt;code&gt;CipherSpi&lt;/code&gt; for a transformation of the form &quot;</source>
          <target state="translated">&lt;code&gt;Cipher&lt;/code&gt; 엔진 클래스 의 &lt;code&gt;getInstance&lt;/code&gt; 팩토리 메소드는 &quot; 규칙 형식의 변환을 위해 제공자의 &lt;code&gt;CipherSpi&lt;/code&gt; 구현을 인스턴스화하기 위해 이러한 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f09e308477567f7fb18f8db544516ee32916e1fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getNotifTypes&lt;/code&gt; method returns an array of strings containing the notification types that the MBean may emit. The notification type is a dot-notation string which describes what the emitted notification is about, not the Java class of the notification. A single generic notification class can be used to send notifications of several types. All of these types are returned in the string array result of the &lt;code&gt;getNotifTypes&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;getNotifTypes&lt;/code&gt; 의 방법은 MBean가 방출 할 수 있다는 통지 유형을 포함하는 문자열의 배열을 반환한다. 알림 유형은 알림의 Java 클래스가 아니라 생성 된 알림에 대해 설명하는 점 표기법 문자열입니다. 단일 일반 알림 클래스를 사용하여 여러 유형의 알림을 보낼 수 있습니다. 이러한 모든 유형은 &lt;code&gt;getNotifTypes&lt;/code&gt; 메소드 의 문자열 배열 결과로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="058e0ca7376a98eb437efbc0aef64d1a8a108d0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getObjectInstance()&lt;/code&gt; method of an object factory may be invoked multiple times, possibly using different parameters. The implementation is thread-safe.</source>
          <target state="translated">객체 팩토리 의 &lt;code&gt;getObjectInstance()&lt;/code&gt; 메소드는 다른 매개 변수를 사용하여 여러 번 호출 될 수 있습니다. 구현은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6a8501111fcfea5e31cfee8d6894af584ff150ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getOptionType&lt;/code&gt; method returns this value if this &lt;code&gt;ConfirmationCallback&lt;/code&gt; was instantiated with &lt;code&gt;options&lt;/code&gt; instead of an &lt;code&gt;optionType&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;ConfirmationCallback&lt;/code&gt; 가 &lt;code&gt;optionType&lt;/code&gt; 대신에 &lt;code&gt;options&lt;/code&gt; 으로 인스턴스화 된 경우 , &lt;code&gt;getOptionType&lt;/code&gt; 메소드는이 값을 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="c8a70b914e02ddbca33ccc8428f3eed3b38dd996" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getPropertyInfo&lt;/code&gt; method is intended to allow a generic GUI tool to discover what properties it should prompt a human for in order to get enough information to connect to a database. Note that depending on the values the human has supplied so far, additional values may become necessary, so it may be necessary to iterate though several calls to the &lt;code&gt;getPropertyInfo&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;getPropertyInfo&lt;/code&gt; 방법은 일반적인 GUI 도구에서 데이터베이스로 연결하기 위해 충분한 정보를 얻을 수 있도록하기위한 프롬프트해야 할 특성을 발견 할 수 있도록하기위한 것입니다. 지금까지 인간이 제공 한 값에 따라 추가 값이 필요할 수 있으므로 &lt;code&gt;getPropertyInfo&lt;/code&gt; 메소드 에 대한 여러 호출을 반복해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ebc4bc14d6647d69c5c4a4fb63fb8fd2ffdfd9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getResources&lt;/code&gt; method of the context &lt;code&gt;ClassLoader&lt;/code&gt; is used locate JAR files containing files named &lt;code&gt;META-INF/services/javax.imageio.spi.&lt;/code&gt;</source>
          <target state="translated">컨텍스트 &lt;code&gt;ClassLoader&lt;/code&gt; 의 &lt;code&gt;getResources&lt;/code&gt; 메소드는 &lt;code&gt;META-INF/services/javax.imageio.spi.&lt;/code&gt; 라는 파일을 포함하는 JAR 파일을 찾는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2b6b51bd170eb65242dd9c81805d8ac434ccc43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getStateToBind()&lt;/code&gt; method of a state factory may be invoked multiple times, possibly using different parameters. The implementation is thread-safe.</source>
          <target state="translated">상태 팩토리 의 &lt;code&gt;getStateToBind()&lt;/code&gt; 메소드는 다른 매개 변수를 사용하여 여러 번 호출 될 수 있습니다. 구현은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4133bc1ef355b2f7d534eacc6206c1d3c4756a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;glassPane&lt;/code&gt; and &lt;code&gt;contentPane&lt;/code&gt; have the same bounds, which means &lt;code&gt;JRootPane&lt;/code&gt; does not tiles its children and this should return false.</source>
          <target state="translated">그만큼 &lt;code&gt;glassPane&lt;/code&gt; 와 &lt;code&gt;contentPane&lt;/code&gt; 같은 경계 수단이 &lt;code&gt;JRootPane&lt;/code&gt; 그 아이를 타일링하지 않고, false를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee344936fcd60a44c7aadfe704fe188c2bf05a14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;glassPane&lt;/code&gt; and &lt;code&gt;contentPane&lt;/code&gt; have the same bounds, which means &lt;code&gt;JRootPane&lt;/code&gt; does not tiles its children and this should return false. On the other hand, the &lt;code&gt;glassPane&lt;/code&gt; is normally not visible, and so this can return true if the &lt;code&gt;glassPane&lt;/code&gt; isn't visible. Therefore, the return value here depends upon the visibility of the &lt;code&gt;glassPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;glassPane&lt;/code&gt; 와 &lt;code&gt;contentPane&lt;/code&gt; 에 의미 같은 경계를 가지고 &lt;code&gt;JRootPane&lt;/code&gt; 의를 그 아이를 타일링하지 않고, false를 반환해야합니다. 한편, &lt;code&gt;glassPane&lt;/code&gt; 일반적으로 볼 수없는, 그리고 경우이 때문에 true를 반환 할 수 &lt;code&gt;glassPane&lt;/code&gt; 표시되지 않습니다. 따라서 여기서 반환 값은 &lt;code&gt;glassPane&lt;/code&gt; 의 가시성에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="c64b9cd519193ff182ca1d2c0d0b61365f9b46ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;glassPane&lt;/code&gt; fills the entire viewable area of the &lt;code&gt;JRootPane&lt;/code&gt; (bounds - insets).</source>
          <target state="translated">&lt;code&gt;glassPane&lt;/code&gt; 의 전체 가시 영역 채우고 &lt;code&gt;JRootPane&lt;/code&gt; 의 (- 세트 경계).</target>
        </trans-unit>
        <trans-unit id="303f1b7ffcb897ac198d0b32c1e4690dd69e7d53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;glassPane&lt;/code&gt; sits on top of all other components in the &lt;code&gt;JRootPane&lt;/code&gt;. That provides a convenient place to draw above all other components, and makes it possible to intercept mouse events, which is useful both for dragging and for drawing. Developers can use &lt;code&gt;setVisible&lt;/code&gt; on the &lt;code&gt;glassPane&lt;/code&gt; to control when the &lt;code&gt;glassPane&lt;/code&gt; displays over the other children. By default the &lt;code&gt;glassPane&lt;/code&gt; is not visible.</source>
          <target state="translated">&lt;code&gt;glassPane&lt;/code&gt; 의 다른 모든 구성 요소의 꼭대기에 앉아 &lt;code&gt;JRootPane&lt;/code&gt; . 이는 다른 모든 구성 요소 위에 그릴 수있는 편리한 위치를 제공하고 마우스 이벤트를 가로 챌 수있게하여 드래그 및 그리기 모두에 유용합니다. 개발자는 &lt;code&gt;glassPane&lt;/code&gt; 에서 &lt;code&gt;setVisible&lt;/code&gt; 을 사용 하여 &lt;code&gt;glassPane&lt;/code&gt; 이 다른 자식 위에 표시되는 시기를 제어 할 수 있습니다 . 기본적으로 &lt;code&gt;glassPane&lt;/code&gt; 은 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f433eca03b2eb0f32d07fb7e2e68b92fac6f3c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; method implementation checks the instance(s) of the &lt;code&gt;Callback&lt;/code&gt; object(s) passed in to retrieve or display the requested information. The following example is provided to help demonstrate what an &lt;code&gt;handle&lt;/code&gt; method implementation might look like. This example code is for guidance only. Many details, including proper error handling, are left out for simplicity.</source>
          <target state="translated">&lt;code&gt;handle&lt;/code&gt; 의 방법을 구현 검사 인스턴스 (들) &lt;code&gt;Callback&lt;/code&gt; 전달 객체 (들)를 검색 또는 요청 된 정보를 표시한다. 다음 예제는 &lt;code&gt;handle&lt;/code&gt; 메소드 구현의 모양을 보여주기 위해 제공됩니다 . 이 예제 코드는 지침 용입니다. 적절한 오류 처리를 포함하여 많은 세부 사항이 단순성을 위해 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="78806b6c0d8e3a500425fd33fe6be57433f2f45a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hashCode&lt;/code&gt; method of the returned set returns the sum of the</source>
          <target state="translated">리턴 된 세트 의 &lt;code&gt;hashCode&lt;/code&gt; 메소드는</target>
        </trans-unit>
        <trans-unit id="2f587f428ba9d70c513a6f20faefa7737e3169e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hashCode&lt;/code&gt; method uses the underlying &lt;code&gt;java.util.Date&lt;/code&gt; implementation and therefore does not include nanos in its computation.</source>
          <target state="translated">&lt;code&gt;hashCode&lt;/code&gt; 방법은 기본 사용 &lt;code&gt;java.util.Date&lt;/code&gt; 의 구현하므로 그 나노 계산에 포함되지 않는다.</target>
        </trans-unit>
        <trans-unit id="fd1ec688b3211b62ec6deea7903a4e5a33c5b1e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hostname&lt;/code&gt; argument is illegal if it:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;hostname&lt;/code&gt; 인수가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e43ec7f450994678afac7d3d20f221033df02a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hostnameVerifier&lt;/code&gt; for this object.</source>
          <target state="translated">이 객체 의 &lt;code&gt;hostnameVerifier&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a0862b9286e778fa946553866f62a5a21c32639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iconOnly&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;iconOnly&lt;/code&gt; 의 값.</target>
        </trans-unit>
        <trans-unit id="daad7e8488e5cfcb51dabab10521abe9fa406690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iconifyFrame()&lt;/code&gt; code calls this to determine the proper bounds for the desktopIcon.</source>
          <target state="translated">&lt;code&gt;iconifyFrame()&lt;/code&gt; 의 코드는이 desktopIcon의 적절한 경계를 결정하기 위해 호출합니다.</target>
        </trans-unit>
        <trans-unit id="51e65210412db39a03c74c582c66b807b1845931" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;icons&lt;/code&gt; list can contain &lt;code&gt;MultiResolutionImage&lt;/code&gt; images also. Suitable image depending on screen resolution is extracted from base &lt;code&gt;MultiResolutionImage&lt;/code&gt; image and added to the icons list while base resolution image is removed from list. The &lt;code&gt;icons&lt;/code&gt; list is scanned for the images of most appropriate dimensions from the beginning. If the list contains several images of the same size, the first will be used.</source>
          <target state="translated">&lt;code&gt;icons&lt;/code&gt; 목록에 포함 할 수 있습니다 &lt;code&gt;MultiResolutionImage&lt;/code&gt; 의 도 이미지를. 기본 &lt;code&gt;MultiResolutionImage&lt;/code&gt; 이미지 에서 화면 해상도에 따라 적합한 이미지를 추출 하여 아이콘 목록에 추가하고 기본 해상도 이미지는 목록에서 제거합니다. &lt;code&gt;icons&lt;/code&gt; 목록은 처음부터 가장 적절한 크기의 이미지를 스캔됩니다. 목록에 같은 크기의 여러 이미지가 포함 된 경우 첫 번째 이미지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a3a03a08373e3a4eb0d5649cfecb26445106e34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;identity&lt;/code&gt; value must be an identity for the accumulator function. This means that for all &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;accumulator.apply(identity, t)&lt;/code&gt; is equal to &lt;code&gt;t&lt;/code&gt;. The &lt;code&gt;accumulator&lt;/code&gt; function must be an &lt;a href=&quot;package-summary#Associativity&quot;&gt;associative&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 값은 누적 함수에 대한 식별해야한다. 이 모든 것을 의미 &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;accumulator.apply(identity, t)&lt;/code&gt; 와 동일하다 &lt;code&gt;t&lt;/code&gt; . &lt;code&gt;accumulator&lt;/code&gt; 함수가 있어야 &lt;a href=&quot;package-summary#Associativity&quot;&gt;연관&lt;/a&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="15d70cdc09c9191c55557a009f3a78afb163bfc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;identity&lt;/code&gt; value must be an identity for the accumulator function. This means that for all &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;accumulator.apply(identity, x)&lt;/code&gt; is equal to &lt;code&gt;x&lt;/code&gt;. The &lt;code&gt;accumulator&lt;/code&gt; function must be an &lt;a href=&quot;package-summary#Associativity&quot;&gt;associative&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 값은 누적 함수에 대한 식별해야한다. 이 수단은 모든 것을 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;accumulator.apply(identity, x)&lt;/code&gt; 와 동일하다 &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;accumulator&lt;/code&gt; 함수가 있어야 &lt;a href=&quot;package-summary#Associativity&quot;&gt;연관&lt;/a&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="c7c434e8ee038c0b3fcfe01a6456babfb2b633e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;identity&lt;/code&gt; value must be an identity for the combiner function. This means that for all &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;combiner(identity, u)&lt;/code&gt; is equal to &lt;code&gt;u&lt;/code&gt;. Additionally, the &lt;code&gt;combiner&lt;/code&gt; function must be compatible with the &lt;code&gt;accumulator&lt;/code&gt; function; for all &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, the following must hold:</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 값은 결합기 기능에 대한 정체성을해야합니다. 이 모든 것을 의미 &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;combiner(identity, u)&lt;/code&gt; 과 동일 &lt;code&gt;u&lt;/code&gt; . 또한 &lt;code&gt;combiner&lt;/code&gt; 기능은 &lt;code&gt;accumulator&lt;/code&gt; 기능 과 호환되어야합니다 . 모든 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;t&lt;/code&gt; 에 대해 다음을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb7b6822fbfe6353745706addd58f9b58b682324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ifAddress&lt;/code&gt; argument can be used on a multi-homed host for a &lt;code&gt;ServerSocket&lt;/code&gt; that will only accept connect requests to one of its addresses. If &lt;code&gt;ifAddress&lt;/code&gt; is null, it will accept connections on all local addresses. The socket is configured with the socket options (such as accept timeout) given to this factory.</source>
          <target state="translated">&lt;code&gt;ifAddress&lt;/code&gt; 의 인수는 대한 멀티 홈 호스트에서 사용할 수 있습니다 &lt;code&gt;ServerSocket&lt;/code&gt; 의 단지의 주소에 대한 접속 요구를 받아 들일 것입니다. 경우 &lt;code&gt;ifAddress&lt;/code&gt; 가 널 (null)이, 모든 로컬 주소에 대한 연결을 허용합니다. 소켓은이 팩토리에 제공된 소켓 옵션 (예 : 승인 시간 종료)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9d4aa0ca4766a00288d0853e4d6293a48f65d87d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignoreMetadata&lt;/code&gt; parameter, if set to &lt;code&gt;true&lt;/code&gt;, allows the reader to disregard any metadata encountered during the read. Subsequent calls to the &lt;code&gt;getStreamMetadata&lt;/code&gt; and &lt;code&gt;getImageMetadata&lt;/code&gt; methods may return &lt;code&gt;null&lt;/code&gt;, and an &lt;code&gt;IIOImage&lt;/code&gt; returned from &lt;code&gt;readAll&lt;/code&gt; may return &lt;code&gt;null&lt;/code&gt; from their &lt;code&gt;getMetadata&lt;/code&gt; method. Setting this parameter may allow the reader to work more efficiently. The reader may choose to disregard this setting and return metadata normally.</source>
          <target state="translated">&lt;code&gt;ignoreMetadata&lt;/code&gt; 의 로 설정하면 매개 변수는 &lt;code&gt;true&lt;/code&gt; , 읽기 중에 발생한 메타 데이타를 리더가 무시할 수 있습니다. 받는 후속 호출 &lt;code&gt;getStreamMetadata&lt;/code&gt; 및 &lt;code&gt;getImageMetadata&lt;/code&gt; 방법은 반환 할 수 있습니다 &lt;code&gt;null&lt;/code&gt; , 그리고 &lt;code&gt;IIOImage&lt;/code&gt; 에 에서 반환 &lt;code&gt;readAll&lt;/code&gt; 반환 할 수 있습니다 &lt;code&gt;null&lt;/code&gt; 자신의에서 &lt;code&gt;getMetadata&lt;/code&gt; 방법. 이 매개 변수를 설정하면 리더가 더 효율적으로 작동 할 수 있습니다. 독자는이 설정을 무시하고 메타 데이터를 정상적으로 반환하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a61b8b43c5d10d1b00563be9b1b6cef6be194e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;imageUpdate&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; incrementally draws an image on the component as more of the bits of the image are available.</source>
          <target state="translated">&lt;code&gt;imageUpdate&lt;/code&gt; 방법 &lt;code&gt;Component&lt;/code&gt; 더 많은 이미지 비트를 사용할 수있을 때 구성 요소에 이미지를 점진적으로 그립니다.</target>
        </trans-unit>
        <trans-unit id="fd6a40388fc0550eb7dfd1739f418989dfe9f308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;implies&lt;/code&gt; method is used by the AccessController to determine whether or not a requested permission is implied by another permission that is known to be valid in the current execution context.</source>
          <target state="translated">는 &lt;code&gt;implies&lt;/code&gt; 방법은 권한 요청이 현재 실행 콘텍스트에서 유효한 것으로 알려진 다른 권한에 의해 암시되는 여부를 결정하기 위해 AccessController에 의해 사용된다.</target>
        </trans-unit>
        <trans-unit id="99323cb09ca7a1b5b3ed49e52564ae4467d979f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inactiveObject&lt;/code&gt; call informs the &lt;code&gt;ActivationMonitor&lt;/code&gt; that the remote object reference it holds for the object with the activation identifier, &lt;code&gt;id&lt;/code&gt;, is no longer valid. The monitor considers the reference associated with &lt;code&gt;id&lt;/code&gt; as a stale reference. Since the reference is considered stale, a subsequent &lt;code&gt;activate&lt;/code&gt; call for the same activation identifier results in re-activating the remote object.</source>
          <target state="translated">&lt;code&gt;inactiveObject&lt;/code&gt; 호출 알리는 &lt;code&gt;ActivationMonitor&lt;/code&gt; 에 원격 개체 참조가 기동 식별자 보유 개체 즉, &lt;code&gt;id&lt;/code&gt; 더 이상 유효하지 않다. 모니터는 &lt;code&gt;id&lt;/code&gt; 와 연관된 참조를 부실 참조로 간주합니다 . 참조가 오래된 것으로 간주되므로 후속 &lt;code&gt;activate&lt;/code&gt; 동일한 활성화 식별자에 대한 호출은 원격 개체를 다시 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dc20171b44b44f5f3758ac37b7d5a7ded6f19e83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; is defined to be out of bounds if any of the following inequalities is true:</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 다음과 같은 불평등 중 하나에 해당하는 경우 아웃 오브 바운드로 정의된다 :</target>
        </trans-unit>
        <trans-unit id="5f5eaf7ade6f853439e4b56543435a4f43f085fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; parameter is the index of the name element to return. The element that is &lt;em&gt;closest&lt;/em&gt; to the root in the directory hierarchy has index &lt;code&gt;0&lt;/code&gt;. The element that is &lt;em&gt;farthest&lt;/em&gt; from the root has index &lt;a href=&quot;#getNameCount()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 매개 변수는 반환 할 이름 요소의 인덱스입니다. 디렉토리 계층 구조에서 루트에 &lt;em&gt;가장 가까운&lt;/em&gt; 요소 에는 인덱스 &lt;code&gt;0&lt;/code&gt; 이 있습니다. 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 요소의 인덱스 &lt;a href=&quot;#getNameCount()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64642e3202227bf1eb96b4d1dcff39ebc286b611" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; parameter is the index of the name element to return. The element that is &lt;em&gt;closest&lt;/em&gt; to the root in the directory hierarchy has index &lt;code&gt;0&lt;/code&gt;. The element that is &lt;em&gt;farthest&lt;/em&gt; from the root has index &lt;a href=&quot;path#getNameCount--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 매개 변수는 반환 할 이름 요소의 인덱스입니다. 디렉토리 계층에서 루트에 &lt;em&gt;가장 가까운&lt;/em&gt; 요소의 인덱스는 &lt;code&gt;0&lt;/code&gt; 입니다. 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 요소의 인덱스 &lt;a href=&quot;path#getNameCount--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ba30d2da47964c5ec7ffd415d13cac0e4683bed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infoflags&lt;/code&gt; argument should be the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of the following flags: &lt;code&gt;WIDTH&lt;/code&gt;, &lt;code&gt;HEIGHT&lt;/code&gt;, &lt;code&gt;PROPERTIES&lt;/code&gt;, &lt;code&gt;SOMEBITS&lt;/code&gt;, &lt;code&gt;FRAMEBITS&lt;/code&gt;, &lt;code&gt;ALLBITS&lt;/code&gt;, &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;ABORT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;infoflags&lt;/code&gt; 인수는 비트 포함해야 &lt;b&gt;OR&lt;/b&gt; : 다음 플래그의 &lt;code&gt;WIDTH&lt;/code&gt; , &lt;code&gt;HEIGHT&lt;/code&gt; , &lt;code&gt;PROPERTIES&lt;/code&gt; , &lt;code&gt;SOMEBITS&lt;/code&gt; , &lt;code&gt;FRAMEBITS&lt;/code&gt; , &lt;code&gt;ALLBITS&lt;/code&gt; , &lt;code&gt;ERROR&lt;/code&gt; , &lt;code&gt;ABORT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd34925c76b9aa7f124b7924e51f96a4065ec4cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; handle describes the initial value of an additional optional loop-local variable. In each iteration, this loop-local variable, if present, will be passed to the &lt;code&gt;body&lt;/code&gt; and updated with the value returned from its invocation. The result of loop execution will be the final value of the additional loop-local variable (if present).</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 핸들 부가 선택적 루프 로컬 변수의 초기 값을 설명한다. 각 반복에서이 루프 로컬 변수 (있는 경우)는 &lt;code&gt;body&lt;/code&gt; 전달됩니다. 호출에서 반환 된 값으로 업데이트됩니다. 루프 실행의 결과는 추가 루프 로컬 변수 (있는 경우)의 최종 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="a4d191b328a1c5a3fb19ebaef345b041450f0653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initEvent&lt;/code&gt; method is used to initialize the value of an &lt;code&gt;Event&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;initEvent&lt;/code&gt; 방법은의 값을 초기화하는 데 사용되는 &lt;code&gt;Event&lt;/code&gt; 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스.</target>
        </trans-unit>
        <trans-unit id="e980ab2973cbdf463d4df8c8ce1591af9572002f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initEvent&lt;/code&gt; method is used to initialize the value of an &lt;code&gt;Event&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface. This method may only be called before the &lt;code&gt;Event&lt;/code&gt; has been dispatched via the &lt;code&gt;dispatchEvent&lt;/code&gt; method, though it may be called multiple times during that phase if necessary. If called multiple times the final invocation takes precedence. If called from a subclass of &lt;code&gt;Event&lt;/code&gt; interface only the values specified in the &lt;code&gt;initEvent&lt;/code&gt; method are modified, all other attributes are left unchanged.</source>
          <target state="translated">&lt;code&gt;initEvent&lt;/code&gt; 방법은의 값을 초기화하는 데 사용되는 &lt;code&gt;Event&lt;/code&gt; 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스. 이 메서드는 &lt;code&gt;dispatchEvent&lt;/code&gt; 메서드 를 통해 &lt;code&gt;Event&lt;/code&gt; 가 전달 되기 전에 만 호출 될 수 있지만 필요한 경우 해당 단계에서 여러 번 호출 될 수 있습니다. 여러 번 호출되면 최종 호출이 우선합니다. &lt;code&gt;Event&lt;/code&gt; 인터페이스 의 하위 클래스에서 호출 되면 &lt;code&gt;initEvent&lt;/code&gt; 메서드에 지정된 값만 수정되고 다른 모든 속성은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e79e9c0595f3db6eb879c2cd4bff42c0c8821e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initMouseEvent&lt;/code&gt; method is used to initialize the value of a &lt;code&gt;MouseEvent&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;initMouseEvent&lt;/code&gt; 방법은 값을 초기화하는 데 사용 &lt;code&gt;MouseEvent&lt;/code&gt; 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스.</target>
        </trans-unit>
        <trans-unit id="fbeef5c0517fc941e5840401645ff8bb1740d90c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initMouseEvent&lt;/code&gt; method is used to initialize the value of a &lt;code&gt;MouseEvent&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface. This method may only be called before the &lt;code&gt;MouseEvent&lt;/code&gt; has been dispatched via the &lt;code&gt;dispatchEvent&lt;/code&gt; method, though it may be called multiple times during that phase if necessary. If called multiple times, the final invocation takes precedence.</source>
          <target state="translated">&lt;code&gt;initMouseEvent&lt;/code&gt; 방법은 값을 초기화하는 데 사용 &lt;code&gt;MouseEvent&lt;/code&gt; 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스. 이 메서드는 &lt;code&gt;dispatchEvent&lt;/code&gt; 메서드 를 통해 &lt;code&gt;MouseEvent&lt;/code&gt; 가 전달 되기 전에 만 호출 될 수 있지만 필요한 경우 해당 단계에서 여러 번 호출 될 수 있습니다. 여러 번 호출하면 최종 호출이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="625a8b0abe6c5b47d1eefb61955bc931458fce29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initMutationEvent&lt;/code&gt; method is used to initialize the value of a &lt;code&gt;MutationEvent&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;initMutationEvent&lt;/code&gt; 방법은 값을 초기화하는 데 사용되는 &lt;code&gt;MutationEvent&lt;/code&gt; 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스.</target>
        </trans-unit>
        <trans-unit id="254b29b2d9aabd1ae0ea96ab048a74c10af149c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initMutationEvent&lt;/code&gt; method is used to initialize the value of a &lt;code&gt;MutationEvent&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface. This method may only be called before the &lt;code&gt;MutationEvent&lt;/code&gt; has been dispatched via the &lt;code&gt;dispatchEvent&lt;/code&gt; method, though it may be called multiple times during that phase if necessary. If called multiple times, the final invocation takes precedence.</source>
          <target state="translated">&lt;code&gt;initMutationEvent&lt;/code&gt; 방법은 값을 초기화하는 데 사용되는 &lt;code&gt;MutationEvent&lt;/code&gt; 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스. 전과이 방법은 호출 할 수 &lt;code&gt;MutationEvent&lt;/code&gt; 이 비아 파견 된 &lt;code&gt;dispatchEvent&lt;/code&gt; 에 메서드 될 수 있지만 필요한 경우 해당 단계에서 여러 번 호출 될 수 있습니다. 여러 번 호출하면 최종 호출이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="0031ccc968fa433b9c0ee69137ad1acff5549339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initUIEvent&lt;/code&gt; method is used to initialize the value of a &lt;code&gt;UIEvent&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;initUIEvent&lt;/code&gt; 의 방법은 값을 초기화하는 데 사용되는 &lt;code&gt;UIEvent&lt;/code&gt; 를 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스.</target>
        </trans-unit>
        <trans-unit id="f5e2a52bd2dedb43955ead95d35976c3258ced77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initUIEvent&lt;/code&gt; method is used to initialize the value of a &lt;code&gt;UIEvent&lt;/code&gt; created through the &lt;code&gt;DocumentEvent&lt;/code&gt; interface. This method may only be called before the &lt;code&gt;UIEvent&lt;/code&gt; has been dispatched via the &lt;code&gt;dispatchEvent&lt;/code&gt; method, though it may be called multiple times during that phase if necessary. If called multiple times, the final invocation takes precedence.</source>
          <target state="translated">&lt;code&gt;initUIEvent&lt;/code&gt; 의 방법은 값을 초기화하는 데 사용되는 &lt;code&gt;UIEvent&lt;/code&gt; 를 관통 생성 &lt;code&gt;DocumentEvent&lt;/code&gt; 인터페이스. 이 메서드는 &lt;code&gt;dispatchEvent&lt;/code&gt; 메서드 를 통해 &lt;code&gt;UIEvent&lt;/code&gt; 가 전달 되기 전에 만 호출 될 수 있지만 필요한 경우 해당 단계에서 여러 번 호출 될 수 있습니다. 여러 번 호출하면 최종 호출이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="178fa46f7783f7ca8be10feb795a8f432e6ce094" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialSize&lt;/code&gt; parameter may be used by the implementation as a &lt;em&gt;hint&lt;/em&gt; as to the initial number of tasks it may submit. For example, it may be used to indicate the initial number of threads that wait on I/O events.</source>
          <target state="translated">&lt;code&gt;initialSize&lt;/code&gt; 가의 매개 변수는 같은 구현에 의해 사용될 수있는 &lt;em&gt;힌트&lt;/em&gt; 가 제출할 수 작업의 초기 수있다. 예를 들어, I / O 이벤트를 기다리는 초기 스레드 수를 나타내는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bd09b116084a74e12383d4253d1c5f87a806306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialize&lt;/code&gt; methods may each be called any number of times. If no &lt;code&gt;initialize&lt;/code&gt; method is called on a DSAKeyPairGenerator, each provider that implements this interface should supply (and document) a default initialization. Note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the DSAKeyPairGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">&lt;code&gt;initialize&lt;/code&gt; 방법은 각각 여러 번 호출 할 수 있습니다. DSAKeyPairGenerator에서 &lt;code&gt;initialize&lt;/code&gt; 메서드가 호출 되지 않으면 이 인터페이스를 구현하는 각 공급자는 기본 초기화를 제공하고 문서화해야합니다. 기본값은 제공 업체에 따라 다를 수 있습니다. 또한 공급자의 기본값은 향후 버전에서 변경 될 수 있습니다. 따라서 공급자 별 기본값에 의존하는 대신 DSAKeyPairGenerator를 명시 적으로 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8e1910412b5ab4f4360c75fcf4e4c4f981f39033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialize&lt;/code&gt; methods may each be called any number of times. If no &lt;code&gt;initialize&lt;/code&gt; method is called on a DSAKeyPairGenerator, the default is to generate 1024-bit keys, using precomputed p, q and g parameters and an instance of SecureRandom as the random bit source.</source>
          <target state="translated">&lt;code&gt;initialize&lt;/code&gt; 방법은 각각 여러 번 호출 할 수 있습니다. DSAKeyPairGenerator에서 &lt;code&gt;initialize&lt;/code&gt; 메소드가 호출 되지 않은 경우 기본값은 사전 계산 된 p, q 및 g 매개 변수와 SecureRandom 인스턴스를 임의의 비트 소스로 사용하여 1024 비트 키를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e89c947619670b6f05ed77c9eb43708ff984ab4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;abstract&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;abstract&lt;/code&gt; 수정합니다.</target>
        </trans-unit>
        <trans-unit id="57a2bf2f87f99f529f820792d0d9541859c36200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;final&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;final&lt;/code&gt; 수정 자.</target>
        </trans-unit>
        <trans-unit id="b83b91795fa9f3dd467562df8b850ad43ca35b18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;interface&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;interface&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="6e6129e278d1c31b1641cf76868b23a7ccbc053b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;native&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;native&lt;/code&gt; 수정합니다.</target>
        </trans-unit>
        <trans-unit id="9487f7c45da0d56c561a74e7e315aad283ae33db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;private&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;private&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="d998015ddde224da2f2e242d06b1b5cda8342b93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;protected&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;protected&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="1ab9b738d34103d531a4ba5cdf4833da76ab4445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;public&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;public&lt;/code&gt; 수정합니다.</target>
        </trans-unit>
        <trans-unit id="cb450909d14452e1607d3359ccbe310b15e65773" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;static&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;static&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="e48ba12a5c869896a959b271934ece28496f4515" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;strictfp&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;strictfp&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="ab15ce0d3f3e80624e13e8b8f7afdae7f2cc31b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;synchronized&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;synchronized&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="47c273abe027c89df6d6ce37e4c65a5d5f445ccc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;transient&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;transient&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="75d6fc286ca2b46ac7f2dfbb0cff289b6c5d7d46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; value representing the &lt;code&gt;volatile&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 나타내는 값 &lt;code&gt;volatile&lt;/code&gt; 수정합니다.</target>
        </trans-unit>
        <trans-unit id="cfd98033227ef6b3a7f984e0cf8a786a155a86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interface&lt;/code&gt; modifier discussed in this class is not a true modifier in the Java language and it appears after all other modifiers listed by this method. This method may return a string of modifiers that are not valid modifiers of a Java entity; in other words, no checking is done on the possible validity of the combination of modifiers represented by the input. Note that to perform such checking for a known kind of entity, such as a constructor or method, first AND the argument of &lt;code&gt;toString&lt;/code&gt; with the appropriate mask from a method like &lt;a href=&quot;#constructorModifiers()&quot;&gt;&lt;code&gt;constructorModifiers()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#methodModifiers()&quot;&gt;&lt;code&gt;methodModifiers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스에서 설명 하는 &lt;code&gt;interface&lt;/code&gt; 수정자는 Java 언어의 실제 수정자가 아니며이 메소드에 의해 나열된 다른 모든 수정 자 뒤에 나타납니다. 이 메소드는 Java 엔티티의 유효한 수정자가 아닌 수정 자 문자열을 리턴 할 수 있습니다. 즉, 입력으로 표시되는 수정 자 조합의 가능한 유효성에 대한 검사가 수행되지 않습니다. 생성자 또는 메서드와 같은 알려진 종류의 엔티티에 대해 이러한 검사를 수행하려면 먼저 &lt;a href=&quot;#constructorModifiers()&quot;&gt; &lt;code&gt;constructorModifiers()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#methodModifiers()&quot;&gt; &lt;code&gt;methodModifiers()&lt;/code&gt; &lt;/a&gt; 와 같은 메서드의 적절한 마스크를 사용하여 &lt;code&gt;toString&lt;/code&gt; 인수를 AND합니다 .</target>
        </trans-unit>
        <trans-unit id="cfcd94506157aeb895a9c9c21b22d64a6d79a08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interface&lt;/code&gt; modifier discussed in this class is not a true modifier in the Java language and it appears after all other modifiers listed by this method. This method may return a string of modifiers that are not valid modifiers of a Java entity; in other words, no checking is done on the possible validity of the combination of modifiers represented by the input. Note that to perform such checking for a known kind of entity, such as a constructor or method, first AND the argument of &lt;code&gt;toString&lt;/code&gt; with the appropriate mask from a method like &lt;a href=&quot;modifier#constructorModifiers--&quot;&gt;&lt;code&gt;constructorModifiers()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;modifier#methodModifiers--&quot;&gt;&lt;code&gt;methodModifiers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt; 이 클래스에서 논의 수정은 자바 언어의 진정한 수정하지 않고는이 방법에 의해 나열된 다른 모든 수정 후에 나타납니다. 이 메소드는 Java 엔티티의 유효한 수정자가 아닌 수정 자의 문자열을 리턴 할 수 있습니다. 즉, 입력으로 표시되는 수정 자 조합의 가능한 유효성에 대해서는 점검이 수행되지 않습니다. 생성자 또는 메소드와 같은 알려진 유형의 엔티티에 대해 이러한 검사를 수행하려면 먼저 &lt;a href=&quot;modifier#constructorModifiers--&quot;&gt; &lt;code&gt;constructorModifiers()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;modifier#methodModifiers--&quot;&gt; &lt;code&gt;methodModifiers()&lt;/code&gt; &lt;/a&gt; 와 같은 메소드에서 적절한 마스크를 사용하여 &lt;code&gt;toString&lt;/code&gt; 의 인수를 AND하십시오 .</target>
        </trans-unit>
        <trans-unit id="58627a573928318b0e86229e8345a42317bf4581" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;invokedynamic&lt;/code&gt; instruction makes use of bootstrap &lt;code&gt;MethodHandle&lt;/code&gt; constants to dynamically resolve &lt;code&gt;CallSite&lt;/code&gt; objects for custom method invocation behavior.</source>
          <target state="translated">&lt;code&gt;invokedynamic&lt;/code&gt; 명령 차종은 부트 스트랩의 사용 &lt;code&gt;MethodHandle&lt;/code&gt; 의 동적 해결하기 위해 상수 &lt;code&gt;CallSite&lt;/code&gt; 는 사용자 정의 메소드 호출 동작에 대한 객체.</target>
        </trans-unit>
        <trans-unit id="665a37a65bad1ed4e2e3237e067bfa95f31eb667" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isContainer&lt;/code&gt;&lt;a href=&quot;../../java/beans/featuredescriptor#getValue(java.lang.String)&quot;&gt;&lt;code&gt;feature attribute&lt;/code&gt;&lt;/a&gt; was introduced primarily for the Swing library. All Swing components extend the &lt;a href=&quot;../../java/awt/container&quot;&gt;&lt;code&gt;Container&lt;/code&gt;&lt;/a&gt; class by design, so the builder tool assumes that all Swing components are containers. The &lt;a href=&quot;../../java/beans/beaninfo&quot;&gt;&lt;code&gt;BeanInfo&lt;/code&gt;&lt;/a&gt; classes with the &lt;code&gt;isContainer&lt;/code&gt; attribute allow to directly specify whether a Swing component is a container or not.</source>
          <target state="translated">&lt;code&gt;isContainer&lt;/code&gt; 의&lt;a href=&quot;../../java/beans/featuredescriptor#getValue(java.lang.String)&quot;&gt; &lt;code&gt;feature attribute&lt;/code&gt; &lt;/a&gt; 주로 스윙 라이브러리에 대한 소개되었다. 모든 Swing 구성 요소는 설계에 따라 &lt;a href=&quot;../../java/awt/container&quot;&gt; &lt;code&gt;Container&lt;/code&gt; &lt;/a&gt; 클래스를 확장 하므로 빌더 도구는 모든 Swing 구성 요소가 컨테이너라고 가정합니다. &lt;a href=&quot;../../java/beans/beaninfo&quot;&gt; &lt;code&gt;BeanInfo&lt;/code&gt; &lt;/a&gt; 와 클래스 &lt;code&gt;isContainer&lt;/code&gt; 의 속성은 직접 스윙 구성 요소가 컨테이너인지 여부를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbbe4efb7b82c12416112b91d882adb2461b3096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isEnabled&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;isEnabled&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="f254cbd5db1e9d15f5755ade659caa4db237d900" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isMixerSupported&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; for all the info objects returned by this method. The corresponding mixer instances for the info objects are returned by the &lt;code&gt;getMixer&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;isMixerSupported&lt;/code&gt; 의 메소드가 리턴 &lt;code&gt;true&lt;/code&gt; 모든 정보를이 메소드에 의해 반환되는 객체. info 객체의 해당 믹서 인스턴스는 &lt;code&gt;getMixer&lt;/code&gt; 메서드에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc647a7047b23398301d649428d6203301b91e91" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterations&lt;/code&gt; handle must not be &lt;code&gt;null&lt;/code&gt;, and must return the type &lt;code&gt;int&lt;/code&gt;, referred to here as &lt;code&gt;I&lt;/code&gt; in parameter type lists.</source>
          <target state="translated">&lt;code&gt;iterations&lt;/code&gt; 핸들이 아니어야 &lt;code&gt;null&lt;/code&gt; , 및 유형의 반환해야 &lt;code&gt;int&lt;/code&gt; , 여기에 언급 &lt;code&gt;I&lt;/code&gt; 매개 변수 유형 목록에.</target>
        </trans-unit>
        <trans-unit id="faab6cad1b99da33b71348933be79609cd1c2d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.awt.TextArea&lt;/code&gt; could be monitored for changes by adding a &lt;code&gt;TextListener&lt;/code&gt; for &lt;code&gt;TextEvent&lt;/code&gt;s. In the &lt;code&gt;JTextComponent&lt;/code&gt; based components, changes are broadcasted from the model via a &lt;code&gt;DocumentEvent&lt;/code&gt; to &lt;code&gt;DocumentListeners&lt;/code&gt;. The &lt;code&gt;DocumentEvent&lt;/code&gt; gives the location of the change and the kind of change if desired. The code fragment might look something like:</source>
          <target state="translated">&lt;code&gt;java.awt.TextArea&lt;/code&gt; 의는 추가하는 것으로 써 변화를 모니터링 할 수있다 &lt;code&gt;TextListener&lt;/code&gt; 에 대한 &lt;code&gt;TextEvent&lt;/code&gt; 의 들. 에서 &lt;code&gt;JTextComponent&lt;/code&gt; 에 기초하여 구성 요소의 변화는 모델을 통해 방송된다 &lt;code&gt;DocumentEvent&lt;/code&gt; 에 &lt;code&gt;DocumentListeners&lt;/code&gt; . &lt;code&gt;DocumentEvent&lt;/code&gt; 변화의 위치 변경의 종류를 제공한다. 코드 조각은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55efcc9383d4d056ce334accbd6b2bac39494936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.awt.TextArea&lt;/code&gt; has the ability to do line wrapping. This was controlled by the horizontal scrolling policy. Since scrolling is not done by &lt;code&gt;JTextArea&lt;/code&gt; directly, backward compatibility must be provided another way. &lt;code&gt;JTextArea&lt;/code&gt; has a bound property for line wrapping that controls whether or not it will wrap lines. By default, the line wrapping property is set to false (not wrapped).</source>
          <target state="translated">&lt;code&gt;java.awt.TextArea&lt;/code&gt; 의은 줄 바꿈을 할 수있는 능력을 가지고 있습니다. 이것은 수평 스크롤 정책에 의해 제어되었습니다. 스크롤링은 &lt;code&gt;JTextArea&lt;/code&gt; 에 의해 직접 수행되지 않으므로 이전 버전과의 호환성을 다른 방법으로 제공해야합니다. &lt;code&gt;JTextArea&lt;/code&gt; 에는 줄 바꿈 여부를 제어하는 ​​줄 바꿈에 대한 바운드 속성이 있습니다. 기본적으로 줄 바꿈 속성은 false (줄 바꿈되지 않음)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c0fcfe43cbce6a18be4a70c21673c0e92d35fccc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.awt.TextArea&lt;/code&gt; internally handles scrolling. &lt;code&gt;JTextArea&lt;/code&gt; is different in that it doesn't manage scrolling, but implements the swing &lt;code&gt;Scrollable&lt;/code&gt; interface. This allows it to be placed inside a &lt;code&gt;JScrollPane&lt;/code&gt; if scrolling behavior is desired, and used directly if scrolling is not desired.</source>
          <target state="translated">&lt;code&gt;java.awt.TextArea&lt;/code&gt; 의는 내부적으로 스크롤을 처리합니다. &lt;code&gt;JTextArea&lt;/code&gt; 는 스크롤링을 관리하지 않고 스윙 &lt;code&gt;Scrollable&lt;/code&gt; 인터페이스를 구현한다는 점에서 다릅니다 . 이렇게하면 스크롤 동작이 필요한 경우 &lt;code&gt;JScrollPane&lt;/code&gt; 내부에 배치 할 수 있고 스크롤을 원하지 않는 경우 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0db34ffc0a9406c8096ce234b9fa75533ba4eff0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.awt.TextField&lt;/code&gt; could be monitored for changes by adding a &lt;code&gt;TextListener&lt;/code&gt; for &lt;code&gt;TextEvent&lt;/code&gt;'s. In the &lt;code&gt;JTextComponent&lt;/code&gt; based components, changes are broadcasted from the model via a &lt;code&gt;DocumentEvent&lt;/code&gt; to &lt;code&gt;DocumentListeners&lt;/code&gt;. The &lt;code&gt;DocumentEvent&lt;/code&gt; gives the location of the change and the kind of change if desired. The code fragment might look something like:</source>
          <target state="translated">&lt;code&gt;java.awt.TextField&lt;/code&gt; 의는 추가하는 것으로 써 변화를 모니터링 할 수있다 &lt;code&gt;TextListener&lt;/code&gt; 에 대한 &lt;code&gt;TextEvent&lt;/code&gt; 의 의를. 에서 &lt;code&gt;JTextComponent&lt;/code&gt; 에 기초하여 구성 요소의 변화는 모델을 통해 방송된다 &lt;code&gt;DocumentEvent&lt;/code&gt; 에 &lt;code&gt;DocumentListeners&lt;/code&gt; . &lt;code&gt;DocumentEvent&lt;/code&gt; 변화의 위치 변경의 종류를 제공한다. 코드 조각은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bec8b9be4298b00c09430efa2b0f3eff6e4f2e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.lang.invoke&lt;/code&gt; package contains dynamic language support provided directly by the Java core class libraries and virtual machine.</source>
          <target state="translated">&lt;code&gt;java.lang.invoke&lt;/code&gt; 의 패키지는 자바 코어 클래스 라이브러리 및 가상 머신에 의해 직접 제공 동적 언어 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0a41816ff2f5ea5a0a95f8f418989d42132101f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.lang.invoke&lt;/code&gt; package provides low-level primitives for interacting with the Java Virtual Machine.</source>
          <target state="translated">&lt;code&gt;java.lang.invoke&lt;/code&gt; 의 패키지는 자바 가상 머신과 상호 작용을위한 저수준 요소를 제공한다.</target>
        </trans-unit>
        <trans-unit id="e2e6b7ef82a944f100ddc377e04a645035f44c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.nio&lt;/code&gt; package defines the buffer classes, which are used throughout the NIO APIs. The charset API is defined in the &lt;a href=&quot;charset/package-summary&quot;&gt;&lt;code&gt;java.nio.charset&lt;/code&gt;&lt;/a&gt; package, and the channel and selector APIs are defined in the &lt;a href=&quot;channels/package-summary&quot;&gt;&lt;code&gt;java.nio.channels&lt;/code&gt;&lt;/a&gt; package. Each of these subpackages has its own service-provider (SPI) subpackage, the contents of which can be used to extend the platform's default implementations or to construct alternative implementations.</source>
          <target state="translated">&lt;code&gt;java.nio&lt;/code&gt; 에서의 패키지는 NIO API 전체로 사용하는 버퍼 클래스를 정의한다. charset API는 &lt;a href=&quot;charset/package-summary&quot;&gt; &lt;code&gt;java.nio.charset&lt;/code&gt; &lt;/a&gt; 패키지에 정의되어 있으며 채널 및 선택기 API는 &lt;a href=&quot;channels/package-summary&quot;&gt; &lt;code&gt;java.nio.channels&lt;/code&gt; &lt;/a&gt; 패키지에 정의되어 있습니다. 각 서브 패키지에는 자체 SPI (Service-Provider) 서브 패키지가 있으며 그 내용은 플랫폼의 기본 구현을 확장하거나 대체 구현을 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169158b25e43c0b1b051996b7d7ecf8990270082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.security.ProtectionDomain&lt;/code&gt; of a proxy class is the same as that of system classes loaded by the bootstrap class loader, such as &lt;code&gt;java.lang.Object&lt;/code&gt;, because the code for a proxy class is generated by trusted system code. This protection domain will typically be granted &lt;code&gt;java.security.AllPermission&lt;/code&gt;.</source>
          <target state="translated">프록시 클래스 의 코드는 신뢰할 수있는 시스템 코드에 의해 생성되므로 프록시 클래스 의 &lt;code&gt;java.security.ProtectionDomain&lt;/code&gt; 은 부트 스트랩 클래스 로더가로드 한 시스템 클래스 (예 : &lt;code&gt;java.lang.Object&lt;/code&gt; ) 와 동일 합니다. 이 보호 도메인에는 일반적으로 &lt;code&gt;java.security.AllPermission&lt;/code&gt; 이 부여 됩니다.</target>
        </trans-unit>
        <trans-unit id="9813f685206a1823081b6d834a2cc39d317ab3f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.security.acl &lt;/code&gt; package provides the interfaces to the ACL and related data structures (ACL entries, groups, permissions, etc.), and the &lt;code&gt;sun.security.acl &lt;/code&gt; classes provide a default implementation of the interfaces. For example, &lt;code&gt;java.security.acl.Acl &lt;/code&gt; provides the interface to an ACL and the &lt;code&gt;sun.security.acl.AclImpl &lt;/code&gt; class provides the default implementation of the interface.</source>
          <target state="translated">&lt;code&gt;java.security.acl &lt;/code&gt; 의 용 패키지는 ACL 및 관련된 데이터 구조에 대한 인터페이스 (ACL 엔트리 그룹, 권한 등)를 제공하고, &lt;code&gt;sun.security.acl &lt;/code&gt; 클래스 인터페이스의 기본 구현을 제공한다. 예를 들어, &lt;code&gt;java.security.acl.Acl &lt;/code&gt; 은 ACL에 대한 인터페이스를 제공하고 &lt;code&gt;sun.security.acl.AclImpl &lt;/code&gt; 클래스는 인터페이스의 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cfb4c2fdc7d8d17ba626b9a63de7a2721320820c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.security.acl.Acl &lt;/code&gt; interface extends the &lt;code&gt;java.security.acl.Owner &lt;/code&gt; interface. The Owner interface is used to maintain a list of owners for each ACL. Only owners are allowed to modify an ACL. For example, only an owner can call the ACL's &lt;code&gt;addEntry&lt;/code&gt; method to add a new ACL entry to the ACL.</source>
          <target state="translated">&lt;code&gt;java.security.acl.Acl &lt;/code&gt; 의의 인터페이스는 확장 &lt;code&gt;java.security.acl.Owner &lt;/code&gt; 에의 인터페이스를. 소유자 인터페이스는 각 ACL의 소유자 목록을 유지하는 데 사용됩니다. 소유자 만 ACL을 수정할 수 있습니다. 예를 들어, 소유자 만 ACL의 &lt;code&gt;addEntry&lt;/code&gt; 메소드를 호출하여 ACL 에 새 ACL 항목을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784b90ba50939cbb669846b289f22423e455bd4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.sql&lt;/code&gt; package contains API for the following:</source>
          <target state="translated">&lt;code&gt;java.sql&lt;/code&gt; 패키지는 다음을위한 API가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="c584f80333ee86bf0587299c7f49da992c3a95b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.time.chrono&lt;/code&gt; package contains the calendar neutral API &lt;a href=&quot;chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;chrono/chronolocaldatetime&quot;&gt;&lt;code&gt;ChronoLocalDateTime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;chrono/chronozoneddatetime&quot;&gt;&lt;code&gt;ChronoZonedDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chrono/era&quot;&gt;&lt;code&gt;Era&lt;/code&gt;&lt;/a&gt;. This is intended for use by applications that need to use localized calendars. It is recommended that applications use the ISO-8601 date and time classes from this package across system boundaries, such as to the database or across the network. The calendar neutral API should be reserved for interactions with users.</source>
          <target state="translated">&lt;code&gt;java.time.chrono&lt;/code&gt; 의 패키지는 달력 중립 API 포함 &lt;a href=&quot;chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;chrono/chronolocaldatetime&quot;&gt; &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;chrono/chronozoneddatetime&quot;&gt; &lt;code&gt;ChronoZonedDateTime&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;chrono/era&quot;&gt; &lt;code&gt;Era&lt;/code&gt; &lt;/a&gt; . 현지화 된 달력을 사용해야하는 응용 프로그램에서 사용하기위한 것입니다. 응용 프로그램은 데이터베이스 또는 네트워크와 같은 시스템 경계에서이 패키지의 ISO-8601 날짜 및 시간 클래스를 사용하는 것이 좋습니다. 캘린더 중립 API는 사용자와의 상호 작용을 위해 예약되어야합니다.</target>
        </trans-unit>
        <trans-unit id="dd3f9283b71471748cf9a84dacce07bc07e230bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.imageio.spi&lt;/code&gt; package contains service provider interfaces for reading, writing, and transcoding images, and obtaining image input and output streams, as well as a run-time registry that discovers installed instances of Image I/O service providers and allows new instances to be registered dynamically.</source>
          <target state="translated">&lt;code&gt;javax.imageio.spi&lt;/code&gt; 의의 패키지는 발견하여 이미지의 경우 I / O 서비스 제공 업체를 설치하고 새로운 수 있다는 점, 읽기, 쓰기 및 이미지를 트랜스 코딩, 이미지 입력 및 출력 스트림을 취득뿐만 아니라 런타임 레지스트리에 대한 서비스 프로 바이더 인터페이스를 포함 동적으로 등록 할 인스턴스.</target>
        </trans-unit>
        <trans-unit id="31f5723f716d2e10c3dc95d349885c1c4063b2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.imageio.spi&lt;/code&gt; package contains service provider interfaces for reading, writing, and transcoding images, and obtaining input and output streams, as well as a run-time registry that discovers installed service provider instances and allows new instances to be registered dynamically.</source>
          <target state="translated">&lt;code&gt;javax.imageio.spi&lt;/code&gt; 의의 패키지는 읽기, 쓰기, 및 트랜스 코딩 이미지 및 획득 입력 및 출력 스트림을위한 서비스 프로 바이더 인터페이스뿐만 아니라 발견하여 서비스 프로 바이더 인스턴스를 설치하고 새로운 인스턴스를 동적으로 등록 할 수 있도록하는 런타임 레지스트리가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9893bf2cb21c5852d399c228329581eed4bc85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.print.attribute&lt;/code&gt; package describes the types of attributes and how they can be collected into sets. The &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; package enumerates all of the standard attributes supported by the API, most of which are implementations of attributes specified in the IETF Specification, &lt;a href=&quot;http://www.ietf.org/rfc/rfc2911.txt&quot;&gt; RFC 2911 Internet Printing Protocol, 1.1: Model and Semantics&lt;/a&gt;, dated September 2000. The attributes specified in &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; include common capabilities, such as: resolution, copies, media sizes, job priority, and page ranges.</source>
          <target state="translated">&lt;code&gt;javax.print.attribute&lt;/code&gt; 의의 패키지는 속성과 그들이 어떻게 세트에 수집되는 유형을 설명합니다. &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; 패키지는 IETF 사양에 지정된 속성의 구현입니다 대부분의 API가 지원하는 표준 속성의 모든 열거 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2911.txt&quot;&gt;모델 및 의미 : RFC 2911 인터넷 인쇄 프로토콜, 1.1&lt;/a&gt; 2000 년 9 월 일자를, &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; 에 지정된 속성 에는 해상도, 사본, 용지 크기, 작업 우선 순위 및 페이지 범위와 같은 공통 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c52c82c2dc7611fe0c69651dc489e948a8470acb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.print.attribute&lt;/code&gt; package describes the types of attributes and how they can be collected into sets. The &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; package enumerates all of the standard attributes supported by the API, most of which are implementations of attributes specified in the IETF Specification, &lt;a href=&quot;http://www.ietf.org/rfc/rfc2911.txt&quot;&gt;RFC 2911 Internet Printing Protocol, 1.1: Model and Semantics&lt;/a&gt;, dated September 2000. The attributes specified in &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; include common capabilities, such as: resolution, copies, media sizes, job priority, and page ranges.</source>
          <target state="translated">&lt;code&gt;javax.print.attribute&lt;/code&gt; 의의 패키지는 속성과 그들이 어떻게 세트에 수집되는 유형을 설명합니다. &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; 패키지는 IETF 사양에 지정된 속성의 구현입니다 대부분의 API가 지원하는 표준 속성의 모든 열거 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2911.txt&quot;&gt;모델 및 의미 : RFC 2911 인터넷 인쇄 프로토콜, 1.1&lt;/a&gt; 2000 년 9 월 일자를, &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; 에 지정된 속성 에는 해상도, 사본, 용지 크기, 작업 우선 순위 및 페이지 범위와 같은 공통 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f1ac81c4983fd4e99cf0a56e6178b754e13e7442" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.print.attribute&lt;/code&gt; package includes &lt;a href=&quot;hashattributeset&quot;&gt;HashAttributeSet&lt;/a&gt; as a concrete implementation of the attribute set interface. &lt;code&gt;HashAttributeSet&lt;/code&gt; provides an attribute set based on a hash map. You can use this implementation or provide your own implementation of interface &lt;code&gt;AttributeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;javax.print.attribute&lt;/code&gt; 의의 패키지는 포함 &lt;a href=&quot;hashattributeset&quot;&gt;을 HashAttributeSet를&lt;/a&gt; 속성 세트 인터페이스의 구체적인 구현한다. &lt;code&gt;HashAttributeSet&lt;/code&gt; 은 해시 맵을 기반으로하는 속성 세트를 제공합니다. 이 구현을 사용하거나 &lt;code&gt;AttributeSet&lt;/code&gt; 인터페이스의 자체 구현을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce40bf00e14dc3ae69324c9a349e2c2ebf3d4866" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.sql&lt;/code&gt; package provides for the following:</source>
          <target state="translated">&lt;code&gt;javax.sql&lt;/code&gt; 패키지는 다음을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="054bef0e67b4c84386043a510c836ef1eefccd8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.sql&lt;/code&gt; package provides the preferred way to make a connection with a data source. The &lt;code&gt;DriverManager&lt;/code&gt; class, the original mechanism, is still valid, and code using it will continue to run. However, the newer &lt;code&gt;DataSource&lt;/code&gt; mechanism is preferred because it offers many advantages over the &lt;code&gt;DriverManager&lt;/code&gt; mechanism.</source>
          <target state="translated">&lt;code&gt;javax.sql&lt;/code&gt; 패키지는 데이터 소스와의 접속을 할 수있는 좋은 방법을 제공합니다. &lt;code&gt;DriverManager&lt;/code&gt; 클래스, 원래의 메커니즘은 여전히 유효하고, 그것을 사용하는 코드는 계속 실행됩니다. 그러나 최신 &lt;code&gt;DataSource&lt;/code&gt; 메커니즘은 &lt;code&gt;DriverManager&lt;/code&gt; 메커니즘에 비해 많은 이점을 제공하기 때문에 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="78270c76347c7770cb655e4c785215d8bdb0d512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.xml.catalog.defer&lt;/code&gt; property as described in item &lt;a href=&quot;catalogfeatures#DEFER&quot;&gt;DEFER&lt;/a&gt; of the Catalog Features table.</source>
          <target state="translated">&lt;code&gt;javax.xml.catalog.defer&lt;/code&gt; 의 항목에 설명 된대로 재산 &lt;a href=&quot;catalogfeatures#DEFER&quot;&gt;DEFER&lt;/a&gt; 카탈로그의 테이블 특징.</target>
        </trans-unit>
        <trans-unit id="15d2ad6f93e03730ebc25b9f11249586e69ac782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property as described in item &lt;a href=&quot;catalogfeatures#FILES&quot;&gt;FILES&lt;/a&gt; of the Catalog Features table.</source>
          <target state="translated">&lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 의 항목에 설명 된대로 재산 &lt;a href=&quot;catalogfeatures#FILES&quot;&gt;FILES&lt;/a&gt; 카탈로그의 테이블 특징.</target>
        </trans-unit>
        <trans-unit id="9fc2f2e095ade91fa2f052d206896d8dfe4877e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.xml.catalog.prefer&lt;/code&gt; property as described in item &lt;a href=&quot;catalogfeatures#PREFER&quot;&gt;PREFER&lt;/a&gt; of the Catalog Features table.</source>
          <target state="translated">&lt;code&gt;javax.xml.catalog.prefer&lt;/code&gt; 의 항목에 설명 된대로 자산 &lt;a href=&quot;catalogfeatures#PREFER&quot;&gt;선호&lt;/a&gt; 카탈로그의 테이블 특징.</target>
        </trans-unit>
        <trans-unit id="db3821d6c87a43457aa9b8813d01a7019a6129e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; property as described in item &lt;a href=&quot;catalogfeatures#RESOLVE&quot;&gt;RESOLVE&lt;/a&gt; of the Catalog Features table.</source>
          <target state="translated">&lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; 항목에 설명 된대로 재산 &lt;a href=&quot;catalogfeatures#RESOLVE&quot;&gt;RESOLVE&lt;/a&gt; 카탈로그의 테이블 특징.</target>
        </trans-unit>
        <trans-unit id="93789cdb1067b60dea1052c68162e9476ca283fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jaxp.properties&lt;/code&gt; file is typically in the conf directory of the Java installation. The file is read only once by the JAXP implementation and its values are then cached for future use. If the file does not exist when the first attempt is made to read from it, no further attempts are made to check for its existence. It is not possible to change the value of any properties in &lt;code&gt;jaxp.properties&lt;/code&gt; after it has been read.</source>
          <target state="translated">&lt;code&gt;jaxp.properties&lt;/code&gt; 의 파일은 Java 설치의 conf 디렉토리에 일반적입니다. 파일은 JAXP 구현에 의해 한 번만 읽히고 해당 값은 나중에 사용하기 위해 캐시됩니다. 파일을 처음 읽으려고 할 때 파일이 존재하지 않으면 그 존재를 확인하기 위해 더 이상 시도하지 않습니다. &lt;code&gt;jaxp.properties&lt;/code&gt; 를 읽은 후에는 속성 값을 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e2a7485770f758bc31860b6c07b8541a8b9eeb14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jdbc.drivers&lt;/code&gt; system property which contains a colon separated list of fully qualified class names of JDBC drivers. Each driver is loaded using the &lt;a href=&quot;../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;system class loader&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;jdbc.drivers&lt;/code&gt; 콜론이 포함되어 시스템 속성은 JDBC 드라이버의 완전한 클래스 이름의 목록을 분리했다. 각 드라이버는 &lt;a href=&quot;../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;시스템 클래스 로더를&lt;/a&gt; 사용하여로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4512a267bf8a4a8b628ff06249f45a97a9013e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kind&lt;/code&gt; of a directive.</source>
          <target state="translated">지시어 의 &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="766e65fec5bf118351de7f21179d89ba7379dbda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kind&lt;/code&gt; of an element.</source>
          <target state="translated">요소 의 &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="583ea0cb6650b486f04f1d06cd030a009d684d42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;krb5.conf&lt;/code&gt; file is formatted in the Windows INI file style, which contains a series of relations grouped into different sections. Each relation contains a key and a value, the value can be an arbitrary string or a boolean value. A boolean value can be one of &quot;true&quot;, &quot;false&quot;, &quot;yes&quot;, or &quot;no&quot;, and values are case-insensitive.</source>
          <target state="translated">&lt;code&gt;krb5.conf&lt;/code&gt; 파일은 다른 섹션으로 그룹화 관계의 시리즈를 포함하는 윈도우 INI 파일 스타일에 지정됩니다. 각 관계에는 키와 값이 포함되며 값은 임의의 문자열 또는 부울 값이 될 수 있습니다. 부울 값은 &quot;true&quot;, &quot;false&quot;, &quot;yes&quot;또는 &quot;no&quot;중 하나 일 수 있으며 값은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbe5ef5eb552727a780a36060063e8f5dc9148f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;layeredPane&lt;/code&gt; fills the entire viewable area of the &lt;code&gt;JRootPane&lt;/code&gt;. (bounds - insets)</source>
          <target state="translated">&lt;code&gt;layeredPane&lt;/code&gt; 의 전체 가시 영역 채운다 &lt;code&gt;JRootPane&lt;/code&gt; . (경계-삽입)</target>
        </trans-unit>
        <trans-unit id="3cfb47b698c324c8e60c3a7f81085135ef605f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;layeredPane&lt;/code&gt; is the parent of all children in the &lt;code&gt;JRootPane&lt;/code&gt; -- both as the direct parent of the menu and the grandparent of all components added to the &lt;code&gt;contentPane&lt;/code&gt;. It is an instance of &lt;code&gt;JLayeredPane&lt;/code&gt;, which provides the ability to add components at several layers. This capability is very useful when working with menu popups, dialog boxes, and dragging -- situations in which you need to place a component on top of all other components in the pane.</source>
          <target state="translated">&lt;code&gt;layeredPane&lt;/code&gt; 에있는 모든 어린이의 부모 &lt;code&gt;JRootPane&lt;/code&gt; 의 두 메뉴의 직접적인 부모와에 추가 된 모든 구성 요소의 조부모 등 - &lt;code&gt;contentPane&lt;/code&gt; . 여러 계층에 구성 요소를 추가하는 기능을 제공하는 &lt;code&gt;JLayeredPane&lt;/code&gt; 의 인스턴스입니다 . 이 기능은 메뉴 팝업, 대화 상자 및 드래그 작업 (창의 다른 모든 구성 요소 위에 구성 요소를 배치해야하는 상황)에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bbb82873975dbeba0e74c27fbee85cbfbbfbdc0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ldc&lt;/code&gt; instruction makes use of bootstrap &lt;code&gt;MethodHandle&lt;/code&gt; constants to dynamically resolve custom constant values.</source>
          <target state="translated">&lt;code&gt;ldc&lt;/code&gt; 명령 차종은 부트 스트랩의 사용 &lt;code&gt;MethodHandle&lt;/code&gt; 의 동적의 해결 사용자 정의 상수 값으로 상수.</target>
        </trans-unit>
        <trans-unit id="a5fbfe70cef778b32594cced3a732339cbc1acf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; argument is negative.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 의 인수가 부의이다.</target>
        </trans-unit>
        <trans-unit id="5c30faee739e118e9dbf221fbacf126dc2e548ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; argument must be less than or equal to &lt;code&gt;buf.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 인수 미만이거나에 동일해야 &lt;code&gt;buf.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ab860b5d9fdfdc8cacefe29fa6bee88d721891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limit&lt;/code&gt; parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 파라미터는 패턴이 적용되는 횟수를 제어하기 때문에, 결과 어레이의 길이에 영향을 미친다.</target>
        </trans-unit>
        <trans-unit id="a20aaa21bfe3d598720524fef65f51974af49fb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limit&lt;/code&gt; parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array. If the limit</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 파라미터는 패턴이 적용되는 횟수를 제어하기 때문에, 결과 어레이의 길이에 영향을 미친다. 한도</target>
        </trans-unit>
        <trans-unit id="7227cc8a8f47600f7a135282736709ff73dd62b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; parameter locates the directory entry to create. The &lt;code&gt;existing&lt;/code&gt; parameter is the path to an existing file. This method creates a new directory entry for the file so that it can be accessed using &lt;code&gt;link&lt;/code&gt; as the path. On some file systems this is known as creating a &quot;hard link&quot;. Whether the file attributes are maintained for the file or for each directory entry is file system specific and therefore not specified. Typically, a file system requires that all links (directory entries) for a file be on the same file system. Furthermore, on some platforms, the Java virtual machine may require to be started with implementation specific privileges to create hard links or to create links to directories.</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 매개 변수를 만들 수있는 디렉토리 항목을 찾습니다. &lt;code&gt;existing&lt;/code&gt; 매개 변수는 기존 파일의 경로입니다. 이 메소드는 &lt;code&gt;link&lt;/code&gt; 를 경로로 사용하여 액세스 할 수 있도록 파일의 새 디렉토리 항목을 작성합니다 . 일부 파일 시스템에서는이를 &quot;하드 링크&quot;라고합니다. 파일 속성이 파일 또는 각 디렉토리 항목에 대해 유지 보수되는지 여부는 파일 시스템마다 다르므로 지정되지 않습니다. 일반적으로 파일 시스템에서는 파일의 모든 링크 (디렉토리 항목)가 동일한 파일 시스템에 있어야합니다. 또한 일부 플랫폼에서 Java 가상 머신은 하드 링크를 작성하거나 디렉토리에 대한 링크를 작성하기 위해 구현 특정 권한으로 시작해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d151fce3015e4ed9e5cd20051237afb5cefea88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;listIterator(int)&lt;/code&gt; method returns a &quot;wrapper object&quot; over a list iterator on the backing list, which is created with the corresponding method on the backing list. The &lt;code&gt;iterator&lt;/code&gt; method merely returns &lt;code&gt;listIterator()&lt;/code&gt;, and the &lt;code&gt;size&lt;/code&gt; method merely returns the subclass's &lt;code&gt;size&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;listIterator(int)&lt;/code&gt; 에있어서, 상기 배면에서의 대응하는 방법으로 생성되는 배킹리스트의리스트 반복자는 &quot;래퍼 객체&quot;를 리턴한다. &lt;code&gt;iterator&lt;/code&gt; 방법은 단순히 반환 &lt;code&gt;listIterator()&lt;/code&gt; 하고, &lt;code&gt;size&lt;/code&gt; 방법은 단지 서브 클래스의 반환 &lt;code&gt;size&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="2c77410030181476fea1a68458124459ebc9a9bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;listener&lt;/code&gt; listens to property changes only in this context.</source>
          <target state="translated">&lt;code&gt;listener&lt;/code&gt; 단지이 상황에서 속성 변경을 대기.</target>
        </trans-unit>
        <trans-unit id="1fedd930e38f5398c449c705300b0fc17b0566c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loadClass&lt;/code&gt; method in class &lt;code&gt;ClassLoader&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loadClass&lt;/code&gt; 클래스의 메소드 &lt;code&gt;ClassLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df54bb2871f3875ee6a1a7f2fe8a7beb4fbe0bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locate&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; simply returns the component itself if the (</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;locate&lt;/code&gt; 메소드 는 (</target>
        </trans-unit>
        <trans-unit id="6c9b144092edff275e75b32f1dca016975180187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; function passed to &lt;code&gt;flatMap&lt;/code&gt; splits a line, using a simple regular expression, into an array of words, and then creates a stream of words from that array.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; 에 전달 된 &lt;code&gt;mapper&lt;/code&gt; 함수 는 간단한 정규식을 사용하여 행을 단어 배열로 분할 한 다음 해당 배열에서 단어 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e7777926bab037130e9c4b41941f7d725a543594" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapping()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, such as downstream of a &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. For example, given a stream of &lt;code&gt;Person&lt;/code&gt;, to accumulate the set of last names in each city:</source>
          <target state="translated">&lt;code&gt;mapping()&lt;/code&gt; 등의 다운 스트림으로, 다단계 감소를 사용할 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 예를 들어, &lt;code&gt;Person&lt;/code&gt; 이라는 스트림이 주어지면 각 도시에 성 집합을 누적합니다.</target>
        </trans-unit>
        <trans-unit id="903b585e02a8cfe6d8af38444d4c285b4ecfdab9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InflaterInputStream&lt;/code&gt; does nothing.</source>
          <target state="translated">&lt;code&gt;InflaterInputStream&lt;/code&gt; 의 &lt;code&gt;mark&lt;/code&gt; 메소드 는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0371bac823202240bd6c72d5e06eb31b731df75c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does nothing.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 의 &lt;code&gt;mark&lt;/code&gt; 메소드 는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e02e9dcce04c471816e17e93a8e7c8612865389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; remembers the current line number in a private variable, and then calls the &lt;code&gt;mark&lt;/code&gt; method of the underlying input stream.</source>
          <target state="translated">&lt;code&gt;LineNumberInputStream&lt;/code&gt; 의 &lt;code&gt;mark&lt;/code&gt; 메소드는 전용 변수의 현재 행 번호를 기억 한 다음 기본 입력 스트림 의 &lt;code&gt;mark&lt;/code&gt; 메소드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9baaba468b2b9ec943dee5d33e382f44cbd16e98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;PushbackInputStream&lt;/code&gt; does nothing.</source>
          <target state="translated">&lt;code&gt;PushbackInputStream&lt;/code&gt; 의 &lt;code&gt;mark&lt;/code&gt; 메소드 는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="266811666f451efbcca8485179044d44787aa53c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;markSupported()&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;mark()&lt;/code&gt; and &lt;code&gt;reset()&lt;/code&gt; methods throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;markSupported()&lt;/code&gt; 메서드는 반환 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;mark()&lt;/code&gt; 및 &lt;code&gt;reset()&lt;/code&gt; 메소드는 던져 &lt;code&gt;IOException&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="24e3553f60a435975160a122db551ded68bc69d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;markSupported()&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;mark()&lt;/code&gt; method does nothing, and the &lt;code&gt;reset()&lt;/code&gt; method throws &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;markSupported()&lt;/code&gt; 메서드는 반환 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;mark()&lt;/code&gt; 메소드는 아무것도하지 않습니다, 그리고 &lt;code&gt;reset()&lt;/code&gt; 메소드는 발생 &lt;code&gt;IOException&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="77e5480e00ffc1e7db2c7cde3ede487453a10255" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxDepth&lt;/code&gt; parameter is the maximum number of levels of directories to visit. A value of &lt;code&gt;0&lt;/code&gt; means that only the starting file is visited, unless denied by the security manager. A value of &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;MAX_VALUE&lt;/code&gt;&lt;/a&gt; may be used to indicate that all levels should be visited.</source>
          <target state="translated">&lt;code&gt;maxDepth&lt;/code&gt; 매개 변수는 방문에 디렉토리 수준의 최대 수입니다. &lt;code&gt;0&lt;/code&gt; 값은 보안 관리자가 거부하지 않는 한 시작 파일 만 방문 함을 의미합니다. &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;MAX_VALUE&lt;/code&gt; &lt;/a&gt; 값은 모든 레벨을 방문해야 함을 나타내는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18e28bc41e209ebe6c61a493b6c9622bd4b0c37d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxDepth&lt;/code&gt; parameter is the maximum number of levels of directories to visit. A value of &lt;code&gt;0&lt;/code&gt; means that only the starting file is visited, unless denied by the security manager. A value of &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;MAX_VALUE&lt;/code&gt;&lt;/a&gt; may be used to indicate that all levels should be visited. The &lt;code&gt;visitFile&lt;/code&gt; method is invoked for all files, including directories, encountered at &lt;code&gt;maxDepth&lt;/code&gt;, unless the basic file attributes cannot be read, in which case the &lt;code&gt;
 visitFileFailed&lt;/code&gt; method is invoked.</source>
          <target state="translated">&lt;code&gt;maxDepth&lt;/code&gt; 매개 변수는 방문에 디렉토리 수준의 최대 수입니다. &lt;code&gt;0&lt;/code&gt; 값은 보안 관리자가 거부하지 않는 한 시작 파일 만 방문 함을 의미합니다. &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;MAX_VALUE&lt;/code&gt; &lt;/a&gt; 값을 사용하여 모든 레벨을 방문해야 함을 나타낼 수 있습니다. &lt;code&gt;visitFile&lt;/code&gt; 의 방법에서 발생하는 디렉토리를 포함한 모든 파일에 대한 호출 &lt;code&gt;maxDepth&lt;/code&gt; 이 경우 기본 파일 속성을 읽을 수 없습니다하지 않는 한, &lt;code&gt; visitFileFailed&lt;/code&gt; 의 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="259fe46dcadeee76b1ff944baef9fa3edc7fae57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxDepth&lt;/code&gt; parameter is the maximum number of levels of directories to visit. A value of &lt;code&gt;0&lt;/code&gt; means that only the starting file is visited, unless denied by the security manager. A value of &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;MAX_VALUE&lt;/code&gt;&lt;/a&gt; may be used to indicate that all levels should be visited. The &lt;code&gt;visitFile&lt;/code&gt; method is invoked for all files, including directories, encountered at &lt;code&gt;maxDepth&lt;/code&gt;, unless the basic file attributes cannot be read, in which case the &lt;code&gt;visitFileFailed&lt;/code&gt; method is invoked.</source>
          <target state="translated">&lt;code&gt;maxDepth&lt;/code&gt; 매개 변수는 방문에 디렉토리 수준의 최대 수입니다. &lt;code&gt;0&lt;/code&gt; 값은 보안 관리자가 거부하지 않는 한 시작 파일 만 방문 함을 의미합니다. &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;MAX_VALUE&lt;/code&gt; &lt;/a&gt; 값은 모든 레벨을 방문해야 함을 나타내는 데 사용될 수 있습니다. &lt;code&gt;visitFile&lt;/code&gt; 의 방법에서 발생하는 디렉토리를 포함한 모든 파일에 대한 호출 &lt;code&gt;maxDepth&lt;/code&gt; 이 경우 기본 파일 속성을 읽을 수 없습니다하지 않는 한, &lt;code&gt;visitFileFailed&lt;/code&gt; 의 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="df4b870fb6b307f47ae3b882d0d392b6a0a27623" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;menuBar&lt;/code&gt; is positioned at the upper edge of the &lt;code&gt;layeredPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;menuBar&lt;/code&gt; 의 상부 에지에 위치 &lt;code&gt;layeredPane&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25cc63f27b499ac936092a81d7ae1cac847e5fe0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;messageType&lt;/code&gt; parameter is primarily used to supply a default icon from the look and feel.</source>
          <target state="translated">&lt;code&gt;messageType&lt;/code&gt; 매개 변수는 주로 모양과 느낌에서 기본 아이콘을 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6af76e421d8e057e7b7d9ff20dd9e09a4d087b85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaData&lt;/code&gt; parameter can be used to limit the number of I/O operations that this method is required to perform. Passing &lt;code&gt;false&lt;/code&gt; for this parameter indicates that only updates to the file's content need be written to storage; passing &lt;code&gt;true&lt;/code&gt; indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.</source>
          <target state="translated">&lt;code&gt;metaData&lt;/code&gt; 파라미터는이 방법을 수행하기 위해 요구되는 I / O 동작들의 수를 제한 할 수있다. 이 매개 변수에 대해 &lt;code&gt;false&lt;/code&gt; 를 전달 하면 파일 내용에 대한 업데이트 만 저장소에 기록해야 함을 나타냅니다. &lt;code&gt;true&lt;/code&gt; 를 전달 하면 파일의 내용과 메타 데이터 모두에 대한 업데이트를 작성해야하며 이는 일반적으로 하나 이상의 I / O 작업이 필요합니다. 이 매개 변수가 실제로 영향을 미치는지 여부는 기본 운영 체제에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68681b14e33063683f77b0c98ad6ad810109a928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minimum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; parameters can be &lt;code&gt;null&lt;/code&gt; to indicate that the range doesn't have an upper or lower bound. If &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;stepSize&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or if both &lt;code&gt;minimum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; are specified and &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Similarly if &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum&lt;/code&gt;) is false, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;minimum&lt;/code&gt; 및 &lt;code&gt;maximum&lt;/code&gt; 파라미터 일 수 &lt;code&gt;null&lt;/code&gt; 범위는 상부가 없거나 하한 것을 나타내는. 경우 &lt;code&gt;value&lt;/code&gt; 또는 &lt;code&gt;stepSize&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 또는 둘 경우 &lt;code&gt;minimum&lt;/code&gt; 및 &lt;code&gt;maximum&lt;/code&gt; 지정 및 &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; 후 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 슬로우됩니다. 마찬가지로 &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum&lt;/code&gt; )이 false이면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74be4dfd459c69d6c5eed0336db7d26406e6421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minimumCapacity&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;minimumCapacity&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="890e9f6e189646766e2f576b109ba30702568602" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; argument specifies the access mode with which the file is to be opened. The permitted values and their meanings are as specified for the &lt;a href=&quot;#mode&quot;&gt;&lt;code&gt;RandomAccessFile(File,String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 인수는 파일을 열 수하는있는 액세스 모드를 지정합니다. 허용되는 값과 의미는 &lt;a href=&quot;#mode&quot;&gt; &lt;code&gt;RandomAccessFile(File,String)&lt;/code&gt; &lt;/a&gt; 생성자에 지정된 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8d634c96d7b7dc8c2283b2dc960c9bfb6ad5d16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modifiers&lt;/code&gt; parameter specifies &lt;em&gt;modifiers&lt;/em&gt; that qualify how the directory is registered. This release does not define any &lt;em&gt;standard&lt;/em&gt; modifiers. It may contain implementation specific modifiers.</source>
          <target state="translated">&lt;code&gt;modifiers&lt;/code&gt; 지정 매개 변수 &lt;em&gt;수정&lt;/em&gt; 디렉토리 등록 방법 자격. 이 릴리스는 &lt;em&gt;표준&lt;/em&gt; 수정자를 정의하지 않습니다 . 구현 특정 수정자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c71b33fd5b314e171d4df0723194294f0896265" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msg&lt;/code&gt; string is localized using the given resource bundle. If the resource bundle is &lt;code&gt;null&lt;/code&gt;, then the &lt;code&gt;msg&lt;/code&gt; string is not localized.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 문자열은 주어진 자원 번들을 사용하여 지역화됩니다. 자원 번들 인 경우 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;code&gt;msg&lt;/code&gt; 문자열은 지역화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ad795f1c708af7880ff420b8fad93daa8b2155f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; parameter may be negative, even though the &lt;code&gt;skip&lt;/code&gt; method of the &lt;a href=&quot;reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt; superclass throws an exception in this case. If &lt;code&gt;n&lt;/code&gt; is negative, then this method does nothing and returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 파라미터는, 비록 음극 일 수있다 &lt;code&gt;skip&lt;/code&gt; 의 방법 &lt;a href=&quot;reader&quot;&gt; &lt;code&gt;Reader&lt;/code&gt; &lt;/a&gt; 수퍼이 경우 예외를 던진다. 경우 &lt;code&gt;n&lt;/code&gt; 은 음,이 메소드는 아무 것도 반환하지 않습니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dff9aa267101b80032f4f16286856df7bec91f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; parameters are owned by the caller. The implementation will not modify these objects or keep references to them, although it may keep references to clones or copies.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;environment&lt;/code&gt; 변수는 호출 측이 소유합니다. 구현은 이러한 객체를 수정하거나 참조를 유지하지 않지만 복제본이나 복사본에 대한 참조를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d43ffbfe8d9be7ac13f65149aa0271dd8dbc00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. &lt;code&gt;name&lt;/code&gt; is the name of the object, relative to context &lt;code&gt;nameCtx&lt;/code&gt;. This information could be useful to the object factory or to the object implementation. If there are several possible contexts from which the object could be named -- as will often be the case -- it is up to the caller to select one. A good rule of thumb is to select the &quot;deepest&quot; context available. If &lt;code&gt;nameCtx&lt;/code&gt; is null, &lt;code&gt;name&lt;/code&gt; is relative to the default initial context. If no name is being specified, the &lt;code&gt;name&lt;/code&gt; parameter should be null.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. &lt;code&gt;name&lt;/code&gt; 은 컨텍스트 &lt;code&gt;nameCtx&lt;/code&gt; 에 상대적인 객체 이름입니다 . 이 정보는 객체 팩토리 또는 객체 구현에 유용 할 수 있습니다. 경우에 따라 객체의 이름을 지정할 수있는 컨텍스트가 여러 개있는 경우 하나를 선택하는 것은 호출자에게 달려 있습니다. 경험상 &quot;가장 깊은&quot;컨텍스트를 선택하는 것이 좋습니다. 경우 &lt;code&gt;nameCtx&lt;/code&gt; 에이 널 (null)이며, &lt;code&gt;name&lt;/code&gt; 디폴트의 초기 컨텍스트에 상대적입니다. 이름을 지정하지 않으면 &lt;code&gt;name&lt;/code&gt; 매개 변수는 null이어야합니다.</target>
        </trans-unit>
        <trans-unit id="be1fd20ce63d2a2b2230f8b0a96a9b6d08008ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c9872e72bac6d145cc0c98edc174c7beb6a1a6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details. If a factory uses &lt;code&gt;nameCtx&lt;/code&gt; it should synchronize its use against concurrent access, since context implementations are not guaranteed to be thread-safe.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오. 팩토리가 &lt;code&gt;nameCtx&lt;/code&gt; 를 사용하는 경우 컨텍스트 구현이 스레드로부터 안전하다고 보장되지 않으므로 동시 액세스에 대해 사용을 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f70a327d5594e9f181a40f5c6ca0cd8e025505b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d4c006afdb1b3d49e58c74bd4a0ffd732b023002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details. If a factory uses &lt;code&gt;nameCtx&lt;/code&gt; it should synchronize its use against concurrent access, since context implementations are not guaranteed to be thread-safe.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오. 팩토리가 &lt;code&gt;nameCtx&lt;/code&gt; 를 사용하는 경우 컨텍스트 구현이 스레드 안전을 보장하지 않으므로 동시 액세스에 대해 사용을 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="e883ac2d08181956247cb122333240f05339fa61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; argument is case insensitive.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 인수는 경우를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75ed05c0b8a33486c051a951114b24540ff05d3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; matching is case insensitive, with any leading and trailing whitespace character removed.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 매칭을 제거 선행과 후행 공백 문자로, 사례를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b3818f758723f19e7f19461448d70ae40bd144a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;attrs&lt;/code&gt;, and &lt;code&gt;environment&lt;/code&gt; parameters are owned by the caller. The implementation will not modify these objects or keep references to them, although it may keep references to clones or copies.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; , &lt;code&gt;attrs&lt;/code&gt; 및 &lt;code&gt;environment&lt;/code&gt; 파라미터는 호출 측이 소유합니다. 구현은 이러한 객체를 수정하거나 참조를 유지하지 않지만 복제본이나 복사본에 대한 참조를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48161fbd495af11311a77e82a4acb8a1f70aaa4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;inAttrs&lt;/code&gt;, and &lt;code&gt;environment&lt;/code&gt; parameters are owned by the caller. The implementation will not modify these objects or keep references to them, although it may keep references to clones or copies. The object returned by this method is owned by the caller. The implementation will not subsequently modify it. It will contain either a new &lt;code&gt;Attributes&lt;/code&gt; object that is likewise owned by the caller, or a reference to the original &lt;code&gt;inAttrs&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; , &lt;code&gt;inAttrs&lt;/code&gt; , 및 &lt;code&gt;environment&lt;/code&gt; 파라미터는 호출 측이 소유합니다. 구현은 이러한 객체를 수정하거나 참조를 유지하지 않지만 복제본이나 복사본에 대한 참조를 유지할 수 있습니다. 이 메소드에 의해 리턴 된 오브젝트는 호출자가 소유합니다. 구현은 나중에 수정하지 않습니다. 호출자가 소유 한 새로운 &lt;code&gt;Attributes&lt;/code&gt; 객체 또는 원래 &lt;code&gt;inAttrs&lt;/code&gt; 매개 변수에 대한 참조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2e6b4b4d41262649d36998a45ab4a554e41dd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X500Principal&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 의 &lt;code&gt;X500Principal&lt;/code&gt; 를 의.</target>
        </trans-unit>
        <trans-unit id="f5c100cec826504d35586ac2749c0d0f50484e21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; of names. Each name is a &lt;code&gt;String&lt;/code&gt; or a byte array representing a distinguished name (in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; or ASN.1 DER encoded form, respectively). If &lt;code&gt;null&lt;/code&gt; is supplied as the value for this argument, no issuerNames check will be performed.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 이름. 각 이름은 고유 이름을 나타내는 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열입니다 ( 각각 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; 또는 ASN.1 DER로 인코딩 된 형식). 이 인수의 값으로 &lt;code&gt;null&lt;/code&gt; 이 제공 되면 issuerNames 점검이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10f8926ca6dbdca434f3cdffa8eda26510a88124" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the pathToNames criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. If &lt;code&gt;null&lt;/code&gt; is supplied as the value for this argument, no pathToNames check will be performed.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 각각의 이름에 대해 하나 개의 항목이 pathToNames 기준치에 포함 될 것입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 동일한 유형의 이름이 여러 개있을 수 있습니다. 이 인수의 값으로 &lt;code&gt;null&lt;/code&gt; 이 제공 되면 pathToNames 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7f614fb779c50df2c64620e5af3100fbb23fe19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the subject alternative name criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. If &lt;code&gt;null&lt;/code&gt; is supplied as the value for this argument, no subjectAlternativeNames check will be performed.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 각각의 이름에 대해 하나 개의 항목이 주체 대체 이름 기준에 포함 될 것입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 동일한 유형의 이름이 여러 개있을 수 있습니다. 이 인수의 값으로 &lt;code&gt;null&lt;/code&gt; 이 제공 되면 subjectAlternativeNames 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86f6973623e34ae41d0cb380cd7a6687a04a283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;network interface&lt;/code&gt; and &lt;code&gt;ttl&lt;/code&gt; parameters let the caller specify which network interface the test will go through and the maximum number of hops the packets should go through. A negative value for the &lt;code&gt;ttl&lt;/code&gt; will result in an IllegalArgumentException being thrown.</source>
          <target state="translated">&lt;code&gt;network interface&lt;/code&gt; 와 &lt;code&gt;ttl&lt;/code&gt; 매개 변수는 테스트를 통과하고 최대 홉의 수는 패킷이 통과해야 인터페이스 호출자가있는 네트워크를 지정할 수 있습니다. &lt;code&gt;ttl&lt;/code&gt; 의 값이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b09e54aa5c847f44721e53e1758b993160bcd0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newLength&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;newLength&lt;/code&gt; 인수보다 더 큰 일하거나 동일해야합니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7231d4e3f44c3037aca933714c69e80b5eb9b9ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newTypes&lt;/code&gt; list contains types &lt;code&gt;P..., M..., A...&lt;/code&gt;, with as many types in &lt;code&gt;P&lt;/code&gt; as indicated by &lt;code&gt;pos&lt;/code&gt;. The &lt;code&gt;M&lt;/code&gt; types are precisely those that the &lt;code&gt;M&lt;/code&gt; types in the target handle's parameter type list are supposed to match. The types in &lt;code&gt;A&lt;/code&gt; are additional types found after the matching sub-list.</source>
          <target state="translated">&lt;code&gt;newTypes&lt;/code&gt; 의 목록이 포함 된 타입 &lt;code&gt;P..., M..., A...&lt;/code&gt; , 많은 종류와 같이 &lt;code&gt;P&lt;/code&gt; 는 에 의해 나타낸 바와 같이, &lt;code&gt;pos&lt;/code&gt; . &lt;code&gt;M&lt;/code&gt; 의 종류는 정확하게 것들이다 &lt;code&gt;M&lt;/code&gt; 의 대상 핸들의 매개 변수 유형 목록에서 유형이 일치하도록되어있다. &lt;code&gt;A&lt;/code&gt; 의 유형 은 일치하는 하위 목록 뒤에있는 추가 유형입니다.</target>
        </trans-unit>
        <trans-unit id="238e2ddc1de1cf5d38b16bf8a5ed7a88e495f8bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nodeName&lt;/code&gt; attribute that is inherited from &lt;code&gt;Node&lt;/code&gt; contains the name of the entity.</source>
          <target state="translated">&lt;code&gt;nodeName&lt;/code&gt; 에서 상속되는 속성 &lt;code&gt;Node&lt;/code&gt; 엔티티의 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cd6f3c9ed9744a178a240c4efe334b44144e9408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method helps solve these problems by transforming text into the canonical composed and decomposed forms as shown in the first example above. In addition, you can have it perform compatibility decompositions so that you can treat compatibility characters the same as their equivalents. Finally, the &lt;code&gt;normalize&lt;/code&gt; method rearranges accents into the proper canonical order, so that you do not have to worry about accent rearrangement on your own.</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 방법으로 구성 및 상기 첫번째 예에 도시 된 바와 같이 형태를 분해 정식으로 텍스트를 변환하여 이러한 문제를 해결할 수. 또한 호환성 분해를 수행하여 호환성 문자를 동등 문자와 동일하게 취급 할 수 있습니다. 마지막으로 &lt;code&gt;normalize&lt;/code&gt; 방법은 악센트를 올바른 정식 순서로 재 배열하므로 사용자가 직접 악센트 재배 열에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f52e6638e3eca203f0c48df0632a417ad5518e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notations&lt;/code&gt;&lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal.</source>
          <target state="translated">&lt;code&gt;notations&lt;/code&gt; &lt;code&gt;NamedNodeMaps&lt;/code&gt; 는 동일하다.</target>
        </trans-unit>
        <trans-unit id="63cf4faf44647d95951cea7798d0b85f615c45ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ns&lt;/code&gt; parameter may be negative, even though the &lt;code&gt;skip&lt;/code&gt; method of the &lt;a href=&quot;reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt; superclass throws an exception in this case. Negative values of &lt;code&gt;ns&lt;/code&gt; cause the stream to skip backwards. Negative return values indicate a skip backwards. It is not possible to skip backwards past the beginning of the string.</source>
          <target state="translated">&lt;code&gt;ns&lt;/code&gt; 파라미터는, 비록 음극 일 수있다 &lt;code&gt;skip&lt;/code&gt; 의 방법 &lt;a href=&quot;reader&quot;&gt; &lt;code&gt;Reader&lt;/code&gt; &lt;/a&gt; 수퍼이 경우 예외를 던진다. &lt;code&gt;ns&lt;/code&gt; 의 음수 값은 스트림을 뒤로 건너 뜁니다. 음수 반환 값은 뒤로 건너 뛰기를 나타냅니다. 문자열의 시작을지나 뒤로 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0fcc06e98814dd87a3c62b985949fba60bdb550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument is the index of the first byte of the subarray, and the &lt;code&gt;count&lt;/code&gt; argument specifies the length of the subarray.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자는 배열의 첫 번째 바이트의 인덱스이고, 상기 &lt;code&gt;count&lt;/code&gt; 인수는 배열의 길이를 지정한다.</target>
        </trans-unit>
        <trans-unit id="baa0351e008899618db6b64da0e758694ddf41eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument is the index of the first character of the subarray. The &lt;code&gt;count&lt;/code&gt; argument specifies the length of the subarray. The contents of the subarray are copied; subsequent modification of the character array does not affect the returned string.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인수는 배열의 첫 번째 문자의 인덱스입니다. &lt;code&gt;count&lt;/code&gt; 인수는 부분 배열의 길이를 지정합니다. 하위 배열의 내용이 복사됩니다. 후속 문자 배열 수정은 반환 된 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c01d1aa6c77241f92e51f28f20db5fb08e4c253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;charsequence#length()&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자보다 크거나 같아야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;charsequence#length()&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="7d930134c90bf6d49ed3db167b3ffa23d64e6b5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;stringbuffer#length--&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자보다 크거나 같아야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;stringbuffer#length--&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="5649ec97e26cd383b62037dbe7726158b1b2a542" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;stringbuilder#length--&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자보다 크거나 같아야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;stringbuilder#length--&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="2d5b4d40ecb1db6747499e6955bb54e7c954105e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;openAttributes&lt;/code&gt;, &lt;code&gt;openConstructors&lt;/code&gt;, &lt;code&gt;
 openOperations&lt;/code&gt; and &lt;code&gt;notifications&lt;/code&gt; array parameters are internally copied, so that subsequent changes to the arrays referenced by these parameters have no effect on this instance.</source>
          <target state="translated">&lt;code&gt;openAttributes&lt;/code&gt; , &lt;code&gt;openConstructors&lt;/code&gt; , &lt;code&gt; openOperations&lt;/code&gt; 및 &lt;code&gt;notifications&lt;/code&gt; 배열 매개 변수는 내부적으로 이러한 매개 변수에 의해 참조되는 그 후의 배열의 변경이이 인스턴스에 영향을 미치지 그래서, 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="4b47fbce935f5d028b77339d1ef9818c0b7586f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;openAttributes&lt;/code&gt;, &lt;code&gt;openConstructors&lt;/code&gt;, &lt;code&gt;openOperations&lt;/code&gt; and &lt;code&gt;notifications&lt;/code&gt; array parameters are internally copied, so that subsequent changes to the arrays referenced by these parameters have no effect on this instance.</source>
          <target state="translated">&lt;code&gt;openAttributes&lt;/code&gt; , &lt;code&gt;openConstructors&lt;/code&gt; , &lt;code&gt;openOperations&lt;/code&gt; 및 &lt;code&gt;notifications&lt;/code&gt; 배열 매개 변수는 내부적으로 이러한 매개 변수에 의해 참조되는 그 후의 배열의 변경이이 인스턴스에 영향을 미치지 그래서, 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d6983d2110c5fe985de448c67aa2a3f5fba3481e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled by the resulting file attribute view for the case that the file is a symbolic link. By default, symbolic links are followed. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed. This option is ignored by implementations that do not support symbolic links.</source>
          <target state="translated">그만큼 &lt;code&gt;options&lt;/code&gt; 배열은 파일이 심볼릭 링크 인 경우의 결과 파일의 속성보기 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 기호 링크가 수행됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 있으면 기호 링크를 따르지 않습니다. 이 옵션은 심볼릭 링크를 지원하지 않는 구현에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e205a1262affb513a2bd877857ae965e9d442d7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 배열은 파일이 심볼릭 링크 인 경우에 대한 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 기호 링크가 따르고 링크의 최종 대상 파일 속성이 읽 힙니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 있으면 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07b7edf8d716c1c078bf2b1c0f91fb4940940f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 배열은 파일이 심볼릭 링크 인 경우에 대한 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 심볼릭 링크가 따르고 링크의 최종 대상의 파일 속성이 설정됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 있으면 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d06342b773fea6549bc89fc2462a7083b70f4fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled. By default, symbolic links are resolved to their final target. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then this method does not resolve symbolic links. Some implementations allow special names such as &quot;&lt;code&gt;..&lt;/code&gt;&quot; to refer to the parent directory. When deriving the &lt;em&gt;real path&lt;/em&gt;, and a &quot;&lt;code&gt;..&lt;/code&gt;&quot; (or equivalent) is preceded by a non-&quot;&lt;code&gt;..&lt;/code&gt;&quot; name then an implementation will typically cause both names to be removed. When not resolving symbolic links and the preceding name is a symbolic link then the names are only removed if it guaranteed that the resulting path will locate the same file as this path.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 배열을 처리하는 방법을 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 심볼릭 링크는 최종 대상으로 확인됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 존재하면이 메소드는 기호 링크를 해석하지 않습니다. 일부 구현에서는 &quot; &lt;code&gt;..&lt;/code&gt; &quot; 와 같은 특수 이름으로 상위 디렉토리를 참조 할 수 있습니다. 상기 유도 &lt;em&gt;실제 경로를&lt;/em&gt; , 그리고 &quot; &lt;code&gt;..&lt;/code&gt; &quot;(또는 동등한 항목) 앞에 &quot;&quot; &lt;code&gt;..&lt;/code&gt; &quot; 가 아닌 이름이 오는 경우 구현시 일반적으로 두 이름이 모두 제거됩니다. 심볼릭 링크를 해결하지 않고 이전 이름이 심볼릭 링크 인 경우 결과 경로가이 경로와 동일한 파일을 찾도록 보장 된 경우에만 이름이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a345ea481a9989b3e67c3fdfaa252ee2038c96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. If no options are present then it is equivalent to opening the file with the &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; option. In addition to the &lt;code&gt;
 READ&lt;/code&gt; option, an implementation may also support additional implementation specific options.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. 옵션이 없으면 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 옵션으로 파일을 여는 것과 같습니다 . 받는 사람 또한 &lt;code&gt; READ&lt;/code&gt; 옵션, 구현은 추가적인 구현 고유의 옵션을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bc9bb7ec20a4fcc37fab92a84728a3be6a3d529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. If no options are present then it is equivalent to opening the file with the &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; option. In addition to the &lt;code&gt;READ&lt;/code&gt; option, an implementation may also support additional implementation specific options.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. 옵션이 없으면 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 옵션으로 파일을 여는 것과 같습니다 . 여기에 덧붙여 &lt;code&gt;READ&lt;/code&gt; 옵션, 구현은 추가적인 구현 고유의 옵션을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb5d322a388c3217a1ff698a06ad00e166739fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. The &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options determine if the file should be opened for reading and/or writing. If neither option (or the &lt;a href=&quot;../file/standardopenoption#APPEND&quot;&gt;&lt;code&gt;APPEND&lt;/code&gt;&lt;/a&gt; option) is contained in the array then the file is opened for reading. By default reading or writing commences at the beginning of the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 파일 읽기 및 / 또는 쓰기 위해 열 수 있습니다 경우 옵션을 결정합니다. 옵션 (또는 &lt;a href=&quot;../file/standardopenoption#APPEND&quot;&gt; &lt;code&gt;APPEND&lt;/code&gt; )이&lt;/a&gt; 없으면 옵션)이 배열에 포함되어 파일을 읽기 위해 열립니다. 기본적으로 읽기 또는 쓰기는 파일 시작 부분에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c735a8e347a9d0b0ecd22343769651f2ac14125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. The &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options determines if the file should be opened for reading and/or writing. If neither option is contained in the array then an existing file is opened for reading.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 파일 읽기 및 / 또는 쓰기 위해 열 수 있습니다 경우 옵션을 결정합니다. 배열에 옵션이 없으면 기존 파일을 열어 읽습니다.</target>
        </trans-unit>
        <trans-unit id="70441efdb55fa14107d32cb84dfbb03932007cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. The &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options determine if the file should be opened for reading and/or writing. If neither option (or the &lt;a href=&quot;standardopenoption#APPEND&quot;&gt;&lt;code&gt;APPEND&lt;/code&gt;&lt;/a&gt; option) is present then the file is opened for reading. By default reading or writing commence at the beginning of the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 파일 읽기 및 / 또는 쓰기 위해 열 수 있습니다 경우 옵션을 결정합니다. 옵션 (또는 &lt;a href=&quot;standardopenoption#APPEND&quot;&gt; &lt;code&gt;APPEND&lt;/code&gt; )이&lt;/a&gt; 없으면 옵션)이 파일을 읽기 위해 열립니다. 기본적으로 파일의 시작 부분에서 읽기 또는 쓰기가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="adaafaa0c2c26b989f9f5f2e8716f29c6f11b35c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일이 심볼릭 링크 인 경우에 대한 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 기호 링크가 수행됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 인 경우 이 있으면 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e88e22b5339b7c784d561d64428df97e00625dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter may include any of the following:</source>
          <target state="translated">그만큼 &lt;code&gt;options&lt;/code&gt; 매개 변수는 다음 중 하나를 포함 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="4b13774c0241962d758bb9e487f1b8e4b324b63e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter specifies how the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메서드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 쓰기 위해 파일을 열고, 존재하지 않는 경우 파일을 생성하거나, 기존 &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 을 처음 에 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="9f9d8a105de341349c54bc6855f4dc3514259ce3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter specifies how the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. The method ensures that the file is closed when all lines have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has been created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메서드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 쓰기 위해 파일을 열고, 존재하지 않는 경우 파일을 생성하거나, 기존 &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 을 처음 에 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다 . 이 메서드는 모든 행이 기록되었을 때 파일이 닫히도록합니다 (또는 I / O 오류 또는 기타 런타임 예외가 발생 함). I / O 오류가 발생하면 파일이 작성되거나 잘린 후 또는 파일에 일부 바이트가 기록 된 후에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c00a59ba94adcb6905e3dd085514e8e2f27d12a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter specifies how the the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. The method ensures that the file is closed when all lines have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 하여 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메소드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 파일을 작성하기 위해 파일을 열거 나 존재하지 않는 경우 파일을 만들거나 기존의 &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 처음에 자릅니다 을 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다 . 이 방법을 사용하면 모든 줄을 쓸 때 (또는 I / O 오류 또는 기타 런타임 예외가 발생했을 때) 파일이 닫힙니다. I / O 오류가 발생하면 파일이 작성되거나 잘린 후 또는 일부 바이트가 파일에 기록 된 후에 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19ea8dcb435d7496383db34913da36823ca371d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;orientation&lt;/code&gt; argument must take one of the two values &lt;code&gt;Scrollbar.HORIZONTAL&lt;/code&gt;, or &lt;code&gt;Scrollbar.VERTICAL&lt;/code&gt;, indicating a horizontal or vertical scroll bar, respectively.</source>
          <target state="translated">&lt;code&gt;orientation&lt;/code&gt; 인자는 두 개의 값 중 하나를 수행해야 &lt;code&gt;Scrollbar.HORIZONTAL&lt;/code&gt; 또는 &lt;code&gt;Scrollbar.VERTICAL&lt;/code&gt; 을 각각 수직 또는 수평 스크롤 바를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="d38cc57bdb401fa5458030b8203d68a47b6b87cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;outputMimeType&lt;/code&gt; parameter describes the document type that you want to create, whereas the &lt;code&gt;flavor&lt;/code&gt; parameter describes the format in which the input data will be provided by the application to the &lt;code&gt;StreamPrintService&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;outputMimeType&lt;/code&gt; 의 매개 변수는 반면, 만들려는 문서 유형을 설명 &lt;code&gt;flavor&lt;/code&gt; 파라미터는 상기 입력 데이터가 애플리케이션에 의해 제공 될 것이다 포맷 설명 &lt;code&gt;StreamPrintService&lt;/code&gt; 를이 .</target>
        </trans-unit>
        <trans-unit id="8257034935941be3f0b0a79bcb02da45c170ab8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ownerElement&lt;/code&gt; attribute is set to &lt;code&gt;null&lt;/code&gt; and the &lt;code&gt;specified&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt; on the adopted &lt;code&gt;Attr&lt;/code&gt;. The descendants of the source &lt;code&gt;Attr&lt;/code&gt; are recursively adopted.</source>
          <target state="translated">&lt;code&gt;ownerElement&lt;/code&gt; 속성이 설정되어 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;specified&lt;/code&gt; 플래그가 설정되어 &lt;code&gt;true&lt;/code&gt; 채택에 &lt;code&gt;Attr&lt;/code&gt; . 소스 &lt;code&gt;Attr&lt;/code&gt; 의 자손 은 재귀 적으로 채택됩니다.</target>
        </trans-unit>
        <trans-unit id="db95ff142963f6cc3449f48fbd4ccbf6c3102b9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ownerElement&lt;/code&gt; attribute is set to &lt;code&gt;null&lt;/code&gt; and the &lt;code&gt;specified&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt; on the generated &lt;code&gt;Attr&lt;/code&gt;. The descendants of the source &lt;code&gt;Attr&lt;/code&gt; are recursively imported and the resulting nodes reassembled to form the corresponding subtree. Note that the &lt;code&gt;deep&lt;/code&gt; parameter has no effect on &lt;code&gt;Attr&lt;/code&gt; nodes; they always carry their children with them when imported.</source>
          <target state="translated">&lt;code&gt;ownerElement&lt;/code&gt; 속성이 설정되어 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;specified&lt;/code&gt; 플래그가 설정되어 &lt;code&gt;true&lt;/code&gt; 생성에 &lt;code&gt;Attr&lt;/code&gt; . 소스 &lt;code&gt;Attr&lt;/code&gt; 의 하위 항목을 재귀 적으로 가져오고 결과 노드를 재 조립하여 해당 하위 트리를 형성합니다. 참고 것을 &lt;code&gt;deep&lt;/code&gt; 매개 변수에 아무런 영향이 없습니다 &lt;code&gt;Attr&lt;/code&gt; 노드; 그들은 수입 될 때 항상 그들의 아이들을 가지고갑니다.</target>
        </trans-unit>
        <trans-unit id="5c95aaf1fcdce3e672aff6748a9bdc1c5a92b1a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packageFinder&lt;/code&gt; parameter is for use when reading module descriptors from legacy module-artifact formats that do not record the set of packages in the descriptor itself.</source>
          <target state="translated">&lt;code&gt;packageFinder&lt;/code&gt; 의 기술자 자체 패키지 세트를 기록하지 않는 레거시 모듈 유물 형식의 모듈 설명을 읽을 때 매개 변수는 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d6a3e2666b292d57c5aab696b343f540ec638d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; field now contains two elements, each of which is an array two elements long. The first element is the parameter number; the second is the value to be set. In this case, the first element of &lt;code&gt;params&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;5000&lt;/code&gt;, and the second element is &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;&quot;West&quot;&lt;/code&gt;. When an application calls the method &lt;code&gt;execute&lt;/code&gt;, it will in turn call on this &lt;code&gt;RowSet&lt;/code&gt; object's reader, which will in turn invoke its &lt;code&gt;readData&lt;/code&gt; method. As part of its implementation, &lt;code&gt;readData&lt;/code&gt; will get the values in &lt;code&gt;params&lt;/code&gt; and use them to set the command's placeholder parameters. The following code fragment gives an idea of how the reader does this, after obtaining the &lt;code&gt;Connection&lt;/code&gt; object &lt;code&gt;con&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;params&lt;/code&gt; 필드에는 두 개의 요소가 포함되며, 각 요소는 두 요소 길이의 배열입니다. 첫 번째 요소는 매개 변수 번호입니다. 두 번째는 설정할 값입니다. 이 경우 &lt;code&gt;params&lt;/code&gt; 의 첫 번째 요소 는 &lt;code&gt;1&lt;/code&gt; 입니다 . &lt;code&gt;5000&lt;/code&gt; 이고 두 번째 요소는 &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;&quot;West&quot;&lt;/code&gt; 입니다. 응용 프로그램이 메소드가 호출하면 &lt;code&gt;execute&lt;/code&gt; ,이에 차례 호출됩니다 &lt;code&gt;RowSet&lt;/code&gt; 객체의 리더, 년 된 invoke 켜 것이다 &lt;code&gt;readData&lt;/code&gt; 방법. 구현의 일부로 &lt;code&gt;readData&lt;/code&gt; 는 &lt;code&gt;params&lt;/code&gt; 이를 사용하여 명령의 자리 표시 자 매개 변수를 설정합니다. 다음 코드 조각은 &lt;code&gt;Connection&lt;/code&gt; 객체 &lt;code&gt;con&lt;/code&gt; 을 얻은 후 독자가이를 수행하는 방법에 대한 아이디어를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="edb61ce5d9acc2ab5ce76544d532094234d018a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; argument determines two things: the frame on which the open dialog depends and the component whose position the look and feel should consider when placing the dialog. If the parent is a &lt;code&gt;Frame&lt;/code&gt; object (such as a &lt;code&gt;JFrame&lt;/code&gt;) then the dialog depends on the frame and the look and feel positions the dialog relative to the frame (for example, centered over the frame). If the parent is a component, then the dialog depends on the frame containing the component, and is positioned relative to the component (for example, centered over the component). If the parent is &lt;code&gt;null&lt;/code&gt;, then the dialog depends on no visible window, and it's placed in a look-and-feel-dependent position such as the center of the screen.</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; 열기 대화 상자가 의존하는 프레임 위치 모양과 느낌 대화 상자를 배치 할 때 고려해야 할 요소 : 인수는 두 가지를 결정한다. 부모가 &lt;code&gt;Frame&lt;/code&gt; 객체 (예 : &lt;code&gt;JFrame&lt;/code&gt; ) 인 경우 대화 상자는 프레임에 따라 달라지며 모양과 느낌은 프레임을 기준으로 대화 상자를 배치합니다 (예 : 프레임 중앙에 위치). 부모가 구성 요소 인 경우 대화 상자는 구성 요소를 포함하는 프레임에 따라 달라지며 구성 요소를 기준으로 배치됩니다 (예 : 구성 요소 중앙에 위치). 부모가 &lt;code&gt;null&lt;/code&gt; 이면 대화 상자는 보이지 않는 창에 의존하며 화면 중앙과 같은 모양과 느낌에 종속 된 위치에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="64a8995d9ac05171aede64481f740265b7613585" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseURL&lt;/code&gt; method of &lt;code&gt;URLStreamHandler&lt;/code&gt; parses the string representation as if it were an &lt;code&gt;http&lt;/code&gt; specification. Most URL protocol families have a similar parsing. A stream protocol handler for a protocol that has a different syntax must override this routine.</source>
          <target state="translated">&lt;code&gt;URLStreamHandler&lt;/code&gt; 의 &lt;code&gt;parseURL&lt;/code&gt; 메소드 는 문자열 표현을 마치 &lt;code&gt;http&lt;/code&gt; 스펙을 http 스펙 인 . 대부분의 URL 프로토콜 패밀리는 유사한 구문 분석을 가지고 있습니다. 구문이 다른 프로토콜의 스트림 프로토콜 핸들러는이 루틴을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="2221038019d4be2cb2f88fab060218d2d5a02e57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; parameter is associated with a &lt;code&gt;FileSystem&lt;/code&gt; that supports the &lt;a href=&quot;attribute/posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt;. This attribute view provides access to file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 파라미터는와 연관된 &lt;code&gt;FileSystem&lt;/code&gt; 지지체 &lt;a href=&quot;attribute/posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; 를&lt;/a&gt; . 이 속성보기는 POSIX (Portable Operating System Interface) 표준 제품군을 구현하는 운영 체제에서 사용되는 파일 시스템의 파일과 일반적으로 관련된 파일 속성에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b249e9a3d9c0f37793a768ee4c126d9c0f3b49e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; parameter is associated with a file system that supports &lt;a href=&quot;attribute/fileownerattributeview&quot;&gt;&lt;code&gt;FileOwnerAttributeView&lt;/code&gt;&lt;/a&gt;. This file attribute view provides access to a file attribute that is the owner of the file.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 매개 변수가 지원하는 파일 시스템과 관련된 &lt;a href=&quot;attribute/fileownerattributeview&quot;&gt; &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; 을&lt;/a&gt; . 이 파일 속성보기는 파일 소유자 인 파일 속성에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5493aef38945eeedee66c785a93a8e949626fc4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perms&lt;/code&gt; parameter is a &lt;code&gt;String&lt;/code&gt; representing the permissions. It has 9 characters that are interpreted as three sets of three. The first set refers to the owner's permissions; the next to the group permissions and the last to others. Within each set, the first character is &lt;code&gt;'r'&lt;/code&gt; to indicate permission to read, the second character is &lt;code&gt;'w'&lt;/code&gt; to indicate permission to write, and the third character is &lt;code&gt;'x'&lt;/code&gt; for execute permission. Where a permission is not set then the corresponding character is set to &lt;code&gt;'-'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perms&lt;/code&gt; 매개 변수는 있습니다 &lt;code&gt;String&lt;/code&gt; 권한을 나타내는. 3 개의 3 개 세트로 해석되는 9 개의 문자가 있습니다. 첫 번째 세트는 소유자의 권한을 나타냅니다. 그룹 권한 옆에 있고 다른 사람에게 마지막 권한. 각 세트 내에서 첫 번째 문자는 읽기 권한을 나타내는 &lt;code&gt;'r'&lt;/code&gt; 이고, 두 번째 문자는 쓰기 권한을 나타내는 &lt;code&gt;'w'&lt;/code&gt; 이며, 세 번째 문자는 실행 권한 &lt;code&gt;'x'&lt;/code&gt; 경우 'x' 입니다. 권한이 설정되지 않은 경우 해당 문자는 &lt;code&gt;'-'&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9d482d82a8c67b95f55d10ab3dda1aad0c96b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;persistPolicy&lt;/code&gt; and &lt;code&gt;currencyTimeLimit&lt;/code&gt; fields are meaningless for constructors, but are not considered invalid.</source>
          <target state="translated">&lt;code&gt;persistPolicy&lt;/code&gt; 과 &lt;code&gt;currencyTimeLimit&lt;/code&gt; 에는 필드는 생성자에 대한 의미가 있지만, 유효하지 않은 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca92d75fa54a7f375119b1732a1defda2c5a065a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;popup&lt;/code&gt; can be set on one &lt;code&gt;TrayIcon&lt;/code&gt; only. Setting the same popup on multiple &lt;code&gt;TrayIcon&lt;/code&gt;s will cause an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;popup&lt;/code&gt; 하나를 설정할 수 있습니다 &lt;code&gt;TrayIcon&lt;/code&gt; 에 만. 여러 &lt;code&gt;TrayIcon&lt;/code&gt; 에 동일한 팝업을 설정하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="822e7053ed501794bcb73e078de627432ea24760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pos&lt;/code&gt; argument may range between zero and</source>
          <target state="translated">그만큼 &lt;code&gt;pos&lt;/code&gt; 인수 제로 사이의 범위 일 수있다</target>
        </trans-unit>
        <trans-unit id="0d4b8df143426535636c3d9fcf5d259dd494e8ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pos&lt;/code&gt; argument selects which parameters are to be bound. It may range between zero and</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 매개 변수는 인수 선택이 결합된다. 0과 0 사이의 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a88d4013b421f51fd6a8b134cf58266c11d071d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred&lt;/code&gt; handle describes the loop condition; and &lt;code&gt;body&lt;/code&gt;, its body. The loop resulting from this method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate evaluates to &lt;code&gt;true&lt;/code&gt;). The loop will terminate once the predicate evaluates to &lt;code&gt;false&lt;/code&gt; (the body will not be executed in this case).</source>
          <target state="translated">그만큼 &lt;code&gt;pred&lt;/code&gt; 핸들 루프 조건을 나타내고; 그리고 &lt;code&gt;body&lt;/code&gt; , 그 몸. 이 메서드의 결과 루프는 각 반복에서 먼저 술어를 평가 한 다음 해당 본문을 실행합니다 (조건자가 &lt;code&gt;true&lt;/code&gt; 로 평가되는 경우 ). 술어가 &lt;code&gt;false&lt;/code&gt; 로 평가되면 루프가 종료됩니다 (이 경우 본문이 실행되지 않음).</target>
        </trans-unit>
        <trans-unit id="a86ac63e6484dc40818acb31efed1223ef30cbe4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred&lt;/code&gt; handle describes the loop condition; and &lt;code&gt;body&lt;/code&gt;, its body. The loop resulting from this method will, in each iteration, first execute its body and then evaluate the predicate. The loop will terminate once the predicate evaluates to &lt;code&gt;false&lt;/code&gt; after an execution of the body.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 핸들 루프 조건을 나타내고; 그리고 &lt;code&gt;body&lt;/code&gt; , 그 몸. 이 메서드의 결과 루프는 각 반복에서 먼저 본문을 실행 한 다음 술어를 평가합니다. 루프는 본문 실행 후 술어가 &lt;code&gt;false&lt;/code&gt; 평가되면 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="83271b2397fc080adb45b6ed96f5fc2c799338f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred&lt;/code&gt; handle must not be &lt;code&gt;null&lt;/code&gt;. It must have &lt;code&gt;boolean&lt;/code&gt; as its return type. Its parameter list (either empty or of the form &lt;code&gt;(V A*)&lt;/code&gt;) must be effectively identical to the internal parameter list.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 핸들이 아니어야합니다 &lt;code&gt;null&lt;/code&gt; . 반환 유형으로 &lt;code&gt;boolean&lt;/code&gt; 이 있어야합니다 . 매개 변수 목록 (비어 있거나 &lt;code&gt;(V A*)&lt;/code&gt; 형식 )은 내부 매개 변수 목록과 실질적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="12d2f504fe0c18a15bb945c0612b6e3db966f980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preferredSize&lt;/code&gt; is only computed once, subsequent calls to this method just return a cached size.</source>
          <target state="translated">&lt;code&gt;preferredSize&lt;/code&gt; 가이 한 번만 계산이 방법에 대한 후속 호출은 캐시 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3295278a86db378f96ef38915c5399dfa8f46eb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; argument must be at least three characters long. It is recommended that the prefix be a short, meaningful string such as &lt;code&gt;&quot;hjb&quot;&lt;/code&gt; or &lt;code&gt;&quot;mail&quot;&lt;/code&gt;. The &lt;code&gt;suffix&lt;/code&gt; argument may be &lt;code&gt;null&lt;/code&gt;, in which case the suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 인수는 길이 3 자 이상이어야합니다. 접두어는 &lt;code&gt;&quot;hjb&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;mail&quot;&lt;/code&gt; 과 같이 짧고 의미있는 문자열 인 것이 좋습니다 . &lt;code&gt;suffix&lt;/code&gt; 인수는있을 수 있습니다 &lt;code&gt;null&lt;/code&gt; 접미사가있는 경우에, &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="925230b553f62600c7f8ab6d82a4beb6853e7805" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;premain&lt;/code&gt; method has one of two possible signatures. The JVM first attempts to invoke the following method on the agent class:</source>
          <target state="translated">&lt;code&gt;premain&lt;/code&gt; 방법은 두 가지 중 하나의 서명이있다. JVM은 먼저 에이전트 클래스에서 다음 메소드를 호출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0521fbe64ec7e5f9ef121124473e0d97a004ca5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r.width&lt;/code&gt; or &lt;code&gt;r.height&lt;/code&gt; values will be automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.width&lt;/code&gt; 또는 &lt;code&gt;r.height&lt;/code&gt; 에 이전 호출에 의해 지정된 하나 적은 최소 크기 이하인 경우 값이 자동으로 확대된다 &lt;code&gt;setMinimumSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5caea50061710cec044d7be43530e50e1eb551a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;radix&lt;/code&gt; argument is valid if it is greater than or equal to &lt;code&gt;MIN_RADIX&lt;/code&gt; and less than or equal to &lt;code&gt;MAX_RADIX&lt;/code&gt;. The &lt;code&gt;digit&lt;/code&gt; argument is valid if &lt;code&gt;0 &amp;lt;= digit &amp;lt; radix&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;radix&lt;/code&gt; 가보다 크거나 같으면 인수 유효 &lt;code&gt;MIN_RADIX&lt;/code&gt; 미만 또는 동등 &lt;code&gt;MAX_RADIX&lt;/code&gt; . &lt;code&gt;digit&lt;/code&gt; 인수 경우 유효 &lt;code&gt;0 &amp;lt;= digit &amp;lt; radix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b33942ad43fbe9d22cb9d95c4c4908fdaa08301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;radix&lt;/code&gt; is either smaller than &lt;a href=&quot;character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or larger than &lt;a href=&quot;character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;radix&lt;/code&gt; 하나보다 작은 &lt;a href=&quot;character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt; 보다 작거나 큰 &lt;a href=&quot;character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d785142e5ab58037a089cd9e5a386011f0b7e09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ranges&lt;/code&gt; to be given can take one of the following forms:</source>
          <target state="translated">제공되는 &lt;code&gt;ranges&lt;/code&gt; 는 다음 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1259bcaaf2e03d5637399a403f2eed4bcb0658f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt; has the same effect as:</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 클래스 의 &lt;code&gt;read(b)&lt;/code&gt; 메소드 는 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4604e99f767c72aaa96525bf29f68941bb283ab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read(b)&lt;/code&gt; method has the same effect as:</source>
          <target state="translated">&lt;code&gt;read(b)&lt;/code&gt; 에있어서의 효과는 :</target>
        </trans-unit>
        <trans-unit id="d053108594714cc2e678b8a8b8bcae476c059c88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read(b,&lt;/code&gt;&lt;code&gt;off,&lt;/code&gt;&lt;code&gt;len)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt; simply calls the method &lt;code&gt;read()&lt;/code&gt; repeatedly. If the first such call results in an &lt;code&gt;IOException&lt;/code&gt;, that exception is returned from the call to the &lt;code&gt;read(b,&lt;/code&gt;&lt;code&gt;off,&lt;/code&gt;&lt;code&gt;len)&lt;/code&gt; method. If any subsequent call to &lt;code&gt;read()&lt;/code&gt; results in a &lt;code&gt;IOException&lt;/code&gt;, the exception is caught and treated as if it were end of file; the bytes read up to that point are stored into &lt;code&gt;b&lt;/code&gt; and the number of bytes read before the exception occurred is returned. The default implementation of this method blocks until the requested amount of input data &lt;code&gt;len&lt;/code&gt; has been read, end of file is detected, or an exception is thrown. Subclasses are encouraged to provide a more efficient implementation of this method.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 클래스 의 &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; 메소드는 단순히 &lt;code&gt;read()&lt;/code&gt; 메소드를 반복적으로 호출합니다 . 첫 번째 호출로 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 해당 예외는 호출에서 &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; 메소드 로 리턴됩니다 . &lt;code&gt;read()&lt;/code&gt; 대한 후속 호출로 인해 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 예외는 파일의 끝인 것처럼 잡히고 처리됩니다. 해당 시점까지 읽은 바이트 &lt;code&gt;b&lt;/code&gt; 에 예외가 발생하기 전에 읽은 바이트 수가 리턴됩니다. 이 메소드의 기본 구현은 요청 된 양의 입력 데이터가 &lt;code&gt;len&lt;/code&gt; 까지 차단됩니다.읽었거나 파일 끝이 감지되었거나 예외가 발생했습니다. 서브 클래스는이 메소드를보다 효율적으로 구현할 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="d73e15d99486a3edb623a542384b22544dac32ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; calls the &lt;code&gt;read&lt;/code&gt; method of three arguments with the arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 방법 &lt;code&gt;InputStream&lt;/code&gt; 부르는 &lt;code&gt;read&lt;/code&gt; 인수와 세 개의 인수의 방법 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;b.length&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="7efed5a820d4dabed25b8a28bd1df6414d7e77e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; calls the &lt;code&gt;read&lt;/code&gt; method of the underlying input stream. It checks for carriage returns and newline characters in the input, and modifies the current line number as appropriate. A carriage-return character or a carriage return followed by a newline character are both converted into a single newline character.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 의 방법 &lt;code&gt;LineNumberInputStream&lt;/code&gt; 가 부르는 &lt;code&gt;read&lt;/code&gt; 기본이되는 입력 스트림의 방법을. 입력에서 캐리지 리턴과 개행 문자를 확인하고 현재 행 번호를 적절하게 수정합니다. 캐리지 리턴 문자 또는 캐리지 리턴 다음에 개행 문자가 둘 다 단일 개행 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d12f1e1c60d3ded7ff55ddd8ec9fa42dcbe1312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; repeatedly calls the &lt;code&gt;read&lt;/code&gt; method of zero arguments to fill in the byte array.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 방법 &lt;code&gt;LineNumberInputStream&lt;/code&gt; 가 반복 호출 &lt;code&gt;read&lt;/code&gt; 바이트 배열을 작성 제로 인수 방법.</target>
        </trans-unit>
        <trans-unit id="9c073aae985b3b46c91c5b9276bb615fd3d6afcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;SequenceInputStream&lt;/code&gt; tries to read the data from the current substream. If it fails to read any characters because the substream has reached the end of the stream, it calls the &lt;code&gt;close&lt;/code&gt; method of the current substream and begins reading from the next substream.</source>
          <target state="translated">&lt;code&gt;SequenceInputStream&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 메소드 는 현재 서브 스트림에서 데이터를 읽으려고합니다. 서브 스트림이 스트림의 끝에 도달하여 문자를 읽지 못하면 현재 서브 스트림 의 &lt;code&gt;close&lt;/code&gt; 메소드를 호출 하고 다음 서브 스트림에서 읽기를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="266c4f3bc071054256173e68adbd4a6e7656ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;StringBufferInputStream&lt;/code&gt; cannot block. It copies the low eight bits from the characters in this input stream's buffer into the byte array argument.</source>
          <target state="translated">&lt;code&gt;StringBufferInputStream&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 메소드는 차단할 수 없습니다. 이 입력 스트림 버퍼의 문자에서 하위 8 비트를 바이트 배열 인수로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="e61745f20485b6632a27794087bfb013bec50ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;StringBufferInputStream&lt;/code&gt; cannot block. It returns the low eight bits of the next character in this input stream's buffer.</source>
          <target state="translated">&lt;code&gt;StringBufferInputStream&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 메소드는 차단할 수 없습니다. 이 입력 스트림의 버퍼에있는 다음 문자의 하위 8 비트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b68abbad5ba6fb28f94eaadf9085c6dda28742eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or</source>
          <target state="translated">기본 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드는 파일 끝을 나타내는 &lt;code&gt;-1&lt;/code&gt; 을 리턴 하거나</target>
        </trans-unit>
        <trans-unit id="3c7f1342e13b19c7f98cefc6efd106f8e231e650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; methods of the resulting stream will throw an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">결과 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드 는 기본 채널이 비 차단 모드에있는 동안 호출되면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다. 스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를. 스트림은 여러 동시 스레드에 의한 액세스에 안전합니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="6ff4f563e5b69d4b6268d50e4aa9d51aa5725103" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; methods of the resulting stream will throw an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">기본 채널이 비 블로킹 모드에있는 동안 호출되면 결과 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드에서 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 지원하지 않습니다 . 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="3b7ea7159daa93e13abc58f5ee72d1aa9624ff2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; methods of the returned &lt;code&gt;InputStream&lt;/code&gt; will throw &lt;code&gt;IOException&lt;/code&gt; when reading bytes that cannot be decoded.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 반환 된 방법 &lt;code&gt;InputStream&lt;/code&gt; 발생합니다 &lt;code&gt;IOException&lt;/code&gt; 가 디코딩 할 수없는 바이트를 읽을 때.</target>
        </trans-unit>
        <trans-unit id="05a4ee599465096efb07afcd435e0618463168e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readData&lt;/code&gt; method adds rows to the caller. It can be implemented in a wide variety of ways and can even populate the caller with rows from a nonrelational data source. In general, a reader may invoke any of the rowset's methods, with one exception. Calling the method &lt;code&gt;execute&lt;/code&gt; will cause an &lt;code&gt;SQLException&lt;/code&gt; to be thrown because &lt;code&gt;execute&lt;/code&gt; may not be called recursively. Also, when a reader invokes &lt;code&gt;RowSet&lt;/code&gt; methods, no listeners are notified; that is, no &lt;code&gt;RowSetEvent&lt;/code&gt; objects are generated and no &lt;code&gt;RowSetListener&lt;/code&gt; methods are invoked. This is true because listeners are already being notified by the method &lt;code&gt;execute&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readData&lt;/code&gt; 방법은 발신자에 행을 추가한다. 다양한 방법으로 구현할 수 있으며 비 관계형 데이터 소스의 행으로 호출자를 채울 수도 있습니다. 일반적으로 판독기는 한 가지 예외를 제외하고 행 집합의 모든 메서드를 호출 할 수 있습니다. 이 방법은 호출 &lt;code&gt;execute&lt;/code&gt; 의 원인이됩니다 &lt;code&gt;SQLException&lt;/code&gt; 때문에 슬로우 &lt;code&gt;execute&lt;/code&gt; 재귀 적으로 호출 할 수 없습니다. 또한 판독기가 &lt;code&gt;RowSet&lt;/code&gt; 메서드를 호출 할 때 리스너는 알림을받지 않습니다. 즉, &lt;code&gt;RowSetEvent&lt;/code&gt; 객체가 생성되지 않고 &lt;code&gt;RowSetListener&lt;/code&gt; 메서드가 호출 되지 않습니다 . 이는 리스너가 &lt;code&gt;execute&lt;/code&gt; 메소드에서 이미 알림을 받고 있기 때문에 사실 입니다.</target>
        </trans-unit>
        <trans-unit id="b52f6c80e4a3c11df2890b54a5a8b3b1218aeabd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to allow that many bytes to be read before the mark position gets invalidated.</source>
          <target state="translated">&lt;code&gt;readlimit&lt;/code&gt; 는의 인수는, 마크 위치가 무효가되기 전에 많은 바이트를 읽도록하려면이 입력 스트림을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f523a2bdf73035ee44a575de3e5dff08d7683039" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readlimit&lt;/code&gt; arguments tells this input stream to allow that many bytes to be read before the mark position gets invalidated.</source>
          <target state="translated">&lt;code&gt;readlimit&lt;/code&gt; 는의 인수는, 마크 위치가 무효가되기 전에 많은 바이트를 읽도록하려면이 입력 스트림을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="26aa2e19c94981b7af3edb0fd924e85788e560ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready&lt;/code&gt; method of the underlying stream returns &lt;code&gt;false&lt;/code&gt;, indicating that further input requests would block.</source>
          <target state="translated">기본 스트림 의 &lt;code&gt;ready&lt;/code&gt; 메소드는 추가 입력 요청이 &lt;code&gt;false&lt;/code&gt; 을 나타내는 false를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="82057f4ffe730acc914f906991a8da694e9b715d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple map-reduce on a stream, use &lt;a href=&quot;stream#map(java.util.function.Function)&quot;&gt;&lt;code&gt;Stream.map(Function)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">그만큼 &lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 맵 축소를 수행하려면 대신 &lt;a href=&quot;stream#map(java.util.function.Function)&quot;&gt; &lt;code&gt;Stream.map(Function)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="165873d7f5551dc1377b152568842b2aacddf487" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple map-reduce on a stream, use &lt;a href=&quot;stream#map-java.util.function.Function-&quot;&gt;&lt;code&gt;Stream.map(Function)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 맵 축소를 수행하려면 &lt;a href=&quot;stream#map-java.util.function.Function-&quot;&gt; &lt;code&gt;Stream.map(Function)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8dd7b9000da8c4a38e9a5b07cb2af0e9bc54239" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt;} instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 단순 축소를 수행하려면 대신 &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; }를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1031f383b6493cee2618b8a613faaaa7b50cece7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce(java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 단순 감소를 수행하려면 다음을 사용하십시오.&lt;a href=&quot;stream#reduce(java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt; &lt;/a&gt;대신 Stream.reduce (BinaryOperator)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e64fcbf48d32ed9f489fe7ed817a63867533729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt;} instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 축소를 수행하려면 대신 &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; }를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="331f2b86728595fcc490eed59b6a8eb8cea11e3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 축소를 수행하려면 &lt;a href=&quot;stream#reduce-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6e4a1cfb3d954ef8dc93a66017c84659865340e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refresh&lt;/code&gt; method causes the policy object to refresh/reload its data. This operation is implementation-dependent. For example, if the policy object stores its data in configuration files, calling &lt;code&gt;refresh&lt;/code&gt; will cause it to re-read the configuration policy files. If a refresh operation is not supported, this method does nothing. Note that refreshed policy may not have an effect on classes in a particular ProtectionDomain. This is dependent on the Policy provider's implementation of the &lt;code&gt;implies&lt;/code&gt; method and its PermissionCollection caching strategy.</source>
          <target state="translated">&lt;code&gt;refresh&lt;/code&gt; 방법은 정책 개체 / 새로 고침 데이터를 다시로드됩니다. 이 작업은 구현에 따라 다릅니다. 예를 들어, 정책 개체가 데이터를 구성 파일에 저장하는 경우 &lt;code&gt;refresh&lt;/code&gt; 를 호출 하면 구성 정책 파일을 다시 읽게됩니다. 새로 고침 작업이 지원되지 않으면이 방법은 아무 작업도 수행하지 않습니다. 새로 고친 정책은 특정 ProtectionDomain의 클래스에 영향을 미치지 않을 수 있습니다. 이는 정책 공급자의 &lt;code&gt;implies&lt;/code&gt; 메소드 구현 및 PermissionCollection 캐싱 전략에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e2cb1c75917513fd66c67c74580c51f242c6ba51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refreshRow&lt;/code&gt; method provides a way for an application to explicitly tell the JDBC driver to refetch a row(s) from the database. An application may want to call &lt;code&gt;refreshRow&lt;/code&gt; when caching or prefetching is being done by the JDBC driver to fetch the latest value of a row from the database. The JDBC driver may actually refresh multiple rows at once if the fetch size is greater than one.</source>
          <target state="translated">&lt;code&gt;refreshRow&lt;/code&gt; 방법은 응용 프로그램이 명시 적으로 데이터베이스에서의 행의 재 취득을 위해 JDBC 드라이버를 알 수있는 방법을 제공합니다. 응용 프로그램에서 전화를 걸 수 있습니다. &lt;code&gt;refreshRow&lt;/code&gt; 데이터베이스에서 행의 최신 값을 가져 오기 위해 JDBC 드라이버가 캐싱 또는 프리 페치를 수행 할 때 refreshRow 있습니다. JDBC 드라이버는 페치 크기가 1보다 큰 경우 실제로 한 번에 여러 행을 새로 고칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92536f2a5a0e1a3b6f9a0f2c5c546403063f5bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registerMBean&lt;/code&gt; method is simpler for local use, but cannot be used remotely. The &lt;code&gt;createMBean&lt;/code&gt; method can be used remotely, but sometimes requires attention to class loading issues.</source>
          <target state="translated">&lt;code&gt;registerMBean&lt;/code&gt; 방법은 현지 사용을위한 간단하지만 원격으로 사용할 수 없습니다. &lt;code&gt;createMBean&lt;/code&gt; 방법은 원격으로 사용할 수 있지만, 클래스의로드의 문제에주의를 필요로 할 수있다.</target>
        </trans-unit>
        <trans-unit id="3bd964509b0c0b7b2aff54193499f79341906bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registerObject&lt;/code&gt; method is used to register an activation descriptor, &lt;code&gt;desc&lt;/code&gt;, and obtain an activation identifier for a activatable remote object.</source>
          <target state="translated">&lt;code&gt;registerObject&lt;/code&gt; 의 방법은, 기동 기술자를 등록하는 데 사용 &lt;code&gt;desc&lt;/code&gt; , 및 기동 가능한 원격 객체의 기동 식별자를 얻었다.</target>
        </trans-unit>
        <trans-unit id="0648dc19ee55d0e590d0f1e083a26887e631abbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registerObject&lt;/code&gt; method is used to register an activation descriptor, &lt;code&gt;desc&lt;/code&gt;, and obtain an activation identifier for a activatable remote object. The &lt;code&gt;ActivationSystem&lt;/code&gt; creates an &lt;code&gt;ActivationID&lt;/code&gt; (a activation identifier) for the object specified by the descriptor, &lt;code&gt;desc&lt;/code&gt;, and records, in stable storage, the activation descriptor and its associated identifier for later use. When the &lt;code&gt;Activator&lt;/code&gt; receives an &lt;code&gt;activate&lt;/code&gt; request for a specific identifier, it looks up the activation descriptor (registered previously) for the specified identifier and uses that information to activate the object.</source>
          <target state="translated">&lt;code&gt;registerObject&lt;/code&gt; 에 있어서 기동 기술자 등록하는 데 사용되는 &lt;code&gt;desc&lt;/code&gt; , 및 기동 가능한 원격 객체의 기동 식별자를 얻었다. &lt;code&gt;ActivationSystem&lt;/code&gt; 를는 생성 &lt;code&gt;ActivationID&lt;/code&gt; , 기술자에 의해 지정된 개체 (기동 식별자) &lt;code&gt;desc&lt;/code&gt; 안정된 저장, 나중에 사용하기위한 기동 기술자 및 관련 식별자에, 그리고 기록. 때 &lt;code&gt;Activator&lt;/code&gt; 수신 &lt;code&gt;activate&lt;/code&gt; 특정 식별자에 대한 요청을, 상기 지정된 식별자 및 정보 객체를 활성화 할 것을 용도 기동 기술자 (미리 등록)를 보인다.</target>
        </trans-unit>
        <trans-unit id="d5b769a6261bcf9c925196e481e33f743eb9161c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replaceEditor&lt;/code&gt; method is called when the spinners editor is changed with &lt;code&gt;JSpinner.setEditor&lt;/code&gt;. If you've overriden this method, then you'll probably want to override &lt;code&gt;replaceEditor&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;replaceEditor&lt;/code&gt; 스피 나 에디터가로 변경 될 때 메소드가 불려 &lt;code&gt;JSpinner.setEditor&lt;/code&gt; . 이 메서드를 재정의했다면 &lt;code&gt;replaceEditor&lt;/code&gt; 를 재정의하고 싶을 것입니다. 도 .</target>
        </trans-unit>
        <trans-unit id="b2bff7fa0a0c8c4fa4c945d1cc03fe4bb97f5383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;required&lt;/code&gt; field is &lt;code&gt;true&lt;/code&gt; if a value must be supplied for this property during &lt;code&gt;Driver.connect&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; 필드는 &lt;code&gt;true&lt;/code&gt; 값을 지정해야하는 경우, &lt;code&gt;Driver.connect&lt;/code&gt; 에 와 &lt;code&gt;false&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dec43624de062d1e7493f56cb68ff2515b4d245d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; resets the line number to be the line number at the time the &lt;code&gt;mark&lt;/code&gt; method was called, and then calls the &lt;code&gt;reset&lt;/code&gt; method of the underlying input stream.</source>
          <target state="translated">&lt;code&gt;LineNumberInputStream&lt;/code&gt; 의 &lt;code&gt;reset&lt;/code&gt; 메소드는 &lt;code&gt;mark&lt;/code&gt; 메소드가 호출 될 때 행 번호가되도록 행 번호를 &lt;code&gt;reset&lt;/code&gt; 한 다음 기본 입력 스트림 의 reset 메소드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bcb2620e18cfc65d493f7d3aa17132a5ca731483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;root&lt;/code&gt; node of the &lt;code&gt;TreeWalker&lt;/code&gt;, as specified when it was created.</source>
          <target state="translated">그만큼 &lt;code&gt;root&lt;/code&gt; 의 노드 &lt;code&gt;TreeWalker&lt;/code&gt; 는 이 생성 된 경우로 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="ef077420b03ffbe4cf9c89bd8f72839c46602b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; components should be floating-point values between zero and one (numbers in the range 0.0-1.0). The &lt;code&gt;h&lt;/code&gt; component can be any floating-point number. The floor of this number is subtracted from it to create a fraction between 0 and 1. This fractional number is then multiplied by 360 to produce the hue angle in the HSB color model.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 성분 (0.0 ~ 1.0의 범위의 수)는 0과 1 사이의 부동 소수점 값이어야한다. &lt;code&gt;h&lt;/code&gt; 구성 요소는 부동 소수점 숫자가 될 수 있습니다. 이 숫자의 하한값을 빼서 0과 1 사이의 분수를 만듭니다. 그런 다음이 분수에 360을 곱하여 HSB 색상 모델에서 색조 각도를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e6920483d1b5d5fdadee6caa3bd9747d28274c80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;saturation&lt;/code&gt; and &lt;code&gt;brightness&lt;/code&gt; components should be floating-point values between zero and one (numbers in the range 0.0-1.0). The &lt;code&gt;hue&lt;/code&gt; component can be any floating-point number. The floor of this number is subtracted from it to create a fraction between 0 and 1. This fractional number is then multiplied by 360 to produce the hue angle in the HSB color model.</source>
          <target state="translated">&lt;code&gt;saturation&lt;/code&gt; 및 &lt;code&gt;brightness&lt;/code&gt; 성분 (0.0 ~ 1.0의 범위의 수)는 0과 1 사이의 부동 소수점 값이어야한다. &lt;code&gt;hue&lt;/code&gt; 구성 요소는 부동 소수점 숫자가 될 수 있습니다. 이 숫자의 하한값을 빼서 0과 1 사이의 분수를 만듭니다. 그런 다음이 분수에 360을 곱하여 HSB 색상 모델에서 색조 각도를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9e487af727a443b2fc09683914bf955d5aed101d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schedule&lt;/code&gt; methods create tasks with various delays and return a task object that can be used to cancel or check execution. The &lt;code&gt;scheduleAtFixedRate&lt;/code&gt; and &lt;code&gt;scheduleWithFixedDelay&lt;/code&gt; methods create and execute tasks that run periodically until cancelled.</source>
          <target state="translated">&lt;code&gt;schedule&lt;/code&gt; 메서드는 다양한 지연을 가지는 태스크를 생성하고 취소 체크 실행하는 데 사용할 수있는 작업 개체를 반환합니다. &lt;code&gt;scheduleAtFixedRate&lt;/code&gt; 및 &lt;code&gt;scheduleWithFixedDelay&lt;/code&gt; 방법은 생성하고 해제 할 때까지 주기적으로 실행 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="08c9e29dc36b0482fbc29013fb24d1e073d335c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scrollUnderway&lt;/code&gt; flag is used for components like &lt;code&gt;JList&lt;/code&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;scrollUnderway&lt;/code&gt; 의 플래그와 같은 구성 요소에 사용되는 &lt;code&gt;JList&lt;/code&gt; 의 .</target>
        </trans-unit>
        <trans-unit id="0d1c017ef96a248d10e61c88fe2cbb2851eb303e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scrollUnderway&lt;/code&gt; flag is used for components like &lt;code&gt;JList&lt;/code&gt;. When the downarrow key is pressed on a &lt;code&gt;JList&lt;/code&gt; and the selected cell is the last in the list, the &lt;code&gt;scrollpane&lt;/code&gt; autoscrolls. Here, the old selected cell needs repainting and so we need a flag to make the viewport do the optimized painting only when there is an explicit call to &lt;code&gt;setViewPosition(Point)&lt;/code&gt;. When &lt;code&gt;setBounds&lt;/code&gt; is called through other routes, the flag is off and the view repaints normally. Another approach would be to remove this from the &lt;code&gt;JViewport&lt;/code&gt; class and have the &lt;code&gt;JList&lt;/code&gt; manage this case by using &lt;code&gt;setBackingStoreEnabled&lt;/code&gt;. The default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scrollUnderway&lt;/code&gt; 의 플래그와 같은 구성 요소에 사용되는 &lt;code&gt;JList&lt;/code&gt; 를 . &lt;code&gt;JList&lt;/code&gt; 에서 아래쪽 화살표 키를 누르고 선택한 셀이 목록의 마지막 셀이면 &lt;code&gt;scrollpane&lt;/code&gt; 창이 자동 스크롤됩니다. 여기에서 이전에 선택한 셀은 다시 칠해야하므로 &lt;code&gt;setViewPosition(Point)&lt;/code&gt; 대한 명시 적 호출이있을 때만 뷰포트에서 최적화 된 페인팅을 수행하도록하는 플래그가 필요합니다 . &lt;code&gt;setBounds&lt;/code&gt; 가 다른 경로를 통해 호출 되면 플래그가 꺼지고 뷰가 정상적으로 다시 그려집니다. 또 다른 접근 방식은 &lt;code&gt;JViewport&lt;/code&gt; 클래스 에서 이것을 제거 하고 &lt;code&gt;JList&lt;/code&gt; 가 &lt;code&gt;setBackingStoreEnabled&lt;/code&gt; 를 사용 하여이 경우를 관리하도록하는 것 입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="275b9770ecb642dad5739bf9b860015b219e5bc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seekForwardOnly&lt;/code&gt; parameter controls whether the value returned by &lt;code&gt;getMinIndex&lt;/code&gt; will be increased as each image (or thumbnail, or image metadata) is read. If &lt;code&gt;seekForwardOnly&lt;/code&gt; is true, then a call to &lt;code&gt;read(index)&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; if &lt;code&gt;index &amp;lt; this.minIndex&lt;/code&gt;; otherwise, the value of &lt;code&gt;minIndex&lt;/code&gt; will be set to &lt;code&gt;index&lt;/code&gt;. If &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the value of &lt;code&gt;minIndex&lt;/code&gt; will remain 0 regardless of any read operations.</source>
          <target state="translated">&lt;code&gt;seekForwardOnly&lt;/code&gt; 의해 리턴 된 값 여부 파라미터 조절기 &lt;code&gt;getMinIndex&lt;/code&gt; 각 화상 (또는 썸네일 이미지 또는 메타 데이터)으로 상승한다이 판독된다. 경우 &lt;code&gt;seekForwardOnly&lt;/code&gt; 는 사실에의 호출 &lt;code&gt;read(index)&lt;/code&gt; 발생합니다 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 경우 &lt;code&gt;index &amp;lt; this.minIndex&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;minIndex&lt;/code&gt; 값이 &lt;code&gt;index&lt;/code&gt; 로 설정됩니다 . 경우 &lt;code&gt;seekForwardOnly&lt;/code&gt; 가 인 &lt;code&gt;false&lt;/code&gt; 의 값 &lt;code&gt;minIndex&lt;/code&gt; 관계없이 읽기 작업의 0을 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d1482f0d46f1a2acb9dc1233fcf5f91d87996d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sendClose&lt;/code&gt; method does not close this WebSocket's input. It merely closes this WebSocket's output by sending a Close message. To enforce closing the input, invoke the &lt;code&gt;abort&lt;/code&gt; method. Here is an example of an application that sends a Close message, and then starts a timer. Once no data has been received within the specified timeout, the timer goes off and the alarm aborts &lt;code&gt;WebSocket&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sendClose&lt;/code&gt; 방법은이 웹 소켓의 입력 닫히지 않습니다. Close 메시지를 보내이 WebSocket의 출력을 닫을뿐입니다. 입력을 강제로 닫으려면 &lt;code&gt;abort&lt;/code&gt; 메서드를 호출합니다 . 다음은 닫기 메시지를 보낸 다음 타이머를 시작하는 응용 프로그램의 예입니다. 지정된 제한 시간 내에 데이터가 수신되지 않으면 타이머가 꺼지고 알람이 &lt;code&gt;WebSocket&lt;/code&gt; 을 중단합니다. .</target>
        </trans-unit>
        <trans-unit id="2b89c456d2b4bd25e583ec6cc1aa01d8496f3f6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setPaintMode&lt;/code&gt; method is implemented as a convenience method to set the default &lt;code&gt;Composite&lt;/code&gt;, equivalent to &lt;code&gt;setComposite(new AlphaComposite.SrcOver)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setPaintMode&lt;/code&gt; 의 방법은 기본 설정하기위한 편의 수단으로 구현되는 &lt;code&gt;Composite&lt;/code&gt; 등가, &lt;code&gt;setComposite(new AlphaComposite.SrcOver)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43b250cc63cb491b2b4915e37282c63d786eef72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setSize&lt;/code&gt; method should be prepared to be called a number of times (i.e. It may be called even if the size didn't change). The &lt;code&gt;setSize&lt;/code&gt; method is generally called to make sure the View layout is complete prior to trying to perform an operation on it that requires an up-to-date layout. A view's size should &lt;em&gt;always&lt;/em&gt; be set to a value within the minimum and maximum span specified by that view. Additionally, the view must always call the &lt;code&gt;preferenceChanged&lt;/code&gt; method on the parent if it has changed the values for the layout it would like, and expects the parent to honor. The parent View is not required to recognize a change until the &lt;code&gt;preferenceChanged&lt;/code&gt; has been sent. This allows parent View implementations to cache the child requirements if desired. The calling sequence looks something like the following:</source>
          <target state="translated">&lt;code&gt;setSize&lt;/code&gt; 방법은 여러 번 호출 할 수 있도록 준비해야한다 (사이즈가 변경되지 않는 경우에서도 호출 할 수 있습니다 즉). &lt;code&gt;setSize&lt;/code&gt; 방법은 일반적으로 확인보기 레이아웃 전에 최신의 레이아웃을 필요로하는 작업을 수행하려고 노력을 완료하기 위해 호출된다. 보기의 크기는 &lt;em&gt;항상&lt;/em&gt; 해당보기에서 지정한 최소 및 최대 범위 내의 값으로 설정 되어야 합니다. 또한보기는 원하는 레이아웃의 값을 변경하고 부모가 존중할 것으로 예상하는 경우 부모에서 항상 &lt;code&gt;preferenceChanged&lt;/code&gt; 메서드를 호출해야합니다 . parent View는 &lt;code&gt;preferenceChanged&lt;/code&gt; 까지 변경을 인식 할 필요가 없습니다.전송 된. 이를 통해 원하는 경우 상위 View 구현이 하위 요구 사항을 캐시 할 수 있습니다. 호출 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42f025b3d9979c63bfda933d9c9717fb99aa29ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setXORMode(Color xorcolor)&lt;/code&gt; method is implemented as a convenience method to set a special &lt;code&gt;Composite&lt;/code&gt; object that ignores the &lt;code&gt;Alpha&lt;/code&gt; components of source colors and sets the destination color to the value:</source>
          <target state="translated">&lt;code&gt;setXORMode(Color xorcolor)&lt;/code&gt; 방법은 특별한 설정하는 편리한 방법으로 구현 &lt;code&gt;Composite&lt;/code&gt; 무시 객체 &lt;code&gt;Alpha&lt;/code&gt; 소스 컬러 성분 값 및 목표 색을 설정 :</target>
        </trans-unit>
        <trans-unit id="e4d9578b126fe071444650921e8afdae2dde1b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shape&lt;/code&gt; argument may have the following values:</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 인수는 다음과 같은 값을 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bf825e34076ebaf2f0b03cf88441dbd2884319b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; array parameter is internally copied, so that subsequent changes to the array referenced by &lt;code&gt;
 signature&lt;/code&gt; have no effect on this instance.</source>
          <target state="translated">The &lt;code&gt;signature&lt;/code&gt; array parameter is internally copied, so that subsequent changes to the array referenced by &lt;code&gt; signature&lt;/code&gt; have no effect on this instance.</target>
        </trans-unit>
        <trans-unit id="76ca7bc87a7a645eee5be869e5f2afee6e7546a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; array parameter is internally copied, so that subsequent changes to the array referenced by &lt;code&gt;signature&lt;/code&gt; have no effect on this instance.</source>
          <target state="translated">&lt;code&gt;signature&lt;/code&gt; 배열 매개 변수는 내부적으로 참조되는 그 후의 배열의 변경 그래서, 복사 &lt;code&gt;signature&lt;/code&gt; 이 인스턴스에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ab62abd8dea24de7feab17efb96ab240af801b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;isEmpty&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, and &lt;code&gt;listIterator&lt;/code&gt; operations run in constant time. The &lt;code&gt;add&lt;/code&gt; operation runs in</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; , &lt;code&gt;isEmpty&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; 및 &lt;code&gt;listIterator&lt;/code&gt; 의의 일정한 시간에 실행 작업. &lt;code&gt;add&lt;/code&gt; 작업이 실행됩니다</target>
        </trans-unit>
        <trans-unit id="9a1118dd39358bc6d8e191accb546fe46ebdd2b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method implementation of this class creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method. For instance, the implementation may depend on the ability to seek.</source>
          <target state="translated">The &lt;code&gt;skip&lt;/code&gt; method implementation of this class creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method. For instance, the implementation may depend on the ability to seek.</target>
        </trans-unit>
        <trans-unit id="a4a7eb3594e941fdb97e903210733646c272b12a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is negative, the method will try to skip backwards. In case the backing file does not support backward skip at its current position, an &lt;code&gt;IOException&lt;/code&gt; is thrown. The actual number of bytes skipped is returned. If it skips forwards, it returns a positive value. If it skips backwards, it returns a negative value.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; 방법은 여러 가지 이유로,보다 적은 바이트 수 밖에 스킵 수 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;code&gt;n&lt;/code&gt; 은 음, 방법은 뒤로 건너하려고합니다. 백업 파일이 현재 위치에서 뒤로 건너 뛰기를 지원하지 않는 경우 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다. 건너 뛴 실제 바이트 수가 반환됩니다. 앞으로 건너 뛰면 양수 값을 반환합니다. 뒤로 건너 뛰면 음수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66c38c1c54f362c964143fb2033b1ddc5a7e0a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached.</source>
          <target state="translated">&lt;code&gt;LineNumberInputStream&lt;/code&gt; 의 &lt;code&gt;skip&lt;/code&gt; 메소드는 바이트 배열을 작성한 다음 &lt;code&gt;n&lt;/code&gt; 바이트를 읽거나 스트림의 끝에 도달 할 때까지 반복적으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="6a923526e0376b2377270933dbe7190607b0ff31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method of &lt;code&gt;PushbackInputStream&lt;/code&gt; first skips over the bytes in the pushback buffer, if any. It then calls the &lt;code&gt;skip&lt;/code&gt; method of the underlying input stream if more bytes need to be skipped. The actual number of bytes skipped is returned.</source>
          <target state="translated">&lt;code&gt;PushbackInputStream&lt;/code&gt; 의 &lt;code&gt;skip&lt;/code&gt; 메소드는 먼저 푸시 백 버퍼의 바이트를 건너 뜁니다 (있는 경우). 그런 다음 더 많은 바이트를 건너 뛸 필요가있는 경우 기본 입력 스트림 의 &lt;code&gt;skip&lt;/code&gt; 메소드 를 호출합니다 . 건너 뛴 실제 바이트 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c16533536dab6e2f9b65c6a5002fc87433ad4e31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method of this class creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method. For instance, the implementation may depend on the ability to seek.</source>
          <target state="translated">이 클래스 의 &lt;code&gt;skip&lt;/code&gt; 메소드는 바이트 배열을 작성한 다음 &lt;code&gt;n&lt;/code&gt; 바이트를 읽거나 스트림의 끝에 도달 할 때까지 반복적으로 읽습니다 . 서브 클래스는이 메소드를보다 효율적으로 구현할 것을 권장합니다. 예를 들어, 구현은 탐색 능력에 의존 할 수있다.</target>
        </trans-unit>
        <trans-unit id="48bb13788e4dffd1bf5c784a19fc6b8edec85d28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument and &lt;code&gt;dest&lt;/code&gt; argument refer to arrays whose component types are different primitive types.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인수 및 &lt;code&gt;dest&lt;/code&gt; 인수는 그 구성 요소 유형의 다른 원시적 형이다 배열을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ded185c55f988e1ab8aa4ba594d8425c8a39394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a primitive component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array with a reference component type.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인자는 프리미티브 컴포넌트 유형의 배열을 의미하고, &lt;code&gt;dest&lt;/code&gt; 인수는 기준 성분 유형 배열을 말한다.</target>
        </trans-unit>
        <trans-unit id="9b64842c9ed7d557d1d18f19836d86fd1cadc9b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a reference component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array with a primitive component type.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인수는 기준 부품 형태로 배열를 참조하여 &lt;code&gt;dest&lt;/code&gt; 인자는 프리미티브 컴포넌트 유형의 배열을 말한다.</target>
        </trans-unit>
        <trans-unit id="17390f5ec2c7023bf41b502643c3390be1470837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument refers to an object that is not an array.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인수 배열이 아닌 오브젝트를 지칭한다.</target>
        </trans-unit>
        <trans-unit id="32cf5d4487a70ff5b3296fb66460f51ac7c6a160" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;srcPos&lt;/code&gt; argument is negative.</source>
          <target state="translated">&lt;code&gt;srcPos&lt;/code&gt; 인수는 부정적이다.</target>
        </trans-unit>
        <trans-unit id="be02728a3743350708b8b357f2bfb78e56f08541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; handles must not be &lt;code&gt;null&lt;/code&gt;, and must both return the common type &lt;code&gt;int&lt;/code&gt;, referred to here as &lt;code&gt;I&lt;/code&gt; in parameter type lists.</source>
          <target state="translated">The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; handles must not be &lt;code&gt;null&lt;/code&gt; , and must both return the common type &lt;code&gt;int&lt;/code&gt; , referred to here as &lt;code&gt;I&lt;/code&gt; in parameter type lists.</target>
        </trans-unit>
        <trans-unit id="6dc25c0527566429af8136756050546b7203d021" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; parameters can be &lt;code&gt;null&lt;/code&gt; to indicate that the range doesn't have an upper or lower bound. If &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;calendarField&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or if both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are specified and &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Similarly if &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum)&lt;/code&gt; is false, an IllegalArgumentException is thrown.</source>
          <target state="translated">The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; parameters can be &lt;code&gt;null&lt;/code&gt; to indicate that the range doesn't have an upper or lower bound. If &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;calendarField&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; , or if both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are specified and &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Similarly if &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum)&lt;/code&gt; is false, an IllegalArgumentException is thrown.</target>
        </trans-unit>
        <trans-unit id="e4cc6c311e7eebc97573c7745efa0c1accd23d43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;startPipeline&lt;/code&gt; method performs the same checks on each ProcessBuilder as does the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. The new process will invoke the command and arguments given by &lt;a href=&quot;#command()&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by &lt;a href=&quot;#directory()&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by &lt;a href=&quot;#environment()&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The &lt;code&gt;startPipeline&lt;/code&gt; method performs the same checks on each ProcessBuilder as does the &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; method. The new process will invoke the command and arguments given by &lt;a href=&quot;#command()&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt;, in a working directory as given by &lt;a href=&quot;#directory()&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt;, with a process environment as given by &lt;a href=&quot;#environment()&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="076b65d1dcb2536b5b9253389218e30908409663" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stateChange&lt;/code&gt; of any &lt;code&gt;ItemEvent&lt;/code&gt; instance takes one of the following values:</source>
          <target state="translated">The &lt;code&gt;stateChange&lt;/code&gt; of any &lt;code&gt;ItemEvent&lt;/code&gt; instance takes one of the following values:</target>
        </trans-unit>
        <trans-unit id="4d7e3c187b7502624a8ff731ccc49ed33e5b1f80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;statusCode&lt;/code&gt; is an integer from the range &lt;code&gt;1000 &amp;lt;= code &amp;lt;= 4999&lt;/code&gt;. Status codes &lt;code&gt;1002&lt;/code&gt;, &lt;code&gt;1003&lt;/code&gt;, &lt;code&gt;1006&lt;/code&gt;, &lt;code&gt;1007&lt;/code&gt;, &lt;code&gt;1009&lt;/code&gt;, &lt;code&gt;1010&lt;/code&gt;, &lt;code&gt;1012&lt;/code&gt;, &lt;code&gt;1013&lt;/code&gt; and &lt;code&gt;1015&lt;/code&gt; are illegal. Behaviour in respect to other status codes is implementation-specific. A legal &lt;code&gt;reason&lt;/code&gt; is a string that has a UTF-8 representation not longer than &lt;code&gt;123&lt;/code&gt; bytes.</source>
          <target state="translated">The &lt;code&gt;statusCode&lt;/code&gt; is an integer from the range &lt;code&gt;1000 &amp;lt;= code &amp;lt;= 4999&lt;/code&gt; . Status codes &lt;code&gt;1002&lt;/code&gt; , &lt;code&gt;1003&lt;/code&gt; , &lt;code&gt;1006&lt;/code&gt; , &lt;code&gt;1007&lt;/code&gt; , &lt;code&gt;1009&lt;/code&gt; , &lt;code&gt;1010&lt;/code&gt; , &lt;code&gt;1012&lt;/code&gt; , &lt;code&gt;1013&lt;/code&gt; and &lt;code&gt;1015&lt;/code&gt; are illegal. Behaviour in respect to other status codes is implementation-specific. A legal &lt;code&gt;reason&lt;/code&gt; is a string that has a UTF-8 representation not longer than &lt;code&gt;123&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="96a37830010cc84066474823aaa8925f3e262fd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow.</source>
          <target state="translated">The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow.</target>
        </trans-unit>
        <trans-unit id="87a32d228a0f8798ef1bced948af76af2274fc0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow. If this method is called by any &lt;code&gt;EventListener&lt;/code&gt; the event will cease propagating through the tree. The event will complete dispatch to all listeners on the current &lt;code&gt;EventTarget&lt;/code&gt; before event flow stops. This method may be used during any stage of event flow.</source>
          <target state="translated">The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow. If this method is called by any &lt;code&gt;EventListener&lt;/code&gt; the event will cease propagating through the tree. The event will complete dispatch to all listeners on the current &lt;code&gt;EventTarget&lt;/code&gt; before event flow stops. This method may be used during any stage of event flow.</target>
        </trans-unit>
        <trans-unit id="345b6d87d178ad048ca717372d6308e35699c398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stream&lt;/code&gt; walks the file tree as elements are consumed. The &lt;code&gt;Stream&lt;/code&gt; returned is guaranteed to have at least one element, the starting file itself. For each file visited, the stream attempts to read its &lt;a href=&quot;attribute/basicfileattributes&quot;&gt;&lt;code&gt;BasicFileAttributes&lt;/code&gt;&lt;/a&gt;. If the file is a directory and can be opened successfully, entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; will follow the directory in the stream as they are encountered. When all entries have been visited, then the directory is closed. The file tree walk then continues at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 요소가 소비의 파일 트리를 안내합니다. 리턴 된 &lt;code&gt;Stream&lt;/code&gt; 은 적어도 하나의 요소, 시작 파일 자체를 갖도록 보장됩니다. 방문한 각 파일에 대해 스트림은 &lt;a href=&quot;attribute/basicfileattributes&quot;&gt; &lt;code&gt;BasicFileAttributes&lt;/code&gt; &lt;/a&gt; 를 읽으려고 시도합니다 . 파일이 디렉토리이고 성공적으로 열 수있는 경우 디렉토리의 항목 및 해당 &lt;em&gt;하위&lt;/em&gt; 항목 은 스트림에서 디렉토리를 따라갑니다. 모든 항목을 방문하면 디렉토리가 닫힙니다. 그런 다음 파일 트리 워크는 다음 디렉토리의 &lt;em&gt;형제&lt;/em&gt; 에서 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3710d2b5eccac183494c98736ff55e0daad76d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; factory methods provide clocks based on the best available system clock This may use &lt;a href=&quot;../lang/system#currentTimeMillis()&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;, or a higher resolution clock if one is available.</source>
          <target state="translated">The &lt;code&gt;system&lt;/code&gt; factory methods provide clocks based on the best available system clock This may use &lt;a href=&quot;../lang/system#currentTimeMillis()&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt;, or a higher resolution clock if one is available.</target>
        </trans-unit>
        <trans-unit id="bbed603ba13286eef01f00c49ed0143e560232fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; factory methods provide clocks based on the best available system clock This may use &lt;a href=&quot;../lang/system#currentTimeMillis--&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;, or a higher resolution clock if one is available.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 팩토리 메소드는이 사용할 수 있습니다 가능한 최상의 시스템 클럭을 기준으로 시계 제공 &lt;a href=&quot;../lang/system#currentTimeMillis--&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt; 사용 가능한 경우, 또는 더 높은 해상도 시계를.</target>
        </trans-unit>
        <trans-unit id="705416f1898f90c6d7101837ec2872b8de0927e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt;. The &lt;code&gt;baseUri&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in an xml source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt;, thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</source>
          <target state="translated">The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt; . The &lt;code&gt;baseUri&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in an xml source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt; , thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</target>
        </trans-unit>
        <trans-unit id="5fa8fe0340ab2e43b8e4f2fccf1346d93701ab46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt;. The &lt;code&gt;baseUri&lt;/code&gt;, &lt;code&gt;namespaceUri&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in a source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt;, thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</source>
          <target state="translated">The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt; . The &lt;code&gt;baseUri&lt;/code&gt; , &lt;code&gt;namespaceUri&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in a source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt; , thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</target>
        </trans-unit>
        <trans-unit id="102c04e139e85c06b332c1cf89cc171685c4335a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt; handles must have the same corresponding argument and return types, except that the &lt;code&gt;cleanup&lt;/code&gt; handle may omit trailing arguments. Also, the &lt;code&gt;cleanup&lt;/code&gt; handle must have one or two extra leading parameters:</source>
          <target state="translated">The &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt; handles must have the same corresponding argument and return types, except that the &lt;code&gt;cleanup&lt;/code&gt; handle may omit trailing arguments. Also, the &lt;code&gt;cleanup&lt;/code&gt; handle must have one or two extra leading parameters:</target>
        </trans-unit>
        <trans-unit id="fc9c79ee1df025d55ac0b05752be64291c34d35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; and the &lt;code&gt;methodName&lt;/code&gt; values should not be &lt;code&gt;null&lt;/code&gt;. Otherwise an attempt to execute this &lt;code&gt;Expression&lt;/code&gt; will result in a &lt;code&gt;NullPointerException&lt;/code&gt;. If the &lt;code&gt;arguments&lt;/code&gt; value is &lt;code&gt;null&lt;/code&gt;, an empty array is used as the value of the &lt;code&gt;arguments&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 과 &lt;code&gt;methodName&lt;/code&gt; 로의 값이어야한다 &lt;code&gt;null&lt;/code&gt; . 그렇지 않으면이 &lt;code&gt;Expression&lt;/code&gt; 을 실행하려고 하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다. 경우] &lt;code&gt;arguments&lt;/code&gt; 값은 &lt;code&gt;null&lt;/code&gt; 빈 배열의 값으로서 사용되는 &lt;code&gt;arguments&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="67df39f98209ce29324f6940292995bb97c5d095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; parameter is the target of the link. It may be an &lt;a href=&quot;path#isAbsolute()&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link.</source>
          <target state="translated">The &lt;code&gt;target&lt;/code&gt; parameter is the target of the link. It may be an &lt;a href=&quot;path#isAbsolute()&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link.</target>
        </trans-unit>
        <trans-unit id="643140ef281b03db8ff1987c73ac0c49fd06dd1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; parameter is the target of the link. It may be an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 파라미터는 링크의 대상이다. &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 또는 상대 경로 일 수 있으며 존재하지 않을 수 있습니다. 대상이 상대 경로 인 경우 결과 링크에서 파일 시스템 조작은 링크 경로에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="0009c69a4dc15a49dcbf1a0c8eae01039c7c4a96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thumbnails&lt;/code&gt; argument must either be &lt;code&gt;null&lt;/code&gt; or contain only &lt;code&gt;BufferedImage&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;thumbnails&lt;/code&gt; 인수는 하나 여야합니다 &lt;code&gt;null&lt;/code&gt; 또는에만 포함 &lt;code&gt;BufferedImage&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="7f203db2af4b065dabcc3805554e22404c4433c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeStamp&lt;/code&gt; of the notification is a time value (consistent with &lt;a href=&quot;../../../../java.base/java/lang/system#currentTimeMillis()&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;) indicating when the notification was constructed.</source>
          <target state="translated">The &lt;code&gt;timeStamp&lt;/code&gt; of the notification is a time value (consistent with &lt;a href=&quot;../../../../java.base/java/lang/system#currentTimeMillis()&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt;) indicating when the notification was constructed.</target>
        </trans-unit>
        <trans-unit id="a0e9ab517d625c7c2deaf59529ad7e0219c013fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeStamp&lt;/code&gt; of the notification is a time value (consistent with &lt;a href=&quot;../../../java/lang/system#currentTimeMillis--&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;) indicating when the notification was constructed.</source>
          <target state="translated">알림 의 &lt;code&gt;timeStamp&lt;/code&gt; 는 알림이 생성 된시기를 나타내는 시간 값 ( &lt;a href=&quot;../../../java/lang/system#currentTimeMillis--&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt; 일치 )입니다.</target>
        </trans-unit>
        <trans-unit id="b2dc1977f789016cfbe08995493b9abe10ad9cbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toString&lt;/code&gt; method for class &lt;code&gt;Object&lt;/code&gt; returns a string consisting of the name of the class of which the object is an instance, the at-sign character `&lt;code&gt;@&lt;/code&gt;', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 클래스 의 &lt;code&gt;toString&lt;/code&gt; 메소드 는 오브젝트가 인스턴스 인 클래스의 이름, at 기호 문자` &lt;code&gt;@&lt;/code&gt; '및 오브젝트의 해시 코드의 부호없는 16 진 표현으로 구성된 문자열을 리턴 합니다. 즉,이 메소드는 다음 값과 동일한 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f35e165aad5f7865197b005be9bb45266399d993" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toString&lt;/code&gt; method may return two different values on two &lt;code&gt;StackTraceElement&lt;/code&gt; instances that are &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;equal&lt;/a&gt;, for example one created via the constructor, and one obtained from &lt;a href=&quot;throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stackwalker.stackframe&quot;&gt;&lt;code&gt;StackWalker.StackFrame&lt;/code&gt;&lt;/a&gt;, where an implementation may choose to omit some element in the returned string.</source>
          <target state="translated">The &lt;code&gt;toString&lt;/code&gt; method may return two different values on two &lt;code&gt;StackTraceElement&lt;/code&gt; instances that are &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;equal&lt;/a&gt;, for example one created via the constructor, and one obtained from &lt;a href=&quot;throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;stackwalker.stackframe&quot;&gt; &lt;code&gt;StackWalker.StackFrame&lt;/code&gt; &lt;/a&gt;, where an implementation may choose to omit some element in the returned string.</target>
        </trans-unit>
        <trans-unit id="bc716b32be2e2ea2d617e608d9ff17039ae30d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be a valid value for the byte that follows the status byte in the &lt;code&gt;MetaMessage&lt;/code&gt;. The &lt;code&gt;data&lt;/code&gt; argument should contain all the subsequent bytes of the &lt;code&gt;MetaMessage&lt;/code&gt;. In other words, the byte that specifies the type of &lt;code&gt;MetaMessage&lt;/code&gt; is not considered a data byte.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 인자는의 상태 바이트 다음 바이트의 유효 값이 &lt;code&gt;MetaMessage&lt;/code&gt; 의이 . &lt;code&gt;data&lt;/code&gt; 인수는 모든 후속 바이트를 포함해야 &lt;code&gt;MetaMessage&lt;/code&gt; 의를 . 즉, &lt;code&gt;MetaMessage&lt;/code&gt; 유형을 지정하는 바이트는 데이터 바이트로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06b9218c7159f9ade16823be04d6c173149333fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; of any &lt;code&gt;AdjustmentEvent&lt;/code&gt; instance takes one of the following values:</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; of any &lt;code&gt;AdjustmentEvent&lt;/code&gt; instance takes one of the following values:</target>
        </trans-unit>
        <trans-unit id="9d6e7d46137f25ad7f8964128a6f000618a91b9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter indicates the relation between the two components. If the two components will be contained in the same parent and are showing similar logically related items, use &lt;code&gt;RELATED&lt;/code&gt;. If the two components will be contained in the same parent but show logically unrelated items use &lt;code&gt;UNRELATED&lt;/code&gt;. Some look and feels may not distinguish between the &lt;code&gt;RELATED&lt;/code&gt; and &lt;code&gt;UNRELATED&lt;/code&gt; types.</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; parameter indicates the relation between the two components. If the two components will be contained in the same parent and are showing similar logically related items, use &lt;code&gt;RELATED&lt;/code&gt; . If the two components will be contained in the same parent but show logically unrelated items use &lt;code&gt;UNRELATED&lt;/code&gt; . Some look and feels may not distinguish between the &lt;code&gt;RELATED&lt;/code&gt; and &lt;code&gt;UNRELATED&lt;/code&gt; types.</target>
        </trans-unit>
        <trans-unit id="fc25f1a4f79c0d9cb38f65494514c69d349c3f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attributes required and this method returns an instance of that type if supported. All implementations support a basic set of file attributes and so invoking this method with a &lt;code&gt;type&lt;/code&gt; parameter of &lt;code&gt;
 BasicFileAttributes.class&lt;/code&gt; will not throw &lt;code&gt;
 UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attributes required and this method returns an instance of that type if supported. All implementations support a basic set of file attributes and so invoking this method with a &lt;code&gt;type&lt;/code&gt; parameter of &lt;code&gt; BasicFileAttributes.class&lt;/code&gt; will not throw &lt;code&gt; UnsupportedOperationException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="714e35a3944791dcc0a21aa2cfb1cc1a672a4844" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attributes required and this method returns an instance of that type if supported. All implementations support a basic set of file attributes and so invoking this method with a &lt;code&gt;type&lt;/code&gt; parameter of &lt;code&gt;BasicFileAttributes.class&lt;/code&gt; will not throw &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 매개 변수는 필수 속성의 유형 및 지원하는 경우이 방법은 해당 유형의 인스턴스를 반환합니다. 모든 구현은 기본 파일 속성 세트를 지원하므로 &lt;code&gt;BasicFileAttributes.class&lt;/code&gt; &lt;code&gt;type&lt;/code&gt; 매개 변수 로이 메소드를 호출하면 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f1056213ec4dbb35ecbc5b5160831677aa11a47e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter is typically a class, but it may be any type, such as an interface, a primitive type (like &lt;code&gt;int.class&lt;/code&gt;), or &lt;code&gt;void.class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 파라미터는 일반적으로 클래스이지만, 이러한 인터페이스 (같은 원시 형 등 임의의 타입 일 수있다 &lt;code&gt;int.class&lt;/code&gt; 를 ) 또는 &lt;code&gt;void.class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0f557c7ffa69e938b51901e39f9567f456bb67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeName&lt;/code&gt; here is determined by the &lt;a href=&quot;#type-names&quot;&gt; type name rules&lt;/a&gt; detailed below.</source>
          <target state="translated">여기서 &lt;code&gt;typeName&lt;/code&gt; 은 아래에 자세히 설명 된 &lt;a href=&quot;#type-names&quot;&gt;유형 이름 규칙&lt;/a&gt; 에 따라 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b34f44d7ea255df3fe2a501bc7503f396e8bcc57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uncaughtException&lt;/code&gt; method of &lt;code&gt;ThreadGroup&lt;/code&gt; does the following:</source>
          <target state="translated">&lt;code&gt;ThreadGroup&lt;/code&gt; 의 &lt;code&gt;uncaughtException&lt;/code&gt; 메소드 는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="284484383fbc17bd10f3ef3060ba77933b35645d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;underlinedIndex&lt;/code&gt; parameter points to a char value (Unicode code unit) in the given string. If the char value specified at the underlined index is in the high-surrogate range and the char value at the following index is in the low-surrogate range then the supplementary character corresponding to this surrogate pair is underlined.</source>
          <target state="translated">The &lt;code&gt;underlinedIndex&lt;/code&gt; parameter points to a char value (Unicode code unit) in the given string. If the char value specified at the underlined index is in the high-surrogate range and the char value at the following index is in the low-surrogate range then the supplementary character corresponding to this surrogate pair is underlined.</target>
        </trans-unit>
        <trans-unit id="4450253c95c412d34ca14474c433b55151989bf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; calls this component's &lt;code&gt;paint&lt;/code&gt; method to redraw this component. This method is commonly overridden by subclasses which need to do additional work in response to a call to &lt;code&gt;repaint&lt;/code&gt;. Subclasses of Component that override this method should either call &lt;code&gt;super.update(g)&lt;/code&gt;, or call &lt;code&gt;paint(g)&lt;/code&gt; directly from their &lt;code&gt;update&lt;/code&gt; method.</source>
          <target state="translated">The &lt;code&gt;update&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; calls this component's &lt;code&gt;paint&lt;/code&gt; method to redraw this component. This method is commonly overridden by subclasses which need to do additional work in response to a call to &lt;code&gt;repaint&lt;/code&gt; . Subclasses of Component that override this method should either call &lt;code&gt;super.update(g)&lt;/code&gt; , or call &lt;code&gt;paint(g)&lt;/code&gt; directly from their &lt;code&gt;update&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="ba8b125bbe0fb10254e8b4e3a983a07e8dccd3bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uri&lt;/code&gt; parameter is an absolute, hierarchical URI, with a scheme equal (without regard to case) to the scheme supported by this provider. The exact form of the URI is highly provider dependent. The &lt;code&gt;env&lt;/code&gt; parameter is a map of provider specific properties to configure the file system.</source>
          <target state="translated">&lt;code&gt;uri&lt;/code&gt; 파라미터는이 제공자가 지원하는 방식으로 (경우에 관계없이)와 동일한 방식으로, 절대 계층 URI이다. URI의 정확한 형식은 공급자에 따라 크게 다릅니다. &lt;code&gt;env&lt;/code&gt; 매개 변수는 파일 시스템을 구성하는 제공자 특정 속성의 맵입니다.</target>
        </trans-unit>
        <trans-unit id="8d5265eccd53a8174604390135889708c5fc5e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useOrdering&lt;/code&gt; argument controls the ordering of the results using the same rules as &lt;code&gt;getServiceProviders(Class, boolean)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useOrdering&lt;/code&gt; 인수 컨트롤과 같은 규칙을 사용하여 결과의 순서 &lt;code&gt;getServiceProviders(Class, boolean)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf3c577a872e1c1751d1a92167097db6476c0ae8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a &lt;code&gt;key&lt;/code&gt; that is equal to the original &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 발신하여 검색 할 수있는 &lt;code&gt;get&lt;/code&gt; A의 방법 &lt;code&gt;key&lt;/code&gt; 일본어 같다 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6dc1003235f78ae44b563cd9c64b625dec84264" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt;, the Java environment, and the driver-supplied default values.</source>
          <target state="translated">The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt; , the Java environment, and the driver-supplied default values.</target>
        </trans-unit>
        <trans-unit id="6bb04aabca923c27392cb6a07985f491ac538c08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt;, the Java environment, and the driver-supplied default values. This field may be null if no value is known.</source>
          <target state="translated">The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt; , the Java environment, and the driver-supplied default values. This field may be null if no value is known.</target>
        </trans-unit>
        <trans-unit id="a0dc0ca5643c577e2bc28f2c4d9f85f55ae2ae0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;view&lt;/code&gt; attribute identifies the &lt;code&gt;AbstractView&lt;/code&gt; from which the event was generated.</source>
          <target state="translated">The &lt;code&gt;view&lt;/code&gt; attribute identifies the &lt;code&gt;AbstractView&lt;/code&gt; from which the event was generated.</target>
        </trans-unit>
        <trans-unit id="35e9083dd12ca67db6c302fb48e049498f0e86ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e270b26fb5f4d86ce8e6fe4ab24f798852bc112c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb6cc5d83f6f060e6206ee4432cd2838d953df43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;unwrap()&lt;/code&gt; methods may execute concurrently of each other.</source>
          <target state="translated">&lt;code&gt;wrap()&lt;/code&gt; 및 &lt;code&gt;unwrap()&lt;/code&gt; 메소드는 서로 동시에 실행할 수있다.</target>
        </trans-unit>
        <trans-unit id="b6ac35afc51c676f6acfb59fbb66aebb7fd7dffe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;CipherOutputStream&lt;/code&gt; calls the &lt;code&gt;write&lt;/code&gt; method of three arguments with the three arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 의 방법 &lt;code&gt;CipherOutputStream&lt;/code&gt; 를이 부르는 &lt;code&gt;write&lt;/code&gt; 세 개의 인수와 세 개의 인수의 방법 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;b.length&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="b444208efa76dded6db1c12df1b7df685049876c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls its &lt;code&gt;write&lt;/code&gt; method of three arguments with the arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 의 방법을 &lt;code&gt;FilterOutputStream&lt;/code&gt; 자사의 호출을 &lt;code&gt;write&lt;/code&gt; 인수와 세 개의 인수의 방법 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;b.length&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="4d273be569b8b30933a05fc498292c5402a93de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls the &lt;code&gt;write&lt;/code&gt; method of its underlying output stream, that is, it performs &lt;code&gt;out.write(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 방법 &lt;code&gt;FilterOutputStream&lt;/code&gt; 부르는 &lt;code&gt;write&lt;/code&gt; 자사 기본 출력 스트림의 방법, 그것을 행하는 &lt;code&gt;out.write(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b52d117ddcb1aaf2483d386c55d430f15571498" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls the &lt;code&gt;write&lt;/code&gt; method of one argument on each &lt;code&gt;byte&lt;/code&gt; to output.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 방법 &lt;code&gt;FilterOutputStream&lt;/code&gt; 부르는 &lt;code&gt;write&lt;/code&gt; 각각에 하나 개의 인자에있어서의 &lt;code&gt;byte&lt;/code&gt; 를 출력한다.</target>
        </trans-unit>
        <trans-unit id="f6b5bd7ff632f357b485afe4736af5f2318b4eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt; calls the write method of one argument on each of the bytes to be written out. Subclasses are encouraged to override this method and provide a more efficient implementation.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 방법 &lt;code&gt;OutputStream&lt;/code&gt; 바이트마다 인수의 쓰기 방법을 기입합니다 호출합니다. 서브 클래스는이 메소드를 대체하고보다 효율적인 구현을 제공하도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="4052734952517729cae634a4334fbfe7bc56b79a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; methods of the resulting stream will throw an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">기본 채널이 비 차단 모드에있는 동안 호출되면 결과 스트림 의 &lt;code&gt;write&lt;/code&gt; 메소드에서 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 스트림은 버퍼링되지 않습니다. 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7aeccac65dd62b076d4abb5d4c775615877d46ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by a &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation. Although this method is not final, it should not need to be subclassed under normal circumstances.</source>
          <target state="translated">&lt;code&gt;writeObject&lt;/code&gt; 지속성에 대한 단일 진입 점이며 의해 사용되는 &lt;code&gt;Encoder&lt;/code&gt; 대표의 전통적인 모드. 이 방법은 최종 방법은 아니지만 일반적인 상황에서 하위 클래스로 분류 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0937ca02336197261dddb7803acba46aa6ec7743" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation.</source>
          <target state="translated">The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation.</target>
        </trans-unit>
        <trans-unit id="9c855374ef3af39f227ccdf574cfb54afb0d247f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation. Although this method is not final, it should not need to be subclassed under normal circumstances.</source>
          <target state="translated">The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation. Although this method is not final, it should not need to be subclassed under normal circumstances.</target>
        </trans-unit>
        <trans-unit id="65972030b222838810b7ba8b656c7648e06077d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeUTF&lt;/code&gt; method of interface &lt;code&gt;DataOutput&lt;/code&gt; may be used to write data that is suitable for reading by this method.</source>
          <target state="translated">&lt;code&gt;DataOutput&lt;/code&gt; 인터페이스 의 &lt;code&gt;writeUTF&lt;/code&gt; 메소드를 사용하여이 메소드로 읽기에 적합한 데이터를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecdfdf55c3e6233c34db1e9797ae4ac06e60e0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{ }&lt;/code&gt; characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The &lt;code&gt;&quot;,&quot;&lt;/code&gt; character is used to separate the subpatterns. Groups cannot be nested.</source>
          <target state="translated">&lt;code&gt;{ }&lt;/code&gt; 문자는 그룹이있는 경우 일치 서브 패턴의 그룹이다 그룹 경기에서 어떤 서브 패턴. 은 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 문자는 서브 패턴을 분리하는 데 사용됩니다. 그룹은 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4383cedf66c99d541142d23205794e9fbe074f11" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;action&lt;/em&gt;. For a permission you need, this is one of the actions in the list &lt;a href=&quot;#action-list&quot;&gt;below&lt;/a&gt;. For a permission you have, this is a comma-separated list of those actions, or &lt;code&gt;*&lt;/code&gt;, representing all actions.</source>
          <target state="translated">&lt;em&gt;행동&lt;/em&gt; . 필요한 권한의 경우 &lt;a href=&quot;#action-list&quot;&gt;아래&lt;/a&gt; 목록의 작업 중 하나입니다 . 권한이있는 경우이 목록은 쉼표로 구분 된 해당 작업 목록 또는 &lt;code&gt;*&lt;/code&gt; 이며 모든 작업을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a6904e89112c0b2f4cf76a3eaf77590286f5121f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string as described for &lt;a href=&quot;#getCanonicalKeyPropertyListString()&quot;&gt;&lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string as described for &lt;a href=&quot;#getCanonicalKeyPropertyListString()&quot;&gt; &lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4203e1844ba2358b9cf99e65861fc5814fcbd135" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string as described for &lt;a href=&quot;objectname#getCanonicalKeyPropertyListString--&quot;&gt;&lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;표준 키의 프로퍼티리스트&lt;/em&gt; 에 기술 된 것과 동일한 문자열 &lt;a href=&quot;objectname#getCanonicalKeyPropertyListString--&quot;&gt; &lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0da932c873e0a87699cfc16c3ea52c0b2e0de4c0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;class name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;클래스 이름&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b34ed1bdfeb4a02859cb87fc0dd3c70da93cc4ac" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;domain&lt;/em&gt; is a string of characters not including the character colon (&lt;code&gt;:&lt;/code&gt;). It is recommended that the domain should not contain the string &quot;&lt;code&gt;//&lt;/code&gt;&quot;, which is reserved for future use.</source>
          <target state="translated">&lt;em&gt;도메인은&lt;/em&gt; 문자 콜론을 포함하지 않는 문자열입니다 ( &lt;code&gt;:&lt;/code&gt; ). 도메인에는 &quot; &lt;code&gt;//&lt;/code&gt; &quot; 문자열이 포함되어서는 안되며 , 나중에 사용하기 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4031de43ef1c59b0c68ad4834eee900eefebe3c6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;head&lt;/em&gt; of this queue is the &lt;em&gt;least&lt;/em&gt; element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily. The queue retrieval operations &lt;code&gt;poll&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;peek&lt;/code&gt;, and &lt;code&gt;element&lt;/code&gt; access the element at the head of the queue.</source>
          <target state="translated">이 큐 의 &lt;em&gt;헤드&lt;/em&gt; 는 지정된 순서와 관련 하여 &lt;em&gt;가장 작은&lt;/em&gt; 요소입니다. 여러 요소가 최소한의 가치로 묶여 있으면 머리는 그러한 요소 중 하나입니다. 넥타이는 임의로 끊어집니다. 큐 검색 조작 은 큐 헤드에서 &lt;code&gt;element&lt;/code&gt; &lt;code&gt;poll&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;peek&lt;/code&gt; 및 요소 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="132748ef7ce7edd118fa2aec50bbb6b7013d4a04" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;key properties&lt;/em&gt; are an unordered set of keys and associated values.</source>
          <target state="translated">&lt;em&gt;키 등록은&lt;/em&gt; 키와 관련된 값들의 순서화 된 집합이다.</target>
        </trans-unit>
        <trans-unit id="49b6c7b812bfb37bbfa829d277662d381281a9fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapped&lt;/em&gt; Java type, &lt;em&gt;opendata(J)&lt;/em&gt;, which is always the same for any given &lt;em&gt;opentype(J)&lt;/em&gt;. This is a Java class.</source>
          <target state="translated">&lt;em&gt;매핑 된&lt;/em&gt; Java 형, &lt;em&gt;opendata (J)&lt;/em&gt; 항상 주어진에 대해 동일, &lt;em&gt;오픈 타입 (J)&lt;/em&gt; . 이것은 Java 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bbb454761775dc1a414464798499aeee43da2b26" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;member&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;멤버&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="074cbd71c6bb024356bb7396d0de2ecfe45082b5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; of the permission can also denote a list of one or more comma-separated operations. Spaces are allowed at the beginning and end of the &lt;em&gt;name&lt;/em&gt; and before and after commas.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 권한의는 하나 이상의 쉼표로 구분 된 작업 목록을 표시 할 수 있습니다. &lt;em&gt;이름&lt;/em&gt; 의 시작과 끝 과 쉼표 앞뒤에 공백이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9480872eca819a401a143d99801ef4a81e78cc7a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;object name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;개체 이름&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b8bea707941f307636110813bd9843488dbd1cb0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;opens&lt;/em&gt; directive in a module declaration declares a package to be open to allow all types in the package, and all their members, not just public types and their public members to be reflected on by APIs that support private access or a way to bypass or suppress default Java language access control checks.</source>
          <target state="translated">The &lt;em&gt;opens&lt;/em&gt; directive in a module declaration declares a package to be open to allow all types in the package, and all their members, not just public types and their public members to be reflected on by APIs that support private access or a way to bypass or suppress default Java language access control checks.</target>
        </trans-unit>
        <trans-unit id="5ea4f18aba4c5af225e35673d4891fc5fa9e0a6b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item.</source>
          <target state="translated">The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item.</target>
        </trans-unit>
        <trans-unit id="7bf772b2c89d559914753f218273f17b3f5fef8c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item. The origin of an element or item models how a construct in a program is declared in the source code, explicitly, implicitly, etc.</source>
          <target state="translated">The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item. The origin of an element or item models how a construct in a program is declared in the source code, explicitly, implicitly, etc.</target>
        </trans-unit>
        <trans-unit id="f0e83e021e240eac4fd2981ea6d32868e52f81d8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the pathname's prefix, if any, and each name in the pathname's name sequence except for the last. If the name sequence is empty then the pathname does not name a parent directory.</source>
          <target state="translated">추상 경로명 의 &lt;em&gt;부모&lt;/em&gt; 는 경로명의 접두사 (있는 경우)와 마지막을 제외한 경로명의 이름 순서에있는 각 이름으로 구성됩니다. 이름 순서가 비어 있으면 경로 이름이 상위 디렉토리의 이름을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89fec665c0c46c36e97a962d8fe4d0387ff30f83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking the &lt;a href=&quot;#getParent()&quot;&gt;&lt;code&gt;getParent()&lt;/code&gt;&lt;/a&gt; method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any &lt;code&gt;File&lt;/code&gt; object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; is an ancestor of the directory denoted by the pathname &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt;.</source>
          <target state="translated">The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking the &lt;a href=&quot;#getParent()&quot;&gt; &lt;code&gt;getParent()&lt;/code&gt; &lt;/a&gt; method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any &lt;code&gt;File&lt;/code&gt; object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; is an ancestor of the directory denoted by the pathname &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0528ba347878b821ba42755b3a17661463c339f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking the &lt;a href=&quot;file#getParent--&quot;&gt;&lt;code&gt;getParent()&lt;/code&gt;&lt;/a&gt; method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any &lt;code&gt;File&lt;/code&gt; object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; is an ancestor of the directory denoted by the pathname &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;부모&lt;/em&gt; 추상 패스의이 호출함으로써 얻어 질 수있다 &lt;a href=&quot;file#getParent--&quot;&gt; &lt;code&gt;getParent()&lt;/code&gt; &lt;/a&gt; 이 클래스의 방법과 경로의 접두사와 마지막을 제외한 경로 이름 순서에서 각각 이름 구성된다. 각 디렉토리의 절대 경로 이름은 디렉토리의 절대 경로 이름으로 시작하는 절대 추상 경로 이름을 가진 &lt;code&gt;File&lt;/code&gt; 객체 의 조상입니다 . 예를 들어, 추상 경로 이름 &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; 으로 표시된 디렉토리는 경로 이름 &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt; 으로 표시된 디렉토리의 조상입니다 .</target>
        </trans-unit>
        <trans-unit id="3219f3facb21696d1ed20d4e54a6c99ee13262e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;pattern indication&lt;/em&gt; is:</source>
          <target state="translated">&lt;em&gt;패턴 표시&lt;/em&gt; 이다 :</target>
        </trans-unit>
        <trans-unit id="75b0986f1f4d3f972e20d5706e48596a413d0f0a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;specified&lt;/em&gt; flag for each attribute will always be true, unless it has been set to false in the copy constructor or using &lt;a href=&quot;#setSpecified(int,boolean)&quot;&gt;&lt;code&gt;setSpecified(int, boolean)&lt;/code&gt;&lt;/a&gt;. Similarly, the &lt;em&gt;declared&lt;/em&gt; flag for each attribute will always be false, except for defaulted attributes (&lt;em&gt;specified&lt;/em&gt; is false), non-CDATA attributes, or when it is set to true using &lt;a href=&quot;#setDeclared(int,boolean)&quot;&gt;&lt;code&gt;setDeclared(int, boolean)&lt;/code&gt;&lt;/a&gt;. If you change an attribute's type by hand, you may need to modify its &lt;em&gt;declared&lt;/em&gt; flag to match.</source>
          <target state="translated">The &lt;em&gt;specified&lt;/em&gt; flag for each attribute will always be true, unless it has been set to false in the copy constructor or using &lt;a href=&quot;#setSpecified(int,boolean)&quot;&gt; &lt;code&gt;setSpecified(int, boolean)&lt;/code&gt; &lt;/a&gt;. Similarly, the &lt;em&gt;declared&lt;/em&gt; flag for each attribute will always be false, except for defaulted attributes (&lt;em&gt;specified&lt;/em&gt; is false), non-CDATA attributes, or when it is set to true using &lt;a href=&quot;#setDeclared(int,boolean)&quot;&gt; &lt;code&gt;setDeclared(int, boolean)&lt;/code&gt; &lt;/a&gt;. If you change an attribute's type by hand, you may need to modify its &lt;em&gt;declared&lt;/em&gt; flag to match.</target>
        </trans-unit>
        <trans-unit id="e24706d6569ad24b7b450fbbe13dd7ea6ed5e827" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast datagrams</source>
          <target state="translated">&lt;em&gt;타임 - 투 - 라이브&lt;/em&gt; 인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램에 대한</target>
        </trans-unit>
        <trans-unit id="2a0f0d9a04c7aa959de016e80e8a27f487dc3d88" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast datagrams.</source>
          <target state="translated">&lt;em&gt;타임 - 투 - 라이브&lt;/em&gt; 인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램합니다.</target>
        </trans-unit>
        <trans-unit id="a5cbd78bbaec3014307f658d756d06fe19f45c6b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;outer&lt;/var&gt; parameter is a pointer to the MBeanServer that should be passed to the &lt;a href=&quot;mbeanregistration&quot;&gt;&lt;code&gt;MBeanRegistration&lt;/code&gt;&lt;/a&gt; interface when registering MBeans inside the MBeanServer. If &lt;var&gt;outer&lt;/var&gt; is &lt;code&gt;null&lt;/code&gt;, then the MBeanServer implementation must use its own &lt;code&gt;this&lt;/code&gt; reference when invoking the &lt;a href=&quot;mbeanregistration&quot;&gt;&lt;code&gt;MBeanRegistration&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;var&gt;outer&lt;/var&gt; 파라미터는에게 건네지는 MBeanServer의 포인터 &lt;a href=&quot;mbeanregistration&quot;&gt; &lt;code&gt;MBeanRegistration&lt;/code&gt; &lt;/a&gt; MBeanServer에 MBean를 등록 할 때에 인터페이스. &lt;var&gt;outer&lt;/var&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 , MBeanServer 구현은 독자적인 것을 사용해야합니다 &lt;code&gt;this&lt;/code&gt; &lt;a href=&quot;mbeanregistration&quot;&gt; &lt;code&gt;MBeanRegistration&lt;/code&gt; &lt;/a&gt; 인터페이스를 호출 할 때 으로이 참조를 .</target>
        </trans-unit>
        <trans-unit id="f59eba20773f5628795f2594c47e23e68f64a277" translate="yes" xml:space="preserve">
          <source>The ACL Entries in each ACL observe the following rules:</source>
          <target state="translated">각 ACL의 ACL 항목은 다음 규칙을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="8bff27e96b6704d8f87499203e5a6ae8eb995398" translate="yes" xml:space="preserve">
          <source>The ACL entry represented by this class is based on the ACL model specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3530.txt&quot;&gt;&lt;i&gt;RFC 3530: Network File System (NFS) version 4 Protocol&lt;/i&gt;&lt;/a&gt;. Each entry has four components as follows:</source>
          <target state="translated">이 클래스가 나타내는 ACL 항목은에 지정된 ACL 모델을 기반으로합니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3530.txt&quot;&gt;&lt;i&gt; RFC 3530 : NFS (Network File System) 버전 4 프로토콜에&lt;/i&gt;&lt;/a&gt;. 각 항목에는 다음과 같은 네 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7935a2f1ee484e91861f127adcc137f1458cac88" translate="yes" xml:space="preserve">
          <source>The API allows a concrete &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; object to be created from the static function &lt;a href=&quot;transformerfactory#newInstance()&quot;&gt;&lt;code&gt;TransformerFactory.newInstance()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The API allows a concrete &lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt; object to be created from the static function &lt;a href=&quot;transformerfactory#newInstance()&quot;&gt; &lt;code&gt;TransformerFactory.newInstance()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="36548e1972814e3b9960a257ac0e7fefe094719d" translate="yes" xml:space="preserve">
          <source>The API has a relatively large surface area in terms of number of methods. This is made manageable through the use of consistent method prefixes.</source>
          <target state="translated">API는 메소드 수 측면에서 비교적 넓은 표면적을 가지고 있습니다. 일관된 메소드 접두사를 사용하여 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="dbd68d7bbcc6cfd76b2979294dc860ef940a8a77" translate="yes" xml:space="preserve">
          <source>The API has been designed to reject null early and to be clear about this behavior. A key exception is any method that takes an object and returns a boolean, for the purpose of checking or validating, will generally return false for null.</source>
          <target state="translated">API는 null을 일찍 거부하고이 동작에 대해 명확하게 설계되었습니다. 중요한 예외는 객체를 가져 와서 부울을 리턴하는 메소드이며, 점검 또는 유효성 검증을 위해 일반적으로 널 (null)에 대해 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d2d1219bb89c1b00654a21e6d21d64a9c99c7dd" translate="yes" xml:space="preserve">
          <source>The API includes remote access, so a remote management program can interact with a running application for these purposes.</source>
          <target state="translated">API에는 원격 액세스가 포함되어 있으므로 원격 관리 프로그램은 이러한 목적으로 실행중인 응용 프로그램과 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddb46698ab6320ca268f051f9fdff93cea456dc" translate="yes" xml:space="preserve">
          <source>The API is also designed for user extensibility, as there are many ways of calculating time. The &lt;a href=&quot;temporal/temporalfield&quot;&gt;field&lt;/a&gt; and &lt;a href=&quot;temporal/temporalunit&quot;&gt;unit&lt;/a&gt; API, accessed via &lt;a href=&quot;temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/temporal&quot;&gt;&lt;code&gt;Temporal&lt;/code&gt;&lt;/a&gt; provide considerable flexibility to applications. In addition, the &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/temporaladjuster&quot;&gt;&lt;code&gt;TemporalAdjuster&lt;/code&gt;&lt;/a&gt; interfaces provide day-to-day power, allowing code to read close to business requirements:</source>
          <target state="translated">API는 시간을 계산하는 많은 방법이 있기 때문에 사용자 확장 성을 위해 설계되었습니다. &lt;a href=&quot;temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/temporal&quot;&gt; &lt;code&gt;Temporal&lt;/code&gt; 을&lt;/a&gt; 통해 액세스 되는 &lt;a href=&quot;temporal/temporalfield&quot;&gt;필드&lt;/a&gt; 및 &lt;a href=&quot;temporal/temporalunit&quot;&gt;단위&lt;/a&gt; API 는 애플리케이션에 상당한 유연성을 제공합니다. 또한 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/temporaladjuster&quot;&gt; &lt;code&gt;TemporalAdjuster&lt;/code&gt; &lt;/a&gt; 인터페이스는 일상적인 성능을 제공하여 코드가 비즈니스 요구 사항에 근접하여 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="9d4850815012acd78d63e490cb3a9ac9619de1e0" translate="yes" xml:space="preserve">
          <source>The API is defined by classes in the package &lt;code&gt;javax.smartcardio&lt;/code&gt;. They can be classified as follows:</source>
          <target state="translated">The API is defined by classes in the package &lt;code&gt;javax.smartcardio&lt;/code&gt; . They can be classified as follows:</target>
        </trans-unit>
        <trans-unit id="14204c857d829d56ea62ee7c57aa99da1a8c1fa8" translate="yes" xml:space="preserve">
          <source>The API is designed to be type-safe where reasonable in the main high-level API. Thus, there are separate classes for the distinct concepts of date, time and date-time, plus variants for offset and time-zone. This can seem like a lot of classes, but most applications can begin with just five date/time types.</source>
          <target state="translated">API는 주요 고급 API에서 합리적인 경우 형식이 안전하도록 설계되었습니다. 따라서 날짜, 시간 및 날짜-시간의 고유 한 개념에 대한 별도의 클래스와 오프셋 및 시간대에 대한 변형이 있습니다. 이것은 많은 수업처럼 보일 수 있지만 대부분의 응용 프로그램은 5 개의 날짜 / 시간 유형으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef3ef0b96f3f41f9bc604e1a12e6451e41174cc" translate="yes" xml:space="preserve">
          <source>The API provides a way for URIs referenced from within the stylesheet instructions or within the transformation to be resolved by the calling application. This can be done by creating a class that implements the &lt;a href=&quot;uriresolver&quot;&gt;&lt;code&gt;URIResolver&lt;/code&gt;&lt;/a&gt; interface, with its one method, &lt;a href=&quot;uriresolver#resolve(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;URIResolver.resolve(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, and use this class to set the URI resolution for the transformation instructions or transformation with &lt;a href=&quot;transformerfactory#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt;&lt;code&gt;TransformerFactory.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;transformer#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt;&lt;code&gt;Transformer.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;URIResolver.resolve&lt;/code&gt; method takes two String arguments, the URI found in the stylesheet instructions or built as part of the transformation process, and the base URI against which the first argument will be made absolute if the absolute URI is required. The returned &lt;a href=&quot;source&quot;&gt;&lt;code&gt;Source&lt;/code&gt;&lt;/a&gt; object must be usable by the transformer, as specified in its implemented features.</source>
          <target state="translated">The API provides a way for URIs referenced from within the stylesheet instructions or within the transformation to be resolved by the calling application. This can be done by creating a class that implements the &lt;a href=&quot;uriresolver&quot;&gt; &lt;code&gt;URIResolver&lt;/code&gt; &lt;/a&gt; interface, with its one method, &lt;a href=&quot;uriresolver#resolve(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;URIResolver.resolve(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;, and use this class to set the URI resolution for the transformation instructions or transformation with &lt;a href=&quot;transformerfactory#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt; &lt;code&gt;TransformerFactory.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;transformer#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt; &lt;code&gt;Transformer.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt; &lt;/a&gt;. The &lt;code&gt;URIResolver.resolve&lt;/code&gt; method takes two String arguments, the URI found in the stylesheet instructions or built as part of the transformation process, and the base URI against which the first argument will be made absolute if the absolute URI is required. The returned &lt;a href=&quot;source&quot;&gt; &lt;code&gt;Source&lt;/code&gt; &lt;/a&gt; object must be usable by the transformer, as specified in its implemented features.</target>
        </trans-unit>
        <trans-unit id="1d7455826253bffa39b78615725dcdd563f19a04" translate="yes" xml:space="preserve">
          <source>The API requires every print service to support certain attributes; other attributes are optional and the service can choose whether or not to support them. Each attribute has a set of values that it accepts. The API requires every print service to support certain values for certain attributes; other attribute values are optional and the service can choose whether or not to support them. These support requirements are recorded in the documentation for each attribute class.</source>
          <target state="translated">API는 모든 인쇄 서비스가 특정 속성을 지원하도록 요구합니다. 다른 속성은 선택 사항이며 서비스는 해당 속성을 지원할지 여부를 선택할 수 있습니다. 각 속성에는 허용되는 값 세트가 있습니다. API는 모든 인쇄 서비스가 특정 속성에 대한 특정 값을 지원하도록 요구합니다. 다른 속성 값은 선택 사항이며 서비스는이를 지원할지 여부를 선택할 수 있습니다. 이러한 지원 요구 사항은 각 속성 클래스에 대한 설명서에 기록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="98bf436512bc6abd974a2733430a3d5b5a388d6c" translate="yes" xml:space="preserve">
          <source>The APIs added in 1.7 map between the old and new language codes, maintaining the old codes internal to Locale (so that &lt;code&gt;getLanguage&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; reflect the old code), but using the new codes in the BCP 47 language tag APIs (so that &lt;code&gt;toLanguageTag&lt;/code&gt; reflects the new one). This preserves the equivalence between Locales no matter which code or API is used to construct them. Java's default resource bundle lookup mechanism also implements this mapping, so that resources can be named using either convention, see &lt;a href=&quot;resourcebundle.control&quot;&gt;&lt;code&gt;ResourceBundle.Control&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1.7에 추가 된 API는 이전 언어 코드와 새 언어 코드를 매핑하여 로케일 내부의 기존 코드를 유지하지만 ( &lt;code&gt;getLanguage&lt;/code&gt; 및 &lt;code&gt;toString&lt;/code&gt; 은 이전 코드를 반영 함) BCP 47 언어 태그 API에서 새 코드를 사용합니다 ( &lt;code&gt;toLanguageTag&lt;/code&gt; 는 새로운 것). 이렇게하면 로케일간에 코드 또는 API를 사용하여 로케일 간의 동등성을 유지합니다. Java의 기본 자원 번들 조회 메커니즘은이 맵핑을 구현하므로 두 규칙 중 하나를 사용하여 자원의 이름을 지정할 수 있습니다 ( &lt;a href=&quot;resourcebundle.control&quot;&gt; &lt;code&gt;ResourceBundle.Control&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6023c5172deb2e42606e029f4d360e805d38b457" translate="yes" xml:space="preserve">
          <source>The APIs in this package are all deprecated without replacement.</source>
          <target state="translated">The APIs in this package are all deprecated without replacement.</target>
        </trans-unit>
        <trans-unit id="1e8aa36e1e31661c0e8ce5465a873be7b0631796" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition for this is:</source>
          <target state="translated">이에 대한 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="943be2a0bc4bf87f26928040bf4bf42222a1a4d3" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition is as follows:</source>
          <target state="translated">ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33b3e4f975d64c40485d484aff9c8c6946bbcac2" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;GeneralNames&lt;/code&gt; is defined in &lt;a href=&quot;#getSubjectAlternativeNames()&quot;&gt;&lt;code&gt;getSubjectAlternativeNames&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The ASN.1 definition of &lt;code&gt;GeneralNames&lt;/code&gt; is defined in &lt;a href=&quot;#getSubjectAlternativeNames()&quot;&gt; &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="47734034dda78f218c309ac08628f954c60425f3" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;GeneralNames&lt;/code&gt; is defined in &lt;a href=&quot;x509certificate#getSubjectAlternativeNames--&quot;&gt;&lt;code&gt;getSubjectAlternativeNames&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GeneralNames&lt;/code&gt; 의 ASN.1 정의는 &lt;a href=&quot;x509certificate#getSubjectAlternativeNames--&quot;&gt; &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d4394df37dee40fdf32c164d9e7675520b84225" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;tbsCertList&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;tbsCertList&lt;/code&gt; 의 ASN.1 정의는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3b0786ad17cd85c2406e5dec048d22519850b47" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;tbsCertificate&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;tbsCertificate&lt;/code&gt; 의 ASN.1 정의는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef48af476f938c6dbaa3d39664736786a596b706" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of the &lt;code&gt;IssuerAltName&lt;/code&gt; extension is:</source>
          <target state="translated">&lt;code&gt;IssuerAltName&lt;/code&gt; 확장 의 ASN.1 정의 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3bfe2daf1a8d1055520bbddc7ce3310410386b4" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of the &lt;code&gt;SubjectAltName&lt;/code&gt; extension is:</source>
          <target state="translated">&lt;code&gt;SubjectAltName&lt;/code&gt; 확장 의 ASN.1 정의 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef7fb5e463d8e7a85b7d17a9a4424f5c59dec8a2" translate="yes" xml:space="preserve">
          <source>The AWT Focus Subsystem</source>
          <target state="translated">The AWT Focus Subsystem</target>
        </trans-unit>
        <trans-unit id="c23a37e89e94656b7c67efc2143f08a7162a7dc6" translate="yes" xml:space="preserve">
          <source>The AWT Modality</source>
          <target state="translated">The AWT Modality</target>
        </trans-unit>
        <trans-unit id="b973428a4010a2e2c6902dfcdc73ebef4dc85d16" translate="yes" xml:space="preserve">
          <source>The AWT listener model lets applications attach event listeners to components in order to bind events to actions. Swing encourages the use of keymaps instead of listeners, but maintains compatibility with listeners by giving the listeners a chance to steal an event by consuming it.</source>
          <target state="translated">The AWT listener model lets applications attach event listeners to components in order to bind events to actions. Swing encourages the use of keymaps instead of listeners, but maintains compatibility with listeners by giving the listeners a chance to steal an event by consuming it.</target>
        </trans-unit>
        <trans-unit id="0669e573aa756da1edc3404f2ca12e839dcd44e2" translate="yes" xml:space="preserve">
          <source>The AccessControlContext of the thread that created the instance of URLClassLoader will be used when subsequently loading classes and resources.</source>
          <target state="translated">URLClassLoader의 인스턴스를 만든 스레드의 AccessControlContext는 이후에 클래스와 리소스를로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b36f05d0d881d326a4ca7052f41c11e7cb29b4d8" translate="yes" xml:space="preserve">
          <source>The AccessController class is used for access control operations and decisions.</source>
          <target state="translated">AccessController 클래스는 액세스 제어 조작 및 결정에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e44ca12442a1e7b0c2ea9c89fdb764999e8954ae" translate="yes" xml:space="preserve">
          <source>The AccessibleObject class is the base class for Field, Method and Constructor objects.</source>
          <target state="translated">AccessibleObject 클래스는 Field, Method 및 Constructor 객체의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6a4566430ddc25f7244284392e568dac22b82186" translate="yes" xml:space="preserve">
          <source>The AccessibleObject class is the base class for Field, Method and Constructor objects. It provides the ability to flag a reflected object as suppressing default Java language access control checks when it is used. The access checks--for public, default (package) access, protected, and private members--are performed when Fields, Methods or Constructors are used to set or get fields, to invoke methods, or to create and initialize new instances of classes, respectively.</source>
          <target state="translated">AccessibleObject 클래스는 Field, Method 및 Constructor 객체의 기본 클래스입니다. 사용시 기본 Java 언어 액세스 제어 검사를 억제하여 반사 된 오브젝트에 플래그를 지정할 수 있습니다. 공개, 기본 (패키지) 액세스, 보호 및 개인 멤버에 대한 액세스 검사는 필드, 메소드 또는 생성자가 필드를 설정 또는 가져 오거나 메소드를 호출하거나 클래스의 새 인스턴스를 작성 및 초기화하는 데 사용되는 경우 수행됩니다. 각각.</target>
        </trans-unit>
        <trans-unit id="a68ea02747038a8e45417b19cd5c6838a7022a98" translate="yes" xml:space="preserve">
          <source>The AffineTransform parameter passed into and out of this class are cloned. The RenderingHints and Shape parameters are not necessarily cloneable and are therefore only reference copied. Altering RenderingHints or Shape instances that are in use by instances of RenderContext may have undesired side effects.</source>
          <target state="translated">The AffineTransform parameter passed into and out of this class are cloned. The RenderingHints and Shape parameters are not necessarily cloneable and are therefore only reference copied. Altering RenderingHints or Shape instances that are in use by instances of RenderContext may have undesired side effects.</target>
        </trans-unit>
        <trans-unit id="6784e3abc090fab94e5244fcbe90ade6d9424123" translate="yes" xml:space="preserve">
          <source>The AllPermission is a permission that implies all other permissions.</source>
          <target state="translated">AllPermission은 다른 모든 권한을 암시하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="160ae22b65044b8568a8445e371a31bf8aaf3856" translate="yes" xml:space="preserve">
          <source>The Alt key extended modifier constant.</source>
          <target state="translated">The Alt key extended modifier constant.</target>
        </trans-unit>
        <trans-unit id="c32b87d13e51010df9b131a2a159c6f08c4061cc" translate="yes" xml:space="preserve">
          <source>The Alt key modifier constant.</source>
          <target state="translated">The Alt key modifier constant.</target>
        </trans-unit>
        <trans-unit id="67ebaec467a6e9959ba36c0e74821764b3f28d0e" translate="yes" xml:space="preserve">
          <source>The AltGraph key extended modifier constant.</source>
          <target state="translated">The AltGraph key extended modifier constant.</target>
        </trans-unit>
        <trans-unit id="af96a3451e70135ea5a5f5dfb4bc7b7416b43b8e" translate="yes" xml:space="preserve">
          <source>The AltGraph key modifier constant.</source>
          <target state="translated">The AltGraph key modifier constant.</target>
        </trans-unit>
        <trans-unit id="6868186048f362d856c90c60963c84a42086381e" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated, no replacement.</source>
          <target state="translated">The Applet API is deprecated, no replacement.</target>
        </trans-unit>
        <trans-unit id="952898db7755e8938613fa579a9e9fc86b6e5a52" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated.</source>
          <target state="translated">The Applet API is deprecated.</target>
        </trans-unit>
        <trans-unit id="8dd33816bcdb119edd3850a36cdb8640a02f66c5" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated. See the &lt;a href=&quot;../../java/applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</source>
          <target state="translated">The Applet API is deprecated. See the &lt;a href=&quot;../../java/applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</target>
        </trans-unit>
        <trans-unit id="3fde7dcfee0eaa7810b2d3e4119c1b3003baeb65" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated. See the &lt;a href=&quot;../applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</source>
          <target state="translated">The Applet API is deprecated. See the &lt;a href=&quot;../applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</target>
        </trans-unit>
        <trans-unit id="074b0f1a024ad247a895c2f41c9dab31804bb1f1" translate="yes" xml:space="preserve">
          <source>The Arabic range with the Arabic-Indic digits.</source>
          <target state="translated">The Arabic range with the Arabic-Indic digits.</target>
        </trans-unit>
        <trans-unit id="5f0a7cc180f7ec121449f8ad22a0f254f01aed33" translate="yes" xml:space="preserve">
          <source>The Arabic range with the Eastern Arabic-Indic digits.</source>
          <target state="translated">The Arabic range with the Eastern Arabic-Indic digits.</target>
        </trans-unit>
        <trans-unit id="9b559b3d068940514b3b2c10adaad5cfb38dfc1e" translate="yes" xml:space="preserve">
          <source>The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself.</source>
          <target state="translated">The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself.</target>
        </trans-unit>
        <trans-unit id="9477ca8f0c7cd6500bd0479d8977d02cdcbaf631" translate="yes" xml:space="preserve">
          <source>The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself. Since the returned object represents the bounding box with integers, the bounding box can only be as tight as the nearest integer coordinates that encompass the geometry of the Shape.</source>
          <target state="translated">The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself. Since the returned object represents the bounding box with integers, the bounding box can only be as tight as the nearest integer coordinates that encompass the geometry of the Shape.</target>
        </trans-unit>
        <trans-unit id="e40e5d487b331e1f7f4c2477322a84662ea1dcde" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming</source>
          <target state="translated">컴퓨터 프로그래밍의 기술</target>
        </trans-unit>
        <trans-unit id="3e916cc17dff2d73e810c4085e8846b18e562a3e" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming,</source>
          <target state="translated">컴퓨터 프로그래밍 기술,</target>
        </trans-unit>
        <trans-unit id="d69bacd54b669ff7d878e60414c2d1f8611ca3a2" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming, Volume 2</source>
          <target state="translated">컴퓨터 프로그래밍 기술, 2 권</target>
        </trans-unit>
        <trans-unit id="545bef1b9e1299301bb2907b1e213bfe088b7b67" translate="yes" xml:space="preserve">
          <source>The Attribute with attrID that was previous in this attribute set; null if no such attribute existed.</source>
          <target state="translated">이 속성 세트에서 이전에 attrID를 가진 속성. 그러한 속성이 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="86989bf0d4a1d404f5eef67b394b9e8347a4cb82" translate="yes" xml:space="preserve">
          <source>The Attribute with the same ID as attr that was previous in this attribute set; null if no such attribute existed.</source>
          <target state="translated">이 속성 세트에서 이전에 attr과 동일한 ID를 가진 속성. 그러한 속성이 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="188be4b00e3695b200467797aef29ec1a27bdb7b" translate="yes" xml:space="preserve">
          <source>The Attribute with the same ID as attrID that was previous in the attribute set; null if no such attribute existed.</source>
          <target state="translated">속성 세트에서 이전에 attrID와 동일한 ID를 가진 속성. 그러한 속성이 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="17831de708d75ed43f9af6c62286f3a3d590fbe3" translate="yes" xml:space="preserve">
          <source>The Attributes class maps Manifest attribute names to associated string values.</source>
          <target state="translated">Attributes 클래스는 매니페스트 속성 이름을 관련 문자열 값에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="11106864e8cece63f4df274160f30c89327ce115" translate="yes" xml:space="preserve">
          <source>The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the JAR File Specification for more information about valid attribute names and values.</source>
          <target state="translated">Attributes 클래스는 매니페스트 속성 이름을 관련 문자열 값에 매핑합니다. 유효한 속성 이름은 대소 문자를 구분하지 않으며 [0-9a-zA-Z_-] 집합의 ASCII 문자로 제한되며 70자를 초과 할 수 없습니다. 속성 값은 모든 문자를 포함 할 수 있으며 출력 스트림에 기록 될 때 UTF8로 인코딩됩니다. 유효한 속성 이름 및 값에 대한 자세한 정보는 JAR 파일 스펙을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef11f26de12755419a148282a58582ba21062d2" translate="yes" xml:space="preserve">
          <source>The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. There must be a colon and a SPACE after the name; the combined length will not exceed 72 characters. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</source>
          <target state="translated">The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. There must be a colon and a SPACE after the name; the combined length will not exceed 72 characters. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</target>
        </trans-unit>
        <trans-unit id="5b1b32f55e754aebc8c66e80e5a265f6ce9b4d29" translate="yes" xml:space="preserve">
          <source>The Attributes.Name class represents an attribute name stored in this Map.</source>
          <target state="translated">Attributes.Name 클래스는이 맵에 저장된 속성 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e586abe0903b7ef3e0a894bd9fa0abd2347cbc7b" translate="yes" xml:space="preserve">
          <source>The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</source>
          <target state="translated">The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</target>
        </trans-unit>
        <trans-unit id="130d29f5e1935938287de918b31d59eac532adc8" translate="yes" xml:space="preserve">
          <source>The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the JAR File Specification for more information about valid attribute names and values.</source>
          <target state="translated">Attributes.Name 클래스는이 맵에 저장된 속성 이름을 나타냅니다. 유효한 속성 이름은 대소 문자를 구분하지 않으며 [0-9a-zA-Z_-] 집합의 ASCII 문자로 제한되며 70자를 초과 할 수 없습니다. 속성 값은 모든 문자를 포함 할 수 있으며 출력 스트림에 기록 될 때 UTF8로 인코딩됩니다. 유효한 속성 이름 및 값에 대한 자세한 정보는 JAR 파일 스펙을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="933c13e97de653f311c0095da4356feb1ef9aa07" translate="yes" xml:space="preserve">
          <source>The BIDI_EMBEDDING attribute in the text, if present, represents embedding level information. Negative values from -1 to -62 indicate overrides at the absolute value of the level. Positive values from 1 to 62 indicate embeddings. Where values are zero or not defined, the base embedding level as determined by the base direction is assumed.</source>
          <target state="translated">텍스트의 BIDI_EMBEDDING 속성 (있는 경우)은 포함 레벨 정보를 나타냅니다. -1에서 -62까지의 음수 값은 레벨의 절대 값에서 재정의를 나타냅니다. 1에서 62 사이의 양수 값은 임베딩을 나타냅니다. 값이 0이거나 정의되지 않은 경우 기본 방향으로 결정된 기본 포함 수준이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a6d149de56262f01e5e36cd8497b77dee6738e2" translate="yes" xml:space="preserve">
          <source>The BackSpace key.</source>
          <target state="translated">The BackSpace key.</target>
        </trans-unit>
        <trans-unit id="39a8d250337b403c7a9d7f4737d5c4ebb7d43c9b" translate="yes" xml:space="preserve">
          <source>The Balinese range with the Balinese digits.</source>
          <target state="translated">The Balinese range with the Balinese digits.</target>
        </trans-unit>
        <trans-unit id="479b03243c34870565e01fcb4d8b7558405fd430" translate="yes" xml:space="preserve">
          <source>The Base64 padding character &lt;code&gt;'='&lt;/code&gt; is accepted and interpreted as the end of the encoded byte data, but is not required. So if the final unit of the encoded byte data only has two or three Base64 characters (without the corresponding padding character(s) padded), they are decoded as if followed by padding character(s). If there is a padding character present in the final unit, the correct number of padding character(s) must be present, otherwise &lt;code&gt;IllegalArgumentException&lt;/code&gt; ( &lt;code&gt;IOException&lt;/code&gt; when reading from a Base64 stream) is thrown during decoding.</source>
          <target state="translated">Base64 패딩 문자 &lt;code&gt;'='&lt;/code&gt; 는 인코딩 된 바이트 데이터의 끝으로 승인되고 해석되지만 필수는 아닙니다. 따라서, 인코딩 된 바이트 데이터의 최종 단위가 2 개 또는 3 개의 Base64 문자 (패딩 문자를 채우지 않은 채) 만 가진 경우에는 패딩 문자가 뒤 따르는 것처럼 디코딩됩니다. 최종 단위에 패딩 문자가 있으면 올바른 수의 패딩 문자가 있어야합니다. 그렇지 않으면 디코딩 중에 &lt;code&gt;IllegalArgumentException&lt;/code&gt; ( Base64 스트림에서 읽을 때 &lt;code&gt;IOException&lt;/code&gt; )이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7f2fa42fffaffc455185b2641418acb565381be2" translate="yes" xml:space="preserve">
          <source>The BasicPermission class extends the Permission class, and can be used as the base class for permissions that want to follow the same naming convention as BasicPermission.</source>
          <target state="translated">BasicPermission 클래스는 Permission 클래스를 확장하며 BasicPermission과 동일한 이름 지정 규칙을 따르려는 권한의 기본 클래스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8109724094de0721a57a12d33075bebc3a6c1d9" translate="yes" xml:space="preserve">
          <source>The BasicReason enumerates the potential reasons that a certification path of any type may be invalid.</source>
          <target state="translated">BasicReason은 모든 유형의 인증 경로가 유효하지 않은 잠재적 이유를 열거합니다.</target>
        </trans-unit>
        <trans-unit id="7f2f07330207c79bdf9b8035cdfc8c33b0b86b6f" translate="yes" xml:space="preserve">
          <source>The BeanContext acts a logical hierarchical container for JavaBeans.</source>
          <target state="translated">BeanContext는 JavaBeans의 논리적 계층 컨테이너 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="db9f214e6794613d1af4a4bd16aca364a324671d" translate="yes" xml:space="preserve">
          <source>The BeanContextServices interface provides a mechanism for a BeanContext to expose generic &quot;services&quot; to the BeanContextChild objects within.</source>
          <target state="translated">BeanContextServices 인터페이스는 BeanContext가 일반 &quot;서비스&quot;를 BeanContextChild 객체에 노출 할 수있는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28e60bfa8d3958dbf027cd9ce5a707ff9a06e8f0" translate="yes" xml:space="preserve">
          <source>The Bengali range with the Bengali digits.</source>
          <target state="translated">The Bengali range with the Bengali digits.</target>
        </trans-unit>
        <trans-unit id="61f473874cda4877ad49e4b4e18b2669d648bcfa" translate="yes" xml:space="preserve">
          <source>The BigInteger constant one.</source>
          <target state="translated">BigInteger 상수입니다.</target>
        </trans-unit>
        <trans-unit id="4fe20da433bea836e2620a8e5bd24465caa34b0d" translate="yes" xml:space="preserve">
          <source>The BigInteger constant ten.</source>
          <target state="translated">BigInteger 상수 10입니다.</target>
        </trans-unit>
        <trans-unit id="2ae94bca84a3b818bb066e53ab21fbe4a5a93bac" translate="yes" xml:space="preserve">
          <source>The BigInteger constant two.</source>
          <target state="translated">The BigInteger constant two.</target>
        </trans-unit>
        <trans-unit id="eaa19daee6ceb68fa207da723944fc65078e9b5c" translate="yes" xml:space="preserve">
          <source>The BigInteger constant zero.</source>
          <target state="translated">BigInteger 상수 0입니다.</target>
        </trans-unit>
        <trans-unit id="f2abfa8bc11f1cc0906af68cb43302c5e56e7dbc" translate="yes" xml:space="preserve">
          <source>The Boolean class wraps a value of the primitive type &lt;code&gt;boolean&lt;/code&gt; in an object.</source>
          <target state="translated">부울 클래스는 기본 유형의 &lt;code&gt;boolean&lt;/code&gt; 값을 객체에 래핑 합니다.</target>
        </trans-unit>
        <trans-unit id="d66eb41900b1a53b5e15c061f84c26f96aec8f20" translate="yes" xml:space="preserve">
          <source>The Boolean class wraps a value of the primitive type &lt;code&gt;boolean&lt;/code&gt; in an object. An object of type &lt;code&gt;Boolean&lt;/code&gt; contains a single field whose type is &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">부울 클래스는 기본 유형의 &lt;code&gt;boolean&lt;/code&gt; 값을 객체에 래핑 합니다. &lt;code&gt;Boolean&lt;/code&gt; 유형의 객체 에는 유형이 &lt;code&gt;boolean&lt;/code&gt; 인 단일 필드가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="81801484504e216b7fb284280633eaa1558a087c" translate="yes" xml:space="preserve">
          <source>The BoxLayout manager is constructed with an axis parameter that specifies the type of layout that will be done. There are four choices:</source>
          <target state="translated">The BoxLayout manager is constructed with an axis parameter that specifies the type of layout that will be done. There are four choices:</target>
        </trans-unit>
        <trans-unit id="bc0905838de7d1f34ab2990b1ad9e0ca39c77842" translate="yes" xml:space="preserve">
          <source>The Builder class for building the CatalogFeatures object.</source>
          <target state="translated">The Builder class for building the CatalogFeatures object.</target>
        </trans-unit>
        <trans-unit id="efc67a7d1a2c9c36bea385389f98ef36be245ba3" translate="yes" xml:space="preserve">
          <source>The CIEXYZ conversion color space defined above.</source>
          <target state="translated">The CIEXYZ conversion color space defined above.</target>
        </trans-unit>
        <trans-unit id="806e172d08d936be7f9a402bfc1b266638b44841" translate="yes" xml:space="preserve">
          <source>The CLA byte of the command APDU is automatically adjusted to match the channel number of this CardChannel.</source>
          <target state="translated">The CLA byte of the command APDU is automatically adjusted to match the channel number of this CardChannel.</target>
        </trans-unit>
        <trans-unit id="69ad751af3c43bdb33861e917a3b1c15e936c9cf" translate="yes" xml:space="preserve">
          <source>The COLUMN_SIZE column represents the specified column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</source>
          <target state="translated">The COLUMN_SIZE column represents the specified column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</target>
        </trans-unit>
        <trans-unit id="36a57ef1b9f6c643e2079cf370e0822f39c24fb7" translate="yes" xml:space="preserve">
          <source>The COLUMN_SIZE column specifies the column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</source>
          <target state="translated">The COLUMN_SIZE column specifies the column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</target>
        </trans-unit>
        <trans-unit id="730ba74f50d3f28436fa29f532e375e6c0695ab2" translate="yes" xml:space="preserve">
          <source>The CPU time provided by this interface has nanosecond precision but not necessarily nanosecond accuracy.</source>
          <target state="translated">이 인터페이스가 제공하는 CPU 시간은 나노초 정밀도이지만 반드시 나노초 정확도는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e8f7f2f7ff227a32e7a5531eecf91cf56365cd7f" translate="yes" xml:space="preserve">
          <source>The CRL or OCSP response cannot be obtained because of a network error.</source>
          <target state="translated">네트워크 오류로 인해 CRL 또는 OCSP 응답을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7089d78e3e0c62b70041275bb433057c167f603b" translate="yes" xml:space="preserve">
          <source>The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt; RFC 5280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</source>
          <target state="translated">The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt; RFC 5280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b4d351c3db241b4d379234c7ac2cb5765fab41d2" translate="yes" xml:space="preserve">
          <source>The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt; RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</source>
          <target state="translated">CRLReason 열거는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280 : Internet X.509 공개 키 인프라 인증서 및 CRL 프로파일에&lt;/a&gt; 정의 된대로 인증서가 취소 된 이유를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e7812130094f12985b55dbf55a811756b56e1df5" translate="yes" xml:space="preserve">
          <source>The CS_CIEXYZ space used by the toCIEXYZ/fromCIEXYZ methods can be described as follows:</source>
          <target state="translated">The CS_CIEXYZ space used by the toCIEXYZ/fromCIEXYZ methods can be described as follows:</target>
        </trans-unit>
        <trans-unit id="c9919c5ae2bcb3b9d6a077925318f690f537fce5" translate="yes" xml:space="preserve">
          <source>The Caps Lock key, a non-ASCII action key.</source>
          <target state="translated">The Caps Lock key, a non-ASCII action key.</target>
        </trans-unit>
        <trans-unit id="8e67b3c0835b7fe125721227039570d3711aedb5" translate="yes" xml:space="preserve">
          <source>The Catalog API defines a standard solution for resolving external resources referenced by XML documents. It is fully supported by the XML Processors allowing application developers to configure a catalog through an XML processor or system property or the jaxp.properties file to take advantage of the feature.</source>
          <target state="translated">The Catalog API defines a standard solution for resolving external resources referenced by XML documents. It is fully supported by the XML Processors allowing application developers to configure a catalog through an XML processor or system property or the jaxp.properties file to take advantage of the feature.</target>
        </trans-unit>
        <trans-unit id="8c3439a20de44e9f818a8524933afd2726aea753" translate="yes" xml:space="preserve">
          <source>The Catalog Features are supported throughout the JAXP processors, including SAX and DOM (&lt;a href=&quot;../parsers/package-summary&quot;&gt;&lt;code&gt;javax.xml.parsers&lt;/code&gt;&lt;/a&gt;), and StAX parsers (&lt;a href=&quot;../stream/package-summary&quot;&gt;&lt;code&gt;javax.xml.stream&lt;/code&gt;&lt;/a&gt;), Schema Validation (&lt;a href=&quot;../validation/package-summary&quot;&gt;&lt;code&gt;javax.xml.validation&lt;/code&gt;&lt;/a&gt;), and XML Transformation (&lt;a href=&quot;../transform/package-summary&quot;&gt;&lt;code&gt;javax.xml.transform&lt;/code&gt;&lt;/a&gt;). The features described above can be set through JAXP factories or processors that define a setProperty or setAttribute interface. For example, the following code snippet sets a URI to a catalog file on a SAX parser through the &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property:</source>
          <target state="translated">The Catalog Features are supported throughout the JAXP processors, including SAX and DOM (&lt;a href=&quot;../parsers/package-summary&quot;&gt; &lt;code&gt;javax.xml.parsers&lt;/code&gt; &lt;/a&gt;), and StAX parsers (&lt;a href=&quot;../stream/package-summary&quot;&gt; &lt;code&gt;javax.xml.stream&lt;/code&gt; &lt;/a&gt;), Schema Validation (&lt;a href=&quot;../validation/package-summary&quot;&gt; &lt;code&gt;javax.xml.validation&lt;/code&gt; &lt;/a&gt;), and XML Transformation (&lt;a href=&quot;../transform/package-summary&quot;&gt; &lt;code&gt;javax.xml.transform&lt;/code&gt; &lt;/a&gt;). The features described above can be set through JAXP factories or processors that define a setProperty or setAttribute interface. For example, the following code snippet sets a URI to a catalog file on a SAX parser through the &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property:</target>
        </trans-unit>
        <trans-unit id="f5c80cce7f8e24a12ba725dd3dd4f782aefcd3e2" translate="yes" xml:space="preserve">
          <source>The Catalog Manager manages the creation of XML Catalogs and Catalog Resolvers.</source>
          <target state="translated">The Catalog Manager manages the creation of XML Catalogs and Catalog Resolvers.</target>
        </trans-unit>
        <trans-unit id="385001113bb38abb20285d1ebb83df4d50340b14" translate="yes" xml:space="preserve">
          <source>The Catalog class represents an entity Catalog as defined by &lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html&quot;&gt; XML Catalogs, OASIS Standard V1.1, 7 October 2005&lt;/a&gt;.</source>
          <target state="translated">The Catalog class represents an entity Catalog as defined by &lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html&quot;&gt; XML Catalogs, OASIS Standard V1.1, 7 October 2005&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1909b728d3f1eea8632e5d9e1f0a292d2819745c" translate="yes" xml:space="preserve">
          <source>The Catalog support is available for any process in the JAXP library that supports a resolver. The following table lists all such processes.</source>
          <target state="translated">The Catalog support is available for any process in the JAXP library that supports a resolver. The following table lists all such processes.</target>
        </trans-unit>
        <trans-unit id="ed3ae395d6b192794b3d15b214dfe88f06d1d0b4" translate="yes" xml:space="preserve">
          <source>The CatalogFeatures holds a collection of features and properties.</source>
          <target state="translated">The CatalogFeatures holds a collection of features and properties.</target>
        </trans-unit>
        <trans-unit id="45bf43ea40ad206a16c91fe7538584c327d0aa28" translate="yes" xml:space="preserve">
          <source>The CatalogResolver however, will throw &lt;a href=&quot;catalogexception&quot;&gt;&lt;code&gt;CatalogException&lt;/code&gt;&lt;/a&gt; only when &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; is specified as &lt;code&gt;strict&lt;/code&gt;. For applications that expect to handle the checked Exceptions, it may be necessary to use a custom resolver to wrap the CatalogResolver or implement it with a &lt;a href=&quot;catalog&quot;&gt;&lt;code&gt;Catalog&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">The CatalogResolver however, will throw &lt;a href=&quot;catalogexception&quot;&gt; &lt;code&gt;CatalogException&lt;/code&gt; &lt;/a&gt; only when &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; is specified as &lt;code&gt;strict&lt;/code&gt; . For applications that expect to handle the checked Exceptions, it may be necessary to use a custom resolver to wrap the CatalogResolver or implement it with a &lt;a href=&quot;catalog&quot;&gt; &lt;code&gt;Catalog&lt;/code&gt; &lt;/a&gt; object.</target>
        </trans-unit>
        <trans-unit id="3c9da4fdbaba5f8c9f09732fa4d7f6d8a7c39639" translate="yes" xml:space="preserve">
          <source>The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement for unique nonces with a given key. After each encryption or decryption operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305 ciphers with parameters that specify a different nonce value. Please see &lt;a href=&quot;https://tools.ietf.org/html/rfc7539&quot;&gt;RFC 7539&lt;/a&gt; for more information on the ChaCha20 and ChaCha20-Poly1305 algorithms.</source>
          <target state="translated">The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement for unique nonces with a given key. After each encryption or decryption operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305 ciphers with parameters that specify a different nonce value. Please see &lt;a href=&quot;https://tools.ietf.org/html/rfc7539&quot;&gt;RFC 7539&lt;/a&gt; for more information on the ChaCha20 and ChaCha20-Poly1305 algorithms.</target>
        </trans-unit>
        <trans-unit id="b6a9e74f4885fe7cf70c23e4e55e9a31b16bb5b1" translate="yes" xml:space="preserve">
          <source>The Cham range with the Cham digits.</source>
          <target state="translated">The Cham range with the Cham digits.</target>
        </trans-unit>
        <trans-unit id="33f1a9e451f535334439b331e5952fb5eceaa417" translate="yes" xml:space="preserve">
          <source>The Character Encoding is not supported.</source>
          <target state="translated">문자 인코딩은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a47ec8afb6ab11bcf60e2a316aaa05ee5d6f88e" translate="yes" xml:space="preserve">
          <source>The Class Loader Repository used by the given MBeanServer.</source>
          <target state="translated">주어진 MBeanServer가 사용하는 클래스 로더 저장소</target>
        </trans-unit>
        <trans-unit id="004f0206b3d3d849c825f918d9b68ef429b3b940" translate="yes" xml:space="preserve">
          <source>The Class object for the bean's customizer. This may be null if the bean doesn't have a customizer.</source>
          <target state="translated">Bean 커 스터 마이저의 Class 객체. Bean에 사용자 정의 프로그램이없는 경우 널이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="537754527d3370203382836d7cb800a91b8ee729" translate="yes" xml:space="preserve">
          <source>The Class object for the bean.</source>
          <target state="translated">Bean의 클래스 오브젝트</target>
        </trans-unit>
        <trans-unit id="df1481dabe3eac178ff1405ee9b4259ce1e6e7a5" translate="yes" xml:space="preserve">
          <source>The Class object for the target interface that will get invoked when the event is fired.</source>
          <target state="translated">이벤트가 시작될 때 호출 될 대상 인터페이스의 Class 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7eac5b9958cd8cfff4271334618aee040eeba806" translate="yes" xml:space="preserve">
          <source>The Class object representing the primitive type boolean.</source>
          <target state="translated">프리미티브 유형의 부울을 나타내는 Class 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3618cc4f2a2349312e42daaa29d613987f1e092c" translate="yes" xml:space="preserve">
          <source>The ClassLoader that the module is defined to</source>
          <target state="translated">The ClassLoader that the module is defined to</target>
        </trans-unit>
        <trans-unit id="d40630063d92d99c85238befefd749074cac2197" translate="yes" xml:space="preserve">
          <source>The ClassLoader used for that MBean. If &lt;var&gt;l&lt;/var&gt; is the MBean's actual ClassLoader, and &lt;var&gt;r&lt;/var&gt; is the returned value, then either:</source>
          <target state="translated">해당 MBean에 사용되는 ClassLoader 경우 &lt;var&gt;l&lt;/var&gt; MBean에의 실제 클래스 로더이고, &lt;var&gt;r&lt;/var&gt; 은 다음 중 반환 된 값입니다 :</target>
        </trans-unit>
        <trans-unit id="66051b6d430a30f6ea7fd611d6e0df14e41ad561" translate="yes" xml:space="preserve">
          <source>The ClassLoaderRepository for this MBeanServer.</source>
          <target state="translated">이 MBeanServer의 ClassLoaderRepository입니다.</target>
        </trans-unit>
        <trans-unit id="2fd3574d8c10f0ef7d993b723f5632e342d0a6ee" translate="yes" xml:space="preserve">
          <source>The CodeBase and Signedby components of the triplet name/value pairs are optional. If they are not present, then any any codebase will match, and any signer (including unsigned code) will match. For Example,</source>
          <target state="translated">삼중 항 이름 / 값 쌍의 CodeBase 및 Signedby 구성 요소는 선택 사항입니다. 존재하지 않으면 모든 코드베이스가 일치하고 서명자 (서명되지 않은 코드 포함)가 일치합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c2d96326649dde95c7e44b0d7b9ed5f0eb24edde" translate="yes" xml:space="preserve">
          <source>The Color choice action identifier The color is passed as an argument</source>
          <target state="translated">The Color choice action identifier The color is passed as an argument</target>
        </trans-unit>
        <trans-unit id="9aefa3745661aac9f95067164415b6aba2584a76" translate="yes" xml:space="preserve">
          <source>The ColorType instance to use for specifying color printing.</source>
          <target state="translated">The ColorType instance to use for specifying color printing.</target>
        </trans-unit>
        <trans-unit id="fc12d050c25db30932a215afa844cd2c0a1f9907" translate="yes" xml:space="preserve">
          <source>The ColorType instance to use for specifying monochrome printing.</source>
          <target state="translated">The ColorType instance to use for specifying monochrome printing.</target>
        </trans-unit>
        <trans-unit id="a1a553cf69cfe6ca631789fbb350d1c4c807cf8f" translate="yes" xml:space="preserve">
          <source>The Component that the @{code ComboBoxEditor} uses for editing.</source>
          <target state="translated">The Component that the @{code ComboBoxEditor} uses for editing.</target>
        </trans-unit>
        <trans-unit id="227d796281ad0577957a4e31b0889941847041af" translate="yes" xml:space="preserve">
          <source>The Component this DragGestureRecognizer is associated with</source>
          <target state="translated">The Component this DragGestureRecognizer is associated with</target>
        </trans-unit>
        <trans-unit id="d6129cd0df87476b144f9ae72f10280b8502d399" translate="yes" xml:space="preserve">
          <source>The Component this label is for; null if the label is not the label for a component</source>
          <target state="translated">The Component this label is for; null if the label is not the label for a component</target>
        </trans-unit>
        <trans-unit id="8e16e6d4e4c40d6ee7cab533803dc66da6417071" translate="yes" xml:space="preserve">
          <source>The Component will receive drops only if it is enabled.</source>
          <target state="translated">The Component will receive drops only if it is enabled.</target>
        </trans-unit>
        <trans-unit id="e75fddc976a61c1460b567593850ec1eade9d839" translate="yes" xml:space="preserve">
          <source>The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text.</source>
          <target state="translated">The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text.</target>
        </trans-unit>
        <trans-unit id="0c349a7e3983834131e43d6005575c88312a4af1" translate="yes" xml:space="preserve">
          <source>The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text. It is used to reflect the differences in this ordering between Western alphabets, Middle Eastern (such as Hebrew), and Far Eastern (such as Japanese).</source>
          <target state="translated">The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text. It is used to reflect the differences in this ordering between Western alphabets, Middle Eastern (such as Hebrew), and Far Eastern (such as Japanese).</target>
        </trans-unit>
        <trans-unit id="5789b4c7dbeca56610041c215040cd828abe15bd" translate="yes" xml:space="preserve">
          <source>The ConnectionBuilder instance that was created</source>
          <target state="translated">The ConnectionBuilder instance that was created</target>
        </trans-unit>
        <trans-unit id="88c73e6550e83b79c38c378eb869baa98b113ae7" translate="yes" xml:space="preserve">
          <source>The ContentHandler that is to be transformation output.</source>
          <target state="translated">The ContentHandler that is to be transformation output.</target>
        </trans-unit>
        <trans-unit id="17423c94f8f2ce034afcc39cef2cb4df86197b19" translate="yes" xml:space="preserve">
          <source>The Control key extended modifier constant.</source>
          <target state="translated">The Control key extended modifier constant.</target>
        </trans-unit>
        <trans-unit id="d1ab2b838d9028c98dee874736d7f5d9ec2c600c" translate="yes" xml:space="preserve">
          <source>The Control key modifier constant.</source>
          <target state="translated">The Control key modifier constant.</target>
        </trans-unit>
        <trans-unit id="69e37ac36977091dd5dd589e3937201a303cc9c9" translate="yes" xml:space="preserve">
          <source>The DGC abstraction is used for the server side of the distributed garbage collection algorithm.</source>
          <target state="translated">The DGC abstraction is used for the server side of the distributed garbage collection algorithm.</target>
        </trans-unit>
        <trans-unit id="bed07d1e948423e4a8940850acf00fea1b04ba74" translate="yes" xml:space="preserve">
          <source>The DGC abstraction is used for the server side of the distributed garbage collection algorithm. This interface contains the two methods: dirty and clean. A dirty call is made when a remote reference is unmarshaled in a client (the client is indicated by its VMID). A corresponding clean call is made when no more references to the remote reference exist in the client. A failed dirty call must schedule a strong clean call so that the call's sequence number can be retained in order to detect future calls received out of order by the distributed garbage collector. A reference to a remote object is leased for a period of time by the client holding the reference. The lease period starts when the dirty call is received. It is the client's responsibility to renew the leases, by making additional dirty calls, on the remote references it holds before such leases expire. If the client does not renew the lease before it expires, the distributed garbage collector assumes that the remote object is no longer referenced by that client.</source>
          <target state="translated">The DGC abstraction is used for the server side of the distributed garbage collection algorithm. This interface contains the two methods: dirty and clean. A dirty call is made when a remote reference is unmarshaled in a client (the client is indicated by its VMID). A corresponding clean call is made when no more references to the remote reference exist in the client. A failed dirty call must schedule a strong clean call so that the call's sequence number can be retained in order to detect future calls received out of order by the distributed garbage collector. A reference to a remote object is leased for a period of time by the client holding the reference. The lease period starts when the dirty call is received. It is the client's responsibility to renew the leases, by making additional dirty calls, on the remote references it holds before such leases expire. If the client does not renew the lease before it expires, the distributed garbage collector assumes that the remote object is no longer referenced by that client.</target>
        </trans-unit>
        <trans-unit id="7d83f00558a7ea5fd54e20050b4b87aeb295129d" translate="yes" xml:space="preserve">
          <source>The DOM Core does not support editing &lt;code&gt;Notation&lt;/code&gt; nodes; they are therefore readonly.</source>
          <target state="translated">The DOM Core does not support editing &lt;code&gt;Notation&lt;/code&gt; nodes; they are therefore readonly.</target>
        </trans-unit>
        <trans-unit id="43530ca2de642f60fb45cbf08c7d48675f2f6e1a" translate="yes" xml:space="preserve">
          <source>The DOM Core represents all attribute values as simple strings, even if the DTD or schema associated with the document declares them of some specific type such as tokenized.</source>
          <target state="translated">The DOM Core represents all attribute values as simple strings, even if the DTD or schema associated with the document declares them of some specific type such as tokenized.</target>
        </trans-unit>
        <trans-unit id="1199d22f6ddd51766a7301391a2be8379e37ab04" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 does not support editing entities, therefore &lt;code&gt;entities&lt;/code&gt; cannot be altered in any way.</source>
          <target state="translated">The DOM Level 2 does not support editing entities, therefore &lt;code&gt;entities&lt;/code&gt; cannot be altered in any way.</target>
        </trans-unit>
        <trans-unit id="c8bb5a095cdbe93e8badd4f90d462b85913dc20b" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 does not support editing notations, therefore &lt;code&gt;notations&lt;/code&gt; cannot be altered in any way.</source>
          <target state="translated">The DOM Level 2 does not support editing notations, therefore &lt;code&gt;notations&lt;/code&gt; cannot be altered in any way.</target>
        </trans-unit>
        <trans-unit id="38aa50df9727b894588dbbc35c05e27ae364fb85" translate="yes" xml:space="preserve">
          <source>The DOM does not provide any filters. &lt;code&gt;NodeFilter&lt;/code&gt; is just an interface that users can implement to provide their own filters.</source>
          <target state="translated">The DOM does not provide any filters. &lt;code&gt;NodeFilter&lt;/code&gt; is just an interface that users can implement to provide their own filters.</target>
        </trans-unit>
        <trans-unit id="df7387b1fd60bcbca923e30e23e97edc8aba858f" translate="yes" xml:space="preserve">
          <source>The DOM implementation is expected to use the attribute &lt;code&gt;Attr.isId&lt;/code&gt; to determine if an attribute is of type ID.</source>
          <target state="translated">DOM 구현은 속성이 ID 유형인지 확인하기 위해 &lt;code&gt;Attr.isId&lt;/code&gt; 속성을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="261049d3d4a4937744f0dafd0f1e3545c9ba8678" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ANY</source>
          <target state="translated">DTD 상수는 ANY에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="8c0b4e5d9b4605e3158ab4842fcd5983e5fb8dd8" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to CDATA</source>
          <target state="translated">DTD 상수는 CDATA에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="28996f14fa52b071fff9da5038251a1e16777136" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to CONREF</source>
          <target state="translated">DTD 상수는 CONREF에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f70e3a438499a724f3e9b5b8faacae04267c9342" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to CURRENT</source>
          <target state="translated">DTD 상수는 CURRENT에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7462581804069a243f9c87bece58e662cb9bbd5a" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to DEFAULT</source>
          <target state="translated">DTD 상수는 DEFAULT에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c5d9608e6bca1b6ed6581eea2cd2e05102db06db" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to EMPTY</source>
          <target state="translated">DTD 상수는 EMPTY에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ba76c731eea210411652ded92b544523f559f8cf" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ENDTAG</source>
          <target state="translated">DTD 상수는 ENDTAG에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b037b57b7b4055d8226d80e6b35f4dd61693ff9f" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ENTITIES</source>
          <target state="translated">DTD 상수는 ENTITIES에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="8c124dba0aabae007ca78f786c43238803deb8de" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ENTITY</source>
          <target state="translated">DTD 상수는 ENTITY에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="92bfbbfc06b21dd3f552573a10a0382a8a8b166c" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to FIXED</source>
          <target state="translated">DTD 상수는 FIXED에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d0730aee51ad3d5e3c5d358c5486abb58f57b053" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to GENERAL</source>
          <target state="translated">DTD 상수는 GENERAL에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d512f886dc03b5f4056a96d2ee1b6e8d93d6234f" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ID</source>
          <target state="translated">DTD 상수는 ID에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c82b046bea18e9a490fb2a44c0258368ed834626" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to IDREF</source>
          <target state="translated">DTD 상수는 IDREF에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="6385c232cbf5970b321152ba72e8ec4b8bf03880" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to IDREFS</source>
          <target state="translated">DTD 상수는 IDREFS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d27662c44dc624358badebfa3780410f2185d572" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to IMPLIED</source>
          <target state="translated">DTD 상수는 IMPLIED에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0bb5d1554124f83a103f88151731450f51e29063" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to MD</source>
          <target state="translated">DTD 상수는 MD에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9e2a110f1661c64c646c0d75fca1fd31b10c0d7b" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to MODEL</source>
          <target state="translated">DTD 상수는 MODEL에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="217e0e2fe34e949d8d212ae8100c329e2798959d" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to MS</source>
          <target state="translated">DTD 상수는 MS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="210401b9f4da9fb6620b3dfe9a679b8ba982571f" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NAME</source>
          <target state="translated">DTD 상수는 NAME에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d059f6bc57570668211b615f9ec763ce6c011d33" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NAMES</source>
          <target state="translated">DTD 상수는 NAMES에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="08d23b2ba3d9d4c0170e8dceb590345eef62e898" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NMTOKEN</source>
          <target state="translated">DTD 상수는 NMTOKEN에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="43e5d6fd6f35ae58bb647fdbe002079d0ef4e79c" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NMTOKENS</source>
          <target state="translated">DTD 상수는 NMTOKENS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4d3d6809165f3ec86156d0455227d9f935592dc6" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NOTATION</source>
          <target state="translated">DTD 상수는 NOTATION에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c82aa0c7d66e7bfc1ad232cd78fa3ee3b3837ca2" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUMBER</source>
          <target state="translated">DTD 상수는 NUMBER에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f6dcc9ece8551b878b9dbb942a5c4193aafd677b" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUMBERS</source>
          <target state="translated">DTD 상수는 NUMBERS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0f4c355ec8195dd5f3a4b693d27573962d42907a" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUTOKEN</source>
          <target state="translated">DTD 상수는 NUTOKEN에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="464cfae6e349c057b8352dc2ee53bd2e0ce2c4d2" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUTOKENS</source>
          <target state="translated">DTD 상수는 NUTOKENS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f530150f84f7ecb1f890a8d98900f43e6e96c04a" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to PARAMETER</source>
          <target state="translated">DTD 상수는 PARAMETER에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2b88e73f94ceff69a11fb44af74e03c994ab76c6" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to PI</source>
          <target state="translated">DTD 상수는 PI에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a793a8ddc64beceb41e4cb80ca28fff3889db1b7" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to PUBLIC</source>
          <target state="translated">DTD 상수는 PUBLIC에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4f40a4668a58a1e30057b305854e48fe8a85cb6e" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to RCDATA</source>
          <target state="translated">DTD 상수는 RCDATA에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="594edcbb019633ce1e15d7afb490d0bfd587095c" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to REQUIRED</source>
          <target state="translated">DTD 상수는 REQUIRED에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3941302d7f73508bc2f880765e67c45b860abdd3" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to SDATA</source>
          <target state="translated">DTD 상수는 SDATA에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7659fc2638f54b5b97b669423f51591f41e6dd65" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to STARTTAG</source>
          <target state="translated">DTD 상수는 STARTTAG에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2b30fe032c549b0fe7db4de6e7c9c64ffab5c023" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to SYSTEM</source>
          <target state="translated">DTD 상수는 SYSTEM에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2ced5dc3156a8a4a80da644c296c6141e4689e3c" translate="yes" xml:space="preserve">
          <source>The DTD specification is provided as Appendix A to the Java Logging APIs specification.</source>
          <target state="translated">DTD 사양은 Java Logging API 사양의 부록 A로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a7f4a801e7fcf309a447907757a88537413eb4aa" translate="yes" xml:space="preserve">
          <source>The DataBuffer that stores the image data.</source>
          <target state="translated">이미지 데이터를 저장하는 DataBuffer입니다.</target>
        </trans-unit>
        <trans-unit id="9b8dc3e1ba53caad2f4dafd2ec2d61e42595250b" translate="yes" xml:space="preserve">
          <source>The Delete key.</source>
          <target state="translated">Delete 키입니다.</target>
        </trans-unit>
        <trans-unit id="c016969447ee027a7d4e0c0671983d0d54d60bd4" translate="yes" xml:space="preserve">
          <source>The Descriptor fields contributed in this way by different annotations on the same program element must be consistent. That is, two different annotations, or two members of the same annotation, must not define a different value for the same Descriptor field. Fields from annotations on a getter method must also be consistent with fields from annotations on the corresponding setter method.</source>
          <target state="translated">설명자 필드는 동일한 프로그램 요소에 대해 다른 주석으로 이러한 방식으로 기여해야합니다. 즉, 두 개의 서로 다른 주석 또는 동일한 주석의 두 구성원이 동일한 설명자 필드에 대해 다른 값을 정의해서는 안됩니다. getter 메소드의 주석 필드는 해당 setter 메소드의 주석 필드와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bb6cc0ddd226d41211cd3043455d41114d7cede" translate="yes" xml:space="preserve">
          <source>The Descriptor resulting from these annotations will be merged with any Descriptor fields provided by the implementation, such as the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;
 immutableInfo&lt;/code&gt;&lt;/a&gt; field for an MBean. The fields from the annotations must be consistent with these fields provided by the implementation.</source>
          <target state="translated">이러한 어노테이션의 결과 인 Descriptor 는 MBean 의 &lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt; immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 와 같이 구현에서 제공하는 Descriptor 필드와 병합됩니다 . 주석의 필드는 구현에서 제공하는 이러한 필드와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bee60701b79c62232ecee0abd5ca5f3df40a69c" translate="yes" xml:space="preserve">
          <source>The Descriptor resulting from these annotations will be merged with any Descriptor fields provided by the implementation, such as the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;immutableInfo&lt;/code&gt;&lt;/a&gt; field for an MBean. The fields from the annotations must be consistent with these fields provided by the implementation.</source>
          <target state="translated">이러한 주석의 결과 인 Descriptor 는 MBean 의 &lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt;immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 와 같이 구현에서 제공 한 모든 Descriptor 필드와 병합됩니다 . 주석의 필드는 구현에서 제공 한 이러한 필드와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2264cfb97c49339ec2eb79ff8f9c5b3541970253" translate="yes" xml:space="preserve">
          <source>The Devanagari range with the Devanagari digits.</source>
          <target state="translated">Devanagari 숫자가있는 Devanagari 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c9d5aea86dc06f534995783c5eed783935bbadb9" translate="yes" xml:space="preserve">
          <source>The Directory Context</source>
          <target state="translated">디렉토리 컨텍스트</target>
        </trans-unit>
        <trans-unit id="3e6ee01f1cfdc49d30867413241b4a4694ea090f" translate="yes" xml:space="preserve">
          <source>The Document Type Declaration (see &lt;code&gt;DocumentType&lt;/code&gt;) associated with this document.</source>
          <target state="translated">이 문서 와 관련된 문서 유형 선언 ( &lt;code&gt;DocumentType&lt;/code&gt; 참조 )입니다.</target>
        </trans-unit>
        <trans-unit id="254ccb37fffeb4d7034d09aace0490d444a1fd8d" translate="yes" xml:space="preserve">
          <source>The Document Type Declaration (see &lt;code&gt;DocumentType&lt;/code&gt;) associated with this document. For XML documents without a document type declaration this returns &lt;code&gt;null&lt;/code&gt;. For HTML documents, a &lt;code&gt;DocumentType&lt;/code&gt; object may be returned, independently of the presence or absence of document type declaration in the HTML document.</source>
          <target state="translated">이 문서 와 관련된 문서 유형 선언 ( &lt;code&gt;DocumentType&lt;/code&gt; 참조 )입니다. 문서 유형 선언이없는 XML 문서의 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . HTML 문서의 경우 HTML 문서 에 문서 유형 선언이 있는지 여부와 관계없이 &lt;code&gt;DocumentType&lt;/code&gt; 객체가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d54d249addf311d02c8ca2ce1ec1e6177cdf46" translate="yes" xml:space="preserve">
          <source>The DocumentEvent notification is based upon the JavaBeans event model. There is no guarantee about the order of delivery to listeners, and all listeners must be notified prior to making further mutations to the Document. &lt;em&gt;This means implementations of the DocumentListener may not mutate the source of the event (i.e. the associated Document)&lt;/em&gt;.</source>
          <target state="translated">DocumentEvent 알림은 JavaBeans 이벤트 모델을 기반으로합니다. 청취자에게 전달되는 순서에 대한 보장은 없으며 문서를 추가로 변경하기 전에 모든 청취자에게 알려야합니다. &lt;em&gt;이는 DocumentListener의 구현이 이벤트의 소스 (즉, 관련 문서)를 변경할 수 없음을 의미합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="306e0349e4730fe12ea20a18564d5aded0a959d4" translate="yes" xml:space="preserve">
          <source>The DocumentTypeDefinition is written to the output</source>
          <target state="translated">DocumentTypeDefinition이 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d62abb5465a5124d177e3dae735859f7772db3a7" translate="yes" xml:space="preserve">
          <source>The Down Arrow key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 작업 키인 아래쪽 화살표 키입니다.</target>
        </trans-unit>
        <trans-unit id="535a8c59d3fc6ca72816c57f9fe3cb8a0847b806" translate="yes" xml:space="preserve">
          <source>The DriverManager will try to load as many drivers as it can find and then for any given connection request, it will ask each driver in turn to try to connect to the target URL.</source>
          <target state="translated">DriverManager는 찾을 수있는만큼의 드라이버를로드하려고 시도한 다음 지정된 연결 요청에 대해 차례로 각 드라이버에 대상 URL에 연결을 시도하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="9908e26b6e54260393c71d3b6feaa03992ee4047" translate="yes" xml:space="preserve">
          <source>The End key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 종료 키.</target>
        </trans-unit>
        <trans-unit id="82569fedc0af6f3aed7f65a6a3fe39ea20b67c7c" translate="yes" xml:space="preserve">
          <source>The Enter key.</source>
          <target state="translated">Enter 키입니다.</target>
        </trans-unit>
        <trans-unit id="9467ddc0b1822e3f422eef8fbcd692138357cb1f" translate="yes" xml:space="preserve">
          <source>The ErrorManager's &quot;error&quot; method will be invoked if any errors occur while using this Handler.</source>
          <target state="translated">이 핸들러를 사용하는 동안 오류가 발생하면 ErrorManager의 &quot;error&quot;메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="337111c58074fe3c7a3c0c5188b4a34f626e799a" translate="yes" xml:space="preserve">
          <source>The Escape key.</source>
          <target state="translated">Esc 키입니다.</target>
        </trans-unit>
        <trans-unit id="855ec55237c438b93c6ece3595fe96fed3e0fe47" translate="yes" xml:space="preserve">
          <source>The Ethiopic range with the Ethiopic digits.</source>
          <target state="translated">에티오피아 숫자가있는 에티오피아 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c4abdb2c97b7ad28fbff4b44ab36d6a6f3821d59" translate="yes" xml:space="preserve">
          <source>The Ethiopic range with the Ethiopic digits. Ethiopic does not have a decimal digit 0 so Latin (European) 0 is used.</source>
          <target state="translated">에티오피아 숫자가있는 에티오피아 범위입니다. 에티오피아에는 10 진수 0이 없으므로 라틴 (유럽) 0이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f846f27691c1830b0c4862884909ba741da0054f" translate="yes" xml:space="preserve">
          <source>The F1 function key, a non-ASCII action key.</source>
          <target state="translated">F1 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="e0c99ce79d7c1cf5f028270fbbd639ed83b660bf" translate="yes" xml:space="preserve">
          <source>The F10 function key, a non-ASCII action key.</source>
          <target state="translated">F10 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="34b95e3d41adccd87cc4a5447e94b0969fdf7692" translate="yes" xml:space="preserve">
          <source>The F11 function key, a non-ASCII action key.</source>
          <target state="translated">F11 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="4712072dec079034a0d1d72b4ea1e0bd718589b7" translate="yes" xml:space="preserve">
          <source>The F12 function key, a non-ASCII action key.</source>
          <target state="translated">F12 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="8f3e6133006f60f80467d379477797cb8466f921" translate="yes" xml:space="preserve">
          <source>The F2 function key, a non-ASCII action key.</source>
          <target state="translated">F2 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="8cba0d95d956dcad6261f3c860b0b98ddb8261bd" translate="yes" xml:space="preserve">
          <source>The F3 function key, a non-ASCII action key.</source>
          <target state="translated">F3 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="688fc8033a58b76724aa1e69114742ef26b5aea2" translate="yes" xml:space="preserve">
          <source>The F4 function key, a non-ASCII action key.</source>
          <target state="translated">F4 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="424aca125a04f4c0ca7b024f4f463806f8d801e0" translate="yes" xml:space="preserve">
          <source>The F5 function key, a non-ASCII action key.</source>
          <target state="translated">F5 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="75137fe57f42039f646febcef40c10236bd497b2" translate="yes" xml:space="preserve">
          <source>The F6 function key, a non-ASCII action key.</source>
          <target state="translated">F6 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="32df2a32958042664970351ad3ceae10e39b1214" translate="yes" xml:space="preserve">
          <source>The F7 function key, a non-ASCII action key.</source>
          <target state="translated">F7 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="04f2191aa3813883fac7f747c758351877d2dbd7" translate="yes" xml:space="preserve">
          <source>The F8 function key, a non-ASCII action key.</source>
          <target state="translated">F8 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="1822ce331e4a2923ad9c29fc3b0f664d404ea2c6" translate="yes" xml:space="preserve">
          <source>The F9 function key, a non-ASCII action key.</source>
          <target state="translated">F9 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="4d4c7427ed03e2196382cf762ac3a454fd9aad30" translate="yes" xml:space="preserve">
          <source>The FeatureDescriptor class is the common baseclass for PropertyDescriptor, EventSetDescriptor, and MethodDescriptor, etc.</source>
          <target state="translated">FeatureDescriptor 클래스는 PropertyDescriptor, EventSetDescriptor 및 MethodDescriptor 등의 공통 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6e02d9b92b748aa46a1fe40c56191a70c2db37b1" translate="yes" xml:space="preserve">
          <source>The ForkJoinTask class is not usually directly subclassed. Instead, you subclass one of the abstract classes that support a particular style of fork/join processing, typically &lt;a href=&quot;recursiveaction&quot;&gt;&lt;code&gt;RecursiveAction&lt;/code&gt;&lt;/a&gt; for most computations that do not return results, &lt;a href=&quot;recursivetask&quot;&gt;&lt;code&gt;RecursiveTask&lt;/code&gt;&lt;/a&gt; for those that do, and &lt;a href=&quot;countedcompleter&quot;&gt;&lt;code&gt;CountedCompleter&lt;/code&gt;&lt;/a&gt; for those in which completed actions trigger other actions. Normally, a concrete ForkJoinTask subclass declares fields comprising its parameters, established in a constructor, and then defines a &lt;code&gt;compute&lt;/code&gt; method that somehow uses the control methods supplied by this base class.</source>
          <target state="translated">ForkJoinTask 클래스는 일반적으로 직접 서브 클래스가 아닙니다. 대신, 포크의 특정 스타일을 지원하는 추상 클래스의 당신 서브 클래스 하나가 / 처리, 일반적으로 가입 &lt;a href=&quot;recursiveaction&quot;&gt; &lt;code&gt;RecursiveAction&lt;/code&gt; 을&lt;/a&gt; 결과를 반환하지 않는 대부분의 계산에, &lt;a href=&quot;recursivetask&quot;&gt; &lt;code&gt;RecursiveTask&lt;/code&gt; &lt;/a&gt; 할 것들, 그리고에 대한 &lt;a href=&quot;countedcompleter&quot;&gt; &lt;code&gt;CountedCompleter&lt;/code&gt; &lt;/a&gt; 하는 사람들을 위해이 행동이 다른 작업을 실행 완료. 일반적으로, 구체적인 ForkJoinTask 서브 클래스는 생성자에서 설정된 해당 매개 변수를 포함하는 필드를 선언 한 다음 이 기본 클래스가 제공하는 제어 메소드를 사용 하는 &lt;code&gt;compute&lt;/code&gt; 메소드 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b623035f5596637c9505afc931878e7c86c5b5b2" translate="yes" xml:space="preserve">
          <source>The GCM specification states that &lt;code&gt;tLen&lt;/code&gt; may only have the values {128, 120, 112, 104, 96}, or {64, 32} for certain applications. Other values can be specified for this class, but not all CSP implementations will support them.</source>
          <target state="translated">GCM 사양은 &lt;code&gt;tLen&lt;/code&gt; 이 특정 응용 프로그램에 대해 {128, 120, 112, 104, 96} 또는 {64, 32} 값만 가질 수 있다고 명시하고 있습니다. 이 클래스에 다른 값을 지정할 수 있지만 모든 CSP 구현이이를 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="21c0818ef96710144df08a551d7b266882d023aa" translate="yes" xml:space="preserve">
          <source>The GIF image writer plug-in guarantees lossless writing for images which meet the following requirements:</source>
          <target state="translated">GIF 이미지 작성기 플러그인은 다음 요구 사항을 충족하는 이미지에 대한 무손실 쓰기를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="69631d7c8bd6040a091b247bf1496d5ed878fb6f" translate="yes" xml:space="preserve">
          <source>The GIF image writer plug-in supports setting output stream metadata from metadata supplied to the writer in either the native GIF stream metadata format  javax_imageio_gif_stream_1.0  or the standard metadata format  javax_imageio_1.0, and setting output image metadata from metadata supplied to the writer in either the native GIF image metadata format  javax_imageio_gif_image_1.0  or the standard metadata format javax_imageio_1.0. The mapping of standard metadata format to the GIF native stream and image metadata formats is given in the tables  here .</source>
          <target state="translated">GIF 이미지 작성기 플러그인은 기본 GIF 스트림 메타 데이터 형식 javax_imageio_gif_stream_1.0 또는 표준 메타 데이터 형식 javax_imageio_1.0에서 작성기에 제공되는 메타 데이터의 출력 스트림 메타 데이터 설정을 지원합니다. 기본 GIF 이미지 메타 데이터 형식 javax_imageio_gif_image_1.0 또는 표준 메타 데이터 형식 javax_imageio_1.0 중 하나입니다. 표준 메타 데이터 형식을 GIF 기본 스트림 및 이미지 메타 데이터 형식으로 매핑하는 방법은 여기 표에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a39c518ab297860c2f8783913dcca7c6af3666c" translate="yes" xml:space="preserve">
          <source>The GIF image writer plug-in supports setting output stream metadata from metadata supplied to the writer in either the native GIF stream metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_stream_metadata_format&quot;&gt; javax_imageio_gif_stream_1.0&lt;/a&gt; or the standard metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt;, and setting output image metadata from metadata supplied to the writer in either the native GIF image metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format&quot;&gt; javax_imageio_gif_image_1.0&lt;/a&gt; or the standard metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt;. The mapping of standard metadata format to the GIF native stream and image metadata formats is given in the tables &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#mapping&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">GIF 이미지 작성기 플러그인은 기본 GIF 스트림 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_stream_metadata_format&quot;&gt;javax_imageio_gif_stream_1.0&lt;/a&gt; 또는 표준 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt; 으로 작성기에 제공된 메타 데이터의 출력 스트림 메타 데이터 설정 및 작성기에 제공된 메타 데이터의 출력 이미지 메타 데이터 설정을 지원합니다. 네이티브 GIF 이미지 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format&quot;&gt;javax_imageio_gif_image_1.0&lt;/a&gt; 또는 표준 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt; . 표준 메타 데이터 형식과 GIF 네이티브 스트림 및 이미지 메타 데이터 형식의 매핑은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#mapping&quot;&gt;여기&lt;/a&gt; 표에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fe47dfc42c1004ae9afdedd5c749c38a37ee470" translate="yes" xml:space="preserve">
          <source>The GIF writer plug-in supports the creation of animated GIF images through the standard sequence writing methods defined in the &lt;code&gt;ImageWriter&lt;/code&gt; class.</source>
          <target state="translated">GIF 작성기 플러그인은 &lt;code&gt;ImageWriter&lt;/code&gt; 클래스에 정의 된 표준 시퀀스 작성 방법을 통해 애니메이션 GIF 이미지 작성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="36041d90b5051a2148ab5cf02c46a6972de006b3" translate="yes" xml:space="preserve">
          <source>The GSS-API authentication tokens contain a definitive start and end. This method will attempt to read one of these tokens per invocation, and may block on the stream if only part of the token is available. In all other respects this method is equivalent to the byte array based &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;acceptSecContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GSS-API 인증 토큰은 명확한 시작과 끝을 포함합니다. 이 메서드는 호출 당 이러한 토큰 중 하나를 읽으려고 시도하고 토큰의 일부만 사용할 수있는 경우 스트림에서 차단할 수 있습니다. 다른 모든 측면에서이 메소드는 &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;acceptSecContext&lt;/code&gt; &lt;/a&gt; 기반의 바이트 배열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="56846475ff5ecbb5782e2832cfad2417350c183f" translate="yes" xml:space="preserve">
          <source>The GSS-API authentication tokens contain a definitive start and end. This method will attempt to read one of these tokens per invocation, and may block on the stream if only part of the token is available. In all other respects this method is equivalent to the byte array based &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;initSecContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GSS-API 인증 토큰은 명확한 시작과 끝을 포함합니다. 이 메서드는 호출 당 이러한 토큰 중 하나를 읽으려고 시도하고 토큰의 일부만 사용할 수있는 경우 스트림에서 차단할 수 있습니다. 다른 모든 측면에서이 메서드는 &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;initSecContext&lt;/code&gt; &lt;/a&gt; 기반의 바이트 배열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="eeb819a0af8bbcd4715be7fc89a01023347f013f" translate="yes" xml:space="preserve">
          <source>The GSS-API does not perform any communication with the peer. It merely produces tokens that the application must somehow transport to the other end.</source>
          <target state="translated">GSS-API는 피어와의 통신을 수행하지 않습니다. 애플리케이션이 어떻게 든 다른 쪽 끝으로 전송해야하는 토큰을 생성 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="016e2418772c7bef7110806243864d9ad960cfde" translate="yes" xml:space="preserve">
          <source>The GSS-API is defined in a language independent way in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2743.txt&quot;&gt;RFC 2743&lt;/a&gt;. The Java language bindings are defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853&lt;/a&gt;</source>
          <target state="translated">GSS-API는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2743.txt&quot;&gt;RFC 2743&lt;/a&gt; 에서 언어 독립적 인 방식으로 정의됩니다 . Java 언어 바인딩은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bda69e49cc0677094f88eb85a8d0e079496d764" translate="yes" xml:space="preserve">
          <source>The GSS-API itself does not dictate how an underlying mechanism obtains the credentials that are needed for authentication. It is assumed that prior to calling the GSS-API, these credentials are obtained and stored in a location that the mechanism provider is aware of. However, the default model in the Java platform will be that mechanism providers must obtain credentials only from the private or public credential sets associated with the &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; in the current access control context. The Kerberos v5 mechanism will search for the required INITIATE and ACCEPT credentials (&lt;a href=&quot;../../../javax/security/auth/kerberos/kerberosticket&quot;&gt;&lt;code&gt;KerberosTicket&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../javax/security/auth/kerberos/kerberoskey&quot;&gt;&lt;code&gt;KerberosKey&lt;/code&gt;&lt;/a&gt;) in the private credential set where as some other mechanism might look in the public set or in both. If the desired credential is not present in the appropriate sets of the current Subject, the GSS-API call must fail.</source>
          <target state="translated">GSS-API 자체는 기본 메커니즘이 인증에 필요한 자격 증명을 얻는 방법을 지시하지 않습니다. GSS-API를 호출하기 전에 이러한 자격 증명을 획득하여 메커니즘 공급자가 알고있는 위치에 저장한다고 가정합니다. 그러나 Java 플랫폼의 기본 모델은 메커니즘 제공자가 현재 액세스 제어 컨텍스트 의 &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; 와 연관된 개인 또는 공용 자격 증명 세트에서만 자격 증명을 가져와야한다는 것 입니다. Kerberos v5 메커니즘은 필요한 INITIATE 및 ACCEPT 자격 증명 ( &lt;a href=&quot;../../../javax/security/auth/kerberos/kerberosticket&quot;&gt; &lt;code&gt;KerberosTicket&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../javax/security/auth/kerberos/kerberoskey&quot;&gt; &lt;code&gt;KerberosKey&lt;/code&gt; )을 검색합니다.&lt;/a&gt;) 다른 메커니즘이 공개 세트 또는 둘 다에서 볼 수있는 개인 자격 증명 세트에서. 원하는 자격 증명이 현재 주제의 적절한 집합에 없으면 GSS-API 호출이 실패해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e36671f93a675a82883cad4ce03c74c37680a15" translate="yes" xml:space="preserve">
          <source>The GSSManager would then first check with B if m1 was needed. In case B did not provide support for m1, the GSSManager would continue on to check with A. If any mechanism m2 is needed where m2 is different from m1 then the GSSManager would skip B and check with A directly.</source>
          <target state="translated">그런 다음 GSSManager는 먼저 m1이 필요한지 B와 함께 확인합니다. B가 m1에 대한 지원을 제공하지 않은 경우 GSSManager는 계속해서 A와 확인합니다. m2가 m1과 다른 m2 메커니즘이 필요한 경우 GSSManager는 B를 건너 뛰고 A와 직접 확인합니다.</target>
        </trans-unit>
        <trans-unit id="78d03db12c1f011d0634db41f691571762f77a53" translate="yes" xml:space="preserve">
          <source>The GSSName name class contains public static Oid objects representing the standard name types defined in GSS-API.</source>
          <target state="translated">GSSName 이름 클래스에는 GSS-API에 정의 된 표준 이름 유형을 나타내는 공용 정적 Oid 개체가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0eb54612e1b91b3d550046715cc18734cac067" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark source code that has been generated.</source>
          <target state="translated">생성 된 주석은 생성 된 소스 코드를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f56c3c8627f80ee0eab3cf06dab68a8edf476a84" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark source code that has been generated. It can also be used to differentiate user written code from generated code in a single file.</source>
          <target state="translated">생성 된 주석은 생성 된 소스 코드를 표시하는 데 사용됩니다. 또한 사용자가 작성한 코드와 단일 파일에서 생성 된 코드를 구별하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e14d8067e3c65f5d662592905874e96a639ba661" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark source code that has been generated. It can also be used to differentiate user written code from generated code in a single file. When used, the value element must have the name of the code generator. The recommended convention is to use the fully qualified name of the code generator in the value field .</source>
          <target state="translated">생성 된 주석은 생성 된 소스 코드를 표시하는 데 사용됩니다. 또한 사용자가 작성한 코드와 생성 된 코드를 단일 파일로 구별하는 데 사용할 수 있습니다. 사용될 때 value 요소는 코드 생성기의 이름을 가져야합니다. 권장되는 규칙은 값 필드에 완전한 코드 생성기 이름을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7af39d750477e1f9f73af9fe47ad7493425adbba" translate="yes" xml:space="preserve">
          <source>The Grand Unification of the above three.</source>
          <target state="translated">위의 세 가지 대 통일.</target>
        </trans-unit>
        <trans-unit id="04a51ed5fc80fe55a7d442756d529463d0e7f962" translate="yes" xml:space="preserve">
          <source>The GraphicAttribute determines the logical and visual bounds of the text; the actual Font values are ignored.</source>
          <target state="translated">GraphicAttribute는 텍스트의 논리적 및 시각적 경계를 결정합니다. 실제 글꼴 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="80dc94d54b402ab87a3bcf626574c928999dab0b" translate="yes" xml:space="preserve">
          <source>The Gujarati range with the Gujarati digits.</source>
          <target state="translated">Gujarati 숫자가있는 Gujarati 범위입니다.</target>
        </trans-unit>
        <trans-unit id="3204f255d6bf3f20cea1af9b6db821aaebbf6fe0" translate="yes" xml:space="preserve">
          <source>The Gurmukhi range with the Gurmukhi digits.</source>
          <target state="translated">Gurmukhi 숫자가있는 Gurmukhi 범위입니다.</target>
        </trans-unit>
        <trans-unit id="034f52c179ed2f285aff346a1a725164486ab642" translate="yes" xml:space="preserve">
          <source>The HTTP cookie management in java.net package looks like:</source>
          <target state="translated">java.net 패키지의 HTTP 쿠키 관리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b3a512be37bd12625c3a8628efd22b37676aac1" translate="yes" xml:space="preserve">
          <source>The HTTP method (GET,POST,PUT,etc.).</source>
          <target state="translated">HTTP 메소드 (GET, POST, PUT 등)</target>
        </trans-unit>
        <trans-unit id="45069240481f167a4b1839f87d58530261cd8d54" translate="yes" xml:space="preserve">
          <source>The HTTP protocol handler has a few settings that can be accessed through System Properties. This covers &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#Proxies&quot;&gt;Proxy settings&lt;/a&gt; as well as &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#MiscHTTP&quot;&gt; various other settings&lt;/a&gt;.</source>
          <target state="translated">HTTP 프로토콜 처리기에는 시스템 속성을 통해 액세스 할 수있는 몇 가지 설정이 있습니다. 여기에는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#Proxies&quot;&gt;프록시 설정&lt;/a&gt; 과 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#MiscHTTP&quot;&gt;다양한 기타 설정이 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d94af71e4f20cb6dbee51f81cf708d34fd43e9a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol handler has a few settings that can be accessed through System Properties. This covers Proxy settings as well as  various other settings.</source>
          <target state="translated">HTTP 프로토콜 핸들러에는 시스템 속성을 통해 액세스 할 수있는 몇 가지 설정이 있습니다. 여기에는 프록시 설정 및 기타 다양한 설정이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5cddb7cac72e4320c7958e414281c0eaaa74294f" translate="yes" xml:space="preserve">
          <source>The HTTP protocol version.</source>
          <target state="translated">HTTP 프로토콜 버전입니다.</target>
        </trans-unit>
        <trans-unit id="0965d22a7cf7456f138f50ade9b626d2ce1a8ce8" translate="yes" xml:space="preserve">
          <source>The HTTP response message.</source>
          <target state="translated">HTTP 응답 메시지</target>
        </trans-unit>
        <trans-unit id="342acebe15f32e49ce73e2666488d1f7edf89d4a" translate="yes" xml:space="preserve">
          <source>The Highlighter bound to the associated text component is used to render the selection by default. Selection appearance can be customized by supplying a painter to use for the highlights. By default a painter is used that will render a solid color as specified in the associated text component in the &lt;code&gt;SelectionColor&lt;/code&gt; property. This can easily be changed by reimplementing the &lt;a href=&quot;#getSelectionPainter()&quot;&gt;&lt;code&gt;getSelectionPainter&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">연결된 텍스트 구성 요소에 바인딩 된 형광펜은 기본적으로 선택 항목을 렌더링하는 데 사용됩니다. 하이라이트에 사용할 페인터를 제공하여 선택 모양을 사용자 지정할 수 있습니다. 기본적으로 &lt;code&gt;SelectionColor&lt;/code&gt; 속성 의 관련 텍스트 구성 요소에 지정된 단색을 렌더링하는 페인터가 사용됩니다 . 이는 &lt;a href=&quot;#getSelectionPainter()&quot;&gt; &lt;code&gt;getSelectionPainter&lt;/code&gt; &lt;/a&gt; 메소드 를 다시 구현하여 쉽게 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76c37afd4ebfca43ecc7113a9e735aed8c4a4c59" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar has a different total of days in a year than Gregorian calendar, and the length of each month is based on the period of a complete revolution of the moon around the earth (as between successive new moons). Refer to the &lt;a href=&quot;hijrahchronology&quot;&gt;&lt;code&gt;HijrahChronology&lt;/code&gt;&lt;/a&gt; for details of supported variants.</source>
          <target state="translated">히즈라 달력은 그레고리력과는 달리 일 년에 총 일수가 다르며, 매월의 길이는 지구 주위의 달이 완전히 혁명적 인 기간 (연속적인 새 달 사이)에 기초합니다. 지원되는 변형에 대한 자세한 내용은 &lt;a href=&quot;hijrahchronology&quot;&gt; &lt;code&gt;HijrahChronology&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cbb0a5265ed2b32362a56646ea33dae11e8ddd1" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar is a lunar calendar supporting Islamic calendars.</source>
          <target state="translated">Hijrah 달력은 이슬람 달력을 지원하는 음력입니다.</target>
        </trans-unit>
        <trans-unit id="5ef062b6d3746a7faa9fd4ff82681d5f88437d55" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar system has one era, 'AH', defined by &lt;a href=&quot;hijrahera&quot;&gt;&lt;code&gt;HijrahEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hijrah 달력 시스템에는 &lt;a href=&quot;hijrahera&quot;&gt; &lt;code&gt;HijrahEra&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 'AH'시대가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e597c41e9fa5f54ee9b2548de5fc25d85b9400b7" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar system has only one era covering the proleptic years greater than zero.</source>
          <target state="translated">Hijrah 달력 시스템은 0보다 큰 발화 년을 다루는 시대가 단 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8c7bf054691c4990879f32b517b7eb5c7c8f7c31" translate="yes" xml:space="preserve">
          <source>The Hijrah property resource is a set of properties that describe the calendar. The syntax is defined by &lt;code&gt;java.util.Properties#load(Reader)&lt;/code&gt;.</source>
          <target state="translated">Hijrah 속성 리소스는 달력을 설명하는 속성 집합입니다. 구문은 &lt;code&gt;java.util.Properties#load(Reader)&lt;/code&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d5f51089d0f9a89148d7f6f56fbc17a08c3c7dd" translate="yes" xml:space="preserve">
          <source>The HijrahChronology follows the rules of the Hijrah calendar system. The Hijrah calendar has several variants based on differences in when the new moon is determined to have occurred and where the observation is made. In some variants the length of each month is computed algorithmically from the astronomical data for the moon and earth and in others the length of the month is determined by an authorized sighting of the new moon. For the algorithmically based calendars the calendar can project into the future. For sighting based calendars only historical data from past sightings is available.</source>
          <target state="translated">HijrahChronology는 Hijrah 일정 시스템의 규칙을 따릅니다. Hijrah 달력에는 초승달이 발생한 것으로 판단 된 시점과 관측 지점의 차이에 따라 여러 가지 변형이 있습니다. 어떤 변형에서, 달과 지구에 대한 천문학적 데이터로부터 각 달의 길이는 알고리즘에 의해 계산되고, 다른 달에서 달의 길이는 승인 된 초승달 관찰에 의해 결정된다. 알고리즘 기반 캘린더의 경우 캘린더는 미래로 투사 할 수 있습니다. 시력 기반 달력의 경우 과거 시력의 과거 데이터 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24e34ecc8a9ad3b4e4ea87309f75a1db55428a1" translate="yes" xml:space="preserve">
          <source>The Home key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 홈 키.</target>
        </trans-unit>
        <trans-unit id="b30101cf2f801668711691b72956c848b7ff79c7" translate="yes" xml:space="preserve">
          <source>The IANA charset registry does change over time, and so the canonical name and the aliases of a particular charset may also change over time. To ensure compatibility it is recommended that no alias ever be removed from a charset, and that if the canonical name of a charset is changed then its previous canonical name be made into an alias.</source>
          <target state="translated">IANA 문자 집합 레지스트리는 시간이 지남에 따라 변경되므로 특정 문자 집합의 정식 이름과 별칭도 시간이 지남에 따라 변경 될 수 있습니다. 호환성을 보장하기 위해 문자 집합에서 별칭을 제거하지 말고 문자 집합의 정식 이름을 변경하면 이전 정식 이름을 별칭으로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4291d010a17ade250e32deaae43f97dfb3a7ba1f" translate="yes" xml:space="preserve">
          <source>The ICC standard uses a device independent color space (DICS) as the mechanism for converting color from one device to another device. In this architecture, colors are converted from the source device's color space to the ICC DICS and then from the ICC DICS to the destination device's color space. The ICC standard defines device profiles which contain transforms which will convert between a device's color space and the ICC DICS. The overall conversion of colors from a source device to colors of a destination device is done by connecting the device-to-DICS transform of the profile for the source device to the DICS-to-device transform of the profile for the destination device. For this reason, the ICC DICS is commonly referred to as the profile connection space (PCS). The color space used in the methods toCIEXYZ and fromCIEXYZ is the CIEXYZ PCS defined by the ICC Specification. This is also the color space represented by ColorSpace.CS_CIEXYZ.</source>
          <target state="translated">ICC 표준은 한 장치에서 다른 장치로 색상을 변환하는 메커니즘으로 DICS (장치 독립 색상 공간)를 사용합니다. 이 아키텍처에서 색상은 소스 장치의 색상 공간에서 ICC DICS로 변환 된 다음 ICC DICS에서 대상 장치의 색상 공간으로 변환됩니다. ICC 표준은 장치의 색상 공간과 ICC DICS간에 변환되는 변환을 포함하는 장치 프로필을 정의합니다. 소스 장치에서 대상 장치의 색상으로의 전체 색상 변환은 소스 장치에 대한 프로필의 장치 대 DICS 변환을 대상 장치에 대한 프로필의 DICS 대 장치 변환에 연결하여 수행됩니다. 이러한 이유로 ICC DICS를 일반적으로 PCS (프로파일 연결 공간)라고합니다.toCIEXYZ 및 fromCIEXYZ 메서드에서 사용되는 색 공간은 ICC 사양에 정의 된 CIEXYZ PCS입니다. 이것은 ColorSpace.CS_CIEXYZ로 표현되는 색 공간이기도합니다.</target>
        </trans-unit>
        <trans-unit id="e6b1df547566cde6967819973372499ee99ddb22" translate="yes" xml:space="preserve">
          <source>The ICC_ColorSpace class is an implementation of the abstract ColorSpace class.</source>
          <target state="translated">ICC_ColorSpace 클래스는 추상 ColorSpace 클래스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="29a4fdfa37a516d2928ce968cabea4dcd82635e5" translate="yes" xml:space="preserve">
          <source>The ICC_ColorSpace class is an implementation of the abstract ColorSpace class. This representation of device independent and device dependent color spaces is based on the International Color Consortium Specification ICC.1:2001-12, File Format for Color Profiles (see &lt;a href=&quot;http://www.color.org&quot;&gt;http://www.color.org&lt;/a&gt;).</source>
          <target state="translated">ICC_ColorSpace 클래스는 추상 ColorSpace 클래스의 구현입니다. 장치 독립 및 장치 종속 색상 공간의이 표현은 International Color Consortium Specification ICC.1 : 2001-12, File Format for Color Profiles ( &lt;a href=&quot;http://www.color.org&quot;&gt;http://www.color.org 참조&lt;/a&gt; )를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="72f3ceadbe13561989c9f7b18cd300f66f00b9cf" translate="yes" xml:space="preserve">
          <source>The ICC_ProfileRGB class is a subclass of the ICC_Profile class that represents profiles which meet the following criteria:</source>
          <target state="translated">ICC_ProfileRGB 클래스는 다음 기준을 충족하는 프로필을 나타내는 ICC_Profile 클래스의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="46384c6ea74d47171799bd6ab4946e6155803a9f" translate="yes" xml:space="preserve">
          <source>The ICC_ProfileRGB class is a subclass of the ICC_Profile class that represents profiles which meet the following criteria: The profile's color space type is RGB. The profile includes the &lt;code&gt;redColorantTag&lt;/code&gt;, &lt;code&gt;greenColorantTag&lt;/code&gt;, &lt;code&gt;blueColorantTag&lt;/code&gt;, &lt;code&gt;redTRCTag&lt;/code&gt;, &lt;code&gt;greenTRCTag&lt;/code&gt;, &lt;code&gt;blueTRCTag&lt;/code&gt;, and &lt;code&gt;mediaWhitePointTag&lt;/code&gt; tags. The &lt;code&gt;ICC_Profile getInstance&lt;/code&gt; method will return an &lt;code&gt;ICC_ProfileRGB&lt;/code&gt; object when these conditions are met.</source>
          <target state="translated">ICC_ProfileRGB 클래스는 다음 기준을 충족하는 프로필을 나타내는 ICC_Profile 클래스의 하위 클래스입니다. 프로필의 색 공간 유형은 RGB입니다. 프로필에는 &lt;code&gt;redColorantTag&lt;/code&gt; , &lt;code&gt;greenColorantTag&lt;/code&gt; , &lt;code&gt;blueColorantTag&lt;/code&gt; , &lt;code&gt;redTRCTag&lt;/code&gt; , &lt;code&gt;greenTRCTag&lt;/code&gt; , &lt;code&gt;blueTRCTag&lt;/code&gt; 및 &lt;code&gt;mediaWhitePointTag&lt;/code&gt; 태그가 포함됩니다. &lt;code&gt;ICC_Profile getInstance&lt;/code&gt; 메소드가 리턴 &lt;code&gt;ICC_ProfileRGB&lt;/code&gt; 의 이러한 조건이 충족 될 때 개체를.</target>
        </trans-unit>
        <trans-unit id="a09a7c491e42ec0ccd6087606b59441de1f0715c" translate="yes" xml:space="preserve">
          <source>The ID is minor variation to the standard ISO-8601 formatted string for the offset. There are three formats:</source>
          <target state="translated">ID는 오프셋에 대한 표준 ISO-8601 형식 문자열과 약간 다릅니다. 세 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29cb73c296776b288211b97e00b807749e9b2d0" translate="yes" xml:space="preserve">
          <source>The ID is unique within the system. There are three types of ID.</source>
          <target state="translated">ID는 시스템 내에서 고유합니다. ID에는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae854760d3f4276cd755511e493cc5a51b830e12" translate="yes" xml:space="preserve">
          <source>The ID of the listener to which the notification is targeted.</source>
          <target state="translated">알림의 대상이되는 리스너의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="01ee2510bd3aca83bad9699f7e3b7df60b473549" translate="yes" xml:space="preserve">
          <source>The ID of the returned offset will be normalized to one of the formats described by &lt;a href=&quot;#getId()&quot;&gt;&lt;code&gt;getId()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 오프셋의 ID는 &lt;a href=&quot;#getId()&quot;&gt; &lt;code&gt;getId()&lt;/code&gt; &lt;/a&gt; 설명 된 형식 중 하나로 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="61fd4732cbe2e01752b6c8cf6a30f14f6ab40119" translate="yes" xml:space="preserve">
          <source>The ID of the returned offset will be normalized to one of the formats described by &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;getId()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 오프셋의 ID는 &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;getId()&lt;/code&gt; &lt;/a&gt; 설명 된 형식 중 하나로 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c8cb46fd48547fa630e300fcba11829a98c4159" translate="yes" xml:space="preserve">
          <source>The ID of the thread that owns the object that the thread is blocked.</source>
          <target state="translated">스레드가 차단 된 오브젝트를 소유 한 스레드의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="4bed910017ae47e15f9fd68ce9f4a7a2eb621fdb" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;#of(java.lang.String)&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . &lt;a href=&quot;#of(java.lang.String)&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;code&gt;Chronology&lt;/code&gt; 를 조회하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbbbed4ad86feca80f73d8a6ba6de9c29be78a79" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of(java.lang.String)&quot;&gt;&lt;code&gt;Chronology.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . 이는 조회하는데 사용될 수있다 &lt;code&gt;Chronology&lt;/code&gt; 사용 &lt;a href=&quot;chronology#of(java.lang.String)&quot;&gt; &lt;code&gt;Chronology.of(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6d60e60fa86ec5a78289385fee6d0f6bc1bdd6" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;Chronology.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . 이는 조회하는데 사용될 수있다 &lt;code&gt;Chronology&lt;/code&gt; 사용 &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;Chronology.of(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cafcec37d18d1f40c55857c337e84b388be6a4b" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;code&gt;Chronology&lt;/code&gt; 를 조회하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eec3d7c57ef5447e9bdebab954ee90700a2a652d" translate="yes" xml:space="preserve">
          <source>The IP address of the remote end of this socket.</source>
          <target state="translated">이 소켓의 리모트 엔드의 IP 주소</target>
        </trans-unit>
        <trans-unit id="510660eb55dda01e452a05872bd22f9cfe584483" translate="yes" xml:space="preserve">
          <source>The IPv6-address is a literal IPv6 address as described above. The</source>
          <target state="translated">IPv6- 주소는 위에서 설명한 리터럴 IPv6 주소입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="4679bfab8bdf1a02bfe30406e4c9f7a2085873a2" translate="yes" xml:space="preserve">
          <source>The ISO 3166-1 codes can be found on-line.</source>
          <target state="translated">ISO 3166-1 코드는 온라인에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="611dd8f9d48699c9411b9432a1cb2dc63863602c" translate="yes" xml:space="preserve">
          <source>The ISO calendar system behaves as follows:</source>
          <target state="translated">ISO 캘린더 시스템은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6082f991bd981467ab45e2ffde3309b5e82f6280" translate="yes" xml:space="preserve">
          <source>The ISO calendar system defines an additional week-based division of years. This defines a year based on whole Monday to Monday weeks. This is modeled in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ISO 캘린더 시스템은 추가 주 단위로 년을 정의합니다. 이것은 월요일부터 월요일까지의 주 전체를 기준으로 연도를 정의합니다. 이것은 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 에서 모델링되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4d077fd16854767d357096f809fb7b81bacb82c7" translate="yes" xml:space="preserve">
          <source>The ISO calendar system.</source>
          <target state="translated">ISO 캘린더 시스템.</target>
        </trans-unit>
        <trans-unit id="58e26e3bf55479a8a5120fe45b369953d4715df2" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date with an offset, such as '2011-12-03+01:00'.</source>
          <target state="translated">'2011-12-03 + 01 : 00'과 같이 오프셋으로 날짜를 형식화하거나 구문 분석하는 ISO 날짜 형식 기입니다.</target>
        </trans-unit>
        <trans-unit id="6de9417addd60d61c439ecd60520ce653b7ff208" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date with the offset if available, such as '2011-12-03' or '2011-12-03+01:00'.</source>
          <target state="translated">'2011-12-03'또는 '2011-12-03 + 01 : 00'과 같이 사용 가능한 경우 오프셋으로 날짜를 형식화하거나 구문 분석하는 ISO 날짜 형식 기입니다.</target>
        </trans-unit>
        <trans-unit id="2bed7eaa4131a3fd0eed3c41b0dc86a015ca96db" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date without an offset, such as '2011-12-03'.</source>
          <target state="translated">'2011-12-03'과 같이 오프셋없이 날짜를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="21efec4c9a9cd99bd7c37c45effa030d9f01c4ca" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date without an offset, such as '20111203'.</source>
          <target state="translated">'20111203'과 같이 오프셋없이 날짜를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="5e79ab154ec99d657cac16998df6c24432d36bfb" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses the ordinal date without an offset, such as '2012-337'.</source>
          <target state="translated">'2012-337'과 같이 오프셋없이 서수를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="8947499950b72303579b6072a1f0f70410f938f9" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses the week-based date without an offset, such as '2012-W48-6'.</source>
          <target state="translated">'2012-W48-6'과 같이 오프셋없이 주 기반 날짜를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="ad4a4f923ef1dd96afdbb263d3503d29224e8ce9" translate="yes" xml:space="preserve">
          <source>The ISO date of the first day of the minimum Hijrah year.</source>
          <target state="translated">최소 Hijrah 연도의 첫 날의 ISO 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="ab2094bfe0e934a818f591f8e39df5d0c0f5b428" translate="yes" xml:space="preserve">
          <source>The ISO date-time formatter that formats or parses a date-time with an offset, such as '2011-12-03T10:15:30+01:00'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30 + 01 : 00'과 같은 오프셋으로 날짜-시간을 형식화하거나 구문 분석하는 ISO 날짜-시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="b7f380848807763c304877a683626ef209b2dd72" translate="yes" xml:space="preserve">
          <source>The ISO date-time formatter that formats or parses a date-time without an offset, such as '2011-12-03T10:15:30'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30'과 같이 오프셋없이 날짜-시간을 형식화하거나 구문 분석하는 ISO 날짜-시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="bd2f9f3c47232e93e12ebe7e08b1617ed46664af" translate="yes" xml:space="preserve">
          <source>The ISO instant formatter that formats or parses an instant in UTC, such as '2011-12-03T10:15:30Z'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30Z'와 같이 UTC로 인스턴트를 형식화하거나 구문 분석하는 ISO 인스턴트 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="95a52b961a46e25216875fca80e6d411d7ab598a" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time with an offset, such as '10:15+01:00' or '10:15:30+01:00'.</source>
          <target state="translated">'10 : 15 + 01 : 00 '또는 '10 : 15 : 30 + 01 : 00'과 같이 오프셋으로 시간을 형식화하거나 구문 분석하는 ISO 시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="df2987c695a53ce54ed87dd02ab3fbad12667817" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time without an offset, such as '10:15' or '10:15:30'.</source>
          <target state="translated">'10 : 15 '또는 '10 : 15 : 30'과 같이 오프셋없이 시간을 형식화하거나 구문 분석하는 ISO 시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="d335e1639bd2cf2c6fa963a589bd508ea6cff667" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time, with the offset if available, such as '10:15', '10:15:30' or '10:15:30+01:00'.</source>
          <target state="translated">'10 : 15 ', '10 : 15 : 30'또는 '10 : 15 : 30 + 01 : 00 '과 같이 사용 가능한 경우 오프셋을 사용하여 시간을 형식화하거나 구문 분석하는 ISO 시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="0a3f5206473b8e9b0e863ce6a87c607ec16d4baa" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.</source>
          <target state="translated">ISO-8601 캘린더 시스템은 오늘날 대부분의 세계에서 사용되는 최신 민사 캘린더 시스템입니다. 그것은 윤년에 대한 오늘날의 규칙이 모든 시간에 적용되는 다발성 그레고리력 시스템과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6b0753a83aa00ab66715a1d0bce536d311b35dee" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.</source>
          <target state="translated">ISO-8601 캘린더 시스템은 오늘날 대부분의 세계에서 사용되는 최신 민사 캘린더 시스템입니다. 그것은 윤년에 대한 오늘날의 규칙이 모든 시간에 적용되는 다발성 그레고리력 시스템과 동일합니다. 오늘날 작성된 대부분의 응용 프로그램에는 ISO-8601 규칙이 전적으로 적합합니다. 그러나 과거 날짜를 사용하고 정확한 날짜를 요구하는 응용 프로그램은 ISO-8601 접근 방식이 적합하지 않다는 것을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="2b87b0b3d3f02384c82a8cdf0d2d60d19047ef46" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. This API assumes that all calendar systems use the same representation, this class, for time-of-day.</source>
          <target state="translated">ISO-8601 캘린더 시스템은 오늘날 대부분의 세계에서 사용되는 최신 민사 캘린더 시스템입니다. 이 API는 모든 달력 시스템이 시간에 대해 동일한 클래스 인이 클래스를 사용한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="24cf4f50b66f15436634e4e63889e0eeb0811579" translate="yes" xml:space="preserve">
          <source>The ISO-8601 definition, where a week starts on Monday and the first week has a minimum of 4 days.</source>
          <target state="translated">주가 월요일에 시작하고 첫 번째 주가 최소 4 일인 ISO-8601 정의.</target>
        </trans-unit>
        <trans-unit id="ea56e5764492774cbd5793c14b636ad2fff88f1f" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard defines a calendar system based on weeks. It uses the week-based-year and week-of-week-based-year concepts to split up the passage of days instead of the standard year/month/day.</source>
          <target state="translated">ISO-8601 표준은 주 단위로 달력 시스템을 정의합니다. 주별 및 주별 개념을 사용하여 표준 연도 / 월 / 일 대신 요일을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="cd8f2e4ef07a7ae4561e3a206df7d9c3194cc3bf" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard does not define eras. A definition has therefore been created with two eras - 'Current era' (CE) for years on or after 0001-01-01 (ISO), and 'Before current era' (BCE) for years before that.</source>
          <target state="translated">ISO-8601 표준은 시대를 정의하지 않습니다. 따라서 0001-01-01 (ISO) 또는 그 이후 몇 년 동안 '현재 시대'(CE)와 그 이전 몇 년 동안 '현재 시대 이전'(BCE)이라는 두 가지 시대로 정의가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="15f2960aca862d8387dbd45828c14f2ee1a23360" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard is based on the standard civic 12 month year. This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.</source>
          <target state="translated">ISO-8601 표준은 표준 시민 12 개월 연도를 기준으로합니다. 이것은 일반적으로 4 분기로 나누어지며 종종 Q1, Q2, Q3 및 Q4로 약칭됩니다.</target>
        </trans-unit>
        <trans-unit id="6e18900e4d1930d96696f4d4906e19682a06d587" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard was originally intended as a data interchange format, defining a string format for dates and times. However, it also defines an alternate way of expressing the date, based on the concept of week-based-year.</source>
          <target state="translated">ISO-8601 표준은 원래 날짜와 시간에 대한 문자열 형식을 정의하는 데이터 교환 형식으로 고안되었습니다. 그러나 주별 연도의 개념에 따라 날짜를 표현하는 다른 방법도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="12da9e8bfa2848ec37f88ea0629d59e6306e0906" translate="yes" xml:space="preserve">
          <source>The ISO-like date-time formatter that formats or parses a date-time with offset and zone, such as '2011-12-03T10:15:30+01:00[Europe/Paris]'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30 + 01 : 00 [유럽 / 파리]'와 같이 오프셋 및 영역으로 날짜 시간을 형식화하거나 구문 분석하는 ISO와 같은 날짜-시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="86afa3124f1aed75c36e4dd56bfce8c49977f732" translate="yes" xml:space="preserve">
          <source>The ISO-like date-time formatter that formats or parses a date-time with the offset and zone if available, such as '2011-12-03T10:15:30', '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30', '2011-12-03T10 : 15 : 30 + 01과 같이 사용 가능한 경우 오프셋 및 영역으로 날짜 시간을 형식화하거나 구문 분석하는 ISO와 같은 날짜-시간 포맷터 : 00 '또는'2011-12-03T10 : 15 : 30 + 01 : 00 [유럽 / 파리] '.</target>
        </trans-unit>
        <trans-unit id="1770c1e43e10767defa4c018f5743b7b2d0ab296" translate="yes" xml:space="preserve">
          <source>The IV is taken from &lt;code&gt;iv&lt;/code&gt;, starting at &lt;code&gt;offset&lt;/code&gt; inclusive. Note that the size of the IV (block size), starting at &lt;code&gt;offset&lt;/code&gt; inclusive, must be twice the word size. The bytes that constitute the IV are those between &lt;code&gt;iv[offset]&lt;/code&gt; and &lt;code&gt;iv[offset+2*(wordSize/8)-1]&lt;/code&gt; inclusive.</source>
          <target state="translated">IV는 &lt;code&gt;offset&lt;/code&gt; 포함 하여 &lt;code&gt;iv&lt;/code&gt; 에서 가져옵니다 . &lt;code&gt;offset&lt;/code&gt; 포함 하여 IV의 크기 (블록 크기) 는 워드 크기의 두 배 여야합니다. IV를 구성하는 바이트는 &lt;code&gt;iv[offset]&lt;/code&gt; 과 &lt;code&gt;iv[offset+2*(wordSize/8)-1]&lt;/code&gt; 사이의 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="47f00745675042f6a724b595797a24a07101fd7a" translate="yes" xml:space="preserve">
          <source>The IV is taken from &lt;code&gt;iv&lt;/code&gt;, starting at &lt;code&gt;offset&lt;/code&gt; inclusive. The bytes that constitute the IV are those between &lt;code&gt;iv[offset]&lt;/code&gt; and &lt;code&gt;iv[offset+7]&lt;/code&gt; inclusive.</source>
          <target state="translated">IV는 &lt;code&gt;offset&lt;/code&gt; 포함 하여 &lt;code&gt;iv&lt;/code&gt; 에서 가져옵니다 . IV를 구성하는 바이트는 &lt;code&gt;iv[offset]&lt;/code&gt; 과 &lt;code&gt;iv[offset+7]&lt;/code&gt; 사이의 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="dd985ba4ac843c2aa13ce1073a3079fccc30b81d" translate="yes" xml:space="preserve">
          <source>The Id of the calendar in common usage</source>
          <target state="translated">일반적으로 사용되는 캘린더의 ID</target>
        </trans-unit>
        <trans-unit id="faa9a0061bb28bf6c97cd39acf5b5a828ccf93f4" translate="yes" xml:space="preserve">
          <source>The InetAddress class has a cache to store successful as well as unsuccessful host name resolutions.</source>
          <target state="translated">InetAddress 클래스에는 성공 및 실패한 호스트 이름 확인을 저장하기위한 캐시가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6bf2f6528348c5b02c604ad3248d294717b2a1b" translate="yes" xml:space="preserve">
          <source>The InetAddress class provides methods to resolve host names to their IP addresses and vice versa.</source>
          <target state="translated">InetAddress 클래스는 호스트 이름을 IP 주소로 또는 그 반대로 확인하는 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="65b8748cc6268fcd7ebec74a58229406dde9da72" translate="yes" xml:space="preserve">
          <source>The InetAddress returned will represent the IPv4 loopback address, 127.0.0.1, or the IPv6 loopback address, ::1. The IPv4 loopback address returned is only one of many in the form 127.*.*.*</source>
          <target state="translated">반환 된 InetAddress는 IPv4 루프백 주소 127.0.0.1 또는 IPv6 루프백 주소 :: 1을 나타냅니다. 반환 된 IPv4 루프백 주소는 127. *. *. * 형식의 많은 것 중 하나 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="2152fa5309ac167073dd45954409ff4768fda7a1" translate="yes" xml:space="preserve">
          <source>The Initial Context</source>
          <target state="translated">초기 상황</target>
        </trans-unit>
        <trans-unit id="ac8c89b1c1f180681f98a482edf01b3499693ace" translate="yes" xml:space="preserve">
          <source>The Insert key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 Insert 키.</target>
        </trans-unit>
        <trans-unit id="9ff6f766ad82286cf3b4ec81ad2977fb2af744de" translate="yes" xml:space="preserve">
          <source>The Internet Assigned Numbers Authority maintains the &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes.html&quot;&gt;official list of URI schemes&lt;/a&gt;.</source>
          <target state="translated">인터넷 할당 번호 기관 (Internet Assigned Numbers Authority)은 &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes.html&quot;&gt;공식적인 URI 체계 목록을&lt;/a&gt; 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="d6529cb88cc0262a6e384c19547d019dbb6bed8b" translate="yes" xml:space="preserve">
          <source>The Introspector class provides a standard way for tools to learn about the properties, events, and methods supported by a target Java Bean.</source>
          <target state="translated">Introspector 클래스는 도구가 대상 Java Bean이 지원하는 특성, 이벤트 및 메소드를 학습 할 수있는 표준 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d59d73b56b3dc062d05806ca58651ba62a2b2f54" translate="yes" xml:space="preserve">
          <source>The JAAS login module in the JDK reference implementation destroys all tickets after logout.</source>
          <target state="translated">JDK 참조 구현의 JAAS 로그인 모듈은 로그 아웃 후 모든 티켓을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="fc346e9074de046178b6976458380753f8a1bf98" translate="yes" xml:space="preserve">
          <source>The JAR File Specification defines manifest attributes for standalone applications that are packaged as &lt;em&gt;executable JAR files&lt;/em&gt;. If an implementation supports a mechanism to start an application as an executable JAR then the main manifest may include the &lt;code&gt;Launcher-Agent-Class&lt;/code&gt; attribute to specify the class name of an agent to start before the application &lt;code&gt;main&lt;/code&gt; method is invoked. The Java virtual machine attempts to invoke the following method on the agent class:</source>
          <target state="translated">JAR 파일 사양은 &lt;em&gt;실행 가능한 JAR 파일&lt;/em&gt; 로 패키지 된 독립형 응용 프로그램에 대한 매니페스트 속성을 정의 &lt;em&gt;합니다&lt;/em&gt; . 구현이 애플리케이션을 실행 가능한 JAR로 시작하는 메커니즘을 지원하는 경우 기본 매니페스트에는 애플리케이션 &lt;code&gt;main&lt;/code&gt; 메서드가 호출 되기 전에 시작할 에이전트의 클래스 이름을 지정하는 &lt;code&gt;Launcher-Agent-Class&lt;/code&gt; 속성 이 포함될 수 있습니다 . JVM (Java Virtual Machine)은 에이전트 클래스에서 다음 메소드를 호출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9399cacad1f2d454e6eb5e3191a8f321b607ef5b" translate="yes" xml:space="preserve">
          <source>The JAR File Specification: Package Sealing</source>
          <target state="translated">JAR 파일 사양 : 패키지 봉인</target>
        </trans-unit>
        <trans-unit id="bb84f09030f91494fb9beb5357d12365eccba462" translate="yes" xml:space="preserve">
          <source>The JAR manifest file name.</source>
          <target state="translated">JAR 매니페스트 파일 이름</target>
        </trans-unit>
        <trans-unit id="767966e80e6e7fb64c0055271e699571168269ff" translate="yes" xml:space="preserve">
          <source>The JAXP Processors' support for Catalog depends on both the &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt;&lt;code&gt;USE_CATALOG&lt;/code&gt;&lt;/a&gt; feature and the existence of valid Catalog file(s). A JAXP processor will use the Catalog only when the feature is true and valid Catalog file(s) are specified through the &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property. It will make no attempt to use the Catalog if either &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt;&lt;code&gt;USE_CATALOG&lt;/code&gt;&lt;/a&gt; is set to false, or there is no Catalog file specified.</source>
          <target state="translated">JAXP 프로세서의 카탈로그 지원은 &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt; &lt;code&gt;USE_CATALOG&lt;/code&gt; &lt;/a&gt; 기능 및 유효한 카탈로그 파일의 존재 여부에 따라 다릅니다 . JAXP 프로세서는 기능이 true이고 유효한 카탈로그 파일이 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 속성을 통해 지정된 경우에만 카탈로그를 사용합니다 . &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt; &lt;code&gt;USE_CATALOG&lt;/code&gt; &lt;/a&gt; 가 false로 설정되거나 카탈로그 파일이 지정되지 않은 경우 카탈로그 사용을 시도 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="672525f13b4776f4afc24e25f67783864e75b16d" translate="yes" xml:space="preserve">
          <source>The JAXP parsing API has been integrated with the Validation API. Applications may create a &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; with the validation API and associate it with a &lt;a href=&quot;../parsers/documentbuilderfactory&quot;&gt;&lt;code&gt;DocumentBuilderFactory&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../parsers/saxparserfactory&quot;&gt;&lt;code&gt;SAXParserFactory&lt;/code&gt;&lt;/a&gt; instance by using the &lt;a href=&quot;../parsers/documentbuilderfactory#setSchema(javax.xml.validation.Schema)&quot;&gt;&lt;code&gt;DocumentBuilderFactory.setSchema(Schema)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../parsers/saxparserfactory#setSchema(javax.xml.validation.Schema)&quot;&gt;&lt;code&gt;SAXParserFactory.setSchema(Schema)&lt;/code&gt;&lt;/a&gt; methods. &lt;strong&gt;You should not&lt;/strong&gt; both set a schema and call &lt;code&gt;setValidating(true)&lt;/code&gt; on a parser factory. The former technique will cause parsers to use the new validation API; the latter will cause parsers to use their own internal validation facilities. &lt;strong&gt;Turning on both of these options simultaneously will cause either redundant behavior or error conditions.&lt;/strong&gt;</source>
          <target state="translated">JAXP 구문 분석 API는 유효성 검사 API와 통합되었습니다. 응용 프로그램은 유효성 검사 API 로 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; 를 만들고 &lt;a href=&quot;../parsers/documentbuilderfactory#setSchema(javax.xml.validation.Schema)&quot;&gt; &lt;code&gt;DocumentBuilderFactory.setSchema(Schema)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../parsers/saxparserfactory#setSchema(javax.xml.validation.Schema)&quot;&gt; &lt;code&gt;SAXParserFactory.setSchema(Schema)&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하여 이를 &lt;a href=&quot;../parsers/documentbuilderfactory&quot;&gt; &lt;code&gt;DocumentBuilderFactory&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../parsers/saxparserfactory&quot;&gt; &lt;code&gt;SAXParserFactory&lt;/code&gt; &lt;/a&gt; 인스턴스 와 연결할 수 있습니다. 파서 팩토리 에서 스키마를 설정하고 &lt;code&gt;setValidating(true)&lt;/code&gt; 을 호출하면 &lt;strong&gt;안됩니다&lt;/strong&gt; . 이전 기술은 파서가 새로운 유효성 검사 API를 사용하도록합니다. 후자는 파서가 자체 내부 유효성 검사 기능을 사용하도록합니다. &lt;strong&gt;이 두 옵션을 동시에 켜면 중복 동작 또는 오류 조건이 발생합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db8911ccdb0a32b11e7f663779352a6851708390" translate="yes" xml:space="preserve">
          <source>The JAXP processors give preference to user-specified custom resolvers. If such a resolver is registered, it will be used over the CatalogResolver. If it returns null however, the processors will continue resolving with the CatalogResolver. If it returns an empty source, no attempt will be made by the CatalogResolver.</source>
          <target state="translated">JAXP 프로세서는 사용자 지정 사용자 지정 해석기를 선호합니다. 이러한 리졸버가 등록되면 CatalogResolver를 통해 사용됩니다. 그러나 null을 반환하면 프로세서는 CatalogResolver로 계속 분석합니다. 빈 소스를 반환하면 CatalogResolver가 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99f24bc9813db0373534263c88d5131c62a4ac28" translate="yes" xml:space="preserve">
          <source>The JAXP processors will observe the default settings of the &lt;a href=&quot;catalogfeatures&quot;&gt;&lt;code&gt;CatalogFeatures&lt;/code&gt;&lt;/a&gt;. The processors, for example, will report an Exception by default when no matching entry is found since the default value of the &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; property is strict.</source>
          <target state="translated">JAXP 프로세서는 &lt;a href=&quot;catalogfeatures&quot;&gt; &lt;code&gt;CatalogFeatures&lt;/code&gt; &lt;/a&gt; 의 기본 설정을 준수합니다 . 예를 들어, 프로세서는 &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; 속성 의 기본값 이 엄격하기 때문에 일치하는 항목이없는 경우 기본적으로 예외를보고합니다 .</target>
        </trans-unit>
        <trans-unit id="a2d24c7890bba0f3964cbaede11464e0250281a1" translate="yes" xml:space="preserve">
          <source>The JAXP validation API decouples the validation of an instance document from the parsing of an XML document. This is advantageous for several reasons, some of which are:</source>
          <target state="translated">JAXP 유효성 검사 API는 XML 문서 구문 분석에서 인스턴스 문서 유효성 검사를 분리합니다. 이는 다음과 같은 몇 가지 이유로 유리합니다.</target>
        </trans-unit>
        <trans-unit id="c6740abff5341aaea3d3add9108309db47269f46" translate="yes" xml:space="preserve">
          <source>The JDBC 1.0 API</source>
          <target state="translated">JDBC 1.0 API</target>
        </trans-unit>
        <trans-unit id="2ef0b1e1237f551a4a27a689e562cb12d6000ad9" translate="yes" xml:space="preserve">
          <source>The JDBC 1.2 API</source>
          <target state="translated">JDBC 1.2 API</target>
        </trans-unit>
        <trans-unit id="58d78690167f9669f3dd44eef343f4abed230945" translate="yes" xml:space="preserve">
          <source>The JDBC 2.0 Optional Package API</source>
          <target state="translated">JDBC 2.0 선택적 패키지 API</target>
        </trans-unit>
        <trans-unit id="2210ba25b69c2db4ed032d072c7ec3aa1505d86c" translate="yes" xml:space="preserve">
          <source>The JDBC 2.1 core API</source>
          <target state="translated">JDBC 2.1 핵심 API</target>
        </trans-unit>
        <trans-unit id="ea17f896a65d406c1673560b63457b11cfbedc0c" translate="yes" xml:space="preserve">
          <source>The JDBC 3.0 API</source>
          <target state="translated">JDBC 3.0 API</target>
        </trans-unit>
        <trans-unit id="59a75209b42a7de6d5159a3ca206067460cfc599" translate="yes" xml:space="preserve">
          <source>The JDBC 3.0 specification added the maxStatements &lt;code&gt;ConnectionPooledDataSource&lt;/code&gt; property to provide a standard mechanism for enabling the pooling of &lt;code&gt;PreparedStatements&lt;/code&gt; and to specify the size of the statement pool. However, there was no way for a driver to notify an external statement pool when a &lt;code&gt;PreparedStatement&lt;/code&gt; becomes invalid. For some databases, a statement becomes invalid if a DDL operation is performed that affects the table. For example an application may create a temporary table to do some work on the table and then destroy it. It may later recreate the same table when it is needed again. Some databases will invalidate any prepared statements that reference the temporary table when the table is dropped.</source>
          <target state="translated">JDBC 3.0 사양 은 &lt;code&gt;PreparedStatements&lt;/code&gt; 풀링을 활성화 하고 문 풀의 크기를 지정 하기위한 표준 메커니즘을 제공하기 위해 maxStatements &lt;code&gt;ConnectionPooledDataSource&lt;/code&gt; 속성을 추가했습니다 . 그러나 &lt;code&gt;PreparedStatement&lt;/code&gt; 가 유효하지 않은 경우 드라이버가 외부 명령문 풀에 알릴 수있는 방법이 없습니다 . 일부 데이터베이스의 경우 테이블에 영향을주는 DDL 작업이 수행되면 문이 유효하지 않게됩니다. 예를 들어, 응용 프로그램은 임시 테이블을 생성하여 테이블에 대한 작업을 수행 한 다음이를 삭제할 수 있습니다. 나중에 다시 필요할 때 동일한 테이블을 다시 만들 수 있습니다. 일부 데이터베이스는 테이블이 삭제 될 때 임시 테이블을 참조하는 준비된 명령문을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="b75de8c2dc71b65df97e8ecbf3ef4bedd3196b45" translate="yes" xml:space="preserve">
          <source>The JDBC 4.0 API</source>
          <target state="translated">JDBC 4.0 API</target>
        </trans-unit>
        <trans-unit id="8537833ae96efc546ce1bf57458bf13e4e00612d" translate="yes" xml:space="preserve">
          <source>The JDBC 4.1 API</source>
          <target state="translated">JDBC 4.1 API</target>
        </trans-unit>
        <trans-unit id="2522ad222d6d4fff647d1822f3c053ef1b208ea1" translate="yes" xml:space="preserve">
          <source>The JDBC 4.2 API</source>
          <target state="translated">JDBC 4.2 API</target>
        </trans-unit>
        <trans-unit id="063101cb057d027845a508bc0a2d52d1e469963b" translate="yes" xml:space="preserve">
          <source>The JDBC 4.3 API incorporates all of the previous JDBC API versions:</source>
          <target state="translated">JDBC 4.3 API는 모든 이전 JDBC API 버전을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="908da5094f4f523619fcbfb6f3b042822f877a05" translate="yes" xml:space="preserve">
          <source>The JDBC API provides mechanisms for mapping an SQL structured type or DISTINCT type to the Java programming language. Typically, a structured type is mapped to a class, and its attributes are mapped to fields in the class. (A DISTINCT type can thought of as having one attribute.) However, there are many other possibilities, and there may be any number of different mappings.</source>
          <target state="translated">JDBC API는 SQL 구조화 유형 또는 DISTINCT 유형을 Java 프로그래밍 언어에 맵핑하기위한 메커니즘을 제공합니다. 일반적으로 구조화 된 유형은 클래스에 매핑되고 해당 속성은 클래스의 필드에 매핑됩니다. (DISTINCT 유형은 하나의 속성을 갖는 것으로 생각할 수 있습니다.) 그러나 다른 많은 가능성이 있으며 여러 다른 맵핑이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e67b3a9fa0b65d4e49f3b35324e61a95fab14b1" translate="yes" xml:space="preserve">
          <source>The JDBC API supports this SQL feature by providing the name of the SQL cursor used by a &lt;code&gt;ResultSet&lt;/code&gt; object. The current row of a &lt;code&gt;ResultSet&lt;/code&gt; object is also the current row of this SQL cursor.</source>
          <target state="translated">JDBC API는 &lt;code&gt;ResultSet&lt;/code&gt; 오브젝트가 사용하는 SQL 커서의 이름을 제공하여이 SQL 기능을 지원 합니다. a의 현재 행 &lt;code&gt;ResultSet&lt;/code&gt; 객체는이 SQL 커서의 현재의 행입니다.</target>
        </trans-unit>
        <trans-unit id="9d48b4e02a7ef8b217df6704fbc3fbef3055bb97" translate="yes" xml:space="preserve">
          <source>The JDBC driver initializes the input stream with a type map before calling this method, which is used by the appropriate &lt;code&gt;SQLInput&lt;/code&gt; reader method on the stream.</source>
          <target state="translated">JDBC 드라이버는이 메서드를 호출하기 전에 형식 맵을 사용하여 입력 스트림을 초기화합니다.이 메서드 는 스트림 의 적절한 &lt;code&gt;SQLInput&lt;/code&gt; 판독기 메서드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcf45bd369f2e97b6bb4e9ebc9b75d647e55ac9a" translate="yes" xml:space="preserve">
          <source>The JDBC driver's static initialization block must call &lt;a href=&quot;drivermanager#registerDriver(java.sql.Driver,java.sql.DriverAction)&quot;&gt;DriverManager.registerDriver(java.sql.Driver, java.sql.DriverAction)&lt;/a&gt; in order to inform &lt;code&gt;DriverManager&lt;/code&gt; which &lt;code&gt;DriverAction&lt;/code&gt; implementation to call when the JDBC driver is de-registered.</source>
          <target state="translated">JDBC 드라이버의 정적 초기화 블록을 호출해야 &lt;a href=&quot;drivermanager#registerDriver(java.sql.Driver,java.sql.DriverAction)&quot;&gt;DriverManager.registerDriver (java.sql.Driver, java.sql.DriverAction)를&lt;/a&gt; 알리기 위해 &lt;code&gt;DriverManager&lt;/code&gt; 를가 한다 &lt;code&gt;DriverAction&lt;/code&gt; JDBC 드라이버가 디 등록되면 호출 구현.</target>
        </trans-unit>
        <trans-unit id="90e93f4c83b64826e6a378f97cf636a358d28bb9" translate="yes" xml:space="preserve">
          <source>The JDBC specification defines a standard mapping from Java &lt;code&gt;Object&lt;/code&gt; types to SQL types. The driver will use this standard mapping to convert the given object to its corresponding SQL type before sending it to the database. If the object has a custom mapping (is of a class implementing &lt;code&gt;SQLData&lt;/code&gt;), the driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to the SQL data stream.</source>
          <target state="translated">JDBC 사양은 Java &lt;code&gt;Object&lt;/code&gt; 유형에서 SQL 유형으로 의 표준 매핑을 정의합니다 . 드라이버는이 표준 매핑을 사용하여 주어진 개체를 데이터베이스로 보내기 전에 해당 SQL 유형으로 변환합니다. 개체에 사용자 지정 매핑이있는 경우 ( &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스에 속함 ) 드라이버는 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드 를 호출 하여 개체를 SQL 데이터 스트림에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee974a8e55da2c721c226bef3a30b526c2729b4d" translate="yes" xml:space="preserve">
          <source>The JDBC specification provides a standard mapping from Java Object types to SQL types. The driver will convert the given Java object to its standard SQL mapping before sending it to the database.</source>
          <target state="translated">JDBC 사양은 Java 개체 유형에서 SQL 유형으로의 표준 매핑을 제공합니다. 드라이버는 주어진 Java 객체를 데이터베이스로 보내기 전에 표준 SQL 매핑으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3e9c491f1d268a5ac29eab9e5df11e173ed6c9d0" translate="yes" xml:space="preserve">
          <source>The JDBC specification specifies a standard mapping from Java &lt;code&gt;Object&lt;/code&gt; types to SQL types. The given argument will be converted to the corresponding SQL type before being sent to the database.</source>
          <target state="translated">JDBC 사양은 Java &lt;code&gt;Object&lt;/code&gt; 유형에서 SQL 유형으로 의 표준 매핑을 지정합니다 . 주어진 인수는 데이터베이스로 전송되기 전에 해당 SQL 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="523fd79ec39492a793ce5d43b1d416a59b37eb0f" translate="yes" xml:space="preserve">
          <source>The JDBC technology-enabled driver registers a type map with the stream before passing the stream to the application.</source>
          <target state="translated">JDBC 기술 사용 드라이버는 스트림을 애플리케이션에 전달하기 전에 스트림에 유형 맵을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="4f2501807ea5543e21ac42081e7607f5eda00852" translate="yes" xml:space="preserve">
          <source>The JDBC type specified by &lt;code&gt;sqlType&lt;/code&gt; for an OUT parameter determines the Java type that must be used in the &lt;code&gt;get&lt;/code&gt; method to read the value of that parameter.</source>
          <target state="translated">OUT 매개 변수에 대해 &lt;code&gt;sqlType&lt;/code&gt; 에 지정된 JDBC 유형 은 해당 매개 변수의 값을 읽기 &lt;code&gt;get&lt;/code&gt; 메소드 에서 사용해야하는 Java 유형을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="de789869d263780a3433be03e37625511f9f77e8" translate="yes" xml:space="preserve">
          <source>The JDBC&amp;trade; 4.3 API includes both the &lt;code&gt;java.sql&lt;/code&gt; package, referred to as the JDBC core API, and the &lt;code&gt;javax.sql&lt;/code&gt; package, referred to as the JDBC Optional Package API. This complete JDBC API is included in the Java&amp;trade; Standard Edition (Java SE&amp;trade;), version 7. The &lt;code&gt;javax.sql&lt;/code&gt; package extends the functionality of the JDBC API from a client-side API to a server-side API, and it is an essential part of the Java&amp;trade; Enterprise Edition (Java EE&amp;trade;) technology.</source>
          <target state="translated">JDBC &amp;trade; 4.3 API에는 JDBC 코어 API라고 하는 &lt;code&gt;java.sql&lt;/code&gt; 패키지와 JDBC 선택적 패키지 API라고 하는 &lt;code&gt;javax.sql&lt;/code&gt; 패키지 가 모두 포함되어 있습니다 . 이 완전한 JDBC API는 Java &amp;trade; Standard Edition (Java SE &amp;trade;) 버전 7에 포함되어 있습니다. &lt;code&gt;javax.sql&lt;/code&gt; 패키지는 JDBC API의 기능을 클라이언트 측 API에서 서버 측 API로 확장합니다. Java &amp;trade; Enterprise Edition (Java EE &amp;trade;) 기술의 필수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="f969a21212467360facf86185bc85dca1542c554" translate="yes" xml:space="preserve">
          <source>The JDK 1.0 event system is supported for backwards compatibility, but its use with newer versions of the platform is discouraged. The five types of adjustment events introduced with JDK 1.1 correspond to the five event types that are associated with scroll bars in previous platform versions. The following list gives the adjustment event type, and the corresponding JDK 1.0 event type it replaces.</source>
          <target state="translated">JDK 1.0 이벤트 시스템은 이전 버전과의 호환성을 위해 지원되지만 최신 버전의 플랫폼에서는 사용하지 않는 것이 좋습니다. JDK 1.1에 도입 된 5 가지 유형의 조정 이벤트는 이전 플랫폼 버전의 스크롤 막대와 관련된 5 가지 이벤트 유형에 해당합니다. 다음 목록은 조정 이벤트 유형 및 대체되는 해당 JDK 1.0 이벤트 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3d1c7a729b653acd1693d52a432bb13d5ba67a48" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffe26effc5f2dd90c2a6cedb9ce1386ed82b03d8" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ac4775b3e40e73761c25007bba30e40be920bc3" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62bf224ef20a8c8efd79de17ded7edf373246c8e" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45825bff39d02867764b21ee89aae790885bd0b7" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="803cbab520d0b89989ac7e30afebc082051ee02d" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cbcd88a86bafdf6f51dcf7a0cbbb0373e437354" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fc06d2c193c85c4e354c96804cda6886c8cc40b" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd56ba177b238763ab159cda3e93de4df961c47c" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2ff4634b7d2e0418683c1f5d82da119c746f73f" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="befa33c1b2a2cde739097412d1f98fd45c743c49" translate="yes" xml:space="preserve">
          <source>The JDK SunJSSE provider implementation default for this mode is false.</source>
          <target state="translated">이 모드의 JDK SunJSSE 공급자 구현 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="8bf12e035729ecbd5e8b0cb95471b6a6dd98ddbd" translate="yes" xml:space="preserve">
          <source>The JDK SunJSSE provider implementation returns false unless &lt;a href=&quot;#setUseClientMode(boolean)&quot;&gt;&lt;code&gt;setUseClientMode(boolean)&lt;/code&gt;&lt;/a&gt; is used to change the mode to true.</source>
          <target state="translated">JDK SunJSSE 공급자 구현은 &lt;a href=&quot;#setUseClientMode(boolean)&quot;&gt; &lt;code&gt;setUseClientMode(boolean)&lt;/code&gt; &lt;/a&gt; 를 사용하여 모드를 true로 변경 하지 않는 한 false를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="358eb35c3338a7ee46a21e172820d69f3e988176" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module includes a language-independent command-line script shell, &lt;em&gt;&lt;a id=&quot;jrunscript&quot;&gt;jrunscript&lt;/a&gt;&lt;/em&gt;, that supports executing JavaScript and other languages if its corresponding script engine is installed.</source>
          <target state="translated">이 모듈의 JDK 구현에는 해당 스크립트 엔진이 설치된 경우 JavaScript 및 기타 언어 실행을 지원 하는 언어 독립적 명령 줄 스크립트 셸 &lt;em&gt;&lt;a id=&quot;jrunscript&quot;&gt;jrunscript&lt;/a&gt;&lt;/em&gt; 가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ca8ec67b178a4223fa65b7e67f9198c2b19d7c3c" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module includes the &lt;em&gt;&lt;a id=&quot;rmiregistry&quot;&gt;rmiregistry&lt;/a&gt;&lt;/em&gt; tool to start a remote object registry, and the &lt;em&gt;&lt;a id=&quot;rmid&quot;&gt;rmid&lt;/a&gt;&lt;/em&gt; tool to start the activation system daemon.</source>
          <target state="translated">이 모듈의 JDK 구현에는 원격 개체 레지스트리를 시작하는 &lt;em&gt;&lt;a id=&quot;rmiregistry&quot;&gt;rmiregistry&lt;/a&gt;&lt;/em&gt; 도구와 활성화 시스템 데몬을 시작하는 &lt;em&gt;&lt;a id=&quot;rmid&quot;&gt;rmid&lt;/a&gt;&lt;/em&gt; 도구가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a40a63ec61f8f60c0c587e2bbb0619e0bd28d621" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module provides an implementation of the &lt;a id=&quot;jrt&quot;&gt;jrt&lt;/a&gt;&lt;a href=&quot;java/nio/file/spi/filesystemprovider&quot;&gt;file system provider&lt;/a&gt; to enumerate and read the class and resource files in a run-time image. The jrt file system can be created by calling &lt;a href=&quot;java/nio/file/filesystems#newFileSystem(java.net.URI,java.util.Map)&quot;&gt;&lt;code&gt;FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 JDK 구현은 런타임 이미지에서 클래스 및 리소스 파일을 열거하고 읽는 &lt;a id=&quot;jrt&quot;&gt;jrt &lt;/a&gt;&lt;a href=&quot;java/nio/file/spi/filesystemprovider&quot;&gt;파일 시스템 공급자&lt;/a&gt; 의 구현을 제공합니다 . jrt 파일 시스템은 &lt;a href=&quot;java/nio/file/filesystems#newFileSystem(java.net.URI,java.util.Map)&quot;&gt; &lt;code&gt;FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;))&lt;/code&gt; &lt;/a&gt; 을 호출하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff828cede05c6d73aace767cbbd1fa03e209c5c1" translate="yes" xml:space="preserve">
          <source>The JDK implementation returns the cache size as set by the &lt;code&gt;setSessionCacheSize&lt;/code&gt; method, or if not set, the value of the system property. If neither is set, it returns a default value of 20480.</source>
          <target state="translated">JDK 구현은 &lt;code&gt;setSessionCacheSize&lt;/code&gt; 메서드에 의해 설정된 캐시 크기 또는 설정되지 않은 경우 시스템 속성 값을 반환합니다. 둘 다 설정되지 않은 경우 기본값 20480을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63abf37567a69daeb1c9eb0eac9845726723f07a" translate="yes" xml:space="preserve">
          <source>The JDK implementation returns the session timeout as set by the &lt;code&gt;setSessionTimeout&lt;/code&gt; method, or if not set, a default value of 86400 seconds (24 hours).</source>
          <target state="translated">JDK 구현은 &lt;code&gt;setSessionTimeout&lt;/code&gt; 메소드에 의해 설정된대로 세션 제한 시간을 리턴 하거나 설정되지 않은 경우 기본값 인 86400 초 (24 시간)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1e8321947a5392937c7a6036d74e85eb794e0aeb" translate="yes" xml:space="preserve">
          <source>The JDK implementation supports static registration of the security providers via the &lt;code&gt;conf/security/java.security&lt;/code&gt; file in the Java installation directory. These providers are automatically installed by the JDK runtime, see &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jca_provider&quot;&gt;The Provider Class&lt;/a&gt; in the Java Cryptography Architecture (JCA) Reference Guide for information about how a particular type of provider, the cryptographic service provider, works and is installed.</source>
          <target state="translated">JDK 구현은 Java 설치 디렉토리 의 &lt;code&gt;conf/security/java.security&lt;/code&gt; 파일을 통해 보안 공급자의 정적 등록을 지원합니다 . 이러한 공급자는 JDK 런타임에 의해 자동으로 설치됩니다. 특정 유형의 공급자 인 암호화 서비스 공급자가 작동하고 설치되는 방법에 대한 자세한 내용은 JCA (Java Cryptography Architecture) 참조 가이드 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jca_provider&quot;&gt;의 공급자 클래스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7977a89a83ddfc3d655c3423c1d5cef0ff1b4d9d" translate="yes" xml:space="preserve">
          <source>The JDK includes &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations that can locate the standard platform printers. To locate other types of printers, such as IPP printers or JINI printers, a print-service provider can write implementations of &lt;code&gt;PrintServiceLookup&lt;/code&gt;. The print-service provider can dynamically install these &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations using the  SPI JAR file specification.</source>
          <target state="translated">JDK에는 표준 플랫폼 프린터를 찾을 수있는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현이 포함되어 있습니다. IPP 프린터 또는 JINI 프린터와 같은 다른 유형의 프린터를 찾기 위해 인쇄 서비스 제공 업체는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 작성할 수 있습니다 . 인쇄 서비스 제공자는 SPI JAR 파일 스펙을 사용하여 이러한 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 동적으로 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95544c4457ec318de1023345ff557bed46437913" translate="yes" xml:space="preserve">
          <source>The JDK includes &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations that can locate the standard platform printers. To locate other types of printers, such as IPP printers or JINI printers, a print-service provider can write implementations of &lt;code&gt;PrintServiceLookup&lt;/code&gt;. The print-service provider can dynamically install these &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations using the &lt;a href=&quot;../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; facility.</source>
          <target state="translated">JDK에는 표준 플랫폼 프린터를 찾을 수있는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현이 포함되어 있습니다. IPP 프린터 또는 JINI 프린터와 같은 다른 유형의 프린터를 찾기 위해 인쇄 서비스 제공 업체는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 작성할 수 있습니다 . 인쇄 서비스 공급자는 &lt;a href=&quot;../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 이러한 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 동적으로 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c17c58306c6fb36155552fb80a036d49556c883b" translate="yes" xml:space="preserve">
          <source>The JDK(tm) 1.1 rendering model is based on a pixelization model that specifies that coordinates are infinitely thin, lying between the pixels. Drawing operations are performed using a one-pixel wide pen that fills the pixel below and to the right of the anchor point on the path. The JDK 1.1 rendering model is consistent with the capabilities of most of the existing class of platform renderers that need to resolve integer coordinates to a discrete pen that must fall completely on a specified number of pixels.</source>
          <target state="translated">JDK (tm) 1.1 렌더링 모델은 좌표가 무한히 얇고 픽셀 사이에 위치하도록 지정하는 픽셀 화 모델을 기반으로합니다. 그리기 작업은 경로의 앵커 포인트 아래 및 오른쪽에있는 픽셀을 채우는 1 픽셀 너비의 펜을 사용하여 수행됩니다. JDK 1.1 렌더링 모델은 정수 좌표를 지정된 픽셀 수에 완전히 포함되어야하는 개별 펜으로 해석해야하는 기존 클래스의 플랫폼 렌더러 대부분의 기능과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b4df1f98a0565fca9a29ad6073a1bc23033b2822" translate="yes" xml:space="preserve">
          <source>The JList used for representing the files is created by subclasses, but the selection is monitored in this class.</source>
          <target state="translated">파일을 나타내는 데 사용되는 JList는 서브 클래스에 의해 생성되지만 선택은이 클래스에서 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="7224bc9a099b77a16bc3be0479f9b05ff7eb1a25" translate="yes" xml:space="preserve">
          <source>The JList used for representing the files is created by subclasses, but the selection is monitored in this class. The TransferHandler installed in the JFileChooser is also installed in the file list as it is used as the actual transfer source. The list is updated on a mouse enter to reflect the current data transfer state of the file chooser.</source>
          <target state="translated">파일을 나타내는 데 사용되는 JList는 서브 클래스에 의해 생성되지만 선택은이 클래스에서 모니터링됩니다. JFileChooser에 설치된 TransferHandler는 실제 전송 소스로 사용되기 때문에 파일 목록에도 설치됩니다. 마우스 입력시 목록이 업데이트되어 파일 선택기의 현재 데이터 전송 상태를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="adacbc5dc9ca937440df58f189dfa0a26e578715" translate="yes" xml:space="preserve">
          <source>The JMM specifically allows optimizing compilers to elide reads or writes of variables that are known to be useless. Such elided reads and writes have no effect on the happens-before relation. Regardless of this fact, the volatile &lt;code&gt;V&lt;/code&gt; will not be elided, even though its written value is indeterminate and its read value is not used.</source>
          <target state="translated">JMM을 사용하면 최적화 컴파일러가 쓸모없는 것으로 알려진 변수의 읽기 또는 쓰기를 생략 할 수 있습니다. 이러한 생략 된 읽기 및 쓰기는 이전에 발생한 관계에 영향을 미치지 않습니다. 이러한 사실에 관계없이, 휘발성 &lt;code&gt;V&lt;/code&gt; 는 기록 된 값이 불확실하고 판독 값이 사용되지 않더라도 제거되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="245a29e6968c20703520c2a92906f5e9e0f071ea" translate="yes" xml:space="preserve">
          <source>The JMX API can also be used as part of a solution for managing systems, networks, and so on.</source>
          <target state="translated">JMX API는 시스템, 네트워크 등을 관리하기위한 솔루션의 일부로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcfd357aa0013a97754ba965d15a09dda3cf149c" translate="yes" xml:space="preserve">
          <source>The JMX API consists of interfaces for monitoring and management of the JVM and other components in the Java runtime.</source>
          <target state="translated">JMX API는 Java 런타임의 JVM 및 기타 구성 요소를 모니터링하고 관리하기위한 인터페이스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="44195781584f2d466ba7e2c1a615da361d712792" translate="yes" xml:space="preserve">
          <source>The JMX Remote API also defines an optional connector called &lt;b&gt;JMXMP Connector&lt;/b&gt; implementing the JMX Message Protocol (JMXMP). As it is optional, it is not part of this bundle (see note below).</source>
          <target state="translated">JMX 원격 API는 &lt;b&gt;JMXMP&lt;/b&gt; (JMX Message Protocol)를 구현하는 &lt;b&gt;JMXMP&lt;/b&gt; 커넥터라는 선택적 커넥터도 정의합니다 . 선택 사항이므로이 번들의 일부가 아닙니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="49ce3ebe998d499efd4c77a77394ab17b1f03636" translate="yes" xml:space="preserve">
          <source>The JMX Remote API defines a standard connector, the &lt;b&gt;RMI Connector&lt;/b&gt;, which provides remote access to an MBeanServer through RMI.</source>
          <target state="translated">JMX Remote API는 &lt;b&gt;RMI&lt;/b&gt; 를 통해 MBeanServer에 대한 원격 액세스를 제공 하는 표준 커넥터 &lt;b&gt;RMI Connector를&lt;/b&gt; 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fd57cf73dfe60c2aa55ec8129a23ade5a302d5fa" translate="yes" xml:space="preserve">
          <source>The JMX specification also defines the notion of an &lt;em&gt;adaptor&lt;/em&gt;. An adaptor translates between requests in a protocol such as SNMP or HTML and accesses to an MBean Server. So for example an SNMP GET operation might result in a &lt;code&gt;getAttribute&lt;/code&gt; on the MBean Server.</source>
          <target state="translated">JMX 사양은 또한 &lt;em&gt;어댑터&lt;/em&gt; 의 개념을 정의합니다 . 어댑터는 SNMP 또는 HTML과 같은 프로토콜의 요청 간을 변환하고 MBean 서버에 액세스합니다. 예를 들어 SNMP GET 조작 으로 인해 MBean 서버 에서 &lt;code&gt;getAttribute&lt;/code&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad7600c1b4c4869f0bb7b9d742500b17e728fe9b" translate="yes" xml:space="preserve">
          <source>The JMX specification defines the notion of &lt;b&gt;connectors&lt;/b&gt;. A connector is attached to a JMX API MBean server and makes it accessible to remote Java clients. The client end of a connector exports essentially the same interface as the MBean server, specifically the &lt;a href=&quot;../mbeanserverconnection&quot;&gt;&lt;code&gt;MBeanServerConnection&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">JMX 사양은 &lt;b&gt;커넥터&lt;/b&gt; 의 개념을 정의합니다 . 커넥터는 JMX API MBean 서버에 접속되어 원격 Java 클라이언트가 액세스 할 수있게합니다. 커넥터의 클라이언트 쪽은 기본적으로 MBean 서버와 동일한 인터페이스, 특히 &lt;a href=&quot;../mbeanserverconnection&quot;&gt; &lt;code&gt;MBeanServerConnection&lt;/code&gt; &lt;/a&gt; 인터페이스를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="96af366dabe06f77839ee8dbe7885151d35d2d4b" translate="yes" xml:space="preserve">
          <source>The JNDI SPI provides the means for creating JNDI service providers, through which JNDI applications access different naming and directory services.</source>
          <target state="translated">JNDI SPI는 JNDI 응용 프로그램이 다른 이름 지정 및 디렉토리 서비스에 액세스하는 JNDI 서비스 공급자를 만드는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33732f94d8d93f615200108becd1fb08f06a0bea" translate="yes" xml:space="preserve">
          <source>The JNDI class library reads the resource files and makes the property values freely available. Thus JNDI resource files should be considered to be &quot;world readable&quot;, and sensitive information such as clear-text passwords should not be stored there.</source>
          <target state="translated">JNDI 클래스 라이브러리는 자원 파일을 읽고 특성 값을 자유롭게 사용할 수있게합니다. 따라서 JNDI 자원 파일은 &quot;세계가 읽을 수있는&quot;것으로 간주되어야하며 일반 텍스트 비밀번호와 같은 민감한 정보는 저장되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="088d7c9d898f7a840b1256be8ddef986f15194cb" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for different initial context implementations to be specified at runtime. An initial context is created using an initial context factory. A program can install its own builder that creates initial context factories, thereby overriding the default policies used by the framework, by calling NamingManager.setInitialContextFactoryBuilder(). The InitialContextFactoryBuilder interface must be implemented by such a builder.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 런타임시 서로 다른 초기 컨텍스트 구현을 지정할 수 있습니다. 초기 컨텍스트 팩토리를 사용하여 초기 컨텍스트가 작성됩니다. 프로그램은 초기 컨텍스트 팩토리를 작성하는 자체 빌더를 설치하여 NamingManager.setInitialContextFactoryBuilder ()를 호출하여 프레임 워크에서 사용하는 기본 정책을 대체합니다. InitialContextFactoryBuilder 인터페이스는 이러한 빌더로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="d098149f3977423197730ce483608b5d9c5ba323" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for different initial context implementations to be specified at runtime. The initial context is created using an &lt;em&gt;initial context factory&lt;/em&gt;. An initial context factory must implement the InitialContextFactory interface, which provides a method for creating instances of initial context that implement the Context interface. In addition, the factory class must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 런타임시 서로 다른 초기 컨텍스트 구현을 지정할 수 있습니다. 초기 컨텍스트는 &lt;em&gt;초기 컨텍스트 팩토리를&lt;/em&gt; 사용하여 작성됩니다 . 초기 컨텍스트 팩토리는 Context 인터페이스를 구현하는 초기 컨텍스트 인스턴스를 작성하는 메소드를 제공하는 InitialContextFactory 인터페이스를 구현해야합니다. 또한 팩토리 클래스는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b9064bba67a68203f58a597fa1fa3afbedec89f6" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;code&gt;object factories&lt;/code&gt;.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;code&gt;object factories&lt;/code&gt; 를 통해 객체 구현을 동적으로로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="134c5f63e690609e9c6a657638ccd21e3550dca4" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to &lt;code&gt;Reference&lt;/code&gt;s, the printer &lt;code&gt;Reference&lt;/code&gt; could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 예를 들어, 네임 스페이스에 바인딩 된 프린터를 &lt;code&gt;Reference&lt;/code&gt; 할 때 인쇄 서비스가 프린터 이름을 Reference에 바인딩 하면 프린터 &lt;code&gt;Reference&lt;/code&gt; 를 사용하여 프린터 개체를 만들 수 있으므로 조회 호출자가 프린터 개체에서 직접 작동 할 수 있습니다 조회 후.</target>
        </trans-unit>
        <trans-unit id="f3b7acec5238c7d2dd7fa0082fb8db71d5d2e9ed" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 예를 들어, 네임 스페이스에 바인딩 된 프린터를 조회 할 때 인쇄 서비스가 프린터 이름을 참조에 바인딩하는 경우 프린터 참조를 사용하여 프린터 개체를 생성 할 수 있으므로 프린터 호출자가 프린터 개체에서 직접 작업 할 수 있습니다. 조회.</target>
        </trans-unit>
        <trans-unit id="0f159102714c8eb7af6cff7ee4872dd30ee0cf55" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup. An ObjectFactory is responsible for creating objects of a specific type. JNDI uses a default policy for using and loading object factories. You can override this default policy by calling &lt;code&gt;NamingManager.setObjectFactoryBuilder()&lt;/code&gt; with an ObjectFactoryBuilder, which contains the program-defined way of creating/loading object factories. Any &lt;code&gt;ObjectFactoryBuilder&lt;/code&gt; implementation must implement this interface that for creating object factories.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 예를 들어, 네임 스페이스에 바인딩 된 프린터를 조회 할 때 인쇄 서비스가 프린터 이름을 참조에 바인딩하는 경우 프린터 참조를 사용하여 프린터 개체를 생성 할 수 있으므로 프린터 호출자가 프린터 개체에서 직접 작업 할 수 있습니다. 조회. ObjectFactory는 특정 유형의 객체를 생성합니다. JNDI는 객체 팩토리 사용 및로드에 기본 정책을 사용합니다. ObjectFactoryBuilder와 함께 &lt;code&gt;NamingManager.setObjectFactoryBuilder()&lt;/code&gt; 를 호출하여이 기본 정책을 재정의 할 수 있습니다 . ObjectFactoryBuilder에는 오브젝트 팩토리를 작성 /로드하는 프로그램 정의 방법이 포함되어 있습니다. 모든 &lt;code&gt;ObjectFactoryBuilder&lt;/code&gt; 구현은 객체 팩토리를 작성하기위한이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="88db5d84ce039b71278336e8b1b44b578aa0d61d" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. See &lt;code&gt;ObjectFactory&lt;/code&gt; for details.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 자세한 내용은 &lt;code&gt;ObjectFactory&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5669f05609b02ee4c44fdaa5adbcabc508864f50" translate="yes" xml:space="preserve">
          <source>The JNDI library will consult the provider resource file when determining the values of these properties. Properties other than these may be set in the provider resource file at the discretion of the service provider. The service provider's documentation should clearly state which properties are allowed; other properties in the file will be ignored.</source>
          <target state="translated">JNDI 라이브러리는 이러한 특성 값을 결정할 때 제공자 자원 파일을 참조합니다. 이들 이외의 속성은 서비스 공급자의 판단에 따라 공급자 리소스 파일에 설정 될 수 있습니다. 서비스 제공 업체의 문서에는 어떤 속성이 허용되는지 명시해야합니다. 파일의 다른 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bec69931581644a1ef0084216dc02cc47be425fa" translate="yes" xml:space="preserve">
          <source>The JNDI name of the resource. For field annotations, the default is the field name. For method annotations, the default is the JavaBeans property name corresponding to the method. For class annotations, there is no default and this must be specified.</source>
          <target state="translated">자원의 JNDI 이름 필드 주석의 경우 기본값은 필드 이름입니다. 메소드 어노테이션의 경우 기본값은 메소드에 해당하는 JavaBeans 특성 이름입니다. 클래스 주석의 경우 기본값이 없으므로이를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="edc24d0f37d47900732cfdcdc56bc8ec2f6044ca" translate="yes" xml:space="preserve">
          <source>The JPS API is designed to be used in Java profiles which do not support AWT.</source>
          <target state="translated">JPS API는 AWT를 지원하지 않는 Java 프로파일에서 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="363b84f0385d00914c1240423dd0f5bb6b4ee6f6" translate="yes" xml:space="preserve">
          <source>The JRE data transfer implementation interprets the parameter &quot;class&quot; of a MIME type as &lt;b&gt;a representation class&lt;/b&gt;. The representation class reflects the class of the object being transferred. In other words, the representation class is the type of object returned by &lt;a href=&quot;transferable#getTransferData(java.awt.datatransfer.DataFlavor)&quot;&gt;&lt;code&gt;Transferable.getTransferData(java.awt.datatransfer.DataFlavor)&lt;/code&gt;&lt;/a&gt;. For example, the MIME type of &lt;a href=&quot;#imageFlavor&quot;&gt;&lt;code&gt;imageFlavor&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;image/x-java-image;class=java.awt.Image&quot;&lt;/code&gt;, the primary type is &lt;code&gt;image&lt;/code&gt;, the subtype is &lt;code&gt;x-java-image&lt;/code&gt;, and the representation class is &lt;code&gt;java.awt.Image&lt;/code&gt;. When &lt;code&gt;getTransferData&lt;/code&gt; is invoked with a &lt;code&gt;DataFlavor&lt;/code&gt; of &lt;code&gt;imageFlavor&lt;/code&gt;, an instance of &lt;code&gt;java.awt.Image&lt;/code&gt; is returned. It's important to note that &lt;code&gt;DataFlavor&lt;/code&gt; does no error checking against the representation class. It is up to consumers of &lt;code&gt;DataFlavor&lt;/code&gt;, such as &lt;code&gt;Transferable&lt;/code&gt;, to honor the representation class.</source>
          <target state="translated">JRE 데이터 전송 구현은 MIME 유형의 &quot;클래스&quot;매개 변수를 &lt;b&gt;표현 클래스&lt;/b&gt; 로 해석합니다 . 표현 클래스는 전송되는 객체의 클래스를 반영합니다. 즉, 표현 클래스는 &lt;a href=&quot;transferable#getTransferData(java.awt.datatransfer.DataFlavor)&quot;&gt; &lt;code&gt;Transferable.getTransferData(java.awt.datatransfer.DataFlavor)&lt;/code&gt; &lt;/a&gt; 의해 반환 된 객체의 유형입니다 . 예를 들어, &lt;a href=&quot;#imageFlavor&quot;&gt; &lt;code&gt;imageFlavor&lt;/code&gt; &lt;/a&gt; 의 MIME 유형 은 &lt;code&gt;&quot;image/x-java-image;class=java.awt.Image&quot;&lt;/code&gt; , 기본 유형은 &lt;code&gt;image&lt;/code&gt; , 하위 유형은 &lt;code&gt;x-java-image&lt;/code&gt; , 표현 클래스는 &lt;code&gt;java.awt.Image&lt;/code&gt; . 시 &lt;code&gt;getTransferData&lt;/code&gt; 를 호출 &lt;code&gt;DataFlavor&lt;/code&gt; 의 &lt;code&gt;imageFlavor&lt;/code&gt; , &lt;code&gt;java.awt.Image&lt;/code&gt; 의 인스턴스 가 리턴됩니다. &lt;code&gt;DataFlavor&lt;/code&gt; 는 표현 클래스에 대해 오류 검사를하지 않는다는 점에 유의하는 것이 중요합니다 . 표현 클래스를 존중하는 것은 &lt;code&gt;Transferable&lt;/code&gt; 과 같은 &lt;code&gt;DataFlavor&lt;/code&gt; 소비자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="17a160f7d45e8174e9c03f104bfe115657a97de9" translate="yes" xml:space="preserve">
          <source>The JScrollPane component creates scrollbars (by default) that override this method and delegate to the viewports Scrollable view, if it has one. The Scrollable interface provides a more specialized version of this method.</source>
          <target state="translated">JScrollPane 구성 요소는이 메서드를 재정의하는 스크롤바 (기본적으로)를 생성하고 스크롤 가능 뷰가있는 경우 뷰포트 스크롤 가능 뷰에 위임합니다. Scrollable 인터페이스는이 메서드의보다 전문화 된 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8578472fe170c11efcaca36252367b026245c2be" translate="yes" xml:space="preserve">
          <source>The JVM bytecode format supports immediate constants of the classes &lt;a href=&quot;methodhandle&quot;&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methodtype&quot;&gt;&lt;code&gt;MethodType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JVM 바이트 코드 형식은 &lt;a href=&quot;methodhandle&quot;&gt; &lt;code&gt;MethodHandle&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;methodtype&quot;&gt; &lt;code&gt;MethodType&lt;/code&gt; &lt;/a&gt; 클래스의 즉시 상수를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="423700bf3f40eb8f7ae2196876409f2568dcd9ca" translate="yes" xml:space="preserve">
          <source>The JVM imposes a similar requirement on &lt;code&gt;invokespecial&lt;/code&gt; instruction, that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt; the current class. Again, this requirement is enforced by narrowing the type of the leading parameter to the resulting method handle. (See the Java Virtual Machine Specification, section 4.10.1.9.)</source>
          <target state="translated">JVM은 &lt;code&gt;invokespecial&lt;/code&gt; 명령 에 대해 비슷한 요구 사항을 적용 합니다. 수신자 인수는 해결 된 메소드 &lt;em&gt;와&lt;/em&gt; 현재 클래스 모두와 일치해야합니다 . 이 요구 사항은 선행 매개 변수의 유형을 결과 메소드 핸들로 좁혀서 적용됩니다. (Java 가상 머신 사양, 섹션 4.10.1.9 참조)</target>
        </trans-unit>
        <trans-unit id="f6a937822298d3770df670d2d33f12a835018bdf" translate="yes" xml:space="preserve">
          <source>The JVM imposes on all methods and constructors of any kind an absolute limit of 255 stacked arguments. This limit can appear more restrictive in certain cases:</source>
          <target state="translated">JVM은 모든 메소드 및 생성자에 255 개의 누적 인수의 절대 한계를 부과합니다. 이 제한은 특정 경우 더 제한적으로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc6a5c598e3c5bccd4ab59217eeb5725b65103d3" translate="yes" xml:space="preserve">
          <source>The JVM represents constructors and static initializer blocks as internal methods with special names (&lt;code&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;lt;clinit&amp;gt;&quot;&lt;/code&gt;). The internal syntax of invocation instructions allows them to refer to such internal methods as if they were normal methods, but the JVM bytecode verifier rejects them. A lookup of such an internal method will produce a &lt;code&gt;NoSuchMethodException&lt;/code&gt;.</source>
          <target state="translated">JVM은 생성자와 정적 이니셜 라이저 블록을 특수 이름 ( &lt;code&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;&amp;lt;clinit&amp;gt;&quot;&lt;/code&gt; )의 내부 메소드로 나타냅니다 . 호출 명령의 내부 구문을 사용하면 마치 내부 메소드가 일반 메소드 인 것처럼 내부 메소드를 참조 할 수 있지만 JVM 바이트 코드 검증기는이를 거부합니다. 이러한 내부 메소드를 검색하면 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4bed2dbd7bc1a0a64894245adfbe5487e3761dab" translate="yes" xml:space="preserve">
          <source>The Japanese Imperial calendar system is the same as the ISO calendar system apart from the era-based year numbering. The proleptic-year is defined to be equal to the ISO proleptic-year.</source>
          <target state="translated">일본 제국 달력 시스템은 시대 별 연도 번호를 제외하고 ISO 달력 시스템과 동일합니다. proleptic-year는 ISO proleptic-year와 같은 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1377cea6a56d5ed563cbb1106ccb49deee8306eb" translate="yes" xml:space="preserve">
          <source>The Japanese Imperial calendar system.</source>
          <target state="translated">일본 황실 달력 시스템.</target>
        </trans-unit>
        <trans-unit id="7564ca9cd9ffac61a50b36479cc4d2f52a3b5c1f" translate="yes" xml:space="preserve">
          <source>The Japanese calendar system has multiple eras defined by &lt;a href=&quot;japaneseera&quot;&gt;&lt;code&gt;JapaneseEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일본어 달력 시스템에는 &lt;a href=&quot;japaneseera&quot;&gt; &lt;code&gt;JapaneseEra&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 여러 시대가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04fc513b47cf3ef30849ce129084aceb11af3867" translate="yes" xml:space="preserve">
          <source>The Japanese government defines the official name and start date of each era. Eras are consecutive and their date ranges do not overlap, so the end date of one era is always the day before the start date of the next era.</source>
          <target state="translated">일본 정부는 각 시대의 공식 명칭과 시작일을 정의합니다. Eras는 연속적이며 날짜 범위가 겹치지 않으므로 한 시대의 종료 날짜는 항상 다음 시대의 시작 날짜 전날입니다.</target>
        </trans-unit>
        <trans-unit id="265e051cf5be43bb91edb907b6aaa5aa90a2b761" translate="yes" xml:space="preserve">
          <source>The Japanese month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes. For example:</source>
          <target state="translated">일본어 월 및 월은 ISO 캘린더 시스템과 동일합니다. 시대가 바뀌더라도 재설정되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a132e736768e81687dffdd4d971dcc6de9796ad" translate="yes" xml:space="preserve">
          <source>The Japanese proleptic year, month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes.</source>
          <target state="translated">일본의 proleptic 연도, 월, 일은 ISO 캘린더 시스템과 동일합니다. 시대가 바뀌더라도 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab077295795f59b02a71b197389bd1772b628d47" translate="yes" xml:space="preserve">
          <source>The Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers. A pen with a width of one pixel does not need to fall completely on pixel N as opposed to pixel N+1. The pen can fall partially on both pixels. It is not necessary to choose a bias direction for a wide pen since the blending that occurs along the pen traversal edges makes the sub-pixel position of the pen visible to the user. On the other hand, when antialiasing is turned off by setting the &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt;&lt;code&gt;KEY_ANTIALIASING&lt;/code&gt;&lt;/a&gt; hint key to the &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_OFF&quot;&gt;&lt;code&gt;VALUE_ANTIALIAS_OFF&lt;/code&gt;&lt;/a&gt; hint value, the renderer might need to apply a bias to determine which pixel to modify when the pen is straddling a pixel boundary, such as when it is drawn along an integer coordinate in device space. While the capabilities of an antialiasing renderer make it no longer necessary for the rendering model to specify a bias for the pen, it is desirable for the antialiasing and non-antialiasing renderers to perform similarly for the common cases of drawing one-pixel wide horizontal and vertical lines on the screen. To ensure that turning on antialiasing by setting the &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt;&lt;code&gt;KEY_ANTIALIASING&lt;/code&gt;&lt;/a&gt; hint key to &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_ON&quot;&gt;&lt;code&gt;VALUE_ANTIALIAS_ON&lt;/code&gt;&lt;/a&gt; does not cause such lines to suddenly become twice as wide and half as opaque, it is desirable to have the model specify a path for such lines so that they completely cover a particular set of pixels to help increase their crispness.</source>
          <target state="translated">Java 2D (tm) (Java (tm) 2 플랫폼) API는 앤티 앨리어싱 렌더러를 지원합니다. 너비가 1 픽셀 인 펜은 픽셀 N + 1과 달리 픽셀 N에 완전히 떨어질 필요가 없습니다. 펜이 두 픽셀에서 부분적으로 떨어질 수 있습니다. 펜 횡단 가장자리를 따라 발생하는 블렌딩으로 인해 펜의 하위 픽셀 위치가 사용자에게 표시되므로 넓은 펜에 대해 바이어스 방향을 선택할 필요가 없습니다. 반면에 &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt; &lt;code&gt;KEY_ANTIALIASING&lt;/code&gt; &lt;/a&gt; 힌트 키를 &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_OFF&quot;&gt; &lt;code&gt;VALUE_ANTIALIAS_OFF&lt;/code&gt; &lt;/a&gt; 로 설정하여 앤티 앨리어싱을 끄면힌트 값의 경우, 렌더러는 장치 공간에서 정수 좌표를 따라 그려지는 경우와 같이 펜이 픽셀 경계에 걸쳐있을 때 수정할 픽셀을 결정하기 위해 바이어스를 적용해야 할 수 있습니다. 앤티 앨리어싱 렌더러의 기능으로 인해 렌더링 모델에서 더 이상 펜에 대한 바이어스를 지정할 필요가 없지만, 앤티 앨리어싱 및 비 앤티 앨리어싱 렌더러는 일반적인 경우 1 픽셀 너비의 수평 및 화면에 수직선. &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt; &lt;code&gt;KEY_ANTIALIASING&lt;/code&gt; &lt;/a&gt; 힌트 키를 &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_ON&quot;&gt; &lt;code&gt;VALUE_ANTIALIAS_ON&lt;/code&gt; &lt;/a&gt; 으로 설정하여 앤티 앨리어싱을 켜려면 이러한 선이 갑자기 폭의 두 배와 불투명하게 절반이되지 않도록 모델이 해당 선의 경로를 지정하여 선명도를 높이기 위해 특정 픽셀 집합을 완전히 덮도록하는 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="0fbc55fe3353d168165d01c77ce52a7169349fae" translate="yes" xml:space="preserve">
          <source>The Java AWT Native Interface (JAWT)</source>
          <target state="translated">자바 AWT 네이티브 인터페이스 (JAWT)</target>
        </trans-unit>
        <trans-unit id="3db037c857875b9fa1012171be8083c44281dea6" translate="yes" xml:space="preserve">
          <source>The Java Accessibility API package consists of 8 Java programming language interfaces, and 6 Java programming language classes. These are described below.</source>
          <target state="translated">Java Accessibility API 패키지는 8 개의 Java 프로그래밍 언어 인터페이스와 6 개의 Java 프로그래밍 언어 클래스로 구성됩니다. 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7cd6bf18e5d512749050266dad5e8ad183ff281" translate="yes" xml:space="preserve">
          <source>The Java Development Kit (JDK) APIs are specific to the JDK and will not necessarily be available in all implementations of the Java SE Platform. These APIs are in modules whose names start with &lt;code&gt;jdk&lt;/code&gt;.</source>
          <target state="translated">JDK (Java Development Kit) API는 JDK에 고유하며 Java SE 플랫폼의 모든 구현에서 반드시 사용할 수있는 것은 아닙니다. 이러한 API는 이름이 &lt;code&gt;jdk&lt;/code&gt; 로 시작하는 모듈에 있습니다.</target>
        </trans-unit>
        <trans-unit id="61602e7596e12b632597fd4f988db4b318fd0d87" translate="yes" xml:space="preserve">
          <source>The Java Language Specification</source>
          <target state="translated">자바 언어 사양</target>
        </trans-unit>
        <trans-unit id="bbe92060513e13f1787c56819355245bef3c94ab" translate="yes" xml:space="preserve">
          <source>The Java Look and Feel, otherwise known as Metal.</source>
          <target state="translated">Metal이라고도하는 Java Look and Feel.</target>
        </trans-unit>
        <trans-unit id="05622f717f9f313a62126060521423008c4d1058" translate="yes" xml:space="preserve">
          <source>The Java Management Extensions (JMX&amp;trade;) API is a standard API for management and monitoring. Typical uses include:</source>
          <target state="translated">JMX &amp;trade; (Java Management Extensions) API는 관리 및 모니터링을위한 표준 API입니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37d13fecff6728378da832d10b9051c944390c97" translate="yes" xml:space="preserve">
          <source>The Java Management Extensions (JMX&lt;sup&gt;TM&lt;/sup&gt;) API is a standard API for management and monitoring. Typical uses include:</source>
          <target state="translated">Java Management Extensions (JMX &lt;sup&gt;TM)&lt;/sup&gt; ) API는 관리 및 모니터링을위한 표준 API입니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d78753332522c3ae6721300363a5c6096e665327" translate="yes" xml:space="preserve">
          <source>The Java Platform distinguishes between two kinds of fonts: &lt;em&gt;physical&lt;/em&gt; fonts and &lt;em&gt;logical&lt;/em&gt; fonts.</source>
          <target state="translated">Java 플랫폼은 &lt;em&gt;물리적&lt;/em&gt; 글꼴과 &lt;em&gt;논리적&lt;/em&gt; 글꼴 의 두 가지 글꼴을 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="8bef35235f701eb6de58ba31cfe59d2bb33aa8ff" translate="yes" xml:space="preserve">
          <source>The Java Platform provides a number of classes that perform locale-sensitive operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats numbers, currency, and percentages in a locale-sensitive manner. Classes such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods for creating a default object of that type. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:</source>
          <target state="translated">Java 플랫폼은 로케일 구분 조작을 수행하는 많은 클래스를 제공합니다. 예를 들어, &lt;code&gt;NumberFormat&lt;/code&gt; 클래스는 숫자, 통화 및 백분율을 로케일 구분 방식으로 형식화합니다. &lt;code&gt;NumberFormat&lt;/code&gt; 과 같은 클래스 에는 해당 유형의 기본 객체를 작성하기위한 몇 가지 편리한 메소드가 있습니다. 예를 들어, &lt;code&gt;NumberFormat&lt;/code&gt; 클래스는 기본 &lt;code&gt;NumberFormat&lt;/code&gt; 을 작성하기위한이 세 가지 편리한 메소드를 제공합니다. 객체 합니다.</target>
        </trans-unit>
        <trans-unit id="3b60f629f49f10f4985e6a720af54abf514bac30" translate="yes" xml:space="preserve">
          <source>The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;-- &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers, respectively.</source>
          <target state="translated">자바 플랫폼의 세 가지 전문 서브 클래스 제공 &lt;code&gt;Format&lt;/code&gt; - &lt;code&gt;DateFormat&lt;/code&gt; 의 , &lt;code&gt;MessageFormat&lt;/code&gt; 의 및 &lt;code&gt;NumberFormat&lt;/code&gt; 각각 포맷 날짜, 메시지 및 숫자 --for을.</target>
        </trans-unit>
        <trans-unit id="03ea0cad9aef11b637a3137ff4122043f3493aef" translate="yes" xml:space="preserve">
          <source>The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;, &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;, that provide a fairly simple way to create resources. As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt; manages its resource as a list of key/value pairs. &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage its resources.</source>
          <target state="translated">자바 플랫폼은 두 개의 서브 클래스 제공 &lt;code&gt;ResourceBundle&lt;/code&gt; 를 , &lt;code&gt;ListResourceBundle&lt;/code&gt; 및 &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 가 리소스를 생성 할 수있는 아주 간단한 방법을 제공합니다. 이전 예제에서 간략하게 살펴본 것처럼 &lt;code&gt;ListResourceBundle&lt;/code&gt; 은 리소스를 키 / 값 쌍 목록으로 관리합니다. &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 은 속성 파일을 사용하여 리소스를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="2228edce994b6e3417cf42c80f9c126b6f466b3b" translate="yes" xml:space="preserve">
          <source>The Java Platform supports input methods that have been developed in the Java programming language, using the interfaces in the &lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.awt.im.spi&lt;/code&gt;&lt;/a&gt; package, which can be made available by adding them to the application's class path. Implementations may also support using the native input methods of the platforms they run on; however, not all platforms and locales provide input methods. Keyboard layouts are provided by the host platform.</source>
          <target state="translated">Java 플랫폼은 응용 프로그램의 클래스 경로에 추가하여 사용할 수있는 &lt;a href=&quot;spi/package-summary&quot;&gt; &lt;code&gt;java.awt.im.spi&lt;/code&gt; &lt;/a&gt; 패키지 의 인터페이스를 사용하여 Java 프로그래밍 언어로 개발 된 입력 메소드를 지원 합니다. 구현은 실행되는 플랫폼의 기본 입력 방법 사용을 지원할 수도 있습니다. 그러나 모든 플랫폼과 로케일이 입력 방법을 제공하는 것은 아닙니다. 키보드 레이아웃은 호스트 플랫폼에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="563105f61580384f40b3157faa1d0806aadcdba7" translate="yes" xml:space="preserve">
          <source>The Java Platform, Standard Edition (Java SE) APIs define the core Java platform for general-purpose computing. These APIs are in modules whose names start with &lt;code&gt;java&lt;/code&gt;.</source>
          <target state="translated">Java SE (Java Platform, Standard Edition) API는 범용 컴퓨팅을위한 핵심 Java 플랫폼을 정의합니다. 이러한 API는 이름이 &lt;code&gt;java&lt;/code&gt; 로 시작하는 모듈에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f239cc990f3edd2c4e5449b541498920cb9d284" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines a group of standard attribute classes modeled upon the attributes in the Internet Printing Protocol (IPP) version 1.1. The standard attribute classes are in the subpackage &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; to keep the actual attribute classes conceptually separate from the generic apparatus defined in package &lt;code&gt;javax.print.attribute&lt;/code&gt;.</source>
          <target state="translated">Java Print Service API는 IPP (Internet Printing Protocol) 버전 1.1의 속성을 기반으로 모델링 된 표준 속성 클래스 그룹을 정의합니다. 표준 속성 클래스는 &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; 패키지에 정의 된 일반 장치와 개념적으로 분리 된 실제 속성 클래스를 유지하기 위해 서브 패키지 &lt;code&gt;javax.print.attribute&lt;/code&gt; .standard에 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f66170e9f1f394a5254a9fe89af973c28cd26f" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines a group of standard attribute classes modeled upon the attributes in the Internet Printing Protocol (IPP) version 1.1. The standard attribute classes are in the subpackage javax.print.attribute.standard to keep the actual attribute classes conceptually separate from the generic apparatus defined in package javax.print.attribute.</source>
          <target state="translated">Java Print Service API는 IPP (Internet Printing Protocol) 버전 1.1의 속성을 모델로 한 표준 속성 클래스 그룹을 정의합니다. 표준 속성 클래스는 서브 패키지 javax.print.attribute.standard에 있으며, 실제 속성 클래스는 개념적으로 javax.print.attribute 패키지에 정의 된 일반 장치와 분리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a818f0937d6870054c9657fd1853dbbf7260285b" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines these different kinds of attributes with five subinterfaces of &lt;code&gt;Attribute&lt;/code&gt;:</source>
          <target state="translated">Java 인쇄 서비스 API는 다섯 개 서브 인터페이스의 속성이 다른 종류의 정의 &lt;code&gt;Attribute&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4a4823caa7194efcb9ec79cc33455ea92b11d4af" translate="yes" xml:space="preserve">
          <source>The Java Print Service API does not define any mandatorily supported &lt;code&gt;DocFlavors&lt;/code&gt;. However, here are some examples of MIME types that a Java Print Service instance might support for client formatted print data. Nested classes inside class &lt;code&gt;DocFlavor&lt;/code&gt; declare predefined static constant &lt;code&gt;DocFlavor&lt;/code&gt; objects for these example doc flavors; class &lt;code&gt;DocFlavor&lt;/code&gt;'s constructor can be used to create an arbitrary doc flavor.</source>
          <target state="translated">Java Print Service API는 필수로 지원되는 &lt;code&gt;DocFlavors&lt;/code&gt; 정의하지 않습니다 . 그러나 다음은 Java 인쇄 서비스 인스턴스가 클라이언트 형식 인쇄 데이터에 대해 지원할 수있는 MIME 유형의 몇 가지 예입니다. &lt;code&gt;DocFlavor&lt;/code&gt; 클래스 내의 중첩 클래스 는 이러한 예제 문서 특징에 대해 미리 정의 된 정적 상수 &lt;code&gt;DocFlavor&lt;/code&gt; 객체를 선언 합니다 . &lt;code&gt;DocFlavor&lt;/code&gt; 클래스 의 생성자를 사용하여 임의의 문서 풍미를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe3bd743981c387b2400e5d9b97f685293d95022" translate="yes" xml:space="preserve">
          <source>The Java Print Service API does not define any mandatorily supported DocFlavors. However, here are some examples of MIME types that a Java Print Service instance might support for client formatted print data. Nested classes inside class DocFlavor declare predefined static constant DocFlavor objects for these example doc flavors; class DocFlavor's constructor can be used to create an arbitrary doc flavor.</source>
          <target state="translated">Java Print Service API는 반드시 지원되는 DocFlavors를 정의하지 않습니다. 그러나 Java Print Service 인스턴스가 클라이언트 형식의 인쇄 데이터를 지원할 수있는 MIME 유형의 예는 다음과 같습니다. DocFlavor 클래스 내부의 중첩 클래스는이 예제 doc 후 레이 바에 대해 미리 정의 된 정적 상수 DocFlavor 객체를 선언합니다. DocFlavor 클래스의 생성자를 사용해 임의의 doc 후 레이 바를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c3c2c1fe707b0a8b3bdeea8d3461a62fcf7c49" translate="yes" xml:space="preserve">
          <source>The Java Print Service API is designed so that vendors can:</source>
          <target state="translated">Java 인쇄 서비스 API는 공급 업체가 다음을 수행 할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f34c755601f30797b5c5b7d5b48474498065dd9" translate="yes" xml:space="preserve">
          <source>The Java Print Service API provides four specializations of an attribute set that are restricted to contain just one of the four kinds of attributes, as discussed in the &lt;a href=&quot;#role&quot;&gt;Attribute Roles&lt;/a&gt; section:</source>
          <target state="translated">Java 인쇄 서비스 API는 &lt;a href=&quot;#role&quot;&gt;속성 역할&lt;/a&gt; 섹션 에서 설명한대로 네 가지 속성 중 하나만 포함하도록 제한되는 속성 세트의 네 가지 전문화를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5e75e4ce71063f5deab60042bab1ecda724688fe" translate="yes" xml:space="preserve">
          <source>The Java SE 11 Platform uses character information from version 10.0 of the Unicode Standard, with an extension. The Java SE 11 Platform allows an implementation of class &lt;code&gt;Character&lt;/code&gt; to use the Japanese Era code point, &lt;code&gt;U+32FF&lt;/code&gt;, from the first version of the Unicode Standard after 10.0 that assigns the code point. Consequently, the behavior of fields and methods of class &lt;code&gt;Character&lt;/code&gt; may vary across implementations of the Java SE 11 Platform when processing the aforementioned code point ( outside of version 10.0 ), except for the following methods that define Java identifiers: &lt;a href=&quot;#isJavaIdentifierStart(int)&quot;&gt;&lt;code&gt;isJavaIdentifierStart(int)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isJavaIdentifierStart(char)&quot;&gt;&lt;code&gt;isJavaIdentifierStart(char)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isJavaIdentifierPart(int)&quot;&gt;&lt;code&gt;isJavaIdentifierPart(int)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#isJavaIdentifierPart(char)&quot;&gt;&lt;code&gt;isJavaIdentifierPart(char)&lt;/code&gt;&lt;/a&gt;. Code points in Java identifiers must be drawn from version 10.0 of the Unicode Standard.</source>
          <target state="translated">Java SE 11 플랫폼은 확장자가있는 유니 코드 표준 버전 10.0의 문자 정보를 사용합니다. Java SE 11 플랫폼은 &lt;code&gt;Character&lt;/code&gt; 클래스 구현이 코드 포인트 를 할당하는 10.0 이후 유니 코드 표준의 첫 번째 버전에서 일본어 시대 코드 포인트 &lt;code&gt;U+32FF&lt;/code&gt; 를 사용할 수 있도록합니다 . 결과적으로, &lt;code&gt;Character&lt;/code&gt; 클래스의 필드 및 메소드 동작은 Java 식별자를 정의하는 다음 메소드를 제외하고 앞서 언급 한 코드 포인트 (버전 10.0 외부)를 처리 할 때 Java SE 11 플랫폼의 구현에 따라 다를 수 있습니다. &lt;a href=&quot;#isJavaIdentifierStart(int)&quot;&gt; &lt;code&gt;isJavaIdentifierStart(int)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#isJavaIdentifierStart(char)&quot;&gt; &lt;code&gt;isJavaIdentifierStart(char)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#isJavaIdentifierPart(int)&quot;&gt; &lt;code&gt;isJavaIdentifierPart(int)&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#isJavaIdentifierPart(char)&quot;&gt; &lt;code&gt;isJavaIdentifierPart(char)&lt;/code&gt; &lt;/a&gt; . Java 식별자의 코드 포인트는 유니 코드 표준 버전 10.0에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="afb3e24894a90acb5b20ffe967cda4ac6a0179f2" translate="yes" xml:space="preserve">
          <source>The Java SE Platform supports all eras defined by the Japanese government, beginning with the Meiji era. Each era is identified in the Platform by an integer value and a name. The &lt;a href=&quot;#of(int)&quot;&gt;&lt;code&gt;of(int)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#valueOf(java.lang.String)&quot;&gt;&lt;code&gt;valueOf(String)&lt;/code&gt;&lt;/a&gt; methods may be used to obtain a singleton instance of JapaneseEra for each era. The &lt;a href=&quot;#values()&quot;&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/a&gt; method returns the singleton instances of all supported eras.</source>
          <target state="translated">Java SE 플랫폼은 메이지 시대를 시작으로 일본 정부가 정의한 모든 시대를 지원합니다. 플랫폼에서 각 시대는 정수 값과 이름으로 식별됩니다. &lt;a href=&quot;#of(int)&quot;&gt; &lt;code&gt;of(int)&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#valueOf(java.lang.String)&quot;&gt; &lt;code&gt;valueOf(String)&lt;/code&gt; &lt;/a&gt; 방법은 각 시대 JapaneseEra의 단일 인스턴스를 획득하기 위해 사용될 수있다. &lt;a href=&quot;#values()&quot;&gt; &lt;code&gt;values()&lt;/code&gt; &lt;/a&gt; 메소드가 반환 지원되는 모든 시대의 싱글 인스턴스.</target>
        </trans-unit>
        <trans-unit id="020b92794f4c93bc0ed4d9763a4e104a73b9e2f4" translate="yes" xml:space="preserve">
          <source>The Java SQL framework allows for multiple database drivers.</source>
          <target state="translated">Java SQL 프레임 워크는 여러 데이터베이스 드라이버를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4cea0620c1bef0b99a18c809ce3bab655ecb274b" translate="yes" xml:space="preserve">
          <source>The Java Sound Tutorial</source>
          <target state="translated">자바 사운드 튜토리얼</target>
        </trans-unit>
        <trans-unit id="c2715c77dd34c70665dfad2f1923e173e786e209" translate="yes" xml:space="preserve">
          <source>The Java Time-Scale divides each calendar day into exactly 86400 subdivisions, known as seconds. These seconds may differ from the SI second. It closely matches the de facto international civil time scale, the definition of which changes from time to time.</source>
          <target state="translated">Java Time-Scale은 매일 달력을 정확히 86400의 세분 (초)으로 나눕니다. 이 초는 SI 초와 다를 수 있습니다. 그것은 사실상 국제 시민의 시간 규모와 밀접하게 일치하며, 그 정의는 때때로 변화합니다.</target>
        </trans-unit>
        <trans-unit id="4bde9066215b58dffb03e10c8882b75db84e87a4" translate="yes" xml:space="preserve">
          <source>The Java Time-Scale has slightly different definitions for different segments of the time-line, each based on the consensus international time scale that is used as the basis for civil time. Whenever the internationally-agreed time scale is modified or replaced, a new segment of the Java Time-Scale must be defined for it. Each segment must meet these requirements:</source>
          <target state="translated">Java Time-Scale은 타임 라인의 각기 다른 세그먼트에 대해 약간 다른 정의를 가지고 있으며, 각각은 민간 시간의 기준으로 사용되는 합의 된 국제 시간 스케일을 기반으로합니다. 국제적으로 합의 된 시간 척도가 수정되거나 교체 될 때마다 Java Time-Scale의 새로운 세그먼트가 정의되어야합니다. 각 세그먼트는 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f78637fddaa4e53e279355beabee4458db283b36" translate="yes" xml:space="preserve">
          <source>The Java Tutorial</source>
          <target state="translated">자바 튜토리얼</target>
        </trans-unit>
        <trans-unit id="4600970ab5dcc28d471a34b69880d44724af7c9c" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine Specification</source>
          <target state="translated">자바 가상 머신 사양</target>
        </trans-unit>
        <trans-unit id="e3cf148b298a0b996efd7f97bd7f2e6174fda315" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로캘을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 메소드에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54550db269bf7cd9cb4b43e4d04a89f68d9ad806" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the &lt;a href=&quot;#setDefault(java.util.Locale)&quot;&gt;&lt;code&gt;setDefault&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로케일을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 방법에서 사용됩니다. &lt;a href=&quot;#setDefault(java.util.Locale)&quot;&gt; &lt;code&gt;setDefault&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9d7a4ea102a2331058fd720ef77be5d28603b6b" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the &lt;a href=&quot;locale#setDefault-java.util.Locale-&quot;&gt;&lt;code&gt;setDefault&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로캘을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 메소드에서 사용됩니다. &lt;a href=&quot;locale#setDefault-java.util.Locale-&quot;&gt; &lt;code&gt;setDefault&lt;/code&gt; 를&lt;/a&gt; 사용하여 변경할 수 있습니다 메소드를 .</target>
        </trans-unit>
        <trans-unit id="935b4a63d6ee5db34b9d75a511cfdfab0947e278" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the setDefault(Locale.Category, Locale) method.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로캘을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 메소드에서 사용됩니다. setDefault (Locale.Category, Locale) 메소드를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5d4bfdb8b77d90d9d3b5f96ac809bfa715ae313" translate="yes" xml:space="preserve">
          <source>The Java class name of composite data values this composite type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName()&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;CompositeData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 복합 유형이 나타내는 복합 데이터 값의 Java 클래스 이름 (즉, &lt;a href=&quot;opentype#getClassName()&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드에서 반환 된 클래스 이름 )은 &lt;code&gt;CompositeData.class.getName()&lt;/code&gt; 반환 한 문자열 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bf9c7a5833d85446736a0e1c4523720b0baa70e" translate="yes" xml:space="preserve">
          <source>The Java class name of composite data values this composite type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;CompositeData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 복합 형이 나타내는 복합 데이터 치의 Java 클래스 명 (즉, &lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 클래스 명 )은 &lt;code&gt;CompositeData.class.getName()&lt;/code&gt; 의해 리턴 된 캐릭터 라인 치로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c797024101e43684f89be3466f4ed077167867bf" translate="yes" xml:space="preserve">
          <source>The Java class name of tabular data values this tabular type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName()&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;TabularData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 테이블 형식 유형이 나타내는 테이블 형식 데이터 값의 Java 클래스 이름 (즉, &lt;a href=&quot;opentype#getClassName()&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 클래스 이름 )은 &lt;code&gt;TabularData.class.getName()&lt;/code&gt; 반환 한 문자열 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bda12988aff6c0c6b0da57eda918cd7f7e41f2f4" translate="yes" xml:space="preserve">
          <source>The Java class name of tabular data values this tabular type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;TabularData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 테이블 형이 나타내는 테이블 형식의 데이터 치의 Java 클래스 명 (즉, &lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드에 의해 반환되는 클래스 명 )은 &lt;code&gt;TabularData.class.getName()&lt;/code&gt; 의해 반환되는 캐릭터 라인 치로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c14a043362d4c6a8070d7ef91c6074e182453f3" translate="yes" xml:space="preserve">
          <source>The Java input method framework intends to support all combinations of input methods (host input methods and Java input methods) and components (peered and lightweight). However, because of limitations in the underlying platform, it may not always be possible to enable the communication between Java input methods and peered AWT components. Support for this specific combination is therefore platform dependent. In Sun's Java SE Runtime Environments, this combination is supported on Windows, but not on Solaris.</source>
          <target state="translated">Java 입력 방법 프레임 워크는 입력 방법 (호스트 입력 방법 및 Java 입력 방법)과 구성 요소 (피어 드 및 경량)의 모든 조합을 지원합니다. 그러나 기본 플랫폼의 제한으로 인해 Java 입력 방법과 피어링 된 AWT 구성 요소 간의 통신을 활성화하는 것이 항상 가능한 것은 아닙니다. 따라서이 특정 조합에 대한 지원은 플랫폼에 따라 다릅니다. Sun의 Java SE Runtime Environment에서이 조합은 Windows에서는 지원되지만 Solaris에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79100a6d797f840a76dcfd0b27ebb8da026f838e" translate="yes" xml:space="preserve">
          <source>The Java interface name for a Standard MBean or MXBean, as returned by &lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly in the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">&lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 표준 MBean 또는 MXBean의 Java 인터페이스 이름입니다 . MBean 서버에 직접 등록되거나 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 생성 된 Standard MBean 또는 MXBean 은 MBeanInfo Descriptor에이 필드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="51863c4a757aa5599aa4ec4ebb6fdc59f85b517e" translate="yes" xml:space="preserve">
          <source>The Java interface name for a Standard MBean or MXBean, as returned by &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly in the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">표준 MBean 또는 MXBean의 Java 인터페이스 명. &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt;. MBean 서버에 직접 등록되거나&lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; 을&lt;/a&gt; 사용하여 작성된 표준 MBean 또는 MXBean 클래스를 은이 필드를 MBeanInfo 디스크립터에 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b846c3f527602fad3b8086a6f7a5ad28be2a0b97" translate="yes" xml:space="preserve">
          <source>The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. For additional information on string concatenation and conversion, see</source>
          <target state="translated">Java 언어는 문자열 연결 연산자 (+) 및 다른 객체를 문자열로 변환하는 특수 지원을 제공합니다. 문자열 연결 및 변환에 대한 추가 정보는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1aedb6f153f14e307ee0a63ee1143e333aca4608" translate="yes" xml:space="preserve">
          <source>The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the &lt;code&gt;StringBuilder&lt;/code&gt;(or &lt;code&gt;StringBuffer&lt;/code&gt;) class and its &lt;code&gt;append&lt;/code&gt; method. String conversions are implemented through the method &lt;code&gt;toString&lt;/code&gt;, defined by &lt;code&gt;Object&lt;/code&gt; and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele,</source>
          <target state="translated">Java 언어는 문자열 연결 연산자 (+) 및 다른 객체를 문자열로 변환하는 데 특별한 지원을 제공합니다. 문자열 연결은 &lt;code&gt;StringBuilder&lt;/code&gt; (또는 &lt;code&gt;StringBuffer&lt;/code&gt; ) 클래스와 클래스를 통해 구현됩니다. &lt;code&gt;append&lt;/code&gt; 메소드를 . 문자열 변환은 &lt;code&gt;Object&lt;/code&gt; 에 의해 정의되고 Java의 모든 클래스에 상속되는 &lt;code&gt;toString&lt;/code&gt; 메소드를 통해 구현됩니다 . 문자열 연결 및 변환에 대한 자세한 내용은 Gosling, Joy 및 Steele을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0998193a86cfe456d402b1f0c70a66b6cd6c11c" translate="yes" xml:space="preserve">
          <source>The Java math library is defined with respect to &lt;code&gt;fdlibm&lt;/code&gt; version 5.3. Where &lt;code&gt;fdlibm&lt;/code&gt; provides more than one definition for a function (such as &lt;code&gt;acos&lt;/code&gt;), use the &quot;IEEE 754 core function&quot; version (residing in a file whose name begins with the letter &lt;code&gt;e&lt;/code&gt;). The methods which require &lt;code&gt;fdlibm&lt;/code&gt; semantics are &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, and &lt;code&gt;log1p&lt;/code&gt;.</source>
          <target state="translated">Java 수학 라이브러리는 &lt;code&gt;fdlibm&lt;/code&gt; 버전 5.3 과 관련하여 정의됩니다 . 어디 &lt;code&gt;fdlibm&lt;/code&gt; 이 (같은 기능에 대해 둘 이상의 정의를 제공 &lt;code&gt;acos&lt;/code&gt; ), (이름이 문자로 시작하는 파일에 존재하는 &quot;IEEE 754 핵심 기능&quot;버전 사용하는 &lt;code&gt;e&lt;/code&gt; ). &lt;code&gt;fdlibm&lt;/code&gt; 의미가 필요한 메소드 는 &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt; , &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;cbrt&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;hypot&lt;/code&gt; , &lt;code&gt;expm1&lt;/code&gt; 입니다. &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , 및 &lt;code&gt;log1p&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75bc96f1b0cc70e1672a7ea3f62bf4ee8f43d325" translate="yes" xml:space="preserve">
          <source>The Java programming language does not guarantee which thread will invoke the &lt;code&gt;finalize&lt;/code&gt; method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates.</source>
          <target state="translated">Java 프로그래밍 언어는 어떤 스레드가 주어진 객체에 대한 &lt;code&gt;finalize&lt;/code&gt; 메소드를 호출한다고 보장하지 않습니다 . 그러나 finalize를 호출하는 스레드는 finalize가 호출 될 때 사용자가 볼 수있는 동기화 잠금을 보유하지 않습니다. 포착되지 않은 예외가 finalize 메소드에 의해 발생되면 예외가 무시되고 해당 오브젝트의 종료가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a17398b63cfead5fb4c823a73d9a91965bc4ebc9" translate="yes" xml:space="preserve">
          <source>The Java run-time has the following built-in class loaders:</source>
          <target state="translated">Java 런타임에는 다음과 같은 내장 클래스 로더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="af13f60de6a564a40dc8e97ebaf3a0143c84236a" translate="yes" xml:space="preserve">
          <source>The Java time-scale is used for all date-time classes. This includes &lt;code&gt;Instant&lt;/code&gt;, &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;, &lt;code&gt;OffsetDateTime&lt;/code&gt;, &lt;code&gt;ZonedDateTime&lt;/code&gt; and &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Java 시간 척도는 모든 날짜-시간 클래스에 사용됩니다. 여기에는 &lt;code&gt;Instant&lt;/code&gt; , &lt;code&gt;LocalDate&lt;/code&gt; , &lt;code&gt;LocalTime&lt;/code&gt; , &lt;code&gt;OffsetDateTime&lt;/code&gt; , &lt;code&gt;ZonedDateTime&lt;/code&gt; 및 &lt;code&gt;Duration&lt;/code&gt; 이 포함됩니다. .</target>
        </trans-unit>
        <trans-unit id="b2da8a881d3a54f6e4f6b884054ec854ec43a1d9" translate="yes" xml:space="preserve">
          <source>The Java type of the resource. For field annotations, the default is the type of the field. For method annotations, the default is the type of the JavaBeans property. For class annotations, there is no default and this must be specified.</source>
          <target state="translated">자원의 Java 유형 필드 주석의 경우 기본값은 필드 유형입니다. 메소드 어노테이션의 경우 기본값은 JavaBeans 특성의 유형입니다. 클래스 주석의 경우 기본값이 없으므로이를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="43d20fd86e33d070ee07b30fb6fd2637b8965aa6" translate="yes" xml:space="preserve">
          <source>The Java virtual machine</source>
          <target state="translated">자바 가상 머신</target>
        </trans-unit>
        <trans-unit id="9b5c7ce28420ae67114f39b12a0543341609a160" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a</source>
          <target state="translated">Java 가상 머신에는</target>
        </trans-unit>
        <trans-unit id="8516f820bb05657121a79dd1bd0a5cddcc1f2f53" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a default provider that provides zone rules for the time-zones defined by IANA Time Zone Database (TZDB). If the system property &lt;code&gt;java.time.zone.DefaultZoneRulesProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete ZoneRulesProvider class to be loaded as the default provider, using the system class loader. If this system property is not defined, a system-default provider will be loaded to serve as the default provider.</source>
          <target state="translated">Java 가상 머신에는 IANA 시간대 데이터베이스 (TZDB)에서 정의한 시간대에 대한 시간대 규칙을 제공하는 기본 제공자가 있습니다. 시스템 프로퍼티 &lt;code&gt;java.time.zone.DefaultZoneRulesProvider&lt;/code&gt; 인 경우 가 정의 된 경우 시스템 클래스 로더를 사용하여 기본 제공자로로드 할 콘크리트 ZoneRulesProvider 클래스의 완전한 이름이됩니다. 이 시스템 속성이 정의되어 있지 않으면 시스템 기본 공급자가 기본 공급자 역할을하도록로드됩니다.</target>
        </trans-unit>
        <trans-unit id="01e66a7f2f90bc990318958109b0d41e725d670b" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a heap for object allocation and also maintains non-heap memory for the method area and the Java virtual machine execution. The Java virtual machine can have one or more memory pools. Each memory pool represents a memory area of one of the following types:</source>
          <target state="translated">JVM (Java Virtual Machine)에는 오브젝트 할당을위한 힙이 있으며 메소드 영역 및 JVM (Java Virtual Machine) 실행을 위해 힙이 아닌 메모리를 유지 보수합니다. Java 가상 머신에는 하나 이상의 메모리 풀이있을 수 있습니다. 각 메모리 풀은 다음 유형 중 하나의 메모리 영역을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="20591611464f80238a71287e9fce3d26d00ecfac" translate="yes" xml:space="preserve">
          <source>The Java virtual machine implementation may use a high resolution timer to measure the elapsed time. This method may return the same value even if the collection count has been incremented if the collection elapsed time is very short.</source>
          <target state="translated">JVM (Java Virtual Machine) 구현은 경과 시간을 측정하기 위해 고해상도 타이머를 사용할 수 있습니다. 이 방법은 수집 경과 시간이 매우 짧은 경우 수집 횟수가 증가한 경우에도 동일한 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b9d55292bfb865db4e6b6204b4073d1f202f8ab" translate="yes" xml:space="preserve">
          <source>The Java virtual machine maintains the peak memory usage of a memory pool since the virtual machine was started or the peak was reset. The peak memory usage is returned by the &lt;a href=&quot;#getPeakUsage()&quot;&gt;&lt;code&gt;getPeakUsage()&lt;/code&gt;&lt;/a&gt; method and reset by calling the &lt;a href=&quot;#resetPeakUsage()&quot;&gt;&lt;code&gt;resetPeakUsage()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">JVM (Java Virtual Machine)은 가상 머신이 시작되거나 피크가 재설정 된 이후 메모리 풀의 피크 메모리 사용량을 유지합니다. 최대 메모리 사용량은 &lt;a href=&quot;#getPeakUsage()&quot;&gt; &lt;code&gt;getPeakUsage()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환되고 &lt;a href=&quot;#resetPeakUsage()&quot;&gt; &lt;code&gt;resetPeakUsage()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="21c32d462e38386cb39051b42822e7568e72eaed" translate="yes" xml:space="preserve">
          <source>The Java virtual machine maintains the peak memory usage of a memory pool since the virtual machine was started or the peak was reset. The peak memory usage is returned by the &lt;a href=&quot;memorypoolmxbean#getPeakUsage--&quot;&gt;&lt;code&gt;getPeakUsage()&lt;/code&gt;&lt;/a&gt; method and reset by calling the &lt;a href=&quot;memorypoolmxbean#resetPeakUsage--&quot;&gt;&lt;code&gt;resetPeakUsage()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신은 가상 머신이 시작되었거나 피크가 재설정 된 이후 메모리 풀의 최대 메모리 사용량을 유지합니다. 최대 메모리 사용량은 &lt;a href=&quot;memorypoolmxbean#getPeakUsage--&quot;&gt; &lt;code&gt;getPeakUsage()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴되고 &lt;a href=&quot;memorypoolmxbean#resetPeakUsage--&quot;&gt; &lt;code&gt;resetPeakUsage()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dd3f55b5efbf2036c2fe1ec00c3c49d3ddb4916" translate="yes" xml:space="preserve">
          <source>The Java virtual machine manages memory other than the heap (referred as</source>
          <target state="translated">JVM (Java Virtual Machine)은 힙 이외의 메모리를 관리합니다 (</target>
        </trans-unit>
        <trans-unit id="472437aa219a5ab5c682981b0f53bbaf388053c7" translate="yes" xml:space="preserve">
          <source>The Java virtual machine may measure the time with a high resolution timer. This statistic is reset when the thread contention monitoring is reenabled.</source>
          <target state="translated">Java 가상 머신은 고해상도 타이머로 시간을 측정 할 수 있습니다. 이 통계는 스레드 경합 모니터링이 다시 활성화 될 때 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5cc1c9e97c8fd121944655161d88c67a4b91ea" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification</source>
          <target state="translated">자바 언어 사양</target>
        </trans-unit>
        <trans-unit id="fff53af6e46bb1a4be8a5ab0a06369d5f80e1391" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, First Edition</source>
          <target state="translated">Java &amp;trade; 언어 사양, 초판</target>
        </trans-unit>
        <trans-unit id="417681d10c199b472becfb181846b8f2351a0cd7" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, Second Edition</source>
          <target state="translated">Java &amp;trade; 언어 사양, 제 2 판</target>
        </trans-unit>
        <trans-unit id="a4154fea8bd8d5b8ca35ca7f9f31b5ca95523b77" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, Third Edition</source>
          <target state="translated">Java &amp;trade; 언어 사양, 제 3 판</target>
        </trans-unit>
        <trans-unit id="b01e874645c4aa3cc169adba9f26395f941d4bfb" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Virtual Machine Specification</source>
          <target state="translated">Java &amp;trade; 가상 머신 스펙</target>
        </trans-unit>
        <trans-unit id="573f4350c0a7648c709160ed919837ba77cd9cc2" translate="yes" xml:space="preserve">
          <source>The Java(tm)2D API adopts the convention that one point is equivalent to one unit in user coordinates. When using a normalized transform for converting user space coordinates to device space coordinates 72 user space units equal 1 inch in device space. In this case one point is 1/72 of an inch.</source>
          <target state="translated">Java (tm) 2D API는 사용자 좌표에서 하나의 포인트가 하나의 단위와 동일하다는 규칙을 채택합니다. 사용자 공간 좌표를 장치 공간 좌표로 변환하기 위해 정규화 된 변환을 사용하는 경우 72 개의 사용자 공간 단위는 장치 공간에서 1 인치와 같습니다. 이 경우 1 포인트는 1/72 인치입니다.</target>
        </trans-unit>
        <trans-unit id="4cadba2d15fbb9804bf151281d2e05044e9bc484" translate="yes" xml:space="preserve">
          <source>The JavaBeans&amp;trade; specification defines the notion of design time as is a mode in which JavaBeans instances should function during their composition and customization in a interactive design, composition or construction tool, as opposed to runtime when the JavaBean is part of an applet, application, or other live Java executable abstraction.</source>
          <target state="translated">JavaBeans &amp;trade; 사양은 JavaBeans가 애플릿, 응용 프로그램, 응용 프로그램, 또는 기타 라이브 Java 실행 가능 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="2c47a19a69292af9f4d3ab44cef1faa2270339a1" translate="yes" xml:space="preserve">
          <source>The Javanese range with the Javanese digits.</source>
          <target state="translated">자바어 숫자가있는 자바어 범위입니다.</target>
        </trans-unit>
        <trans-unit id="7ece0bccd4f47c81fc16bd9c26fb8dacabc06bc3" translate="yes" xml:space="preserve">
          <source>The Jdbc &lt;code&gt;RowSet&lt;/code&gt; Implementations specification provides two reference implementations of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class: &lt;code&gt;RIOptimisticProvider&lt;/code&gt; and &lt;code&gt;RIXMLProvider&lt;/code&gt;. The &lt;code&gt;RIOptimisticProvider&lt;/code&gt; can set any &lt;code&gt;RowSet&lt;/code&gt; implementation with a &lt;code&gt;RowSetReader&lt;/code&gt; object and a &lt;code&gt;RowSetWriter&lt;/code&gt; object. However, only the &lt;code&gt;RIXMLProvider&lt;/code&gt; implementation can set an &lt;code&gt;XmlReader&lt;/code&gt; object and an &lt;code&gt;XmlWriter&lt;/code&gt; object. A &lt;code&gt;WebRowSet&lt;/code&gt; object uses the &lt;code&gt;XmlReader&lt;/code&gt; object to read data in XML format to populate itself with that data. It uses the &lt;code&gt;XmlWriter&lt;/code&gt; object to write itself to a stream or &lt;code&gt;java.io.Writer&lt;/code&gt; object in XML format.</source>
          <target state="translated">Jdbc &lt;code&gt;RowSet&lt;/code&gt; 구현 사양은 &lt;code&gt;SyncProvider&lt;/code&gt; 추상 클래스 의 두 가지 참조 구현 인 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 및 &lt;code&gt;RIXMLProvider&lt;/code&gt; 를 제공 합니다. &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 어떤 설정할 수 &lt;code&gt;RowSet&lt;/code&gt; A를 구현 &lt;code&gt;RowSetReader&lt;/code&gt; 객체와 &lt;code&gt;RowSetWriter&lt;/code&gt; 의의 객체를. 그러나 &lt;code&gt;RIXMLProvider&lt;/code&gt; 구현 만 &lt;code&gt;XmlReader&lt;/code&gt; 개체와 &lt;code&gt;XmlWriter&lt;/code&gt; 개체를 설정할 수 있습니다 . &lt;code&gt;WebRowSet&lt;/code&gt; 객체는 사용 &lt;code&gt;XmlReader&lt;/code&gt; 에서의 데이터 자체를 채우기 위해 XML 형식의 데이터를 읽을 객체. 그것은 &lt;code&gt;XmlWriter&lt;/code&gt; XML 형식으로 스트림 또는 &lt;code&gt;java.io.Writer&lt;/code&gt; 개체에 자신을 쓰는 XmlWriter 개체 입니다.</target>
        </trans-unit>
        <trans-unit id="46152631e4488fac6b1cad7442ef7feac4ea4d12" translate="yes" xml:space="preserve">
          <source>The JobImpressions attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobImpressions attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobImpressions attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobImpressions attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobImpressions 속성은 작업 크기를 설명합니다. 이 속성은 카운터가 아닙니다. 알려진 경우 유용한 라우팅 및 스케줄링 정보가되도록 고안되었습니다. 인쇄 요청에 JobImpressions 속성 값이 제공되지 않으면 프린터에서 JobImpressions 속성 값을 계산하려고 시도 할 수 있습니다. 클라이언트가 인쇄 요청에서 JobImpressions 속성 값을 제공하더라도 프린터가 클라이언트 제공 값보다 정확한 값을 계산할 수있는 경우 프린터는 값을 변경하도록 선택할 수 있습니다. 프린터는 작업 제출 시점 또는 이후에 JobImpressions 속성의 올바른 값을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eda45bce719c55226f8cb11330a3730a179a164" translate="yes" xml:space="preserve">
          <source>The JobImpressionsCompleted attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobImpressionsCompleted value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobImpressionsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobImpressionsCompleted value is the final value for the job.</source>
          <target state="translated">JobImpressionsCompleted 속성은 작업 진행률을 설명합니다. 이 속성은 카운터가됩니다. 즉, 처리를 시작하지 않은 작업의 JobImpressionsCompleted 값은 0이어야합니다. 작업의 &lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt; 가 PROCESSING 또는 PROCESSING_STOPPED 인 경우 JobImpressionsCompleted 값은 작업이 처리됨에 따라 증가합니다. 인쇄 작업의 속성 세트가 조회되거나 인쇄 작업 이벤트가보고 될 때 처리 된 작업의 양을 나타냅니다. 작업이 COMPLETED, CANCELED 또는 ABORTED 상태가되면 JobImpressionsCompleted 값이 작업의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="23b552cbebfc9eeb6f00f5f7f1d577e52be27c5e" translate="yes" xml:space="preserve">
          <source>The JobKOctets attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobKOctets attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobKOctets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobKOctets attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobKOctets 속성은 작업 크기를 설명합니다. 이 속성은 카운터가 아닙니다. 알려진 경우 유용한 라우팅 및 스케줄링 정보가되도록 고안되었습니다. 인쇄 요청에 JobKOctets 속성 값이 제공되지 않으면 프린터는 JobKOctets 속성 값을 계산하려고 시도 할 수 있습니다. 클라이언트가 인쇄 요청에서 JobKOctets 속성 값을 제공하더라도 프린터가 클라이언트 제공 값보다 정확한 값을 계산할 수있는 경우 프린터는 값을 변경하도록 선택할 수 있습니다. 프린터는 작업 제출 시점 또는 이후에 JobKOctets 속성의 올바른 값을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10778b515020fa74e3922d67e4e4cfb07a6b5d4d" translate="yes" xml:space="preserve">
          <source>The JobKOctets value must also not include the multiplicative factor due to a copies instruction embedded in the document data. If the document data actually includes replications of the document data, this value will include such replication. In other words, this value is always the size of the source document data, rather than a measure of the hardcopy output to be produced.</source>
          <target state="translated">문서 데이터에 포함 된 복사 명령으로 인해 JobKOctets 값에도 곱셈 요소가 포함되지 않아야합니다. 문서 데이터에 실제로 문서 데이터의 복제가 포함 된 경우이 값에는 해당 복제가 포함됩니다. 즉,이 값은 생성 할 하드 카피 출력을 측정하는 것이 아니라 항상 소스 문서 데이터의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="4f8e193f841acdf58db4b152692036053ed12078" translate="yes" xml:space="preserve">
          <source>The JobKOctets value must not include the multiplicative factors contributed by the number of copies specified by the &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute, independent of whether the device can process multiple copies without making multiple passes over the job or document data and independent of whether the output is collated or not. Thus the value is independent of the implementation and indicates the size of the document(s) measured in K octets independent of the number of copies.</source>
          <target state="translated">JobKOctets 값은 장치가 작업 또는 문서 데이터를 여러 번 전달하지 않고 여러 사본을 처리 할 수 ​​있는지 여부와 출력의 한 부씩 정렬 여부에 관계없이 &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성으로 지정된 사본 수에 의해 영향을받는 곱셈 요소를 포함 하지 않아야합니다. . 따라서이 값은 구현과 무관하며 사본 수와 상관없이 K 옥텟으로 측정 된 문서의 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="860b972389f862538b6b997fd07b4c1c60636261" translate="yes" xml:space="preserve">
          <source>The JobKOctetsProcessed attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobKOctetsProcessed value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobKOctetsProcessed value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobKOctetsProcessed value is the final value for the job.</source>
          <target state="translated">JobKOctetsProcessed 속성은 작업 진행률을 설명합니다. 이 속성은 카운터가됩니다. 즉, 처리를 시작하지 않은 작업의 JobKOctetsProcessed 값은 0이어야합니다. 작업의 &lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt; 가 PROCESSING 또는 PROCESSING_STOPPED 인 경우 JobKOctetsProcessed 값은 작업이 처리됨에 따라 증가합니다. 인쇄 작업의 속성 세트가 조회되거나 인쇄 작업 이벤트가보고 될 때 처리 된 작업의 양을 나타냅니다. 작업이 COMPLETED, CANCELED 또는 ABORTED 상태가되면 JobKOctetsProcessed 값이 작업의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="67c4f689dd8dce6456481d0861afa2eb83cc72f8" translate="yes" xml:space="preserve">
          <source>The JobMediaSheets attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobMediaSheets attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobMediaSheets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobMediaSheets attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobMediaSheets 속성은 작업 크기를 설명합니다. 이 속성은 카운터가 아닙니다. 알려진 경우 유용한 라우팅 및 스케줄링 정보가되도록 고안되었습니다. 프린터는 JobMediaSheets 속성 값이 인쇄 요청에 제공되지 않은 경우 계산하려고 시도 할 수 있습니다. 클라이언트가 인쇄 요청에서 JobMediaSheets 속성 값을 제공하더라도 프린터가 클라이언트 제공 값보다 정확한 값을 계산할 수있는 경우 프린터는 값을 변경하도록 선택할 수 있습니다. 프린터는 작업 제출 시점 또는 이후에 JobMediaSheets 속성에 대한 올바른 값을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27e40040d6353841f04365a16d249f070597a18a" translate="yes" xml:space="preserve">
          <source>The JobMediaSheetsCompleted attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobMediaSheetsCompleted value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobMediaSheetsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobMediaSheetsCompleted value is the final value for the job.</source>
          <target state="translated">JobMediaSheetsCompleted 속성은 작업 진행 상황을 설명합니다. 이 속성은 카운터가됩니다. 즉, 처리를 시작하지 않은 작업의 JobMediaSheetsCompleted 값은 0이어야합니다. 작업의 &lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt; 가 PROCESSING 또는 PROCESSING_STOPPED 인 경우 JobMediaSheetsCompleted 값은 작업이 처리됨에 따라 증가합니다. 인쇄 작업의 속성 세트가 조회되거나 인쇄 작업 이벤트가보고 될 때 처리 된 작업의 양을 나타냅니다. 작업이 COMPLETED, CANCELED 또는 ABORTED 상태가되면 JobMediaSheetsCompleted 값이 작업의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="bc898aeb76a9f867124df93fc92a814fb7980188" translate="yes" xml:space="preserve">
          <source>The Julian Day is a standard way of expressing date and time commonly used in the scientific community. It is expressed as a decimal number of whole days where days start at midday. This class represents variations on Julian Days that count whole days from midnight.</source>
          <target state="translated">Julian Day는 과학계에서 일반적으로 사용되는 날짜와 시간을 표현하는 표준 방법입니다. 요일이 정오에 시작하는 전체 요일의 10 진수로 표시됩니다. 이 클래스는 자정부터 하루 종일 계산되는 Julian Days의 변형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9eef549030343348c0081e0aeeb494d2d5823916" translate="yes" xml:space="preserve">
          <source>The Kannada range with the Kannada digits.</source>
          <target state="translated">칸나다어 숫자가있는 칸나다어 범위입니다.</target>
        </trans-unit>
        <trans-unit id="9d5cb955409a47e5080caa7c35c25ddf731fb54b" translate="yes" xml:space="preserve">
          <source>The Kayah Li range with the Kayah Li digits.</source>
          <target state="translated">Kayah Li 숫자가있는 Kayah Li 범위입니다.</target>
        </trans-unit>
        <trans-unit id="04de0af52612213497a4e8449d41e7beb1c261f5" translate="yes" xml:space="preserve">
          <source>The Kerberos network authentication protocol is defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt;. The Java platform contains support for the client side of Kerberos via the &lt;a href=&quot;../../../../org/ietf/jgss/package-summary&quot;&gt;&lt;code&gt;org.ietf.jgss&lt;/code&gt;&lt;/a&gt; package. There might also be a login module that implements &lt;a href=&quot;../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt;&lt;code&gt;LoginModule&lt;/code&gt;&lt;/a&gt; to authenticate Kerberos principals.</source>
          <target state="translated">Kerberos 네트워크 인증 프로토콜은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120에&lt;/a&gt; 정의되어 있습니다. Java 플랫폼에는 &lt;a href=&quot;../../../../org/ietf/jgss/package-summary&quot;&gt; &lt;code&gt;org.ietf.jgss&lt;/code&gt; &lt;/a&gt; 패키지 를 통해 Kerberos의 클라이언트 측에 대한 지원이 포함되어 있습니다 . Kerberos 주체를 인증하기 위해 &lt;a href=&quot;../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt; &lt;code&gt;LoginModule&lt;/code&gt; &lt;/a&gt; 을 구현하는 로그인 모듈도있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b31c8a2b1469694c5596d8e7d24f8ca4168d3814" translate="yes" xml:space="preserve">
          <source>The Kerberos network authentication protocol is defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt;. The Java platform contains support for the client side of Kerberos via the &lt;a href=&quot;/openjdk~8_web/org/ietf/jgss/package-summary&quot;&gt;&lt;code&gt;org.ietf.jgss&lt;/code&gt;&lt;/a&gt; package. There might also be a login module that implements &lt;a href=&quot;../spi/loginmodule&quot;&gt;&lt;code&gt;LoginModule&lt;/code&gt;&lt;/a&gt; to authenticate Kerberos principals.</source>
          <target state="translated">Kerberos 네트워크 인증 프로토콜은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120에&lt;/a&gt; 정의되어 있습니다. Java 플랫폼에는 &lt;a href=&quot;/openjdk~8_web/org/ietf/jgss/package-summary&quot;&gt; &lt;code&gt;org.ietf.jgss&lt;/code&gt; &lt;/a&gt; 패키지 를 통해 Kerberos의 클라이언트 측을 지원 합니다. Kerberos 프린시 &lt;a href=&quot;../spi/loginmodule&quot;&gt; &lt;code&gt;LoginModule&lt;/code&gt; &lt;/a&gt; 을 인증하기 위해 LoginModule 을 구현하는 로그인 모듈이있을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="179c153fa31e392a5dae09bfb3ec12cf7382a77e" translate="yes" xml:space="preserve">
          <source>The Kerberos v5 mechanism (&quot;1.2.840.113554.1.2.2&quot;) will always be returned in this list when the indicated nametype is one of &lt;a href=&quot;gssname#NT_HOSTBASED_SERVICE&quot;&gt;&lt;code&gt;GSSName.NT_HOSTBASED_SERVICE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;gssname#NT_EXPORT_NAME&quot;&gt;&lt;code&gt;GSSName.NT_EXPORT_NAME&lt;/code&gt;&lt;/a&gt;, or &quot;1.2.840.113554.1.2.2.1&quot;.</source>
          <target state="translated">표시된 NAMETYPE 중 하나 일 때의 Kerberos V5기구 ( &quot;1.2.840.113554.1.2.2&quot;)는 항상이 목록에 반환됩니다 &lt;a href=&quot;gssname#NT_HOSTBASED_SERVICE&quot;&gt; &lt;code&gt;GSSName.NT_HOSTBASED_SERVICE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;gssname#NT_EXPORT_NAME&quot;&gt; &lt;code&gt;GSSName.NT_EXPORT_NAME&lt;/code&gt; &lt;/a&gt; , 또는 &quot;1.2.840.113554.1.2.2.1&quot;.</target>
        </trans-unit>
        <trans-unit id="1544cf9c5107663734ae872cc327b8154b4bc517" translate="yes" xml:space="preserve">
          <source>The Key interface is the top-level interface for all keys.</source>
          <target state="translated">키 인터페이스는 모든 키의 최상위 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0f7ba838a05da49357b31ae6823009d4f10f3dbe" translate="yes" xml:space="preserve">
          <source>The Key interface is the top-level interface for all keys. It defines the functionality shared by all key objects. All keys have three characteristics:</source>
          <target state="translated">키 인터페이스는 모든 키의 최상위 인터페이스입니다. 모든 주요 객체가 공유하는 기능을 정의합니다. 모든 키에는 세 가지 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf548aaac46d4e0f0b562c298e02a26e9e223aa6" translate="yes" xml:space="preserve">
          <source>The KeyPairGenerator class is used to generate pairs of public and private keys.</source>
          <target state="translated">KeyPairGenerator 클래스는 공개 및 개인 키 쌍을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84ce39b134b25304a741de41814f7513944cfe5b" translate="yes" xml:space="preserve">
          <source>The KeyPairGenerator class is used to generate pairs of public and private keys. Key pair generators are constructed using the &lt;code&gt;getInstance&lt;/code&gt; factory methods (static methods that return instances of a given class).</source>
          <target state="translated">KeyPairGenerator 클래스는 공개 및 개인 키 쌍을 생성하는 데 사용됩니다. 키 페어 생성기는 &lt;code&gt;getInstance&lt;/code&gt; 팩토리 메소드 (주어진 클래스의 인스턴스를 리턴하는 정적 메소드)를 사용하여 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="15b0ebadd884d0b51462c94b77021fc226c8b293" translate="yes" xml:space="preserve">
          <source>The KeyStore is instantiated from &lt;code&gt;provider&lt;/code&gt; if non-null. Otherwise, all installed providers are searched.</source>
          <target state="translated">키 저장소는 널이 아닌 경우 &lt;code&gt;provider&lt;/code&gt; 로부터 인스턴스화됩니다 . 그렇지 않으면 설치된 모든 제공자가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2ef01fdd78023f4e41a2332f54d31d4e897196" translate="yes" xml:space="preserve">
          <source>The KeyboardFocusManager is both a centralized location for client code to query for the focus owner and initiate focus changes, and an event dispatcher for all FocusEvents, WindowEvents related to focus, and KeyEvents.</source>
          <target state="translated">KeyboardFocusManager는 클라이언트 코드가 포커스 소유자를 쿼리하고 포커스 변경을 시작하는 중앙 집중식 위치이자 모든 FocusEvents, 포커스 관련 WindowEvents 및 KeyEvents에 대한 이벤트 디스패처입니다.</target>
        </trans-unit>
        <trans-unit id="fe9108e974a840f34cdac2d8957f8fc6f75c25d0" translate="yes" xml:space="preserve">
          <source>The KeyboardFocusManager is responsible for managing the active and focused Windows, and the current focus owner.</source>
          <target state="translated">KeyboardFocusManager는 활성 및 포커스가있는 Windows와 현재 포커스 소유자를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="c9b92722aba2c53f9e3ad23b73c28a03069188d3" translate="yes" xml:space="preserve">
          <source>The KeyboardFocusManager is responsible for managing the active and focused Windows, and the current focus owner. The focus owner is defined as the Component in an application that will typically receive all KeyEvents generated by the user. The focused Window is the Window that is, or contains, the focus owner. Only a Frame or a Dialog can be the active Window. The native windowing system may denote the active Window or its children with special decorations, such as a highlighted title bar. The active Window is always either the focused Window, or the first Frame or Dialog that is an owner of the focused Window.</source>
          <target state="translated">KeyboardFocusManager는 활성 및 포커스가있는 Windows와 현재 포커스 소유자를 관리합니다. 포커스 소유자는 일반적으로 사용자가 생성 한 모든 KeyEvent를 수신하는 응용 프로그램의 구성 요소로 정의됩니다. 포커스가있는 창은 포커스 소유자이거나 포커스 소유자를 포함하는 창입니다. 프레임 또는 대화 상자 만 활성 창이 될 수 있습니다. 기본 창 시스템은 강조 표시된 제목 표시 줄과 같은 특수 장식으로 활성 창 또는 하위 창을 나타낼 수 있습니다. 활성 창은 항상 초점이 맞춰진 창이거나 초점이 맞춰진 창 소유자 인 첫 번째 프레임 또는 대화 상자입니다.</target>
        </trans-unit>
        <trans-unit id="dfdf028492eeb6a2c0a7e187bb51caef0fe58094" translate="yes" xml:space="preserve">
          <source>The Khmer range with the Khmer digits.</source>
          <target state="translated">크메르 숫자가있는 크메르 범위입니다.</target>
        </trans-unit>
        <trans-unit id="ba0192d9ab92e21e9c2744dd9f7ef43296184075" translate="yes" xml:space="preserve">
          <source>The LDAPv3 protocol uses controls to send and receive additional data to affect the behavior of predefined operations. Controls can be sent along with any LDAP operation to the server. These are referred to as &lt;em&gt;request controls&lt;/em&gt;. For example, a &quot;sort&quot; control can be sent with an LDAP search operation to request that the results be returned in a particular order. Solicited and unsolicited controls can also be returned with responses from the server. Such controls are referred to as &lt;em&gt;response controls&lt;/em&gt;. For example, an LDAP server might define a special control to return change notifications.</source>
          <target state="translated">LDAPv3 프로토콜은 컨트롤을 사용하여 추가 데이터를 송수신하여 미리 정의 된 작업의 동작에 영향을줍니다. 모든 LDAP 조작과 함께 제어를 서버로 보낼 수 있습니다. 이를 &lt;em&gt;요청 제어&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어 &quot;정렬&quot;컨트롤을 LDAP 검색 작업과 함께 보내 특정 결과로 결과를 반환하도록 요청할 수 있습니다. 요청 및 요청되지 않은 제어는 서버의 응답으로 리턴 될 수도 있습니다. 이러한 컨트롤을 &lt;em&gt;응답 컨트롤&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어, LDAP 서버는 변경 알림을 반환하는 특수 컨트롤을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b009686e42e06098b246c404691be107aa2893" translate="yes" xml:space="preserve">
          <source>The Lao range with the Lao digits.</source>
          <target state="translated">라오스 숫자가있는 라오스 범위입니다.</target>
        </trans-unit>
        <trans-unit id="3d7e088fa5dee667531590ff7a47cda4787dd6af" translate="yes" xml:space="preserve">
          <source>The Latin (European) range with the Latin (ASCII) digits.</source>
          <target state="translated">라틴 (ASCII) 숫자가있는 라틴 (유럽) 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e69f4a3d93cbdffcb22365dd2d768eab2d0fbb22" translate="yes" xml:space="preserve">
          <source>The Left Arrow key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 작업 키인 왼쪽 화살표 키입니다.</target>
        </trans-unit>
        <trans-unit id="625f245af32d880495183dfc988c393be7c10c2c" translate="yes" xml:space="preserve">
          <source>The Lepcha range with the Lepcha digits.</source>
          <target state="translated">Lepcha 숫자가있는 Lepcha 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e247331a2fdfcd1f002adc01fbf899e2a1591f78" translate="yes" xml:space="preserve">
          <source>The Level class defines a set of standard logging levels that can be used to control logging output.</source>
          <target state="translated">Level 클래스는 로깅 출력을 제어하는 ​​데 사용할 수있는 표준 로깅 수준 세트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5e0b0c714c17843fb551c38291dba43f83549e84" translate="yes" xml:space="preserve">
          <source>The Level class defines a set of standard logging levels that can be used to control logging output. The logging Level objects are ordered and are specified by ordered integers. Enabling logging at a given level also enables logging at all higher levels.</source>
          <target state="translated">Level 클래스는 로깅 출력을 제어하는 ​​데 사용할 수있는 표준 로깅 수준 세트를 정의합니다. 로깅 레벨 오브젝트는 순서가 지정된 순서대로 지정됩니다. 특정 수준에서 로깅을 활성화하면 모든 상위 수준에서 로깅을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb102e7a522f2dead8bb60ac1334e542914f901" translate="yes" xml:space="preserve">
          <source>The Limbu range with the Limbu digits.</source>
          <target state="translated">Limbu 숫자가있는 Limbu 범위입니다.</target>
        </trans-unit>
        <trans-unit id="23341604b8e30c5db6f5082ffe273ce643ebf866" translate="yes" xml:space="preserve">
          <source>The LineEvent.Type inner class identifies what kind of event occurred on a line.</source>
          <target state="translated">LineEvent.Type 내부 클래스는 회선에서 어떤 종류의 이벤트가 발생했는지 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f4515bae178db99e414cd4419e58ab70e3a4ab78" translate="yes" xml:space="preserve">
          <source>The LineEvent.Type inner class identifies what kind of event occurred on a line. Static instances are provided for the common types (OPEN, CLOSE, START, and STOP).</source>
          <target state="translated">LineEvent.Type 내부 클래스는 회선에서 어떤 종류의 이벤트가 발생했는지 식별합니다. 정적 유형은 공통 유형 (OPEN, CLOSE, START 및 STOP)에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="82041c3f3458b7321d9e6904a9a2fbd85ff5e8fb" translate="yes" xml:space="preserve">
          <source>The ListSelectionListener that's added to the JLists selection model at installUI time, and whenever the JList.selectionModel property changes.</source>
          <target state="translated">installUI시 및 JList.selectionModel 속성이 변경 될 때마다 JList 선택 모델에 추가되는 ListSelectionListener입니다.</target>
        </trans-unit>
        <trans-unit id="9d8a5479edc0054602772a4f3eec0b96299fb21f" translate="yes" xml:space="preserve">
          <source>The ListSelectionListener that's added to the JLists selection model at installUI time, and whenever the JList.selectionModel property changes. When the selection changes we repaint the affected rows.</source>
          <target state="translated">installUI시 및 JList.selectionModel 속성이 변경 될 때마다 JList 선택 모델에 추가되는 ListSelectionListener입니다. 선택이 변경되면 영향을받은 행을 다시 그립니다.</target>
        </trans-unit>
        <trans-unit id="15a370cb868586ab99d868f607377364eaa66939" translate="yes" xml:space="preserve">
          <source>The Locale constructors have always specified that the language and the country param be two characters in length, although in practice they have accepted any length. The specification has now been relaxed to allow language codes of two to eight characters and country (region) codes of two to three characters, and in particular, three-letter language codes and three-digit region codes as specified in the IANA Language Subtag Registry. For compatibility, the implementation still does not impose a length constraint.</source>
          <target state="translated">로케일 생성자는 실제로 언어와 국가 매개 변수의 길이가 두 자로 지정되어 있지만 실제로는 길이를 허용합니다. 이 사양은 이제 2 ~ 8 자의 언어 코드 및 2 ~ 3 자의 국가 (지역) 코드, 특히 IANA 언어 하위 태그 레지스트리에 지정된 3 자리 언어 코드 및 3 자리 지역 코드를 허용하도록 완화되었습니다. . 호환성을 위해 구현시 여전히 길이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb678f5a8ea6de459807c825837564cfaf1f3ed6" translate="yes" xml:space="preserve">
          <source>The LogManager defines two optional system properties that allow control over the initial configuration, as specified in the &lt;a href=&quot;#readConfiguration()&quot;&gt;&lt;code&gt;readConfiguration()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">LogManager는 &lt;a href=&quot;#readConfiguration()&quot;&gt; &lt;code&gt;readConfiguration()&lt;/code&gt; &lt;/a&gt; 메서드에 지정된대로 초기 구성을 제어 할 수있는 두 가지 선택적 시스템 속성을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3bb20e6e58795891b26d0418b98b5c49029c3c3e" translate="yes" xml:space="preserve">
          <source>The LogManager defines two optional system properties that allow control over the initial configuration:</source>
          <target state="translated">LogManager는 초기 구성을 제어 할 수있는 두 가지 선택적 시스템 특성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3cca1e6f62e92b82a24f09973b67d35f6162ed74" translate="yes" xml:space="preserve">
          <source>The LogRecord class is serializable.</source>
          <target state="translated">LogRecord 클래스는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="37b5ec8719483e5837405faf74d2042c53b0e061" translate="yes" xml:space="preserve">
          <source>The Logger factory methods call this method to register each newly created Logger.</source>
          <target state="translated">로거 팩토리 메소드는이 메소드를 호출하여 새로 작성된 각 로거를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="16fa852d45e166564cfd7fb514ab7d4a6acfffbe" translate="yes" xml:space="preserve">
          <source>The Logging APIs offer both static and dynamic configuration control. Static control enables field service staff to set up a particular configuration and then re-launch the application with the new logging settings. Dynamic control allows for updates to the logging configuration within a currently running program. The APIs also allow for logging to be enabled or disabled for different functional areas of the system. For example, a field service engineer might be interested in tracing all AWT events, but might have no interest in socket events or memory management.</source>
          <target state="translated">로깅 API는 정적 및 동적 구성 제어를 모두 제공합니다. 정적 제어를 통해 현장 서비스 직원은 특정 구성을 설정 한 다음 새로운 로깅 설정으로 응용 프로그램을 다시 시작할 수 있습니다. 동적 제어를 통해 현재 실행중인 프로그램 내에서 로깅 구성을 업데이트 할 수 있습니다. API를 사용하면 시스템의 다른 기능 영역에 대해 로깅을 활성화하거나 비활성화 할 수 있습니다. 예를 들어, 현장 서비스 엔지니어는 모든 AWT 이벤트 추적에 관심이 있지만 소켓 이벤트 또는 메모리 관리에는 관심이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2c9dc56a0259f0e6bad38df059f2ef62f5a015" translate="yes" xml:space="preserve">
          <source>The LoginModule-specific options represent the options configured for this &lt;code&gt;LoginModule&lt;/code&gt; by an administrator or user in the login &lt;code&gt;Configuration&lt;/code&gt;. The options are defined by the &lt;code&gt;LoginModule&lt;/code&gt; itself and control the behavior within it. For example, a &lt;code&gt;LoginModule&lt;/code&gt; may define options to support debugging/testing capabilities. Options are defined using a key-value syntax, such as</source>
          <target state="translated">LoginModule 관련 옵션은 로그인 &lt;code&gt;Configuration&lt;/code&gt; 의 관리자 또는 사용자 가이 &lt;code&gt;LoginModule&lt;/code&gt; 에 대해 구성한 옵션을 나타냅니다 . 옵션은 &lt;code&gt;LoginModule&lt;/code&gt; 자체에 의해 정의되며 그 안에있는 동작을 제어합니다. 예를 들어 &lt;code&gt;LoginModule&lt;/code&gt; 은 디버깅 / 테스트 기능을 지원하는 옵션을 정의 할 수 있습니다. 옵션은 다음과 같은 키-값 구문을 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="873df94afa4e7ad82e48e9073fb806c35bb167b5" translate="yes" xml:space="preserve">
          <source>The MAC result is stored in &lt;code&gt;output&lt;/code&gt;, starting at &lt;code&gt;outOffset&lt;/code&gt; inclusive.</source>
          <target state="translated">MAC 결과는 &lt;code&gt;outOffset&lt;/code&gt; 부터 시작하여 &lt;code&gt;output&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="df379351016742258da0a9b0e11610edb7e1d510" translate="yes" xml:space="preserve">
          <source>The MBean Server can be queried for MBeans that meet a particular condition, using its &lt;a href=&quot;mbeanserver#queryNames(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt;&lt;code&gt;queryNames&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mbeanserver#queryMBeans(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt;&lt;code&gt;queryMBeans&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;queryexp&quot;&gt;&lt;code&gt;QueryExp&lt;/code&gt;&lt;/a&gt; parameter to the method can be any implementation of the interface &lt;code&gt;QueryExp&lt;/code&gt;, but it is usually best to obtain the &lt;code&gt;QueryExp&lt;/code&gt; value by calling the static methods in this class. This is particularly true when querying a remote MBean Server: a custom implementation of the &lt;code&gt;QueryExp&lt;/code&gt; interface might not be present in the remote MBean Server, but the methods in this class return only standard classes that are part of the JMX implementation.</source>
          <target state="translated">MBean 서버는 &lt;a href=&quot;mbeanserver#queryNames(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt; &lt;code&gt;queryNames&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;mbeanserver#queryMBeans(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt; &lt;code&gt;queryMBeans&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 특정 조건을 충족하는 MBean에 대해 쿼리 할 수 ​​있습니다 . &lt;a href=&quot;queryexp&quot;&gt; &lt;code&gt;QueryExp&lt;/code&gt; 를의&lt;/a&gt; 방법에 파라미터 인터페이스의 어떤 구현 될 수 &lt;code&gt;QueryExp&lt;/code&gt; 를 있지만 수득하는 것이 최상이다 &lt;code&gt;QueryExp&lt;/code&gt; 를의 이 클래스의 정적 메소드를 호출하여 값. 원격 MBean 서버를 쿼리 할 때 특히 그렇습니다. &lt;code&gt;QueryExp&lt;/code&gt; 인터페이스 의 사용자 정의 구현이 원격 MBean 서버에 없을 수도 있지만이 클래스의 메서드는 JMX 구현의 일부인 표준 클래스 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e20974e279464971ac54f4c492ac718451f3fb7" translate="yes" xml:space="preserve">
          <source>The MBean Server can be queried for MBeans that meet a particular condition, using its &lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryNames&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryMBeans&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;queryexp&quot;&gt;&lt;code&gt;QueryExp&lt;/code&gt;&lt;/a&gt; parameter to the method can be any implementation of the interface &lt;code&gt;QueryExp&lt;/code&gt;, but it is usually best to obtain the &lt;code&gt;QueryExp&lt;/code&gt; value by calling the static methods in this class. This is particularly true when querying a remote MBean Server: a custom implementation of the &lt;code&gt;QueryExp&lt;/code&gt; interface might not be present in the remote MBean Server, but the methods in this class return only standard classes that are part of the JMX implementation.</source>
          <target state="translated">&lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryNames&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryMBeans&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 특정 조건을 충족하는 MBean에 대해 MBean 서버를 조회 할 수 있습니다 . &lt;a href=&quot;queryexp&quot;&gt; &lt;code&gt;QueryExp&lt;/code&gt; 를의&lt;/a&gt; 방법에 파라미터 인터페이스의 어떤 구현 될 수 &lt;code&gt;QueryExp&lt;/code&gt; 를 있지만 수득하는 것이 최상이다 &lt;code&gt;QueryExp&lt;/code&gt; 를의 이 클래스의 정적 메소드를 호출하여 값. 이는 원격 MBean 서버를 조회 할 때 특히 그렇습니다. &lt;code&gt;QueryExp&lt;/code&gt; 인터페이스 의 사용자 정의 구현이 원격 MBean 서버에 없을 수 있지만이 클래스의 메소드는 JMX 구현의 일부인 표준 클래스 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9b55c952d8b9667a8cd83b230d433a9d1d3bc37d" translate="yes" xml:space="preserve">
          <source>The MBean Server used is the one returned by &lt;a href=&quot;queryeval#getMBeanServer()&quot;&gt;&lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 된 MBean 서버는 &lt;a href=&quot;queryeval#getMBeanServer()&quot;&gt; &lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="72d1d3a5c29db56a086580b10e87cee9417c2769" translate="yes" xml:space="preserve">
          <source>The MBean Server used is the one returned by &lt;a href=&quot;queryeval#getMBeanServer--&quot;&gt;&lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 된 MBean 서버는 &lt;a href=&quot;queryeval#getMBeanServer--&quot;&gt; &lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="21324a38f03c31ace3a1e422ca3454c83ac8dbb8" translate="yes" xml:space="preserve">
          <source>The MBean is already registered in the repository.</source>
          <target state="translated">MBean은 이미 저장소에 등록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="43753879ff4a9ab9e94f41c105bc04ec605906f3" translate="yes" xml:space="preserve">
          <source>The MBean must have a listener that exactly matches the given &lt;code&gt;listener&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, and &lt;code&gt;handback&lt;/code&gt; parameters. If there is more than one such listener, only one is removed.</source>
          <target state="translated">MBean에는 지정된 &lt;code&gt;listener&lt;/code&gt; , &lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;handback&lt;/code&gt; 매개 변수 와 정확히 일치하는 수신기가 있어야합니다 . 이러한 리스너가 둘 이상 있으면 하나만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="30152426051a3aa7c2787f9bb448c65fd9d96573" translate="yes" xml:space="preserve">
          <source>The MBean server connection through which the methods of a proxy using this handler are forwarded.</source>
          <target state="translated">이 핸들러를 사용하는 프록시 메소드가 전달되는 MBean 서버 연결입니다.</target>
        </trans-unit>
        <trans-unit id="5a6b667365181658d557141a79bdcd9ae1d79d48" translate="yes" xml:space="preserve">
          <source>The MBeanServer reference is internally kept. This will allow &lt;code&gt;findMBeanServer&lt;/code&gt; to return a reference to this MBeanServer object.</source>
          <target state="translated">MBeanServer 참조는 내부적으로 유지됩니다. 이렇게하면 &lt;code&gt;findMBeanServer&lt;/code&gt; 가이 MBeanServer 오브젝트에 대한 참조를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce98176f741b29841e04388f314ecc341556fb9" translate="yes" xml:space="preserve">
          <source>The MBeanServerBuilder makes it possible to wrap the MBeanServers returned by the default MBeanServerBuilder implementation, for the purpose of e.g. adding an additional security layer.</source>
          <target state="translated">MBeanServerBuilder를 사용하면 추가 보안 계층 ​​추가와 같은 목적으로 기본 MBeanServerBuilder 구현에서 리턴 한 MBeanServer를 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebb8ef1bdda79f2bf977d8f0f2c843f817752de" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-1&quot; message digest</source>
          <target state="translated">&quot;SHA-1&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="c43e787474141d0bb72e21314b04491164ecd29c" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-1&quot; message digest.</source>
          <target state="translated">&quot;SHA-1&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="32c91218272c1ce637c8a43d4efa8d7be714817e" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-224&quot; message digest</source>
          <target state="translated">&quot;SHA-224&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="ded68968556406a67098d9312cb325eb7740b1a7" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-224&quot; message digest.</source>
          <target state="translated">&quot;SHA-224&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="f4145abd624d13b5fd6c271646d555d996874e76" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-256&quot; message digest</source>
          <target state="translated">&quot;SHA-256&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="30567a972c0ebfa4faa9759c8c4f5615d0736a78" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-256&quot; message digest.</source>
          <target state="translated">&quot;SHA-256&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="ffe8090c162f81eda0ca11ad18b4d00f0460668a" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-384&quot; message digest</source>
          <target state="translated">&quot;SHA-384&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="8f743fd5434a0de8774dcd2c54b80badfe4a3dec" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-384&quot; message digest.</source>
          <target state="translated">&quot;SHA-384&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="9fcd13c9a51cff2dfe34d11d75622669ff7a2f6f" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512 message digest</source>
          <target state="translated">SHA-512 메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="773fa0838097295208f32770a4edbdf66bd50a46" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512 message digest.</source>
          <target state="translated">SHA-512 메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="c6fdeb15a6d0d672938ac7162d09074690eabb53" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512/224 message digest</source>
          <target state="translated">SHA-512 / 224 메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="6b740423dca40861f104766ac050de56d78d3f30" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512/256 message digest</source>
          <target state="translated">SHA-512 / 256 메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="516e21a61c986db4b650efb7f3b9edffb19e1c28" translate="yes" xml:space="preserve">
          <source>The MIDI 1.0 Specification defines both 7-bit controllers and 14-bit controllers. Continuous controllers, such as wheels and sliders, typically have 14 bits (two MIDI bytes), while discrete controllers, such as switches, typically have 7 bits (one MIDI byte). Refer to the specification to see the expected resolution for each type of control.</source>
          <target state="translated">MIDI 1.0 사양은 7 비트 컨트롤러와 14 비트 컨트롤러를 모두 정의합니다. 휠 및 슬라이더와 같은 연속 컨트롤러에는 일반적으로 14 비트 (2 개의 MIDI 바이트)가 있고 스위치와 같은 개별 컨트롤러에는 일반적으로 7 비트 (1 개의 MIDI 바이트)가 있습니다. 각 제어 유형에 대한 예상 해상도를 보려면 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b90ca10823dacdb7ec1aff6e9c338eb2858be24" translate="yes" xml:space="preserve">
          <source>The MIDI 1.0 specification provides for 16 channels, so this method returns an array of at least 16 elements. However, if this synthesizer doesn't make use of all 16 channels, some of the elements of the array might be &lt;code&gt;null&lt;/code&gt;, so you should check each element before using it.</source>
          <target state="translated">MIDI 1.0 사양은 16 개의 채널을 제공하므로이 방법은 16 개 이상의 요소 배열을 반환합니다. 그러나이 신시사이저가 16 개의 채널을 모두 사용하지 않으면 배열의 일부 요소가 &lt;code&gt;null&lt;/code&gt; 이 될 수 있으므로 사용하기 전에 각 요소를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="049c7ab3e0f2c876b50b46fe3789a8747dae1e9c" translate="yes" xml:space="preserve">
          <source>The MIDI channel on which this voice is playing.</source>
          <target state="translated">이 음색이 재생되는 MIDI 채널입니다.</target>
        </trans-unit>
        <trans-unit id="b52e6c1511e484eaf10f9c3556aee2243b42e67c" translate="yes" xml:space="preserve">
          <source>The MIDI channel on which this voice is playing. The value is a zero-based channel number if the voice is active, or unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 연주되는 MIDI 채널입니다. 음성이 활성화 된 경우이 값은 0부터 시작하는 채널 번호이거나 음성이 비활성화 된 경우 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="526debeb157a66f1367b032953ad21ed8a2a5fd6" translate="yes" xml:space="preserve">
          <source>The MIDI message data.</source>
          <target state="translated">MIDI 메시지 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="72e471be8e18253cd2fa90755b2430be47a7c9c7" translate="yes" xml:space="preserve">
          <source>The MIDI message data. The first byte is the status byte for the message; subsequent bytes up to the length of the message are data bytes for this message.</source>
          <target state="translated">MIDI 메시지 데이터 첫 번째 바이트는 메시지의 상태 바이트입니다. 메시지 길이까지의 후속 바이트는이 메시지의 데이터 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="317772b1f4d7bef7e847f7a2507ef5cf22a36f76" translate="yes" xml:space="preserve">
          <source>The MIDI note that this voice is playing.</source>
          <target state="translated">이 음색이 재생되고있는 MIDI 노트입니다.</target>
        </trans-unit>
        <trans-unit id="09d0f1e1fda22537e5c3106cad4d736b151fe66f" translate="yes" xml:space="preserve">
          <source>The MIDI note that this voice is playing. The range for an active voice is from 0 to 127 in semitones, with 60 referring to Middle C. The value is unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 연주되고있는 MIDI 음표. 활성 음성의 범위는 반음 단위로 0에서 127까지이며 60은 중간 C를 나타냅니다. 음성이 비활성이면 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f275ac1e77302fd1f9c984942071af0000235dd" translate="yes" xml:space="preserve">
          <source>The MIDI specification does not dictate whether notes that are already sounding should switch to the new instrument (timbre) or continue with their original timbre until terminated by a note-off.</source>
          <target state="translated">MIDI 사양은 이미 소리가 나는 음이 새로운 악기 (음색)로 전환되어야하는지 또는 음표로 종료 될 때까지 원래의 음색으로 계속해야하는지 여부를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="883ec76cbd3a1ad3d350032e79eb664e1f1a784b" translate="yes" xml:space="preserve">
          <source>The MIDI specification stipulates that pitch bend be a 14-bit value, where zero is maximum downward bend, 16383 is maximum upward bend, and 8192 is the center (no pitch bend). The actual amount of pitch change is not specified; it can be changed by a pitch-bend sensitivity setting. However, the General MIDI specification says that the default range should be two semitones up and down from center.</source>
          <target state="translated">MIDI 사양은 피치 벤드를 14 비트 값으로 규정합니다. 여기서 0은 최대 하향 벤드, 16383은 최대 상향 벤드, 8192는 중앙 (피치 벤드 없음)입니다. 실제 피치 변경 량은 지정되지 않습니다. 피치 벤드 감도 설정으로 변경할 수 있습니다. 그러나 일반 MIDI 사양에 따르면 기본 범위는 중앙에서 위아래로 두 반음이어야합니다.</target>
        </trans-unit>
        <trans-unit id="635898bd1d6ec018c38dd8a4feda9d061e0d6d2b" translate="yes" xml:space="preserve">
          <source>The MIDI specification stipulates that pitch bend be a 14-bit value, where zero is maximum downward bend, 16383 is maximum upward bend, and 8192 is the center (no pitch bend). The actual amount of pitch change is not specified; it can be changed by a pitch-bend sensitivity setting. However, the General MIDI specification says that the default range should be two semitones up and down from center. It is possible that the underlying synthesizer does not support this MIDI message. In order to verify that &lt;code&gt;setPitchBend&lt;/code&gt; was successful, use &lt;code&gt;getPitchBend&lt;/code&gt;.</source>
          <target state="translated">MIDI 사양에서는 피치 벤드가 14 비트 값이며, 0은 최대 하향 벤드, 16383은 최대 상향 벤드, 8192는 중심 (피치 벤드 없음)입니다. 실제 피치 변경 량은 지정되어 있지 않습니다. 피치 벤드 감도 설정으로 변경할 수 있습니다. 그러나 일반 MIDI 사양에 따르면 기본 범위는 중앙에서 위 아래로 두 개의 반음이어야합니다. 기본 신디사이저가이 MIDI 메시지를 지원하지 않을 수 있습니다. &lt;code&gt;setPitchBend&lt;/code&gt; 가 성공 했는지 확인 하려면 &lt;code&gt;getPitchBend&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cc37db06eee182d506afa49c0c246f6a9c01a35" translate="yes" xml:space="preserve">
          <source>The MIDI standard expresses MIDI data in bytes. However, because Java&amp;trade; uses signed bytes, the Java Sound API uses integers instead of bytes when expressing MIDI data. For example, the &lt;a href=&quot;#getStatus()&quot;&gt;&lt;code&gt;getStatus()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;MidiMessage&lt;/code&gt; returns MIDI status bytes as integers. If you are processing MIDI data that originated outside Java Sound and now is encoded as signed bytes, the bytes can be converted to integers using this conversion:</source>
          <target state="translated">MIDI 표준은 MIDI 데이터를 바이트 단위로 표현합니다. 그러나 Java &amp;trade;는 부호있는 바이트를 사용하기 때문에 Java Sound API는 MIDI 데이터를 표현할 때 바이트 대신 정수를 사용합니다. 예를 들어, &lt;code&gt;MidiMessage&lt;/code&gt; 의 &lt;a href=&quot;#getStatus()&quot;&gt; &lt;code&gt;getStatus()&lt;/code&gt; &lt;/a&gt; 메서드 는 MIDI 상태 바이트를 정수로 반환합니다. Java Sound 외부에서 생성 된 MIDI 데이터를 처리 중이고 이제 부호있는 바이트로 인코딩 된 경우 다음 변환을 사용하여 바이트를 정수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c526e09fb95606778bb5e764a54a0e9f208fc206" translate="yes" xml:space="preserve">
          <source>The MIDI standard expresses MIDI data in bytes. However, because Java&lt;sup id=&quot;integersVsBytes&quot;&gt;TM&lt;/sup&gt; uses signed bytes, the Java Sound API uses integers instead of bytes when expressing MIDI data. For example, the &lt;a href=&quot;midimessage#getStatus--&quot;&gt;&lt;code&gt;getStatus()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;MidiMessage&lt;/code&gt; returns MIDI status bytes as integers. If you are processing MIDI data that originated outside Java Sound and now is encoded as signed bytes, the bytes can can be converted to integers using this conversion:</source>
          <target state="translated">MIDI 표준은 MIDI 데이터를 바이트 단위로 표현합니다. 그러나 Java &lt;sup id=&quot;integersVsBytes&quot;&gt;TM&lt;/sup&gt; 는 부호있는 바이트를 사용 하기 때문에 Java Sound API는 MIDI 데이터를 표현할 때 바이트 대신 정수를 사용합니다. 예를 들어 &lt;code&gt;MidiMessage&lt;/code&gt; 의 &lt;a href=&quot;midimessage#getStatus--&quot;&gt; &lt;code&gt;getStatus()&lt;/code&gt; &lt;/a&gt; 메서드 는 MIDI 상태 바이트를 정수로 반환합니다. Java Sound 외부에서 시작하여 부호있는 바이트로 인코딩 된 MIDI 데이터를 처리하는 경우 다음 변환을 사용하여 바이트를 정수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c8a2781b35fa31817c29abe30b50e8043af665c" translate="yes" xml:space="preserve">
          <source>The MIDI tracks in this sequence.</source>
          <target state="translated">이 순서에서 MIDI 트랙.</target>
        </trans-unit>
        <trans-unit id="23a350af8445001f598c4651a4f45324e9f33c23" translate="yes" xml:space="preserve">
          <source>The MLet text file's base URL.</source>
          <target state="translated">MLet 텍스트 파일의 기본 URL입니다.</target>
        </trans-unit>
        <trans-unit id="db0ce9ae1e5d2f89a8f312663fdfbed2b32ba495" translate="yes" xml:space="preserve">
          <source>The MXBean concept provides a simple way to code an MBean that only references a predefined set of types, the ones defined by &lt;a href=&quot;openmbean/package-summary&quot;&gt;&lt;code&gt;javax.management.openmbean&lt;/code&gt;&lt;/a&gt;. In this way, you can be sure that your MBean will be usable by any client, including remote clients, without any requirement that the client have access to &lt;em&gt;model-specific classes&lt;/em&gt; representing the types of your MBeans.</source>
          <target state="translated">MXBean 개념은 &lt;a href=&quot;openmbean/package-summary&quot;&gt; &lt;code&gt;javax.management.openmbean&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 사전 정의 된 유형의 세트 만 참조하는 MBean을 코딩하는 간단한 방법을 제공합니다 . 이러한 방식으로, 클라이언트가 MBean 유형을 나타내는 &lt;em&gt;모델 특정 클래스에&lt;/em&gt; 액세스 할 필요없이 원격 클라이언트를 포함한 모든 클라이언트가 MBean을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e33c92fe4338e85410252cbf5f86c27123acc080" translate="yes" xml:space="preserve">
          <source>The Malayalam range with the Malayalam digits.</source>
          <target state="translated">Malayalam 숫자가있는 Malayalam 범위입니다.</target>
        </trans-unit>
        <trans-unit id="d4a3d1afcec2a7b84cb429f3bcbbf430180a0aa8" translate="yes" xml:space="preserve">
          <source>The ManageReferral control's assigned object identifier is 2.16.840.1.113730.3.4.2.</source>
          <target state="translated">ManageReferral 컨트롤의 할당 된 개체 식별자는 2.16.840.1.113730.3.4.2입니다.</target>
        </trans-unit>
        <trans-unit id="f0c9875b8d07e007e2745fc0af6fe732b94df483" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes.</source>
          <target state="translated">매니페스트 클래스는 매니페스트 항목 이름과 관련 속성을 유지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f91edbc800e6ebe0a97d46777ffeab5dd79019f" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes. There are main Manifest Attributes as well as per-entry Attributes. For information on the Manifest format, please see the  Manifest format specification.</source>
          <target state="translated">매니페스트 클래스는 매니페스트 항목 이름과 관련 속성을 유지하는 데 사용됩니다. 항목 별 속성뿐만 아니라 주요 매니페스트 속성이 있습니다. 매니페스트 형식에 대한 자세한 내용은 매니페스트 형식 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b08c1dceec8f387af3ac7117a090db5f90ca9a8" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes. There are main Manifest Attributes as well as per-entry Attributes. For information on the Manifest format, please see the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt; Manifest format specification&lt;/a&gt;.</source>
          <target state="translated">Manifest 클래스는 Manifest 항목 이름 및 관련 속성을 유지하는 데 사용됩니다. 주요 매니페스트 속성과 항목 별 속성이 있습니다. 매니페스트 형식에 대한 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;매니페스트 형식 사양을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a14dcb9ffe833bd8ff0c3971c624e1ee8fa1ea44" translate="yes" xml:space="preserve">
          <source>The MediaSize is in turn used to locate the MediaSizeName object. This method may return null if the closest matching MediaSize has no corresponding Media instance.</source>
          <target state="translated">MediaSize는 MediaSizeName 개체를 찾는 데 사용됩니다. 가장 일치하는 MediaSize에 해당하는 Media 인스턴스가없는 경우이 메서드는 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7f2589c5eb6fefc0630c3f00ed4bcf6743212bf" translate="yes" xml:space="preserve">
          <source>The MediaType instance for 6 3/4 envelope, 3 5/8 x 6 1/2 in.</source>
          <target state="translated">6 3/4 봉투, 3 5/8 x 6 1/2 인치에 대한 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="573f4b6872edf71d06ba58486250a54311c264a2" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering A, 8 1/2 x 11 in.</source>
          <target state="translated">Engineering A의 MediaType 인스턴스, 8 1/2 x 11 인치.</target>
        </trans-unit>
        <trans-unit id="64d3072107241435185f88936c6286ff514d147e" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering B, 11 x 17 in.</source>
          <target state="translated">Engineering B, 11 x 17 인치의 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="c7692968c3215d63e31ac87679acd24d403571f9" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering C, 17 x 22 in.</source>
          <target state="translated">Engineering C의 MediaType 인스턴스, 17 x 22 인치.</target>
        </trans-unit>
        <trans-unit id="9f478c8d9d5bcb2ea8dcf961f52385b3f2895b9b" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering D, 22 x 34 in.</source>
          <target state="translated">Engineering D의 MediaType 인스턴스, 22 x 34 인치.</target>
        </trans-unit>
        <trans-unit id="dbaba1c80bc3cfe1b7c16c807a907a7e87387b83" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering E, 34 x 44 in.</source>
          <target state="translated">Engineering E의 MediaType 인스턴스, 34 x 44 인치</target>
        </trans-unit>
        <trans-unit id="0b90d28550428199920f8f10dbe0d35f58b47e46" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Executive, 7 1/4 x 10 1/2 in.</source>
          <target state="translated">Executive 용 MediaType 인스턴스, 7 1/4 x 10 1/2 인치.</target>
        </trans-unit>
        <trans-unit id="54db702c63c3eba7e3cf9613a7e24e501b5591f5" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Folio, 8 1/2 x 13 in.</source>
          <target state="translated">Folio 용 MediaType 인스턴스, 8 1/2 x 13 인치</target>
        </trans-unit>
        <trans-unit id="ca7bc12d3f763cdf64763c795bba0f7408968808" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO Designated Long, 110 x 220 mm.</source>
          <target state="translated">ISO Designated Long, 110 x 220mm에 대한 MediaType 인스턴스입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
