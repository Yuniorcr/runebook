<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="0722074a59b34b3ba484f8bc879b29bc05ad8807" translate="yes" xml:space="preserve">
          <source>If client code has explicitly set the focusability of a Component by either overriding &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; or &lt;code&gt;Component.isFocusable()&lt;/code&gt;, or by calling &lt;code&gt;Component.setFocusable()&lt;/code&gt;, then a DefaultFocusTraversalPolicy behaves exactly like a ContainerOrderFocusTraversalPolicy. If, however, the Component is relying on default focusability, then a DefaultFocusTraversalPolicy will reject all Components with non-focusable peers. This is the default FocusTraversalPolicy for all AWT Containers.</source>
          <target state="translated">클라이언트 코드가 명시 적 중 하나를 대체하여 구성 요소의 포커스 특성을 설정 한 경우 &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; 또는 &lt;code&gt;Component.isFocusable()&lt;/code&gt; , 또는 호출하여 &lt;code&gt;Component.setFocusable()&lt;/code&gt; , 후 정확히 ContainerOrderFocusTraversalPolicy가 같은 DefaultFocusTraversalPolicy의 동작합니다. 그러나 구성 요소가 기본 초점 기능에 의존하는 경우 DefaultFocusTraversalPolicy는 초점을 맞출 수없는 피어가있는 모든 구성 요소를 거부합니다. 이는 모든 AWT 컨테이너에 대한 기본 FocusTraversalPolicy입니다.</target>
        </trans-unit>
        <trans-unit id="6e53a4db1482395c02ce01ebbf19081343f35a43" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 생성되는 경우 해당 예외는이 메서드에서 throw되지 않습니다. &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; &lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="aa5def33651e6193aa37639feee2e1bacd4151be" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 발생하면이 메소드에서 해당 예외가 발생하지 않습니다. &lt;a href=&quot;../jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 을&lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="239b3d190809a5bb14183b924e8a7fef0e270a8a" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; with type &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt;&lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 발생하면이 메소드에서 해당 예외가 발생하지 않습니다. &lt;a href=&quot;jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; &lt;/a&gt; 유형 &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt; &lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt; 을&lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="e50776b9b1e158d35a0ee5b01de8d5ed7f3a4764" translate="yes" xml:space="preserve">
          <source>If concurrency support is desired, there are the following additional implications. The code path for any DocumentListener implementation and any UndoListener implementation must be threadsafe, and not access the component lock if trying to be safe from deadlocks. The &lt;code&gt;repaint&lt;/code&gt; and &lt;code&gt;revalidate&lt;/code&gt; methods on JComponent are safe.</source>
          <target state="translated">동시성 지원이 필요한 경우 다음과 같은 추가 의미가 있습니다. DocumentListener 구현 및 UndoListener 구현에 대한 코드 경로는 스레드로부터 안전해야하며 교착 상태로부터 보호하려는 경우 구성 요소 잠금에 액세스하지 않아야합니다. JComponent 의 &lt;code&gt;repaint&lt;/code&gt; 및 &lt;code&gt;revalidate&lt;/code&gt; 메서드는 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6cc58710f7a52a62031b39086a811bf5c62f9be6" translate="yes" xml:space="preserve">
          <source>If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.</source>
          <target state="translated">corePoolSize 이상의 스레드가 실행중인 경우 실행자는 항상 새 스레드를 추가하는 대신 요청 큐를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="cb543f07d153ad84e16f6614709ff0723e83f00b" translate="yes" xml:space="preserve">
          <source>If currencyTimeLimit is &amp;gt; 0, then the new value for the attribute is cached in the attribute descriptor's 'value' field and the 'lastUpdatedTimeStamp' field is set to the current time stamp.</source>
          <target state="translated">currencyTimeLimit이&amp;gt; 0이면 속성의 새 값이 속성 설명 자의 'value'필드에 캐시되고 'lastUpdatedTimeStamp'필드가 현재 시간 소인으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="318a070d46817b0d3e2904d4f73faabc24bf182e" translate="yes" xml:space="preserve">
          <source>If current thread is interrupted, throw InterruptedException.</source>
          <target state="translated">현재 스레드가 중단 된 경우 InterruptedException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d2831e950ddf2d38fc039e2e83359dc77d52eecc" translate="yes" xml:space="preserve">
          <source>If data has already been sent on the connection, it continues to flow during this handshake. When the handshake completes, this will be signaled with an event. This method is synchronous for the initial handshake on a connection and returns when the negotiated handshake is complete. Some protocols may not support multiple handshakes on an existing socket and may throw an IOException.</source>
          <target state="translated">연결에서 데이터가 이미 전송 된 경우이 핸드 셰이크 동안 데이터가 계속 흐릅니다. 핸드 셰이크가 완료되면 이벤트가 표시됩니다. 이 메소드는 연결의 초기 핸드 셰이크와 동기화되며 협상 된 핸드 셰이크가 완료되면 리턴합니다. 일부 프로토콜은 기존 소켓에서 다중 핸드 셰이크를 지원하지 않을 수 있으며 IOException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9eaed7fbd77713f034b874df556fc6a3657252" translate="yes" xml:space="preserve">
          <source>If data is specified for a &lt;code&gt;Node&lt;/code&gt; which does not support data.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 대한 데이터가 지정된 경우 지원하지 않는 .</target>
        </trans-unit>
        <trans-unit id="a23edc5313c1114129c0451e0f085c188db85181" translate="yes" xml:space="preserve">
          <source>If different docs have different bindings specified, then only two values of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; make sense, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">다른 문서에 서로 다른 바인딩이 지정되어 있으면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의&lt;/a&gt; 두 값만 의미가 있으며 다른 값을 지정하면 작업이 제출 될 때 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6a5c3e077d48f57da30ae30c448c6f813a923be7" translate="yes" xml:space="preserve">
          <source>If different docs have different sheet collations specified, then only one value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; is permitted, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">다른 문서에 다른 시트 데이터 정렬이 지정된 경우 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값은 하나만 허용되며 다른 값이 지정된 경우 작업을 제출하면 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4cc730ea4ab4177fe6780dd6b3762cbb0dc9f71f" translate="yes" xml:space="preserve">
          <source>If disabled, only the name and class of the object is returned. If enabled, the object will be returned.</source>
          <target state="translated">비활성화하면 개체의 이름과 클래스 만 반환됩니다. 활성화하면 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="768caddc9c01e6493ed6902aeea52fa3f4bd3950" translate="yes" xml:space="preserve">
          <source>If dragger is not null it is messaged with completeDrag.</source>
          <target state="translated">dragger가 null이 아닌 경우 completeDrag 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ee0a7ef7d597d86c66ef2b09b41b3a0ba000faa" translate="yes" xml:space="preserve">
          <source>If dragger is not null it is messaged with continueDrag.</source>
          <target state="translated">dragger가 null이 아닌 경우 continueDrag로 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="db742d57b076cafc55a417d3693f22f0799621fd" translate="yes" xml:space="preserve">
          <source>If dynamic layout is currently inactive then Containers re-layout their components when resizing is completed. As a result the &lt;code&gt;Component.validate()&lt;/code&gt; method will be invoked only once per resize. If dynamic layout is currently active then Containers re-layout their components on every native resize event and the &lt;code&gt;validate()&lt;/code&gt; method will be invoked each time. The OS/WM support can be queried using the getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) method. This property will reflect the platform capability but is not sufficient to tell if it is presently enabled.</source>
          <target state="translated">동적 레이아웃이 현재 비활성화 된 경우 컨테이너는 크기 조정이 완료 될 때 구성 요소를 다시 레이아웃합니다. 결과적으로 &lt;code&gt;Component.validate()&lt;/code&gt; 메서드는 크기 조정 당 한 번만 호출됩니다. 동적 레이아웃이 현재 활성화 된 경우 컨테이너는 모든 기본 크기 조정 이벤트에서 구성 요소를 다시 레이아웃하고 &lt;code&gt;validate()&lt;/code&gt; 메서드가 매번 호출됩니다. OS / WM 지원은 getDesktopProperty ( &quot;awt.dynamicLayoutSupported&quot;) 메서드를 사용하여 쿼리 할 수 ​​있습니다. 이 속성은 플랫폼 기능을 반영하지만 현재 활성화되어 있는지 여부를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c6f6022b3d9e0a350f4a712d1847c54f77b4d41" translate="yes" xml:space="preserve">
          <source>If editing, the &lt;code&gt;Component&lt;/code&gt; that is handling the editing.</source>
          <target state="translated">편집하는 경우 편집을 처리하는 &lt;code&gt;Component&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f896ef7bc7275d3c393aa1c9ea95576d1ef92625" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than 0, the result will have the dimensions of the other &lt;code&gt;Rectangle&lt;/code&gt;. If both &lt;code&gt;Rectangle&lt;/code&gt;s have at least one dimension less than 0, the result will have at least one dimension less than 0.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 이 0보다 작은 차원을 갖는 경우 결과는 다른 &lt;code&gt;Rectangle&lt;/code&gt; 의 차원을 갖습니다 . 모두 &lt;code&gt;Rectangle&lt;/code&gt; 경우 0보다 작은 차원이 하나 이상 결과는 0보다 작은 차원이 하나 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="39bac83a50271cce4e40efc5165cbf9b9a9d7c02" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. If only one has a dimension less than zero, then the result will be a copy of the other &lt;code&gt;Rectangle&lt;/code&gt;. If both have dimension less than zero, then the result will have at least one dimension less than zero.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 중 하나에 0보다 작은 치수가 있으면 &lt;a href=&quot;#NonExistent&quot;&gt;존재하지 않는&lt;/a&gt; 직사각형에 대한 규칙이 적용됩니다. 하나의 차원이 0보다 작은 경우 결과는 다른 &lt;code&gt;Rectangle&lt;/code&gt; 의 복사본이 됩니다. 둘 다 0보다 작은 차원이 있으면 결과에 0보다 작은 차원이 하나 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="76142416fc4a8b368750309700f44557ecfd75c6" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has one or both dimensions equal to 0, the result along those axes with 0 dimensions will be equivalent to the results obtained by adding the corresponding origin coordinate to the result rectangle along that axis, similar to the operation of the &lt;a href=&quot;#add(java.awt.Point)&quot;&gt;&lt;code&gt;add(Point)&lt;/code&gt;&lt;/a&gt; method, but contribute no further dimension beyond that.</source>
          <target state="translated">어느 경우 &lt;code&gt;Rectangle&lt;/code&gt; 을 가지고 또는 두 차원 모두가 0, 0 크기와 그 축에 따른 결과는 대응 기원의 동작과 유사한 그 축에 따라 결과 직사각형의 좌표를 가산 한 결과에 해당 할 것이다 &lt;a href=&quot;#add(java.awt.Point)&quot;&gt; &lt;code&gt;add(Point)&lt;/code&gt; &lt;/a&gt; 방법이지만 그 이상의 차원은 기여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e4a2225fea7b35153360c5ca3721807756a8d75" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.</source>
          <target state="translated">어느 경우 &lt;code&gt;elem&lt;/code&gt; 또는 &lt;code&gt;htmlText&lt;/code&gt; 매개 변수가 &lt;code&gt;null&lt;/code&gt; , 변경은 문서에 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b1071c4cdf25b92ce3f411ba460944872014a99" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;fixedCellWidth&lt;/code&gt; or &lt;code&gt;fixedCellHeight&lt;/code&gt; haven't been specified, heuristics are used. If the model is empty, the width is the &lt;code&gt;fixedCellWidth&lt;/code&gt;, if greater than &lt;code&gt;0&lt;/code&gt;, or a hard-coded value of &lt;code&gt;256&lt;/code&gt;. The height is the &lt;code&gt;fixedCellHeight&lt;/code&gt; multiplied by &lt;code&gt;visibleRowCount&lt;/code&gt;, if &lt;code&gt;fixedCellHeight&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;, otherwise it is a hard-coded value of &lt;code&gt;16&lt;/code&gt; multiplied by &lt;code&gt;visibleRowCount&lt;/code&gt;.</source>
          <target state="translated">어느 경우 &lt;code&gt;fixedCellWidth&lt;/code&gt; 또는 &lt;code&gt;fixedCellHeight&lt;/code&gt; 프로퍼티가 지정되지 않은, 발견 적 방법이 사용된다. 모델이 비어있는 경우 너비는 &lt;code&gt;fixedCellWidth&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; 보다 크면 ) 또는 하드 코딩 된 값 &lt;code&gt;256&lt;/code&gt; 입니다. 높이는 &lt;code&gt;fixedCellHeight&lt;/code&gt; 에 &lt;code&gt;visibleRowCount&lt;/code&gt; 를 곱한 값 이고, &lt;code&gt;fixedCellHeight&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 보다 크면 , 그렇지 않으면 하드 코딩 된 &lt;code&gt;16&lt;/code&gt; 값에 &lt;code&gt;visibleRowCount&lt;/code&gt; 를 곱한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="332d8e7d0f59b9812b7d8680ca5e21ee5e3a7a49" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;sourceXSubsampling&lt;/code&gt; or &lt;code&gt;sourceYSubsampling&lt;/code&gt; is 0 or negative, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">어느 경우 &lt;code&gt;sourceXSubsampling&lt;/code&gt; 또는 &lt;code&gt;sourceYSubsampling&lt;/code&gt; 가 0 또는 음수, &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="10859c24a221b0a1a8f8c2d45e2dd5f29f7ffaa0" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;subsamplingXOffset&lt;/code&gt; or &lt;code&gt;subsamplingYOffset&lt;/code&gt; is negative or greater than or equal to the corresponding period, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">어느 쪽이든 &lt;code&gt;subsamplingXOffset&lt;/code&gt; 또는 &lt;code&gt;subsamplingYOffset&lt;/code&gt; 가 네거티브 이상을 초과하거나 동기 같 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 발생한다.</target>
        </trans-unit>
        <trans-unit id="8c9e3a00ed69f539de04dcde556ef5fedbed9bf1" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is a negative number then a value is substituted to maintain the aspect ratio of the original image dimensions. If both &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are negative, then the original image dimensions are used.</source>
          <target state="translated">어느 경우 &lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 음수 인 다음 값은 원래 화상 크기의 종횡비를 유지하기 위해 치환된다. 두 경우 &lt;code&gt;width&lt;/code&gt; 과 &lt;code&gt;height&lt;/code&gt; 제외하고, 그 원 화상 사이즈가 사용된다.</target>
        </trans-unit>
        <trans-unit id="f1bccf0359c9d2523582443e154621147124c9b2" translate="yes" xml:space="preserve">
          <source>If either argument is NaN and neither argument is infinite, then the result is NaN.</source>
          <target state="translated">인수가 NaN이고 인수가 모두 무한대 인 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="a87ec8779fbe2da84925808f31ac1112c6261d11" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, or the first argument is infinite, or the second argument is positive zero or negative zero, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 첫 번째 인수가 무한하거나 두 번째 인수가 양의 0 또는 음의 0이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="b78f08e2975896437871c452fd60393fe6909b91" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, then the result is NaN.</source>
          <target state="translated">인수 중 하나가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="34eb1a13a1d41fedad71ac94304afaf4d3b30061" translate="yes" xml:space="preserve">
          <source>If either argument is a NaN, then NaN is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1dead44a3b56a54e43e3eaa910e00403c25df167" translate="yes" xml:space="preserve">
          <source>If either argument is infinite, then the result is positive infinity.</source>
          <target state="translated">인수 중 하나가 무한하면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="41bc9309c0f8d33aae679550f8327f3ba41d91bd" translate="yes" xml:space="preserve">
          <source>If either index is &lt;code&gt;-1&lt;/code&gt;, this method does nothing and returns without exception. Otherwise, if either index is less than &lt;code&gt;-1&lt;/code&gt;, an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown.</source>
          <target state="translated">인덱스가 &lt;code&gt;-1&lt;/code&gt; 이면이 메서드는 아무 작업도 수행하지 않고 예외없이 반환합니다. 두 지수 미만이면 그렇지 않으면, &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2a88d05f4fde9c492de3341283adf63bc8f2e9c" translate="yes" xml:space="preserve">
          <source>If either of the destination offsets are negative, the source region is clipped so that its top left will coincide with the top left of the destination image, taking subsampling into account. Then the result is clipped to the destination image on the right and bottom, if one is specified, taking subsampling and destination offsets into account.</source>
          <target state="translated">대상 오프셋 중 하나가 음수이면 소스 영역이 클리핑되어 서브 샘플링을 고려하여 왼쪽 상단이 대상 이미지의 왼쪽 상단과 일치합니다. 그런 다음 서브 샘플링 및 대상 오프셋을 고려하여 지정된 경우 오른쪽과 아래쪽의 대상 이미지에 결과가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="03f21ceb73c687836a6489d537281750ea1dd4dd" translate="yes" xml:space="preserve">
          <source>If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.</source>
          <target state="translated">지정된 배열 중 하나 이상이 하나 이상의 배열 수준을 통해 직접 또는 간접적으로 요소로 포함 된 경우이 메서드의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="180e76f99201ee9fe15021c8ef7f28c26ec9a151" translate="yes" xml:space="preserve">
          <source>If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true.</source>
          <target state="translated">useParentHandlers 특성의 결과 또는 이전 값이 널이 아닌 경우 로거가 존재하거나 해당 로거의 하위가 존재하면 해당 로거가 결과 값으로 업데이트됩니다. useParentHandlers 속성의 값은 구성에 지정된 값입니다. 지정하지 않으면 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="e3db76a27295abd8950cde00cc86a08c8f4f37d6" translate="yes" xml:space="preserve">
          <source>If either the source or destination regions end up having a width or height of 0, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">소스 또는 대상 영역 중 하나의 너비 또는 높이가 0이면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16d93984ca72bf8d13d016fde295c0c3effdeb16" translate="yes" xml:space="preserve">
          <source>If either this URI or the given URI are opaque, or if the scheme and authority components of the two URIs are not identical, or if the path of this URI is not a prefix of the path of the given URI, then the given URI is returned.</source>
          <target state="translated">이 URI 또는 ​​제공된 URI가 불투명하거나 두 URI의 체계 및 권한 구성 요소가 동일하지 않거나이 URI의 경로가 지정된 URI 경로의 접 두부가 아닌 경우 제공된 URI는 다음과 같습니다. 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="9aa050dc79127dc702ac7f7af9f8c09a95bedff5" translate="yes" xml:space="preserve">
          <source>If element and/or attribute names in the same start or empty-element tag are bound to different namespace URIs and are using the same prefix then the element or the first occurring attribute retains the original prefix and the following attributes have their prefixes replaced with a new prefix that is bound to the namespace URIs of those attributes.</source>
          <target state="translated">동일한 시작 또는 빈 요소 태그의 요소 및 / 또는 속성 이름이 서로 다른 네임 스페이스 URI에 바인딩되고 동일한 접두사를 사용하는 경우 요소 또는 첫 번째 발생 속성은 원래 접두사를 유지하고 다음 속성은 접두사가 해당 속성의 네임 스페이스 URI에 바인딩 된 새 접두사.</target>
        </trans-unit>
        <trans-unit id="5f2bce0ea72e2df5a3161327906870e899626cea" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then a &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 파일의 끝이 언제라도 발견되면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ec3c5e0a4dd72da9a56884a1749a8ec51b24003" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 언제라도 파일 끝이 발견되면 &lt;code&gt;EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e02489afb24dcd898ea786f1764d129a6f696e32" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 언제라도 파일 끝이 발견되면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69e5b4feef83c14b8462d2220d828694ae4230e4" translate="yes" xml:space="preserve">
          <source>If end of file is encountered before even one byte can be read, then &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, each byte that is read is converted to type &lt;code&gt;char&lt;/code&gt; by zero-extension. If the character &lt;code&gt;'\n'&lt;/code&gt; is encountered, it is discarded and reading ceases. If the character &lt;code&gt;'\r'&lt;/code&gt; is encountered, it is discarded and, if the following byte converts to the character &lt;code&gt;'\n'&lt;/code&gt;, then that is discarded also; reading then ceases. If end of file is encountered before either of the characters &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\r'&lt;/code&gt; is encountered, reading ceases. Once reading has ceased, a &lt;code&gt;String&lt;/code&gt; is returned that contains all the characters read and not discarded, taken in order. Note that every character in this string will have a value less than &lt;code&gt;\u0100&lt;/code&gt;, that is, &lt;code&gt;(char)256&lt;/code&gt;.</source>
          <target state="translated">1 바이트라도 읽기 전에 파일 끝이 발견되면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 읽은 각 바이트는 0 확장에 의해 &lt;code&gt;char&lt;/code&gt; 유형으로 변환됩니다 . 문자 &lt;code&gt;'\n'&lt;/code&gt; 이 있으면 문자 가 삭제되고 읽기가 중단됩니다. 문자 &lt;code&gt;'\r'&lt;/code&gt; 이 발견 되면 해당 문자 는 버리고 다음 바이트가 문자 &lt;code&gt;'\n'&lt;/code&gt; 변환되면 파기됩니다. 그런 다음 독서가 중단됩니다. 문자 &lt;code&gt;'\n'&lt;/code&gt; 및 &lt;code&gt;'\r'&lt;/code&gt; 중 하나가 발견되기 전에 파일 끝 이 발견되면 읽기가 중단됩니다. 독서가 끝나면 &lt;code&gt;String&lt;/code&gt; 을 읽고 삭제하지 않은 모든 문자를 순서대로 가져 오는을 반환합니다. 이 문자열의 모든 문자는 &lt;code&gt;\u0100&lt;/code&gt; 보다 작은 값 , 즉 &lt;code&gt;(char)256&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c4bef5ed2f034c6a6bf34fec9b291f4c50c29549" translate="yes" xml:space="preserve">
          <source>If errors occur during the invocation of this method, such as an attempt to update a read-only node or a &lt;code&gt;Node.nodeName&lt;/code&gt; contains an invalid character according to the XML version in use, errors or warnings (&lt;code&gt;DOMError.SEVERITY_ERROR&lt;/code&gt; or &lt;code&gt;DOMError.SEVERITY_WARNING&lt;/code&gt;) will be reported using the &lt;code&gt;DOMErrorHandler&lt;/code&gt; object associated with the &quot;error-handler &quot; parameter. Note this method might also report fatal errors ( &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt;) if an implementation cannot recover from an error.</source>
          <target state="translated">읽기 전용 노드를 업데이트하려는 시도와 &lt;code&gt;Node.nodeName&lt;/code&gt; 메서드를 호출하는 동안 오류가 발생하거나 Node.nodeName 에 사용중인 XML 버전에 따라 잘못된 문자가 포함 된 경우 오류 또는 경고 ( &lt;code&gt;DOMError.SEVERITY_ERROR&lt;/code&gt; 또는 &lt;code&gt;DOMError.SEVERITY_WARNING&lt;/code&gt; ) &quot;error-handler&quot;매개 변수와 연관된 &lt;code&gt;DOMErrorHandler&lt;/code&gt; 객체를 사용하여보고 됩니다. 이 메서드 는 구현이 오류에서 복구 할 수없는 경우 치명적인 오류 ( &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt; )를 보고 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b674afa2ba891dd7a58dfaa94a5d64325a48496" translate="yes" xml:space="preserve">
          <source>If everything fails, &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">모든 것이 실패하면 &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="84787651c093f5940bda88b1a55845848cbc36dc" translate="yes" xml:space="preserve">
          <source>If everything fails, an &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">모든 것이 실패하면 &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a3e73ecba896208f50db9710798b46a965a908cf" translate="yes" xml:space="preserve">
          <source>If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.</source>
          <target state="translated">corePoolSize 스레드보다 적은 수의 스레드가 실행중인 경우 실행자는 항상 큐 대신 새 스레드를 추가하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="f250a59034e1c489b9abe228c4a6bad44105503f" translate="yes" xml:space="preserve">
          <source>If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, calling the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method with a &lt;code&gt;FocusEvent&lt;/code&gt; as the argument will result in a call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt; method regardless of the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 에 대해 포커스 이벤트가 활성화 된 경우 &lt;code&gt;FocusEvent&lt;/code&gt; 를 인수로 사용 하여 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;dispatchEvent&lt;/code&gt; 메서드를 호출 하면 현재 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 에 관계없이 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;processFocusEvent&lt;/code&gt; 메서드 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="40fc17409e4ee706dff7b6c91533503275fb1e4d" translate="yes" xml:space="preserve">
          <source>If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines whether or not a focus event should be dispatched to registered &lt;code&gt;FocusListener&lt;/code&gt; objects. If the events are to be dispatched, the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; calls the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method, which results in a call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 에 포커스 이벤트가 활성화 된 경우 현재 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 는 포커스 이벤트를 등록 된 &lt;code&gt;FocusListener&lt;/code&gt; 객체 로 전달해야하는지 여부를 결정합니다 . 이벤트를 전달해야하는 경우 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 는 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;dispatchEvent&lt;/code&gt; 메서드를 호출하여 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;processFocusEvent&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ca5a8548f3fbffd915bbf435ebb21f7a97c206bb" translate="yes" xml:space="preserve">
          <source>If for the URL's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">URL의 프로토콜 (예 : HTTP 또는 JAR)의 경우 java.lang, java.io, java.util, java.net, 리턴 된 연결은 해당 서브 클래스의 연결입니다. 예를 들어, HTTP의 경우 HttpURLConnection이 리턴되고 JAR의 경우 JarURLConnection이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ecc3cf47c73dc6fc1a7d51257f1c70d39038a258" translate="yes" xml:space="preserve">
          <source>If for the handler's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">처리기 프로토콜 (예 : HTTP 또는 JAR)의 경우 java.lang, java.io, java.util, java.net 패키지 중 하나 또는 해당 하위 패키지 중 하나에 속하는 공용 특수 URLConnection 서브 클래스가 있습니다. 리턴 된 연결은 해당 서브 클래스의 연결입니다. 예를 들어, HTTP의 경우 HttpURLConnection이 리턴되고 JAR의 경우 JarURLConnection이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8a04deb6efc63b4ca14bf4a5640a470b9eb6a3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the given socket addresses IP address and port number.</source>
          <target state="translated">&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; 가&lt;/a&gt; 주어지면 이 메서드 는 지정된 소켓 주소 IP 주소 및 포트 번호로 &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a4abed1287821693f6da736875b1dd20090fd9c3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the the given socket addresses IP address and port number.</source>
          <target state="translated">&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; 가&lt;/a&gt; 제공된 경우 ,이 메소드 는, 지정된 소켓 주소 IP 주소 및 포트 번호로 &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="e516526c9c2357988df1234780c497763164fab1" translate="yes" xml:space="preserve">
          <source>If handshaking fails for any reason, the &lt;code&gt;SSLSocket&lt;/code&gt; is closed, and no further communications can be done.</source>
          <target state="translated">어떤 이유로 든 핸드 셰이 킹에 실패하면 &lt;code&gt;SSLSocket&lt;/code&gt; 이 닫히고 더 이상 통신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a00d8a2054c6cca37fdcf90a95f1f7f1ad5e5f0" translate="yes" xml:space="preserve">
          <source>If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate.</source>
          <target state="translated">후크 또는 콜백 메소드에서 예외가 발생하면 내부 작업자 스레드가 실패하고 갑자기 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2a7481f1636ab9a24c9018af1fcad7f07157bdd" translate="yes" xml:space="preserve">
          <source>If hook, callback, or BlockingQueue methods throw exceptions, internal worker threads may in turn fail, abruptly terminate, and possibly be replaced.</source>
          <target state="translated">후크, 콜백 또는 BlockingQueue 메서드에서 예외가 발생하면 내부 작업자 스레드가 실패하고 갑작스럽게 종료되고 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="085d6508b165d7efeb827d901170784516d5c017" translate="yes" xml:space="preserve">
          <source>If horizon is &lt;code&gt;0&lt;/code&gt;, then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern.</source>
          <target state="translated">수평선이 &lt;code&gt;0&lt;/code&gt; 이면 horizon이 무시되고이 메소드는 입력을 통해 계속해서 지정된 패턴을 경계없이 찾습니다. 이 경우 패턴을 검색하는 모든 입력을 버퍼링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e185e59957de1a2d9502a435e3bf5d9b3e15599e" translate="yes" xml:space="preserve">
          <source>If horizon is negative, then an IllegalArgumentException is thrown.</source>
          <target state="translated">수평선이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c1e650eb5f2174a711da5a09bfcd316b4c0f07f" translate="yes" xml:space="preserve">
          <source>If however, the serialization is not possible because the Java object is not immediately serializable, this class will attempt to serialize all non-static members to permit the object state to be serialized. Static or transient fields cannot be serialized; an attempt to serialize them will result in a &lt;code&gt;SerialException&lt;/code&gt; object being thrown.</source>
          <target state="translated">그러나 Java 객체를 즉시 직렬화 할 수 없기 때문에 직렬화가 불가능한 경우이 클래스는 객체 상태를 직렬화 할 수 있도록 모든 비 정적 멤버를 직렬화하려고 시도합니다. 정적 또는 임시 필드는 직렬화 할 수 없습니다. 직렬화를 시도하면 &lt;code&gt;SerialException&lt;/code&gt; 객체가 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="31e1ede01add4d64dba9a3481e31fdf9753b8a4c" translate="yes" xml:space="preserve">
          <source>If however, the serialization is not possible in the case where the Java object is not immediately serializable, this class will attempt to serialize all non static members to permit the object instance state to be serialized. Static or transient fields cannot be serialized and attempting to do so will result in a &lt;code&gt;SerialException&lt;/code&gt; being thrown.</source>
          <target state="translated">그러나 Java 객체를 즉시 직렬화 할 수없는 경우 직렬화가 불가능한 경우이 클래스는 객체 인스턴스 상태를 직렬화 할 수 있도록 모든 비 정적 멤버를 직렬화하려고 시도합니다. 정적 또는 임시 필드는 직렬화 할 수 없으며 그렇게하면 &lt;code&gt;SerialException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="272ee6aa9e995da35c3e7f8f88e4b02553afd186" translate="yes" xml:space="preserve">
          <source>If i == 0 returns the action description fetched from UIManager.getString(&quot;AbstractButton.clickText&quot;); otherwise returns null.</source>
          <target state="translated">i == 0이면 UIManager.getString ( &quot;AbstractButton.clickText&quot;);에서 가져온 작업 설명을 반환합니다. 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c3c9e4ade0cd42fbb5a5e7d40ca8bfb9569f944c" translate="yes" xml:space="preserve">
          <source>If i == 0 selects this AccessibleJListChild by calling JList.this.setSelectedIndex(indexInParent) and then returns true; otherwise returns false.</source>
          <target state="translated">i == 0이면 JList.this.setSelectedIndex (indexInParent)를 호출하여이 AccessibleJListChild를 선택한 다음 true를 반환합니다. 그렇지 않으면 거짓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c672e7792e737065f944dcb4cec0eb9d5372d1e1" translate="yes" xml:space="preserve">
          <source>If implementing JavaSound on a I3DL2-compliant device:</source>
          <target state="translated">I3DL2 호환 장치에서 JavaSound를 구현하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3fd0a906cb89e2de9c5076d850930cae34f103b9" translate="yes" xml:space="preserve">
          <source>If implementing an unusual calendar system that is not based on years, months and days, or where you want direct control, then the &lt;code&gt;ChronoPeriod&lt;/code&gt; interface must be directly implemented.</source>
          <target state="translated">연도, 월, 일을 기준으로하지 않거나 직접 제어 할 위치가 아닌 비정상적인 달력 시스템을 구현하는 경우 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인터페이스를 직접 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="07b0ad2086ad124aeb2593860505d4dc09bcafc2" translate="yes" xml:space="preserve">
          <source>If implicit and explicit opening and closing are mixed on the same &lt;code&gt;MidiDevice&lt;/code&gt; instance, the following rules apply:</source>
          <target state="translated">암시 적 및 명시 적 개폐가 동일한 &lt;code&gt;MidiDevice&lt;/code&gt; 에서 혼합 된 경우 인스턴스에서 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="58b430e8bf58bb5b6e8fdbf80a0cd30f4538db11" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value.</source>
          <target state="translated">색인 또는 크기가 음수이거나 허용 된 값보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="c635ec7df61e52aeac84e0512f36bd12bd58d35c" translate="yes" xml:space="preserve">
          <source>If inputComponent is non-null, the focus is requested on that, otherwise request focus on the default value</source>
          <target state="translated">inputComponent가 null이 아닌 경우 포커스가 요청되고 그렇지 않으면 기본값에 포커스가 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="1b6c1ac0801d0f32085f65cf19851af72a8b38e1" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">사용 권한이 충분하지 않으면 현재 스레드가 스레드 예약 용도로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="41f0c20f43c3bf64e0efed44e2fb775806ea99b7" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면 현재 스레드가 스레드 예약 용도로 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="0d316920d5718f1bd7a8baa6604a77f96ebb5665" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore and the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">사용 가능한 허용이 충분하지 않은 경우 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다른 스레드 가이 세마포어 에 대한 &lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 방법 중 하나를 호출 하고 현재 스레드가 다음으로 허용을 할당하고 사용 가능한 허용 수가이 요청을 충족 할 때까지 휴면 상태 에 있습니다. .</target>
        </trans-unit>
        <trans-unit id="6392fbf3bc8eb96daeacf7450eb84b4b39a684c9" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면 현재 스레드가 스레드 스케줄링 목적으로 사용 불가능하게되고 다른 스레드 가이 세마포어 에 대한 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 호출 할 때까지 휴면 상태 가됩니다. .</target>
        </trans-unit>
        <trans-unit id="2f81c133b1f0b74c30d4d20073c4db1886f54e67" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt; and the number of available permits is unchanged.</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면이 방법은 값 &lt;code&gt;false&lt;/code&gt; 와 함께 즉시 반환되며 사용 가능한 허용 수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6917340a867ad875b7b2abf8931c9a665a0bbc79" translate="yes" xml:space="preserve">
          <source>If integer math were being used and this value were being composited in &lt;a href=&quot;#SRC&quot;&gt;&lt;code&gt;SRC&lt;/code&gt;&lt;/a&gt; mode with no extra alpha, then the math would indicate that the results were (in integer format):</source>
          <target state="translated">정수 수학이 사용되고이 값이 추가 알파없이 &lt;a href=&quot;#SRC&quot;&gt; &lt;code&gt;SRC&lt;/code&gt; &lt;/a&gt; 모드 에서 합성되는 경우 수학은 결과가 다음과 같음을 나타냅니다 (정수 형식).</target>
        </trans-unit>
        <trans-unit id="3ee886087a23f0ef283d53172b5a86b2108daa86" translate="yes" xml:space="preserve">
          <source>If interrupted while blocked in step 4, throw InterruptedException.</source>
          <target state="translated">4 단계에서 차단 된 동안 인터럽트 된 경우 InterruptedException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3a74fc2cc725f0cf0347bdb572b4ec73b5f5ad65" translate="yes" xml:space="preserve">
          <source>If invokeLater is called from the event dispatching thread -- for example, from a JButton's ActionListener -- the</source>
          <target state="translated">invokeLater가 이벤트 디스패치 스레드 (예 : JButton의 ActionListener)에서 호출되면</target>
        </trans-unit>
        <trans-unit id="8d2bc19f50633c8c0c8e271655bc0f3233284658" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active subgroup in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">이 스레드 그룹에서 모든 활성 하위 그룹을 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;list&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc469862baa4b5e3d18bc2ca8c5358c4773f7d5f" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in the current thread's thread group and its subgroups, the invoker should verify that the returned int value is strictly less than the length of &lt;code&gt;tarray&lt;/code&gt;.</source>
          <target state="translated">현재 스레드의 스레드 그룹 및 해당 하위 그룹에있는 모든 활성 스레드를 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;tarray&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22683bf338326eeebb95e34c255b900a9e0a2f93" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">이 스레드 그룹의 모든 활성 스레드를 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;list&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="c685c0ba10c68c8f1f3a8c193feb8d700f179cf1" translate="yes" xml:space="preserve">
          <source>If it is false, then expose &lt;b&gt;[member type definition name]&lt;/b&gt; and &lt;b&gt;[member type definition namespace]&lt;/b&gt; properties;</source>
          <target state="translated">false이면 &lt;b&gt;[멤버 유형 정의 이름]&lt;/b&gt; 및 &lt;b&gt;[멤버 유형 정의 네임 스페이스]&lt;/b&gt; 속성 을 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="15b4ed739e5d26e30a9b9b0921ac056bf0af4f7b" translate="yes" xml:space="preserve">
          <source>If it is false, then expose &lt;b&gt;[type definition name]&lt;/b&gt; and &lt;b&gt;[type definition namespace]&lt;/b&gt; properties;</source>
          <target state="translated">false이면 &lt;b&gt;[유형 정의 이름]&lt;/b&gt; 및 &lt;b&gt;[유형 정의 네임 스페이스]&lt;/b&gt; 속성 을 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="54d0672abd6341128d9d7ad099fd323b0c8ef7b4" translate="yes" xml:space="preserve">
          <source>If it is implemented to do so, the &lt;code&gt;SyncProvider&lt;/code&gt; object may also create a &lt;code&gt;SyncResolver&lt;/code&gt; object and either initialize the &lt;code&gt;SyncProviderException&lt;/code&gt; object with it at construction time or set it with the &lt;code&gt;SyncProvider&lt;/code&gt; object at a later time.</source>
          <target state="translated">그렇게하도록 구현 된 경우 &lt;code&gt;SyncProvider&lt;/code&gt; 개체는 &lt;code&gt;SyncResolver&lt;/code&gt; 개체를 만들고 생성시 &lt;code&gt;SyncProviderException&lt;/code&gt; 개체를 초기화 하거나 나중에 &lt;code&gt;SyncProvider&lt;/code&gt; 개체로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e7088330e477594f46099a50c9ebf8a9c61981" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">&lt;a href=&quot;#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt; 로 설정 되면 패커는 요소를 재정렬하고 Java 애플리케이션에 대한 유용한 정보가없는 JAR 디렉토리 항목도 제거 할 수 있습니다. (일반적으로 이것은 더 나은 압축을 가능하게합니다.)</target>
        </trans-unit>
        <trans-unit id="a8a140e583fff0cfc9d06bbb68afa76210088042" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;pack200.packer#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">&lt;a href=&quot;pack200.packer#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt; 로 설정 되면 패커는 요소를 재정렬하고 JAR 디렉토리 항목을 제거하여 Java 애플리케이션에 유용한 정보를 제공하지 않습니다. 일반적으로 압축률이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="349c3ce48f2850808153616db77878ba7dc35133" translate="yes" xml:space="preserve">
          <source>If iterables and sets containing &lt;code&gt;null&lt;/code&gt; are passed as arguments to methods in this class, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 포함 된 iterables 및 세트 가이 클래스의 메소드에 인수로 전달되면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b5e36e15c72143d9f79d44bccee481b6c8b7952" translate="yes" xml:space="preserve">
          <source>If key events are enabled for a &lt;code&gt;Component&lt;/code&gt;, the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines whether or not a key event should be dispatched to registered &lt;code&gt;KeyListener&lt;/code&gt; objects. The &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; will not dispatch key events to a &lt;code&gt;Component&lt;/code&gt; that is not the focus owner or is not showing.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 에 키 이벤트가 활성화 된 경우 현재 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 는 등록 된 &lt;code&gt;KeyListener&lt;/code&gt; 객체에 키 이벤트를 전달할지 여부를 결정합니다 . &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; 는 A를 키 이벤트를 전달하지 않습니다 &lt;code&gt;Component&lt;/code&gt; 가 포커스 소유자가 아니거나 표시되지 않도록.</target>
        </trans-unit>
        <trans-unit id="578dfd2269ad5f68f754865852ba3828ba552206" translate="yes" xml:space="preserve">
          <source>If l is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is performed.</source>
          <target state="translated">l이 &lt;code&gt;null&lt;/code&gt; 이면 예외가 발생하지 않고 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f1683e5b5f316b42c49560377be91252becd81d" translate="yes" xml:space="preserve">
          <source>If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is performed.</source>
          <target state="translated">리스너 &lt;code&gt;l&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이면 예외가 발생하지 않고 조치가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7b8214ffef472fc8e7c1e2311b38613b16b1726" translate="yes" xml:space="preserve">
          <source>If listener is already registered, it will be registered again.</source>
          <target state="translated">리스너가 이미 등록되어 있으면 다시 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="0102c4bf84a1e8f5da988caa52f2807997272c61" translate="yes" xml:space="preserve">
          <source>If listener is null, no exception is thrown and no action is performed.</source>
          <target state="translated">listener가 null이면 예외가 발생하지 않고 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f90529506d3a0958fad7a3ecbf1c1171a153e5b" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform and that are in the usual extension directories (installed extensions) are loaded.</source>
          <target state="translated">loader가 &lt;code&gt;null&lt;/code&gt; 인 경우 플랫폼과 함께 번들로 제공되고 일반적인 확장 디렉토리 (설치된 확장)에있는 스크립트 엔진 팩토리가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="6e767135edebb75b3957eb1a33bb637fe33bf252" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform are loaded.</source>
          <target state="translated">loader가 &lt;code&gt;null&lt;/code&gt; 이면 플랫폼과 함께 번들로 제공되는 스크립트 엔진 팩토리가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ee069a1e9967d9348b8218cc73e384bb53741058" translate="yes" xml:space="preserve">
          <source>If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.</source>
          <target state="translated">많은 수의 항목을 &lt;code&gt;Hashtable&lt;/code&gt; 로 만들려면 충분히 큰 용량으로 입력하면 테이블을 확장하는 데 필요한 자동 재해시를 수행하는 것보다 더 효율적으로 항목을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc60d765a093b43a6239eb2d5685c05051e44ee" translate="yes" xml:space="preserve">
          <source>If many mappings are to be stored in a &lt;code&gt;HashMap&lt;/code&gt; instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">많은 매핑을 &lt;code&gt;HashMap&lt;/code&gt; 인스턴스에 저장해야하는 경우 충분한 대용량으로 매핑하면 테이블을 확장하는 데 필요한 자동 재해시를 수행하는 것보다 매핑을보다 효율적으로 저장할 수 있습니다. 동일한 &lt;code&gt;hashCode()&lt;/code&gt; 와 함께 많은 키를 사용 하면 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 키가 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때 영향을 개선하기 위해이 클래스는 키 간 비교 순서를 사용하여 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d3048870d83219010add9711bb4dd7ca3f2a54" translate="yes" xml:space="preserve">
          <source>If module &lt;code&gt;X&lt;/code&gt; exports a package to &lt;code&gt;Y&lt;/code&gt;, and if the runtime &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;X&lt;/code&gt; does not read &lt;code&gt;Y&lt;/code&gt; then target &lt;code&gt;Y&lt;/code&gt; is located as if by invoking &lt;a href=&quot;#findModule(java.lang.String)&quot;&gt;&lt;code&gt;findModule&lt;/code&gt;&lt;/a&gt; to find the module in the layer or its parent layers. If &lt;code&gt;Y&lt;/code&gt; is found then the package is exported to the instance of &lt;code&gt;Y&lt;/code&gt; that was found. If &lt;code&gt;Y&lt;/code&gt; is not found then the qualified export is ignored.</source>
          <target state="translated">모듈 &lt;code&gt;X&lt;/code&gt; 가 패키지를 &lt;code&gt;Y&lt;/code&gt; 로 내보내고 런타임 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;Y&lt;/code&gt; 를 읽지 않으면 &lt;a href=&quot;#findModule(java.lang.String)&quot;&gt; &lt;code&gt;findModule&lt;/code&gt; &lt;/a&gt; 을 호출 하여 레이어 또는 상위 레이어에서 모듈을 찾는 것처럼 대상 &lt;code&gt;Y&lt;/code&gt; 를 찾습니다. 경우 &lt;code&gt;Y&lt;/code&gt; 는 다음 발견 된 패키지의 인스턴스에 수출되고 &lt;code&gt;Y&lt;/code&gt; 발견되었다. 경우 &lt;code&gt;Y&lt;/code&gt; 는 다음을 찾을 수없는 자격을 갖춘 수출은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d390f7b0fed59c2ff1380a1ceb798db4d298ae1b" translate="yes" xml:space="preserve">
          <source>If module &lt;code&gt;X&lt;/code&gt; exports a package to &lt;code&gt;Y&lt;/code&gt;, and if the runtime &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;X&lt;/code&gt; reads &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;Y&lt;/code&gt;, then the package is exported to &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;Y&lt;/code&gt; (which may be in the same layer as &lt;code&gt;X&lt;/code&gt; or a parent layer).</source>
          <target state="translated">모듈 &lt;code&gt;X&lt;/code&gt; 가 패키지를 &lt;code&gt;Y&lt;/code&gt; 로 내보내고 런타임 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Y&lt;/code&gt; 를 읽는 경우 패키지는 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Y&lt;/code&gt; ( &lt;code&gt;X&lt;/code&gt; 또는 상위 계층 과 동일한 계층에있을 수 있음)로 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="403efbf3d99b9a55860af122e7ea1fa369ccd1ea" translate="yes" xml:space="preserve">
          <source>If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats are provided than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt; formats are replaced.</source>
          <target state="translated">패턴 문자열에 필요한 것보다 많은 형식이 제공되면 나머지 형식은 무시됩니다. 필요한 것보다 적은 형식이 제공되면 첫 번째 &lt;code&gt;newFormats.length&lt;/code&gt; 형식 만 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="88fc14eaff46a9dd5b43fbbfdf0127ddfea55823" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegatePublic&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;publicIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;delegatePublic&lt;/code&gt; 항목이 일치하는 경우 일치하는 가장 긴 &lt;code&gt;publicIdStartString&lt;/code&gt; 값이 있는 일치하는 항목 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="59651f5fa4d31880a671cf0ce022bc0fa42ba699" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegatePublic&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;uriStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;delegatePublic&lt;/code&gt; 항목이 일치하면 일치하는 가장 긴 &lt;code&gt;uriStartString&lt;/code&gt; 값이 있는 일치하는 항목 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="297b17bdac784aa0adbfddd9b55d1bbb6d8ed4e3" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegateSystem&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;systemIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;delegateSystem&lt;/code&gt; 항목이 일치하면 일치하는 가장 긴 &lt;code&gt;systemIdStartString&lt;/code&gt; 값이 있는 일치하는 항목 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5f1964f8ab19e3a1d9048d9994e12715e3e82bb8" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;rewriteSystem&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;systemIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;rewriteSystem&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;systemIdStartString&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="493c294f5c18b9360394be2f1230acb929c4efe8" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;rewriteURI&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;uriStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;rewriteURI&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;uriStartString&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f645ec9f2894ffb6e64d13303f47e749823b0e9" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;systemSuffix&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;systemIdSuffix&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;systemSuffix&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;systemIdSuffix&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16b11a7c5339b99b84c48f7fe6a5331cc8851de5" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;uriSuffix&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;uriSuffix&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;uriSuffix&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;uriSuffix&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f81dba9cec8cf743a82c5f4acc275a929c8964b3" translate="yes" xml:space="preserve">
          <source>If more than one listener terminates with an uncaught error or exception, an implementation may record the additional errors or exceptions as &lt;a href=&quot;../../../../java.base/java/lang/throwable#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed exceptions&lt;/a&gt;.</source>
          <target state="translated">둘 이상의 리스너가 포착되지 않은 오류 또는 예외로 종료되는 경우 구현에서 추가 오류 또는 예외를 &lt;a href=&quot;../../../../java.base/java/lang/throwable#addSuppressed(java.lang.Throwable)&quot;&gt;억제 된 예외&lt;/a&gt; 로 기록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca2bc26c1a10450fbbbc1b4da5d4954e22c3c85b" translate="yes" xml:space="preserve">
          <source>If more than one prefix is currently mapped to the same URI, this method will make an arbitrary selection; if you want all of the prefixes, use the &lt;a href=&quot;#getPrefixes()&quot;&gt;&lt;code&gt;getPrefixes()&lt;/code&gt;&lt;/a&gt; method instead.</source>
          <target state="translated">두 개 이상의 접두사가 현재 동일한 URI에 매핑 된 경우이 메서드는 임의 선택을 수행합니다. 모든 접두사를 원하면 &lt;a href=&quot;#getPrefixes()&quot;&gt; &lt;code&gt;getPrefixes()&lt;/code&gt; &lt;/a&gt; 메서드를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4db95816febda6de7835e87bdeaef107c21d9eea" translate="yes" xml:space="preserve">
          <source>If multiple catalog files are specified through the &lt;code&gt;uris&lt;/code&gt; argument or &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property, the first entry is considered the main catalog, while others are treated as alternative catalogs after those referenced by the &lt;code&gt;nextCatalog&lt;/code&gt; elements in the main catalog.</source>
          <target state="translated">&lt;code&gt;uris&lt;/code&gt; 인수 또는 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 특성을 통해 여러 카탈로그 파일이 지정된 경우 첫 번째 항목은 기본 카탈로그로 간주되고 다른 항목은 기본 카탈로그의 &lt;code&gt;nextCatalog&lt;/code&gt; 요소가 참조하는 항목 이후에 대체 카탈로그로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b42ca8cc8280b3ca185d72fc9765dbc058c02c1" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program.</source>
          <target state="translated">여러 클래스 로더가 서로에 위임하고 동일한 패키지 이름으로 클래스를 정의하고, 하나의 로더의 조회 동작에 의존하는 경우 &lt;code&gt;getPackage&lt;/code&gt; 반환 &lt;code&gt;Package&lt;/code&gt; 부모 로더에서, 다음에 의해 노출 된 속성 &lt;code&gt;Package&lt;/code&gt; 예상되지 않을 수 있습니다로 나머지 프로그램.</target>
        </trans-unit>
        <trans-unit id="f2cf1bf7c92db59422c4dbe0cefb78945b19c3fa" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program. For example, the &lt;code&gt;Package&lt;/code&gt; will only expose annotations from the &lt;code&gt;package-info.class&lt;/code&gt; file defined by the parent loader, even if annotations exist in a &lt;code&gt;package-info.class&lt;/code&gt; file defined by a child loader. A more robust approach is to use the &lt;a href=&quot;#getDefinedPackage(java.lang.String)&quot;&gt;&lt;code&gt;getDefinedPackage(java.lang.String)&lt;/code&gt;&lt;/a&gt; method which returns a &lt;code&gt;Package&lt;/code&gt; for the specified class loader.</source>
          <target state="translated">여러 클래스 로더가 서로에 위임하고 동일한 패키지 이름으로 클래스를 정의하고, 하나의 로더의 조회 동작에 의존하는 경우 &lt;code&gt;getPackage&lt;/code&gt; 반환 &lt;code&gt;Package&lt;/code&gt; 부모 로더에서, 다음에 의해 노출 된 속성 &lt;code&gt;Package&lt;/code&gt; 예상되지 않을 수 있습니다로 나머지 프로그램. 예를 들어, &lt;code&gt;Package&lt;/code&gt; 단지에서 주석을 노출 할 &lt;code&gt;package-info.class&lt;/code&gt; 주석이 존재하는 경우에도, 부모 로더에 의해 정의 된 파일 &lt;code&gt;package-info.class&lt;/code&gt; 아이 로더에 의해 정의 파일. 보다 강력한 접근 방식은 지정된 클래스 로더에 대한 &lt;code&gt;Package&lt;/code&gt; 를 반환하는 &lt;a href=&quot;#getDefinedPackage(java.lang.String)&quot;&gt; &lt;code&gt;getDefinedPackage(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3eff7fa36e61e7e0bac30eb94dfd47ccf1823466" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program. For example, the &lt;code&gt;Package&lt;/code&gt; will only expose annotations from the &lt;code&gt;package-info.class&lt;/code&gt; file defined by the parent loader, even if annotations exist in a &lt;code&gt;package-info.class&lt;/code&gt; file defined by a child loader. A more robust approach is to use the &lt;a href=&quot;classloader#getDefinedPackage(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getDefinedPackage(java.lang.String)&lt;/code&gt;&lt;/a&gt; method which returns a &lt;code&gt;Package&lt;/code&gt; for the specified class loader.</source>
          <target state="translated">여러 클래스 로더가 서로에 위임하고 동일한 패키지 이름으로 클래스를 정의하고, 하나의 로더의 조회 동작에 의존하는 경우 &lt;code&gt;getPackage&lt;/code&gt; 반환 &lt;code&gt;Package&lt;/code&gt; 부모 로더에서, 다음에 의해 노출 된 속성 &lt;code&gt;Package&lt;/code&gt; 예상되지 않을 수 있습니다로 나머지 프로그램. 예를 들어, &lt;code&gt;Package&lt;/code&gt; 단지에서 주석을 노출 할 &lt;code&gt;package-info.class&lt;/code&gt; 주석이 존재하는 경우에도, 부모 로더에 의해 정의 된 파일 &lt;code&gt;package-info.class&lt;/code&gt; 아이 로더에 의해 정의 파일. 보다 강력한 접근 방식은 지정된 클래스 로더에 대해 를 반환하는 &lt;a href=&quot;classloader#getDefinedPackage(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getDefinedPackage(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하는 것 &lt;code&gt;Package&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cee9f9e59ed8b4cfd7dc142950cdc7c34a80861f" translate="yes" xml:space="preserve">
          <source>If multiple collated copies of a document are requested, and the printer cannot natively support this, then the document may be imaged multiple times. Printing will start each copy from the lowest print stream page index page.</source>
          <target state="translated">문서의 한 부씩 인쇄 된 사본이 여러 개 요청되고 프린터가 기본적으로이를 지원할 수없는 경우 문서 이미지가 여러 번 생성 될 수 있습니다. 인쇄는 가장 낮은 인쇄 스트림 페이지 색인 페이지에서 각 사본을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="362678d61121ba55b56c2cd8e3a33ea5e494ed6c" translate="yes" xml:space="preserve">
          <source>If multiple identical &lt;code&gt;EventListener&lt;/code&gt;s are registered on the same &lt;code&gt;EventTarget&lt;/code&gt; with the same parameters the duplicate instances are discarded. They do not cause the &lt;code&gt;EventListener&lt;/code&gt; to be called twice and since they are discarded they do not need to be removed with the &lt;code&gt;removeEventListener&lt;/code&gt; method.</source>
          <target state="translated">여러 개의 동일한 &lt;code&gt;EventListener&lt;/code&gt; 가 동일한 매개 변수 를 사용하여 동일한 &lt;code&gt;EventTarget&lt;/code&gt; 에 등록 된 경우 중복 인스턴스는 삭제됩니다. 그들은 발생하지 않습니다 &lt;code&gt;EventListener&lt;/code&gt; 를 두 번 호출해야하고 폐기되기 때문에 그들은 제거 할 필요가 없습니다 &lt;code&gt;removeEventListener&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="d6b342590893d7d01546097e9b3ca381aee04072" translate="yes" xml:space="preserve">
          <source>If multiple language tags match as a result of the subtag &lt;code&gt;'*'&lt;/code&gt; included in a language range, the first matching language tag returned by an &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; of language tags is treated as the best matching one.</source>
          <target state="translated">여러 언어 태그가 서브 태그의 결과로 일치하면 &lt;code&gt;'*'&lt;/code&gt; 언어의 범위에 포함 된 첫 번째 일치하는 언어 태그는에 의해 반환 된 &lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 이상 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 최고 매칭 하나로 처리 언어 태그의.</target>
        </trans-unit>
        <trans-unit id="c9110f9cffafe9e6ee4b1350deb1a1949682093b" translate="yes" xml:space="preserve">
          <source>If multiple property entries with same currency code but different numeric code and/or minor unit are encountered, those entries are ignored and the remainder of entries in file are processed.</source>
          <target state="translated">통화 코드는 같지만 숫자 코드 및 / 또는 부 단위가 다른 속성 항목이 여러 개 있으면 해당 항목이 무시되고 파일의 나머지 항목이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e11014b61e4bf68a9834bb242ccbe0daf8328a8f" translate="yes" xml:space="preserve">
          <source>If necessary paints the background of the component, then invokes &lt;code&gt;paint&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 구성 요소의 배경을 &lt;code&gt;paint&lt;/code&gt; 다음 paint 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d13023cd4e8fcc2d288092b2cc22c117c42c1426" translate="yes" xml:space="preserve">
          <source>If necessary paints the background of the currently selected item.</source>
          <target state="translated">필요한 경우 현재 선택한 항목의 배경을 그립니다.</target>
        </trans-unit>
        <trans-unit id="502a7634dd4fbb85fac2085ee478540e682a31a5" translate="yes" xml:space="preserve">
          <source>If necessary paints the currently selected item.</source>
          <target state="translated">필요한 경우 현재 선택한 항목을 그립니다.</target>
        </trans-unit>
        <trans-unit id="8a47d40ac17dd40421ec44cb538636a1094721bf" translate="yes" xml:space="preserve">
          <source>If necessary, invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;audioAction&lt;/code&gt; to play a sound.</source>
          <target state="translated">필요한 경우 &lt;code&gt;audioAction&lt;/code&gt; 에서 &lt;code&gt;actionPerformed&lt;/code&gt; 를 호출 하여 사운드를 재생합니다.</target>
        </trans-unit>
        <trans-unit id="8ed84b12e8b4451f9860f8aeb95a2d9783b84f78" translate="yes" xml:space="preserve">
          <source>If necessary, invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;audioAction&lt;/code&gt; to play a sound. The &lt;code&gt;actionPerformed&lt;/code&gt; method is invoked if the value of the &lt;code&gt;&quot;AuditoryCues.playList&quot;&lt;/code&gt; default is a &lt;code&gt;
 non-null&lt;/code&gt;&lt;code&gt;Object[]&lt;/code&gt; containing a &lt;code&gt;String&lt;/code&gt; entry equal to the name of the &lt;code&gt;audioAction&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 &lt;code&gt;actionPerformed&lt;/code&gt; 를 호출합니다. &lt;code&gt;audioAction&lt;/code&gt; 에서 를 하여 사운드를 재생합니다. &lt;code&gt;actionPerformed&lt;/code&gt; 의 값 경우 메소드 호출 &lt;code&gt;&quot;AuditoryCues.playList&quot;&lt;/code&gt; 기본이있다 &lt;code&gt; non-null&lt;/code&gt; &lt;code&gt;Object[]&lt;/code&gt; 함유 &lt;code&gt;String&lt;/code&gt; 의 이름과 동일한 항목을 &lt;code&gt;audioAction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31a786a4b9ebe666db90e8ced8967b23f743b698" translate="yes" xml:space="preserve">
          <source>If necessary, perform Namespace processing.</source>
          <target state="translated">필요한 경우 네임 스페이스 처리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d8f13b5330308bc60cf99460dc77123faeb1fbfe" translate="yes" xml:space="preserve">
          <source>If negative values are supplied for &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;, the size of the &lt;code&gt;Rectangle&lt;/code&gt; decreases accordingly. The &lt;code&gt;grow&lt;/code&gt; method will check for integer overflow and underflow, but does not check whether the resulting values of &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; grow from negative to non-negative or shrink from non-negative to negative.</source>
          <target state="translated">음수 값이 제공된 경우 &lt;code&gt;h&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 에 하면 &lt;code&gt;Rectangle&lt;/code&gt; 의 크기가 그에 따라 감소합니다. &lt;code&gt;grow&lt;/code&gt; 방법은 정수 오버플로 및 언더 플로를 확인하지만, 결과 값의 여부를 확인하지 않은 &lt;code&gt;width&lt;/code&gt; 과 &lt;code&gt;height&lt;/code&gt; 비 마이너스 음극에서 성장 또는 마이너스 음수에서 수축.</target>
        </trans-unit>
        <trans-unit id="5fbfbdd8794986ee056ce3b4b224daa409c09c76" translate="yes" xml:space="preserve">
          <source>If neither of these properties is defined then the LogManager uses its default configuration. The default configuration is typically loaded from the properties file &quot;&lt;code&gt;lib/logging.properties&lt;/code&gt;&quot; in the Java installation directory.</source>
          <target state="translated">이 특성 중 어느 것도 정의되지 않으면 LogManager는 기본 구성을 사용합니다. 기본 구성은 일반적으로 Java 설치 디렉토리의 &quot; &lt;code&gt;lib/logging.properties&lt;/code&gt; &quot; 특성 파일에서로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3ae7424666e0772e32faa1585ee99d03123f286" translate="yes" xml:space="preserve">
          <source>If no &quot;%g&quot; field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.</source>
          <target state="translated">&quot;% g&quot;필드가 지정되지 않고 파일 수가 1보다 큰 경우 생성 번호는 생성 된 파일 이름 끝에 점 뒤에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c49e64ec417bf53b53b9cae02beab8814230bf7f" translate="yes" xml:space="preserve">
          <source>If no 'getMethod' field is defined then the default value of the attribute is returned. If the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">'getMethod'필드가 정의되어 있지 않으면 속성의 기본값이 리턴됩니다. 반환 된 값이 선언 된 속성 유형과 호환되지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9225d15e7619420ba47ebcf86e79d42187eb2a62" translate="yes" xml:space="preserve">
          <source>If no &lt;a id=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a id=&quot;floatdFlags&quot;&gt;플래그&lt;/a&gt; 가 지정 되지 않은 경우 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78c4da8fa7e0254c8812c85bb272ccfe8cae4bea" translate="yes" xml:space="preserve">
          <source>If no &lt;a id=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a id=&quot;intdFlags&quot;&gt;플래그&lt;/a&gt; 가 지정 되지 않은 경우 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf903b34c15e4e7c1e0d072f0b913417b22851de" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a name=&quot;floatdFlags&quot;&gt;플래그&lt;/a&gt; 가 제공 되지 않으면 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25494f57433f4174256b8e508bd8d48cd34d752d" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a name=&quot;intdFlags&quot;&gt;플래그&lt;/a&gt; 가 제공 되지 않으면 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a454d687e36b47d42fe06ade51852e5f906999d0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContentHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt; mechanism is used to locate &lt;a href=&quot;contenthandlerfactory&quot;&gt;ContentHandlerFactory&lt;/a&gt; implementations using the system class loader. The order that factories are located is implementation specific, and an implementation is free to cache the located factories. A &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;, &lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;RuntimeException&lt;/code&gt; thrown from the &lt;code&gt;createContentHandler&lt;/code&gt;, if encountered, will be propagated to the calling thread. The &lt;code&gt;
     createContentHandler&lt;/code&gt; method of each factory, if instantiated, is invoked, with the content type, until a factory returns non-null, or all factories have been exhausted.</source>
          <target state="translated">어떤 경우 &lt;code&gt;ContentHandlerFactory&lt;/code&gt; 를가 아직 설정되어 있지 않은 공장의 경우, 또는 &lt;code&gt;createContentHandler&lt;/code&gt; 의 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader의&lt;/a&gt; 메커니즘을 찾는 데 사용됩니다&lt;a href=&quot;contenthandlerfactory&quot;&gt; ContentHandlerFactory를&lt;/a&gt; 시스템 클래스 로더를 사용하여 구현. 팩토리가 위치하는 순서는 구현에 따라 다르며 배치 된 팩토리를 자유롭게 캐시 할 수 있습니다. &lt;code&gt;createContentHandler&lt;/code&gt; 에서 throw 된 &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt; , &lt;code&gt;Error&lt;/code&gt; 또는 &lt;code&gt;RuntimeException&lt;/code&gt; 이 발생 하면 호출 스레드로 전파됩니다. &lt;code&gt; createContentHandler&lt;/code&gt; 인스턴스화 된 경우 각 팩토리의 메소드는 팩토리가 널이 아닌 값을 리턴하거나 모든 팩토리가 소진 될 때까지 컨텐츠 유형으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dd48417e371ab33de209406773a687b4b7228a04" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;LoggerFinder&lt;/code&gt; provider is found, the system default &lt;code&gt;LoggerFinder&lt;/code&gt; implementation will be used.</source>
          <target state="translated">&lt;code&gt;LoggerFinder&lt;/code&gt; 공급자가 없으면 시스템 기본 &lt;code&gt;LoggerFinder&lt;/code&gt; 구현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce2df46d03f068b49d97f68dc89d5e9b2960ee5" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SSLContext&lt;/code&gt; was set in this client's builder, then the &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#getDefault()&quot;&gt;default context&lt;/a&gt; is returned.</source>
          <target state="translated">이 클라이언트의 빌더에 &lt;code&gt;SSLContext&lt;/code&gt; 가 설정 되지 않은 경우 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#getDefault()&quot;&gt;기본 컨텍스트&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="13df2cedfcaa3a22fc1954dda64acbabb2c44e93" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SSLParameters&lt;/code&gt; were set in the client's builder, then an implementation specific default set of parameters, that the client will use, is returned.</source>
          <target state="translated">클라이언트 빌더에 &lt;code&gt;SSLParameters&lt;/code&gt; 가 설정 되지 않은 경우 클라이언트가 사용할 구현 특정 기본 매개 변수 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1aacf1b45616404046adf43e5124614b11f8bf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SyncProvider&lt;/code&gt; object is specified, the reference implementation provider &lt;code&gt;RIOptimisticProvider&lt;/code&gt; is supplied.</source>
          <target state="translated">아니라면 &lt;code&gt;SyncProvider&lt;/code&gt; 개체가 지정 참조 구현 공급자 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0991a62933ecfd2bd1a1cdacfe077cecaa408e5f" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt; mechanism is used to locate &lt;a href=&quot;spi/urlstreamhandlerprovider&quot;&gt;URLStreamHandlerProvider&lt;/a&gt; implementations using the system class loader. The order that providers are located is implementation specific, and an implementation is free to cache the located providers. A &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;, &lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;RuntimeException&lt;/code&gt; thrown from the &lt;code&gt;createURLStreamHandler&lt;/code&gt;, if encountered, will be propagated to the calling thread. The &lt;code&gt;
     createURLStreamHandler&lt;/code&gt; method of each provider, if instantiated, is invoked, with the protocol string, until a provider returns non-null, or all providers have been exhausted.</source>
          <target state="translated">어떤 경우 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 를가 아직 설정되어 있지 않은 공장의 경우, 또는 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 의 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader의&lt;/a&gt; 메커니즘을 찾는 데 사용됩니다 &lt;a href=&quot;spi/urlstreamhandlerprovider&quot;&gt;URLStreamHandlerProvider&lt;/a&gt; 시스템 클래스 로더를 사용하여 구현. 공급자를 찾는 순서는 구현에 따라 다르며 구현은 찾은 공급자를 자유롭게 캐시 할 수 있습니다. &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;것은, ServiceConfigurationError&lt;/a&gt; , &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;createURLStreamHandler&lt;/code&gt; 에서 throw 또는 &lt;code&gt;RuntimeException&lt;/code&gt; 이 발생 하면 호출 스레드로 전파됩니다. &lt;code&gt; createURLStreamHandler&lt;/code&gt; 인스턴스화 된 경우 각 공급자의 메서드는 공급자가 null이 아닌 값을 반환하거나 모든 공급자가 소진 될 때까지 프로토콜 문자열과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48c606520866ed3b5c7ab60dadf8ce7019bfde30" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the constructor finds the value of the system property:</source>
          <target state="translated">어떤 경우 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 를가 아직 설정되어 있지 않은 공장의 경우, 또는 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 의 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; , 다음 생성자는 시스템 프로퍼티의 값을 찾습니다</target>
        </trans-unit>
        <trans-unit id="e563df7258f13a8f225773d813627e3543639a63" translate="yes" xml:space="preserve">
          <source>If no Configuration object has been installed in the runtime, a call to &lt;code&gt;getConfiguration&lt;/code&gt; installs an instance of the default Configuration implementation (a default subclass implementation of this abstract class). The default Configuration implementation can be changed by setting the value of the &lt;code&gt;login.configuration.provider&lt;/code&gt; security property to the fully qualified name of the desired Configuration subclass implementation.</source>
          <target state="translated">런타임에 Configuration 객체가 설치되지 않은 경우 &lt;code&gt;getConfiguration&lt;/code&gt; 을 호출 하면 기본 Configuration 구현 (이 추상 클래스의 기본 서브 클래스 구현)의 인스턴스가 설치됩니다. &lt;code&gt;login.configuration.provider&lt;/code&gt; 보안 특성 값을 원하는 구성 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 구성 구현을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f28da2d05be1c33c6f8a1b624ec1c4eb508ea0e9" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation.</source>
          <target state="translated">런타임에 Policy 객체가 설치되어 있지 않은 경우, &lt;code&gt;getPolicy&lt;/code&gt; 를 호출 하면 기본 Policy 구현의 인스턴스 (이 추상 클래스의 기본 서브 클래스 구현)가 설치됩니다. &lt;code&gt;policy.provider&lt;/code&gt; 보안 특성 의 값을 원하는 Policy 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 Policy 구현을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ff9c3a3e2b449d9fdfd8119017b2beec1065ca4" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation. The system class loader is used to load this class.</source>
          <target state="translated">런타임에 Policy 객체가 설치되지 않은 경우 &lt;code&gt;getPolicy&lt;/code&gt; 를 호출 하면 기본 Policy 구현 (이 추상 클래스의 기본 서브 클래스 구현)의 인스턴스가 설치됩니다. &lt;code&gt;policy.provider&lt;/code&gt; 보안 특성 의 값을 원하는 Policy 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 정책 구현을 변경할 수 있습니다 . 시스템 클래스 로더는이 클래스를로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef589a356e1913a9ee01360e4dbbec446e431cfd" translate="yes" xml:space="preserve">
          <source>If no System ID was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, String systemId)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt;&lt;code&gt;setSystemId(String systemId)&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, String systemId)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt; &lt;code&gt;setSystemId(String systemId)&lt;/code&gt; &lt;/a&gt; 를 통해 시스템 ID가 설정되지 않은 경우 , 다음 &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d8103a3ac14929d0ea6f76a89ffe79e5d895f4e5" translate="yes" xml:space="preserve">
          <source>If no access is allowed, the suffix is &quot;/noaccess&quot;.</source>
          <target state="translated">액세스가 허용되지 않으면 접미 부는 &quot;/ noaccess&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="51d8e33d13184ce0c057a13cfc7fd7024a488d5d" translate="yes" xml:space="preserve">
          <source>If no array is specified on the constructor, but tiling is allowed, then this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">생성자에 배열이 지정되지 않았지만 타일링이 허용되는 경우이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c0cfda8bbfe14b8fb38a9ed37f0082a13f36c5b4" translate="yes" xml:space="preserve">
          <source>If no attribute with this local name and namespace URI is found, this method has no effect.</source>
          <target state="translated">이 로컬 이름 및 네임 스페이스 URI가있는 속성이 없으면이 메서드는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8225a781e6aeb21876e42212e39dd339fac75791" translate="yes" xml:space="preserve">
          <source>If no attribute with this name is found, this method has no effect.</source>
          <target state="translated">이 이름을 가진 속성이 없으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4bff44b972295c18222a6d267bf9bd47ae29d380" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;#setCalendarType(java.lang.String)&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">&lt;a href=&quot;#setCalendarType(java.lang.String)&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt; 메서드 에 대한 호출로 달력 유형이 명시 적으로 지정되지 않은 경우 &lt;code&gt;Locale&lt;/code&gt; 값을 사용하여 &lt;code&gt;Calendar&lt;/code&gt; 유형을 결정합니다. 빌드 할 .</target>
        </trans-unit>
        <trans-unit id="f57aed5ec85446dac8b881e2e9691de38db155c7" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">&lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 호출로 일정 관리 유형이 명시 적으로 제공되지 않으면 &lt;code&gt;Locale&lt;/code&gt; 값을 사용하여 빌드 할 &lt;code&gt;Calendar&lt;/code&gt; 유형을 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="935be8843834b9a2add0a2c48a0401f80247fd8f" translate="yes" xml:space="preserve">
          <source>If no card is present in this terminal when this method is called, it returns immediately.</source>
          <target state="translated">이 메서드가 호출 될 때이 터미널에 카드가 없으면 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="635db19022015f7488d5435599c4fb48937a985a" translate="yes" xml:space="preserve">
          <source>If no class can be found in this way, this method will use an implementation-specific way to locate an implementation. If none is found, a NamingException is thrown.</source>
          <target state="translated">이런 방식으로 클래스를 찾을 수 없으면이 메소드는 구현 별 방법을 사용하여 구현을 찾습니다. 아무것도 발견되지 않으면 NamingException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ca30507c3453e7a86b86ecc80fdbdb06caf5ff95" translate="yes" xml:space="preserve">
          <source>If no compiler is available, these methods do nothing.</source>
          <target state="translated">사용 가능한 컴파일러가없는 경우이 메소드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03a20d9ed1179b7d5a03dd542c674e1b486901d" translate="yes" xml:space="preserve">
          <source>If no content handler could be &lt;a href=&quot;urlconnection#getContent()&quot;&gt;found&lt;/a&gt;, URLConnection will look for a content handler in a user-definable set of places. Users can define a vertical-bar delimited set of class prefixes to search through by defining the</source>
          <target state="translated">컨텐츠 핸들러를 &lt;a href=&quot;urlconnection#getContent()&quot;&gt;찾을&lt;/a&gt; 수없는 경우 URLConnection은 사용자 정의 가능한 위치 세트에서 컨텐츠 핸들러를 찾습니다. 사용자는 세로줄로 구분 된 클래스 접두사 집합을 정의하여 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="243bf1d6846d6372968ae561b146475eecd8f1fd" translate="yes" xml:space="preserve">
          <source>If no content handler could be found, URLConnection will look for a content handler in a user-defineable set of places. By default it looks in sun.net.www.content, but users can define a vertical-bar delimited set of class prefixes to search through in addition by defining the java.content.handler.pkgs property. The class name must be of the form:</source>
          <target state="translated">컨텐츠 핸들러를 찾을 수없는 경우 URLConnection은 사용자가 정의 할 수있는 장소 세트에서 컨텐츠 핸들러를 찾습니다. 기본적으로 sun.net.www.content에 있지만 사용자는 java.content.handler.pkgs 등록 정보를 정의하여 검색 할 세로 막대로 구분 된 클래스 접두사 세트를 정의 할 수 있습니다. 클래스 이름은 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="521ced0b1e8fb5511e3ff3521639bbd2e1d892dd" translate="yes" xml:space="preserve">
          <source>If no content handler factory has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the application loads the class named:</source>
          <target state="translated">컨텐츠 핸들러 팩토리가 아직 설정되지 않았거나 팩토리의 &lt;code&gt;createContentHandler&lt;/code&gt; 메소드가 &lt;code&gt;null&lt;/code&gt; 을 리턴 하면 애플리케이션은 다음과 같은 이름의 클래스를로드합니다.</target>
        </trans-unit>
        <trans-unit id="8116296a26510935b6c10d95ea6e65ff6f455a64" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 설명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;null&lt;/code&gt; 에서 반환 &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; ,이 방법은 반환해야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2514c39dc0080097bab43387d9c7ddb3546f473f" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityValues&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 설명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;null&lt;/code&gt; 에서 반환 &lt;code&gt;getCompressionQualityValues&lt;/code&gt; ,이 방법은 반환해야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78db565fdb9cf670cbeb4a07cf3f94628d766f5b" translate="yes" xml:space="preserve">
          <source>If no encoding is reachable through the above properties, a default encoding of &quot;UTF-8&quot; will be used. If the specified encoding is not supported an &quot;unsupported-encoding&quot; fatal error is raised.</source>
          <target state="translated">위의 속성을 통해 연결할 수있는 인코딩이 없으면 기본 인코딩 인 &quot;UTF-8&quot;이 사용됩니다. 지정된 인코딩이 지원되지 않으면 &quot;지원되지 않는 인코딩&quot;치명적 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d14c96365230fe95d4c170b5d326eb6ff39f4595" translate="yes" xml:space="preserve">
          <source>If no enough field parameters are given for determining date and/or time, calendar specific default values are used when building a &lt;code&gt;Calendar&lt;/code&gt;. For example, if the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; value isn't given for the Gregorian calendar, 1970 will be used. If there are any conflicts among field parameters, the &lt;a href=&quot;calendar#resolution&quot;&gt; resolution rules&lt;/a&gt; are applied. Therefore, the order of field setting matters.</source>
          <target state="translated">날짜 및 / 또는 시간을 결정하기위한 충분한 필드 매개 변수가 제공되지 않으면 &lt;code&gt;Calendar&lt;/code&gt; 를 작성할 때 달력 특정 기본값이 사용됩니다 . 예를 들어, Gregorian 달력에 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 값을 지정하지 않으면 1970이 사용됩니다. 필드 매개 변수간에 충돌이 있으면 &lt;a href=&quot;calendar#resolution&quot;&gt;해결 규칙&lt;/a&gt; 이 적용됩니다. 따라서 필드 설정 순서가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="98b4a446eb39aa005a8ac1b8be8c197590e7249d" translate="yes" xml:space="preserve">
          <source>If no explicit module prefix is given and modules are supported in the environment, a suitable module is inferred. If a suitable module cannot be inferred &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference.</source>
          <target state="translated">명시적인 모듈 접두사가 지정되지 않고 모듈이 환경에서 지원되는 경우 적절한 모듈이 유추됩니다. 적합한 모듈을 유추 할 수없는 경우 &lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 구현은 추론의 일부로 주석 처리 도구의 구성에 대한 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c83500feb8ee5817fa7b2052c71d1bfe69e3f6ba" translate="yes" xml:space="preserve">
          <source>If no face for the requested style can be found, the font system may apply algorithmic styling to achieve the desired style. For example, if &lt;code&gt;ITALIC&lt;/code&gt; is requested, but no italic face is available, glyphs from the plain face may be algorithmically obliqued (slanted).</source>
          <target state="translated">요청한 스타일의 얼굴을 찾을 수없는 경우 글꼴 시스템은 알고리즘 스타일을 적용하여 원하는 스타일을 얻을 수 있습니다. 예를 들어, &lt;code&gt;ITALIC&lt;/code&gt; 이 요청되었지만 사용 가능한 기울임 꼴면이없는 경우 일반면의 글리프가 알고리즘 적으로 기울어 질 수 있습니다 (경사).</target>
        </trans-unit>
        <trans-unit id="3c3b8e9ce2ba433f5bd56b760aee79cd23850c9f" translate="yes" xml:space="preserve">
          <source>If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.</source>
          <target state="translated">위의 1 단계에서 필드를 찾지 못하면이 알고리즘은 C의 각 직접 슈퍼 인터페이스에 재귀 적으로 적용됩니다. 직접 슈퍼 인터페이스는 선언 된 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="3a478bf1473f7f2d59cb1ae1a418bd4cb78d9c7e" translate="yes" xml:space="preserve">
          <source>If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a &lt;code&gt;NoSuchFieldException&lt;/code&gt; is thrown.</source>
          <target state="translated">위의 1, 2 단계에서 필드를 찾을 수없고 C에 수퍼 클래스 S가 있으면이 알고리즘은 S에 대해 재귀 적으로 호출됩니다. C에 수퍼 클래스가 없으면 &lt;code&gt;NoSuchFieldException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="157bac57c7c9bc8f974ce96ebf0d2865b133b27f" translate="yes" xml:space="preserve">
          <source>If no input methods are available or the current input method does not provide an input method control object, then null is returned.</source>
          <target state="translated">사용할 수있는 입력 방법이 없거나 현재 입력 방법이 입력 방법 제어 개체를 제공하지 않는 경우 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="85d8b2f1396493ecd88a1cad4f6f3c76ce079715" translate="yes" xml:space="preserve">
          <source>If no localization information is available, the non-localized name is returned.</source>
          <target state="translated">현지화 정보가 없으면 현지화되지 않은 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22fd3bbeb9c5dbaa32c21b11f1b89bc4bd8ecdd6" translate="yes" xml:space="preserve">
          <source>If no mapping rules exist to derive &lt;em&gt;opentype(J)&lt;/em&gt; from &lt;em&gt;J&lt;/em&gt;, then &lt;em&gt;J&lt;/em&gt; cannot be the type of a method parameter or return value in an MXBean interface.</source>
          <target state="translated">맵핑 규칙을 도출하도록 없으면 &lt;em&gt;오픈 (J)&lt;/em&gt; 에서 &lt;em&gt;J&lt;/em&gt; 후 &lt;em&gt;J는&lt;/em&gt; MXBean의 인터페이스 메소드 파라미터 나 리턴 값의 타입이 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="b5ddd6654d9c602c5f7f5aebb431141368be7c43" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">마크가 설정되어 있지 않은 경우, mark의 값은 생성자에게 건네지는 오프셋 (또는 오프셋이 제공되지 않은 경우는 0)입니다.</target>
        </trans-unit>
        <trans-unit id="bebf4b9fd62e0e0e062741afac69f1752343555c" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of the mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">마크가 설정되어 있지 않은 경우, 마크의 값은 생성자에게 건네지는 오프셋 (또는 오프셋이 제공되어 있지 않은 경우는 0)입니다.</target>
        </trans-unit>
        <trans-unit id="c4e2dfab8e70fdd67fdbf85be3aefb24cc2ae831" translate="yes" xml:space="preserve">
          <source>If no match is found with the &lt;code&gt;systemId&lt;/code&gt; and &lt;code&gt;public&lt;/code&gt; identifier, the resolver will continue searching &lt;code&gt;uri&lt;/code&gt; entries with the specified &lt;code&gt;systemId&lt;/code&gt; or &lt;code&gt;href&lt;/code&gt;. The &lt;code&gt;uri&lt;/code&gt; entries include &lt;code&gt;uri&lt;/code&gt;, &lt;code&gt;rewriteURI&lt;/code&gt;, and &lt;code&gt;uriSuffix&lt;/code&gt; entries.</source>
          <target state="translated">&lt;code&gt;systemId&lt;/code&gt; 및 &lt;code&gt;public&lt;/code&gt; 식별자 와 일치하는 항목이 없으면 확인자는 지정된 &lt;code&gt;systemId&lt;/code&gt; 또는 &lt;code&gt;href&lt;/code&gt; 를 사용하여 &lt;code&gt;uri&lt;/code&gt; 항목을 계속 검색 합니다 . &lt;code&gt;uri&lt;/code&gt; 항목이 포함 &lt;code&gt;uri&lt;/code&gt; , &lt;code&gt;rewriteURI&lt;/code&gt; 및 &lt;code&gt;uriSuffix&lt;/code&gt; 을 항목을.</target>
        </trans-unit>
        <trans-unit id="ca0a82059235a2192c2af72074baf7ab9d68bd42" translate="yes" xml:space="preserve">
          <source>If no match is found, &lt;code&gt;public&lt;/code&gt; entries may be searched in accordance with the &lt;code&gt;prefer&lt;/code&gt; attribute.</source>
          <target state="translated">일치하는 항목이없는 경우 &lt;code&gt;prefer&lt;/code&gt; 항목에 따라 &lt;code&gt;public&lt;/code&gt; 항목을 검색 할 수 있습니다. 속성 .</target>
        </trans-unit>
        <trans-unit id="04e67c9a77bba1f9d49ec8d97898bd5df73e6e1e" translate="yes" xml:space="preserve">
          <source>If no matching method is found by step 1 then:</source>
          <target state="translated">1 단계에서 일치하는 방법을 찾지 못하면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="98b1341ab5d1352e8c92eb553367593ccb7794fd" translate="yes" xml:space="preserve">
          <source>If no node was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, String systeId)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setNode(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;setNode(Node node)&lt;/code&gt;&lt;/a&gt;, then the node will be set by the transformation, and may be obtained from this method once the transformation is complete. Calling this method before the transformation will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">어떤 노드로 설정되어 있지 않은 경우 &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, String systeId)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setNode(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;setNode(Node node)&lt;/code&gt; &lt;/a&gt; 후, 노드는 변환에 의해 설정되며 변환이 완료되면이 메서드에서 얻을 수 있습니다. 변환 전에이 메서드를 호출하면 &lt;code&gt;null&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2c6ebb366cc139ff51efee5ce5b414347a8bb8" translate="yes" xml:space="preserve">
          <source>If no node was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setNextSibling(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;setNextSibling(Node nextSibling)&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">어떤 노드를 통해 설정되어 있지 않은 경우 &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setNextSibling(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;setNextSibling(Node nextSibling)&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd216b7387fe2dee5dd00b4fdaab3ce4feee3b7f" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">다른 스레드가 교환을 기다리고 있지 않은 경우, 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하며 다음 세 가지 중 하나가 발생할 때까지 휴면 상태입니다.</target>
        </trans-unit>
        <trans-unit id="f82da2a19e504b2d12c547c6cd21c732ba85238d" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">다른 스레드가 교환을 기다리고 있지 않으면 스레드 예약을 위해 현재 스레드가 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="1d8f5c6897dfd0200026687e7449f5e103ba0680" translate="yes" xml:space="preserve">
          <source>If no output DOM source is set, the transformation will create a Document node as the holder for the result of the transformation, which may be retrieved with &lt;a href=&quot;#getNode()&quot;&gt;&lt;code&gt;getNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">출력 DOM 소스가 설정되지 않은 경우 변환은 &lt;a href=&quot;#getNode()&quot;&gt; &lt;code&gt;getNode()&lt;/code&gt; &lt;/a&gt; 하여 검색 할 수있는 변환 결과에 대한 홀더로 Document 노드를 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="60a5d7e2c9421527851b4de33c50dfcdd772e870" translate="yes" xml:space="preserve">
          <source>If no output is specified in the &lt;code&gt;LSOutput&lt;/code&gt;, a &quot;no-output-specified&quot; fatal error is raised.</source>
          <target state="translated">&lt;code&gt;LSOutput&lt;/code&gt; 에 출력이 지정되지 않은 경우 &quot;no-output-specified&quot;치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8c99a978e37655f05ece5d09a50cf601a4c0974" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">사용 가능한 허가가없는 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="05c5dee407f95ed89e404e9d431ede44a984e5d6" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">사용 가능한 허가가없는 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="f257165424661099344b4c148a094fafc4e79eea" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">사용 가능한 허용이 없으면 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다른 스레드가 &lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 휴면 상태가됩니다. 가이 세마포어에 대한 메서드를 하고 현재 스레드에 다음으로 허용이 할당 가됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0c61688e7523da669464298c2f1d9cfc1f08b7" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">사용 가능한 허가가없는 경우, 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다른 스레드 가이 세마포어에 대한 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하고 현재 스레드에 허가가 할당 될 때까지 휴면 상태 가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd133845b033ac7223fae8a2a495d3b108c36d1d" translate="yes" xml:space="preserve">
          <source>If no permit is available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 허가가없는 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="5d71b912edbe329f77d7b28fabf9c3de6a91d65f" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 경우를 포함하여 위 단계에서 공급자를 찾을 수없는 경우 구현은 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 throw합니다 . 구현은 다른 방법으로 공급자를 찾을 수 있습니다. 예를 들어 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;서비스 제공 업체를&lt;/a&gt; 지원할 수 있으며 서비스 인터페이스는 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40de0681afbfe30c5174ef02550d9cb4e2c2be74" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 경우를 포함하여 위 단계에서 공급자를 찾을 수없는 경우 구현은 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 throw합니다 . 구현은 다른 방법으로 공급자를 찾을 수 있습니다. 예를 들어 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;서비스 공급자를&lt;/a&gt; 지원할 수 있으며 서비스 인터페이스는 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91b1ae1535d1f33ae0e732627166d15b6a2cc1cc" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 사례를 포함하여 위의 단계에서 공급자를 찾지 못하면 구현시 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 발생시킵니다. 구현은 다른 방법으로 공급자를 찾도록 선택할 수 있습니다. 예를 들어, 서비스 인터페이스가 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 인&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;서비스 제공자에 대한 JAR 규칙을&lt;/a&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70dda654250368e808b6b425e672a82e81efe712" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 사례를 포함하여 위의 단계에서 공급자를 찾지 못하면 구현시 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 발생시킵니다. 구현은 다른 방법으로 공급자를 찾도록 선택할 수 있습니다. 예를 들어, 서비스 인터페이스가 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 인&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;서비스 제공자에 대한 JAR 규칙을&lt;/a&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="358e4b9d7ce6402f029c918e9fe871624205bf53" translate="yes" xml:space="preserve">
          <source>If no schema is being used, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">사용중인 스키마가 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="913b2ab905dfc209e536f0bbc14b4b2d62954ca4" translate="yes" xml:space="preserve">
          <source>If no such listeners exist, this method returns an empty array.</source>
          <target state="translated">그러한 리스너가 없으면이 메서드는 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4f99c7ebdd694b15a7a1884c5882e8188c69e3f" translate="yes" xml:space="preserve">
          <source>If no such value of</source>
          <target state="translated">그러한 가치가 없다면</target>
        </trans-unit>
        <trans-unit id="b1a3c651aeb30026243d1fce39999de76ba1d1b7" translate="yes" xml:space="preserve">
          <source>If no such value of &lt;code&gt;k&lt;/code&gt; exists, then &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">이러한 값의 경우 &lt;code&gt;k&lt;/code&gt; 존재하지 후 &lt;code&gt;-1&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="6ba9d8d2bfd2921beec7b4626cc18a496f95ecd1" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;#getId()&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;#getId()&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="14f661da1d4c4d0449092dff36f1322744a317c5" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;#getValue()&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;#getValue()&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8098cc1dcdc7eef18c37176303f3d539ee64942f" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;dayofweek#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;dayofweek#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="de90c966ff366bae8a6ebf647919730e37775606" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue()&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;era#getValue()&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="172481aa19fb2665297fe8e01e1a105abb6a4821" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;era#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="36c6de59e58640f47a0ec5a526b903e6cdb5056b" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;month#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;month#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="26dec5e0aab4853771305a15bb1f061f803aacdf" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;zoneid#getId--&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;zoneid#getId--&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9627881d92575480927b9f03e39660f159d5d615" translate="yes" xml:space="preserve">
          <source>If no thread factory is supplied via a system property, then the common pool uses a factory that uses the system class loader as the &lt;a href=&quot;../../lang/thread#getContextClassLoader()&quot;&gt;thread context class loader&lt;/a&gt;. In addition, if a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present, then the common pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">시스템 속성을 통해 스레드 팩토리가 제공되지 않으면 공통 풀은 시스템 클래스 로더를 &lt;a href=&quot;../../lang/thread#getContextClassLoader()&quot;&gt;스레드 컨텍스트 클래스 로더&lt;/a&gt; 로 사용하는 팩토리를 사용합니다 . 또한 &lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; 가있는 경우 공용 풀은 사용 &lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt; 활성화 되지 않은 스레드를 제공하는 팩토리를 사용합니다. 이러한 설정을 구성하는 데 오류가 발생하면 기본 매개 변수가 사용됩니다. parallelism 속성을 0으로 설정하거나 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수있는 팩토리를 사용하여 공용 풀에서 스레드 사용을 비활성화하거나 제한 할 수 있습니다 . 그러나 이렇게하면 결합되지 않은 작업이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2720f481dd9e3309673a042872b8da0c6951d663" translate="yes" xml:space="preserve">
          <source>If no update listeners are present, the reader may choose to perform fewer updates to the pixels of the destination images and/or thumbnails, which may result in more efficient decoding.</source>
          <target state="translated">업데이트 리스너가 존재하지 않으면, 리더기는 목적지 이미지 및 / 또는 썸네일의 픽셀에 대해 더 적은 업데이트를 수행하도록 선택할 수 있으며, 이는 더 효율적인 디코딩을 초래할 수있다.</target>
        </trans-unit>
        <trans-unit id="659fa912faf7661e5693f814302e025b38ad17a1" translate="yes" xml:space="preserve">
          <source>If no user-defined content handler is found, then the system tries to load a specific</source>
          <target state="translated">사용자 정의 컨텐츠 핸들러를 찾을 수없는 경우 시스템은 특정</target>
        </trans-unit>
        <trans-unit id="65635a172a1530aa46f43e5e3e59c9e001180baa" translate="yes" xml:space="preserve">
          <source>If no value is specified, a system or implementation default value will be applied.</source>
          <target state="translated">값을 지정하지 않으면 시스템 또는 구현 기본값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3443f1520516224d5cac9f52fd3f3bc9e3c3f5f9" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">&lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt; 메서드 에 대한 호출로 주 정의 매개 변수가 명시 적으로 제공되지 않으면 &lt;code&gt;Locale&lt;/code&gt; 의 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e2d9f63d3b68d988634ea3a7fd560c86f5e146" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">&lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 주 정의 매개 변수를 명시 적으로 지정하지 않으면 &lt;code&gt;Locale&lt;/code&gt; 의 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4076d96bb4d80dea21dec4f9083af903b3282c51" translate="yes" xml:space="preserve">
          <source>If none of the above are true, &lt;code&gt;implies&lt;/code&gt; returns false.</source>
          <target state="translated">위의 어느 것도 해당하지 않는 경우, &lt;code&gt;implies&lt;/code&gt; 를 반환 거짓을.</target>
        </trans-unit>
        <trans-unit id="aa27ae8e73e51a59ee422ae500f77a07374ba6be" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, module, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup()&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">위의 경우에 해당되지 않는 경우 전체 액세스 (공개, 모듈, 패키지, 개인 및 보호)가 허용되는 경우입니다. 이 경우 접미사가 추가되지 않습니다. 이것은 원래 &lt;a href=&quot;methodhandles#lookup()&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt; 에서 가져온 객체에만 해당됩니다 . &lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; 에서&lt;/a&gt; 만든 개체 항상 액세스가 제한되며 접미사를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="65b4b808e5f83fdac6e6f8fa54fe10637573639b" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">위의 어느 경우에도 해당되지 않는 경우 전체 액세스 (공용, 패키지, 개인 및 보호)가 허용되는 경우입니다. 이 경우 접미사가 추가되지 않습니다. 이것은 원래 &lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt; 에서 얻은 객체에만 해당됩니다 . &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; 으로&lt;/a&gt; 만든 개체는 항상 액세스가 제한되며 접미사를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9afb92f74699e092dd43aa6f4a4f20ab8baaf008" translate="yes" xml:space="preserve">
          <source>If none of the package prefixes work, null is returned.</source>
          <target state="translated">작동하는 패키지 접두사가 없으면 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa3a39e0c5471c8e92b9112af6f11814ae21d0e" translate="yes" xml:space="preserve">
          <source>If none of the previous conditions hold then this thread's interrupt status will be set.</source>
          <target state="translated">이전 조건 중 어느 것도 유지되지 않으면이 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="346f69aa8643809549df322ad150080572449fc7" translate="yes" xml:space="preserve">
          <source>If none of these conditions is met, the MBean is invalid and the attempt to register it will generate &lt;a href=&quot;notcompliantmbeanexception&quot;&gt;&lt;code&gt;NotCompliantMBeanException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 조건 중 어느 것도 충족되지 않으면 MBean이 유효하지 않으며 등록을 시도하면 &lt;a href=&quot;notcompliantmbeanexception&quot;&gt; &lt;code&gt;NotCompliantMBeanException&lt;/code&gt; &lt;/a&gt; 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee9f8a416324d0ea9e24a3249a1da2412abc73d7" translate="yes" xml:space="preserve">
          <source>If not already closed, the input remains open until a Close message &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;received&lt;/a&gt;, or &lt;code&gt;abort&lt;/code&gt; is invoked, or an &lt;a href=&quot;websocket.listener#onError(java.net.http.WebSocket,java.lang.Throwable)&quot;&gt;error&lt;/a&gt; occurs.</source>
          <target state="translated">아직 닫히지 않은 경우 Close 메시지가 &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;수신&lt;/a&gt; 되거나 &lt;code&gt;abort&lt;/code&gt; 이 호출되거나 &lt;a href=&quot;websocket.listener#onError(java.net.http.WebSocket,java.lang.Throwable)&quot;&gt;오류가 발생할&lt;/a&gt; 때까지 입력이 열린 상태로 유지 됩니다. 가 발생할 .</target>
        </trans-unit>
        <trans-unit id="9f8a9a330958ea8b81d0d1085cfbfef23cbec83f" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메서드를 호출 하여 지정된 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="2c5743411e869e01038b5d76b71612dce8dfd329" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메소드의 호출로 지정된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf1d0245b93227342f069b480c62ecce5abc272e" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 완료되지 않은 경우, &lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt; 으로이 CompletableFuture를 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="716a361131a6632fa2e7d2e54111159994780e51" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;. Dependent CompletableFutures that have not already completed will also complete exceptionally, with a &lt;a href=&quot;completionexception&quot;&gt;&lt;code&gt;CompletionException&lt;/code&gt;&lt;/a&gt; caused by this &lt;code&gt;CancellationException&lt;/code&gt;.</source>
          <target state="translated">아직 완료하지 않은 경우,이 CompletableFuture를 &lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt; 과 함께 완료하십시오 . 아직 완료되지 않은 종속 CompletableFuture는 이 &lt;code&gt;CancellationException&lt;/code&gt; 으로 인한 &lt;a href=&quot;completionexception&quot;&gt; &lt;code&gt;CompletionException&lt;/code&gt; &lt;/a&gt; 과 함께 예외적으로 완료 됩니다 .</target>
        </trans-unit>
        <trans-unit id="3336ef80734923602b92caaa54e44a6a44b10fdf" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메서드에서 반환 된 값을 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2f1a9e000d1c1d155d951430a94c358745c05ace" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메소드가 리턴 한 값을 제공된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2832c345bb20d08c6428b67a080d7bc676ec986f" translate="yes" xml:space="preserve">
          <source>If not overriden, the resolving parent defaults to the parent element.</source>
          <target state="translated">재정의되지 않은 경우 해결 부모는 기본적으로 부모 요소로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="06df59153329c54021d8f318749947771342b429" translate="yes" xml:space="preserve">
          <source>If not running in a ForkJoinPool, this method is behaviorally equivalent to</source>
          <target state="translated">ForkJoinPool에서 실행되지 않는 경우이 방법은 동작과 동일합니다</target>
        </trans-unit>
        <trans-unit id="33cb4eee9f72e7c592a0781119cfa5815c0c26bf" translate="yes" xml:space="preserve">
          <source>If not specified, the Namespace URI is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. If not specified, the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정되지 않은 경우 네임 스페이스 URI는 &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 . 지정되지 않은 경우 접두사는 &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdc33934659b2005c4bd2af74fa05dccbb573691" translate="yes" xml:space="preserve">
          <source>If obj is non-null, it should be a primitive array of type TransferType. Otherwise, a ClassCastException is thrown. An ArrayIndexOutOfBoundsException may be thrown if the coordinates are not in bounds, or if obj is non-null and is not large enough to hold the pixel data.</source>
          <target state="translated">obj가 널이 아닌 경우 TransferType 유형의 기본 배열이어야합니다. 그렇지 않으면 ClassCastException이 발생합니다. 좌표가 경계 내에 있지 않거나 obj가 null이 아니고 픽셀 데이터를 저장할만큼 크지 않은 경우 ArrayIndexOutOfBoundsException이 throw 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4963d6f03243f1b1eefc52d1ee78e3de46655e5a" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompositeName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 CompositeName 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cfed25f27277239376cbbd5795fd1f2017c24525" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompoundName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 CompoundName의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1c9d5558d685db1a02cae49432f75e2eb93c619" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of LdapName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 LdapName의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bf13cf38688995f01fe92d7c8213b9203d51d95" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 Rdn의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b1bd38492a7c5fc97a66ea1dc538a1fb693b2c3" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, false is returned.</source>
          <target state="translated">obj가 null이거나 Rdn 인스턴스가 아닌 경우 false가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db27cf2143ef5e69d57f054992bd236034dac929" translate="yes" xml:space="preserve">
          <source>If object replacement is currently not enabled, and &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to ensure that the caller is permitted to enable the stream to do replacement of objects read from the stream.</source>
          <target state="translated">객체 교체가 현재 사용하고 있지 않은 경우 &lt;code&gt;enable&lt;/code&gt; 사실 및 설치된 보안 매니저가 존재하는,이 메소드는 최초로 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 과 방법을 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; 호출자가 스트림을 가능하게 할 수 있다는 것을 보증합니다 스트림에서 읽은 객체를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c47a2363c1646e07fb7efdcb6b37946f1291ed86" translate="yes" xml:space="preserve">
          <source>If object replacement is currently not enabled, and &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to ensure that the caller is permitted to enable the stream to do replacement of objects written to the stream.</source>
          <target state="translated">객체 교체가 현재 사용하고 있지 않은 경우 &lt;code&gt;enable&lt;/code&gt; 사실 및 설치된 보안 매니저가 존재하는,이 메소드는 최초로 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 과 방법을 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; 호출자가 스트림을 가능하게 할 수 있다는 것을 보증합니다 스트림에 기록 된 객체를 교체합니다.</target>
        </trans-unit>
        <trans-unit id="6bc0bc4fab7d5c4262f47e32108a9c0ec0a06d6f" translate="yes" xml:space="preserve">
          <source>If one is not found, it searches the set of &lt;code&gt;ScriptEngineFactory&lt;/code&gt; instances stored by the constructor for one with the specified name. If a &lt;code&gt;ScriptEngineFactory&lt;/code&gt; is found by either method, it is used to create instance of &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">하나를 찾지 못하면 생성자가 저장 한 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 인스턴스 세트 에서 지정된 이름을 가진 인스턴스를 검색합니다 . 경우 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 에이 중 하나의 방법으로 발견,의 인스턴스를 생성하는 데 사용됩니다 &lt;code&gt;ScriptEngine&lt;/code&gt; 를 검색 .</target>
        </trans-unit>
        <trans-unit id="624173e017b005ddaae7fe37b2623ee7c893a0a0" translate="yes" xml:space="preserve">
          <source>If one of the arguments does not occur in the pattern.</source>
          <target state="translated">패턴에서 인수 중 하나가 발생하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="491c4f907fd22e40d7d0381d99943007b7f1cc80" translate="yes" xml:space="preserve">
          <source>If one of the commands in a batch update fails to execute properly, this method throws a &lt;code&gt;BatchUpdateException&lt;/code&gt;, and a JDBC driver may or may not continue to process the remaining commands in the batch. However, the driver's behavior must be consistent with a particular DBMS, either always continuing to process commands or never continuing to process commands. If the driver continues processing after a failure, the array returned by the method &lt;code&gt;BatchUpdateException.getLargeUpdateCounts&lt;/code&gt; will contain as many elements as there are commands in the batch, and at least one of the elements will be the following:</source>
          <target state="translated">배치 업데이트의 명령 중 하나가 제대로 실행되지 않으면이 메서드는 &lt;code&gt;BatchUpdateException&lt;/code&gt; 을 발생시키고 JDBC 드라이버는 배치의 나머지 명령을 계속 처리하거나 처리하지 않을 수 있습니다. 그러나 드라이버의 동작은 항상 명령 처리를 계속하거나 명령 처리를 계속하지 않는 특정 DBMS와 일치해야합니다. 드라이버가 실패 후에도 처리를 계속하면 &lt;code&gt;BatchUpdateException.getLargeUpdateCounts&lt;/code&gt; 메서드에서 반환 된 배열 에 일괄 처리에있는 명령 수만큼의 요소가 포함되며 요소 중 하나 이상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a07c16265df1b097f41111154f5c947cf4a13b17" translate="yes" xml:space="preserve">
          <source>If one of the commands in a batch update fails to execute properly, this method throws a &lt;code&gt;BatchUpdateException&lt;/code&gt;, and a JDBC driver may or may not continue to process the remaining commands in the batch. However, the driver's behavior must be consistent with a particular DBMS, either always continuing to process commands or never continuing to process commands. If the driver continues processing after a failure, the array returned by the method &lt;code&gt;BatchUpdateException.getUpdateCounts&lt;/code&gt; will contain as many elements as there are commands in the batch, and at least one of the elements will be the following:</source>
          <target state="translated">일괄 업데이트의 명령 중 하나가 제대로 실행되지 않으면이 메서드는 &lt;code&gt;BatchUpdateException&lt;/code&gt; 을 발생시키고 JDBC 드라이버는 일괄 처리의 나머지 명령을 계속 처리 할 수도 있고 처리하지 않을 수도 있습니다. 그러나 드라이버의 동작은 항상 명령 처리를 계속하거나 명령 처리를 계속하지 않는 특정 DBMS와 일치해야합니다. 드라이버가 실패 후에도 처리를 계속하는 경우 &lt;code&gt;BatchUpdateException.getUpdateCounts&lt;/code&gt; 메서드에서 반환 된 배열 에는 일괄 처리에있는 명령 수만큼의 요소가 포함되며 요소 중 하나 이상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbb26d8aea49aec8452c4aea8b4bbd3bc4797c37" translate="yes" xml:space="preserve">
          <source>If one of the first two arguments is infinite and the other is zero, the result is NaN.</source>
          <target state="translated">처음 두 인수 중 하나가 무한이고 다른 인수가 0이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="a2cb09ff6c56a4c92e19e76c548f38b158889e4b" translate="yes" xml:space="preserve">
          <source>If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components.</source>
          <target state="translated">하나 또는 두 개의 권한 구성 요소가 레지스트리 기반 인 경우 URI는 해당 권한 구성 요소의 순서에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1cdcf3eae93e731adef7dce9b1512efd07547e12" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">어떤 이유로 든 하나 이상의 속성을 검색 할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 목록이 &lt;code&gt;attributes&lt;/code&gt; 배열 과 동일한 크기인지 확인해야합니다 . 주어진 속성이 검색되지 못하게하는 문제를 발견하려면 해당 속성에 대해 &lt;a href=&quot;#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6e2411b61caee1b0fdbbdceb845f12804209588" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">어떤 이유로 든 하나 이상의 속성을 검색 할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 목록이 &lt;code&gt;attributes&lt;/code&gt; 배열 과 동일한 크기인지 확인해야합니다 . 주어진 속성이 검색되지 못하게하는 문제를 발견하려면 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fb7857e904a130ed28ddd9eed419d0b930d6e9e" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 검색 할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 목록이 &lt;code&gt;attributes&lt;/code&gt; 배열 과 동일한 크기인지 확인해야합니다 . 주어진 속성을 검색 할 수없는 문제점을 발견하려면 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a570e550931dc8b2096c4798b37ec71a67373125" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 설정할 수없는 경우 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 입력 &lt;code&gt;AttributeList&lt;/code&gt; 가 출력과 동일한 크기인지 확인해야합니다 . 어떤 문제로 인해 주어진 속성이 검색 되지 않았 는지 알아 보려면 일반적으로 해당 속성에 대해 &lt;a href=&quot;#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다. (예를 들어, 두 속성의 값이 서로 일치하지 않아 거부되었을 수 있습니다. 둘 중 하나만 설정해도됩니다.)</target>
        </trans-unit>
        <trans-unit id="230dbeb4c4a040a775eadcb4d42ecfa395b556e8" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 설정할 수없는 경우 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 입력 &lt;code&gt;AttributeList&lt;/code&gt; 가 출력과 동일한 크기인지 확인해야합니다 . 어떤 문제로 인해 주어진 속성이 검색 되지 않았 는지 알아 보려면 일반적으로 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다. (예를 들어, 두 속성의 값이 서로 일치하지 않아 거부되었을 수 있습니다. 둘 중 하나만 설정해도됩니다.)</target>
        </trans-unit>
        <trans-unit id="1cb46e59026371f237c846d747b96cfab81aa6f7" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 설정할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 입력 된 &lt;code&gt;AttributeList&lt;/code&gt; 가 출력되는 것과 동일한 크기인지 확인해야합니다 . 주어진 속성을 검색 할 수없는 문제점을 발견하기 위해 일반적으로 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 는 있지만 작동하지 않을 수도 있습니다. 예를 들어, 두 속성의 값이 서로 일치하지 않아 거부되었을 수 있습니다. 둘 중 하나만 설정하는 것이 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab57ba0e0e796f21f0a41d005906eb71fb4cd0d" translate="yes" xml:space="preserve">
          <source>If one or more disconnected &lt;code&gt;RowSet&lt;/code&gt; objects are participating in a global transaction, they may wish to coordinate their synchronization commits to preserve data integrity and reduce the number of synchronization exceptions. If this is the case, an application should set the &lt;code&gt;CachedRowSet&lt;/code&gt; constant &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; and use the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;rollback&lt;/code&gt; methods defined in this interface to manage transaction boundaries.</source>
          <target state="translated">하나 이상의 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체가 전역 트랜잭션에 참여하는 경우 데이터 무결성을 유지하고 동기화 예외 수를 줄이기 위해 동기화 커밋을 조정할 수 있습니다. 이 경우 애플리케이션은 &lt;code&gt;CachedRowSet&lt;/code&gt; 상수 &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하고이 인터페이스에 정의 된 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;rollback&lt;/code&gt; 메서드를 사용하여 트랜잭션 경계를 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="fea5108f8ecd0c55ef6981d1ca12427bdd2d199c" translate="yes" xml:space="preserve">
          <source>If one value is a primitive array then the other must be a primitive array of the same type with the same elements.</source>
          <target state="translated">하나의 값이 기본 배열 인 경우 다른 값은 동일한 요소를 가진 동일한 유형의 기본 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="23324c117f5f2583f364f13ab7b02fbef6103829" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">한 값이 객체 배열이면 다른 값도 있어야하며 &lt;a href=&quot;../../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2342ef0932b8de2cf5319fdb221bf8d24533db0" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">한 값이 객체 배열이면 다른 값도 있어야하며 &lt;a href=&quot;../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="83b598a4bb6d8d15d44e8e6f9778b65445620655" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">한 값이 객체 배열이면 다른 값도 있어야하고 &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca221d63216bb033111f2713610351d2376eca45" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">하나의 값이 객체 배열이면 다른 값도 같아야하며 &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8317f7140fbe4d8e0a19dbbc989d6c95b4bba3de" translate="yes" xml:space="preserve">
          <source>If one value is null then the other must be too.</source>
          <target state="translated">하나의 값이 null이면 다른 값도 null이어야합니다.</target>
        </trans-unit>
        <trans-unit id="73766e9e928dc54454acb02c297d1f4e58f13c99" translate="yes" xml:space="preserve">
          <source>If only public access and unconditional access are allowed, the suffix is &quot;/publicLookup&quot;.</source>
          <target state="translated">공용 액세스 및 무조건 액세스 만 허용되는 경우 접미사는 &quot;/ publicLookup&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="46ccc3cea31a77de6874e4d69188651ef3350460" translate="yes" xml:space="preserve">
          <source>If only public access is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">공개 액세스 만 허용되는 경우 접미사는 &quot;/ public&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6d7a4b935aaeac5d27171aa447cb0be5037b635a" translate="yes" xml:space="preserve">
          <source>If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">내 보낸 패키지의 유형에 대한 공용 액세스 만 허용되는 경우 접미사는 &quot;/ public&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5b887737a3d95a66cbb55d332a4697c243ecd0a7" translate="yes" xml:space="preserve">
          <source>If only public and module access are allowed, the suffix is &quot;/module&quot;.</source>
          <target state="translated">공용 및 모듈 액세스 만 허용되는 경우 접미사는 &quot;/ module&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="17e35151d3a9c5e62004f06cdd120c3d5af02427" translate="yes" xml:space="preserve">
          <source>If only public and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">공개 및 패키지 액세스 만 허용되는 경우 접미사는 &quot;/ package&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="69d58dad869cac05ad492aa9acfab56072768dd8" translate="yes" xml:space="preserve">
          <source>If only public, module and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">공용, 모듈 및 패키지 액세스 만 허용되는 경우 접미사는 &quot;/ package&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5a749739e2c519e03259e6286361548abdc9b6a8" translate="yes" xml:space="preserve">
          <source>If only public, module, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">공용, 모듈, 패키지 및 개인 액세스 만 허용되는 경우 접미사는 &quot;/ private&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="78a5d707938565d1ab21a382651974405944eeaa" translate="yes" xml:space="preserve">
          <source>If only public, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">공개, 패키지 및 개인 액세스 만 허용되는 경우 접미사는 &quot;/ private&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b505d5ce8be021b34190ba8758c0f40cdae3cfbe" translate="yes" xml:space="preserve">
          <source>If other values are desired, an application must set the property values explicitly. For example, the following line of code sets the maximum number of rows for the &lt;code&gt;CachedRowSet&lt;/code&gt; object</source>
          <target state="translated">다른 값이 필요한 경우 응용 프로그램에서 속성 값을 명시 적으로 설정해야합니다. 예를 들어 다음 코드 줄은 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체 의 최대 행 수를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="5ff5bcea26eb9f57c1f61e4d4b69139bd9e67391" translate="yes" xml:space="preserve">
          <source>If passed to the appropriate variant of java.beans.Beans.instantiate this method will be called in order to associate the newly instantiated Applet (JavaBean) with its AppletContext, AppletStub, and Container.</source>
          <target state="translated">적절한 java.beans.Beans.instantiate 변형에 전달되면 새로 인스턴스화 된 애플릿 (JavaBean)을 AppletContext, AppletStub 및 Container와 연관시키기 위해이 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63592e8ff0ed49f336b285894d4830d793307f4a" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; subsequent start requests are not affected by an interrupted loop operation.</source>
          <target state="translated">루핑 중에 재생이 중지되면 현재 루프 상태가 지워집니다. 후속 시작 요청은 인터럽트 된 루프 작업의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9cbc94cbe4e5c51dea79fe6a36851f807b7c43f" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; the behavior of subsequent loop and start requests is not affected by an interrupted loop operation.</source>
          <target state="translated">루핑 중에 재생이 중지되면 현재 루프 상태가 지워집니다. 후속 루프 및 시작 요청의 동작은 인터럽트 된 루프 작업의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e381a3ab9ce40b66156b275b2ddf1afe5445d87" translate="yes" xml:space="preserve">
          <source>If possible, display this frame in an appropriate location.</source>
          <target state="translated">가능하면이 프레임을 적절한 위치에 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="b532b85dabe94af369148e9d31febd94ae2e1477" translate="yes" xml:space="preserve">
          <source>If possible, display this frame in an appropriate location. Normally, this is not called, as the creator of the JInternalFrame will add the frame to the appropriate parent.</source>
          <target state="translated">가능하면이 프레임을 적절한 위치에 표시하십시오. 일반적으로 이것은 JInternalFrame의 생성자가 적절한 부모에 프레임을 추가하기 때문에 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d85adb7142d0513e17f4f180e854c7f586b64e2a" translate="yes" xml:space="preserve">
          <source>If possible, the SAX driver should provide the line position of the first character after the text associated with the document event. The first column in each line is column 1.</source>
          <target state="translated">가능한 경우 SAX 드라이버는 문서 이벤트와 관련된 텍스트 뒤의 첫 번째 문자의 줄 위치를 제공해야합니다. 각 줄의 첫 번째 열은 열 1입니다.</target>
        </trans-unit>
        <trans-unit id="04cf22c6258b3cdaaa6e80d2a29b8433dceb3a5d" translate="yes" xml:space="preserve">
          <source>If possible, the SAX driver should provide the line position of the first character after the text associated with the document event. The first line is line 1.</source>
          <target state="translated">가능한 경우 SAX 드라이버는 문서 이벤트와 관련된 텍스트 뒤의 첫 번째 문자의 줄 위치를 제공해야합니다. 첫 번째 줄은 1 번 줄입니다.</target>
        </trans-unit>
        <trans-unit id="49bbc2bd93bc284a0af94a66587e35a5d285e02f" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means ignore the case when comparing name components. If its value is not &quot;true&quot;, or if the property is not present, case is considered when comparing name components.</source>
          <target state="translated">있는 경우 &quot;true&quot;는 이름 구성 요소를 비교할 때 대소 문자를 무시 함을 의미합니다. 값이 &quot;true&quot;가 아니거나 속성이 없으면 이름 구성 요소를 비교할 때 대 / 소문자가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="76f581deb106b2ac36d486ca5972b20b2708e882" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means trim any leading and trailing whitespaces in a name component for comparison purposes. If its value is not &quot;true&quot;, or if the property is not present, blanks are significant.</source>
          <target state="translated">있는 경우 &quot;true&quot;는 비교 목적으로 이름 구성 요소에서 선행 및 후행 공백을 제거하는 것을 의미합니다. 값이 &quot;true&quot;가 아니거나 속성이 없으면 공백이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f71c029405d6c4413ebcbb2a962ddc2c412a1ce0" translate="yes" xml:space="preserve">
          <source>If present, specifies the escape string for overriding separator, escapes and quotes.</source>
          <target state="translated">존재하는 경우 구분 기호, 이스케이프 및 따옴표를 재정의하는 이스케이프 문자열을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b3051402e5a243fd5b4ebf35b610a599bf72fd9d" translate="yes" xml:space="preserve">
          <source>If present, specifies the string delimiting start of a quoted string.</source>
          <target state="translated">있는 경우 인용 문자열의 문자열 구분 시작을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="53a1150c587a660e881fe7821fcb847d00c55297" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">있는 경우 속성과 값을 구분하는 문자열을 지정합니다 (예 : &quot;age = 65&quot;의 &quot;=&quot;).</target>
        </trans-unit>
        <trans-unit id="ac3c844cdeac2520127d85d40f83a50ed68f9c88" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute-value-assertions when specifying multiple attribute/value pairs. (e.g. &quot;,&quot; in age=65,gender=male).</source>
          <target state="translated">있는 경우 여러 속성 / 값 쌍을 지정할 때 속성-값-어설 션을 구분하는 문자열을 지정합니다. (예 : 연령 = 65, 성별 = 남성에서 &quot;,&quot;).</target>
        </trans-unit>
        <trans-unit id="839f44a4939d27c69ac39a75a7ee01b1f1bbc830" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separators attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">존재하는 경우 속성을 값과 구분하는 문자열을 지정합니다 (예 : &quot;age = 65&quot;의 &quot;=&quot;).</target>
        </trans-unit>
        <trans-unit id="4e033c3e596848d293e0852aa5e0284f4620f551" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling &lt;code&gt;Doc&lt;/code&gt;'s &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an &lt;code&gt;InputStream&lt;/code&gt; or &lt;code&gt;Reader&lt;/code&gt;, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that &lt;code&gt;Doc&lt;/code&gt; implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">&lt;code&gt;Doc&lt;/code&gt; 의 &lt;code&gt;getReaderForText()&lt;/code&gt; 또는 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 메서드 를 호출 하거나 인쇄 데이터 소스가 이미 &lt;code&gt;InputStream&lt;/code&gt; 또는 &lt;code&gt;Reader&lt;/code&gt; 이기 때문에 클라이언트에서 스트림으로 인쇄 데이터를 가져 오는 경우 인쇄 서비스는 항상 이러한 스트림을 닫아야합니다. 모든 작업 완료 조건에서 클라이언트. 다음과 같은주의 사항이 있습니다. 인쇄 데이터 자체가 스트림 인 경우 서비스는 항상이를 닫습니다. 인쇄 데이터가 스트림으로 요청 될 수있는 것이라면 서비스는 종료하기 전에 스트림을 얻은 경우에만 스트림을 닫습니다. 즉, 인쇄 서비스가 데이터를 스트림으로 요청할 수 있다고해서 데이터를 요청한다는 의미는 아닙니다. &lt;code&gt;Doc&lt;/code&gt; 서비스를 닫기 위해 서비스에 의존하는 구현자는 서비스의 요청에 대한 응답으로 만 이러한 스트림을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="a8b99e1ebf742f5bd861cd2fd56fba8c921820bf" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling Doc's &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an InputStream or Reader, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that Doc implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">클라이언트에서 스트림으로 인쇄 데이터를 얻는 경우 Doc의 &lt;code&gt;getReaderForText()&lt;/code&gt; 또는 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 를 호출하여인쇄 데이터 소스가 이미 InputStream 또는 Reader이기 때문에 인쇄 서비스는 모든 작업 완료 조건에서 클라이언트에 대해 항상 이러한 스트림을 닫아야합니다. 다음과 같은 경고가 있습니다. 인쇄 데이터 자체가 스트림 인 경우 서비스는 항상 데이터를 닫습니다. 인쇄 데이터가 스트림으로 요청 될 수있는 것이면 서비스는 스트림을 종료하기 전에 스트림을 얻은 경우에만 스트림을 닫습니다. 즉, 인쇄 서비스가 데이터를 스트림으로 요청할 수 있다고해서 데이터를 닫기 위해 서비스에 의존하는 Doc 구현자가 서비스의 요청에 대한 응답으로 만 해당 스트림을 작성해야 함을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="698e747d05614178dfac851043daa01f20a613ea" translate="yes" xml:space="preserve">
          <source>If readUnshared is called to deserialize a back-reference (the stream representation of an object which has been written previously to the stream), an ObjectStreamException will be thrown.</source>
          <target state="translated">역 참조를 직렬화 해제하기 위해 readUnshared를 호출하면 (이전에 스트림에 기록 된 객체의 스트림 표현) ObjectStreamException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4f57444325034269269b979e9040fba82af28a1" translate="yes" xml:space="preserve">
          <source>If readUnshared returns successfully, then any subsequent attempts to deserialize back-references to the stream handle deserialized by readUnshared will cause an ObjectStreamException to be thrown.</source>
          <target state="translated">readUnshared가 성공적으로 리턴되면, readUnshared에 의해 역 직렬화 된 스트림 핸들에 대한 역 참조를 역 직렬화하려고 시도하면 ObjectStreamException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa301e6f70a966a031213bd64c45f05d89ac7164" translate="yes" xml:space="preserve">
          <source>If resolution should be possible, but the data is invalid, the resolver style should be used to determine an appropriate level of leniency, which may require throwing a &lt;code&gt;DateTimeException&lt;/code&gt; or &lt;code&gt;ArithmeticException&lt;/code&gt;. If no resolution is possible, the resolve method must return null.</source>
          <target state="translated">확인이 가능하지만 데이터가 유효하지 않은 경우, 리졸버 스타일을 사용하여 적절한 수준의 신뢰도를 결정해야합니다 . &lt;code&gt;DateTimeException&lt;/code&gt; 또는 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생해야 할 수도 있습니다 . 해결 방법이 없으면 resolve 메서드는 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3812495ff2c8cc9bdfa1044d03962dc8bf6711c5" translate="yes" xml:space="preserve">
          <source>If running in a ForkJoinPool, the pool may first be expanded to ensure sufficient parallelism available during the call to &lt;code&gt;blocker.block()&lt;/code&gt;.</source>
          <target state="translated">ForkJoinPool에서 실행중인 경우 &lt;code&gt;blocker.block()&lt;/code&gt; 호출하는 동안 사용 가능한 병렬 처리를 보장하기 위해 풀을 먼저 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b345c507b8eb5308663521a467d3fdf7b2c7424" translate="yes" xml:space="preserve">
          <source>If screen devices are reconfigured such that the coordinate system is affected, the behavior of existing Robot objects is undefined.</source>
          <target state="translated">좌표계가 영향을 받도록 화면 장치를 재구성하면 기존 로봇 객체의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae78817156ff952aba10e581c466f3b983c1decc" translate="yes" xml:space="preserve">
          <source>If script or extensions are present and variant is missing, no underscore is added before the &quot;#&quot;.</source>
          <target state="translated">스크립트 또는 확장자가 존재하고 변형이 누락 된 경우 &quot;#&quot;앞에 밑줄이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bacc3b39afe6555d76b04639e544a3a769989526" translate="yes" xml:space="preserve">
          <source>If set on an &lt;a href=&quot;objectinputstream&quot;&gt;&lt;code&gt;ObjectInputStream&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt;&lt;code&gt;checkInput(FilterInfo)&lt;/code&gt;&lt;/a&gt; method is called to validate classes, the length of each array, the number of objects being read from the stream, the depth of the graph, and the total number of bytes read from the stream.</source>
          <target state="translated">온 설정 한 경우 &lt;a href=&quot;objectinputstream&quot;&gt; &lt;code&gt;ObjectInputStream&lt;/code&gt; &lt;/a&gt; 상기 &lt;a href=&quot;#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt; &lt;code&gt;checkInput(FilterInfo)&lt;/code&gt; &lt;/a&gt; 방법은 유효성 클래스를 호출하고, 각각의 어레이의 길이는, 오브젝트의 개수가 스트림으로부터 판독되며, 상기 그래프의 깊이와 총 바이트 스트림으로부터 판독 .</target>
        </trans-unit>
        <trans-unit id="d68a475ad0b21c04ea65cb73ab3824fc6e8e1d2f" translate="yes" xml:space="preserve">
          <source>If set to &lt;a href=&quot;httpclient.version#HTTP_2&quot;&gt;HTTP/2&lt;/a&gt;, then each request will attempt to upgrade to HTTP/2. If the upgrade succeeds, then the response to this request will use HTTP/2 and all subsequent requests and responses to the same &lt;a href=&quot;https://tools.ietf.org/html/rfc6454#section-4&quot;&gt;origin server&lt;/a&gt; will use HTTP/2. If the upgrade fails, then the response will be handled using HTTP/1.1</source>
          <target state="translated">&lt;a href=&quot;httpclient.version#HTTP_2&quot;&gt;HTTP / 2로&lt;/a&gt; 설정된 경우 각 요청은 HTTP / 2로 업그레이드를 시도합니다. 업그레이드가 성공하면이 요청에 대한 응답은 HTTP / 2를 사용하고 동일한 &lt;a href=&quot;https://tools.ietf.org/html/rfc6454#section-4&quot;&gt;원본 서버에&lt;/a&gt; 대한 모든 후속 요청 및 응답 은 HTTP / 2를 사용합니다. 업그레이드에 실패하면 HTTP / 1.1을 사용하여 응답이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a63684a8335dacd2334257d6490511210af93630" translate="yes" xml:space="preserve">
          <source>If set to true, assume that the input is certified (see section 2.13 in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;]) when parsing [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;].</source>
          <target state="translated">True로 설정이 입력이 인증되는 것을 가정하면 ([섹션 2.13를 참조 &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]) 구문 분석 할 때 &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="aca1859a49861db1474a56d8e3d2f23a51a9b08b" translate="yes" xml:space="preserve">
          <source>If set, the creation time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">설정된 경우, 생성 시간은 ZIP 파일 또는 ZIP 파일 형식의 스트림으로 출력 될 때 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 의 확장 된 타임 스탬프 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="254aa9b5d6babc55c52a29bf015e860182b09607" translate="yes" xml:space="preserve">
          <source>If set, the data will be written out in a top-down manner, the first scanline being written first.</source>
          <target state="translated">설정된 경우 데이터는 하향식으로 기록되며 첫 번째 스캔 라인이 먼저 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d3fe3fca46a00d556efb3e52ff334ccc25f6d2f2" translate="yes" xml:space="preserve">
          <source>If set, the last access time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">설정된 경우, 마지막 액세스 시간은 ZIP 파일 또는 ZIP 파일 형식의 스트림으로 출력 될 때 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 의 확장 된 타임 스탬프 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f308d30cc56ad52b3bab469509470a688175d5d" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamic call site, the JVM must choose one &lt;code&gt;CallSite&lt;/code&gt; object and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored, and their dynamic call site invocations proceed with the originally chosen target object.</source>
          <target state="translated">여러 스레드가 단일 동적 호출 사이트에 대해 부트 스트랩 메소드를 동시에 실행하는 경우 JVM은 하나의 &lt;code&gt;CallSite&lt;/code&gt; 오브젝트를 선택 하여 모든 스레드에 시각적으로 설치해야합니다. 다른 부트 스트랩 메소드 호출은 완료 할 수 있지만 결과는 무시되고 동적 호출 사이트 호출은 원래 선택된 대상 오브젝트로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="18b1b4b5ea1cd9ac6c8f6934c943af5a9030e95e" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamically-computed call site or constant, the JVM must choose one bootstrap method result and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored.</source>
          <target state="translated">여러 스레드가 동적으로 계산 된 단일 호출 사이트 또는 상수에 대해 부트 스트랩 메소드를 동시에 실행하는 경우 JVM은 하나의 부트 스트랩 메소드 결과를 선택하고 모든 스레드에 가시적으로 설치해야합니다. 다른 부트 스트랩 메서드 호출은 완료 할 수 있지만 그 결과는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="653e73bbef0b2a0664fc9c6111cdb7e33befdd39" translate="yes" xml:space="preserve">
          <source>If simply changing the name of the given node is not possible, the following operations are performed: a new node is created, any registered event listener is registered on the new node, any user data attached to the old node is removed from that node, the old node is removed from its parent if it has one, the children are moved to the new node, if the renamed node is an &lt;code&gt;Element&lt;/code&gt; its attributes are moved to the new node, the new node is inserted at the position the old node used to have in its parent's child nodes list if it has one, the user data that was attached to the old node is attached to the new node.</source>
          <target state="translated">단순히 주어진 노드의 이름을 변경할 수없는 경우 다음 작업이 수행됩니다. 새 노드가 생성되고 등록 된 이벤트 리스너가 새 노드에 등록되고 이전 노드에 연결된 모든 사용자 데이터가 해당 노드에서 제거됩니다. 이전 노드가있는 경우 상위 노드에서 제거되고, 하위 노드가 새 노드로 이동하고, 이름이 바뀐 노드가 &lt;code&gt;Element&lt;/code&gt; 이면 해당 속성이 새 노드로 이동되고, 새 노드가 이전 노드가 사용 된 위치에 삽입됩니다. 부모의 자식 노드 목록에 포함하려면 이전 노드에 연결된 사용자 데이터가 새 노드에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c65182d3cadba09ddb23fbbd8a75757afd7c8e" translate="yes" xml:space="preserve">
          <source>If size requirements are explicitly specified for the paragraph, use that requirements. Otherwise, use the requirements of the superclass &lt;a href=&quot;../paragraphview&quot;&gt;&lt;code&gt;ParagraphView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단락에 대해 크기 요구 사항이 명시 적으로 지정된 경우 해당 요구 사항을 사용합니다. 그렇지 않으면 수퍼 클래스 &lt;a href=&quot;../paragraphview&quot;&gt; &lt;code&gt;ParagraphView&lt;/code&gt; &lt;/a&gt; 의 요구 사항을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a30312a3ee2ee2f769f60fddc7aed8e6e676a91e" translate="yes" xml:space="preserve">
          <source>If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns as required.</source>
          <target state="translated">그렇다면 SQL AS 절을 사용하여 계산 된 열의 이름을 제공하거나 필요에 따라 열의 별칭 이름을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3080743f4d15c8fc1f75465fc6801e428e44fe7c" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of PropertyChangeListeners and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">명명 된 속성으로 일부 리스너가 추가 된 경우 반환되는 배열은 PropertyChangeListeners와 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 의 혼합입니다 . 호출 메소드가 리스너를 구별하는 데 관심이있는 경우 각 요소를 테스트하여 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 인지 확인 하고 캐스트를 수행 한 후 매개 변수를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cf497c1785865189fe796ed0e1d220915d011be" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of VetoableChangeListeners and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">명명 된 속성으로 일부 리스너가 추가 된 경우 반환 된 배열은 VetoableChangeListeners와 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 의 혼합입니다 . 호출 메소드가 리스너를 구별하는 데 관심이있는 경우 각 요소를 테스트하여 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 인지 확인 하고 캐스트를 수행하고 매개 변수를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc3c7dd73763675362089e6dbd76aa79687340e" translate="yes" xml:space="preserve">
          <source>If some of the clause functions are virtual methods on an instance, the instance itself can be conveniently placed in an initial invariant loop &quot;variable&quot;, using an initial clause like &lt;code&gt;new MethodHandle[]{identity(ObjType.class)}&lt;/code&gt;. In that case, the instance reference will be the first iteration variable value, and it will be easy to use virtual methods as clause parts, since all of them will take a leading instance reference matching that value.</source>
          <target state="translated">절 함수 중 일부가 인스턴스의 가상 메서드 인 경우 인스턴스 자체는 &lt;code&gt;new MethodHandle[]{identity(ObjType.class)}&lt;/code&gt; 와 같은 초기 절을 사용하여 초기 고정 루프 &quot;변수&quot;에 편리하게 배치 할 수 있습니다 . 이 경우 인스턴스 참조는 첫 번째 반복 변수 값이되며 가상 메서드는 모두 해당 값과 일치하는 선행 인스턴스 참조를 사용하므로 절 부분으로 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4809b1b1dafea4dfced97329f0d27180c7e418e7" translate="yes" xml:space="preserve">
          <source>If some other window is already always-on-top then the relative order between these windows is unspecified (depends on platform). No window can be brought to be over the always-on-top window except maybe another always-on-top window.</source>
          <target state="translated">다른 창이 이미 항상 맨 위에있는 경우이 창 사이의 상대적 순서는 지정되지 않습니다 (플랫폼에 따라 다름). 다른 항상 위에있는 창을 제외하고는 항상 위에있는 창 위에 창을 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c852ab67f6ae0af547293dc6511f0705244b787" translate="yes" xml:space="preserve">
          <source>If specified, these insets act as padding around the cell renderer when laying out and painting the &quot;selected&quot; item in the combo box.</source>
          <target state="translated">지정된 경우 이러한 인세 트는 콤보 상자에서 &quot;선택된&quot;항목을 레이아웃하고 칠할 때 셀 렌더러 주위의 패딩 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5a8e20a8b6edf9f99ddfa05066dd30cd8c55b9b1" translate="yes" xml:space="preserve">
          <source>If specified, these insets act as padding around the cell renderer when laying out and painting the &quot;selected&quot; item in the combo box. These insets add to those specified by the cell renderer.</source>
          <target state="translated">지정된 경우 이러한 인세 트는 콤보 상자에서 &quot;선택된&quot;항목을 레이아웃하고 칠할 때 셀 렌더러 주위의 패딩 역할을합니다. 이러한 삽입은 셀 렌더러에서 지정한 삽입에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a5c010eef59c15644a375468c16c24a59e5c43de" translate="yes" xml:space="preserve">
          <source>If starting any of the processes throws an Exception, all processes are forcibly destroyed.</source>
          <target state="translated">프로세스를 시작할 때 예외가 발생하면 모든 프로세스가 강제로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ee377394ee6fe11a94b05880ae8a4e56e23eb11b" translate="yes" xml:space="preserve">
          <source>If state is &lt;a href=&quot;cardterminals.state#ALL&quot;&gt;&lt;code&gt;State.ALL&lt;/code&gt;&lt;/a&gt;, this method returns all CardTerminals encapsulated by this object. If state is &lt;a href=&quot;cardterminals.state#CARD_PRESENT&quot;&gt;&lt;code&gt;State.CARD_PRESENT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cardterminals.state#CARD_ABSENT&quot;&gt;&lt;code&gt;State.CARD_ABSENT&lt;/code&gt;&lt;/a&gt;, it returns all CardTerminals where a card is currently present or absent, respectively.</source>
          <target state="translated">state가 &lt;a href=&quot;cardterminals.state#ALL&quot;&gt; &lt;code&gt;State.ALL&lt;/code&gt; &lt;/a&gt; 이면이 메서드는이 개체에 의해 캡슐화 된 모든 CardTerminals를 반환합니다. state가 &lt;a href=&quot;cardterminals.state#CARD_PRESENT&quot;&gt; &lt;code&gt;State.CARD_PRESENT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cardterminals.state#CARD_ABSENT&quot;&gt; &lt;code&gt;State.CARD_ABSENT&lt;/code&gt; &lt;/a&gt; 이면 카드가 현재 존재하거나 존재하지 않는 모든 CardTerminals를 각각 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97e2c677edafae44cb499869bec55d8b0b28cb2c" translate="yes" xml:space="preserve">
          <source>If state is &lt;a href=&quot;cardterminals.state#CARD_INSERTION&quot;&gt;&lt;code&gt;State.CARD_INSERTION&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cardterminals.state#CARD_REMOVAL&quot;&gt;&lt;code&gt;State.CARD_REMOVAL&lt;/code&gt;&lt;/a&gt;, it returns all CardTerminals for which an insertion (or removal, respectively) was detected during the last call to &lt;a href=&quot;#waitForChange()&quot;&gt;waitForChange()&lt;/a&gt;. If &lt;code&gt;waitForChange()&lt;/code&gt; has not been called on this object, &lt;code&gt;CARD_INSERTION&lt;/code&gt; is equivalent to &lt;code&gt;CARD_PRESENT&lt;/code&gt; and &lt;code&gt;CARD_REMOVAL&lt;/code&gt; is equivalent to &lt;code&gt;CARD_ABSENT&lt;/code&gt;. For an example of the use of &lt;code&gt;CARD_INSERTION&lt;/code&gt;, see &lt;a href=&quot;#waitForChange()&quot;&gt;&lt;code&gt;waitForChange()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">state가 &lt;a href=&quot;cardterminals.state#CARD_INSERTION&quot;&gt; &lt;code&gt;State.CARD_INSERTION&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cardterminals.state#CARD_REMOVAL&quot;&gt; &lt;code&gt;State.CARD_REMOVAL&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#waitForChange()&quot;&gt;waitForChange ()에&lt;/a&gt; 대한 마지막 호출 중에 삽입 (또는 제거)이 감지 된 모든 CardTerminals를 반환합니다 . 경우 &lt;code&gt;waitForChange()&lt;/code&gt; 이 객체에 호출되지, &lt;code&gt;CARD_INSERTION&lt;/code&gt; 은 동일합니다 &lt;code&gt;CARD_PRESENT&lt;/code&gt; 및 &lt;code&gt;CARD_REMOVAL&lt;/code&gt; 은 동일합니다 &lt;code&gt;CARD_ABSENT&lt;/code&gt; . &lt;code&gt;CARD_INSERTION&lt;/code&gt; 사용의 예는 &lt;a href=&quot;#waitForChange()&quot;&gt; &lt;code&gt;waitForChange()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36119d6ef751d0ba1a40bc06d8c08c0232acb626" translate="yes" xml:space="preserve">
          <source>If still no result bundle is found, the base name alone is looked up. If this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.</source>
          <target state="translated">여전히 결과 번들이 없으면 기본 이름 만 찾습니다. 여전히 실패하면 &lt;code&gt;MissingResourceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49c2d956b15c160db2755278d76b95411d1638e9" translate="yes" xml:space="preserve">
          <source>If such a service has been registered with the context, or one of its nesting context's, in the case where a context delegate to its context to satisfy a service request, then the BeanContextServiceProvider associated with the service is asked to provide an instance of that service.</source>
          <target state="translated">이러한 서비스가 컨텍스트 또는 중첩 컨텍스트 중 하나에 등록 된 경우 컨텍스트가 컨텍스트에 위임되어 서비스 요청을 충족시키는 경우 서비스와 연관된 BeanContextServiceProvider는 해당 서비스의 인스턴스를 제공하도록 요청됩니다. .</target>
        </trans-unit>
        <trans-unit id="94b0570a3ef5bacc1df2844b6f6f55155f5164cd" translate="yes" xml:space="preserve">
          <source>If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by any bytes that otherwise would have been the next input data as of the time of the call to &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;code&gt;IOException&lt;/code&gt; 이 발생하지 않으면, 스트림은 가장 최근의 &lt;code&gt;mark&lt;/code&gt; 호출 이후 (또는 &lt;code&gt;mark&lt;/code&gt; 가 호출되지 않은 경우 파일의 시작 이후) 읽은 모든 바이트 가 후속으로 재 공급되도록 상태로 재설정됩니다. &lt;code&gt;read&lt;/code&gt; 메소드의 호출자 다음에, &lt;code&gt;reset&lt;/code&gt; 호출의 시점에서 다음의 입력 데이터가 된 바이트가 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba67a915702ddd93a2439399e9e5620bf22a0c62" translate="yes" xml:space="preserve">
          <source>If such an error is thrown then subsequent invocations of the iterator will make a best effort to locate and instantiate the next available provider, but in general such recovery cannot be guaranteed.</source>
          <target state="translated">이러한 오류가 발생하면 이후 반복자를 호출하면 사용 가능한 다음 제공자를 찾고 인스턴스화하기 위해 최선을 다하지만 일반적으로 이러한 복구를 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ca56d49fb83daa43c8cab6e57a0bc195c1fa094" translate="yes" xml:space="preserve">
          <source>If support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use only the following standard button masks: &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt;.</source>
          <target state="translated">확장 마우스 버튼에 대한 지원 이 Java에 의해 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; 된 경우 다음 표준 버튼 마스크 만 사용할 수 있습니다 : &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d39904b337a524b3be8e74dcbdcdc3b283655905" translate="yes" xml:space="preserve">
          <source>If support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use the standard button masks and masks for existing extended mouse buttons, if the mouse has more then three buttons. In that way, it is allowed to use the button masks corresponding to the buttons in the range from 1 to &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장 마우스 버튼에 대한 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에 의해 활성화 된 경우 마우스에 버튼이 세 개 이상있는 경우 기존 확장 마우스 버튼에 대한 표준 버튼 마스크 및 마스크를 사용할 수 있습니다. 이렇게하면 1부터 &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt; 까지의 범위에서 버튼에 해당하는 버튼 마스크를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="486f3c00239a42cba8b1916fb667e0081bff0684" translate="yes" xml:space="preserve">
          <source>If support for the extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to create &lt;code&gt;MouseEvent&lt;/code&gt; objects only with the standard buttons: &lt;code&gt;NOBUTTON&lt;/code&gt;, &lt;code&gt;BUTTON1&lt;/code&gt;, &lt;code&gt;BUTTON2&lt;/code&gt;, and &lt;code&gt;BUTTON3&lt;/code&gt;.</source>
          <target state="translated">확장 된 마우스 버튼에 대한 지원 이 Java에 의해 &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; 된 경우 표준 버튼 인 &lt;code&gt;NOBUTTON&lt;/code&gt; , &lt;code&gt;BUTTON1&lt;/code&gt; , &lt;code&gt;BUTTON2&lt;/code&gt; 및 &lt;code&gt;BUTTON3&lt;/code&gt; 으로 만 &lt;code&gt;MouseEvent&lt;/code&gt; 객체 를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65884caffeef70616af6ac015fb22950976842d5" translate="yes" xml:space="preserve">
          <source>If support for the extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to create &lt;code&gt;MouseEvent&lt;/code&gt; objects with the standard buttons. In case the support for extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java, then in addition to the standard buttons, &lt;code&gt;MouseEvent&lt;/code&gt; objects can be created using buttons from the range starting from 4 to &lt;a href=&quot;../mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt; if the mouse has more than three buttons.</source>
          <target state="translated">확장 마우스 버튼에 대한 &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에서 활성화 된 경우 표준 버튼으로 &lt;code&gt;MouseEvent&lt;/code&gt; 객체 를 생성 할 수 있습니다 . 확장 된 마우스 버튼에 대한 &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에 의해 활성화 된 경우 표준 버튼 외에도 마우스에 3 개 이상의 버튼이있는 경우 4부터 &lt;a href=&quot;../mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt; 까지 범위의 버튼을 사용하여 &lt;code&gt;MouseEvent&lt;/code&gt; 객체를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d3c9f547885ed5dc664bee523aaf2e97a59a19a" translate="yes" xml:space="preserve">
          <source>If supported by the underlying SSL/TLS/DTLS implementation, application name negotiation mechanisms such as &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application-Layer Protocol Negotiation (ALPN), can negotiate application-level values between peers.</source>
          <target state="translated">기본 SSL / TLS / DTLS 구현에서 지원하는 경우 &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt; , ALPN (Application-Layer Protocol Negotiation) 과 같은 애플리케이션 이름 협상 메커니즘 은 피어간에 애플리케이션 수준 값을 협상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="483297556e0d86a729fc879bc3d6a3a654a16eca" translate="yes" xml:space="preserve">
          <source>If system exclusive data from &lt;code&gt;SysexMessages&lt;/code&gt; objects is being transmitted using MIDI wire protocol, only the initial 0xF0 status byte, the system exclusive data itself, and the final 0xF7 (EOX) byte should be propagated; any 0xF7 status bytes used to indicate that a &lt;code&gt;SysexMessage&lt;/code&gt; contains continuing system exclusive data should not be propagated via MIDI wire protocol.</source>
          <target state="translated">&lt;code&gt;SysexMessages&lt;/code&gt; 객체의 시스템 독점 데이터가 MIDI 유선 프로토콜을 사용하여 전송되는 경우 초기 0xF0 상태 바이트, 시스템 독점 데이터 자체 및 최종 0xF7 (EOX) 바이트 만 전파되어야합니다. &lt;code&gt;SysexMessage&lt;/code&gt; 에 지속적인 시스템 독점 데이터가 포함되어 있음을 나타내는 데 사용되는 0xF7 상태 바이트는 MIDI 와이어 프로토콜을 통해 전파되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8a60148766d9542dcdda7613f880094d44b2ef2c" translate="yes" xml:space="preserve">
          <source>If system properties &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; and &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; are defined or they are defined in the file &quot;sound.properties&quot;, they are used to retrieve default lines. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If the respective property is not set, or the mixer requested in the property is not installed or does not provide the requested line, all installed mixers are queried for the requested line type. A Line will be returned from the first mixer providing the requested line type.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; , &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt; , &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 및 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 이 정의되거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 줄을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 해당 속성이 설정되지 않았거나 속성에서 요청 된 믹서가 설치되지 않았거나 요청 된 라인을 제공하지 않으면 설치된 모든 믹서가 요청 된 라인 유형에 대해 쿼리됩니다. 요청 된 라인 유형을 제공하는 첫 번째 믹서에서 라인이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a8e3d47700ce7e07788d64cbfa2cd41b86d9c136" translate="yes" xml:space="preserve">
          <source>If target is _self, the action is to change the value of the &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute and fires a &lt;code&gt;ChangedUpdate&lt;/code&gt; event.</source>
          <target state="translated">target이 _self 인 경우 작업은 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 속성 의 값을 변경하고 &lt;code&gt;ChangedUpdate&lt;/code&gt; 이벤트를 발생시키는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="1f583398dc1f86dc2870e17e17525bfe7bcb7fe2" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">&quot;java.util.logging.config.class&quot;특성이 설정되면 특성 값이 클래스 이름으로 처리됩니다. 지정된 클래스가로드되고 객체가 인스턴스화되며 해당 객체의 생성자가 초기 구성을 읽습니다. 이 객체는 다른 시스템 속성을 사용하여 구성을 제어 할 수 있습니다. 대체 구성 클래스는 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 을 사용하여 LogManager에서 속성을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c21737341f78d589edcf2b473c1e9d4710529e7" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; system property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">&quot;java.util.logging.config.class&quot;시스템 속성이 설정된 경우 속성 값은 클래스 이름으로 처리됩니다. 지정된 클래스가로드되고 객체가 인스턴스화되며 해당 객체의 생성자가 초기 구성에서 읽기를 담당합니다. (이 객체는 다른 시스템 속성을 사용하여 구성을 제어 할 수 있습니다.) 대체 구성 클래스는 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 을 사용하여 LogManager에서 속성을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee9a28b9f37694fc322c18e7908dd9236e4f1f5e" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.file&quot; system property is set, then the property value specifies the properties file to be read as the new configuration. Otherwise, the LogManager default configuration is used.</source>
          <target state="translated">&quot;java.util.logging.config.file&quot;시스템 특성이 설정된 경우 특성 값은 새 구성으로 읽을 특성 파일을 지정합니다. 그렇지 않으면 LogManager 기본 구성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3e35bcf72871950c117a29249ba322eaf7916a" translate="yes" xml:space="preserve">
          <source>If the 'getMethod' field contains the name of a valid operation descriptor, then the method described by the operation descriptor is executed. The response from the method is returned as the value of the attribute. If the operation fails or the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">'getMethod'필드에 유효한 작업 설명 자의 이름이 포함되어 있으면 작업 설명자가 설명하는 방법이 실행됩니다. 메소드의 응답은 속성 값으로 리턴됩니다. 작업이 실패하거나 반환 된 값이 선언 된 속성 유형과 호환되지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e0d548ba22d2542cb9fd6382914ac5396917edaa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#%3Cinit%3E(java.security.SecureRandomParameters)&quot;&gt;&lt;code&gt;SecureRandomSpi(SecureRandomParameters)&lt;/code&gt;&lt;/a&gt; constructor is overridden in an implementation, it will always be called whenever a &lt;code&gt;SecureRandom&lt;/code&gt; is instantiated. Precisely, if an object is instantiated with one of &lt;code&gt;SecureRandom&lt;/code&gt;'s &lt;code&gt;getInstance&lt;/code&gt; methods &lt;em&gt;without&lt;/em&gt; a &lt;a href=&quot;securerandomparameters&quot;&gt;&lt;code&gt;SecureRandomParameters&lt;/code&gt;&lt;/a&gt; parameter, the constructor will be called with a &lt;code&gt;null&lt;/code&gt; argument and the implementation is responsible for creating its own &lt;code&gt;SecureRandomParameters&lt;/code&gt; parameter for use when &lt;a href=&quot;#engineGetParameters()&quot;&gt;&lt;code&gt;engineGetParameters()&lt;/code&gt;&lt;/a&gt; is called. If an object is instantiated with one of &lt;code&gt;SecureRandom&lt;/code&gt;'s &lt;code&gt;getInstance&lt;/code&gt; methods &lt;em&gt;with&lt;/em&gt; a &lt;code&gt;SecureRandomParameters&lt;/code&gt; argument, the constructor will be called with that argument. The &lt;a href=&quot;#engineGetParameters()&quot;&gt;&lt;code&gt;engineGetParameters()&lt;/code&gt;&lt;/a&gt; method must not return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;#%3Cinit%3E(java.security.SecureRandomParameters)&quot;&gt; &lt;code&gt;SecureRandomSpi(SecureRandomParameters)&lt;/code&gt; &lt;/a&gt; 생성자 구현에서 재정의되는 때마다 항상 호출됩니다 &lt;code&gt;SecureRandom&lt;/code&gt; 의이 인스턴스화됩니다. 객체가 하나 인스턴스화하면 정확하게, &lt;code&gt;SecureRandom&lt;/code&gt; 의 의 &lt;code&gt;getInstance&lt;/code&gt; 방법 &lt;em&gt;이없는 &lt;/em&gt;&lt;a href=&quot;securerandomparameters&quot;&gt; &lt;code&gt;SecureRandomParameters&lt;/code&gt; 의&lt;/a&gt; 매개 변수, 생성자가 호출됩니다 &lt;code&gt;null&lt;/code&gt; 인수 및 구현은 자신의 창조에 대한 책임 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 을 할 때 사용하는 매개 변수 &lt;a href=&quot;#engineGetParameters()&quot;&gt; &lt;code&gt;engineGetParameters()&lt;/code&gt; &lt;/a&gt; 호출된다. 대상은 중 하나를 인스턴스화하는 경우 &lt;code&gt;SecureRandom&lt;/code&gt; 의 의 &lt;code&gt;getInstance&lt;/code&gt; 메소드&lt;em&gt;와 &lt;/em&gt; &lt;code&gt;SecureRandomParameters&lt;/code&gt; 의 인수 생성자는 해당 인수로 호출됩니다. &lt;a href=&quot;#engineGetParameters()&quot;&gt; &lt;code&gt;engineGetParameters()&lt;/code&gt; &lt;/a&gt; 메서드는 반환하지 않아야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd0e8651509209ab66f4363379a0875ab48d6ad" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#FOREGROUND&quot;&gt;&lt;code&gt;FOREGROUND&lt;/code&gt;&lt;/a&gt; attribute is set, its &lt;code&gt;Paint&lt;/code&gt; will be used as the background, otherwise the &lt;code&gt;Paint&lt;/code&gt; currently on the &lt;code&gt;Graphics&lt;/code&gt; will be used. If the &lt;a href=&quot;#BACKGROUND&quot;&gt;&lt;code&gt;BACKGROUND&lt;/code&gt;&lt;/a&gt; attribute is set, its &lt;code&gt;Paint&lt;/code&gt; will be used as the foreground, otherwise the system will find a contrasting color to the (resolved) background so that the text will be visible.</source>
          <target state="translated">&lt;a href=&quot;#FOREGROUND&quot;&gt; &lt;code&gt;FOREGROUND&lt;/code&gt; &lt;/a&gt; 속성이 설정되어 있으면 해당 &lt;code&gt;Paint&lt;/code&gt; 가 배경으로 사용되고 그렇지 않으면 현재 &lt;code&gt;Graphics&lt;/code&gt; 에있는 &lt;code&gt;Paint&lt;/code&gt; 가 사용됩니다. &lt;a href=&quot;#BACKGROUND&quot;&gt; &lt;code&gt;BACKGROUND&lt;/code&gt; &lt;/a&gt; 속성이 설정되어 있으면 해당 &lt;code&gt;Paint&lt;/code&gt; 가 전경으로 사용됩니다. 그렇지 않으면 시스템이 (해결 된) 배경과 대조되는 색상을 찾아 텍스트가 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="86337241a9668cc6a25c97b5de65d911d14a1894" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#redirectErrorStream()&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">는 IF &lt;a href=&quot;#redirectErrorStream()&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; 의&lt;/a&gt; 속성이 설정되어있는 &lt;code&gt;true&lt;/code&gt; ,이 방법으로 재 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b85fc122285cb0d2f89cc05f312ee0e46a0a070d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;setInput(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method was called to provide a buffer for input, the input buffer's position will be advanced by the number of bytes consumed by this operation, even in the event that a &lt;a href=&quot;dataformatexception&quot;&gt;&lt;code&gt;DataFormatException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우] &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;setInput(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 방법은 입력 버퍼를 제공하기 위해 호출 된, 입력 버퍼의 위치에도있는 경우에는,이 조작에 의해 소비 된 바이트의 수에 의해 전진 될 것이다 &lt;a href=&quot;dataformatexception&quot;&gt; &lt;code&gt;DataFormatException&lt;/code&gt; 가&lt;/a&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="beaa63bfc2c275017816960a621f79d777650f26" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;setInput(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method was called to provide a buffer for input, the input buffer's position will be advanced by the number of bytes consumed by this operation.</source>
          <target state="translated">경우] &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;setInput(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 방법은 입력 버퍼를 제공하기 위해 호출 된, 입력 버퍼의 위치는이 동작에 의해 소비 된 바이트의 수에 의해 전진 될 것이다.</target>
        </trans-unit>
        <trans-unit id="89d95c390fbfbed6f9512b14bde317e19394155e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt;&lt;code&gt;staticPermissionsOnly()&lt;/code&gt;&lt;/a&gt; method returns true, then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">는 IF &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt; &lt;code&gt;staticPermissionsOnly()&lt;/code&gt; &lt;/a&gt; 메소드가 true를 돌려, 그 권한은, 구축시에 제공된 PermissionCollection에 대해서 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3202df3f64a60f68be2f6e8445b0bee61ca858" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../java.base/java/util/properties&quot;&gt;&lt;code&gt;Properties&lt;/code&gt;&lt;/a&gt; file &lt;code&gt;swing.properties&lt;/code&gt; exists and contains the key &lt;code&gt;swing.defaultlaf&lt;/code&gt;, use its value as the default look and feel class name. The location that is checked for &lt;code&gt;swing.properties&lt;/code&gt; may vary depending upon the implementation of the Java platform. Typically the &lt;code&gt;swing.properties&lt;/code&gt; file is located in the &lt;code&gt;conf&lt;/code&gt; subdirectory of the Java installation directory. Refer to the release notes of the implementation being used for further details.</source>
          <target state="translated">경우 &lt;a href=&quot;../../../java.base/java/util/properties&quot;&gt; &lt;code&gt;Properties&lt;/code&gt; &lt;/a&gt; 파일의 &lt;code&gt;swing.properties&lt;/code&gt; 가 존재하고 키 포함 &lt;code&gt;swing.defaultlaf&lt;/code&gt; 가를 기본 모양과 느낌 클래스 이름으로 그 값을 사용합니다. &lt;code&gt;swing.properties&lt;/code&gt; 를 확인하는 위치 는 Java 플랫폼의 구현에 따라 다를 수 있습니다. 일반적으로 &lt;code&gt;swing.properties&lt;/code&gt; 파일은 Java 설치 디렉토리 의 &lt;code&gt;conf&lt;/code&gt; 하위 디렉토리에 있습니다. 자세한 내용은 사용중인 구현의 릴리스 정보를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0cf976d251facbb1b28639a31b11358b94746e84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;beaninfo&quot;&gt;&lt;code&gt;BeanInfo&lt;/code&gt;&lt;/a&gt; for this type has a &lt;a href=&quot;beandescriptor&quot;&gt;&lt;code&gt;BeanDescriptor&lt;/code&gt;&lt;/a&gt; which defined a &quot;persistenceDelegate&quot; attribute, the value of this named attribute is returned.</source>
          <target state="translated">이 유형 의 &lt;a href=&quot;beaninfo&quot;&gt; &lt;code&gt;BeanInfo&lt;/code&gt; &lt;/a&gt; 에 &quot;persistenceDelegate&quot;속성을 정의한 &lt;a href=&quot;beandescriptor&quot;&gt; &lt;code&gt;BeanDescriptor&lt;/code&gt; &lt;/a&gt; 가 있으면 이 이름 지정된 속성의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f7796e655e99564bb42833b6c22ae781567c8b7e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">는 IF &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; 의&lt;/a&gt; 속성이 설정되어있는 &lt;code&gt;true&lt;/code&gt; ,이 방법으로 재 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6369ec721b8ca4ab5fda1157ad5cc4775754c615" translate="yes" xml:space="preserve">
          <source>If the &lt;a id=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">IF로 &lt;a id=&quot;floatDPrec&quot;&gt;변환&lt;/a&gt; 인 &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'E'&lt;/code&gt; 또는 &lt;code&gt;'f'&lt;/code&gt; , 그 정밀도의 소수점 이하의 자리수이다. 정밀도가 지정되지 않은 경우 &lt;code&gt;6&lt;/code&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="69cea4d19b20fb91d97db82c5ca57aaf842e28d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a name=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">IF로 &lt;a name=&quot;floatDPrec&quot;&gt;변환&lt;/a&gt; 인 &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'E'&lt;/code&gt; 또는 &lt;code&gt;'f'&lt;/code&gt; , 그 정밀도의 소수점 이하의 자리수이다. 정밀도가 지정되지 않으면 &lt;code&gt;6&lt;/code&gt; 으로 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5059e8ee90e4d07843498ec51dc8abef786de5aa" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[member type definition anonymous]&lt;/b&gt; exists:</source>
          <target state="translated">경우] &lt;b&gt;[회원 유형 정의 익명]&lt;/b&gt; 존재한다 :</target>
        </trans-unit>
        <trans-unit id="b3bdad546a4d7a971b883151ac70a2ccbe1f0095" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[type definition anonymous]&lt;/b&gt; exists:</source>
          <target state="translated">경우] &lt;b&gt;[유형 정의 익명]&lt;/b&gt; 존재한다 :</target>
        </trans-unit>
        <trans-unit id="224235c33cd803b74bad7dc5b6641bf25c3410c2" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[type definition]&lt;/b&gt; property exists:</source>
          <target state="translated">경우] &lt;b&gt;[유형 정의]&lt;/b&gt; 속성이 존재 :</target>
        </trans-unit>
        <trans-unit id="ea735b3ad144dc0d3c88616e2055c7a3baba85a5" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[validity]&lt;/b&gt; property exists AND is &lt;em&gt;&quot;invalid&quot;&lt;/em&gt; or &lt;em&gt;&quot;notKnown&quot;&lt;/em&gt;: the {target namespace} and {name} properties of the declared type if available, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;b&gt;[유효 기간]&lt;/b&gt; 속성이 존재하고있다 &lt;em&gt;&quot;무효&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;notKnown&quot;&lt;/em&gt; 다음 {대상 네임 스페이스} 및 가능한 경우 선언 된 형태의 {이름} 속성, 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5654c5178b9647add1bfe15b4562bdf804149ac" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[validity]&lt;/b&gt; property exists and is &lt;em&gt;&quot;valid&quot;&lt;/em&gt;:</source>
          <target state="translated">는 IF &lt;b&gt;[유효 기간]&lt;/b&gt; 속성이 존재하고있다 &lt;em&gt;&quot;유효&quot;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="244d88b2fe1f7cc3d006bcc6bed47c61fe2ec794" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;zh&quot;&lt;/code&gt;-to-&lt;code&gt;&quot;zh&quot;&lt;/code&gt; mapping isn't included in the map, a simple replacement will be performed and the customized list won't include &lt;code&gt;&quot;zh&quot;&lt;/code&gt; and &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&quot;zh&quot;&lt;/code&gt; Di의 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 매핑이 맵에 포함되지 않은 단순 교체가 수행되고 사용자 정의 목록은 포함되지 않습니다 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f4d1d76d4c61640485815093054acc02ce819f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="1c680cd1a5cd595f752bed838baa38292f42bbcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given and the argument is not a &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt; , then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하고 인수가되지이다 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 가&lt;/a&gt; , 다음 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3ca6b4a24528a74561304ff78b46e45f7ce091" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="95f5e2ee606537dc80cd0c08600e71779319b292" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="705393d5e4190c15bb4ded3f92e669b7967af3af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with &lt;code&gt;'0'&lt;/code&gt; prefix.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 출력은 항상 시작됩니다 &lt;code&gt;'0'&lt;/code&gt; 접두사.</target>
        </trans-unit>
        <trans-unit id="d94fd5d1c396bfff4fed3e4917313944fa0d8ce4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;&quot;0x&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되었을 경우, 출력은 항상 기수 지시자로 시작됩니다 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af351499ffe1eb584449ad1db1312af2f6169806" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;'0'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되었을 경우, 출력은 항상 기수 지시자로 시작됩니다 &lt;code&gt;'0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e2b33eac4b29de7dc276798ef6bb121e0f191c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 다음 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="193a49527f28f69b767038d67c1984e036b12529" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then the decimal separator will always be present.</source>
          <target state="translated">경우] &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 소수점이 항상 존재할 것이다.</target>
        </trans-unit>
        <trans-unit id="170d2f39d6b7a451069152ef956aa45571ac5f4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'('&lt;/code&gt; or &lt;code&gt;','&lt;/code&gt; flags are given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;'('&lt;/code&gt; 또는 &lt;code&gt;','&lt;/code&gt; 플래그가 지정되고있는 경우, &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="25f8f50b77134591d75e17a674bec028e9c6e997" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'+'&lt;/code&gt; flag is given and the value is positive or zero (or floating-point positive zero), then a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;) will be prepended.</source>
          <target state="translated">경우] &lt;code&gt;'+'&lt;/code&gt; 플래그가 지정하고, 값이 양수 또는 제로 (또는 부동 소수점 긍정적 영) 다음, &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;'\u002b'&lt;/code&gt; ) 붙을.</target>
        </trans-unit>
        <trans-unit id="dd8701b10b903c76286404a520374517bcb6cb05" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a id=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize()&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;','&lt;/code&gt; ( &lt;code&gt;'\u002c'&lt;/code&gt; ) &lt;a id=&quot;L10nGroup&quot;&gt;플래그는&lt;/a&gt; , 그 로케일 특정 주어진다 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;세퍼레이터 그룹화&lt;/a&gt; 로케일에 의해 정의 된 간격으로 세퍼레이터를 적어도 상당한 최상위 자릿수의 문자열의 정수 부분을 스캐닝하고 삽입하여 삽입 &lt;a href=&quot;../text/decimalformat#getGroupingSize()&quot;&gt;그룹핑 크기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="910241aebecc3c9182f2e0462c8f58f123333d6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a name=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;','&lt;/code&gt; ( &lt;code&gt;'\u002c'&lt;/code&gt; ) &lt;a name=&quot;L10nGroup&quot;&gt;플래그는&lt;/a&gt; , 그 로케일 특정 주어진다 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;세퍼레이터 그룹화&lt;/a&gt; 로케일에 의해 정의 된 간격으로 세퍼레이터를 적어도 상당한 최상위 자릿수의 문자열의 정수 부분을 스캐닝하고 삽입하여 삽입 &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;그룹핑 크기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44a9f549cf29b75acc2fdec3fc183e7f16568846" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;','&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="45726f7fab2e09c7f3869df2e50226749801e01e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given, then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;','&lt;/code&gt; 플래그가 지정되고있는 경우, &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="970c69f921423c9cb9e926402bc01ce17c9690e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'-'&lt;/code&gt; flag is not given, then the space padding will occur before the sign.</source>
          <target state="translated">경우 &lt;code&gt;'-'&lt;/code&gt; 플래그가 지정되어 있지 않은 경우, 공간 패딩은 기호 앞에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4999add0ec4ab7e8f065de52e1702ab41f20c0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given and the value is negative, then the zero padding will occur after the sign.</source>
          <target state="translated">경우 &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되어 값이 부의되어, 다음 제로 패딩은 기호 다음에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c36904575776fe73769eda50759d8e13da3acc3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 부여되는 출력 기수 지시자 또는 기호 (존재하는 경우) 이후의 선두에 제로 필드 폭으로 패딩한다.</target>
        </trans-unit>
        <trans-unit id="b5e7f4a54ddb769b1293d2814dfdf865f8198b97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded with leading zeros to the field width following any indication of sign.</source>
          <target state="translated">경우 &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되는 출력 기호의 표시를 다음과 폭 필드에 0을 선도하는 패딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f0743f520ad52ab8654c0fd8007d4814742634" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit()&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되고, 그 로케일 특정 &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit()&quot;&gt;제로 숫자&lt;/a&gt; 기호 문자 뒤에 삽입되어있는 경우와되어 제 비제 자리 전에, 문자열의 길이가 요구 된 필드 폭과 동일 할 때까지.</target>
        </trans-unit>
        <trans-unit id="ba1bcf00b5c45bf451134d21adaed5e63f1fcd56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되고, 그 로케일 특정 &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;제로 숫자&lt;/a&gt; 기호 문자 뒤에 삽입되어있는 경우와되어 제 비제 자리 전에, 문자열의 길이가 요구 된 필드 폭과 동일 할 때까지.</target>
        </trans-unit>
        <trans-unit id="e6f16828d0308872e7e04a7c1ddeb45e9f4f1750" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt; point lies outside the grid, the following rules are used. The column index is returned as zero if &lt;code&gt;x&lt;/code&gt; lies to the left of the layout for a left-to-right container or to the right of the layout for a right-to-left container. The column index is returned as the number of columns if &lt;code&gt;x&lt;/code&gt; lies to the right of the layout in a left-to-right container or to the left in a right-to-left container. The row index is returned as zero if &lt;code&gt;y&lt;/code&gt; lies above the layout, and as the number of rows if &lt;code&gt;y&lt;/code&gt; lies below the layout. The orientation of a container is determined by its &lt;code&gt;ComponentOrientation&lt;/code&gt; property.</source>
          <target state="translated">경우] &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt; 격자 점 밖에 놓여은 다음의 규칙이 사용된다. &lt;code&gt;x&lt;/code&gt; 가 왼쪽에서 오른쪽 컨테이너의 경우 레이아웃의 왼쪽에 있거나 오른쪽에서 왼쪽 컨테이너의 경우 레이아웃의 오른쪽에있는 경우 열 인덱스는 0으로 반환됩니다 . &lt;code&gt;x&lt;/code&gt; 가 왼쪽에서 오른쪽 컨테이너의 레이아웃 오른쪽에 있거나 오른쪽에서 왼쪽 컨테이너의 왼쪽에있는 경우 열 인덱스는 열 수로 반환됩니다 . &lt;code&gt;y&lt;/code&gt; 가 레이아웃 위에 있으면 행 인덱스는 0으로 반환되고 , &lt;code&gt;y&lt;/code&gt; 가 레이아웃 아래에 있으면 행 수로 반환됩니다 . 컨테이너의 방향은 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ecc4eb34ec8dfb382771373ad86df4d2c178e13" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Collection&lt;/code&gt; will be modified by one thread while another thread is calling a method of a Collection &lt;code&gt;CertStore&lt;/code&gt; that has been initialized with this &lt;code&gt;Collection&lt;/code&gt;, the &lt;code&gt;Collection&lt;/code&gt; must have fail-fast iterators.</source>
          <target state="translated">는 IF &lt;code&gt;Collection&lt;/code&gt; 다른 스레드가 수집하는 방법 호출되는 동안 하나 개의 스레드에 의해 수정되는 &lt;code&gt;CertStore&lt;/code&gt; 에 이로 초기화 된 &lt;code&gt;Collection&lt;/code&gt; 의 &lt;code&gt;Collection&lt;/code&gt; 르파 반복자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="810e8374c563e183f8b4590c3bc968fbd81b2167" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CompositeData&lt;/code&gt; came from an earlier version of &lt;em&gt;J&lt;/em&gt;, some items might not be present. In this case, the corresponding setters will not be called.</source>
          <target state="translated">&lt;code&gt;CompositeData&lt;/code&gt; 가 이전 버전의 &lt;em&gt;J&lt;/em&gt; 에서 온 경우 일부 항목이 없을 수 있습니다. 이 경우 해당 세터가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71b4bf78e68bc6776b7a8f7a0eb4ed1d04a8d512" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Event&lt;/code&gt;'s type was not specified by initializing the event before the method was called.</source>
          <target state="translated">메소드가 호출되기 전에 이벤트를 초기화 하여 &lt;code&gt;Event&lt;/code&gt; 유형이 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="203c00aa85f63e7b6b9375fddd15c02205fb7dda" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Event&lt;/code&gt;'s type was not specified by initializing the event before the method was called. Specification of the Event's type as &lt;code&gt;null&lt;/code&gt; or an empty string will also trigger this exception.</source>
          <target state="translated">메소드가 호출되기 전에 이벤트를 초기화 하여 &lt;code&gt;Event&lt;/code&gt; 유형이 지정되지 않은 경우. 이벤트 유형을 &lt;code&gt;null&lt;/code&gt; 또는 빈 문자열로 지정하면이 예외도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="02b4cc8da4d2810c0fbe1d7c64fd610170148d2b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;
 ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">&lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 지연이 아직 경과되지 않은 기존 지연 작업이 취소됩니다. &lt;code&gt; ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않으면 기존 정기 작업의 향후 실행이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="179c5197a088bdfb3577b89615e0f80069ec54a3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">는 IF &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 이 설정되어있는 &lt;code&gt;false&lt;/code&gt; , 지연 시간이 경과하고 있지 않는 기존의 지연 태스크는 삭제됩니다. &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않으면 향후 기존 작업의 향후 실행이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="924b95b5bc360f5419eb164ad25c4917e3384c4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Graphics2D&lt;/code&gt; object cannot handle the curved segments that the &lt;code&gt;PathIterator&lt;/code&gt; object returns then it can call the alternate &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform,double)&quot;&gt;&lt;code&gt;getPathIterator&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Shape&lt;/code&gt;, which flattens the &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;Graphics2D&lt;/code&gt; 객체가 곡선 세그먼트 (segment)를 처리 할 수 있음을 &lt;code&gt;PathIterator&lt;/code&gt; 객체 반환 다음은 대체 호출 할 수 있습니다 &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform,double)&quot;&gt; &lt;code&gt;getPathIterator&lt;/code&gt; 의&lt;/a&gt; 방법 &lt;code&gt;Shape&lt;/code&gt; 평평하게, &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d9438386cfe32fda0c1181ccd31aab76978f092" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;InvocationHandler&lt;/code&gt; is for an MXBean, then the parameters of a method are converted from the type declared in the MXBean interface into the corresponding mapped type, and the return value is converted from the mapped type into the declared type. For example, with the method</source>
          <target state="translated">상기 중간 &lt;code&gt;InvocationHandler&lt;/code&gt; MXBean에위한 다음 방법의 파라미터는 해당 타입에 매핑 MXBean의 인터페이스에서 선언 된 형태로 변환되고, 복귀 값은 선언 된 유형에 맵핑 형태로 변환된다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="db17038cfaa4ef45c73437ed292d512029f6bfe8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JInternalFrame&lt;/code&gt; is not in maximized state, returns &lt;code&gt;getBounds()&lt;/code&gt;; otherwise, returns the bounds that the &lt;code&gt;JInternalFrame&lt;/code&gt; would be restored to.</source>
          <target state="translated">는 IF &lt;code&gt;JInternalFrame&lt;/code&gt; 의가 최대화 상태가 아닌 반환 &lt;code&gt;getBounds()&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;JInternalFrame&lt;/code&gt; 이 복원 될 경계를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f060428dfdce4f587aa2a33814a603772ec95345" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this calls the view's &lt;code&gt;getBaseline()&lt;/code&gt; method.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 뷰의 호출 &lt;code&gt;getBaseline()&lt;/code&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="2d2acc95bb253287fb1fd9ad280f5e3c68a344b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this calls the view's &lt;code&gt;getBaseline()&lt;/code&gt; method. Otherwise, the default implementation is called.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 뷰의 호출 &lt;code&gt;getBaseline()&lt;/code&gt; 메소드를. 그렇지 않으면 기본 구현이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3f2bc6a4dfcf47dbe29117aa68de225f1c61e8cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; method.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 반환 뷰의 결과 &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="1bd4ebb8a1743bab39929e4ec06130e5519f66ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; method. Otherwise, the default implementation is called.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 반환 뷰의 결과 &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; 방법. 그렇지 않으면 기본 구현이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b88a2323263a45207c7b90c89107a58d6356d56a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 반환 뷰의 결과 &lt;code&gt;getMaximumSize()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="78f3308c92a131ac53ba0a2b91ae5625bc8378a8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</target>
        </trans-unit>
        <trans-unit id="30e2482d382c7844747a1e9c47c53ce8993e3afa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="cd6e2b2d459272e76855c9dfdd3c3d186a8512b9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</target>
        </trans-unit>
        <trans-unit id="3e114e0c18eb9a3a04e50b88c65e47b3d1177a2d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="1909e9311585c50274c3f90139597ea7f32cfbeb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</target>
        </trans-unit>
        <trans-unit id="b773147646e5d6ae4684d585a997f76f520542ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="3f268e97c59dcc626388a2e991c9c9562516a82d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; uses the directory syntax, as described above under &lt;a href=&quot;#directory&quot;&gt;&quot;connector addresses based on directory entries&quot;&lt;/a&gt;, then the client may obtain it as just explained, or client and server may both know the appropriate directory entry to use. For example, if the connector server for the Whatsit agent uses the entry &lt;code&gt;whatsit-agent-connector&lt;/code&gt; in the RMI registry on host &lt;code&gt;myhost&lt;/code&gt;, then client and server can both know that the appropriate &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 이 위에서 &lt;a href=&quot;#directory&quot;&gt;&quot;디렉토리 항목을 기반으로하는 커넥터 주소&quot;에&lt;/a&gt; 설명 된대로 디렉토리 구문을 사용하는 경우, 클라이언트는 방금 설명한대로이를 얻거나 클라이언트와 서버가 사용할 적절한 디렉토리 항목을 알 수 있습니다. 예를 들어, Whatsit 에이전트의 커넥터 서버가 호스트 &lt;code&gt;myhost&lt;/code&gt; 의 RMI 레지스트리에있는 &lt;code&gt;whatsit-agent-connector&lt;/code&gt; 항목을 사용하는 경우 클라이언트와 서버는 적절한 &lt;code&gt;JMXServiceURL&lt;/code&gt; 이 다음과 같은 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f826af6b5dd95bfc92e77f04fdf460591da5f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; was generated by the server, as described above under &lt;a href=&quot;#servergen&quot;&gt;&quot;connector addresses generated by the server&quot;&lt;/a&gt;, then the client will need to obtain it directly or indirectly from the server. Typically, the server makes the &lt;code&gt;JMXServiceURL&lt;/code&gt; available by storing it in a file or a lookup service.</source>
          <target state="translated">는 IF &lt;code&gt;JMXServiceURL&lt;/code&gt; 서버에서 생성하고, 같은에서 설명한 &lt;a href=&quot;#servergen&quot;&gt;&quot;서버에서 생성 커넥터 주소&quot;&lt;/a&gt; , 클라이언트는 서버로부터 직접 또는 간접적으로 획득해야한다. 일반적으로 서버는 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 파일 또는 검색 서비스에 저장하여 사용 가능 하게합니다 .</target>
        </trans-unit>
        <trans-unit id="19e53ac3ee0ca858d684bd217c73cfeb534f1225" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt;, the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned, or &lt;code&gt;null&lt;/code&gt; if an error occured. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</source>
          <target state="translated">If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt; , the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned, or &lt;code&gt;null&lt;/code&gt; if an error occured. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</target>
        </trans-unit>
        <trans-unit id="7fc52b341e17306f0b31074b4f7a8dcfcbafb512" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt;, the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</source>
          <target state="translated">If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt; , the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</target>
        </trans-unit>
        <trans-unit id="b5e161a884b01a34270547339690293148ba8fa6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LayoutManager&lt;/code&gt; installed on this container is an instance of the &lt;code&gt;LayoutManager2&lt;/code&gt; interface, then the &lt;a href=&quot;layoutmanager2#invalidateLayout(java.awt.Container)&quot;&gt;&lt;code&gt;LayoutManager2.invalidateLayout(Container)&lt;/code&gt;&lt;/a&gt; method is invoked on it supplying this &lt;code&gt;Container&lt;/code&gt; as the argument.</source>
          <target state="translated">If the &lt;code&gt;LayoutManager&lt;/code&gt; installed on this container is an instance of the &lt;code&gt;LayoutManager2&lt;/code&gt; interface, then the &lt;a href=&quot;layoutmanager2#invalidateLayout(java.awt.Container)&quot;&gt; &lt;code&gt;LayoutManager2.invalidateLayout(Container)&lt;/code&gt; &lt;/a&gt; method is invoked on it supplying this &lt;code&gt;Container&lt;/code&gt; as the argument.</target>
        </trans-unit>
        <trans-unit id="e3f171d07666393092d63f7170ed5ec052f7118d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Level&lt;/code&gt; of the specified logger is &lt;code&gt;null&lt;/code&gt;, which means that this logger's effective level is inherited from its parent, an empty string will be returned.</source>
          <target state="translated">지정된 로거 의 &lt;code&gt;Level&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 ,이 로거의 유효 레벨이 부모로부터 상속되는 경우는 빈 캐릭터 라인이 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="6ebbc0e52293490f8f9b76660317e3c20fc9979e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../../java.base/java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../../java.base/java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="458d82c56d9fb33c66e562fe6ab97aea8cc80904" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;MBeanPermission&lt;/code&gt; 의 확인에 성공, MBean에의 클래스는 그 것을 확인하여 검증 &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt; 의미한다 &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f890b35cefa98c94269d1a9a764077652d426848" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Object&lt;/code&gt; to be tested is not a &lt;code&gt;QName&lt;/code&gt; or is &lt;code&gt;null&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;Object&lt;/code&gt; to be tested is not a &lt;code&gt;QName&lt;/code&gt; or is &lt;code&gt;null&lt;/code&gt; , then this method returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="021af7bb755cf93cf54c9f5f352c98d0f4ca4622" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ObservedAttribute&lt;/code&gt; contains more than one period, for example &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt;, then the above rules are applied iteratively. Here,</source>
          <target state="translated">경우] &lt;code&gt;ObservedAttribute&lt;/code&gt; 는 예를 들어, 하나 이상의주기를 포함 &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt; 후 상기 규칙은 반복적으로 적용된다. 여기,</target>
        </trans-unit>
        <trans-unit id="ea89dee9c534a6485cf68abb91d3ac324905d7e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; method, it is unbound from the directory by this method.</target>
        </trans-unit>
        <trans-unit id="7cb7f5f842a73d2190c2e8a4561e728aa057bb8f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">경우 &lt;code&gt;RMIServerImpl&lt;/code&gt; 의이 바이는 JNDI 디렉토리에 바인드 된 &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; 방법,이 방법으로 디렉토리에서 언 바운드입니다.</target>
        </trans-unit>
        <trans-unit id="5e181fd53600dcd77e327b5091e7925935330a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;LENIENT&lt;/code&gt; and a time is parsed without a date, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; and an excess &lt;code&gt;Period&lt;/code&gt; in days.</source>
          <target state="translated">경우 &lt;code&gt;ResolverStyle&lt;/code&gt; 가 있다 &lt;code&gt;LENIENT&lt;/code&gt; 하고 시간이 날없이 구문 분석, 다음 구문 분석의 전체 결과는 구성 &lt;code&gt;LocalTime&lt;/code&gt; 과 초과 &lt;code&gt;Period&lt;/code&gt; 일이다.</target>
        </trans-unit>
        <trans-unit id="801480d1156ab6ed42af2047f9f67f81a9ed2968" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;SMART&lt;/code&gt; and a time is parsed without a date where the time is 24:00:00, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; of 00:00:00 and an excess &lt;code&gt;Period&lt;/code&gt; of one day.</source>
          <target state="translated">경우 &lt;code&gt;ResolverStyle&lt;/code&gt; 가 있다 &lt;code&gt;SMART&lt;/code&gt; 과 시간이 24:00:00이고 시간은 날짜없이 구문 분석하고 해석의 전체 결과는 구성 &lt;code&gt;LocalTime&lt;/code&gt; 00:00:00 및 초과 &lt;code&gt;Period&lt;/code&gt; 1 일.</target>
        </trans-unit>
        <trans-unit id="ea383b2cd69ecf52b9ec7ee59229284018a85985" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;String&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or does not conform to &lt;a href=&quot;#toString()&quot;&gt;&lt;code&gt;QName.toString()&lt;/code&gt;&lt;/a&gt; formatting, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">If the &lt;code&gt;String&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or does not conform to &lt;a href=&quot;#toString()&quot;&gt; &lt;code&gt;QName.toString()&lt;/code&gt; &lt;/a&gt; formatting, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="679d594737099d64f4c8a7bd67a360d72bcf8bdd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">는 IF &lt;code&gt;Type&lt;/code&gt; 파라미터 화 된 형태의 인 &lt;code&gt;Type&lt;/code&gt; 정확하게 소스 코드로 사용되는 실제의 형태 파라미터를 반영해야합니다 반환 된 객체가.</target>
        </trans-unit>
        <trans-unit id="9c0eea94ebf724c08a182505b07f4b40fc26c467" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UndoManager&lt;/code&gt; contains edits it will call &lt;code&gt;addEdit&lt;/code&gt; on the current edit passing in the new edit as the argument. If &lt;code&gt;addEdit&lt;/code&gt; returns true the new edit is assumed to have been incorporated into the current edit and the new edit will not be added to the list of current edits. Edits can use &lt;code&gt;addEdit&lt;/code&gt; as a way for smaller edits to be incorporated into a larger edit and treated as a single edit.</source>
          <target state="translated">If the &lt;code&gt;UndoManager&lt;/code&gt; contains edits it will call &lt;code&gt;addEdit&lt;/code&gt; on the current edit passing in the new edit as the argument. If &lt;code&gt;addEdit&lt;/code&gt; returns true the new edit is assumed to have been incorporated into the current edit and the new edit will not be added to the list of current edits. Edits can use &lt;code&gt;addEdit&lt;/code&gt; as a way for smaller edits to be incorporated into a larger edit and treated as a single edit.</target>
        </trans-unit>
        <trans-unit id="35ff53d86b4bc68486f63c50ba3db4d56f3b6812" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;#of(java.time.LocalDateTime,java.time.ZoneId)&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt; , this method is equivalent to &lt;a href=&quot;#of(java.time.LocalDateTime,java.time.ZoneId)&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="be1a0f77a615842bdf82ef7b9ebede6a9bce0b3f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;code&gt;ZoneId&lt;/code&gt; 사용될는 인 &lt;code&gt;ZoneOffset&lt;/code&gt; ,이 방법은 동일하다 &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d86f839b1695227093964559a355f46055cbd60" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;abort&lt;/code&gt; phase fails for any reason, then this method propagates the original exception thrown either during the &lt;code&gt;login&lt;/code&gt; phase or the &lt;code&gt;commit&lt;/code&gt; phase. In either case, the overall authentication fails.</source>
          <target state="translated">는 IF &lt;code&gt;abort&lt;/code&gt; 단계는 어떤 이유로 실패,이 메소드는 동안 하나 던져 원래 예외 전파 &lt;code&gt;login&lt;/code&gt; 단계 또는이 &lt;code&gt;commit&lt;/code&gt; 단계. 두 경우 모두 전체 인증이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a7b16f00ee4043e4aeba76ef6283f2971eb30418" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;acceptor&lt;/code&gt; function is not successfully invoked, then the push promise is rejected. The &lt;code&gt;acceptor&lt;/code&gt; function will throw an &lt;code&gt;IllegalStateException&lt;/code&gt; if invoked more than once.</source>
          <target state="translated">If the &lt;code&gt;acceptor&lt;/code&gt; function is not successfully invoked, then the push promise is rejected. The &lt;code&gt;acceptor&lt;/code&gt; function will throw an &lt;code&gt;IllegalStateException&lt;/code&gt; if invoked more than once.</target>
        </trans-unit>
        <trans-unit id="446c80fa5bc5f4e37afc5fc9e155b09818c5562f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll()&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">경우] &lt;code&gt;addAll()&lt;/code&gt; 연산이 예외를 발생이 속성 세트의 상태에 대한 영향은 구현 의존적이다; 예외 시점 이전에 지정된 세트의 요소가이 속성 세트에 추가되었거나 추가되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ef5598f3ce002caa707d0e8dab5fc3e129e43c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">경우] &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; 연산이 예외를 발생이 속성 세트의 상태에 대한 영향은 구현 의존적이다; 예외 시점 이전에 지정된 세트의 요소가이 속성 세트에 추가되었거나 추가되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0511263cbc485e9efb3be19eb199baa7484f96" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">경우 &lt;code&gt;algorithm&lt;/code&gt; 매개 변수가 null 또는 비 비어, 엔드 포인트 식별은 / 검증 절차는 SSL / TLS 핸드 쉐이크 동안 처리해야합니다. 이는 중간자 공격을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6834dc9ff0b8ff599b86ecc51718d6f5b5574c58" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS/DTLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS/DTLS handshaking. This is to prevent man-in-the-middle attacks.</target>
        </trans-unit>
        <trans-unit id="ce642f2bb7f80adee08e960922be3c55ad9db8fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an &lt;code&gt;Attribute&lt;/code&gt; whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the &lt;code&gt;AttributeSet&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an &lt;code&gt;Attribute&lt;/code&gt; whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the &lt;code&gt;AttributeSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df2ce529fb9d0af1fa8bdee431df9ad0c85e4344" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an Attribute whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the AttributeSet.</source>
          <target state="translated">는 IF &lt;code&gt;attributes&lt;/code&gt; 카테고리의 속성을 보관 매개 변수와 동일한 &lt;code&gt;category&lt;/code&gt; 매개 변수, 서비스는 속성 세트에이 속성을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="98b6741e1086600d52bcba89af328ea50edfba2c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt;, &lt;a href=&quot;../../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</source>
          <target state="translated">If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt; , &lt;a href=&quot;../../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</target>
        </trans-unit>
        <trans-unit id="560ee03306807fcb6258a99873dd7c023d6a7244" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt;, &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</source>
          <target state="translated">If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt; , &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</target>
        </trans-unit>
        <trans-unit id="717cef07fc5b446c1f7069da0b2b9e9376ef7862" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;body&lt;/code&gt; handle returns a non-&lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt;, a leading loop iteration variable of that type is also present. This variable is initialized using the optional &lt;code&gt;init&lt;/code&gt; handle, or to the &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; of type &lt;code&gt;V&lt;/code&gt; if that handle is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;body&lt;/code&gt; handle returns a non- &lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt; , a leading loop iteration variable of that type is also present. This variable is initialized using the optional &lt;code&gt;init&lt;/code&gt; handle, or to the &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; of type &lt;code&gt;V&lt;/code&gt; if that handle is &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66b2ac942fdab810011fedc70461bf42a1dedd98" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;boolean&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;, this method causes the virtual machine to stop performing the detailed instruction trace it is performing.</source>
          <target state="translated">경우 &lt;code&gt;boolean&lt;/code&gt; 인수가 &lt;code&gt;false&lt;/code&gt; 이 방법은 수행하는 상세 명령 추적을 중단 가상 머신됩니다.</target>
        </trans-unit>
        <trans-unit id="88001e51dd6c79b8369de89a8cbe2fdfe3865e70" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index - 1)&lt;/code&gt; is in the low-surrogate range, &lt;code&gt;(index - 2)&lt;/code&gt; is not negative, and the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index -
 2)&lt;/code&gt; is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;index -
 1&lt;/code&gt; is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 의 값 &lt;code&gt;(index - 1)&lt;/code&gt; 저 대리 범위이고, &lt;code&gt;(index - 2)&lt;/code&gt; 네거티브 아니며, &lt;code&gt;char&lt;/code&gt; 의 값 &lt;code&gt;(index - 2)&lt;/code&gt; 높은 surrogate 범위에있는 경우, 부가 코드 포인트 대리 쌍의 값이 반환됩니다. &lt;code&gt;index - 1&lt;/code&gt; 의 &lt;code&gt;char&lt;/code&gt; 값 이 짝을 이루지 않은 낮은 서로 게이트 또는 높은 서로 게이트 인 경우 서로 게이트 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc1506abc2a5f78b19fe3dd96f18038b15e4e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this &lt;code&gt;String&lt;/code&gt;, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 지정된 인덱스 지정된 값이 높은 대리 범위에 다음 인덱스는 이것의 길이보다 짧은 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;char&lt;/code&gt; 다음 인덱스의 값은, 저 대리 범위에서 보조 코드 포인트 인 이 대리 쌍에 해당하는이 반환됩니다. 그렇지 않으면 주어진 인덱스 의 &lt;code&gt;char&lt;/code&gt; 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c3a606e3f3d827b22e0257098f87d4bbd176eb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this sequence, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 지정된 인덱스 지정된 값이 높은 대리 범위에 다음 인덱스는이 시퀀스의 길이보다 작은, 상기 &lt;code&gt;char&lt;/code&gt; 다음 인덱스의 값은, 저 대리 범위에서 보조 코드 포인트 인 이 대리 쌍에 해당하는이 반환됩니다. 그렇지 않으면 주어진 인덱스 의 &lt;code&gt;char&lt;/code&gt; 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="adfa6cd0e81b003e1bb2d5b808729dc1489e6300" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;../../../../java.base/java/lang/character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;../../../../java.base/java/lang/character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</target>
        </trans-unit>
        <trans-unit id="7059bfb26c628d831ae809e02477cb1879e60f94" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">경우 &lt;code&gt;char&lt;/code&gt; 인덱스로 지정된 값이 인 &lt;a href=&quot;character#unicode&quot;&gt;대리&lt;/a&gt; , 대리 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8250d512b905f35c6a410fcb5609b7900e346a5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;commit&lt;/code&gt; phase of the authentication process fails, then the overall authentication fails and this method invokes the &lt;code&gt;abort&lt;/code&gt; method for each configured &lt;code&gt;LoginModule&lt;/code&gt;.</source>
          <target state="translated">인증 프로세스 의 &lt;code&gt;commit&lt;/code&gt; 단계가 실패하면 전체 인증이 실패하고이 메소드는 구성된 각 &lt;code&gt;LoginModule&lt;/code&gt; 에 대한 &lt;code&gt;abort&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="84555e61977552659f8d8d7542bd52057f6a2286" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;connect&lt;/code&gt; method is called when the connection has already been opened (indicated by the &lt;code&gt;connected&lt;/code&gt; field having the value &lt;code&gt;true&lt;/code&gt;), the call is ignored.</source>
          <target state="translated">상기 중간 &lt;code&gt;connect&lt;/code&gt; 접속이 이미 개방되었을 때 메소드가 호출된다 (의해 표시된 &lt;code&gt;connected&lt;/code&gt; 값을 갖는 필드 &lt;code&gt;true&lt;/code&gt; ), 호는 무시된다.</target>
        </trans-unit>
        <trans-unit id="342ba2fb4627294d3b781daa9697b718b5c068d6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;, the component is added in the first available position (left/top if open, else right/bottom).</source>
          <target state="translated">If the &lt;code&gt;constraints&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt; , the component is added in the first available position (left/top if open, else right/bottom).</target>
        </trans-unit>
        <trans-unit id="671e297a3a1ea6f0c42770e029c80abaa60e1bfb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS handshake must be permitted by the constraints.</source>
          <target state="translated">&lt;code&gt;constraints&lt;/code&gt; 매개 변수가 널이 아닌 경우, SSL / TLS 핸드 쉐이크에 사용 된 모든 암호화 알고리즘, 키 및 알고리즘 매개 변수는 제한 조건에 의해 허용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b40b2d9ff34a0913ffad16fe301b6eeb61865ff0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS/DTLS handshake must be permitted by the constraints.</source>
          <target state="translated">If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS/DTLS handshake must be permitted by the constraints.</target>
        </trans-unit>
        <trans-unit id="6a5dce44bc4531313d43efc02c3d4e5307173391" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;deep&lt;/code&gt; option was set to &lt;code&gt;true&lt;/code&gt;, the descendants of the source &lt;code&gt;DocumentFragment&lt;/code&gt; are recursively imported and the resulting nodes reassembled under the imported &lt;code&gt;DocumentFragment&lt;/code&gt; to form the corresponding subtree. Otherwise, this simply generates an empty &lt;code&gt;DocumentFragment&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;deep&lt;/code&gt; option was set to &lt;code&gt;true&lt;/code&gt; , the descendants of the source &lt;code&gt;DocumentFragment&lt;/code&gt; are recursively imported and the resulting nodes reassembled under the imported &lt;code&gt;DocumentFragment&lt;/code&gt; to form the corresponding subtree. Otherwise, this simply generates an empty &lt;code&gt;DocumentFragment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c20fefbf5f84e3a9d83640712edb423384c25b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;defaultLoader&lt;/code&gt; argument is non-&lt;code&gt;null&lt;/code&gt; and all of the named interfaces can be resolved through that loader, then,</source>
          <target state="translated">If the &lt;code&gt;defaultLoader&lt;/code&gt; argument is non- &lt;code&gt;null&lt;/code&gt; and all of the named interfaces can be resolved through that loader, then,</target>
        </trans-unit>
        <trans-unit id="44563c51972a22c15c4aac96132c92755f5fb940" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the system-dependent default temporary-file directory will be used. The default temporary-file directory is specified by the system property &lt;code&gt;java.io.tmpdir&lt;/code&gt;. On UNIX systems the default value of this property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;. A different value may be given to this system property when the Java virtual machine is invoked, but programmatic changes to this property are not guaranteed to have any effect upon the temporary directory used by this method.</source>
          <target state="translated">는 IF &lt;code&gt;directory&lt;/code&gt; 인수가 &lt;code&gt;null&lt;/code&gt; 다음 시스템에 의존하는 기본 임시 파일 디렉토리가 사용됩니다. 기본 임시 파일 디렉토리는 시스템 특성 &lt;code&gt;java.io.tmpdir&lt;/code&gt; 에 의해 지정됩니다 . UNIX 시스템에서이 특성의 기본값은 일반적으로 &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 일반적으로 &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt; 입니다. JVM (Java Virtual Machine)이 호출 될 때이 시스템 특성에 다른 값이 제공 될 수 있지만이 특성의 프로그래밍 방식 변경이이 메소드가 사용하는 임시 디렉토리에 영향을 미치지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2c4e3bcad43dd7e533a7fbe7a4541570c19bd7c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="61b3f5e27ccdfa6299b991fa9397c7fbc31d2c50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;emitter&lt;/code&gt; 생성자에 매개 변수의 인스턴스이었다 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 이 메소드는 호출 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab969fd58c84fba8fefef4d68297aff8fba763d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this engine.</source>
          <target state="translated">는 IF &lt;code&gt;engine&lt;/code&gt; 매개 변수를 사용할 수 있으며의 알고리즘 제약 &lt;code&gt;SSLParameters&lt;/code&gt; 인증 경로에있는 모든 인증서, null가 아닌, 같은 주제의 공개 키, 서명 알고리즘, 키 사용, 확장 키 사용 등을 준수하기 위해 필요로 필드 이 엔진의 알고리즘 제약 조건에</target>
        </trans-unit>
        <trans-unit id="4eab346c804a32d54771d78aef5cb1081f3a8a5a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;engine&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">는 IF &lt;code&gt;engine&lt;/code&gt; 매개 변수를 사용할 수 있으며의 엔드 포인트 식별 알고리즘 &lt;code&gt;SSLParameters&lt;/code&gt; 비 비어, man-in-the-middle 공격은 그 주소를 방지하기 위해 &lt;code&gt;engine&lt;/code&gt; 에 연결이 최종 제시 피어의 식별 정보에 대해 확인되어야한다 엔드 포인트 식별 알고리즘에 지정된 엔티티 X509 인증서.</target>
        </trans-unit>
        <trans-unit id="c489bda8ac51d0adb2cd2ea9ed206915eaf00580" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="def3bb99565bff52201998cb9934892d1dd9c8bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</target>
        </trans-unit>
        <trans-unit id="6b551db3025e219ae99ad787aed372f0514c1f97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="c01021b847664573167d59264418973e495b23f1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</target>
        </trans-unit>
        <trans-unit id="56c06cc3e424dcdff076cdd1bf18f2a3b0d87e7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자를로드하는 데 사용할 클래스 로더입니다. 연관된 값이 &lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 인스턴스가 아닌 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d005cee8b528479b05c0be85b9c4205d983a4967" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자 패키지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="826709e7b964ff5f55e8bba64d589128adee0453" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자를로드하는 데 사용할 클래스 로더입니다. 연관된 값이 &lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 인스턴스가 아닌 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57ace146c6c02d090ae1128a0850bf8c4adb9e91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자 패키지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6ad40577697d2d3214b29500713b40249dcf0017" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;execute&lt;/code&gt; method is called at this point, the query sent to the DBMS will be:</source>
          <target state="translated">If the &lt;code&gt;execute&lt;/code&gt; method is called at this point, the query sent to the DBMS will be:</target>
        </trans-unit>
        <trans-unit id="d7e356babec0dbd66ed893c5d593e3b80f2c4c69" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;execute&lt;/code&gt; method is successful, it will set the appropriate private &lt;code&gt;JdbcRowSet&lt;/code&gt; fields with the following:</source>
          <target state="translated">If the &lt;code&gt;execute&lt;/code&gt; method is successful, it will set the appropriate private &lt;code&gt;JdbcRowSet&lt;/code&gt; fields with the following:</target>
        </trans-unit>
        <trans-unit id="f6b8bda61da14baa6de0517de831488bd2ee3ae0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flag&lt;/code&gt; is false, end-of-line characters are treated as white space and serve only to separate tokens.</source>
          <target state="translated">&lt;code&gt;flag&lt;/code&gt; 가 false 인 경우 줄 끝 문자는 공백으로 처리되며 별도의 토큰에만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1442b96066ac814d95028e3d47c625abac13dd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;handleError&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the DOM implementation should stop the current processing when possible. If the method returns &lt;code&gt;true&lt;/code&gt;, the processing may continue depending on &lt;code&gt;DOMError.severity&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;handleError&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; , the DOM implementation should stop the current processing when possible. If the method returns &lt;code&gt;true&lt;/code&gt; , the processing may continue depending on &lt;code&gt;DOMError.severity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e167f1b0b7b6f2ec44852a0a73f6c3eeb0559e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;hsbvals&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt;, then a new array is allocated to return the result. Otherwise, the method returns the array &lt;code&gt;hsbvals&lt;/code&gt;, with the values put into that array.</source>
          <target state="translated">If the &lt;code&gt;hsbvals&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; , then a new array is allocated to return the result. Otherwise, the method returns the array &lt;code&gt;hsbvals&lt;/code&gt; , with the values put into that array.</target>
        </trans-unit>
        <trans-unit id="57070b75c38e47f9bec4e11be8d75f04d3e68264" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt;&lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt; , and each call to &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt; &lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt; &lt;/a&gt; returns a new clone.</target>
        </trans-unit>
        <trans-unit id="f96a39d4789943d7d6902746fb2340490af74ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">경우 &lt;code&gt;info&lt;/code&gt; 배열이 비어 있지 않은, 다음은 경우와 같이 생성자에 의해 복제됩니다 &lt;code&gt;info.clone()&lt;/code&gt; 및 호출 할 때마다 &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt; 새로운 복제를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="3eb68d70f873d065dccf85e83072633accafa5b8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;iterator&lt;/code&gt; handle is non-&lt;code&gt;null&lt;/code&gt;, it must have the return type &lt;code&gt;java.util.Iterator&lt;/code&gt; or a subtype thereof. The iterator it produces when the loop is executed will be assumed to yield values which can be converted to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;iterator&lt;/code&gt; handle is non- &lt;code&gt;null&lt;/code&gt; , it must have the return type &lt;code&gt;java.util.Iterator&lt;/code&gt; or a subtype thereof. The iterator it produces when the loop is executed will be assumed to yield values which can be converted to type &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2eafd26f57a8ac8bfe07dee9777924ccc1ddeef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is specified and does not point to an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 를의 속성이 지정되고 가리 키지 않는 &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="c4278296c23500bf6c0cea864ef00fd56ed5236d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; key is not present in the &lt;code&gt;environment&lt;/code&gt; parameter, the calling thread's context class loader is used.</source>
          <target state="translated">는 IF &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 의 키에 존재하지 않는 &lt;code&gt;environment&lt;/code&gt; 매개 변수, 호출 thread의 문맥 클래스 로더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3056297b7728c6033d8b58edc893075abdeaf0f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;listenerMethodName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;all&lt;/em&gt; methods in the interface trigger the &lt;code&gt;action&lt;/code&gt; to be executed on the &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;listenerMethodName&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 인터페이스의 &lt;em&gt;모든&lt;/em&gt; 메소드 가 &lt;code&gt;target&lt;/code&gt; 실행되도록 &lt;code&gt;action&lt;/code&gt; 를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c26cc70217e4df47d29c0c2d3d16af4b3ed49f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the bootstrap class loader.</source>
          <target state="translated">는 IF &lt;code&gt;loader&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 및 시큐리티 매니저가 존재 해, 호출 측의 클래스 로더가 null는 아니고,이 메소드는 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 와 방법 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 는 부트 스트랩 클래스 로더에 액세스 할 수있는 것을 보증 할 수있는 권한 .</target>
        </trans-unit>
        <trans-unit id="883de64909ad64380525bc73b0b1943d2957d4ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;login&lt;/code&gt; method returns without throwing an exception, then the overall authentication succeeded. The caller can then retrieve the newly authenticated Subject by invoking the &lt;code&gt;getSubject&lt;/code&gt; method. Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective &lt;code&gt;getPrincipals&lt;/code&gt;, &lt;code&gt;getPublicCredentials&lt;/code&gt;, and &lt;code&gt;getPrivateCredentials&lt;/code&gt; methods.</source>
          <target state="translated">경우 &lt;code&gt;login&lt;/code&gt; 메소드가 예외를 throw하지 않고 반환, 인증 전체가 성공했다. 그러면 호출자는 &lt;code&gt;getSubject&lt;/code&gt; 메소드 를 호출하여 새로 인증 된 주제를 검색 할 수 있습니다 . 주제와 연관된 프린시 펄 및 신임은 주제의 해당 &lt;code&gt;getPrincipals&lt;/code&gt; , &lt;code&gt;getPublicCredentials&lt;/code&gt; 및 &lt;code&gt;getPrivateCredentials&lt;/code&gt; 메소드 를 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60cd069f53c1777bbf4cf31f1344fe37a4dd9ac1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mimeType&lt;/code&gt; is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;mimeType&lt;/code&gt; is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b49049ac47e926595641db8085788c19725bedae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;minimumCapacity&lt;/code&gt; argument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here.</source>
          <target state="translated">는 IF &lt;code&gt;minimumCapacity&lt;/code&gt; 의 인수가 정의 값이 아닌,이 메소드는 아무 작업도 간단하게 수익을지지 않습니다. 이 개체에 대한 후속 작업으로 인해 여기에서 요청한 것보다 실제 용량이 줄어들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="848f1dae842a9e3e26ccb5fe35a5a76ed09b5792" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modes&lt;/code&gt; parameter is of length zero, then the existence of the file is checked.</source>
          <target state="translated">는 IF &lt;code&gt;modes&lt;/code&gt; 매개 변수는 길이가 0이며, 파일의 존재가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="26efd0bf17769d06237d7690d4aec1e552ef72d2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modifiers&lt;/code&gt; passed to the constructor are invalid, this method returns them unchanged.</source>
          <target state="translated">If the &lt;code&gt;modifiers&lt;/code&gt; passed to the constructor are invalid, this method returns them unchanged.</target>
        </trans-unit>
        <trans-unit id="68e361de8335b69d5e82c2e65544790404d5fa01" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mouseX&lt;/code&gt; and &lt;code&gt;mouseY&lt;/code&gt; are in the expand/collapse region of the &lt;code&gt;row&lt;/code&gt;, this will toggle the row.</source>
          <target state="translated">If the &lt;code&gt;mouseX&lt;/code&gt; and &lt;code&gt;mouseY&lt;/code&gt; are in the expand/collapse region of the &lt;code&gt;row&lt;/code&gt; , this will toggle the row.</target>
        </trans-unit>
        <trans-unit id="d2a314f2aa28a80e456c2b1019bb7151fb7190ec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; begins with a &lt;code&gt;'/'&lt;/code&gt; (&lt;code&gt;'\u002f'&lt;/code&gt;), then the absolute name of the resource is the portion of the &lt;code&gt;name&lt;/code&gt; following the &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;name&lt;/code&gt; 로 시작할 &lt;code&gt;'/'&lt;/code&gt; ( &lt;code&gt;'\u002f'&lt;/code&gt; ), 그 자원의 절대 이름의 부분 인 &lt;code&gt;name&lt;/code&gt; 다음 &lt;code&gt;'/'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64bdc0e92c398401f342c415851da39654a29de8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is &quot;&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;&quot; or &quot;&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;&quot; a &lt;code&gt;NoSuchMethodException&lt;/code&gt; is raised. Otherwise, the method to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:</source>
          <target state="translated">상기 중간 &lt;code&gt;name&lt;/code&gt; &quot;입니다 &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; &quot;는 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 발생합니다. 그렇지 않으면, 반영 될 방법은 다음 알고리즘에 의해 결정됩니다. C를이 객체가 나타내는 클래스 또는 인터페이스라고하자.</target>
        </trans-unit>
        <trans-unit id="cf8f40175e230701ae0b215435cd687b9dbe0a2f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; parameter represents something other than a logical font, i.e. is interpreted as a physical font face or family, and this cannot be mapped by the implementation to a physical font or a compatible alternative, then the font system will map the Font instance to &quot;Dialog&quot;, such that for example, the family as reported by &lt;a href=&quot;#getFamily()&quot;&gt;&lt;code&gt;getFamily&lt;/code&gt;&lt;/a&gt; will be &quot;Dialog&quot;.</source>
          <target state="translated">If the &lt;code&gt;name&lt;/code&gt; parameter represents something other than a logical font, i.e. is interpreted as a physical font face or family, and this cannot be mapped by the implementation to a physical font or a compatible alternative, then the font system will map the Font instance to &quot;Dialog&quot;, such that for example, the family as reported by &lt;a href=&quot;#getFamily()&quot;&gt; &lt;code&gt;getFamily&lt;/code&gt; &lt;/a&gt; will be &quot;Dialog&quot;.</target>
        </trans-unit>
        <trans-unit id="83d37bcba2e6c3af77d7d4ae04d7689d9a46d013" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute with the same local name and namespace URI, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;newAttr&lt;/code&gt; 속성이 같은 로컬 명과 이름 공간 URI와 기존 속성을 대체, 교체 &lt;code&gt;Attr&lt;/code&gt; 노드는 달리, 반환되는 &lt;code&gt;null&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c99c4ecff1480f789773edec7e413ca2eabcdc6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;newAttr&lt;/code&gt; 속성이 기존의 속성을 대체, 교체 &lt;code&gt;Attr&lt;/code&gt; 노드는 달리, 반환되는 &lt;code&gt;null&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e562c3377bc531b17a3856d97697e38d3cf5595e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newLength&lt;/code&gt; argument is greater than or equal to the current length, sufficient null characters (&lt;code&gt;'\u0000'&lt;/code&gt;) are appended so that length becomes the &lt;code&gt;newLength&lt;/code&gt; argument.</source>
          <target state="translated">경우] &lt;code&gt;newLength&lt;/code&gt; 인수보다 크거나 현재의 길이와 동일 충분한 널 문자 ( &lt;code&gt;'\u0000'&lt;/code&gt; 그 길이는가되도록) 추가된다 &lt;code&gt;newLength&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="31c964b999377de0a92c3ddd622adf97746585c7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;notifier.notifyAll()&lt;/code&gt; happens before the waiting thread enters the &lt;code&gt;notifier.wait()&lt;/code&gt; method, the &lt;code&gt;while&lt;/code&gt; loop ensures that the waiting thread will not enter the &lt;code&gt;notifier.wait()&lt;/code&gt; method. Otherwise, there is no guarantee that the waiting thread will ever be woken from the wait.</source>
          <target state="translated">If the &lt;code&gt;notifier.notifyAll()&lt;/code&gt; happens before the waiting thread enters the &lt;code&gt;notifier.wait()&lt;/code&gt; method, the &lt;code&gt;while&lt;/code&gt; loop ensures that the waiting thread will not enter the &lt;code&gt;notifier.wait()&lt;/code&gt; method. Otherwise, there is no guarantee that the waiting thread will ever be woken from the wait.</target>
        </trans-unit>
        <trans-unit id="cd7d35bb1b07a6fa45d7d92b3c84889d6cce40ac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="301c55c1d2d5648b427ee3a645ab8146cd1a941a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 포함 매개 변수 &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; 의&lt;/a&gt; 옵션은 다음 스트림이 너무 사이클이 검출 될 수 있음을 방문한 디렉토리를 추적합니다. 디렉토리의 조상 인 디렉토리에 항목이있을 때주기가 발생합니다. 디렉토리 탐지는 디렉토리 의 &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; 를 기록 하거나 파일 키를 사용할 수없는 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 디렉토리가 상위 파일과 동일한 파일인지 테스트하여 수행됩니다. 주기가 감지되면 &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt; 인스턴스의 입출력 오류로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="c55674bb2b5b73e671fc2ec40dcb555e23d9e8d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed(T,java.io.IOException)&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed(T,java.io.IOException)&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; &lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ecea4dec8dcb1fadb716a28cf7ec70ca81e1d565" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 포함 매개 변수 &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; 의&lt;/a&gt; 옵션은 다음이 방법은 너무 사이클이 검출 될 수 있음을 방문한 디렉토리를 추적합니다. 디렉토리의 조상 인 디렉토리에 항목이있을 때주기가 발생합니다. 디렉토리 탐지는 디렉토리 의 &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; 를 기록 하거나 파일 키를 사용할 수없는 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 디렉토리가 상위 파일과 동일한 파일인지 테스트하여 수행됩니다. 사이클이 검출 될 때는 I / O 에러로 처리하고, &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; 의&lt;/a&gt; 방법의 인스턴스를 호출 &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31072125bfcecae8a94f901f25b6fafec9dc2ff7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;#isAbsolute()&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;#isAbsolute()&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt; . If &lt;code&gt;other&lt;/code&gt; is an</target>
        </trans-unit>
        <trans-unit id="88ff2d156a33a9f0f1f1ee553f98ff8909648b12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">경우] &lt;code&gt;other&lt;/code&gt; 파라미터가있다 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로가이 메소드는 반환 소소 &lt;code&gt;other&lt;/code&gt; . 경우 &lt;code&gt;other&lt;/code&gt; 인</target>
        </trans-unit>
        <trans-unit id="9865b3d772f73983f404112e79623aa8e389cc36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="4c153c7b1ed1d9892cc1783d56a0214ceb0e6260" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#engineGetOutputSize(int)&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#engineGetOutputSize(int)&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt; to determine how big the output buffer should be.</target>
        </trans-unit>
        <trans-unit id="e5001b62a3fa0f461f2cf7ef6760eeea626b5baf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#getOutputSize(int)&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#getOutputSize(int)&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; to determine how big the output buffer should be.</target>
        </trans-unit>
        <trans-unit id="3573d5215011c7d840ccb006ba46e8ea91465ab0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4e86a833a3d986a22969c431219896e2f0d39b7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="04b14a126287c47f1542560e798db984f2eaa1bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="89fab518710d4b47a17308246643c8e2a1ae9311" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non- &lt;code&gt;null&lt;/code&gt; value just returns it.</target>
        </trans-unit>
        <trans-unit id="e3f72f3125072f59960bf1220d641055ff086775" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getPreferredSize&lt;/code&gt; method returns a non &lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non- &lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getPreferredSize&lt;/code&gt; method returns a non &lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</target>
        </trans-unit>
        <trans-unit id="e09b11d717ca9d2b9db6e423c314021366d5f96d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;pri&lt;/code&gt; argument is less than &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt;&lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt;&lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt;&lt;/a&gt;, the maximum priority of the group remains unchanged.</source>
          <target state="translated">경우] &lt;code&gt;pri&lt;/code&gt; 인수 미만이다 &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt; &lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt; &lt;/a&gt; 또는보다 &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt; &lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt; &lt;/a&gt; 그룹의 최고 우선 순위는 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="c2d320fca5e0359eb42dfb70629d91de0ba8bdc2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;prototypeCellValue&lt;/code&gt; property is &lt;code&gt;non-null&lt;/code&gt;, setting the cell renderer also causes the &lt;code&gt;fixedCellWidth&lt;/code&gt; and &lt;code&gt;fixedCellHeight&lt;/code&gt; properties to be re-calculated. Only one &lt;code&gt;PropertyChangeEvent&lt;/code&gt; is generated however - for the &lt;code&gt;cellRenderer&lt;/code&gt; property.</source>
          <target state="translated">If the &lt;code&gt;prototypeCellValue&lt;/code&gt; property is &lt;code&gt;non-null&lt;/code&gt; , setting the cell renderer also causes the &lt;code&gt;fixedCellWidth&lt;/code&gt; and &lt;code&gt;fixedCellHeight&lt;/code&gt; properties to be re-calculated. Only one &lt;code&gt;PropertyChangeEvent&lt;/code&gt; is generated however - for the &lt;code&gt;cellRenderer&lt;/code&gt; property.</target>
        </trans-unit>
        <trans-unit id="7ab6fa23ab907d0e5b9b458534eaceb7cc5333a4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realEditor&lt;/code&gt; returns true to this message, &lt;code&gt;prepareForEditing&lt;/code&gt; is messaged and true is returned.</source>
          <target state="translated">If the &lt;code&gt;realEditor&lt;/code&gt; returns true to this message, &lt;code&gt;prepareForEditing&lt;/code&gt; is messaged and true is returned.</target>
        </trans-unit>
        <trans-unit id="7083b5d57e80daca82c9ea7e4f69ee995d29855a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realEditor&lt;/code&gt; will allow editing to stop, the &lt;code&gt;realEditor&lt;/code&gt; is removed and true is returned, otherwise false is returned.</source>
          <target state="translated">If the &lt;code&gt;realEditor&lt;/code&gt; will allow editing to stop, the &lt;code&gt;realEditor&lt;/code&gt; is removed and true is returned, otherwise false is returned.</target>
        </trans-unit>
        <trans-unit id="72da6eb0f51543265c08bfdc0d2bc08c5c28b9d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it indicates that this method is being called because the previously loaded resource bundle has expired.</source>
          <target state="translated">경우 &lt;code&gt;reload&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; , 그것은 이전에로드 된 자원 번들이 만료 되었기 때문에이 메소드가 호출되고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f1c25c2d5a4c3be0ad0ceae100cbbd46dd49166c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;resizingColumn&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it is one of the columns in the table that has changed size rather than the table itself. In this case the auto-resize modes govern the way the extra (or deficit) space is distributed amongst the available columns.</source>
          <target state="translated">If the &lt;code&gt;resizingColumn&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; , it is one of the columns in the table that has changed size rather than the table itself. In this case the auto-resize modes govern the way the extra (or deficit) space is distributed amongst the available columns.</target>
        </trans-unit>
        <trans-unit id="9cf1a2b060b2436670293c7813d34eef4b639e76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then the delimiter characters are also returned as tokens. Each delimiter is returned as a string of length one. If the flag is &lt;code&gt;false&lt;/code&gt;, the delimiter characters are skipped and only serve as separators between tokens.</source>
          <target state="translated">는 IF &lt;code&gt;returnDelims&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; 를 , 단락 문자도 토큰으로 반환됩니다. 각 분리 문자는 길이가 1 인 문자열로 리턴됩니다. 플래그가 &lt;code&gt;false&lt;/code&gt; 인 경우 구분 문자는 건너 뛰고 토큰 사이의 구분자 역할 만합니다.</target>
        </trans-unit>
        <trans-unit id="13d413d3ee252e112f59337a3ad9bdce1bc727e1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;rootVisible&lt;/code&gt; setting specifies that the root node is to be displayed, then that is the only node at the topmost level. If the root node is not displayed, then all of its children are at the topmost level of the tree. Handles are always displayed for nodes other than the topmost.</source>
          <target state="translated">If the &lt;code&gt;rootVisible&lt;/code&gt; setting specifies that the root node is to be displayed, then that is the only node at the topmost level. If the root node is not displayed, then all of its children are at the topmost level of the tree. Handles are always displayed for nodes other than the topmost.</target>
        </trans-unit>
        <trans-unit id="814c644fd80ff6c6cfb5225d71687f0ea854f3a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; looks like:</source>
          <target state="translated">경우] &lt;code&gt;serviceURL&lt;/code&gt; 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="135f589d26f864ce90f30a25047418b479d5f710" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; you specify has an empty URL path (after the optional host and port), or if you do not specify a &lt;code&gt;serviceURL&lt;/code&gt;, then the connector server will fabricate a new &lt;code&gt;JMXServiceURL&lt;/code&gt; that clients can use to connect:</source>
          <target state="translated">는 IF &lt;code&gt;serviceURL&lt;/code&gt; 지정은 (옵션의 호스트와 포트) 하늘의 URL 경로가 당신이 지정하지 않은 경우, 또는 &lt;code&gt;serviceURL&lt;/code&gt; 다음 커넥터 서버는 새로운 제조됩니다 &lt;code&gt;JMXServiceURL&lt;/code&gt; 를 클라이언트가 연결하는 데 사용할 수를 :</target>
        </trans-unit>
        <trans-unit id="7de93d07441877a38ae86e0b1d48750f6d309642" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;setSize&lt;/code&gt; or &lt;code&gt;setBounds&lt;/code&gt; methods are called afterwards with a width or height less than that was specified by the &lt;code&gt;setMinimumSize&lt;/code&gt; method the window is automatically enlarged to meet the &lt;code&gt;minimumSize&lt;/code&gt; value. The &lt;code&gt;minimumSize&lt;/code&gt; value also affects the behaviour of the &lt;code&gt;pack&lt;/code&gt; method.</source>
          <target state="translated">If the &lt;code&gt;setSize&lt;/code&gt; or &lt;code&gt;setBounds&lt;/code&gt; methods are called afterwards with a width or height less than that was specified by the &lt;code&gt;setMinimumSize&lt;/code&gt; method the window is automatically enlarged to meet the &lt;code&gt;minimumSize&lt;/code&gt; value. The &lt;code&gt;minimumSize&lt;/code&gt; value also affects the behaviour of the &lt;code&gt;pack&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="a4c7fe60b96360a2fce6906e7dfb1015497d385d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sharedSecret&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, this call should be repeated with a larger output buffer.</source>
          <target state="translated">는 IF &lt;code&gt;sharedSecret&lt;/code&gt; 에 버퍼가 너무 작아 결과를 보관 유지할 수하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생합니다. 이 경우이 호출은 더 큰 출력 버퍼로 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="a59bde6bd9cfdf4f9c0e2000a8690929361fab50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this socket.</source>
          <target state="translated">는 IF &lt;code&gt;socket&lt;/code&gt; 매개 변수의 인스턴스 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 와의 알고리즘 제약 &lt;code&gt;SSLParameters&lt;/code&gt; 인증 경로에있는 모든 인증서, null가 아닌, 등 주제의 공개 키, 서명 알고리즘, 키 사용, 확장 키 사용으로 필드 이 소켓에있는 알고리즘 제약 조건을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9eeaa551ce6db761bfe71fcd9d95ed24d11d58e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;socket&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">경우 &lt;code&gt;socket&lt;/code&gt; 매개 변수의 인스턴스 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 와의 엔드 포인트 식별 알고리즘 &lt;code&gt;SSLParameters&lt;/code&gt; 비 비어, man-in-the-middle 공격은 그 주소를 방지하기 위해 &lt;code&gt;socket&lt;/code&gt; 에 연결이 제시 피어의 식별 정보에 대해 확인되어야한다 엔드 포인트 식별 알고리즘에 지정된 엔드 엔티티 X509 인증서</target>
        </trans-unit>
        <trans-unit id="a8ad5fb90dd67b864239c52c78d91a33b02bcd3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</source>
          <target state="translated">If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</target>
        </trans-unit>
        <trans-unit id="50552460698026ff8f20b17c1d4139edc635e7a4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;verify&lt;/code&gt; flag is on when opening a signed jar file, the content of the jar entry is verified against the signature embedded inside the manifest that is associated with its &lt;a href=&quot;jarentry#getRealName()&quot;&gt;&lt;code&gt;path name&lt;/code&gt;&lt;/a&gt;. For a multi-release jar file, the content of a versioned entry is verfieid against its own signature and &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt;&lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt;&lt;/a&gt; returns its own signers. Please note that the verification process does not include validating the signer's certificate. A caller should inspect the return value of &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt;&lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt;&lt;/a&gt; to further determine if the signature can be trusted.</source>
          <target state="translated">If the &lt;code&gt;verify&lt;/code&gt; flag is on when opening a signed jar file, the content of the jar entry is verified against the signature embedded inside the manifest that is associated with its &lt;a href=&quot;jarentry#getRealName()&quot;&gt; &lt;code&gt;path name&lt;/code&gt; &lt;/a&gt;. For a multi-release jar file, the content of a versioned entry is verfieid against its own signature and &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt; &lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt; &lt;/a&gt; returns its own signers. Please note that the verification process does not include validating the signer's certificate. A caller should inspect the return value of &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt; &lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt; &lt;/a&gt; to further determine if the signature can be trusted.</target>
        </trans-unit>
        <trans-unit id="384a467e1b3d5e62425baa603c92bb9909dbf0dc" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of the characters asterisk or question mark and they are not preceded by a backslash, then they are considered as wildcard characters and the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">는 IF &lt;em&gt;인용 값이&lt;/em&gt; 문자의 별표 (*) 또는 물음표 중 하나 개 이상 발생을 포함하고는 앞에 백 슬래시되지 않습니다, 그들은이 와일드 카드 문자로 간주하고 개체 이름은이다하는 &lt;em&gt;속성 값 패턴&lt;/em&gt; . 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="383d196bbc70848d6d2a83c15bee341a49633abd" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence of the wildcard characters asterisk or question mark, then the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">&lt;em&gt;따옴표없는 값&lt;/em&gt; 에 와일드 카드 문자 별표 또는 물음표가 하나 이상 포함 된 경우 개체 이름은 &lt;em&gt;속성 값 pattern&lt;/em&gt; 입니다. 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8fc60c08a8c50456909645784a1769d622137e78" translate="yes" xml:space="preserve">
          <source>If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted can contain code points that are unassigned in Unicode 3.2, which is the Unicode version on which IDN conversion is based. If the flag is not used, the presence of such unassigned code points is treated as an error.</source>
          <target state="translated">ALLOW_UNASSIGNED 플래그가 사용되는 경우, 변환 될 도메인 이름 문자열은 유니 코드 3.2에서 할당되지 않은 코드 포인트를 포함 할 수 있으며, 이는 IDN 변환이 기반으로하는 유니 코드 버전입니다. 플래그를 사용하지 않으면 할당되지 않은 코드 포인트가 존재하는 것은 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="700fc7ae106ff84c28cd4140489739bfdaaa88d6" translate="yes" xml:space="preserve">
          <source>If the API can not be used to configure a &lt;code&gt;JarFile&lt;/code&gt; (e.g. to override the configuration of a compiled application or library), two &lt;code&gt;System&lt;/code&gt; properties are available.</source>
          <target state="translated">If the API can not be used to configure a &lt;code&gt;JarFile&lt;/code&gt; (e.g. to override the configuration of a compiled application or library), two &lt;code&gt;System&lt;/code&gt; properties are available.</target>
        </trans-unit>
        <trans-unit id="2a7c711b7120183f899af59849df74982f595de0" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="27052094f3a72a9f04c55988b8fcc4b55c99cb46" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments, then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="bf6802705f363000e83d105cf3b075ebc1fbcacb" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 이전에 내부 검사 된 경우 BeanInfo 캐시에서 BeanInfo 클래스가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="74b13711d7aed1bc07acd1271fe358967b6f6726" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="2d00c2a268a3801edc2c4c099c48a140b0fd8461" translate="yes" xml:space="preserve">
          <source>If the CleaningExample is used in a try-finally block then the &lt;code&gt;close&lt;/code&gt; method calls the cleaning action. If the &lt;code&gt;close&lt;/code&gt; method is not called, the cleaning action is called by the Cleaner when the CleaningExample instance has become phantom reachable.</source>
          <target state="translated">If the CleaningExample is used in a try-finally block then the &lt;code&gt;close&lt;/code&gt; method calls the cleaning action. If the &lt;code&gt;close&lt;/code&gt; method is not called, the cleaning action is called by the Cleaner when the CleaningExample instance has become phantom reachable.</target>
        </trans-unit>
        <trans-unit id="454995cc2e260c1d06757623f1b5ad1b2feb2e38" translate="yes" xml:space="preserve">
          <source>If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods.</source>
          <target state="translated">If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods.</target>
        </trans-unit>
        <trans-unit id="a17b4fd0fc3c2da711064a3199127d020c189ac1" translate="yes" xml:space="preserve">
          <source>If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods. If the ColorModel is not an IndexColorModel or is null, this method overrides the default ColorModel used by the ImageProducer and specifies the default RGB ColorModel instead.</source>
          <target state="translated">If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods. If the ColorModel is not an IndexColorModel or is null, this method overrides the default ColorModel used by the ImageProducer and specifies the default RGB ColorModel instead.</target>
        </trans-unit>
        <trans-unit id="ebb62725402f17c9f293bd13a4222501b92b1afb" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</target>
        </trans-unit>
        <trans-unit id="b15f89fd97901ee1fb24930f37e7ae4ef300f4ae" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one. Converts a buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one. Converts a buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method.</target>
        </trans-unit>
        <trans-unit id="a2d4a4e4912ac5e9ff71960aac1cb3d98b8ae728" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel.</target>
        </trans-unit>
        <trans-unit id="f5b2b08b4860ee3f58dfbccb3e9b728f83daa433" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel. Otherwise converts the buffer of byte pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel. Otherwise converts the buffer of byte pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</target>
        </trans-unit>
        <trans-unit id="2fc0046f2b504de87c74868c9d33ea3f35f1d246" translate="yes" xml:space="preserve">
          <source>If the DTD contains an explicit value, as in: &lt;code&gt;&amp;lt;!ATTLIST OPTION selected (selected) #IMPLIED&amp;gt;&lt;/code&gt; this value from the dtd (in this case selected) will be used.</source>
          <target state="translated">If the DTD contains an explicit value, as in: &lt;code&gt;&amp;lt;!ATTLIST OPTION selected (selected) #IMPLIED&amp;gt;&lt;/code&gt; this value from the dtd (in this case selected) will be used.</target>
        </trans-unit>
        <trans-unit id="2cb72115f8155cafe91c7be2e683edb1180ccb8f" translate="yes" xml:space="preserve">
          <source>If the DTD does not contain an definition for the element, or the definition does not have an explicit value then the value in the AttributeSet will be &lt;code&gt;HTML.NULL_ATTRIBUTE_VALUE&lt;/code&gt;.</source>
          <target state="translated">If the DTD does not contain an definition for the element, or the definition does not have an explicit value then the value in the AttributeSet will be &lt;code&gt;HTML.NULL_ATTRIBUTE_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f28761ed1b352634ef38205fef3a87519af308" translate="yes" xml:space="preserve">
          <source>If the Document structure changed as result of the insertion, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to an insertion.</source>
          <target state="translated">If the Document structure changed as result of the insertion, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to an insertion.</target>
        </trans-unit>
        <trans-unit id="030cb95378711b1636920c7d0827ed5b14eb88fe" translate="yes" xml:space="preserve">
          <source>If the Document structure changed as result of the removal, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to a remove.</source>
          <target state="translated">If the Document structure changed as result of the removal, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to a remove.</target>
        </trans-unit>
        <trans-unit id="80ce8c0f1c1c211a90c8b7e66061c58778167da6" translate="yes" xml:space="preserve">
          <source>If the Document supports undo/redo, an UndoableEditEvent will also be generated.</source>
          <target state="translated">If the Document supports undo/redo, an UndoableEditEvent will also be generated.</target>
        </trans-unit>
        <trans-unit id="b0a6b6c38e66debb2926492a33b326ecee7be585" translate="yes" xml:space="preserve">
          <source>If the Drag and Drop System is unable to initiate a drag operation for some reason, the startDrag() method throws a &lt;code&gt;java.awt.dnd.InvalidDnDOperationException&lt;/code&gt; to signal such a condition. Typically this exception is thrown when the underlying platform system is either not in a state to initiate a drag, or the parameters specified are invalid.</source>
          <target state="translated">If the Drag and Drop System is unable to initiate a drag operation for some reason, the startDrag() method throws a &lt;code&gt;java.awt.dnd.InvalidDnDOperationException&lt;/code&gt; to signal such a condition. Typically this exception is thrown when the underlying platform system is either not in a state to initiate a drag, or the parameters specified are invalid.</target>
        </trans-unit>
        <trans-unit id="b36a3a37ab405a50245f8ca60d31eb1f24fccf64" translate="yes" xml:space="preserve">
          <source>If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, or the drop handler throws an exception when processing a dropped item, then this exception is rethrown.</source>
          <target state="translated">If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, or the drop handler throws an exception when processing a dropped item, then this exception is rethrown.</target>
        </trans-unit>
        <trans-unit id="b41cd91e530f36a9b0da3d978e7ece27002c8489" translate="yes" xml:space="preserve">
          <source>If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, then this exception is rethrown, in which case not all subscribers will have been issued this item.</source>
          <target state="translated">If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, then this exception is rethrown, in which case not all subscribers will have been issued this item.</target>
        </trans-unit>
        <trans-unit id="0a887cc255dc4733cf1b5653b5998661c76f2b20" translate="yes" xml:space="preserve">
          <source>If the GSSManager implementation does not support an SPI with a pluggable provider architecture it should throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.</source>
          <target state="translated">If the GSSManager implementation does not support an SPI with a pluggable provider architecture it should throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.</target>
        </trans-unit>
        <trans-unit id="ad4939c5094269e4f9d10a41688acc1a518009fa" translate="yes" xml:space="preserve">
          <source>If the JAR file has a &lt;code&gt;Main-Class&lt;/code&gt; attribute in its main manifest, its value is a legal class name, and its package is in the set of packages derived for the module, then the value is the module &lt;a href=&quot;moduledescriptor#mainClass()&quot;&gt;main class&lt;/a&gt;.</source>
          <target state="translated">If the JAR file has a &lt;code&gt;Main-Class&lt;/code&gt; attribute in its main manifest, its value is a legal class name, and its package is in the set of packages derived for the module, then the value is the module &lt;a href=&quot;moduledescriptor#mainClass()&quot;&gt;main class&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c9ace20d58b64f9f5ea681de79599cbf699eebec" translate="yes" xml:space="preserve">
          <source>If the JAR file has the attribute &quot;&lt;code&gt;Automatic-Module-Name&lt;/code&gt;&quot; in its main manifest then its value is the &lt;a href=&quot;moduledescriptor#name()&quot;&gt;module name&lt;/a&gt;. The module name is otherwise derived from the name of the JAR file.</source>
          <target state="translated">If the JAR file has the attribute &quot; &lt;code&gt;Automatic-Module-Name&lt;/code&gt; &quot; in its main manifest then its value is the &lt;a href=&quot;moduledescriptor#name()&quot;&gt;module name&lt;/a&gt;. The module name is otherwise derived from the name of the JAR file.</target>
        </trans-unit>
        <trans-unit id="bce7057e5b6fdd5c5ebdea045f965918043cd418" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; may be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; may be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver. The method &lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt; retrieves the value.</target>
        </trans-unit>
        <trans-unit id="eaed8c58c642d50f6930fd66554c7e5248239528" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver.. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver.. The method &lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt; retrieves the value.</target>
        </trans-unit>
        <trans-unit id="b6b43fc4ae5c3356c9a39c1f15c9fcd8a5ed346a" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;java.sql.Types.OTHER&lt;/code&gt;. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;java.sql.Types.OTHER&lt;/code&gt; . The method &lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt; retrieves the value.</target>
        </trans-unit>
        <trans-unit id="d8e121332002fc8657fe1d312a926bed5da0268b" translate="yes" xml:space="preserve">
          <source>If the Java implementation provides the command-line interface and you run your application by using the command line or a shortcut, use the Java application launcher option to show a splash screen. The Oracle reference implementation allows you to specify the splash screen image location with the &lt;code&gt;-splash:&lt;/code&gt; option.</source>
          <target state="translated">If the Java implementation provides the command-line interface and you run your application by using the command line or a shortcut, use the Java application launcher option to show a splash screen. The Oracle reference implementation allows you to specify the splash screen image location with the &lt;code&gt;-splash:&lt;/code&gt; option.</target>
        </trans-unit>
        <trans-unit id="540e105812b408574fe65500e02fda28804c6512" translate="yes" xml:space="preserve">
          <source>If the List allows multiple selections, then clicking on an item that is already selected deselects it. In the preceding example, only one item from the scrolling list can be selected at a time, since the second argument when creating the new scrolling list is &lt;code&gt;false&lt;/code&gt;. If the List does not allow multiple selections, selecting an item causes any other selected item to be deselected.</source>
          <target state="translated">If the List allows multiple selections, then clicking on an item that is already selected deselects it. In the preceding example, only one item from the scrolling list can be selected at a time, since the second argument when creating the new scrolling list is &lt;code&gt;false&lt;/code&gt; . If the List does not allow multiple selections, selecting an item causes any other selected item to be deselected.</target>
        </trans-unit>
        <trans-unit id="b9320150224d23795105d0b84d8ba0219f014f46" translate="yes" xml:space="preserve">
          <source>If the LoginContext's overall authentication failed (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed), then the &lt;code&gt;abort&lt;/code&gt; method for each &lt;code&gt;LoginModule&lt;/code&gt; gets invoked. In this case, the &lt;code&gt;LoginModule&lt;/code&gt; removes/destroys any authentication state originally saved.</source>
          <target state="translated">LoginContext의 전체 인증에 실패한 경우 (관련된 REQUIRED, REQUISITE, SUFFICIENT 및 OPTIONAL LoginModules가 실패한 경우) 각 &lt;code&gt;LoginModule&lt;/code&gt; 에 대한 &lt;code&gt;abort&lt;/code&gt; 메소드 가 호출됩니다. 이 경우 &lt;code&gt;LoginModule&lt;/code&gt; 은 원래 저장된 인증 상태를 제거 / 파기합니다.</target>
        </trans-unit>
        <trans-unit id="8b1ca264c954dc0a754372106598096735c9ddf1" translate="yes" xml:space="preserve">
          <source>If the MXBean is a notification emitter (i.e., it implements &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt;), both the &lt;code&gt;mxbeanInterface&lt;/code&gt; and &lt;code&gt;NotificationEmitter&lt;/code&gt; will be implemented by this proxy.</source>
          <target state="translated">MXBean가 통지 이미 터 인 경우 (즉, &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; 를&lt;/a&gt; 구현 하는 경우) &lt;code&gt;mxbeanInterface&lt;/code&gt; 와 &lt;code&gt;NotificationEmitter&lt;/code&gt; 가이 프록시에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="474328420a397c96b5f80aa5f7aa2f2d53878174" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; &lt;/a&gt; wrapping an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b43d6c84cc6fb1e54fa1b85884c057f4a6774967" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ModelMBean가 현재 등록되어있는 경우,이 메소드는 &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 을&lt;/a&gt; 랩핑하는 &lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="0961519d04df02ef89d0ae88943ca50d0c3606b3" translate="yes" xml:space="preserve">
          <source>If the Namespace URI is &lt;code&gt;null&lt;/code&gt;, it is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. This value represents no explicitly defined Namespace as defined by the &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;Namespaces in XML&lt;/a&gt; specification. This action preserves compatible behavior with QName 1.0. Explicitly providing the &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; value is the preferred coding style.</source>
          <target state="translated">If the Namespace URI is &lt;code&gt;null&lt;/code&gt; , it is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;. This value represents no explicitly defined Namespace as defined by the &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;Namespaces in XML&lt;/a&gt; specification. This action preserves compatible behavior with QName 1.0. Explicitly providing the &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; value is the preferred coding style.</target>
        </trans-unit>
        <trans-unit id="e5cc0b4b6523113fb60bbdd890e2ed587190e3eb" translate="yes" xml:space="preserve">
          <source>If the PropertyEditor doesn't honor paint requests (see isPaintable) this method should be a silent noop.</source>
          <target state="translated">PropertyEditor가 페인트 요청을 준수하지 않으면 (isPaintable 참조)이 메소드는 자동 스킵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="edc7ecb68896dc99cf3bfe6d1c68065fc233cc04" translate="yes" xml:space="preserve">
          <source>If the ProtectionDomain was constructed to a &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt;&lt;code&gt;statically bound&lt;/code&gt;&lt;/a&gt; PermissionCollection then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">ProtectionDomain이 &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt; &lt;code&gt;statically bound&lt;/code&gt; &lt;/a&gt; PermissionCollection 으로 구성된 경우 권한은 구성시 제공된 PermissionCollection에 대해서만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="a847aec68a3d5a379f34ca3fc370c158f7a9888a" translate="yes" xml:space="preserve">
          <source>If the Result is not to be written to a file, the system identifier is optional. The application may still want to provide one, however, for use in error messages and warnings, or to resolve relative output identifiers.</source>
          <target state="translated">If the Result is not to be written to a file, the system identifier is optional. The application may still want to provide one, however, for use in error messages and warnings, or to resolve relative output identifiers.</target>
        </trans-unit>
        <trans-unit id="d85ecd870d90f0c4db4acd7de59edc66dc5f937f" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorservermbean#getAddress()&quot;&gt;&lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash ( &lt;code&gt;/&lt;/code&gt; ), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorservermbean#getAddress()&quot;&gt; &lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt; &lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1eb3e9bfa37e0fb36cbe25f740fc69395067b33e" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt;&lt;code&gt;getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; and &lt;code&gt;iiop&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 의 URL 경로 부분 이 비어 있거나 단일 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 인 경우 RMI 오브젝트는 디렉토리에 바인드되지 않습니다. 대신, 이에 대한 참조는 RMIConnectorServer 주소의 URL 경로 ( &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt; &lt;code&gt;getAddress()&lt;/code&gt; &lt;/a&gt; 로 리턴 됨 ) 로 인코딩됩니다 . &lt;code&gt;rmi&lt;/code&gt; 및 &lt;code&gt;iiop&lt;/code&gt; 의 인코딩은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt; 의 패키지 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c88147c00b169cc4a7d700bc22d47ae19dc49b7" translate="yes" xml:space="preserve">
          <source>If the URL specified is &lt;code&gt;null&lt;/code&gt; or is already in the list of URLs, or if this loader is closed, then invoking this method has no effect.</source>
          <target state="translated">지정된 URL이 &lt;code&gt;null&lt;/code&gt; 이거나 이미 URL 목록에 있거나이 로더가 닫혀 있으면이 메소드를 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c0237f144da2fa8c67cb271e88ffe70a6e43f35" translate="yes" xml:space="preserve">
          <source>If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;. It is an error if they don't meet the requirements.</source>
          <target state="translated">USE_STD3_ASCII_RULES 플래그가 사용되면 ASCII 문자열이 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt; 에 대해 검사 됩니다. 요구 사항을 충족하지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="27b1988df75b26444a795d6673a2d8719150a662" translate="yes" xml:space="preserve">
          <source>If the Unicode Standard changes block names, both the previous and current names will be accepted.</source>
          <target state="translated">유니 코드 표준이 블록 이름을 변경하면 이전 이름과 현재 이름이 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4474e2c1fcf43dbf037954df628912501189beb2" translate="yes" xml:space="preserve">
          <source>If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector &lt;em&gt;only&lt;/em&gt; if the caller knows that the Vector does not contain any null elements.)</source>
          <target state="translated">여유 공간이있는 지정된 배열에 Vector가 적합하면 (즉, 배열에 Vector보다 많은 요소가있는 경우) Vector의 끝 바로 뒤에있는 배열의 요소는 null로 설정됩니다. (이것은 호출자가 Vector에 null 요소가 없음을 알고있는 경우 &lt;em&gt;에만&lt;/em&gt; Vector의 길이를 결정하는 데 유용 합니다.)</target>
        </trans-unit>
        <trans-unit id="ce465ff8cda6a5a08541bee73f2366bdc5b6d6b4" translate="yes" xml:space="preserve">
          <source>If the WebSocket's output is not already closed, the &lt;code&gt;CompletionStage&lt;/code&gt; returned by this method will be used as an indication that the WebSocket's output may be closed. The WebSocket will close its output at the earliest of completion of the returned &lt;code&gt;CompletionStage&lt;/code&gt; or invoking either of the &lt;code&gt;sendClose&lt;/code&gt; or &lt;code&gt;abort&lt;/code&gt; methods.</source>
          <target state="translated">If the WebSocket's output is not already closed, the &lt;code&gt;CompletionStage&lt;/code&gt; returned by this method will be used as an indication that the WebSocket's output may be closed. The WebSocket will close its output at the earliest of completion of the returned &lt;code&gt;CompletionStage&lt;/code&gt; or invoking either of the &lt;code&gt;sendClose&lt;/code&gt; or &lt;code&gt;abort&lt;/code&gt; methods.</target>
        </trans-unit>
        <trans-unit id="fa08a72545add7979284f586fe9352374af63dad" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../../java.desktop/java/beans/introspector#getBeanInfo(java.lang.Class)&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../../java.desktop/java/beans/introspector#getBeanInfo(java.lang.Class)&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt;, for the class of</target>
        </trans-unit>
        <trans-unit id="9f95877bd50006d6d00056ef2a51aa22bd21083c" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">위의 규칙이 값을 생성하지 않고 introspection 인 경우 &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt; 를 호출 하여</target>
        </trans-unit>
        <trans-unit id="9b05835af2c154a7c76f77377aa6c52d404cdcb8" translate="yes" xml:space="preserve">
          <source>If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.</source>
          <target state="translated">첫 번째 인수의 절대 값이 1이고 두 번째 인수가 무한하면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="fe0dcdb806d329477c57d32f9509598b1acef0b9" translate="yes" xml:space="preserve">
          <source>If the accelerator is hidden, the method returns &lt;code&gt;true&lt;/code&gt;, otherwise, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">If the accelerator is hidden, the method returns &lt;code&gt;true&lt;/code&gt; , otherwise, returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e03f3411418a033b6bfa2f883c240355cb3f69a7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6afccfd8739251584afc0914039b51c90ada53f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66516904fde9701dc7f61bc426819fb4f146f708" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e52e55025286a627afde1b1d2b384ea2bee735b" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5601c43da232fcabd407827972e1da20bb1375e" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="69341c18d84e15fb20d184c341ea1d0d7b8cbcda" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0773f07cee5964ddff6a0726a10424e6fde400aa" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6eb467bff49959d09e05c7bab75146704c0dc28d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc7b37b752547334d50d87c5179ebe5f7826e35" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4a7f713f21116ad3b228e0623aa03e2b62a6679" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91611fb9a517d38eefd5a99f44bd0d85a21d0920" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5728c1fd6c7474b8e5ee24332d657e8c59b795d7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="06d370e1cbaab2bb12cd8d0300073053596d5bf6" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="290eeb3f1f54f16b09955c88d8cfd90d14b9557d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0dcd5ef32e41f4bca014a916ec5e3e0e6b1fab7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00bbc10814534bf0219172f193911a9aeadd7e16" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8e64dea02dd187ab7473bf716270a883a77afdc" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2cd031f75c6a92efb253dc0527bb3d0bd986894f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3b5ff8c69ea26957c669b0830c3787c984d9d074" translate="yes" xml:space="preserve">
          <source>If the action performed in your &lt;code&gt;run&lt;/code&gt; method could throw a &quot;checked&quot; exception (those listed in the &lt;code&gt;throws&lt;/code&gt; clause of a method), then you need to use the &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; interface instead of the &lt;code&gt;PrivilegedAction&lt;/code&gt; interface:</source>
          <target state="translated">작업이 수행되면 &lt;code&gt;run&lt;/code&gt; 던질 수있는 방법 A 예외를 (에 나열된 사람들은 &quot;확인&quot; &lt;code&gt;throws&lt;/code&gt; 방법의 절을), 당신은 사용할 필요가 &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 와의 대신의 인터페이스 &lt;code&gt;PrivilegedAction&lt;/code&gt; 인터페이스를 :</target>
        </trans-unit>
        <trans-unit id="1c19e93235c53e902185c8c29dee0714c658ee6f" translate="yes" xml:space="preserve">
          <source>If the action was registered via &lt;code&gt;registerKeyboardAction&lt;/code&gt;, then the command string passed in (&lt;code&gt;null&lt;/code&gt; will be used if &lt;code&gt;null&lt;/code&gt; was passed in).</source>
          <target state="translated">If the action was registered via &lt;code&gt;registerKeyboardAction&lt;/code&gt; , then the command string passed in ( &lt;code&gt;null&lt;/code&gt; will be used if &lt;code&gt;null&lt;/code&gt; was passed in).</target>
        </trans-unit>
        <trans-unit id="f8b6f3a11b20582c114df00bdb40a1e0e0cbd27f" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an</source>
          <target state="translated">액션의 &lt;code&gt;run&lt;/code&gt; 메소드가</target>
        </trans-unit>
        <trans-unit id="6baa6ffe1bf64066619e4375881dfdc0f383d936" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an (unchecked) exception, it will propagate through this method.</source>
          <target state="translated">액션의 &lt;code&gt;run&lt;/code&gt; 메소드가 (확인되지 ​​않은) 예외를 throw하면이 메소드를 통해 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="81ae8e4005f2526ae09ac862718dd7fa76cfe92e" translate="yes" xml:space="preserve">
          <source>If the activation group for the object's group descriptor does not yet exist, the activator starts an &lt;code&gt;ActivationInstantiator&lt;/code&gt; executing (by spawning a child process, for example). When the activator receives the activation group's call back (via the &lt;code&gt;ActivationSystem&lt;/code&gt;'s &lt;code&gt;activeGroup&lt;/code&gt; method) specifying the activation group's reference, the activator can then invoke that activation instantiator's &lt;code&gt;newInstance&lt;/code&gt; method to forward each pending activation request to the activation group and return the result (a marshalled remote object reference, a stub) to the caller.</source>
          <target state="translated">If the activation group for the object's group descriptor does not yet exist, the activator starts an &lt;code&gt;ActivationInstantiator&lt;/code&gt; executing (by spawning a child process, for example). When the activator receives the activation group's call back (via the &lt;code&gt;ActivationSystem&lt;/code&gt; 's &lt;code&gt;activeGroup&lt;/code&gt; method) specifying the activation group's reference, the activator can then invoke that activation instantiator's &lt;code&gt;newInstance&lt;/code&gt; method to forward each pending activation request to the activation group and return the result (a marshalled remote object reference, a stub) to the caller.</target>
        </trans-unit>
        <trans-unit id="102269f064fade95ae910ba7bdf983251013c399" translate="yes" xml:space="preserve">
          <source>If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up an ephemeral port and a valid local address to bind the socket.</source>
          <target state="translated">주소가 &lt;code&gt;null&lt;/code&gt; 인 경우 시스템은 임시 포트와 유효한 로컬 주소를 선택하여 소켓을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="deed334073f68c6d00e85a8098ad4ebaa1319066" translate="yes" xml:space="preserve">
          <source>If the agent cannot be started (for example, because the agent class cannot be loaded, or because the agent class does not have an appropriate &lt;code&gt;premain&lt;/code&gt; method), the JVM will abort. If a &lt;code&gt;premain&lt;/code&gt; method throws an uncaught exception, the JVM will abort.</source>
          <target state="translated">If the agent cannot be started (for example, because the agent class cannot be loaded, or because the agent class does not have an appropriate &lt;code&gt;premain&lt;/code&gt; method), the JVM will abort. If a &lt;code&gt;premain&lt;/code&gt; method throws an uncaught exception, the JVM will abort.</target>
        </trans-unit>
        <trans-unit id="3bdc279bcf6c5ee605cac5004f25fb4a4dd94ae8" translate="yes" xml:space="preserve">
          <source>If the agent class does not implement this method then the JVM will attempt to invoke:</source>
          <target state="translated">If the agent class does not implement this method then the JVM will attempt to invoke:</target>
        </trans-unit>
        <trans-unit id="e4c80757c9e2ecb6b75dc0a37636c30cb9490032" translate="yes" xml:space="preserve">
          <source>If the algorithm is the</source>
          <target state="translated">알고리즘이</target>
        </trans-unit>
        <trans-unit id="80ea754a698145f128fdf52efea523a98452381c" translate="yes" xml:space="preserve">
          <source>If the alpha component of the requested background color is less than &lt;code&gt;1.0f&lt;/code&gt;, and any of the above conditions are not met, the background color of this window will not change, the alpha component of the given background color will not affect the mode of operation for this window, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt;
 IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the alpha component of the requested background color is less than &lt;code&gt;1.0f&lt;/code&gt; , and any of the above conditions are not met, the background color of this window will not change, the alpha component of the given background color will not affect the mode of operation for this window, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt; IllegalComponentStateException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="0e8d5a3e745f1450eac261edbc32910b4882938f" translate="yes" xml:space="preserve">
          <source>If the amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must use the ISO chronology.</source>
          <target state="translated">금액이 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인 경우 ISO 연대기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="88b1d50bbaec9f5487c27e8e4cb2386eb42847f9" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;
 TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get(int)&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">주어진 타임 스탬프에서 시간을 절약해야하는 경우이 &lt;code&gt; TimeZone&lt;/code&gt; 및 타임 스탬프를 사용 하여 &lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt; 을 구성하고 &lt;a href=&quot;calendar#get(int)&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="4d740232e114f21d31c73ca4687c4057fb29ccd4" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get-int-&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">지정된 타임 스탬프에서 절약 시간이 필요한 경우이 &lt;code&gt;TimeZone&lt;/code&gt; 과 타임 스탬프를 사용 하여 &lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt; 를 구성하고 &lt;a href=&quot;calendar#get-int-&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; ( Calendar.DST_OFFSET &lt;code&gt;)&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="08afeee4bde07dab89f440c39fce86a0eb463b56" translate="yes" xml:space="preserve">
          <source>If the annotation &lt;code&gt;@Documented&lt;/code&gt; is present on the declaration of an annotation type</source>
          <target state="translated">주석 경우 &lt;code&gt;@Documented&lt;/code&gt; 는 주석 형의 선언에 존재</target>
        </trans-unit>
        <trans-unit id="272549f61fd737d1e73b2c36c4aa004c00079132" translate="yes" xml:space="preserve">
          <source>If the answer is NO, go to the next step.</source>
          <target state="translated">대답이 아니오이면 다음 단계로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f57b79608f2a3ff0ec11e483aaaa3a019d8c2b5b" translate="yes" xml:space="preserve">
          <source>If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; exception.</source>
          <target state="translated">대답이 NO이면 &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="434e3dee0acd3560230fa30595feca5a213bbce4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 및 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="a1eb85cb2614bd41f0d6af38673aa7528bca07f4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="de83ee4eae564494ffc414cfaf8cc18d47b2bed1" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="56a7594c327855897bea9f06e5423ff72ccb1d7b" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it.</source>
          <target state="translated">대답이 예이면 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="160782cdb54c84087be65e0efddfac392e283c77" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate this class, for whose mode and padding scheme default values (as supplied by the provider) are used.</source>
          <target state="translated">대답이 YES 인 경우,이 클래스를 인스턴스화하십시오 (제공자가 제공 한 모드 및 패딩 구성표 기본값이 사용됨).</target>
        </trans-unit>
        <trans-unit id="5fe99f49bc1a1090e02dd6efd4b8d8fd6a67f30a" translate="yes" xml:space="preserve">
          <source>If the application does not register a DTD handler, all DTD events reported by the SAX parser will be silently ignored (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">애플리케이션이 DTD 핸들러를 등록하지 않으면 SAX 파서가보고 한 모든 DTD 이벤트가 자동으로 무시됩니다 (이는 HandlerBase에서 구현하는 기본 동작입니다).</target>
        </trans-unit>
        <trans-unit id="1c521b3dbb8b44d5fe2bd6f0ccfd70ada67afc00" translate="yes" xml:space="preserve">
          <source>If the application does not register a DTD handler, all DTD events reported by the SAX parser will be silently ignored.</source>
          <target state="translated">애플리케이션이 DTD 핸들러를 등록하지 않으면 SAX 파서가보고 한 모든 DTD 이벤트가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1995f916cc7b7a0f6ced6ac9ec5d117bf0b42738" translate="yes" xml:space="preserve">
          <source>If the application does not register a content handler, all content events reported by the SAX parser will be silently ignored.</source>
          <target state="translated">애플리케이션이 컨텐츠 핸들러를 등록하지 않으면 SAX 파서가보고 한 모든 컨텐츠 이벤트가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a62c70d6bc1bda91dda6bd20cde5a3d284087c97" translate="yes" xml:space="preserve">
          <source>If the application does not register a document handler, all document events reported by the SAX parser will be silently ignored (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">애플리케이션이 문서 핸들러를 등록하지 않으면 SAX 파서가보고하는 모든 문서 이벤트가 자동으로 무시됩니다 (이는 HandlerBase에서 구현하는 기본 동작입니다).</target>
        </trans-unit>
        <trans-unit id="5cbd83d12c880c04a3ca2b1f0acd010cea0950ae" translate="yes" xml:space="preserve">
          <source>If the application does not register an entity resolver, the SAX parser will resolve system identifiers and open connections to entities itself (this is the default behaviour implemented in HandlerBase).</source>
          <target state="translated">응용 프로그램이 엔터티 확인자를 등록하지 않으면 SAX 파서는 시스템 식별자를 확인하고 엔터티 자체에 대한 연결을 엽니 다 (이는 HandlerBase에서 구현되는 기본 동작).</target>
        </trans-unit>
        <trans-unit id="a8af630e8d72ae977eff66966545a162b07a84de" translate="yes" xml:space="preserve">
          <source>If the application does not register an entity resolver, the XMLReader will perform its own default resolution.</source>
          <target state="translated">응용 프로그램이 엔티티 확인자를 등록하지 않으면 XMLReader는 자체 기본 확인을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0b84de5172675bfd46a10466b2f6619156504747" translate="yes" xml:space="preserve">
          <source>If the application does not register an error event handler, all error events reported by the SAX parser will be silently ignored, except for fatalError, which will throw a SAXException (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">응용 프로그램이 오류 이벤트 처리기를 등록하지 않으면 SAX 파서가보고 한 모든 오류 이벤트가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc77f1bc697f56ce88184dfc957115a66d88b958" translate="yes" xml:space="preserve">
          <source>If the application does not register an error handler, all error events reported by the SAX parser will be silently ignored; however, normal processing may not continue. It is highly recommended that all SAX applications implement an error handler to avoid unexpected bugs.</source>
          <target state="translated">애플리케이션이 오류 처리기를 등록하지 않으면 SAX 파서에서보고 한 모든 오류 이벤트가 자동으로 무시됩니다. 그러나 정상적인 처리가 계속되지 않을 수 있습니다. 예기치 않은 버그를 방지하기 위해 모든 SAX 응용 프로그램에서 오류 처리기를 구현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="968a78947275cffe7a67b6a953d091962ffdb8ec" translate="yes" xml:space="preserve">
          <source>If the application has previously set up an instance of &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; as the stream handler factory, then the &lt;code&gt;createURLStreamHandler&lt;/code&gt; method of that instance is called with the protocol string as an argument to create the stream protocol handler.</source>
          <target state="translated">애플리케이션이 이전 에 스트림 핸들러 팩토리로 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 의 인스턴스를 설정 한 경우 해당 인스턴스의 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 메소드가 스트림 문자열 핸들러를 작성하기위한 인수로 프로토콜 문자열과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2070d70078ec2db5e6d48447de6438828f0279ed" translate="yes" xml:space="preserve">
          <source>If the application has set up a content handler factory instance using the &lt;code&gt;setContentHandlerFactory&lt;/code&gt; method, the &lt;code&gt;createContentHandler&lt;/code&gt; method of that instance is called with the content type as an argument; the result is a content handler for that content type.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;setContentHandlerFactory&lt;/code&gt; 메소드를 사용하여 컨텐츠 핸들러 팩토리 인스턴스를 설정 한 경우 &lt;code&gt;createContentHandler&lt;/code&gt; 메소드가 컨텐츠 유형을 인수로 사용하여 호출됩니다. 결과는 해당 컨텐츠 유형에 대한 컨텐츠 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="91fdcd973932e65f09e9bdaebd48fb198c503271" translate="yes" xml:space="preserve">
          <source>If the application has specified a server socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">응용 프로그램에서 서버 소켓 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출되어 실제 소켓 구현을 작성합니다. 그렇지 않으면 &quot;일반&quot;소켓이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="221a9611027772cf1f0b3bdc427ffc5e66a9af4e" translate="yes" xml:space="preserve">
          <source>If the application has specified a socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">애플리케이션이 소켓 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출되어 실제 소켓 구현을 작성합니다. 그렇지 않으면 &quot;일반&quot;소켓이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="242a93fe7324bd12593bab009aad2ea56baf1bef" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;#closeOutbound()&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">애플리케이션이 &lt;a href=&quot;#closeOutbound()&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt; 를 호출하여 닫기 프로세스를 시작한 경우 일부 상황에서는 개시자가 피어의 해당 닫기 메시지를 기다릴 필요가 없습니다. ( 종료 경고 대기에 대한 자세한 내용 은 TLS 사양 ( &lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt; ) 의 섹션 7.2.1을 참조하십시오 .) 이러한 경우이 메서드를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b8dff9cb695d7cf445c13c7a8630fbe3ce30315" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">응용 프로그램이 &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt; 를 호출하여 종료 프로세스를 시작한 경우, 경우에 따라 초기자가 피어의 해당 닫기 메시지를 기다릴 필요가 없습니다. ( 클로저 경보 대기에 대한 자세한 정보 는 TLS 스펙 ( &lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt; )의 7.2.1 섹션을 참조하십시오 .) 이러한 경우이 메소드를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b49e74988c341dbee66d98c70300f05b412e8ad" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set it with the setEncoding method.</source>
          <target state="translated">응용 프로그램이 바이트 스트림의 문자 인코딩을 알고 있으면 setEncoding 메소드로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="85ff560af776424016a6f3b941fc1f9585879f10" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set the encoding attribute. Setting the encoding in this way will override any encoding specified in an XML declaration in the data.</source>
          <target state="translated">애플리케이션이 바이트 스트림의 문자 인코딩을 알고있는 경우 인코딩 속성을 설정해야합니다. 이러한 방식으로 인코딩을 설정하면 데이터의 XML 선언에 지정된 인코딩이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7cfd6e9f0bb81bae2991028adadfb572b93731b0" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the object pointed to by the system identifier, it can register the encoding using the setEncoding method.</source>
          <target state="translated">응용 프로그램이 시스템 식별자가 가리키는 개체의 문자 인코딩을 알고있는 경우 setEncoding 메서드를 사용하여 인코딩을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059304a89c9e8193f2d1a44c913f61a85c77d63d" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the object pointed to by the system identifier, it can set the encoding using the &lt;code&gt;encoding&lt;/code&gt; attribute.</source>
          <target state="translated">응용 프로그램이 시스템 식별자가 가리키는 개체의 문자 인코딩을 알고있는 경우 &lt;code&gt;encoding&lt;/code&gt; 속성을 사용하여 인코딩을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a649bc726d746209da5a8d07601c510d8a5af68b" translate="yes" xml:space="preserve">
          <source>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</source>
          <target state="translated">응용 프로그램이 다른 유형의 예외를 통과해야하는 경우 해당 예외를 SAXException 또는 SAXException에서 파생 된 예외로 래핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff002a2eb7163e0d2f905c4e93d3942c2cb282be" translate="yes" xml:space="preserve">
          <source>If the appropriate stub class could not be found, or if the stub class could not be loaded, or if a problem occurs creating the stub instance, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt;&lt;code&gt;StubNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">적절한 스텁 클래스를 찾을 수 없거나 스텁 클래스를로드 할 수없는 경우 또는 스텁 인스턴스 생성에 문제가 발생하면 &lt;a href=&quot;../stubnotfoundexception&quot;&gt; &lt;code&gt;StubNotFoundException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9908f3b7f0fcd38e518a64cda27a8bcf7af02eae" translate="yes" xml:space="preserve">
          <source>If the argument</source>
          <target state="translated">인수가</target>
        </trans-unit>
        <trans-unit id="a274d22f689f758fbbc17c1c36e25f56726e9e93" translate="yes" xml:space="preserve">
          <source>If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo(java.util.Formatter,int,int,int)&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 을&lt;/a&gt; 구현하면 해당 &lt;a href=&quot;formattable#formatTo(java.util.Formatter,int,int,int)&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt; 메서드가 호출됩니다. 그렇지 않으면 인수의 &lt;code&gt;toString()&lt;/code&gt; 메서드 를 호출하여 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="18ba07a0dacca161f919bf38b3942c5cbf0de7b4" translate="yes" xml:space="preserve">
          <source>If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored.</source>
          <target state="translated">인수 색인이 패턴 문자열에서 둘 이상의 형식 요소에 사용되는 경우, 모든 형식 요소에 새 형식이 사용됩니다. 패턴 문자열의 형식 요소에 인수 인덱스를 사용하지 않으면 새 형식이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="201ffc4148225e00891b41aafa471a7bc0ae4e31" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.</source>
          <target state="translated">인수가 &amp;plusmn; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; 인 경우 결과는 2 &lt;sup&gt;971&lt;/sup&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0500f3687980d0c066085bfc637859d5a0f94f45" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.</source>
          <target state="translated">인수가 &amp;plusmn; 경우 &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; , 결과는 2와 동일하다 &lt;sup&gt;(104)&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="e418b56eeca30ec55767a713e51154185f73b688" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7f800000&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0x7f800000&lt;/code&gt; 이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="cc33fb1734d8e8472093718dadfa691efa944850" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 인 경우 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="67ad4ce5c4db05b329a5cf076b7ace8df7e07d24" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xff800000&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0xff800000&lt;/code&gt; 이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="44b83a1db6251fafa0226412a16d0a5aa743a573" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 인 경우 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="d97807e539c09446e4934a8ca25166f2ed929f7e" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 이면 결과는 &quot; &lt;code&gt;false&lt;/code&gt; &quot;입니다. 인수가 &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 이면 결과는 &lt;a href=&quot;../lang/string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 문자열 입니다. 그렇지 않으면 결과는 &quot; &lt;code&gt;true&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="970f258bf10d8b6db35da86a6962bea7e6f056c5" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 의 경우, 결과는 &quot; &lt;code&gt;false&lt;/code&gt; &quot;입니다. 인수가 &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 인 경우 결과는 &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt; 반환 한 문자열 입니다. 그렇지 않으면 결과는 &quot; &lt;code&gt;true&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4acdffc199e6f4f9b1d96e0f15f8a4c625bb7edd" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;null&lt;/code&gt;&quot;. If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 인 경우 결과는 &quot; &lt;code&gt;null&lt;/code&gt; &quot;입니다. 인수가 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 을&lt;/a&gt; 구현하면 해당 &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 그렇지 않으면 인수의 &lt;code&gt;toString()&lt;/code&gt; 메소드 를 호출하여 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="fe94a89675405323875ef4ec6ff361112380225e" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">인수가 NaN이거나 무한대 또는 양수 0 또는 음수 0이면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f1490c0a73a4bdc7beee59aa0b2e8886fa1ac76" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 무한대이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="e8d658cc42466718800cf906b23004b8262a330a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt;&lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">인수가 NaN 또는 무한이면 결과는 &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt; &lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1입니다.</target>
        </trans-unit>
        <trans-unit id="cc7b80c9b72e91dff938c54c51871d14f95c81ca" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt;&lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">인수가 NaN 또는 무한이면 결과는 &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt; &lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1입니다.</target>
        </trans-unit>
        <trans-unit id="745e5106ba9365f2bce0539ab810d8720f71215b" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or its absolute value is greater than 1, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 절대 값이 1보다 크면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="07291af92544374b52ef8f433433f39f1dbb80d9" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than -1, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 -1보다 작은 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="13a256cb6eee91493a6f005cfe5cd4ae37f9697f" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than zero, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 0보다 작은 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="31b76fec8c3bc86ab1662b04d7bb45867ec9f9d7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is 0.</source>
          <target state="translated">인수가 NaN이면 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="3aa89491f3556c271cee0931546f3e5660ec7ac7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7fc00000&lt;/code&gt;.</source>
          <target state="translated">인수가 NaN이면 결과는 &lt;code&gt;0x7fc00000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a83c5a6baaa1bd2366e8865b925beaeea4e26b42" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7ff8000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 NaN이면 결과는 &lt;code&gt;0x7ff8000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="118d734407198a907583b63ea2fc64d7c89b2c28" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="e064879a9427f94b4430bb8b2822c39d482f8755" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the &lt;code&gt;long&lt;/code&gt; integer representing the actual NaN value. Unlike the &lt;code&gt;doubleToLongBits&lt;/code&gt; method, &lt;code&gt;doubleToRawLongBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">인수가 NaN이면 결과는 실제 NaN 값을 나타내는 &lt;code&gt;long&lt;/code&gt; 정수입니다. &lt;code&gt;doubleToLongBits&lt;/code&gt; 메서드 와 달리 &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 는 NaN을 인코딩하는 모든 비트 패턴을 단일 &quot;표준&quot;NaN 값으로 축소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bca2d981cbc0638a09fdc8f8c3691bf1f893da00" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the integer representing the actual NaN value. Unlike the &lt;code&gt;floatToIntBits&lt;/code&gt; method, &lt;code&gt;floatToRawIntBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">인수가 NaN 인 경우 결과는 실제 NaN 값을 나타내는 정수입니다. &lt;code&gt;floatToIntBits&lt;/code&gt; 메서드 와 달리 &lt;code&gt;floatToRawIntBits&lt;/code&gt; 는 NaN을 인코딩하는 모든 비트 패턴을 단일 &quot;정식&quot;NaN 값으로 축소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db8eab43bb6026b1e9b4780ecae1f1526f2beff3" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the string &quot;&lt;code&gt;NaN&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 NaN이면 결과는 문자열 &quot; &lt;code&gt;NaN&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c12f1031f1e9c83194d8ac6506dee76af527571a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, then the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="d554a647f92a4934769f60285a8988bfd2109472" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;a href=&quot;font/glyphvector&quot;&gt;&lt;code&gt;GlyphVector&lt;/code&gt;&lt;/a&gt;, then the &lt;code&gt;GlyphVector&lt;/code&gt; object already contains the appropriate font-specific glyph codes with explicit coordinates for the position of each glyph.</source>
          <target state="translated">인수가 &lt;a href=&quot;font/glyphvector&quot;&gt; &lt;code&gt;GlyphVector&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;GlyphVector&lt;/code&gt; 객체에는 각 글리프의 위치에 대한 명시 적 좌표가있는 적절한 글꼴 별 글리프 코드가 이미 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33084cbb24930f6a9f5be37e387df07eb5022040" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;code&gt;String&lt;/code&gt;, then the current &lt;code&gt;Font&lt;/code&gt; in the &lt;code&gt;Graphics2D&lt;/code&gt; context is asked to convert the Unicode characters in the &lt;code&gt;String&lt;/code&gt; into a set of glyphs for presentation with whatever basic layout and shaping algorithms the font implements.</source>
          <target state="translated">인수가 있으면 &lt;code&gt;String&lt;/code&gt; 다음은 현재 &lt;code&gt;Font&lt;/code&gt; 에서 &lt;code&gt;Graphics2D&lt;/code&gt; 컨텍스트에서 유니 코드 문자로 변환하도록 요청 &lt;code&gt;String&lt;/code&gt; 어떤 기본 레이아웃과 알고리즘을 폰트 구현을 형성하여 프리젠 테이션을 위해 상형 문자의 집합으로.</target>
        </trans-unit>
        <trans-unit id="5a923aa0ff948589bbbea2c5c98edba0c8041581" translate="yes" xml:space="preserve">
          <source>If the argument is already a localized stream, it may be returned as the result.</source>
          <target state="translated">인수가 이미 지역화 된 스트림 인 경우 결과로 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e184dfc2be8d0cd0cc281824d50fb9ce2efa94b1" translate="yes" xml:space="preserve">
          <source>If the argument is an &lt;a href=&quot;../../../java.base/java/text/attributedcharacteriterator&quot;&gt;&lt;code&gt;AttributedCharacterIterator&lt;/code&gt;&lt;/a&gt;, the iterator is asked to convert itself to a &lt;a href=&quot;font/textlayout&quot;&gt;&lt;code&gt;TextLayout&lt;/code&gt;&lt;/a&gt; using its embedded font attributes. The &lt;code&gt;TextLayout&lt;/code&gt; implements more sophisticated glyph layout algorithms that perform Unicode bi-directional layout adjustments automatically for multiple fonts of differing writing directions.</source>
          <target state="translated">인수가 &lt;a href=&quot;../../../java.base/java/text/attributedcharacteriterator&quot;&gt; &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; &lt;/a&gt; 인 경우 반복자는 자신을&lt;a href=&quot;font/textlayout&quot;&gt; &lt;code&gt;TextLayout&lt;/code&gt; &lt;/a&gt;포함 된 글꼴 속성을 사용하여 TextLayout. &lt;code&gt;TextLayout&lt;/code&gt; 구현 기입 방향이 다른 복수의 폰트를 자동으로 유니 코드 쌍방향 레이아웃 조정을 실행하는보다 정교한 그래프 레이아웃 알고리즘.</target>
        </trans-unit>
        <trans-unit id="e9264d5fd055500aa5c8726a54e413523844cbaf" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7f800001&lt;/code&gt; through &lt;code&gt;0x7fffffff&lt;/code&gt; or in the range &lt;code&gt;0xff800001&lt;/code&gt; through &lt;code&gt;0xffffffff&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;0x7f800001&lt;/code&gt; ~ &lt;code&gt;0x7fffffff&lt;/code&gt; 범위 또는 &lt;code&gt;0xff800001&lt;/code&gt; ~ &lt;code&gt;0xffffffff&lt;/code&gt; 범위의 값 이면 결과는 NaN입니다. Java가 제공하는 IEEE 754 부동 소수점 연산은 비트 패턴이 다른 동일한 유형의 두 NaN 값을 구별 할 수 없습니다. NaN의 고유 값은 &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; 메소드를 사용하여 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e09c36577e890868103778c6cad080360d9fef25" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; through &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; or in the range &lt;code&gt;0xfff0000000000001L&lt;/code&gt; through &lt;code&gt;0xffffffffffffffffL&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; - &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; 범위 또는 &lt;code&gt;0xfff0000000000001L&lt;/code&gt; - &lt;code&gt;0xffffffffffffffffL&lt;/code&gt; 범위의 값 이면 결과는 NaN입니다. Java가 제공하는 IEEE 754 부동 소수점 연산은 비트 패턴이 다른 동일한 유형의 두 NaN 값을 구별 할 수 없습니다. NaN의 고유 한 값은 &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; 메소드를 사용하여 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="108d000cc41c657851b0d27f0a1ac78cf5e4ee70" translate="yes" xml:space="preserve">
          <source>If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for integer</source>
          <target state="translated">정수 의 인수가 &lt;sup&gt;&lt;i&gt;10n 인&lt;/i&gt;&lt;/sup&gt; 경우</target>
        </trans-unit>
        <trans-unit id="65efe2e81fa8d1ba670e4b1992ae1775f4b62a76" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, the result is positive infinity.</source>
          <target state="translated">인수가 무한한 경우 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="336889ed81a3144be451220af338acfcbb6c9ba3" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is an infinity with the same sign as the argument.</source>
          <target state="translated">인수가 무한하면 결과는 인수와 같은 부호를 가진 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="4691c35189f88af211fb42ae9607c8ae123c02d6" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is positive infinity.</source>
          <target state="translated">인수가 무한하면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ec376818cb2e255655d1881f54f64a5f81a51e7b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이거나 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 값보다 작거나 같은 값이면 결과는 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5a08fe9d371940e4f9d92ad57a75f846bb063ec2" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이거나 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 값보다 작거나 같은 경우 결과는 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f1c38692773d898bd9643813b94e0ae1993eb556" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xff800000&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대 &lt;code&gt;0xff800000&lt;/code&gt; 결과는 0xff800000 입니다.</target>
        </trans-unit>
        <trans-unit id="3bb987ea3c954538087573e2f402d9fdf305369d" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6a939ea1df7c37cb72e17d44d1754a7325b1cce" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is negative infinity.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ba927f3f79a46354d9209dcd811d86b8a661221b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is -1.0.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 -1.0입니다.</target>
        </trans-unit>
        <trans-unit id="20f8e0486c54aeb853e7804b4611ce1c56a73d1b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is &lt;code&gt;-1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 &lt;code&gt;-1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9e3b1cc495f1cc8092755d393fd54a8be9e0bff" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is positive zero.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="d08b29e2ea8c8a74d04b752def011f9cda30c497" translate="yes" xml:space="preserve">
          <source>If the argument is negative one, then the result is negative infinity.</source>
          <target state="translated">인수가 음수 인 경우 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ad3d4a3e9566e2c0df155d95c37161c79599330f" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이거나 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 값보다 크거나 같은 값 이면 결과는 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eff50c12018038db62b68855eb707df57d7cd5ae" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이거나 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값보다 크거나 같은 값 이면 결과는 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a13758d0f976c89623e38e841da2cbc62912670" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7f800000&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;0x7f800000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c05eefbf6b8959edbbea1c8b9a02322d8935ca7" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf429a21c2dc34b66e4269078332483b3641ead6" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="31b9de6b24ff8d5ffbebf56f3f1cecc792456081" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is &lt;code&gt;+1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;+1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f87ee2c0e3d173098373d3990b3903acb3bfadf9" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="96dab47247ae7e1056e56799ef0665e4ab651c26" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative infinity, then the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이거나 음의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="78148cd34a5b7680af0ed6412b4903e44701b46c" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Double.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양수 또는 음수 0이면 결과는 &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c4032eb755d363cebfbea8af5b3c0b4a94596cf" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Float.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양수 또는 음수 0이면 결과는 &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f15f3f96dc5106b38775f4ba76d739b00aa110dd" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, the result is positive zero.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="0553928b250b89074ae0163da0309f356dd0aea5" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is negative infinity.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="f8ad8830694a6f7c940aad7bd91216f8c775287b" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="11b6940276c4e767ac8a361ca5f19636e270c2d9" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt;&lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">인수가 0이거나 비정규이면 결과는 &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt; &lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="3905704a484368c3992190c17ec803f5c9734872" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt;&lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">인수가 0이거나 비정규이면 결과는 &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt; &lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="65b605eea787dfcd26a427a347ea4ad7abd516d5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="82de080d3a1d56fdbaf695d271e223d79695fa9d" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="368d7952fccceed4084cffb62407a857e1140ff5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="e43dae92e6e1f445b98367ed57735c6219a0d0f9" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="5db3ba052bf056b3adf9c2be7e6188d33a4e952e" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8d665f9570f8b5f180ad4bdb572f1e1aab98bad" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is a zero with the same sign as the argument.</source>
          <target state="translated">인수가 0이면 결과는 인수와 같은 부호를 갖는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d1f82cc652138d856ee89a85be827d630ca9f31c" translate="yes" xml:space="preserve">
          <source>If the argument value is already equal to a mathematical integer, then the result is the same as the argument.</source>
          <target state="translated">인수 값이 이미 수학 정수와 같으면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="38b3adaab247759b54b2aa2e88f5b5ce2609340f" translate="yes" xml:space="preserve">
          <source>If the argument value is less than zero but greater than -1.0, then the result is negative zero.</source>
          <target state="translated">인수 값이 0보다 작지만 -1.0보다 큰 경우 결과는 음의 0입니다.</target>
        </trans-unit>
        <trans-unit id="acfd94f24240c24943c8ec432b5700b6212aa09a" translate="yes" xml:space="preserve">
          <source>If the argument,</source>
          <target state="translated">인수가</target>
        </trans-unit>
        <trans-unit id="d16beeb819e4ac6862b921fde8350a257a9f5ad7" translate="yes" xml:space="preserve">
          <source>If the arguments are inconsistent then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. The necessary consistent argument conditions are:</source>
          <target state="translated">인수가 일치하지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. 필요한 일관된 인수 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c14cc5c25518873c4d133fdea60caf8bcd4ae3d" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that reference equal &lt;code&gt;DataFlavor&lt;/code&gt;s, this method will establish new mappings for the first of those elements and ignore the rest of them.</source>
          <target state="translated">배열에 동일한 것을 참조하는 여러 요소가 포함 된 경우 &lt;code&gt;DataFlavor&lt;/code&gt; 경우이 메서드는 해당 요소 중 첫 번째 요소에 대해 새 매핑을 설정하고 나머지 요소는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="cfbcde248a8dade1dd31dd66e1705de02944b301" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that reference equal &lt;code&gt;String&lt;/code&gt; natives, this method will establish new mappings for the first of those elements and ignore the rest of them.</source>
          <target state="translated">배열에 동일한 것을 참조하는 여러 요소가 포함 된 경우 &lt;code&gt;String&lt;/code&gt; 네이티브 경우이 메서드는 해당 요소 중 첫 번째 요소에 대해 새 매핑을 설정하고 나머지 요소는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="9501d16613e807e8eab597eb061cf001422db435" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 요소 유형이 원래 대상의 해당 인수 유형과 다른 경우 원래 대상은 다음을 호출하는 것처럼 배열 요소를 직접 가져 오도록 조정됩니다. &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 을 오도록 조정&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7b613ad1d7b1ad953ca4724e10cf0c2ca14a21e9" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 요소 유형이 원래 대상의 해당 인수 유형과 다른 경우, 원래 대상은 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 호출로 배열 요소를 직접 가져 오도록 조정 됩니다.</target>
        </trans-unit>
        <trans-unit id="50771cd3c005f627dc72ab8c8e5ba994b9a7354f" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 유형이 원래 대상의 최종 인수 유형과 다른 경우 원래 대상은 다음을 호출하는 것처럼 배열 유형을 직접 가져 오도록 조정됩니다. &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 을&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8c623454e44ca641a6c552859181a701097e3dda" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 유형이 원래 대상의 최종 인수 유형과 다른 경우 원래 대상은 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 을&lt;/a&gt; 호출하는 것처럼 배열 유형을 직접 가져 오도록 조정 됩니다.</target>
        </trans-unit>
        <trans-unit id="4602014772a49fdb1a8fa2feb07dd113fad7727a" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../../java.base/java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">이 클래스를로드하려고하면 &lt;a href=&quot;../../../../java.base/java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; 을&lt;/a&gt;하면 목록의 다음 요소에서 핸들러 검색이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="4389eb5f009bdfaeb30b67c701fdcfe35730fb30" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">이 클래스를로드하려고하면 &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; &lt;/a&gt; 이 생성 되면 핸들러 검색은 목록의 다음 요소로 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="27bcadd9ba9512f4ef4c571a9d187c3039f12ed0" translate="yes" xml:space="preserve">
          <source>If the attribute is not set, or is null, then any class is deemed acceptable.</source>
          <target state="translated">속성이 설정되지 않았거나 null이면 모든 클래스가 허용되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="21f75ebcde7181c9e3879b54dc6999c343b75757" translate="yes" xml:space="preserve">
          <source>If the attribute name has a namespace prefix in the document, the application must include the prefix here.</source>
          <target state="translated">속성 이름에 문서에 네임 스페이스 접두사가있는 경우 애플리케이션은 여기에 접두사를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="318b1b00162c20584c04e29ce092027abd6ca2c6" translate="yes" xml:space="preserve">
          <source>If the attribute name has a namespace prefix, the prefix will still be attached.</source>
          <target state="translated">속성 이름에 네임 스페이스 접두사가 있으면 접두사가 계속 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="43f1e5d2810e31afb29d4cbb5b203ff69de05156" translate="yes" xml:space="preserve">
          <source>If the attribute value is a list of tokens (IDREFS, ENTITIES, or NMTOKENS), the tokens will be concatenated into a single string separated by whitespace.</source>
          <target state="translated">속성 값이 토큰 목록 (IDREFS, ENTITIES 또는 NMTOKENS) 인 경우 토큰은 공백으로 구분 된 단일 문자열로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="604294b7c0dd6e4d28df89e25837ca4a62600385" translate="yes" xml:space="preserve">
          <source>If the attribute value is a list of tokens (IDREFS, ENTITIES, or NMTOKENS), the tokens will be concatenated into a single string with each token separated by a single space.</source>
          <target state="translated">속성 값이 토큰 목록 (IDREFS, ENTITIES 또는 NMTOKENS) 인 경우 토큰은 단일 공백으로 구분 된 각 토큰이있는 단일 문자열로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="62a3db83b82f314fea33a46956ad055372005abd" translate="yes" xml:space="preserve">
          <source>If the attribute was not explicitly given a value in the instance document but has a default value provided by the schema associated with the document, an attribute node will be created with &lt;code&gt;specified&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;. Removing attribute nodes for which a default value is defined in the schema generates a new attribute node with the default value and &lt;code&gt;specified&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;. If validation occurred while invoking &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;, attribute nodes with &lt;code&gt;specified&lt;/code&gt; equals to &lt;code&gt;false&lt;/code&gt; are recomputed according to the default attribute values provided by the schema. If no default value is associate with this attribute in the schema, the attribute node is discarded.</source>
          <target state="translated">속성에 인스턴스 문서의 값이 명시 적으로 제공되지 않았지만 문서와 연관된 스키마에서 제공하는 기본값이있는 경우 속성 노드는 &lt;code&gt;specified&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; 로 설정되어 생성됩니다 . 디폴트 값이 스키마에 정의되어있는 속성 노드를 제거하면 기본 값을 가진 새로운 속성 노드 생성 &lt;code&gt;specified&lt;/code&gt; 로 설정 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 를 호출하는 동안 유효성 검사가 발생 하면 스키마에서 제공하는 기본 속성 값에 따라의 속성 노드 가 다시 계산됩니다. 스키마에서이 속성과 연결된 기본값이 없으면 속성 노드가 삭제됩니다. &lt;code&gt;specified&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="3de2839318027a87b01d1160931d4ec1a7e54992" translate="yes" xml:space="preserve">
          <source>If the authority component is present in the spec then the spec is treated as absolute and the spec authority and path will replace the context authority and path. If the authority component is absent in the spec then the authority of the new URL will be inherited from the context.</source>
          <target state="translated">권한 구성 요소가 스펙에 존재하면 스펙이 절대 값으로 처리되고 스펙 권한 및 경로가 컨텍스트 권한 및 경로를 대체합니다. 권한 구성 요소가 스펙에 없으면 새 URL의 권한이 컨텍스트에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="a027f872693de9d0e476629ed221d81049ef3c8e" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;#await()&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">차단 조치가 실행될 때 일시 중단되는 당사자에 의존하지 않는 경우, 당사자의 모든 스레드가 해당 조치가 해제 될 때 해당 조치를 실행할 수 있습니다. 이를 용이하게하기 위해 &lt;a href=&quot;#await()&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt; 의 각 호출은 장벽에서 해당 스레드의 도착 인덱스를 리턴합니다. 그런 다음 차단 작업을 실행할 스레드를 선택할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf5687cbde3be28238012b6e16935454ba496a38" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;cyclicbarrier#await--&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">장벽 조치가 실행될 때 일시 중단 된 당사자에 의존하지 않으면 당사자의 스레드 중 하나가 해제 될 때 해당 조치를 실행할 수 있습니다. 이것을 용이하게하기 위해, &lt;a href=&quot;cyclicbarrier#await--&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt; 의 각 호출은 장벽에서 해당 스레드의 도달 색인을 리턴합니다. 그런 다음 차단 작업을 실행할 스레드를 선택할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="1553601469def15f7ee0f8465070fbc819973117" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;#reset()&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;#isBroken()&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">스레드가 대기하는 동안 장벽이 &lt;a href=&quot;#reset()&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 되거나 &lt;code&gt;await&lt;/code&gt; 가 호출 될 때 장벽 &lt;a href=&quot;#isBroken()&quot;&gt;이 깨지면&lt;/a&gt; , 스레드가 대기하는 동안 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dac9df73081697b7b7531c1d6a0b9c3e69c870d7" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">스레드가 대기 중일 때 장벽이 &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 이거나 &lt;code&gt;await&lt;/code&gt; 가 호출 될 때 장벽 &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;이 끊어 지거나&lt;/a&gt; 스레드가 대기 중일 때 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="575a83a87991707c167ff499c572b2c82c888c2d" translate="yes" xml:space="preserve">
          <source>If the bean also implemented the zero argument get listener method:</source>
          <target state="translated">Bean이 0 인수를 구현 한 경우 리스너 메소드를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="2c223aaa7bd3533fb82949d6d90648ac9350bba7" translate="yes" xml:space="preserve">
          <source>If the bean is a subtype of java.applet.Applet, then it is given some special initialization. First, it is supplied with a default AppletStub and AppletContext. Second, if it was instantiated from a classname the applet's &quot;init&quot; method is called. (If the bean was deserialized this step is skipped.)</source>
          <target state="translated">Bean이 java.applet.Applet의 하위 유형 인 경우 특수 초기화가 제공됩니다. 먼저, 기본 AppletStub 및 AppletContext가 제공됩니다. 둘째, 클래스 이름에서 인스턴스화 된 경우 애플릿의 &quot;init&quot;메소드가 호출됩니다. Bean이 직렬화 해제 된 경우이 단계는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="80874718dd7a5a6c0f974bdb517de9b9cdeaa788" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;visibility&lt;/i&gt;&lt;/a&gt; of those side-effects to other threads, nor are there any guarantees that different operations on the &quot;same&quot; element within the same stream pipeline are executed in the same thread. Further, the ordering of those effects may be surprising. Even when a pipeline is constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream source (for example, &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; must produce &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt;), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</source>
          <target state="translated">동작 매개 변수에 부작용이있는 경우 (특별히 언급되지 않는 한) 다른 스레드에 대한 부작용 의 &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;가시성&lt;/i&gt;&lt;/a&gt; 에 대한 보장이 없으며 동일한 스트림 파이프 라인 내의 &quot;동일한&quot;요소에 대한 다른 조작이 보장되지 않습니다. 같은 스레드에서 실행됩니다. 또한 이러한 효과의 순서는 놀랍습니다. 파이프 라인이 스트림 소스의 발생 순서와 일치 하는 &lt;em&gt;결과&lt;/em&gt; 를 생성하도록 제한되는 경우에도 (예 : &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; 는 &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt; 생성해야합니다 .)의 경우 매퍼 함수가 개별 요소에 적용되는 순서 또는 특정 요소에 대해 동작 매개 변수가 실행되는 스레드에 대해서는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3cae85a2bc3049c2747d3d97aa3594bc11da611" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to:</source>
          <target state="translated">행동 매개 변수에 부작용이있는 경우, 명시 적으로 언급하지 않는 한 다음과 같은 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ccf27e1407104ddd4079359fbf08f2ee48d40b5e" translate="yes" xml:space="preserve">
          <source>If the best MIME type in the array does not support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.</source>
          <target state="translated">배열에서 최상의 MIME 유형이 charset 매개 변수를 지원하지 않는 경우 해당 MIME 유형을 공유하는 플레이버는 다음 순서로 표현 클래스별로 정렬됩니다. &lt;code&gt;java.io.InputStream&lt;/code&gt; , &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt; , &lt;code&gt;[B&lt;/code&gt; , &amp;lt;기타 모든&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ca5ea6c87eee103edbf011257ea8f6318b689500" translate="yes" xml:space="preserve">
          <source>If the best MIME type in the array does support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;, &amp;lt;all others&amp;gt;.</source>
          <target state="translated">배열에서 가장 좋은 MIME 유형이 charset 매개 변수를 지원하는 경우 해당 MIME 유형을 공유하는 플레이버는 다음 순서로 표현 클래스별로 정렬됩니다. &lt;code&gt;java.io.Reader&lt;/code&gt; , &lt;code&gt;java.lang.String&lt;/code&gt; , &lt;code&gt;java.nio.CharBuffer&lt;/code&gt; , &lt;code&gt;[C&lt;/code&gt; , &amp;lt;기타 모든 것&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="e64f9482d0004a103071d818b6eabe3a9e8fa8ce" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one.</source>
          <target state="translated">비트 오프셋이 0이 아니면 현재 바이트의 나머지 비트를 0으로 강제 설정하고 스트림 위치를 1 씩 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="f00562687194200d7d3d4e8dbcd71f247eefddae" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one. This method should be called by subclasses at the beginning of the &lt;code&gt;write(int)&lt;/code&gt; and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods.</source>
          <target state="translated">비트 오프셋이 0이 아닌 경우 현재 바이트의 나머지 비트를 0으로 강제하고 스트림 위치를 1 씩 증가시킵니다. 이 메소드는 &lt;code&gt;write(int)&lt;/code&gt; 및 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 메소드 시작시 서브 클래스에 의해 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="92b946e43c30c152e86047538b9789992732b7fc" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아닌 경우, 현재 바이트의 나머지는 0으로 채워지고 먼저 쓰여집니다. 쓰기 후 비트 오프셋은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="618cf6b5a31a53e5fb031a41327ab959ec20a724" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits()&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아니면 현재 바이트의 나머지 부분이 0으로 채워지고 먼저 기록됩니다. 비트 오프셋은 쓰기 후 0이됩니다. 구현 &lt;a href=&quot;imageoutputstreamimpl#flushBits()&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt; 의 flushBits 메서드를 사용하여 이를 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a17bf4b09c9d50c7630d0558298715e241010710" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아닌 경우, 현재 바이트의 나머지는 0으로 채워지고 먼저 쓰여집니다. 쓰기 후 비트 오프셋은 0이됩니다. 구현 &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt; 의 flushBits 메소드를 사용하여 이를 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c99084a7828ec1a975c99c15549a5685147fb7b" translate="yes" xml:space="preserve">
          <source>If the boolean system property &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</source>
          <target state="translated">부울 시스템 특성 &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 기본 서브 타입 특수화에서 조작 할 때 기본 값의 복싱이 발생하면 진단 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="1b7842845f7cac936a098919d982da718dd2d664" translate="yes" xml:space="preserve">
          <source>If the border, font, or color property values are not specified in the constructor or by invoking the appropriate set methods, the property values will be defined by the current look and feel, using the following property names in the Defaults Table:</source>
          <target state="translated">테두리, 글꼴 또는 색상 속성 값이 생성자에 지정되지 않았거나 적절한 set 메서드를 호출하여 속성 값이 기본값 테이블에서 다음 속성 이름을 사용하여 현재 모양과 느낌으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="99c31ef671411db209dfcab81af4e78e3e5b165e" translate="yes" xml:space="preserve">
          <source>If the boundary-points of a Range do not meet specific requirements.</source>
          <target state="translated">범위의 경계 지점이 특정 요구 사항을 충족하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="87e5deffba95ab1ac7918aac0643a0fb2206533c" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange(java.util.Date)&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType()&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">달력 유형 인 경우 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#setGregorianChange(java.util.Date)&quot;&gt;그레고리 변경 일&lt;/a&gt; 의 &lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 를가&lt;/a&gt; 로 설정되어 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 로 &lt;em&gt;예 기적&lt;/em&gt; 그레고리 안 달력. 주 정의 매개 변수도 &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;ISO 8601 표준과 호환되도록&lt;/a&gt; 설정됩니다 . &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 로 생성 된 &lt;code&gt;GregorianCalendar&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#getCalendarType()&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="486a42feea23b408f730eefa4db49a5a9bbd4a21" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">달력 유형 인 경우 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;그레고리 변경 일&lt;/a&gt; 의 &lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 를가&lt;/a&gt; 로 설정되어 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 로 &lt;em&gt;예 기적&lt;/em&gt; 그레고리 안 달력. 주 정의 매개 변수도 &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;ISO 8601 표준과 호환되도록&lt;/a&gt; 설정되어 있습니다 . &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 로 작성된 &lt;code&gt;GregorianCalendar&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="533aa6e407d4df4fa84a0752b83c5cc2a43222eb" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;#type()&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 사이트의 기호 유형 설명 &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 메서드 핸들의 &lt;a href=&quot;#type()&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 과 정확히 일치하면 invokeExact 에서처럼 호출이 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa913ecbed54558eb291f0922076e469c78e1e5a" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;methodhandle#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 사이트의 기호 유형 설명 &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 메소드 핸들의 &lt;a href=&quot;methodhandle#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 과 정확히 일치 하면 호출은 invokeExact에 의한 것처럼 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8da6d1bbefc65f4e59f9e3250b8dcf1e6a450b67" translate="yes" xml:space="preserve">
          <source>If the call was executed on Windows, with SOURCE_PATH set to &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt;, a valid result would be a file object representing the file &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 SOURCE_PATH가 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt; 설정된 상태에서 호출이 실행 된 경우 유효한 결과는 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt; 파일을 나타내는 파일 객체입니다 . src \ share \ classes \ com \ sun \ tools \ javac \ resources \ compiler.properties &quot; .</target>
        </trans-unit>
        <trans-unit id="82c1f7dd616c9fa0f0453a51b6c0d76cd6731897" translate="yes" xml:space="preserve">
          <source>If the caller instantiates the context using the default &lt;code&gt;GSSManager&lt;/code&gt; instance, then the Kerberos v5 GSS-API mechanism is guaranteed to be available for context establishment. This mechanism is identified by the Oid &quot;1.2.840.113554.1.2.2&quot; and is defined in RFC 1964.</source>
          <target state="translated">호출자가 기본 &lt;code&gt;GSSManager&lt;/code&gt; 인스턴스를 사용하여 컨텍스트를 인스턴스화하면 Kerberos v5 GSS-API 메커니즘을 컨텍스트 설정에 사용할 수 있습니다. 이 메커니즘은 Oid &quot;1.2.840.113554.1.2.2&quot;로 식별되며 RFC 1964에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="76dba0e51a985d3607bdbbe713e1aa4f8e5d2e2f" translate="yes" xml:space="preserve">
          <source>If the caller module is a &lt;a href=&quot;spi/resourcebundleprovider#obtain-resource-bundle&quot;&gt; resource bundle provider&lt;/a&gt;, it does not fall back to the class loader search.</source>
          <target state="translated">호출자 모듈이 &lt;a href=&quot;spi/resourcebundleprovider#obtain-resource-bundle&quot;&gt;리소스 번들 공급자&lt;/a&gt; 인 경우 클래스 로더 검색으로 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="127ed743b798d2c554cd5dbd0da31702ddd38bcb" translate="yes" xml:space="preserve">
          <source>If the caller module is a named module and the given &lt;code&gt;loader&lt;/code&gt; is the caller module's class loader, this method is equivalent to &lt;code&gt;getBundle(baseName, locale)&lt;/code&gt;; otherwise, it may not find resource bundles from named modules. Use &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.Module)&quot;&gt;&lt;code&gt;getBundle(String, Locale, Module)&lt;/code&gt;&lt;/a&gt; to load resource bundles on behalf on a specific module instead.</source>
          <target state="translated">호출자 모듈이 명명 된 모듈이고 지정된 &lt;code&gt;loader&lt;/code&gt; 가 호출자 모듈의 클래스 로더 인 경우이 메소드는 &lt;code&gt;getBundle(baseName, locale)&lt;/code&gt; 과 동일합니다 . 그렇지 않으면 명명 된 모듈에서 리소스 번들을 찾지 못할 수 있습니다. 대신 특정 모듈을 대신하여 자원 번들을로드 하려면 &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.Module)&quot;&gt; &lt;code&gt;getBundle(String, Locale, Module)&lt;/code&gt; &lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9bab532ba6bbba009ffbae752606d6da2e48286a" translate="yes" xml:space="preserve">
          <source>If the caller specifies a &lt;code&gt;null&lt;/code&gt; Subject and a &lt;code&gt;null&lt;/code&gt; value is permitted, the LoginContext instantiates a new Subject.</source>
          <target state="translated">호출자가 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 제목과 &lt;code&gt;null&lt;/code&gt; 값을 허용, LoginContext에 새로운 주제를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="cddd5c45ec5323f48597c6883597894f02cc5d57" translate="yes" xml:space="preserve">
          <source>If the caller supplies values that are inconsistent or out of bounds, the method enforces these constraints silently, and without failure. Specifically, if the start position or end position is greater than the length of the text, it is reset to equal the text length. If the start position is less than zero, it is reset to zero, and if the end position is less than the start position, it is reset to the start position.</source>
          <target state="translated">호출자가 일관성이 없거나 범위를 벗어난 값을 제공하는 경우 메서드는 이러한 제약 조건을 오류없이 자동으로 적용합니다. 특히 시작 위치 또는 끝 위치가 텍스트 길이보다 크면 텍스트 길이와 동일하게 재설정됩니다. 시작 위치가 0보다 작 으면 0으로 재설정되고 끝 위치가 시작 위치보다 작 으면 시작 위치로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d99d89b43899a3641eb5674cead1a33a1d5f371" translate="yes" xml:space="preserve">
          <source>If the caller's class loader defines a &lt;code&gt;Package&lt;/code&gt; of the given name, the &lt;code&gt;Package&lt;/code&gt; is returned. Otherwise, the ancestors of the caller's class loader are searched recursively (parent by parent) for a &lt;code&gt;Package&lt;/code&gt; of the given name.</source>
          <target state="translated">호출자의 클래스 로더 가 지정된 이름 의 &lt;code&gt;Package&lt;/code&gt; 를 정의 하면 &lt;code&gt;Package&lt;/code&gt; 가 반환됩니다. 그렇지 않으면, 호출자의 클래스 로더의 조상은 주어진 이름 의 &lt;code&gt;Package&lt;/code&gt; 에 대해 재귀 적으로 (상위 별 상위) 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="326d2f1653f789cda443686d18377e6514d2a778" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to add a service dependence on the given service type.</source>
          <target state="translated">호출자의 모듈이이 모듈이면이 모듈을 업데이트하여 주어진 서비스 유형에 대한 서비스 종속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0de0313a99182f5f835a0cf120f13fa81db11645" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to add a service dependence on the given service type. This method is intended for use by frameworks that invoke &lt;a href=&quot;../util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; on behalf of other modules or where the framework is passed a reference to the service type by other code. This method is a no-op when invoked on an unnamed module or an automatic module.</source>
          <target state="translated">호출자의 모듈이이 모듈이면이 모듈을 업데이트하여 주어진 서비스 유형에 대한 서비스 종속성을 추가합니다. 이 메소드는 다른 모듈을 대신하여 &lt;a href=&quot;../util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 를 호출하는 프레임 워크에서 사용 하거나 프레임 워크가 다른 코드에 의해 서비스 유형에 대한 참조를 전달하는 경우에 사용됩니다. 이 메서드는 이름이 지정되지 않은 모듈 또는 자동 모듈에서 호출 될 때 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2df2be70297edd88e8c12a7c5f300e9bb81d2b5b" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to export the given package to the given module.</source>
          <target state="translated">호출자의 모듈이이 모듈이면이 모듈을 업데이트하여 주어진 패키지를 주어진 모듈로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6758eb950c4ad23ad7160ebf4f955a5a3f8c692e" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to read the given module.</source>
          <target state="translated">호출자의 모듈이이 모듈이면 주어진 모듈을 읽도록이 모듈을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="360e9083fc3848da89a866e2997b26119a42eb1d" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to read the given module. This method is a no-op if &lt;code&gt;other&lt;/code&gt; is this module (all modules read themselves), this module is an unnamed module (as unnamed modules read all modules), or this module already reads &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">호출자의 모듈이이 모듈이면 주어진 모듈을 읽도록이 모듈을 업데이트합니다. &lt;code&gt;other&lt;/code&gt; 모듈이이 모듈 (모든 모듈이 자신을 읽음)이거나이 모듈이 이름이없는 모듈 (이름이없는 모듈이 모든 모듈을 읽음)이거나이 모듈이 이미 &lt;code&gt;other&lt;/code&gt; 모듈을 읽는 경우이 메서드는 작동하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="269b3f0fe8fb44df4ce0a6fe047dfebd11282f41" translate="yes" xml:space="preserve">
          <source>If the calling method is interested in retrieving the named property then it would have to test the element to see if it is a proxy class.</source>
          <target state="translated">호출 메소드가 이름 지정된 특성을 검색하는 데 관심이있는 경우 요소를 테스트하여 프록시 클래스인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9253130a27a78e3a08350cf89cd42b9d30c402d8" translate="yes" xml:space="preserve">
          <source>If the certificate is of type X.509 and has a</source>
          <target state="translated">인증서가 X.509 유형이고 인증서가</target>
        </trans-unit>
        <trans-unit id="aaacbc8edbe2f8c424f5386b7ac1e0da44e25e33" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;#implCloseChannel()&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">채널이 이미 닫힌 경우이 메서드는 즉시 반환됩니다. 그렇지 않으면 채널을 닫힌 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;#implCloseChannel()&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b697d0518cb0986befd095c4c07f371b7bc19eb6" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">채널이 이미 닫혀 있으면이 메소드는 즉시 리턴합니다. 그렇지 않으면 채널을 닫은 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d252f820f6c574294d1558501615ce3622e72864" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop()&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid()&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 멀티 캐스트 그룹의 구성원이면 구성원 자격이 &lt;a href=&quot;membershipkey#drop()&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt; 됩니다. 반환시 &lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;membershipkey#isValid()&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="258471a2858a2bd50b28d36eb9c0232d73db11d8" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop--&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid--&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 멀티 캐스트 그룹의 구성원 인 경우 멤버 자격이 &lt;a href=&quot;membershipkey#drop--&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt; 됩니다. 돌아 오면 &lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;membershipkey#isValid--&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fca12487d5034313786755dfdbb1487ee9174606" translate="yes" xml:space="preserve">
          <source>If the channel's key is not already in the selected-key set then it is added to that set and its ready-operation set is modified to identify exactly those operations for which the channel is now reported to be ready. Any readiness information previously recorded in the ready set is discarded.</source>
          <target state="translated">채널 키가 아직 선택된 키 세트에없는 경우 해당 키가 해당 세트에 추가되고 채널이 준비된 것으로보고 된 작업을 정확하게 식별하도록 준비된 작업 세트가 수정됩니다. 준비 세트에 이전에 기록 된 준비 정보는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a74fcb99fe153ea5c299a617e13d7e98b79feb03" translate="yes" xml:space="preserve">
          <source>If the character &lt;code&gt;oldChar&lt;/code&gt; does not occur in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, then a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence identical to the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, except that every occurrence of &lt;code&gt;oldChar&lt;/code&gt; is replaced by an occurrence of &lt;code&gt;newChar&lt;/code&gt;.</source>
          <target state="translated">문자 경우 &lt;code&gt;oldChar&lt;/code&gt; 는 문자 순서가 발생하지 않습니다이로 표현 &lt;code&gt;String&lt;/code&gt; 객체,이에 대한 참조 &lt;code&gt;String&lt;/code&gt; 객체가 돌려 주어집니다. 그렇지 않으면, &lt;code&gt;String&lt;/code&gt; 목적이 나타내는 문자 시퀀스와 동일한 문자 시퀀스 나타내 리턴 &lt;code&gt;String&lt;/code&gt; 마다 발생하는 것을 제외 객체 &lt;code&gt;oldChar&lt;/code&gt; 이 의 발생으로 대체 &lt;code&gt;newChar&lt;/code&gt; 에이 .</target>
        </trans-unit>
        <trans-unit id="2356291f03c93e71b96f7a671fd497dc56ec73d3" translate="yes" xml:space="preserve">
          <source>If the character defined by the mnemonic is found within the button's label string, the first occurrence of it will be underlined to indicate the mnemonic to the user.</source>
          <target state="translated">니모닉에 의해 정의 된 문자가 버튼의 레이블 문자열 내에서 발견되면 그 첫 번째 항목에 밑줄이 표시되어 사용자에게 니모닉을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e2733b75e92ebe16a2ce70438529de312b56641" translate="yes" xml:space="preserve">
          <source>If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned.</source>
          <target state="translated">문자에 숫자 값이 없으면 -1이 반환됩니다. 문자에 음이 아닌 정수 (예 : 분수 값)로 표현할 수없는 숫자 값이 있으면 -2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a94e7ca6896af3627bbb39f5e579611a67b2ce91" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_FINISH&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">특성 &lt;code&gt;IDENTITY_FINISH&lt;/code&gt; 가 설정된 경우이 함수는 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 캐스트가 확인되지 않은 ID 변환으로 간주 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ef817a66adab96584398608e88fbe1d608af344" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; 특성 이 설정된 경우이 함수는 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 캐스트가 검사되지 않은 ID 변환 인 것으로 추정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a0ae11bb0853d1ee68bf0914e7935640792833e" translate="yes" xml:space="preserve">
          <source>If the check box argument is &lt;code&gt;null&lt;/code&gt;, all check boxes in this check box group are deselected. If the check box argument belongs to a different check box group, this method does nothing.</source>
          <target state="translated">선택란 인수가 &lt;code&gt;null&lt;/code&gt; 이면 이 선택란 그룹의 모든 선택란이 선택 취소됩니다. 확인란 인수가 다른 확인란 그룹에 속하면이 메서드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="497068c1a55f2d965c9c1d485ba0e4ac4c0bfb03" translate="yes" xml:space="preserve">
          <source>If the check fails we throw a SecurityException, otherwise we return normally.</source>
          <target state="translated">검사에 실패하면 SecurityException이 발생하고 그렇지 않으면 정상적으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f200f54b8913d720a0fc8f80cb58e7fb832b09" translate="yes" xml:space="preserve">
          <source>If the chronology makes active use of eras, such as &lt;code&gt;JapaneseChronology&lt;/code&gt; then the year-of-era will be validated against the era. For other chronologies, validation is optional.</source>
          <target state="translated">연대기가 &lt;code&gt;JapaneseChronology&lt;/code&gt; 와 같은 시대를 적극적으로 사용하는 경우 시대 를 기준으로 시대가 검증됩니다. 다른 연대기의 경우 유효성 검사는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="907a36ef0b6c060f7a9d6a76251b166f6ce74a74" translate="yes" xml:space="preserve">
          <source>If the class can successfully be loaded, an attempt will be made to create an instance of it by calling &lt;code&gt;Class.newInstance&lt;/code&gt;. An attempt will be made to narrow the instance to type &lt;code&gt;java.awt.Component&lt;/code&gt; to display the object.</source>
          <target state="translated">클래스가 성공적으로로드 될 수있는 경우 &lt;code&gt;Class.newInstance&lt;/code&gt; 를 호출하여 해당 인스턴스를 만들려고 시도 합니다 . 객체를 표시 하기 위해 인스턴스를 &lt;code&gt;java.awt.Component&lt;/code&gt; 유형으로 좁히려 고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="0c7a6047da53758486c24b6ceb6b4575875d974a" translate="yes" xml:space="preserve">
          <source>If the class implements the interface &lt;a href=&quot;dynamicmbean&quot;&gt;&lt;code&gt;DynamicMBean&lt;/code&gt;&lt;/a&gt; then the MBean is a Dynamic MBean. Note that the class &lt;code&gt;StandardMBean&lt;/code&gt; implements this interface, so this case applies to a Standard MBean or MXBean created using the class &lt;code&gt;StandardMBean&lt;/code&gt;.</source>
          <target state="translated">클래스가 &lt;a href=&quot;dynamicmbean&quot;&gt; &lt;code&gt;DynamicMBean&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 MBean은 Dynamic MBean입니다. 클래스주의 &lt;code&gt;StandardMBean&lt;/code&gt; 이 인터페이스는,이 경우는 표준의 MBean 또는 MXBean의 적용 구현 클래스 사용하여 만든 &lt;code&gt;StandardMBean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9ebf03c3837794b9118548515dce9c5eeac747f" translate="yes" xml:space="preserve">
          <source>If the class is &lt;code&gt;VarHandle&lt;/code&gt; and the name string corresponds to the name of a signature-polymorphic access mode method, the resulting method handle is equivalent to one produced by &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt; with the access mode corresponding to the name string and with the same &lt;code&gt;type&lt;/code&gt; arguments.</source>
          <target state="translated">클래스가 &lt;code&gt;VarHandle&lt;/code&gt; 이고 이름 문자열이 서명 다형성 액세스 모드 메서드의 이름에 해당하는 경우 결과 메서드 핸들은 &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt; 이름 문자열에 해당하는 액세스 모드와 동일한 &lt;code&gt;type&lt;/code&gt; 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7d4839c4011be06ed972a50b4707c4c87c520b22" translate="yes" xml:space="preserve">
          <source>If the class loader is a &lt;a href=&quot;classloader#builtinLoaders&quot;&gt; built-in class loader&lt;/a&gt; or is not named then the first element and its following &lt;code&gt;&quot;/&quot;&lt;/code&gt; are omitted as shown in &quot;&lt;code&gt;acme@2.1/org.acme.Lib.test(Lib.java:80)&lt;/code&gt;&quot;. If the first element is omitted and the module is an unnamed module, the second element and its following &lt;code&gt;&quot;/&quot;&lt;/code&gt; are also omitted as shown in &quot;&lt;code&gt;MyClass.mash(MyClass.java:9)&lt;/code&gt;&quot;.</source>
          <target state="translated">클래스 로더가 &lt;a href=&quot;classloader#builtinLoaders&quot;&gt;내장 클래스 로더&lt;/a&gt; 이거나 이름이 지정되지 않은 경우 &quot; &lt;code&gt;acme@2.1/org.acme.Lib.test(Lib.java:80)&lt;/code&gt; &quot;에 표시된 것처럼 첫 번째 요소와 그 다음 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 가 생략됩니다. . 첫 번째 요소가 생략되고 모듈이 이름이 지정되지 않은 모듈 인 경우 &quot; &lt;code&gt;MyClass.mash(MyClass.java:9)&lt;/code&gt; 와 같이 두 번째 요소와 그 다음 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 도 생략됩니다. &quot; .</target>
        </trans-unit>
        <trans-unit id="572e2e8607da1aaa832eee294d600cd0b74c2f51" translate="yes" xml:space="preserve">
          <source>If the class loader is the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by &lt;code&gt;null&lt;/code&gt;), then the value of the &lt;code&gt;java.rmi.server.codebase&lt;/code&gt; property (or possibly an earlier cached value) is returned, or &lt;code&gt;null&lt;/code&gt; is returned if that property is not set.</source>
          <target state="translated">클래스 로더가 시스템 클래스 로더 ( &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt; 참조 ), 설치된 확장에 사용되는 로더와 같은 시스템 클래스 로더의 상위 또는 부트 스트랩 클래스 로더 ( &lt;code&gt;null&lt;/code&gt; 로 표시 될 수 있음 ) 인 경우 &lt;code&gt;java.rmi.server.codebase&lt;/code&gt; 특성 값 (또는 이전 캐시 된 값)이 리턴되거나 &lt;code&gt;null&lt;/code&gt; 해당 속성이 설정되지 않은 경우 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18dfc6c9d8012fcb4afd5d4cd53b47b6e173ddd4" translate="yes" xml:space="preserve">
          <source>If the class loader of the given module defines other modules and the given name is a class defined in a different module, this method returns &lt;code&gt;null&lt;/code&gt; after the class is loaded.</source>
          <target state="translated">지정된 모듈의 클래스 로더가 다른 모듈을 정의하고 지정된 이름이 다른 모듈에 정의 된 클래스 인 경우이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다. 클래스가로드 된 후 을 .</target>
        </trans-unit>
        <trans-unit id="b6cbdce4f03e8864e2078a8ebda20df5d53693b1" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 클래스 또는 인터페이스 가 다른 클래스의 구성원이면 &lt;code&gt;Class&lt;/code&gt; 를 반환합니다. 경우 선언 된 클래스를 나타내는 객체를 .</target>
        </trans-unit>
        <trans-unit id="952c977645377144d1e9387499dba9c6a0e6f790" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared. This method returns null if this class or interface is not a member of any other class. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, a primitive type, or void,then this method returns null.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 클래스 또는 인터페이스 가 다른 클래스의 멤버 인 경우 선언 된 클래스를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체를 반환합니다 . 이 클래스 또는 인터페이스가 다른 클래스의 멤버가 아닌 경우이 메소드는 널을 리턴합니다. 이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스, 프리미티브 유형 또는 void를 나타내는 경우이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c4b1d6d0e3e6bf78e4579733a8155fce8794f591" translate="yes" xml:space="preserve">
          <source>If the class path of the class loader includes remote network URLs then those URLs may be dereferenced in the process of searching for provider-configuration files.</source>
          <target state="translated">클래스 로더의 클래스 경로에 원격 네트워크 URL이 포함 된 경우 해당 URL은 공급자 구성 파일을 검색하는 과정에서 역 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5149c7a2ea949082634b5eade9a189fb43ba3574" translate="yes" xml:space="preserve">
          <source>If the class pointed to by the property cannot be loaded, or does not correspond to a valid subclass of MBeanServerBuilder then an exception is propagated, and no MBeanServer can be created until the &lt;b&gt;javax.management.builder.initial&lt;/b&gt; system property is reset to valid value.</source>
          <target state="translated">등록 정보가 가리키는 클래스를로드 할 수 없거나 MBeanServerBuilder의 유효한 서브 클래스에 해당하지 않으면 예외가 전파되고 &lt;b&gt;javax.management.builder.initial&lt;/b&gt; 시스템 등록 정보가 유효한 값으로 재설정 될 때까지 MBeanServer를 작성할 수 없습니다 &lt;b&gt;.&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="255675b731bcc7202d59daefb4cbc3dbea4fde7b" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;#resolveClass(java.lang.Class)&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">위의 단계를 사용하여 클래스를 찾았고 &lt;code&gt;resolve&lt;/code&gt; 플래그가 true이면이 메서드는 결과 &lt;code&gt;Class&lt;/code&gt; 개체 에서 &lt;a href=&quot;#resolveClass(java.lang.Class)&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt; 메서드 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a48f463646ddc67b0927be2d8f5a0d7e6779ec57" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">위의 단계를 사용하여 클래스를 찾았고 &lt;code&gt;resolve&lt;/code&gt; 플래그가 true 인 경우이 메소드는 결과 &lt;code&gt;Class&lt;/code&gt; 오브젝트 에서 &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="003444596c67295858def4a629af62005e80f04a" translate="yes" xml:space="preserve">
          <source>If the client does not specify a &lt;code&gt;JobPriority&lt;/code&gt; attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">클라이언트가 인쇄 작업에 대한 &lt;code&gt;JobPriority&lt;/code&gt; 속성을 지정하지 않고 프린터가 JobPriority 속성을 지원하는 경우 프린터는 구현 정의 기본 JobPriority 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cb1171375f133959d5fe66bf3b2a054030b8896" translate="yes" xml:space="preserve">
          <source>If the client does not specify a JobPriority attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">클라이언트가 인쇄 작업에 JobPriority 속성을 지정하지 않고 프린터가 JobPriority 속성을 지원하는 경우 프린터는 구현 정의 기본 JobPriority 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d048044cc6cddb0cf0dbc1da3f8b399bcca1c52" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default &lt;code&gt;JobHoldUntil&lt;/code&gt; value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">클라이언트가 인쇄 요청에이 속성을 제공하지 않고 프린터가이 속성을 지원하는 경우 프린터는 (구현에 따라) 기본 &lt;code&gt;JobHoldUntil&lt;/code&gt; 을 사용해야합니다. 작업 제출시 값을 사용해야합니다 (작업 처리에 필요한 경우 사용되는 대부분의 작업 템플릿 속성과는 달리) 시각).</target>
        </trans-unit>
        <trans-unit id="8819695d5b9293144506d78213d046dbf29c7943" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default JobHoldUntil value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">클라이언트가 인쇄 요청에이 속성을 제공하지 않고 프린터가이 속성을 지원하는 경우, 프린터는 작업 제출시 필요한 (구현 종속) 기본 JobHoldUntil 값을 사용해야합니다 (작업 처리에 필요한 경우 사용되는 대부분의 작업 템플리트 속성과는 달리) 시각).</target>
        </trans-unit>
        <trans-unit id="b95b0051a1d9e6aeda4cecd24f2f226586dceb7a" translate="yes" xml:space="preserve">
          <source>If the column class as returned by &lt;code&gt;getColumnClass&lt;/code&gt; is &lt;code&gt;String&lt;/code&gt;, use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getColumnClass&lt;/code&gt; 에서 반환 된 열 클래스 가 &lt;code&gt;String&lt;/code&gt; 이면 &lt;code&gt;Collator.getInstance()&lt;/code&gt; 반환 된 &lt;code&gt;Comparator&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1d2bea1ba481bf3017c0de86b5926674c8b57a55" translate="yes" xml:space="preserve">
          <source>If the column class implements &lt;code&gt;Comparable&lt;/code&gt;, use a &lt;code&gt;Comparator&lt;/code&gt; that invokes the &lt;code&gt;compareTo&lt;/code&gt; method.</source>
          <target state="translated">열 클래스가 &lt;code&gt;Comparable&lt;/code&gt; 을 구현 하는 경우 &lt;code&gt;compareTo&lt;/code&gt; 메서드 를 호출 하는 &lt;code&gt;Comparator&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="425608db615fcee29a758153b3f2f63df2fa7cde" translate="yes" xml:space="preserve">
          <source>If the column index is valid but the row index is less than zero the method returns a rectangle with the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values set appropriately and the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; values both set to zero. In general, when either the row or column indices indicate a cell outside the appropriate range, the method returns a rectangle depicting the closest edge of the closest cell that is within the table's range. When both row and column indices are out of range the returned rectangle covers the closest point of the closest cell.</source>
          <target state="translated">열 인덱스가 유효하지만 행 인덱스가 0보다 작은 경우 메서드는 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 값이 적절하게 설정되고 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; 설정된 사각형을 반환합니다. 값이 모두 0으로 설정된 합니다. 일반적으로 행 또는 열 인덱스가 적절한 범위 밖에있는 셀을 나타내는 경우 메서드는 테이블 범위 내에있는 가장 가까운 셀의 가장 가까운 가장자리를 나타내는 사각형을 반환합니다. 행 및 열 인덱스가 모두 범위를 벗어나면 반환 된 사각형이 가장 가까운 셀의 가장 가까운 지점을 덮습니다.</target>
        </trans-unit>
        <trans-unit id="6f068094c0b9101658e1bd4638d11b46b0682d00" translate="yes" xml:space="preserve">
          <source>If the combiner has a void return, no result will be inserted, and the first &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">컴 바이 너에 void 리턴이 있으면 결과가 삽입되지 않으며 대상 의 첫 번째 &lt;code&gt;N&lt;/code&gt; 매개 변수 유형이 컴 바이 너의 매개 변수와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bd33812eb44d59d69e1fa86993dc6c1b417f658" translate="yes" xml:space="preserve">
          <source>If the combiner returns a value, the first parameter type of the target must be identical with the return type of the combiner, and the next &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">결합기가 값을 반환하면 대상의 첫 번째 매개 변수 유형이 결합기의 반환 유형과 동일해야하며 대상의 다음 &lt;code&gt;N&lt;/code&gt; 매개 변수 유형이 결합기의 매개 변수와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a835e3176ef9901dbf657a51a0dc111ab329f96" translate="yes" xml:space="preserve">
          <source>If the combo box is editable, then this value may not have been added to the combo box with &lt;code&gt;addItem&lt;/code&gt;, &lt;code&gt;insertItemAt&lt;/code&gt; or the data constructors.</source>
          <target state="translated">콤보 상자를 편집 할 수있는 경우이 값은 &lt;code&gt;addItem&lt;/code&gt; , &lt;code&gt;insertItemAt&lt;/code&gt; 또는 데이터 생성자 를 사용하여 콤보 상자에 추가되지 않았을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f746d1a0f0f5d1b71eddaef84d93690d98f495a0" translate="yes" xml:space="preserve">
          <source>If the comment is present (not null) it is written, otherwise an an empty comment is written</source>
          <target state="translated">주석이 있으면 (null이 아님) 작성되고, 그렇지 않으면 빈 주석이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="700d0c6d66bdf7dd366a71fc298f1463af466dfa" translate="yes" xml:space="preserve">
          <source>If the comments argument is not null, then an ASCII &lt;code&gt;#&lt;/code&gt; character, the comments string, and a line separator are first written to the output stream. Thus, the &lt;code&gt;comments&lt;/code&gt; can serve as an identifying comment. Any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed in comments is replaced by a line separator generated by the &lt;code&gt;Writer&lt;/code&gt; and if the next character in comments is not character &lt;code&gt;#&lt;/code&gt; or character &lt;code&gt;!&lt;/code&gt; then an ASCII &lt;code&gt;#&lt;/code&gt; is written out after that line separator.</source>
          <target state="translated">comments 인수가 널이 아닌 경우 ASCII &lt;code&gt;#&lt;/code&gt; 문자, 주석 문자열 및 행 구분 기호가 먼저 출력 스트림에 기록됩니다. 따라서, &lt;code&gt;comments&lt;/code&gt; 식별 주석으로서 기능 할 수있다. 줄 바꿈 ( '\ n'), 캐리지 리턴 ( '\ r') 또는 주석에서 줄 바꿈 바로 다음에 오는 캐리지 리턴은 &lt;code&gt;Writer&lt;/code&gt; 가 생성 한 줄 구분자로 대체되며 다음 문자 인 경우 코멘트에서 문자 &lt;code&gt;#&lt;/code&gt; 또는 문자 가 아닙니다 &lt;code&gt;!&lt;/code&gt; 그런 다음 줄 구분 기호 뒤에 ASCII &lt;code&gt;#&lt;/code&gt; 이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d734df054f4a2c1ef528f0ad746950c442305d2a" translate="yes" xml:space="preserve">
          <source>If the component doesn't have composed text, the offset should be ignored, and the location returned should reflect the beginning (in line direction) of the highlight in the last line containing selected text. For example, for horizontal left-to-right text (such as English), the location to the left of the left-most character on the last line containing selected text is returned. For vertical top-to-bottom text, with lines proceeding from right to left, the location to the top of the left-most line containing selected text is returned.</source>
          <target state="translated">구성 요소에 구성된 텍스트가없는 경우 오프셋을 무시해야하며 반환 된 위치는 선택한 텍스트가 포함 된 마지막 줄의 강조 표시 시작 (줄 방향)을 반영해야합니다. 예를 들어, 수평 왼쪽에서 오른쪽 텍스트 (예 : 영어)의 경우 선택한 텍스트를 포함하는 마지막 줄에서 가장 왼쪽 문자의 왼쪽 위치가 반환됩니다. 행이 오른쪽에서 왼쪽으로 진행되는 수직 위에서 아래로 텍스트의 경우 선택한 텍스트를 포함하는 가장 왼쪽 행의 맨 위 위치가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52458478773761d2bba8b8c640a23a52fc2877dc" translate="yes" xml:space="preserve">
          <source>If the component has composed text (because the most recent InputMethodEvent sent to it contained composed text), then the offset is relative to the composed text - offset 0 indicates the first character in the composed text. The location returned should be for this character.</source>
          <target state="translated">구성 요소에 작성된 텍스트가있는 경우 (가장 최근에 보낸 InputMethodEvent에 작성된 텍스트가 포함되어 있기 때문에) 오프셋은 작성된 텍스트를 기준으로합니다. 오프셋 0은 작성된 텍스트의 첫 번째 문자를 나타냅니다. 반환 된 위치는이 캐릭터에 대한 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa083a799f0c4b27fbcd704b725195417a71c40c" translate="yes" xml:space="preserve">
          <source>If the component is &lt;code&gt;null&lt;/code&gt;, or the &lt;code&gt;
 GraphicsConfiguration&lt;/code&gt; associated with this component is &lt;code&gt;null&lt;/code&gt;, the window is placed in the center of the screen. The center point can be obtained with the &lt;a href=&quot;graphicsenvironment#getCenterPoint()&quot;&gt;&lt;code&gt;GraphicsEnvironment.getCenterPoint&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">성분이면 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt; GraphicsConfiguration&lt;/code&gt; 를 이 컴포넌트와 관련이 &lt;code&gt;null&lt;/code&gt; 창을 화면의 중심에 배치된다. 중심점은 &lt;a href=&quot;graphicsenvironment#getCenterPoint()&quot;&gt; &lt;code&gt;GraphicsEnvironment.getCenterPoint&lt;/code&gt; &lt;/a&gt; 메소드 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dd6f4c457146450ded7e20b80ac380bbab18e53" translate="yes" xml:space="preserve">
          <source>If the component is a child of some other container, it is removed from that container before being added to this container. The important difference between this method and &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; is that this method doesn't call &lt;code&gt;removeNotify&lt;/code&gt; on the component while removing it from its previous container unless necessary and when allowed by the underlying native windowing system. This way, if the component has the keyboard focus, it maintains the focus when moved to the new position.</source>
          <target state="translated">구성 요소가 다른 컨테이너의 자식 인 경우이 컨테이너에 추가되기 전에 해당 컨테이너에서 제거됩니다. 이 메소드와 &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; 의 중요한 차이점은이 메소드 는 필요하지 않고 기본 윈도우 시스템에서 허용하는 경우 이전 컨테이너에서 제거하는 동안 컴포넌트에서 &lt;code&gt;removeNotify&lt;/code&gt; 를 호출하지 않는다는 것입니다. 이렇게하면 구성 요소에 키보드 포커스가있는 경우 새 위치로 이동할 때 포커스가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9f28aca33e4b7d20b3d3eab00c327afedf0feed4" translate="yes" xml:space="preserve">
          <source>If the component is marked as opaque, the background is painted in the current background color of the component.</source>
          <target state="translated">구성 요소가 불투명으로 표시된 경우 배경은 구성 요소의 현재 배경색으로 칠해집니다.</target>
        </trans-unit>
        <trans-unit id="49528cc920475018bcff626e6ad10c005e36e46d" translate="yes" xml:space="preserve">
          <source>If the component is not &lt;code&gt;null&lt;/code&gt; and is shown on the screen, then the window is located in such a way that the center of the window coincides with the center of the component.</source>
          <target state="translated">구성 요소가 &lt;code&gt;null&lt;/code&gt; 이 아니고 화면에 표시되면 창의 중심이 구성 요소의 중심과 일치하는 방식으로 창이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="5eda8ad7764dbe33c30b572a11e1b1539c4e718f" translate="yes" xml:space="preserve">
          <source>If the component is not &lt;code&gt;null&lt;/code&gt;, but it is not currently showing, the window is placed in the center of the target screen defined by the &lt;code&gt;
 GraphicsConfiguration&lt;/code&gt; associated with this component.</source>
          <target state="translated">구성 요소가 &lt;code&gt;null&lt;/code&gt; 이 아니지만 현재 표시되지 않는 경우 창은 이 구성 요소와 연결된 &lt;code&gt; GraphicsConfiguration&lt;/code&gt; 에 의해 정의 된 대상 화면의 중앙에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9fde55638308a4ea2d10d2c4b49e0eee2a91067" translate="yes" xml:space="preserve">
          <source>If the component is not an ancestor of this container and has a non-null parent, it is removed from its current parent before it is added to this container.</source>
          <target state="translated">구성 요소가이 컨테이너의 조상이 아니고 null이 아닌 부모가있는 경우이 컨테이너에 추가되기 전에 현재 부모에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a8a4141d2aef13471dd4a0e737c385e9dc0e5ad9" translate="yes" xml:space="preserve">
          <source>If the component type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then numeric and atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">구성 요소 유형이 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 이면 숫자 및 원자 업데이트 액세스 모드는 비트 표현을 사용하여 값을 비교합니다 &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt; 각각 &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt; 및 Double.doubleToRawLongBits (double) 참조 ).</target>
        </trans-unit>
        <trans-unit id="2c31ff2ad53aa80158077167d3c0952e042633e3" translate="yes" xml:space="preserve">
          <source>If the compression level is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old level (and may be flushed); the new level will take effect only after that invocation.</source>
          <target state="translated">압축 수준이 변경되면 다음에 &lt;code&gt;deflate&lt;/code&gt; 를 호출 하면 이전 수준으로 사용 가능한 입력이 압축되고 플러시 될 수 있습니다. 새 레벨은 해당 호출 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="392c53482c9474c39ea6e8d51c4ff85e2db64e08" translate="yes" xml:space="preserve">
          <source>If the compression strategy is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old strategy (and may be flushed); the new strategy will take effect only after that invocation.</source>
          <target state="translated">압축 전략이 변경되면 다음에 &lt;code&gt;deflate&lt;/code&gt; 를 호출 하면 이전 전략으로 사용 가능한 입력이 압축됩니다 (플러시 될 수 있음). 새로운 전략은 해당 호출 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1941e8a43fce582de3711ef131570c2be6988f0c" translate="yes" xml:space="preserve">
          <source>If the connection is not established within the specified duration then building of the &lt;code&gt;WebSocket&lt;/code&gt; will fail with &lt;a href=&quot;httptimeoutexception&quot;&gt;&lt;code&gt;HttpTimeoutException&lt;/code&gt;&lt;/a&gt;. If this method is not invoked then the infinite timeout is assumed.</source>
          <target state="translated">연결이 지정된 기간 내에 설정되지 않으면 &lt;a href=&quot;httptimeoutexception&quot;&gt; &lt;code&gt;HttpTimeoutException&lt;/code&gt; &lt;/a&gt; 과 함께 &lt;code&gt;WebSocket&lt;/code&gt; 빌드 가 실패 합니다. 이 메소드가 호출되지 않으면 무한 제한 시간이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc304512711f4e405bbe651d78fc410942cc454e" translate="yes" xml:space="preserve">
          <source>If the connection pool manager supports &lt;code&gt;Statement&lt;/code&gt; pooling, for &lt;code&gt;PreparedStatements&lt;/code&gt;, which can be determined by invoking the method &lt;code&gt;DatabaseMetaData.supportsStatementPooling&lt;/code&gt;, the connection pool manager will register as a &lt;code&gt;StatementEventListener&lt;/code&gt; object with the new &lt;code&gt;PooledConnection&lt;/code&gt; object. When the &lt;code&gt;PreparedStatement&lt;/code&gt; is closed or there is an error, the connection pool manager (being a listener) gets a notification that includes a &lt;code&gt;StatementEvent&lt;/code&gt; object.</source>
          <target state="translated">연결 풀 관리자가 &lt;code&gt;DatabaseMetaData.supportsStatementPooling&lt;/code&gt; 메서드를 호출하여 확인할 수있는 &lt;code&gt;PreparedStatements&lt;/code&gt; 에 대해 &lt;code&gt;Statement&lt;/code&gt; 풀링을 지원 하는 경우 연결 풀 관리자는 새 &lt;code&gt;PooledConnection&lt;/code&gt; 개체 와 함께 &lt;code&gt;StatementEventListener&lt;/code&gt; 개체로 등록됩니다 . 때 &lt;code&gt;PreparedStatement&lt;/code&gt; 폐쇄되거나 오류가 연결 풀 매니저 (수신기 인)을 포함하는 통지를 취득 &lt;code&gt;StatementEvent&lt;/code&gt; 의 개체.</target>
        </trans-unit>
        <trans-unit id="c056d8bc44889ca1c50db14d914cd7e3d8e99f1b" translate="yes" xml:space="preserve">
          <source>If the connection pool manager wraps or provides a proxy to the logical handle returned from a call to &lt;code&gt;PoolConnection.getConnection&lt;/code&gt;, the pool manager must do one of the following when the connection pool manager closes or returns the &lt;code&gt;PooledConnection&lt;/code&gt; to the pool in response to the application calling &lt;code&gt;Connection.close&lt;/code&gt;:</source>
          <target state="translated">연결 풀 관리자가 &lt;code&gt;PoolConnection.getConnection&lt;/code&gt; 에 대한 호출에서 반환 된 논리적 핸들에 프록시를 래핑하거나 제공하는 경우 연결 풀 관리자가 응용 프로그램에 대한 응답으로 &lt;code&gt;PooledConnection&lt;/code&gt; 을 풀에 닫거나 반환 할 때 풀 관리자는 다음 중 하나를 수행해야합니다. &lt;code&gt;Connection.close&lt;/code&gt; 호출 :</target>
        </trans-unit>
        <trans-unit id="f881d8d4f5f09d46f8c2856b6d2d804f3ec96cc6" translate="yes" xml:space="preserve">
          <source>If the constructor completes normally, returns the newly created and initialized instance.</source>
          <target state="translated">생성자가 정상적으로 완료되면 새로 생성되고 초기화 된 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2aeb09eb6e0fcfe242a17792207492aa120605ac" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a CallbackHandler input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; CallbackHandler object (and a &lt;code&gt;null&lt;/code&gt; value is permitted), the LoginContext queries the &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; security property for the fully qualified class name of a default handler implementation. If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users. The caller thus assumes that the configured modules have alternative means for authenticating the user.</source>
          <target state="translated">생성자 않으면 &lt;b&gt;하지&lt;/b&gt; CallbackHandler를 입력 매개 변수를 가지고, 또는 발신자 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 의 CallbackHandler 객체 (그리고 &lt;code&gt;null&lt;/code&gt; 값이 허용된다), LoginContext에는 쿼리 &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; 의 기본 핸들러의 완전한 클래스 이름에 대한 보안 속성을 이행. 보안 특성이 설정되지 않은 경우 기본 모듈에는 사용자와 통신하는 데 사용할 CallbackHandler가 없습니다. 따라서 호출자는 구성된 모듈에 사용자를 인증하기위한 대체 수단이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="96edcc96b78112d3bb9f9d209b5477cb96759906" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Configuration input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; Configuration object, the constructor uses the following call to get the installed Configuration:</source>
          <target state="translated">생성자 않으면 &lt;b&gt;되지&lt;/b&gt; 구성 입력 매개 변수를 가지고, 또는 발신자가 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 구성 객체를 생성자는 설치된 구성 얻기 위해 다음 호출을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="56ea3a3517b6a27cca0834c9f4eb544d3dc38d39" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Subject input parameter, the LoginContext instantiates a new Subject.</source>
          <target state="translated">생성자 에 Subject 입력 매개 변수 가 &lt;b&gt;없는&lt;/b&gt; 경우 LoginContext는 새 Subject를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="51d999e9fc75b0313b56adf5745b9fffcd061b50" translate="yes" xml:space="preserve">
          <source>If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object.</source>
          <target state="translated">생성자가 CallbackHandler 입력 매개 변수를 갖는 경우 LoginContext는 호출자 지정 CallbackHandler 오브젝트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1e00d077c5cc21a366671e33a8a738802bc618a" translate="yes" xml:space="preserve">
          <source>If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration.</source>
          <target state="translated">생성자가 구성 입력 매개 변수를 가지고 있고 호출자가 널이 아닌 구성을 지정하면 LoginContext는 호출자 지정 구성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3de799a960e7be55aab3ca032d285e2179f3390f" translate="yes" xml:space="preserve">
          <source>If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object.</source>
          <target state="translated">생성자에 Subject 입력 매개 변수가있는 경우 LoginContext는 호출자 지정 Subject 오브젝트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3a99d0a19bc0f8c41b49ce35b93e620433ac8f02" translate="yes" xml:space="preserve">
          <source>If the constructor is declared to throw exceptions, the parameter list is followed by a space, followed by the word &quot;&lt;code&gt;throws&lt;/code&gt;&quot; followed by a comma-separated list of the thrown exception types.</source>
          <target state="translated">생성자가 예외를 throw하도록 선언 된 경우 매개 변수 목록 뒤에 공백이오고 &quot; &lt;code&gt;throws&lt;/code&gt; &quot; 라는 단어 가 뒤 따르고 쉼표로 구분 된 throw 된 예외 유형 목록이옵니다.</target>
        </trans-unit>
        <trans-unit id="8c9ed368492503e51fcc4ae43d3e8d4462771fd7" translate="yes" xml:space="preserve">
          <source>If the constructor's &lt;code&gt;accessible&lt;/code&gt; flag is not set, access checking is performed immediately on behalf of the lookup class.</source>
          <target state="translated">생성자의 &lt;code&gt;accessible&lt;/code&gt; 플래그가 설정되어 있지 않으면 조회 클래스 대신 즉시 액세스 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2473d04d22b81fa38fb3fac97ebfc248b300280e" translate="yes" xml:space="preserve">
          <source>If the constructor's declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see section 15.9.3 of</source>
          <target state="translated">생성자의 선언 클래스가 정적이 아닌 컨텍스트의 내부 클래스 인 경우 생성자의 첫 번째 인수는 둘러싸는 인스턴스 여야합니다. 섹션 15.9.3 참조</target>
        </trans-unit>
        <trans-unit id="f8c1d043cdccb51e8a4ceda740614fe5576a5363" translate="yes" xml:space="preserve">
          <source>If the container of an boundary-point of a Range is being set to either a node of an invalid type or a node with an ancestor of an invalid type.</source>
          <target state="translated">Range 경계 지점의 컨테이너가 잘못된 유형의 노드 또는 잘못된 유형의 조상이있는 노드로 설정되는 경우.</target>
        </trans-unit>
        <trans-unit id="eae554929c7a6131d929bc3da9b88deb58a80b03" translate="yes" xml:space="preserve">
          <source>If the container's &lt;code&gt;ComponentOrientation&lt;/code&gt; property is horizontal and left-to-right, the above example produces the output shown in Figure 1. If the container's &lt;code&gt;ComponentOrientation&lt;/code&gt; property is horizontal and right-to-left, the example produces the output shown in Figure 2.</source>
          <target state="translated">컨테이너의 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성이 수평이고 왼쪽에서 오른쪽이면 위의 예제는 그림 1과 같은 출력을 생성합니다. 컨테이너의 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성이 수평이고 오른쪽에서 왼쪽이면 예제는 그림 2와 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="12ab1266a164c0f6072aaf95e501de64c7ac066d" translate="yes" xml:space="preserve">
          <source>If the containing type is a parameterized type, the number of type arguments must equal the number of &lt;code&gt;typeElem&lt;/code&gt;'s formal type parameters. If it is not parameterized or if it is &lt;code&gt;null&lt;/code&gt;, this method is equivalent to &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt;.</source>
          <target state="translated">포함하는 유형이 매개 변수화 된 유형 인 경우 유형 인수의 수는 &lt;code&gt;typeElem&lt;/code&gt; 의 공식 유형 매개 변수 수와 같아야합니다 . 파라미터 화되어 있지 않은 경우, 또는 &lt;code&gt;null&lt;/code&gt; 의 경우 ,이 메소드는 &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt; 와 동등합니다 .</target>
        </trans-unit>
        <trans-unit id="1b29895ec70403fd2e17d250a3c6d70239c8ec92" translate="yes" xml:space="preserve">
          <source>If the contents of the underlying document containing the &lt;code&gt;XMLSignature&lt;/code&gt; are subsequently modified, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;XMLSignature&lt;/code&gt; 를 포함하는 기본 문서의 내용 이 이후에 수정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54595108c68c9e1528174df34d61161ee7d1002c" translate="yes" xml:space="preserve">
          <source>If the context is available and there is a security manager installed, the caller may require permission to access it or a security exception may be thrown. In a Java environment, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">컨텍스트가 사용 가능하고 보안 관리자가 설치되어 있으면 호출자에게 액세스 권한이 필요하거나 보안 예외가 발생할 수 있습니다. Java 환경에서 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드는 &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7936f29deee3d60765c1418e1263abb6aa6cc3c" translate="yes" xml:space="preserve">
          <source>If the context node is a &lt;code&gt;Document&lt;/code&gt; node and the action is &lt;code&gt;ACTION_REPLACE_CHILDREN&lt;/code&gt;, then the document that is passed as the context node will be changed such that its &lt;code&gt;xmlEncoding&lt;/code&gt;, &lt;code&gt;documentURI&lt;/code&gt;, &lt;code&gt;xmlVersion&lt;/code&gt;, &lt;code&gt;inputEncoding&lt;/code&gt;, &lt;code&gt;xmlStandalone&lt;/code&gt;, and all other such attributes are set to what they would be set to if the input source was parsed using &lt;code&gt;LSParser.parse()&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 노드가 &lt;code&gt;Document&lt;/code&gt; 노드이고 조치가 &lt;code&gt;ACTION_REPLACE_CHILDREN&lt;/code&gt; 이면 컨텍스트 노드로 전달되는 문서가 변경되어 &lt;code&gt;xmlEncoding&lt;/code&gt; , &lt;code&gt;documentURI&lt;/code&gt; , &lt;code&gt;xmlVersion&lt;/code&gt; , &lt;code&gt;inputEncoding&lt;/code&gt; , &lt;code&gt;xmlStandalone&lt;/code&gt; 및 기타 모든 속성이 해당 속성으로 설정됩니다. 입력 소스가 &lt;code&gt;LSParser.parse()&lt;/code&gt; 사용하여 구문 분석 된 경우로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a360ee8a79bfd6943a67c78860b71ba39acaa75" translate="yes" xml:space="preserve">
          <source>If the conversion failed, value 0 will be used.</source>
          <target state="translated">변환에 실패하면 값 0이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e4edf267c4c18b01156d4fb736a0d9de264f347" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString(double)&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">변환이 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'A'&lt;/code&gt; 인 경우 정밀도는 기수 포인트 뒤의 16 진수 숫자입니다. 정밀도가 제공되지 않으면 &lt;a href=&quot;../lang/double#toHexString(double)&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt; 의해 반환 된 모든 숫자 가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="6d873373059873c2f9dda2243106e00e462486c8" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">변환이 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'A'&lt;/code&gt; 이면 정밀도는 기수 포인트 뒤의 16 진수 수입니다. 정밀도가 제공되지 않으면 &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 모든 숫자 가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="4920cb3a35e9ffdd181f2cc1c02598946a361975" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'g'&lt;/code&gt; or &lt;code&gt;'G'&lt;/code&gt;, then the precision is the total number of significant digits in the resulting magnitude after rounding. If the precision is not specified, then the default value is &lt;code&gt;6&lt;/code&gt;. If the precision is &lt;code&gt;0&lt;/code&gt;, then it is taken to be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">변환이 &lt;code&gt;'g'&lt;/code&gt; 또는 &lt;code&gt;'G'&lt;/code&gt; 이면 정밀도는 반올림 후 결과 크기에서 유효 자릿수의 총 수입니다. 정밀도가 지정되지 않은 경우 기본값은 &lt;code&gt;6&lt;/code&gt; 입니다. 정밀도가 &lt;code&gt;0&lt;/code&gt; 이면 &lt;code&gt;1&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="5b740696da8433363284a2a09b00def3e5dd32a1" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the base indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">변환이 &lt;code&gt;'o'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'X'&lt;/code&gt; 이고 &lt;code&gt;'#'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 플래그가 둘 다 제공된 경우 결과에 기본 표시기 ( 8 진 및 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 또는 &lt;code&gt;'0'&lt;/code&gt; 의 경우 '0') 또는 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; 16 진수의 경우 0X &quot; ), 폭 (너비를 기준으로 한) 0, 값.</target>
        </trans-unit>
        <trans-unit id="8d9565e696ad547e1a513117ec394adf4606346c" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the radix indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">변환이 경우 &lt;code&gt;'o'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , 또는 &lt;code&gt;'X'&lt;/code&gt; 와 모두 &lt;code&gt;'#'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 을 플래그 후 기수 (지시약 결과에는 주어진 &lt;code&gt;'0'&lt;/code&gt; 진수 및 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; 16 진수의 경우 0X &quot; ), 폭 (너비를 기준으로 한) 0, 값.</target>
        </trans-unit>
        <trans-unit id="f92ee64ab913667741eadac9533a1057cb848b90" translate="yes" xml:space="preserve">
          <source>If the count reaches zero then the method returns with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">카운트가 0에 도달하면 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf6135f725f6abcb2f61e9b10a4d1d32a5ee738" translate="yes" xml:space="preserve">
          <source>If the counter can wrap around its maximum value, the modulus needs to be specified. The modulus is the value at which the counter is reset to zero.</source>
          <target state="translated">카운터가 최대 값을 감쌀 수있는 경우 계수를 지정해야합니다. 계수는 카운터가 0으로 재설정되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="7b2012ddc4ebb24e7045b7a055ac3ae1d060dc81" translate="yes" xml:space="preserve">
          <source>If the counter difference mode is used, the value of the derived gauge is calculated as the difference between the observed counter values for two successive observations. If this difference is negative, the value of the derived gauge is incremented by the value of the modulus. The derived gauge value (V[t]) is calculated using the following method:</source>
          <target state="translated">카운터 차이 모드를 사용하는 경우 파생 게이지 값은 두 개의 연속 관측치에 대한 관측 된 카운터 값의 차이로 계산됩니다. 이 차이가 음수이면 파생 게이지 값이 모듈러스 값만큼 증가합니다. 파생 게이지 값 (V [t])은 다음 방법을 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5d33f0fe4d8b3f6830caa94328f7bd32d5be7376" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close()&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Receiver&lt;/code&gt; 생성 한 결과 기본 장치가 암시 적으로 열리면이 메서드에 의해 장치가 암시 적으로 닫힙니다. 이는 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에 해당됩니다. 이 경우 단말기 &lt;code&gt;Receiver&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close()&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Receiver&lt;/code&gt; 역시 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f1b34ff7dc9bdfbc17c9da13d95b1516d17ebbc" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Receiver&lt;/code&gt; 작성 하여 기본 디바이스를 내재적으로 열면 디바이스는이 메소드에 의해 내재적으로 닫힙니다. 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에도 마찬가지 입니다. 이 경우 단말기 &lt;code&gt;Receiver&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Receiver&lt;/code&gt; 역시 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1af258f9977741775b4573e8cb983831177f305" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close()&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Transmitter&lt;/code&gt; 의 생성으로 인해 기본 장치가 암시 적으로 열리면이 메서드에 의해 장치가 암시 적으로 닫힙니다. 이는 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에 해당됩니다. 이 경우 장치 &lt;code&gt;Transmitter&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close()&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Transmitter&lt;/code&gt; 도 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ae995006fbd46da8baab1bfa646c3f1a74c6123" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Transmitter&lt;/code&gt; 생성 하여 기본 장치를 암시 적으로 열면이 방법으로 장치가 암시 적으로 닫힙니다. 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에도 마찬가지 입니다. 이 경우 장치 &lt;code&gt;Transmitter&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Transmitter&lt;/code&gt; 도 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c179704df7cb8ed1b3ce0d3934ef2876dfdab64" translate="yes" xml:space="preserve">
          <source>If the current capacity of this vector is less than &lt;code&gt;minCapacity&lt;/code&gt;, then its capacity is increased by replacing its internal data array, kept in the field &lt;code&gt;elementData&lt;/code&gt;, with a larger one. The size of the new data array will be the old size plus &lt;code&gt;capacityIncrement&lt;/code&gt;, unless the value of &lt;code&gt;capacityIncrement&lt;/code&gt; is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than &lt;code&gt;minCapacity&lt;/code&gt;, then the new capacity will be &lt;code&gt;minCapacity&lt;/code&gt;.</source>
          <target state="translated">이 벡터의 전류 용량보다 작 으면 &lt;code&gt;minCapacity&lt;/code&gt; 가 다음, 그 용량은 필드에서 유지 내부 데이터 배열로 대체함으로써 증가 &lt;code&gt;elementData&lt;/code&gt; 큰 하나. &lt;code&gt;capacityIncrement&lt;/code&gt; 값이 0보다 작거나 같지 않은 한 새 데이터 배열의 크기는 이전 크기 에 &lt;code&gt;capacityIncrement&lt;/code&gt; 가됩니다.이 경우 새 용량은 이전 용량의 두 배가됩니다. 그러나이 새 크기가 여전히 &lt;code&gt;minCapacity&lt;/code&gt; 보다 작 으면 새 용량은 &lt;code&gt;minCapacity&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="15aa95f18520c9768c5e75e2d00df5cd87e5c814" translate="yes" xml:space="preserve">
          <source>If the current count equals zero then nothing happens.</source>
          <target state="translated">현재 카운트가 0이면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f94ee3549183c062116cda5b26a97df611673964" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</source>
          <target state="translated">현재 카운트가 0보다 크면 감소합니다. 새 개수가 0이면 모든 대기중인 스레드가 스레드 예약 목적으로 다시 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7db62e9957e4a583a5bb47860c808eb80b034b" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happen:</source>
          <target state="translated">현재 카운트가 0보다 큰 경우, 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ac4173a35be7aa72f90b5ce9f676b82ef7108f" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen:</source>
          <target state="translated">현재 카운트가 0보다 큰 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e615f8a82085afa953ed38e8e8581f0bc679866" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">현재 카운트가 0이면이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="bf13f63814d624078b38288a8fd1cdef5534f01f" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately.</source>
          <target state="translated">현재 카운트가 0이면이 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7fd54efda8852abf1726c4425c8e78d3b50cf5d3" translate="yes" xml:space="preserve">
          <source>If the current event is a START_ELEMENT or END_ELEMENT this method returns the URI of the prefix or the default namespace.</source>
          <target state="translated">현재 이벤트가 START_ELEMENT 또는 END_ELEMENT 인 경우이 메소드는 프리픽스 또는 기본 네임 스페이스의 URI를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2cd4616380038d25f830f6fb1b42637233fe3f86" translate="yes" xml:space="preserve">
          <source>If the current event is a START_ELEMENT or END_ELEMENT this method returns the URI of the prefix or the default namespace. Returns null if the event does not have a prefix.</source>
          <target state="translated">현재 이벤트가 START_ELEMENT 또는 END_ELEMENT 인 경우이 메소드는 프리픽스 또는 기본 네임 스페이스의 URI를 반환합니다. 이벤트에 접두사가 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5887879e6691c6cf6cd544bc0267797a7fb44c5c" translate="yes" xml:space="preserve">
          <source>If the current layout manager implements &lt;code&gt;LayoutManager2&lt;/code&gt;, then &lt;a href=&quot;../../java/awt/layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt;&lt;/a&gt; is invoked on it. If the current layout manager does not implement &lt;code&gt;LayoutManager2&lt;/code&gt;, and constraints is a &lt;code&gt;String&lt;/code&gt;, then &lt;a href=&quot;../../java/awt/layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt;&lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt;&lt;/a&gt; is invoked on it.</source>
          <target state="translated">현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현 하면 &lt;a href=&quot;../../java/awt/layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현하지 않고 제약 조건이 &lt;code&gt;String&lt;/code&gt; 이면 &lt;a href=&quot;../../java/awt/layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt; &lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3a447a386debb26576b066a1d7df35582ff0b666" translate="yes" xml:space="preserve">
          <source>If the current layout manager implements &lt;code&gt;LayoutManager2&lt;/code&gt;, then &lt;a href=&quot;layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt;&lt;/a&gt; is invoked on it. If the current layout manager does not implement &lt;code&gt;LayoutManager2&lt;/code&gt;, and constraints is a &lt;code&gt;String&lt;/code&gt;, then &lt;a href=&quot;layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt;&lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt;&lt;/a&gt; is invoked on it.</source>
          <target state="translated">현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현 하면 &lt;a href=&quot;layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현하지 않고 제약 조건이 &lt;code&gt;String&lt;/code&gt; 이면 &lt;a href=&quot;layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt; &lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b49d04a03e7f62716b78c4449ecc798158a3b8" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">현재 메서드 핸들이 &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;변수 arity&lt;/a&gt; 가 아닌 경우 현재 메서드 핸들이 반환됩니다. 현재 메서드 핸들이 &lt;code&gt;asVarargsCollector&lt;/code&gt; 에 대한 유효한 입력이 될 수없는 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="a37f29b7a24ab724ec62dade14ae458a9a6defe6" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">현재 메소드 핸들이 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;가변 arity&lt;/a&gt; 가 아닌 경우 현재 메소드 핸들이 리턴됩니다. 현재 메소드 핸들이 &lt;code&gt;asVarargsCollector&lt;/code&gt; 에 유효한 입력이 아니더라도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="8cbc4f7fe8db524f0e4673c73c93f44a75301142" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the corresponding component types of the old and new method handle types.</source>
          <target state="translated">현재 메서드가 가변 arity 메서드 인 경우 인수 목록 변환은 &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;다른 곳&lt;/a&gt; 에서 설명한대로 여러 인수를 배열로 변환하고 수집하는 작업을 포함 할 수 있습니다 . 다른 모든 경우에는 모든 변환이 &lt;em&gt;쌍&lt;/em&gt; 으로 적용됩니다. 즉, 각 인수 또는 반환 값이 정확히 하나의 인수 또는 반환 값으로 변환됩니다 (또는 반환 값 없음). 적용된 변환은 이전 및 새 메서드 핸들 유형의 해당 구성 요소 유형을 참조하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c10541f1b7a87a46fca0e82cb887f1f5cdfbfc64" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types.</source>
          <target state="translated">현재 메소드가 가변 arity 메소드 인 경우 인수 목록 변환에는 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;다른 곳에 설명 된대로&lt;/a&gt; 여러 인수를 배열로 변환 및 수집하는 작업이 포함될 수 있습니다 . 다른 모든 경우에 모든 변환은 &lt;em&gt;pairwise&lt;/em&gt; 적용됩니다. 즉, 각 인수 또는 반환 값이 정확히 하나의 인수 또는 반환 값 (또는 반환 값 없음)으로 변환됩니다. 적용된 변환은 이전 및 새 메소드 핸들 유형의 해당 구성 요소 유형을 참조하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3234b563a8a8287e5245f9226141091af776f5ee" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback continues to the end of the sequence without looping, unless the loop end point is changed subsequently.</source>
          <target state="translated">이 메소드가 호출 될 때 현재 위치가 루프 종료점보다 큰 경우, 루프 종료 점이 이후에 변경되지 않는 한 반복없이 루프의 끝까지 재생이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="7e2a55a1a8bd4ad8685ae28cb47b45b0f898fa44" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback simply continues to the end of the clip without looping.</source>
          <target state="translated">이 메서드가 호출 될 때 현재 위치가 루프 끝점보다 크면 재생은 단순히 루프없이 클립의 끝까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="53f9e2fbf2a84ba1f43f8095838a4643dc8b642a" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가 이미 잠금을 보유한 경우 보유 횟수는 1 씩 증가하고 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bea401fb42f3ffdcd05852cff501d885235ba3f7" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the write lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가 이미 쓰기 잠금을 보유한 경우 보유 횟수는 1 씩 증가하고 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5d5c6242f9711c787eadd91061f9abc9aef5a8f" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">현재의 thread가 벌써이 락을 보관 유지하는 경우, 홀드 카운트는 1 씩 증가 해 메소드는 &lt;code&gt;true&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="e1db59e340b43fddf7a6d53a8527759fc071b7e9" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가이 잠금을 이미 보유하고 있으면 보유 횟수가 1 씩 증가하고 메소드가 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="de1ccea35bb4ddb6a5d8665f27c10c6698fe0002" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허용을 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하지만 스레드에 허용이 할당 된 시간은 중단이 발생하지 않았을 때 허용을받은 시간에 비해 변경 될 수 있습니다. 스레드가이 메서드에서 반환하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="967846e3a908254c0237f926edc93e8f505ceba6" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허용을 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하고 대기열에서의 위치에 영향을주지 않습니다. 스레드가이 메서드에서 반환하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c86b44509cfe15cabcfd2d4aab1300bc1d4ef97f" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허가를 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하지만 스레드에 허가가 할당 된 시간은 중단이 발생하지 않은 허가를받은 시간과 비교하여 변경 될 수 있습니다. 스레드가이 메소드에서 복귀하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="40fca319282952e93dfb024ecdef67ea1fa9292a" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허용을 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하며 큐의 위치는 영향을받지 않습니다. 스레드가이 메소드에서 복귀하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="161cfbc9814785c409424f6bf227b4259b6505f5" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. The &lt;em&gt;interrupted status&lt;/em&gt; of the current thread is cleared when this exception is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">현재 스레드가 대기 전 또는 대기 중에 스레드에 의해 &lt;a href=&quot;thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 &lt;code&gt;InterruptedException&lt;/code&gt; 이 throw됩니다. 이 예외가 발생하면 현재 스레드 의 &lt;em&gt;중단 된 상태&lt;/em&gt; 가 지워집니다. 이 예외는 위에서 설명한대로이 오브젝트의 잠금 상태가 복원 될 때까지 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1885c7979cce95514869fcb5fe52518650ad751" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">현재 스레드가 대기하기 전 또는 대기중인 스레드에 의해 &lt;a href=&quot;thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 된 경우 &lt;code&gt;InterruptedException&lt;/code&gt; 이 발생합니다. 이 예외는이 객체의 잠금 상태가 위에서 설명한대로 복원 될 때까지 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24ed769eb7f1d50760a5de23563feab0d013a7eb" translate="yes" xml:space="preserve">
          <source>If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens:</source>
          <target state="translated">현재 스레드가 마지막으로 도착하지 않은 경우 스레드 스케줄링을 위해 비활성화되고 다음 중 하나가 발생할 때까지 휴면 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e93c6ed45977774fb9b45dd0f270b3aadbc2d8b5" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동 중이면 실행하지 않고 예약을 취소하고 사용 가능한 경우 풀에 외부 적으로 제출 된 작업을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a9ec92500bb555146f4ac53bbc7fab388d80cf9" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동 중이면 실행하지 않고 예약을 취소하고 사용 가능한 경우 풀에 외부 적으로 제출 된 작업을 반환합니다. 가용성은 일시적 일 수 있으므로 &lt;code&gt;null&lt;/code&gt; 결과가 반드시 풀의 정지를 의미하지는 않습니다. 이 방법은 주로 확장을 지원하도록 설계되었으며 그렇지 않으면 유용하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3e28b29b93f45a59813378f46cf35c86d696607" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동 중이면 현재 스레드에 의해 대기열에 있지만 아직 실행되지 않은 다음 작업, 사용 가능한 경우 또는 사용할 수없는 경우 다른 스레드에 의해 분기 된 작업을 실행하지 않고 예약 취소하고 반환합니다. 가능한 경우.</target>
        </trans-unit>
        <trans-unit id="644fbda54838e93f9bd7f153a0b223117b46c3c3" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool this task is operating in. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동중인 경우, 현재 스레드에 의해 대기 중이지만 아직 실행되지 않은 다음 작업 (사용 가능한 경우 또는 사용 가능한 경우 다른 스레드에 의해 분기 된 작업)을 실행하지 않고 예약을 취소하고 반환합니다. 가능한 경우. 가용성은 일시적 일 수 있으므로 &lt;code&gt;null&lt;/code&gt; 결과가이 작업이 실행중인 풀의 정지를 의미하지는 않습니다.이 방법은 주로 확장을 지원하도록 설계되었으며 다른 방법으로는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d049c03bd38570f1b5a5d1aad9ff5cbfe4db5f0" translate="yes" xml:space="preserve">
          <source>If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">현재 스레드가이 잠금의 홀더 인 경우 보류 횟수가 감소합니다. 보류 카운트가 이제 0이면 잠금이 해제됩니다. 현재 스레드가이 잠금의 홀더가 아닌 경우 &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2cbfc6598ed6d1e50de22bbc3b671f7d2bef7cad" translate="yes" xml:space="preserve">
          <source>If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.</source>
          <target state="translated">현재 스레드가 마지막으로 도착한 스레드이고 생성자에 널이 아닌 배리어 조치가 제공된 경우 현재 스레드는 다른 스레드가 계속되도록 조치를 실행합니다. 장벽 동작 중에 예외가 발생하면 해당 예외가 현재 스레드에서 전파되고 장벽이 파손 된 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e09d61076e9dee8c7eca8604a1a4fdebca47aa" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">이 메소드에 들어갈 때 현재 쓰레드의 인터럽트 상태가 설정되거나 대기 중에 &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;인터럽트&lt;/a&gt; 되면 신호를받을 때까지 계속 대기합니다. 마지막으로이 메서드에서 반환되면 중단 된 상태가 계속 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="480b46196b0983b7baf6bc149cb22ece25ccb0df" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">현재 스레드의 인터럽트 상태가이 메소드에 진입 할 때 설정되거나 대기하는 동안 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 되면 신호가 날 때까지 계속 대기합니다. 이 메소드에서 마지막으로 리턴 될 때 인터럽트 된 상태는 계속 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ceafb860d280bdbbb95ef180a5ebfa010ab70b" translate="yes" xml:space="preserve">
          <source>If the current thread:</source>
          <target state="translated">현재 스레드가</target>
        </trans-unit>
        <trans-unit id="1b6dd611de80c284ec3983e42c194ba2625b5744" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number.</source>
          <target state="translated">현재 토큰이 숫자 인 경우이 필드에는 해당 숫자의 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a766629228a237157e338578f73608fe87ee3533" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number. The current token is a number when the value of the &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_NUMBER&lt;/code&gt;.</source>
          <target state="translated">현재 토큰이 숫자 인 경우이 필드에는 해당 숫자의 값이 포함됩니다. 현재 토큰은 &lt;code&gt;ttype&lt;/code&gt; 필드 의 값 이 &lt;code&gt;TT_NUMBER&lt;/code&gt; 일 때의 숫자 입니다.</target>
        </trans-unit>
        <trans-unit id="b366b28cb0c7e588029e3e176037326753259a0b" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token.</source>
          <target state="translated">현재 토큰이 단어 토큰 인 경우이 필드에는 단어 토큰의 문자를 제공하는 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6e1d9b63def477efdc3e54487d9fe89e9c35bd3c" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token. When the current token is a quoted string token, this field contains the body of the string.</source>
          <target state="translated">현재 토큰이 단어 토큰 인 경우이 필드에는 단어 토큰의 문자를 제공하는 문자열이 포함됩니다. 현재 토큰이 인용 문자열 토큰 인 경우이 필드에는 문자열 본문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b562295eceffafbb5ee1280fac546021ba6d2f83" translate="yes" xml:space="preserve">
          <source>If the currently selected input method or keyboard layout supports the requested locale, it remains selected.</source>
          <target state="translated">현재 선택된 입력 방법 또는 키보드 레이아웃이 요청 된 로케일을 지원하는 경우 선택된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e560277f9d287926b99c30eb8d401571d2c384c5" translate="yes" xml:space="preserve">
          <source>If the data to be updated has already been changed in the data source, there is a conflict, in which case the writer will not write the changes to the data source. The algorithm the writer uses for preventing or limiting conflicts depends entirely on its implementation.</source>
          <target state="translated">업데이트 할 데이터가 데이터 소스에서 이미 변경된 경우 충돌이 발생하며이 경우 작성자가 데이터 소스에 변경 사항을 쓰지 않습니다. 작성자가 충돌을 방지하거나 제한하기 위해 사용하는 알고리즘은 전적으로 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4610902d947f8dfa90bc178c559c33b46139cb9c" translate="yes" xml:space="preserve">
          <source>If the database supports SQL distinct types, then getTypeInfo() will return a single row with a TYPE_NAME of DISTINCT and a DATA_TYPE of Types.DISTINCT. If the database supports SQL structured types, then getTypeInfo() will return a single row with a TYPE_NAME of STRUCT and a DATA_TYPE of Types.STRUCT.</source>
          <target state="translated">데이터베이스가 SQL 구별 유형을 지원하는 경우 getTypeInfo ()는 TYPE_NAME이 DISTINCT이고 DATA_TYPE이 Types.DISTINCT 인 단일 행을 리턴합니다. 데이터베이스가 SQL 구조화 유형을 지원하는 경우 getTypeInfo ()는 TYPE_NAME이 STRUCT이고 DATA_TYPE이 Types.STRUCT 인 단일 행을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a247e695dc806480de65475cdb7e49df5eec14fe" translate="yes" xml:space="preserve">
          <source>If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5735c07ca103e22b6407b4ed7457c3834e66f98c" translate="yes" xml:space="preserve">
          <source>If the day-of-week is not available to format or parse then jump to day-of-month.</source>
          <target state="translated">요일을 형식화하거나 구문 분석 할 수없는 경우에는 요일로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f18de43b225ddbb14630d1c44418bb878cab7e5f" translate="yes" xml:space="preserve">
          <source>If the default &lt;a href=&quot;locale.category#DISPLAY&quot;&gt;&lt;code&gt;DISPLAY&lt;/code&gt;&lt;/a&gt; locale contains &quot;rg&quot; (region override) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbol returned from this method reflects the value specified with that extension.</source>
          <target state="translated">기본 &lt;a href=&quot;locale.category#DISPLAY&quot;&gt; &lt;code&gt;DISPLAY&lt;/code&gt; &lt;/a&gt; 로케일에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우이 메서드에서 반환 된 기호는 해당 확장으로 지정된 값을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="dfa93f2a463d291904aa277d4928f5e5cc774981" translate="yes" xml:space="preserve">
          <source>If the default behavior is not desired, then a Java security property can be set to a different Time-to-live (TTL) value for positive caching. Likewise, a system admin can configure a different negative caching TTL value when needed.</source>
          <target state="translated">기본 동작이 필요하지 않은 경우, 긍정적 인 캐싱을 위해 Java 보안 특성을 다른 TTL (Time-to-live) 값으로 설정할 수 있습니다. 마찬가지로, 시스템 관리자는 필요할 때 다른 네거티브 캐싱 TTL 값을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6889d388923a46b89918d04e5ceb2d2c40c4a81f" translate="yes" xml:space="preserve">
          <source>If the default drag cursor behavior is active, this method sets the default drag cursor for the specified actions supported by the drag source, the drop target action, and status, otherwise this method does nothing.</source>
          <target state="translated">기본 드래그 커서 동작이 활성화 된 경우이 메서드는 드래그 소스, 드롭 대상 동작 및 상태에서 지원하는 지정된 동작에 대한 기본 드래그 커서를 설정합니다. 그렇지 않으면이 메서드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28ec4fb264f4592c3191c9dfa387e6201501d30a" translate="yes" xml:space="preserve">
          <source>If the descriptor encoded in the byte buffer does not indicate a set of packages in the module then the &lt;code&gt;packageFinder&lt;/code&gt; will be invoked. The set of packages that the &lt;code&gt;packageFinder&lt;/code&gt; returns must include all the packages that the module exports, opens, as well as the packages of the service implementations that the module provides, and the package of the main class (if the module has a main class). If the &lt;code&gt;packageFinder&lt;/code&gt; throws an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; then &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; cause will be re-thrown.</source>
          <target state="translated">바이트 버퍼에 인코딩 된 설명자가 모듈의 패키지 집합을 나타내지 않으면 &lt;code&gt;packageFinder&lt;/code&gt; 가 호출됩니다. &lt;code&gt;packageFinder&lt;/code&gt; 가 반환 하는 패키지 세트 에는 모듈이 제공하는 서비스 구현의 패키지와 모듈이 제공하는 서비스 구현의 패키지 (모듈에 기본 클래스가있는 경우)뿐만 아니라 모듈이 내보내고 여는 모든 패키지가 포함되어야합니다. . 는 IF &lt;code&gt;packageFinder&lt;/code&gt; 가 발생 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 을&lt;/a&gt; 다음 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이의&lt;/a&gt; 원인은 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b98052904a44628625b06f819a5054b172f83074" translate="yes" xml:space="preserve">
          <source>If the descriptor encoded in the input stream does not indicate a set of packages in the module then the &lt;code&gt;packageFinder&lt;/code&gt; will be invoked. The set of packages that the &lt;code&gt;packageFinder&lt;/code&gt; returns must include all the packages that the module exports, opens, as well as the packages of the service implementations that the module provides, and the package of the main class (if the module has a main class). If the &lt;code&gt;packageFinder&lt;/code&gt; throws an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; then &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; cause will be re-thrown.</source>
          <target state="translated">입력 스트림에 인코딩 된 설명자가 모듈의 패키지 집합을 나타내지 않으면 &lt;code&gt;packageFinder&lt;/code&gt; 가 호출됩니다. &lt;code&gt;packageFinder&lt;/code&gt; 가 반환 하는 패키지 세트 에는 모듈이 제공하는 서비스 구현의 패키지와 모듈이 제공하는 서비스 구현의 패키지 (모듈에 기본 클래스가있는 경우)뿐만 아니라 모듈이 내보내고 여는 모든 패키지가 포함되어야합니다. . 는 IF &lt;code&gt;packageFinder&lt;/code&gt; 가 발생 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 을&lt;/a&gt; 다음 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이의&lt;/a&gt; 원인은 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b2cac5e3a466b13ae80c01fca973dcf37b93b686" translate="yes" xml:space="preserve">
          <source>If the descriptor is empty the following String is returned: &amp;lt;Descriptor&amp;gt;&amp;lt;/Descriptor&amp;gt;</source>
          <target state="translated">디스크립터가 비어 있으면 다음 문자열이 리턴됩니다. &amp;lt;Descriptor&amp;gt; &amp;lt;/ Descriptor&amp;gt;</target>
        </trans-unit>
        <trans-unit id="873e8f5cab98a9e1326f6e91f9c4bb6efc23d9fb" translate="yes" xml:space="preserve">
          <source>If the designated column has a datatype of CHAR or VARCHAR and contains a &quot;0&quot; or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT and contains a 0, a value of &lt;code&gt;false&lt;/code&gt; is returned. If the designated column has a datatype of CHAR or VARCHAR and contains a &quot;1&quot; or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT and contains a 1, a value of &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 컬럼의 데이터 유형이 CHAR 또는 VARCHAR이고 &quot;0&quot;을 포함하거나 데이터 유형이 BIT, TINYINT, SMALLINT, INTEGER 또는 BIGINT이고 0을 포함하는 경우 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 지정된 열의 데이터 유형이 CHAR 또는 VARCHAR이고 &quot;1&quot;을 포함하거나 데이터 유형이 BIT, TINYINT, SMALLINT, INTEGER 또는 BIGINT이고 1을 포함하는 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8424e147bec876cffc18c36963ed5006f3be55ca" translate="yes" xml:space="preserve">
          <source>If the desired URL is not the one currently being displayed, the &lt;code&gt;getStream&lt;/code&gt; method is called to give subclasses control over the stream provided.</source>
          <target state="translated">원하는 URL이 현재 표시되는 URL이 아닌 경우 &lt;code&gt;getStream&lt;/code&gt; 메서드가 호출되어 제공된 스트림에 대한 제어 권한을 하위 클래스에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e04d7b4037ef0253d1eb9639910efd968b0cd89" translate="yes" xml:space="preserve">
          <source>If the desired member is &lt;code&gt;protected&lt;/code&gt;, the usual JVM rules apply, including the requirement that the lookup class must be either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading &lt;code&gt;this&lt;/code&gt; parameter from &lt;code&gt;C&lt;/code&gt; (which will necessarily be a superclass of the lookup class) to the lookup class itself.</source>
          <target state="translated">원하는 멤버가 &lt;code&gt;protected&lt;/code&gt; 되는 경우 조회 클래스가 원하는 멤버와 동일한 패키지에 있어야하거나 해당 멤버를 상속해야한다는 요구 사항을 포함하여 일반적인 JVM 규칙이 적용됩니다. (Java Virtual Machine 사양, 섹션 4.9.2, 5.4.3.5 및 6.4를 참조하십시오.) 또한 원하는 멤버가 정적이 아닌 필드 또는 다른 패키지의 메소드 인 경우 결과 메소드 핸들은 조회 클래스의 객체 또는 해당 서브 클래스 중 하나 이 요구 사항은 &lt;code&gt;this&lt;/code&gt; 매개 변수 의 선행 유형을 &lt;code&gt;C&lt;/code&gt; (조회 클래스의 수퍼 클래스 임)에서 조회 클래스 자체 로 좁 히면 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff1be7735213926c3d2c892b139efeed267ca86c" translate="yes" xml:space="preserve">
          <source>If the destination &lt;code&gt;Raster&lt;/code&gt; is null, a new &lt;code&gt;Raster&lt;/code&gt; is created. An &lt;code&gt;IllegalArgumentException&lt;/code&gt; may be thrown if the source is the same as the destination or if the number of bands in the source is not equal to the number of bands in the destination.</source>
          <target state="translated">대상 &lt;code&gt;Raster&lt;/code&gt; 가 null이면 새 &lt;code&gt;Raster&lt;/code&gt; 가 생성됩니다. &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 소스가 목적지로 또는 소스의 밴드 수와 목적지의 밴드 수와 같지 않으면 동일한 경우 발생 될 수있다.</target>
        </trans-unit>
        <trans-unit id="562d186cddc9b882f1164e575c0ca6cdd70e8771" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream()&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream()&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값)이면 &lt;a href=&quot;process#getErrorStream()&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 반환 된 입력 스트림을 사용하여 하위 프로세스의 오류 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getErrorStream()&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2f1759b66bcf0473ca1f75eb77e287f807f0be61" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 반환 한 입력 스트림을 사용하여 하위 프로세스의 오류 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="3ca5de5b614e7eb26d543dee9c4a10ca118934c5" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream()&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream()&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값)이면 &lt;a href=&quot;process#getInputStream()&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 반환 된 입력 스트림을 사용하여 하위 프로세스의 표준 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getInputStream()&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b68154bc9bb15cf5c833579d040cf02c8940944f" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 리턴 한 입력 스트림을 사용하여 서브 프로세스의 표준 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="24fa6417e10753014fbf446e67531a964d3dc7f5" translate="yes" xml:space="preserve">
          <source>If the destination is null, it will be created with a number of bands equalling the number of rows in the matrix. No exception is thrown if the operation causes a data overflow.</source>
          <target state="translated">대상이 null이면 행렬의 행 수와 같은 수의 밴드로 생성됩니다. 작업으로 인해 데이터 오버플로가 발생하는 경우 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5814c260a49a2bf524faa7ed1d2bd24188a54959" translate="yes" xml:space="preserve">
          <source>If the destination's &lt;code&gt;append()&lt;/code&gt; method never throws &lt;code&gt;IOException&lt;/code&gt;, then this method will always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">목적지의 &lt;code&gt;append()&lt;/code&gt; 메소드가 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시키지 않는 경우 ,이 메소드는 항상 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="00009ef2f2723f566d5cd7d5ea238cfdfa3f8286" translate="yes" xml:space="preserve">
          <source>If the determinant is non-zero, then this transform is invertible and the various methods that depend on the inverse transform do not need to throw a &lt;a href=&quot;noninvertibletransformexception&quot;&gt;&lt;code&gt;NoninvertibleTransformException&lt;/code&gt;&lt;/a&gt;. If the determinant is zero then this transform can not be inverted since the transform maps all input coordinates onto a line or a point. If the determinant is near enough to zero then inverse transform operations might not carry enough precision to produce meaningful results.</source>
          <target state="translated">결정자가 0이 아닌 경우이 변환은 반전 가능하며 역변환에 의존하는 다양한 메소드는 &lt;a href=&quot;noninvertibletransformexception&quot;&gt; &lt;code&gt;NoninvertibleTransformException&lt;/code&gt; &lt;/a&gt; 을 던질 필요가 없습니다 . 결정자가 0이면 변환이 모든 입력 좌표를 선 또는 점에 매핑하므로이 변환을 반전 할 수 없습니다. 행렬식이 0에 충분히 가까우면 역변환 연산이 의미있는 결과를 생성하기에 충분한 정밀도를 전달하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6980173cd7348cb8d2c24081aedaf81b540b3f" translate="yes" xml:space="preserve">
          <source>If the device does not support setting a specific controller, this method returns 0 for that controller. Calling &lt;code&gt;controlChange&lt;/code&gt; will have no effect then.</source>
          <target state="translated">장치가 특정 컨트롤러 설정을 지원하지 않는 경우이 메서드는 해당 컨트롤러에 대해 0을 반환합니다. 그러면 &lt;code&gt;controlChange&lt;/code&gt; 를 호출 해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df1f0903f6dd8ca3989d88e94f2d77f67eb5ad33" translate="yes" xml:space="preserve">
          <source>If the device does not support setting channel pressure, this method always returns 0. Calling &lt;code&gt;setChannelPressure&lt;/code&gt; will have no effect then.</source>
          <target state="translated">장치가 채널 압력 설정을 지원하지 않는 경우이 메서드는 항상 0을 반환합니다 . 그러면 &lt;code&gt;setChannelPressure&lt;/code&gt; 를 호출 해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8233a3647bc57e6741c1cb20e7987108b8967295" translate="yes" xml:space="preserve">
          <source>If the device does not support setting poly pressure, this method always returns 0. Calling &lt;code&gt;setPolyPressure&lt;/code&gt; will have no effect then.</source>
          <target state="translated">장치가 &lt;code&gt;setPolyPressure&lt;/code&gt; 설정을 지원하지 않는 경우이 메서드는 항상 0을 반환합니다. setPolyPressure 를 호출 해도 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8a2d79cc304a6be8aee1283d70f86196ba6e581" translate="yes" xml:space="preserve">
          <source>If the dialog is modal and is not already visible, this call will not return until the dialog is hidden by calling hide or dispose. It is permissible to show modal dialogs from the event dispatching thread because the toolkit will ensure that another event pump runs while the one which invoked this method is blocked.</source>
          <target state="translated">대화 상자가 모달이고 아직 표시되지 않은 경우이 호출은 hide 또는 dispose를 호출하여 대화 상자를 숨길 때까지 반환되지 않습니다. 툴킷은이 메소드를 호출 한 펌프가 차단 된 동안 다른 이벤트 펌프가 실행되도록 보장하기 때문에 이벤트 디스패치 스레드에서 모달 대화 상자를 표시하는 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec907f76145e8ddd032cdc8267ff559cc1c48182" translate="yes" xml:space="preserve">
          <source>If the digit is less than 10, then &lt;code&gt;'0' + digit&lt;/code&gt; is returned. Otherwise, the value &lt;code&gt;'a' + digit - 10&lt;/code&gt; is returned.</source>
          <target state="translated">숫자가 10보다 작 으면 &lt;code&gt;'0' + digit&lt;/code&gt; 가 반환됩니다. 그렇지 않으면 값 &lt;code&gt;'a' + digit - 10&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d397471c9fa609642a9cc71822d0d3db3f61ef8d" translate="yes" xml:space="preserve">
          <source>If the directory does not support a string representation of some or all of its attributes, the form of &lt;code&gt;search&lt;/code&gt; that accepts filter arguments in the form of Objects can be used instead. The service provider for such a directory would then translate the filter arguments to its service-specific representation for filter evaluation. See &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt;.</source>
          <target state="translated">디렉토리가 일부 또는 모든 속성의 문자열 표현을 지원하지 않으면 Objects 형식의 필터 인수를 허용 하는 &lt;code&gt;search&lt;/code&gt; 형식을 대신 사용할 수 있습니다. 그런 디렉토리에 대한 서비스 제공자는 필터 인수를 필터 평가를 위해 서비스 특정 표시로 변환합니다. 참조 &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77d2e43114de0de16774d5ed4ecd9f6313b3e490" translate="yes" xml:space="preserve">
          <source>If the doctype-public or doctype-system properties are specified, then the html output method should output a document type declaration immediately before the first element. The name following &amp;lt;!DOCTYPE should be HTML or html. If the doctype-public property is specified, then the output method should output PUBLIC followed by the specified public identifier; if the doctype-system property is also specified, it should also output the specified system identifier following the public identifier. If the doctype-system property is specified but the doctype-public property is not specified, then the output method should output SYSTEM followed by the specified system identifier.</source>
          <target state="translated">doctype-public 또는 doctype-system 속성이 지정된 경우 html 출력 메서드는 첫 번째 요소 바로 앞에 문서 유형 선언을 출력해야합니다. &amp;lt;! DOCTYPE 다음의 이름은 HTML 또는 html이어야합니다. doctype-public 속성이 지정된 경우 출력 메서드는 지정된 공용 식별자가 뒤에 오는 PUBLIC을 출력해야합니다. doctype-system 속성도 지정되면 공용 식별자 뒤에 지정된 시스템 식별자도 출력해야합니다. doctype-system 속성이 지정되었지만 doctype-public 속성이 지정되지 않은 경우 출력 메서드는 SYSTEM 뒤에 지정된 시스템 식별자를 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="86b3eab9594a91d2810de348de7dd9c40f4c769d" translate="yes" xml:space="preserve">
          <source>If the doctype-system property is specified, the xml output method should output a document type declaration immediately before the first element. The name following &amp;lt;!DOCTYPE should be the name of the first element. If doctype-public property is also specified, then the xml output method should output PUBLIC followed by the public identifier and then the system identifier; otherwise, it should output SYSTEM followed by the system identifier. The internal subset should be empty. The value of the doctype-public property should be ignored unless the doctype-system property is specified.</source>
          <target state="translated">doctype-system 속성이 지정된 경우 xml 출력 메서드는 첫 번째 요소 바로 앞에 문서 유형 선언을 출력해야합니다. &amp;lt;! DOCTYPE 다음의 이름은 첫 번째 요소의 이름이어야합니다. doctype-public 속성도 지정된 경우 xml 출력 메서드는 PUBLIC과 공용 식별자, 시스템 식별자를 차례로 출력해야합니다. 그렇지 않으면 SYSTEM 다음에 시스템 식별자를 출력해야합니다. 내부 하위 집합은 비어 있어야합니다. doctype-system 속성이 지정되지 않은 경우 doctype-public 속성 값은 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="cee8facf69b90419835e8685cee670049ac617cb" translate="yes" xml:space="preserve">
          <source>If the document is loaded asynchronously, the document will be installed into the editor immediately using a call to &lt;code&gt;setDocument&lt;/code&gt; which will fire a document property change event, then a thread will be created which will begin doing the actual loading. In this case, the page property change event will not be fired by the call to this method directly, but rather will be fired when the thread doing the loading has finished. It will also be fired on the event-dispatch thread. Since the calling thread can not throw an &lt;code&gt;IOException&lt;/code&gt; in the event of failure on the other thread, the page property change event will be fired when the other thread is done whether the load was successful or not.</source>
          <target state="translated">문서가 비동기식으로로드 되면 문서 속성 변경 이벤트를 발생시키는 &lt;code&gt;setDocument&lt;/code&gt; 호출을 사용하여 문서가 편집기에 즉시 설치되고 실제로드를 시작하는 스레드가 생성됩니다. 이 경우 페이지 속성 변경 이벤트는이 메서드에 대한 호출에 의해 직접 시작되지 않고로드를 수행하는 스레드가 완료 될 때 시작됩니다. 이벤트 디스패치 스레드에서도 실행됩니다. 호출 스레드는 다른 스레드에서 실패한 &lt;code&gt;IOException&lt;/code&gt; 을 throw 할 수 없으므로 로드 성공 여부에 관계없이 다른 스레드가 완료되면 페이지 속성 변경 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aa862933af1b586831035ab71ba5bcc647784cc" translate="yes" xml:space="preserve">
          <source>If the document is loaded synchronously, it will be filled in with the stream prior to being installed into the editor with a call to &lt;code&gt;setDocument&lt;/code&gt;, which is bound and will fire a property change event. If an &lt;code&gt;IOException&lt;/code&gt; is thrown the partially loaded document will be discarded and neither the document or page property change events will be fired. If the document is successfully loaded and installed, a view will be built for it by the UI which will then be scrolled if necessary, and then the page property change event will be fired.</source>
          <target state="translated">문서가 동 기적으로로드되면 편집기에 설치되기 전에 바인딩되고 속성 변경 이벤트를 발생시키는 &lt;code&gt;setDocument&lt;/code&gt; 에 대한 호출로 편집기에 설치되기 전에 스트림으로 채워집니다 . 경우 &lt;code&gt;IOException&lt;/code&gt; 가이 발생합니다 부분적으로로드 된 문서는 파기되어 문서 또는 페이지 프로퍼티 변경 이벤트가 트리거됩니다. 문서가 성공적으로로드되고 설치되면 UI에 의해 뷰가 빌드되고 필요한 경우 스크롤 된 다음 페이지 속성 변경 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="662626e1d4e27eb6ce910acdf4f7275869e7a388" translate="yes" xml:space="preserve">
          <source>If the document's schema is a DTD or no schema is associated with the document, this method will always return &lt;code&gt;false&lt;/code&gt; . If the document's schema is an XML Schema, the method will return &lt;code&gt;true&lt;/code&gt; if the reference type definition is derived from the other type definition according to the derivation parameter. If the value of the parameter is &lt;code&gt;0&lt;/code&gt; (no bit is set to &lt;code&gt;1&lt;/code&gt; for the &lt;code&gt;derivationMethod&lt;/code&gt; parameter), the method will return &lt;code&gt;true&lt;/code&gt; if the other type definition can be reached by recursing any combination of {base type definition}, {item type definition}, or {member type definitions} from the reference type definition.</source>
          <target state="translated">문서의 스키마가 DTD이거나 문서와 연결된 스키마가없는 경우이 메서드는 항상 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 문서의 스키마가 XML 스키마 인 경우 참조 유형 정의가 파생 매개 변수에 따라 다른 유형 정의에서 파생 된 경우 메서드는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 매개 변수의 값이 &lt;code&gt;0&lt;/code&gt; 인 경우 ( &lt;code&gt;derivationMethod&lt;/code&gt; 매개 변수에 대해 비트가 &lt;code&gt;1&lt;/code&gt; 로 설정되지 않음 ), {base type definition}, {item type definition}의 조합을 반복하여 다른 유형 정의에 도달 할 수 있으면 메소드는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다. , 또는 참조 유형 정의의 {멤버 유형 정의}.</target>
        </trans-unit>
        <trans-unit id="57aa15be161d274da17fe9d39d1cfb694489d07e" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML DTD [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt;], the values are computed as follows:</source>
          <target state="translated">문서의 스키마가 XML DTD [ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt; ] 인 경우 값은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e10cb29a1e33b183a4131d16eb45066ea4a21c22" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면 스키마 유효성 검사 후 infoset 기여 (PSVI 기여라고도 함)를 사용하여 다음과 같이 값이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="8f795881894f367bf4d53a272b0c02b6372a7907" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;list&lt;/a&gt;.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ] 인 경우이 상수는 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;목록을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d81ff9adf73e073ce8071daca81533194b267a61" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt; union&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면이 상수는 단순 유형이 관련된 경우 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt;공용체를&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f779afced39b6f1300c741f0c131c9d3b3d3d63b" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt; extension&lt;/a&gt;.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ] 인 경우이 상수는 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt;확장에&lt;/a&gt; 의한 파생을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="31d86e81e617797ac0b52ef3cd63e328b705ec68" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt; restriction&lt;/a&gt; if complex types are involved, or a &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt; restriction&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면이 상수는 복잡한 유형이 포함 된 경우 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt;제한에&lt;/a&gt; 의한 파생을 나타내고 단순 유형이 포함 된 경우 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt;제한에&lt;/a&gt; 의한 파생을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="762fcdd3511f74261ffaaa36150e2a54b62d2512" translate="yes" xml:space="preserve">
          <source>If the domain includes at least one occurrence of the wildcard characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">도메인에 와일드 카드 문자 별표 ( &lt;code&gt;*&lt;/code&gt; ) 또는 물음표 ( &lt;code&gt;?&lt;/code&gt; )가 하나 이상 포함 된 경우 객체 이름은 패턴입니다. 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b1cec24c27c8efb590156606b357f3a860a3a802" translate="yes" xml:space="preserve">
          <source>If the domain is empty, it will be replaced in certain contexts by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the ObjectName is used.</source>
          <target state="translated">도메인이 비어있는 경우 특정 컨텍스트 에서 ObjectName이 사용되는 MBean 서버 의 &lt;em&gt;기본 도메인&lt;/em&gt; 으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="e3eaf7e155e25958dd79b0ca8cbf2ed30fa28298" translate="yes" xml:space="preserve">
          <source>If the driver does not support catalogs, it will silently ignore this request.</source>
          <target state="translated">드라이버가 카탈로그를 지원하지 않으면이 요청을 자동으로 무시합니다.</target>
        </trans-unit>
        <trans-unit id="49cc5727dc2cc7276bd0bd19c6deedc6d76a47a7" translate="yes" xml:space="preserve">
          <source>If the driver does not support schemas, it will silently ignore this request.</source>
          <target state="translated">드라이버가 스키마를 지원하지 않으면이 요청을 자동으로 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2ec76dcdc78eed5e3ce7b1d5f25a9c8e1223867e" translate="yes" xml:space="preserve">
          <source>If the drop mode is &lt;code&gt;DropMode.INSERT&lt;/code&gt;, the return value refers to the path that should become the parent of the new data, in which case &lt;code&gt;getChildIndex()&lt;/code&gt; indicates where the new item should be inserted into this parent path. A &lt;code&gt;null&lt;/code&gt; path indicates that no parent path has been determined, which can happen for multiple reasons:</source>
          <target state="translated">드롭 모드가 &lt;code&gt;DropMode.INSERT&lt;/code&gt; 인 경우 반환 값은 새 데이터의 부모가되어야하는 경로를 참조하며,이 경우 &lt;code&gt;getChildIndex()&lt;/code&gt; 는 새 항목이이 부모 경로에 삽입되어야하는 위치를 나타냅니다. &lt;code&gt;null&lt;/code&gt; 경로는 부모 경로는 여러 가지 이유로 발생할 수있는 결정되지 않았 음을 나타냅니다 :</target>
        </trans-unit>
        <trans-unit id="7e77cff0b1d03502e9a750d78a9d1c0130ccaafc" translate="yes" xml:space="preserve">
          <source>If the drop mode is &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;, &lt;code&gt;getChildIndex&lt;/code&gt; can be used to determine whether the drop is on top of the path itself (&lt;code&gt;-1&lt;/code&gt;) or the index at which it should be inserted into the path (values other than &lt;code&gt;-1&lt;/code&gt;).</source>
          <target state="translated">드롭 모드 인 경우 &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt; 의 , &lt;code&gt;getChildIndex&lt;/code&gt; 는 드롭 경로 자체 (의 상단에 있는지 여부를 결정하기 위해 사용될 수 &lt;code&gt;-1&lt;/code&gt; 이 경로로 삽입되는) 나 인덱스 (이외의 값 &lt;code&gt;-1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="561e98f303c7dc9236bf9ca6b8c00ec7bcd40ae7" translate="yes" xml:space="preserve">
          <source>If the editor is an instance of &lt;code&gt;DefaultEditor&lt;/code&gt;, the call if forwarded to the editor, otherwise this does nothing.</source>
          <target state="translated">편집기가 &lt;code&gt;DefaultEditor&lt;/code&gt; 의 인스턴스 인 경우 호출은 편집기로 전달되고 그렇지 않으면 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc2230764f1928dcd4435430ac5eacac22d06da" translate="yes" xml:space="preserve">
          <source>If the element contains end-of-content mark (the last &lt;code&gt;
 &quot;\n&quot;&lt;/code&gt; character in document), this character is not removed; instead, preceding leaf element is extended to cover the character. If the last leaf already ends with &lt;code&gt;&quot;\n&quot;,&lt;/code&gt; it is included in content removal.</source>
          <target state="translated">요소에 내용 끝 표시 (문서의 마지막 &lt;code&gt; &quot;\n&quot;&lt;/code&gt; 문자)가 포함 된 경우이 문자는 제거되지 않습니다. 대신 선행 리프 요소가 확장되어 문자를 덮습니다. 마지막 리프가 이미 &lt;code&gt;&quot;\n&quot;,&lt;/code&gt; 끝나는 경우 콘텐츠 제거에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f5906e0e63b8f49e34b6700f88bda4ec0d7f3b19" translate="yes" xml:space="preserve">
          <source>If the element is &lt;code&gt;null,&lt;/code&gt;&lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If the element structure would become invalid after the removal, for example if the element is the document root element, &lt;code&gt;
 IllegalArgumentException&lt;/code&gt; is thrown. If the current element structure is invalid, &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">요소가 &lt;code&gt;null,&lt;/code&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 throw됩니다. 제거 후 요소 구조가 무효화되는 경우 (예 : 요소가 문서 루트 요소 인 경우) &lt;code&gt; IllegalArgumentException&lt;/code&gt; 이 발생합니다. 현재 요소 구조가 유효하지 않으면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="75155a89667cb2237cd0f9e72cff17a55ac4b5e0" translate="yes" xml:space="preserve">
          <source>If the element name has a namespace prefix, the prefix will still be attached to the name.</source>
          <target state="translated">요소 이름에 네임 스페이스 접두사가있는 경우에도 접두사가 이름에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="292c4a6cbb150ef1068ec19842ed8e1904c50655" translate="yes" xml:space="preserve">
          <source>If the element name has a namespace prefix, the prefix will still be attached. Note that the attribute list provided will contain only attributes with explicit values (specified or defaulted): #IMPLIED attributes will be omitted.</source>
          <target state="translated">요소 이름에 네임 스페이스 접두사가있는 경우 접두사가 계속 첨부됩니다. 제공된 속성 목록에는 명시 적 값 (지정 또는 기본값)이있는 속성 만 포함됩니다. #IMPLIED 속성은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="632011698fb01f0e0fc60062d6f97f830dba4d90" translate="yes" xml:space="preserve">
          <source>If the elements contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</source>
          <target state="translated">요소가 하나의 부호의 무한대를 포함하고 중간 합계가 반대 부호의 무한대까지 오버플로되면 합계는 NaN 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925e78d915a458c34d3eb7516f6e0b5010e2a01e" translate="yes" xml:space="preserve">
          <source>If the elements contain infinities of opposite sign, the sum will be NaN.</source>
          <target state="translated">요소에 반대 부호의 무한대가 포함 된 경우 합계는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="be74757b15685dd5fdb4eea579602429c42b5b4c" translate="yes" xml:space="preserve">
          <source>If the elements contain one or more infinities, the sum will be infinite or NaN.</source>
          <target state="translated">요소에 하나 이상의 무한이 포함 된 경우 합계는 무한 또는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="1e256faf6974a8c97c36c1d2dc5a8b6122f7344d" translate="yes" xml:space="preserve">
          <source>If the elements of the source Vector of the ParameterBlock used to construct the RenderableImageOp are instances of RenderedImage, then the CRIF.create() method is called immediately using the original ParameterBlock. This provides a basis case for the recursion.</source>
          <target state="translated">RenderableImageOp를 생성하는 데 사용 된 ParameterBlock의 소스 Vector의 요소가 RenderedImage의 인스턴스 인 경우 원본 ParameterBlock을 사용하여 CRIF.create () 메서드가 즉시 호출됩니다. 이것은 재귀의 기본 사례를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="166569c27e8b2a7656f585d48975b7df17589d30" translate="yes" xml:space="preserve">
          <source>If the encoding has an historical name then that name is returned; otherwise the encoding's canonical name is returned.</source>
          <target state="translated">인코딩에 히스토리 이름이 있으면 해당 이름이 리턴됩니다. 그렇지 않으면 인코딩의 정식 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3837fdfef6f0110640afb54a092f9fb29173f9df" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, a &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">모든 비트를 읽기 전에 스트림의 끝이 발견되면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48c3f477e37a6d7f2bde864091bbef88c4c21567" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">모든 비트를 읽기 전에 스트림의 끝에 도달하면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2217350c5c68b3e5ab4a98715b4b5c48f6366d39" translate="yes" xml:space="preserve">
          <source>If the entire string has been read or skipped, then this method has no effect and always returns 0.</source>
          <target state="translated">전체 문자열을 읽거나 건너 뛴 경우이 메서드는 적용되지 않으며 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ece76de2aa9cb829e9b2c9714827801ca68dc1f" translate="yes" xml:space="preserve">
          <source>If the entry being considered was created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the given certificate is compared to the first element of that entry's certificate chain.</source>
          <target state="translated">항목이 호출에 의해 생성 된 것으로 간주되는 경우 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 다음 지정된 인증서는 그 엔트리의 인증서 체인의 첫 번째 요소로 비교된다.</target>
        </trans-unit>
        <trans-unit id="901709c9c92242d1f05529c7ed99092d836cea48" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. If the date-time set is out of the range of the standard &lt;code&gt;
 MS-DOS date and time format&lt;/code&gt;, the time will also be stored into zip file entry's extended timestamp fields in &lt;code&gt;optional
 extra data&lt;/code&gt; in UTC time. The &lt;a href=&quot;../../time/zoneid#systemDefault()&quot;&gt;&lt;code&gt;system default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the local date-time to UTC time.</source>
          <target state="translated">항목이 ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력되는 경우이 방법으로 설정된 마지막 수정 시간 은 zip 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되고 표준 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 인코딩 됩니다 . 날짜-시간 세트가 표준 &lt;code&gt; MS-DOS date and time format&lt;/code&gt; 의 범위를 벗어난 경우 시간은 UTC 시간의 &lt;code&gt;optional extra data&lt;/code&gt; 에 있는 zip 파일 항목의 확장 된 타임 스탬프 필드에도 저장됩니다 . &lt;a href=&quot;../../time/zoneid#systemDefault()&quot;&gt; &lt;code&gt;system default TimeZone&lt;/code&gt; &lt;/a&gt; UTC 시간 로컬 날짜 - 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b500fa31b73e631f7dcb75621d0a2f6abc54a397" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">항목이 ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력되는 경우이 방법으로 설정된 마지막 수정 시간 은 zip 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되고 표준 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 인코딩 됩니다 . &lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 는 MS-DOS 데이터와 시간에 신기원 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a00a113b23cd107c1f980e1846beabb40469342" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">항목이 ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력되는 경우이 방법으로 설정된 마지막 수정 시간 은 zip 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되고 표준 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 인코딩 됩니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 는 MS-DOS 데이터와 시간에 신기원 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85a5272c1bab15e68743538f438b05df60195e22" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;
 date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우 이는 zip 파일 항목 의 &lt;code&gt; date and time fields&lt;/code&gt; 에서 마지막으로 수정 한 시간입니다 . &lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 신기원 시간에 표준 MS-DOS 형식의 날짜와 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ccafee62ee3362796ffa2f54139e7599780958" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우, 이것은 ZIP 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간입니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 신기원 시간에 표준 MS-DOS 형식의 날짜와 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab32364343d6a000b40b013685c0fce3d0cb517" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽은 경우 확장 된 타임 스탬프 필드가있는 경우 zip 파일 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 에서 마지막으로 수정 한 시간입니다 . 그렇지 않으면 항목의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간을 읽습니다 . &lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 을 사용하여 표준 MS-DOS 형식의 날짜 및 시간을 기점 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b289b42cb002e533856d62e0fbbde21b7d11a5b" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우 확장 된 시간 소인 필드가있는 경우 ZIP 파일 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 에서 마지막 수정 시간입니다 . 그렇지 않으면 항목의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간을 읽습니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 은 표준 MS-DOS 형식의 날짜 및 시간을 에포크 시간으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="05d613b0e17c16e0c66c734b0a98a9ba4f184306" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise, the last modification time is read from entry's standard MS-DOS formatted &lt;code&gt;date and time fields&lt;/code&gt;.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽은 경우 확장 된 타임 스탬프 필드가있는 경우 zip 파일 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 에서 마지막으로 수정 한 시간입니다 . 그렇지 않으면 항목의 표준 MS-DOS 형식 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e02b2a061b3320b01237249ddfaa9eb0520ac284" translate="yes" xml:space="preserve">
          <source>If the event doesn't get filtered, it will try to insert content into the text editor. The content is fetched from the command string of the ActionEvent. The text entry is done through the &lt;code&gt;replaceSelection&lt;/code&gt; method on the target text component. This is the action that will be fired for most text entry tasks.</source>
          <target state="translated">이벤트가 필터링되지 않으면 텍스트 편집기에 콘텐츠 삽입을 시도합니다. 컨텐츠는 ActionEvent의 명령 문자열에서 가져옵니다. 텍스트 입력은 &lt;code&gt;replaceSelection&lt;/code&gt; 을 통해 수행됩니다. 대상 텍스트 구성 요소 메서드를 . 이것은 대부분의 텍스트 입력 작업에 대해 실행되는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="44db14d1e9cdb3209ffe191f5a2a3430583832df" translate="yes" xml:space="preserve">
          <source>If the event involved an exception, this will be the exception object. Otherwise null.</source>
          <target state="translated">이벤트에 예외가 포함 된 경우 예외 개체가됩니다. 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="636af865dd5520f93c482ef1d513964eb35efb7f" translate="yes" xml:space="preserve">
          <source>If the event parameter is &lt;code&gt;null&lt;/code&gt; the behavior is unspecified and may result in an exception.</source>
          <target state="translated">이벤트 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 동작이 지정되지 않고 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1991d1905a17c3a61e8189297ee3cdafb502d7" translate="yes" xml:space="preserve">
          <source>If the event type is not one of the above, nothing happens.</source>
          <target state="translated">이벤트 유형이 위 중 하나가 아니면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04ee175a91380bcfff6774332dbdc8f91673dbd2" translate="yes" xml:space="preserve">
          <source>If the exact product of the first two arguments is infinite (in other words, at least one of the arguments is infinite and the other is neither zero nor NaN) and the third argument is an infinity of the opposite sign, the result is NaN.</source>
          <target state="translated">처음 두 인수의 정확한 곱이 무한대 (즉, 인수 중 하나 이상이 무한이고 다른 인수가 0도 NaN도 아님)이고 세 번째 인수가 반대 부호의 무한대이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="e95e52b95a3d17be2a361085bc902faa16c60d26" translate="yes" xml:space="preserve">
          <source>If the expression contains a function reference, the function will be found through the &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt; set with &lt;a href=&quot;#setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver)&quot;&gt;&lt;code&gt;setXPathFunctionResolver(XPathFunctionResolver resolver)&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the function resolver is undefined or the function resolver returns &lt;code&gt;null&lt;/code&gt; for the function.</source>
          <target state="translated">표현식에 함수 참조가 포함 된 경우 &lt;a href=&quot;#setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver)&quot;&gt; &lt;code&gt;setXPathFunctionResolver(XPathFunctionResolver resolver)&lt;/code&gt; &lt;/a&gt; 설정된 &lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; 를&lt;/a&gt; 통해 함수 를 찾습니다 . &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 함수 해결이 정의되지 않은 경우 발생하거나 기능 확인자 반환 &lt;code&gt;null&lt;/code&gt; 기능을 위해.</target>
        </trans-unit>
        <trans-unit id="43696688f3c4489c7b41ec9b95dff40a7fa60072" translate="yes" xml:space="preserve">
          <source>If the expression contains a function reference, the function will be found through the &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the function resolver is undefined or the function resolver returns &lt;code&gt;null&lt;/code&gt; for the function.</source>
          <target state="translated">표현식에 함수 참조가 포함되어 있으면 &lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; 를&lt;/a&gt; 통해 함수를 찾습니다 . &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 함수 해결이 정의되지 않은 경우 발생하거나 기능 확인자 반환 &lt;code&gt;null&lt;/code&gt; 기능을 위해.</target>
        </trans-unit>
        <trans-unit id="8ec91836ab8810be357b49e4f3c052ec4bf73ac1" translate="yes" xml:space="preserve">
          <source>If the expression contains a variable reference, its value will be found through the &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt; set with &lt;a href=&quot;#setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver)&quot;&gt;&lt;code&gt;setXPathVariableResolver(XPathVariableResolver resolver)&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the variable resolver is undefined or the resolver returns &lt;code&gt;null&lt;/code&gt; for the variable. The value of a variable must be immutable through the course of any single evaluation.</source>
          <target state="translated">표현식에 변수 참조가 포함 된 경우 해당 값은 &lt;a href=&quot;#setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver)&quot;&gt; &lt;code&gt;setXPathVariableResolver(XPathVariableResolver resolver)&lt;/code&gt; &lt;/a&gt; 설정된 &lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; 를&lt;/a&gt; 통해 검색 됩니다. &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 변수 리졸버가 정의되어있는 경우 발생하거나 해결 반환 &lt;code&gt;null&lt;/code&gt; 변수에 대한. 변수의 값은 단일 평가 과정에서 불변이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ac27a65340aff2ce4aa55c84684d42f7fc9702ed" translate="yes" xml:space="preserve">
          <source>If the expression contains a variable reference, its value will be found through the &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the variable resolver is undefined or the resolver returns &lt;code&gt;null&lt;/code&gt; for the variable. The value of a variable must be immutable through the course of any single evaluation.</source>
          <target state="translated">표현식에 변수 참조가 포함 된 경우 해당 값은 &lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; 를&lt;/a&gt; 통해 찾습니다 . &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 변수 리졸버가 정의되어있는 경우 제기하거나 해결 반환되는 &lt;code&gt;null&lt;/code&gt; 변수에 대한. 변수 값은 단일 평가 과정에서 변경 불가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0292adc0114844d25fb79e16b7258d6d3885abd" translate="yes" xml:space="preserve">
          <source>If the extension class loader cannot be found then the system class loader is used; if there is no system class loader then the bootstrap class loader is used.</source>
          <target state="translated">확장 클래스 로더를 찾을 수 없으면 시스템 클래스 로더가 사용됩니다. 시스템 클래스 로더가없는 경우 부트 스트랩 클래스 로더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6968b385e002c9508a424a478292c0f3a7af81" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the range of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 이면 1에서 7까지의 요일 범위가 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5c19fc73e0fc2d097b24a11cffd6f4ae4696359b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the value of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 이면 1에서 7까지의 요일 값이 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="30d9439a6bb009c979b0800716929ef61f2bbd69" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; 인&lt;/a&gt; 경우이 메소드는 true를 리턴합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="326c5765ea79518cbefcc0303c7d41108e792d2b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the range of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면 1에서 12까지의 월 범위가 반환됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="af240bad736f05e53adae955dd58de67cb50462f" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the value of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면 1에서 12까지의 월 값이 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4fe971066ffd7c4b8626dd60c34bb8f8261cfed9" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면이 메소드는 true를 리턴합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cbe7e72fb8b0010865d68d0c08c6481722f84e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the range. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 필드의 범위를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="184058e0a14902aa21c927d78bf2821afd7ffb8f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the value of the era. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 의 필드는 시대의 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1953db0f99dd40e5aaa224b3ed2d92f821f4fad2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 의 필드는 true를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5df5ba306c3a00473938e546303760434732261a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. 지원되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddb65541050763763b556e80a29c16db72c7248" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="871d99f928633d452b234c707859c60ee439a250" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 조정이 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 에 일치하는 방법에 따라 작동합니다 &lt;a href=&quot;localdate#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt; . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="cc3692f941d5abe057e214a3bd9f234905a09651" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 에 일치하는 방법에 따라 작동합니다 &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt; . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1d4babbf0823e08d2dba83490653149a8a5cf2ed" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The supported fields behave as follows:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다. 지원되는 필드는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="654ffbe0ee041234f33cf275c87fc4c9fc7c6dd4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="073a987d8c755e83cfc6ffb42e22775ce7412bb2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 날짜를 기준으로 유효 값을 반환합니다 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="393ab92db0d7f28b2848265a88f15c6d53af21b2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 발생 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="7152b3b52d7c7f0f4904764283f2e7cc4e36acbd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="67d10135df9a9ec6dcec81f7c4eba9e088b27dc9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="241448bc71c4585fd6b57179f68b0b3ae2b77f80" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4394383d7f696594ca101d030728c860c4bd2767" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 날짜를 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="55f31e63ce0b6d34f732d6c74159b03dff5fbefe" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 달 일을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3d5a1d9d7bbcd893d7dda7838ecb8f4a2331eaea" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="54d4291388dc2b83820f747cb1f95091292f696d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e757166ab7f790e16750f19e7591a3771d8323b1" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 올해 개월을 기준으로 유효한 값을 반환합니다 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="07988f9ebdc9aba8f17f1634be192d7cbfc13f5d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해 개월을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="24967a514d85ca0fb445207b1151d9d0b3e22369" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해에 따라 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b3a122466042d935dfadf2919be12e5c6bf577cb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b2fae4d33d968604493905d86ff128c82e5db2f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 발생 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="552594823755dd323e34fbb36aa82bd02dc7ccec" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="64682870ad58c05c116e810cd345d87fe71b6bca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e53df72b9538f5704d56c85109a2837d5a0400cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 날짜를 기준으로 유효 값을 반환합니다 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="32c54db3dedc37f0421eb1580db3b740ec121cad" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 날짜를 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="11ea794a31defe3e3eefa9ea5db21eca50570400" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a90c6eb29cbac028e8449f9cf54d00261c219feb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5b5f3e15dbf7f02cadaff2b1f715b8a83fed50ca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2d7280f2ef05621f8965764c134012686323f8c9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a08bb7dfd7f2733af861740d800b7ce9f70eb5cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f2ea46b126ff3b5bdbf666ca3c46b71e50576dc7" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3f81a778997a088523214d2edc7a7aab7a300ca4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ce1690eace7e2c6d89cc928ca7a7a051f9a8d0f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 달 일을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="54c277810f3ed7c547f4b1ad6fd3fb8f9a746292" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="20e764af5b165d57d63cb3a6753fd7d4d9d38420" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bbfa08249a8a681a77ac31ded9b0970961cb7e45" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="216d1b40d29dcd13ae455e39ff25a34173b680bc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="89af7f61649fef38a7f170c1bd0ab908cfde7464" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f135da292374c58a63e9a7dd6bf4f22cdbf128fc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="66a31e186370c87394aabeac098a9be857ade9fd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1a78917caede284548be462696171d8a8df88818" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해에 따라 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="638fba149e2f9605d4c8dd06cfefd8163837f176" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bc96611b6dd2d22d3132d6d3df53e51b38124d7a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 올해 개월을 기준으로 유효한 값을 반환합니다 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5f2e16d3207b8a1b377b13995b5829979baa3c06" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해 개월을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5fda7020a7bae43a5df2b5286206bb91d72d039d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="88d03525f1042dd0011a22419c6df4c5121eba14" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a0124fd3059f644ca04188c31653732caf32a08f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="0337a2eda7a472dc0aa83a7e1eef644d5a370e32" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4046ccaca6ad2d1bf0b7e5c2e124396f1812f96d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns the value of the offset. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 의 필드 오프셋의 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="09800c7a5d51ab3ac1ecbfa59a39761992b8d783" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 의 필드는 true를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bcdaaec98194652eaec2e755f354592d8a5f1fa2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt;여기에서 쿼리가 구현됩니다. 지원되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26f815de83bf9d85fe8094749e5ea200739939d5" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localdatetime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d8816d4bddc205a3c0266b4706842519edca858" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30e6967c28e9ee1cc43dcf0ccc34a23008296abc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다 . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a927c94cc558aa44e673d3c09b5dede6b4bbec9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edd9f66100a0f8ebdeaf7afd13edd4d404894480" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;#plusDays(long)&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 날짜 단위는 &lt;a href=&quot;localdate#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가됩니다 . 시간 단위는 &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 에 따라 추가되며 &lt;a href=&quot;#plusDays(long)&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일하게 추가 된 일 단위의 오버플로가 있습니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="f5cba436d7af3b0ad553fc0358e491b4ffeb23a3" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 날짜 단위는 &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가됩니다 . 시간 단위는 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가되며 , 일 수의 오버플로는 &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt; 사용과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="87edabfd23bcd4b5580257d424970351a200d0e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The supported fields behave as follows:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 지원되는 필드는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7d28f15788411edaf2c4769963134a70f9a51014" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The zone is not part of the calculation and will be unchanged in the result. The calculation for date and time units differ.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 영역은 계산의 일부가 아니며 결과에서 변경되지 않습니다. 날짜 및 시간 단위에 대한 계산이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="472a2bad58441686158034a719ecf7233180fcd9" translate="yes" xml:space="preserve">
          <source>If the field is declared &lt;code&gt;volatile&lt;/code&gt; then the returned VarHandle will override access to the field (effectively ignore the &lt;code&gt;volatile&lt;/code&gt; declaration) in accordance to its specified access modes.</source>
          <target state="translated">필드가 &lt;code&gt;volatile&lt;/code&gt; 로 선언 되면 반환 된 VarHandle이 필드에 대한 액세스를 재정의합니다 (효과적으로 &lt;code&gt;volatile&lt;/code&gt; 지정된 액세스 모드에 따라 선언을 ).</target>
        </trans-unit>
        <trans-unit id="df5997d9cb9eb98daf0677e44c78da78084843dc" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is obtained according to the preceding rules.</source>
          <target state="translated">필드가 다음 유형으로 숨겨진 경우 &lt;code&gt;obj&lt;/code&gt; 지면 필드 값은 이전 규칙에 따라 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3cd0fa2a6c549544bf0fa17d3fe9a0bbdad3a534" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is set according to the preceding rules.</source>
          <target state="translated">필드가 &lt;code&gt;obj&lt;/code&gt; 유형에 숨겨져있는 경우 값은 이전 규칙에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c8f06458338d0982fde844f74e3eac7907ffd72d" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the field determines whether and how to adjust the instant.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로 . 이 경우 필드는 순간을 조정할지 여부와 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="bc13b792f3c5838d3770d636dc87567d506bc218" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 첫번째 인자로.</target>
        </trans-unit>
        <trans-unit id="593408760a93df2aae450a2a246b1f8f655869de" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="84111e9c7052aea445fc84ff88640c7d9d47a3e1" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 값을 얻을 수 있는지 여부와 값이 나타내는 것은 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0976d6ec775eae314c44e1cc501085eba97650" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="8bfc158b937ea3897727206425819d75e46f302c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the field is supported is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 필드가 지원되는지 여부는 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7688528113c7572e4ebfde7d3d5c748187dbd155" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the range can be obtained is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 범위를 얻을 수 있는지 여부는 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="9dc945edaeb99a9dd905b6958af0da2b698eb2ff" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="1bc2facd61e2bb2d253a7e2d751714a8d91fd304" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the unit determines whether and how to perform the addition.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoUnit&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 이 경우 장치는 추가 수행 여부와 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3745b108d29fe526d4efe7b06863f59e4b41c30c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoUnit&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="7c31bf8c81eb5e3fa5966507ecfeb7eeb414a7a3" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned VarHandle is operated on, the field's declaring class will be initialized, if it has not already been initialized.</source>
          <target state="translated">필드가 정적이고 반환 된 VarHandle이 작동되는 경우 필드의 선언 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="73f48c353a2b4ef722c15d4cc5583b25df30a788" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">필드가 정적이고 리턴 된 메소드 핸들이 호출되면 필드의 클래스가 초기화되지 않은 경우 필드 클래스가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f75aa0d9bdab9beccdb246276fa853bdf88f9fa1" translate="yes" xml:space="preserve">
          <source>If the field type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then numeric and atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">필드 유형이 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 이면 숫자 및 원자 업데이트 액세스 모드는 비트 표현을 사용하여 값을 비교합니다 &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt; 각각 &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt; 및 Double.doubleToRawLongBits (double) 참조 ).</target>
        </trans-unit>
        <trans-unit id="9a766268cd602d31dba43c646e17e366517c908b" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0.</source>
          <target state="translated">파일이 이미 존재하고 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열리면 길이가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="929d4fca608fb0e25c4e8a63977f3cccb4c4213a" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">파일이 이미 존재하고 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열리면 길이가 0으로 잘립니다. 파일이 &lt;a href=&quot;#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 용으로 만 열린 경우이 옵션은 무시됩니다. 액세스 .</target>
        </trans-unit>
        <trans-unit id="99de1988747f1a4d19117e077c897d899a759367" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">파일이 이미 존재하고 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열린 경우에는 길이가 0으로 잘립니다.이 옵션은 파일이 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 액세스 용으로 만 열린 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="717bfba6c0a90a03523ab0b13a3750e80f9e6288" translate="yes" xml:space="preserve">
          <source>If the file does not reside on a local device then no such guarantee is made.</source>
          <target state="translated">파일이 로컬 장치에 없으면 그러한 보증이 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c9b9ed3b31f95435fd26b9b50e781fb7b10f8ba" translate="yes" xml:space="preserve">
          <source>If the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">파일이 존재하지만 일반 파일이 아닌 디렉토리 인 경우 존재하지 않지만 작성할 수 없거나 다른 이유로 열 수없는 경우 &lt;code&gt;FileNotFoundException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f72ad9bda52a7b14dd7371372743b4037fafc486" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist.</source>
          <target state="translated">파일이 디렉토리이면 디렉토리가 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리 작성시 작성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 특수 항목 만 존재할 경우 디렉토리는 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d8fa9367e398fcca0e927495045f7052187e809e" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;#walkFileTree(java.nio.file.Path,java.util.Set,int,java.nio.file.FileVisitor)&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">파일이 디렉토리이면 디렉토리가 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리가 생성 될 때 생성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 디렉토리는 특수 항목 만 존재할 때 비어있는 것으로 간주됩니다. 이 메소드는 &lt;a href=&quot;#walkFileTree(java.nio.file.Path,java.util.Set,int,java.nio.file.FileVisitor)&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용 하여 디렉토리 및 디렉토리의 모든 항목 또는 전체 항목을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c1117a6df1c8b656d3b8ee4f35129ed11c6504" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">파일이 디렉토리 인 경우 디렉토리는 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리 작성시 작성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 특수 항목 만 존재할 경우 디렉토리는 비어있는 것으로 간주됩니다. 이 메소드를 &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용 하여 디렉토리 및 디렉토리의 모든 항목 또는 전체를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d651a40c8a6027fa645d02154642d3d0cbb9614" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">파일이 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열리면 바이트는 시작이 아닌 파일 끝에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7dbd0c6e9ab04a8789ef0e83e00003ffa2ee9662" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">파일이 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열린 경우 바이트는 시작이 아닌 파일의 끝에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d2a8154b6e04db066d371ce68d85675117b48d" translate="yes" xml:space="preserve">
          <source>If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.</source>
          <target state="translated">다른 프로그램이 쓰기 액세스를 위해 파일을 연 경우 파일 끝에 쓰는 것이 원자적인 경우 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
