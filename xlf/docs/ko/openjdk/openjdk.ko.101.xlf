<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="1c155ad46a4245a542e0a856a2e04822b42fb9f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;returnType&lt;/code&gt; is not one of the types defined in &lt;a href=&quot;xpathconstants&quot;&gt;&lt;code&gt;XPathConstants&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;returnType&lt;/code&gt; 이가 에 정의 된 유형 중 하나가 아닌 &lt;a href=&quot;xpathconstants&quot;&gt; &lt;code&gt;XPathConstants&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="d860614074042f19bdf291701426974c3c57e4a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;row&lt;/code&gt; is &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt; this will have no effect.</source>
          <target state="translated">경우 &lt;code&gt;row&lt;/code&gt; 의 &amp;lt;0&amp;gt; = &lt;code&gt;getRowCount&lt;/code&gt; 이 효과가 없을 것이다.</target>
        </trans-unit>
        <trans-unit id="876d8a672b3c54e715d8e73f684241ce161aa28e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s.length&lt;/code&gt; 가 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 문자 &lt;code&gt;s[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;s[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 문자는 &lt;code&gt;s[s.length-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9e4b1baa5111d66d53cd12fc271e18655498ac09" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, one byte is written, the low-order byte, in exactly the manner of the &lt;code&gt;writeByte&lt;/code&gt; method . The high-order eight bits of each character in the string are ignored.</source>
          <target state="translated">경우 &lt;code&gt;s.length&lt;/code&gt; 가 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 문자 &lt;code&gt;s[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;s[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 문자는 &lt;code&gt;s[s.length-1]&lt;/code&gt; 입니다. 각 문자에 대해 &lt;code&gt;writeByte&lt;/code&gt; 메소드 와 정확히 같은 방식으로 하위 바이트 인 1 바이트가 기록 됩니다. 문자열에서 각 문자의 상위 8 비트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="edcdda7ec2d8edbea83d4e8f71c2458f937626bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, one byte is written, the low-order byte, in exactly the manner of the &lt;code&gt;writeByte&lt;/code&gt; method. The high-order eight bits of each character in the string are ignored.</source>
          <target state="translated">경우 &lt;code&gt;s.length&lt;/code&gt; 가 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 문자 &lt;code&gt;s[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;s[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 문자는 &lt;code&gt;s[s.length-1]&lt;/code&gt; 입니다. 각 문자에 대해 정확히 &lt;code&gt;writeByte&lt;/code&gt; 메서드 와 같은 방식으로 하위 바이트 인 1 바이트가 기록 됩니다. 문자열에서 각 문자의 상위 8 비트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e875e2a67d01ff828275b31d43c1fbd127c980d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="44817af6998c4077db388be5b4a7890f5a06339e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are appended.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; , 4 개 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="990d1368ff7f5774e8459cd4e9be500eb83cc4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are inserted into this sequence.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 , 이 순서에 4 개의 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="b05ca4901f2ddfb6f0df8f458f94e1208be8876d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method appends characters as if the s parameter was a sequence containing the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 ,이 메소드는 s 파라미터가 4 개의 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 를 포함한 순서 인 것처럼 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f17a7925b555b07f1177d7e0b04970042d705c0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method inserts characters as if the s parameter was a sequence containing the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 ,이 메소드는 s 파라미터가 4 개의 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 을 포함한 순서 인 것처럼 문자를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="9aac27d78dce887df2392eaea3ecd3f3fa4c1f8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setDestinationOffsets&lt;/code&gt; has not been called, a &lt;code&gt;Point&lt;/code&gt; with zero X and Y values is returned (which is the correct value).</source>
          <target state="translated">경우 &lt;code&gt;setDestinationOffsets&lt;/code&gt; 가 호출되지하는 &lt;code&gt;Point&lt;/code&gt; 제로의 X 및 Y 값은 (올바른 값이다)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="f3a9e603b0a4b8521e4750e1c066ac967b23512c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 0 is returned (which is the correct value).</source>
          <target state="translated">&lt;code&gt;setSourceSubsampling&lt;/code&gt; 이 호출되지 않은 경우 0이 리턴됩니다 (올바른 값).</target>
        </trans-unit>
        <trans-unit id="79ac09906fe716bce01c69681d75a4bf9a9cb03d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 1 is returned (which is the correct value).</source>
          <target state="translated">&lt;code&gt;setSourceSubsampling&lt;/code&gt; 이 호출되지 않은 경우 1이 리턴됩니다 (올바른 값).</target>
        </trans-unit>
        <trans-unit id="aa1ac4e940630f846fd22734fc11fce22cf0121f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setToolTipText&lt;/code&gt; has been invoked with a non-&lt;code&gt;null&lt;/code&gt; value, it will be returned, otherwise</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 &lt;code&gt;setToolTipText&lt;/code&gt; 가 호출 된 경우 반환됩니다. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="61566ceca2a0f3c6f13616e2fc6f7a73b100c4e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sites&lt;/code&gt; contains a null element, a &lt;code&gt;NullPointerException&lt;/code&gt; will be raised. In this case, some non-null elements in the array may be processed before the method returns abnormally. Which elements these are (if any) is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;sites&lt;/code&gt; 에 null 요소가 포함되어 있으면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다. 이 경우 배열에서 null이 아닌 일부 요소는 메서드가 비정상적으로 반환되기 전에 처리 될 수 있습니다. 어떤 요소가 존재하는지는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cee89be3aeb95368cd40a9cab8c4abdc56959164" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream and &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;snk&lt;/code&gt; 연결되지 않은 파이프 입력 스트림이고 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 출력 스트림, 그들은 호출 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="690341647fe6d76e88ef315850f5a25397916209" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader and &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;snk&lt;/code&gt; 미 접속의 파이프 리더이고 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 작가, 그들은 호출 중 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="f9c5366be534f93ab5f5deefe308b27ed6664cd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="3f3a2230d84b641f83bf303d40e79f1f03207242" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is not an instance of one of the classes returned by &lt;code&gt;getInputTypes&lt;/code&gt;, the method should simply return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 가 &lt;code&gt;getInputTypes&lt;/code&gt; 에 의해 리턴 된 클래스 중 하나의 인스턴스가 아닌 경우 , 메소드는 단순히 &lt;code&gt;false&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="637f0a7792b7cb0bc9a73c24b4e0f9994163e5c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;returnType&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 또는 &lt;code&gt;returnType&lt;/code&gt; 이가 있다 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="219f0aba2e1ad229cd0601cb06d21c32b8f7d289" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown and the destination array is not modified.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 , &lt;code&gt;NullPointerException&lt;/code&gt; 가 Throw되어 목적지 배열은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d71167d52ef22cb2f16571454a6827b101e0c9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream and &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 출력 스트림이고 &lt;code&gt;snk&lt;/code&gt; 연결되지 않은 파이프 입력 스트림, 그들은 호출 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="760f4c540dae14e4e4ea567bb935f8fcce39cb15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer and &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 작가이며, &lt;code&gt;snk&lt;/code&gt; 연결되지 않은 파이프 리더, 그들은 호출 중 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="c619334825864b10343e14e3a5fa2edbf88f1438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is &amp;plusmn;&lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, then a zero with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn;이다 &lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; 가&lt;/a&gt; 와 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기, 같은 기호 다음 제로해야한다는 등의 값이 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fae5b0093d13f14219d9322f18e9441f961ca477" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is &amp;plusmn;&lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, then a zero with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn;이다 &lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; 가&lt;/a&gt; 와 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기, 같은 기호 다음 제로해야한다는 등의 값이 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f66998e543c1a12b2ca918a211e06eae5f94b1c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is equal to &amp;plusmn; &lt;a href=&quot;double#MAX_VALUE&quot;&gt;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a larger magnitude, an infinity with same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn; 같다 &lt;a href=&quot;double#MAX_VALUE&quot;&gt; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;direction&lt;/code&gt; 결과는 더 큰 크기로 동일한 부호를 갖는 무한대가되어야되도록 값 가지고 &lt;code&gt;start&lt;/code&gt; 리턴된다.</target>
        </trans-unit>
        <trans-unit id="a161a170f19a8906de8c9a6cfd3d5e37f8f5ff13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is equal to &amp;plusmn; &lt;a href=&quot;float#MAX_VALUE&quot;&gt;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a larger magnitude, an infinity with same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn; 같다 &lt;a href=&quot;float#MAX_VALUE&quot;&gt; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;direction&lt;/code&gt; 결과는 더 큰 크기로 동일한 부호를 갖는 무한대가되어야되도록 값 가지고 &lt;code&gt;start&lt;/code&gt; 리턴된다.</target>
        </trans-unit>
        <trans-unit id="a58cc90d3a573be11a8ea4b0883f3c2086b63b6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is infinite and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, &lt;a href=&quot;double#MAX_VALUE&quot;&gt;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;&lt;/a&gt; with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 무한과 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기, 있어야한다고 같은 값이 &lt;a href=&quot;double#MAX_VALUE&quot;&gt; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 같은 기호로 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae7182c34098ff9d6f56022f88e1e7fdd3a318a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is infinite and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, &lt;a href=&quot;float#MAX_VALUE&quot;&gt;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;&lt;/a&gt; with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 무한과 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기,해야한다는 등의 값이 &lt;a href=&quot;float#MAX_VALUE&quot;&gt; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; 을&lt;/a&gt; 같은 기호로 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6cd80221ac94b2f2e71b197d42d75c47e15af2c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;strict&lt;/code&gt; is false, when a tag that breaks flow, (&lt;code&gt;TagElement.breaksFlows&lt;/code&gt;) or trailing whitespace is encountered, all whitespace will be ignored until a non whitespace character is encountered. This appears to give behavior closer to the popular browsers.</source>
          <target state="translated">경우 &lt;code&gt;strict&lt;/code&gt; 거짓하는 휴식 시간이 흐를 것을 태그 (시 &lt;code&gt;TagElement.breaksFlows&lt;/code&gt; 공백 이외의 문자가 발견 될 때까지) 나 말미에 공백이 발견, 공백은 모두 무시됩니다. 이것은 인기있는 브라우저에 더 가까운 동작을 제공하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="dd9e9926b4084569dcc965ce6b61db0e47d85ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a distinguished name, in RFC 2253 format.</source>
          <target state="translated">&lt;code&gt;subjectDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 는 RFC 2253 형식의 식별 명을 포함 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8333161ec6b6561928b6f53c8cfefeeee4ccdf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded distinguished name, as defined in X.501. For the ASN.1 notation for this structure, see &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;subjectDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ea050f10d06248bcf9421ca5fbce2a0e9eb8454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded distinguished name, as defined in X.501. For the ASN.1 notation for this structure, see &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;subjectDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2013740722fd95a1604400c614bd63582e466a8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectKeyID&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded value corresponding to the contents of the extension value (not including the object identifier, criticality setting, and encapsulating OCTET STRING) for a SubjectKeyIdentifier extension. The ASN.1 notation for this structure follows.</source>
          <target state="translated">&lt;code&gt;subjectKeyID&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 SubjectKeyIdentifier 확장에 대한 확장 값의 내용 (개체 식별자, 중요도 설정 및 OCTET STRING 캡슐화 제외)에 해당하는 단일 DER 인코딩 값을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8a2d56ad412e7e8bed4d2deae78a648b54d9910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;switchPoints&lt;/code&gt; contains a null element, a &lt;code&gt;NullPointerException&lt;/code&gt; will be raised. In this case, some non-null elements in the array may be processed before the method returns abnormally. Which elements these are (if any) is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;switchPoints&lt;/code&gt; 에 null 요소가 포함되어 있으면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다. 이 경우 배열에서 null이 아닌 일부 요소는 메서드가 비정상적으로 반환되기 전에 처리 될 수 있습니다. 어떤 요소가 존재하는지는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="73066e095387b022012986549b34f1448bd7aa6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout&lt;/code&gt; is greater than 0, the method returns after &lt;code&gt;timeout&lt;/code&gt; milliseconds even if there is no change in state. In that case, this method returns &lt;code&gt;false&lt;/code&gt;; otherwise it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;timeout&lt;/code&gt; 0보다 큰 경우, 이후의 메소드가 리턴 &lt;code&gt;timeout&lt;/code&gt; 상태에 변화가 밀리가없는 경우에도. 이 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9110736d0ba8beddd891578c4cd267d3ed2df9b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trayIcon&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or was not added to the system tray, no exception is thrown and no action is performed.</source>
          <target state="translated">경우 &lt;code&gt;trayIcon&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 또는 시스템 트레이에 첨가되지 않은, 예외가 발생되지 않고, 처리는 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="1dc73700c68c63f248dae219cde824ef4b8f9196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; is returned, the JDBC driver must support the returning of auto-generated keys for at least SQL INSERT statements</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 반환되면, JDBC 드라이버의 자동 생성 키의 반환을 지원해야합니다 적어도 SQL INSERT 문에서</target>
        </trans-unit>
        <trans-unit id="06115dacf5b34fb8d3c0d2c47a4c8739954912e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the auto-scrolling is enabled.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 자동 스크롤을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a6d295804593883ad2ce93da589746015b3c79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching whenever it can.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 가능한 때에 캐쉬 (cache)를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="9165b89186b82d1302645d783c2a0c1050d0333c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching whenever it can. If &lt;code&gt;false&lt;/code&gt;, the protocol must always try to get a fresh copy of the object.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 가능한 때에 캐쉬 (cache)를 사용할 수있다. 경우 &lt;code&gt;false&lt;/code&gt; , 프로토콜은 항상 객체의 새로운 카피를 취득 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28bab1545813399b6959c7a48698b477c2089f22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol will automatically follow redirects.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 자동적으로 리다이렉트 (redirect)에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e68e3758b38fae66da1ed8095766c26a46ef65a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol will automatically follow redirects. If &lt;code&gt;false&lt;/code&gt;, the protocol will not automatically follow redirects.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 자동적으로 리다이렉트 (redirect)에 따릅니다. 경우 &lt;code&gt;false&lt;/code&gt; , 프로토콜은 자동으로 리디렉션을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c2bff42d38b3e74f0a77d30306aa66a141445c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;URL&lt;/code&gt; is being examined in a context in which it makes sense to allow user interactions such as popping up an authentication dialog.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 &lt;code&gt;URL&lt;/code&gt; 은 이 인증 대화 상자를 팝업으로 사용자 상호 작용은 허용하는 의미가있는 맥락에서 검토되고있다.</target>
        </trans-unit>
        <trans-unit id="1347facf72554ede8e0ebdf4e21d8496b6b672a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;URL&lt;/code&gt; is being examined in a context in which it makes sense to allow user interactions such as popping up an authentication dialog. If &lt;code&gt;false&lt;/code&gt;, then no user interaction is allowed.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 인증 대화 상자 팝업과 같은 사용자 상호 작용을 허용하는 컨텍스트 에서이 &lt;code&gt;URL&lt;/code&gt; 을 검사합니다. &lt;code&gt;false&lt;/code&gt; 인 경우 사용자 상호 작용이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c993a9c8cd84f954007dac990e0fc740f486086" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this glyph absorbs all extra space at this and lower priority levels when it grows.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 그래프는 여분의 영역을 모두 흡수하고 성장하면 우선 순위 레벨을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="976048025c34666d0a2f1d2690ac8cc5cc20d7e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;,this glyph absorbs all remaining shrinkage at this and lower priority levels as it shrinks.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 그래프는이 축분을 모두 흡수하고 축소로 우선 순위 레벨을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="d0224176165c2117154a3a0f83358aa57f06cb34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uris&lt;/code&gt; is empty, system property &lt;code&gt;javax.xml.catalog.files&lt;/code&gt;, as defined in &lt;a href=&quot;catalogfeatures&quot;&gt;&lt;code&gt;CatalogFeatures&lt;/code&gt;&lt;/a&gt;, will be read to locate the initial list of catalog files.</source>
          <target state="translated">&lt;code&gt;uris&lt;/code&gt; 가 비어 있으면 &lt;a href=&quot;catalogfeatures&quot;&gt; &lt;code&gt;CatalogFeatures&lt;/code&gt; 에&lt;/a&gt; 정의 된 시스템 속성 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 를 읽어 카탈로그 파일의 초기 목록을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="adee4dfa9a0b08ac726e589fa9dfc1c09a04aa62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useNative&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;color&lt;/code&gt; is created by using &lt;code&gt;Color.decode&lt;/code&gt; to convert the &lt;code&gt;
 String&lt;/code&gt; into a &lt;code&gt;Color&lt;/code&gt;. If &lt;code&gt;decode&lt;/code&gt; can not convert the &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Color&lt;/code&gt; (&lt;code&gt;
 NumberFormatException&lt;/code&gt; is thrown) then a &lt;code&gt;
 ColorUIResource&lt;/code&gt; of black is used.</source>
          <target state="translated">경우 &lt;code&gt;useNative&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;color&lt;/code&gt; 사용하여 만든 &lt;code&gt;Color.decode&lt;/code&gt; 을 변환 할 &lt;code&gt; String&lt;/code&gt; 에 &lt;code&gt;Color&lt;/code&gt; . &lt;code&gt;decode&lt;/code&gt; 가 &lt;code&gt;String&lt;/code&gt; 을 &lt;code&gt;Color&lt;/code&gt; 으로 변환 할 수없는 경우 ( &lt;code&gt; NumberFormatException&lt;/code&gt; 이 발생 함) 검은 색 의 &lt;code&gt; ColorUIResource&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e12a5a71cacdb7a4b0cc546bbaf64c5c1947c59f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useNative&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;color&lt;/code&gt; is the value of the field in &lt;code&gt;SystemColor&lt;/code&gt; with the same name as the &lt;code&gt;name&lt;/code&gt; of the &lt;code&gt;name-color&lt;/code&gt; pair. If the field is not valid, a &lt;code&gt;ColorUIResource&lt;/code&gt; of black is used.</source>
          <target state="translated">경우 &lt;code&gt;useNative&lt;/code&gt; 가 인 &lt;code&gt;true&lt;/code&gt; 은 &lt;code&gt;color&lt;/code&gt; 의 필드 값 &lt;code&gt;SystemColor&lt;/code&gt; 는 AS 동일한 이름 &lt;code&gt;name&lt;/code&gt; 의 &lt;code&gt;name-color&lt;/code&gt; 쌍. 필드가 유효하지 않으면 검은 색 의 &lt;code&gt;ColorUIResource&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42c68be27b55a7fc86e8255ec96cc9fc619eff9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a primitive array then &lt;code&gt;h&lt;/code&gt; is computed using the appropriate overloading of &lt;code&gt;java.util.Arrays.hashCode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 가 프리미티브 배열 인 경우 , &lt;code&gt;java.util.Arrays.hashCode&lt;/code&gt; 의 적절한 오버로드를 사용하여 &lt;code&gt;h&lt;/code&gt; 가 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d6ba7534f9cf9c2b36675a6962310dd6297fdb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepHashCode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 한 후 &lt;code&gt;h&lt;/code&gt; 사용하여 계산된다 &lt;a href=&quot;../../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepHashCode&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="697fc3a2ae17f1968e68001fdcb19fb233006602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 후 &lt;code&gt;h&lt;/code&gt; 로 하여 계산된다 &lt;a href=&quot;../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7c2ed9b1d962075a2a4a29e826a8f5a3166754e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepHashCode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 한 후 &lt;code&gt;h&lt;/code&gt; 사용하여 계산된다 &lt;a href=&quot;../../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepHashCode&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b9f393b2dc17964bf329368f78f1fec6ffbcc1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 후 &lt;code&gt;h&lt;/code&gt; 로 하여 계산된다 &lt;a href=&quot;../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f9ca186e13d8a0b2f51cb3a886210bea7f10ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is null then &lt;code&gt;h&lt;/code&gt; is 0.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 널 (null)이 다음 &lt;code&gt;h&lt;/code&gt; 0입니다.</target>
        </trans-unit>
        <trans-unit id="6af7ae4e213065c80428b397aa23f3ea124048d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; this method will remove the property.</source>
          <target state="translated">If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; this method will remove the property.</target>
        </trans-unit>
        <trans-unit id="cdf69f59b52da316eefe1f6713b87184e68ea952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;variableName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">If &lt;code&gt;variableName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; , then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="de58d32d92fa75ad61a38656206078ffc1357769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt;, the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt;
 weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt;
 IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</source>
          <target state="translated">If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt; , the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt; weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt; IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</target>
        </trans-unit>
        <trans-unit id="cf22cf86c23376b8eca15d02a9bb39702899c3a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt;, the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt;weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</source>
          <target state="translated">경우 &lt;code&gt;weekOfYear&lt;/code&gt; 이 있는 유효한 일주일의 년 범위를 벗어 &lt;code&gt;weekYear&lt;/code&gt; 의 &lt;code&gt;weekYear&lt;/code&gt; 및 &lt;code&gt;weekOfYear&lt;/code&gt; 값은 관대 모드에서 조정하거나, &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 엄밀 모드에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e04829a460140c9fa38864c5d9d7777958bc689" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;J&lt;/em&gt; has a method</source>
          <target state="translated">&lt;em&gt;J&lt;/em&gt; 에 메소드가있는 경우</target>
        </trans-unit>
        <trans-unit id="780f93481eae7dbaf2119163257a12d0c3bdf665" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean, then a Java casting conversion (JLS 5.5) is applied. (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by widening and/or narrowing.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 와 &lt;em&gt;T1은&lt;/em&gt; 부울 이외의 기본 요소는 다음 자바 캐스팅 변환 (JLS 5.5) 적용됩니다. 구체적으로, &lt;em&gt;T0&lt;/em&gt; 은 확장 및 / 또는 축소 하여 &lt;em&gt;T1&lt;/em&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dac40b6866039e1587ae30b3906847041aa9167" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, &lt;em&gt;T0&lt;/em&gt; must convert to &lt;em&gt;T1&lt;/em&gt; by a widening primitive conversion.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 및 &lt;em&gt;T1은&lt;/em&gt; 원시적 존재하는 경우, 다음 자바 메소드 호출 변환 (JLS 5.3)에 적용된다. 특히, &lt;em&gt;T0&lt;/em&gt; 은 확장 기본 변환 으로 &lt;em&gt;T1&lt;/em&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ab9ec122966f4e63c48e8d018d94714edba20c1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type, then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast. (This treatment of interfaces follows the usage of the bytecode verifier.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 및 &lt;em&gt;T1을&lt;/em&gt; 참조하고, &lt;em&gt;T1은&lt;/em&gt; 인터페이스 유형, 유형 다음 값 &lt;em&gt;T0는&lt;/em&gt; A와 전달 &lt;em&gt;T1&lt;/em&gt; 캐스팅없이. (이 인터페이스 처리는 바이트 코드 검증기의 사용을 따릅니다.)</target>
        </trans-unit>
        <trans-unit id="79aeb4d5dd8cb350db9c0c092dba6e42f02a5549" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, then a cast to &lt;em&gt;T1&lt;/em&gt; is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 와 &lt;em&gt;T1이&lt;/em&gt; 참조하고, 그 다음에 캐스트 &lt;em&gt;T1이&lt;/em&gt; 적용됩니다. 유형이 특정 방식으로 관련 될 필요는 없습니다. 이는 동적 값 널 (null)이 모든 참조 유형으로 변환 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4afc8d053d3eb053b07d58aea74885c54772acb0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a primitive and &lt;em&gt;T1&lt;/em&gt; a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from &lt;em&gt;T0&lt;/em&gt; to its wrapper class, which is then widened as needed to &lt;em&gt;T1&lt;/em&gt;.)</source>
          <target state="translated">경우 &lt;em&gt;T0은&lt;/em&gt; 원시적이며 &lt;em&gt;T1&lt;/em&gt; 참조가 존재하는 경우, 자바 주조 변환 (JLS 5.5)에 적용된다. (특히, 값은 &lt;em&gt;T0&lt;/em&gt; 에서 래퍼 클래스 까지 상자로 &lt;em&gt;묶고&lt;/em&gt; 필요에 따라 &lt;em&gt;T1&lt;/em&gt; 까지 확장됩니다 .)</target>
        </trans-unit>
        <trans-unit id="f9f655a906d4defe08e1ec4ccc11021ab6bc8df7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java casting conversion (JLS 5.5) on the primitive value, possibly followed by a conversion from byte to boolean by testing the low-order bit.</source>
          <target state="translated">경우 &lt;em&gt;T0는&lt;/em&gt; 기준이고 &lt;em&gt;T1&lt;/em&gt; 원시, 개봉기 변환 프리미티브 값에 자바 주조 변환 (JLS 5.5)에 의해 가능 런타임에 적용 하였다 될 가능성 저차 테스트하여 부울하는 바이트에서 전환 하였다 비트.</target>
        </trans-unit>
        <trans-unit id="db644feaac62822a15a472df6abb94d10f3b2937" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</source>
          <target state="translated">If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="5e7880911e2e6fcd9ad74806ba0070443b27d0e7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T0는&lt;/em&gt; 기준이고 &lt;em&gt;T1&lt;/em&gt; 원시, 개봉기 변환 가능한 프리미티브 값에 자바 메소드 호출 변환 (JLS 5.3) 한 후, 실행시에 적용된다. (이것은 원시 확장 변환입니다.) &lt;em&gt;T0&lt;/em&gt; 은 랩퍼 클래스이거나 1의 수퍼 타입이어야합니다. ( &lt;em&gt;T0&lt;/em&gt; 이 Object 인 경우 &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; 에서&lt;/a&gt; 허용하는 변환 입니다.) unboxing 변환에 성공할 가능성이 있어야합니다. 즉, &lt;em&gt;T0&lt;/em&gt; 자체가 랩퍼 클래스가 아닌 경우 에는 &lt;em&gt;T0&lt;/em&gt; 의 하위 유형이며 상자에없는 기본 값을 &lt;em&gt;T1&lt;/em&gt; 로 확장 할 수있는 하나 이상의 랩퍼 클래스 &lt;em&gt;TW&lt;/em&gt; 가 존재합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="8960999c2c149641fb63da1b8b2e73d16c83837a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, and if the reference is null at runtime, a zero value is introduced.</source>
          <target state="translated">경우 &lt;em&gt;T0는&lt;/em&gt; 기준이고, &lt;em&gt;T1&lt;/em&gt; 프리미티브, 참조가 null 런타임시이면 0의 값이 도입된다.</target>
        </trans-unit>
        <trans-unit id="c411b97d9273d8806592b1669554d07cf4ebec56" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive, the boolean is converted to a byte value, 1 for true, 0 for false. (This treatment follows the usage of the bytecode verifier.)</source>
          <target state="translated">경우 &lt;em&gt;T0은&lt;/em&gt; 부울이며 &lt;em&gt;T1은&lt;/em&gt; 다른 프리미티브이며, 부울 거짓 0 참하는 바이트 값 1로 변환된다. (이 처리는 바이트 코드 검증기의 사용법을 따릅니다.)</target>
        </trans-unit>
        <trans-unit id="11dcb0b6d39107c41f9d02034203e755a22bc31f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive, &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5), and the low order bit of the result is tested, as if by &lt;code&gt;(x &amp;amp; 1) != 0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T1은&lt;/em&gt; 부울이고 &lt;em&gt;T0는&lt;/em&gt; 다른 프리미티브이고, &lt;em&gt;T0는&lt;/em&gt; 변환 (JLS 5.5) 주조 자바를 통해 바이트로 변환하고, 결과의 하위 비트는 마치하여 시험한다 &lt;code&gt;(x &amp;amp; 1) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e03b8b722d047ebd8ff3f27197eddd18529d96a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt;
      &quot;java.lang.String&quot;&lt;/code&gt;.</source>
          <target state="translated">If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt; &quot;java.lang.String&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fd2145f2a73182fb43d09ea345dee1a6c4c8988" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt;&quot;java.lang.String&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T가&lt;/em&gt; 아닌 일반 비 어레이 형이다 &lt;em&gt;genericstring (T)에&lt;/em&gt; 의해 반환 된 값 &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt; , 예를 들면 &lt;code&gt;&quot;int&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;java.lang.String&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="860ba81ee558617e504db9f36e3c29f31a880b19" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt;. For example, &lt;em&gt;genericstring(&lt;code&gt;int[]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt;, and &lt;em&gt;genericstring(&lt;code&gt;
      List&amp;lt;String&amp;gt;[][]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;
      &quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt;.</source>
          <target state="translated">If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt; . For example, &lt;em&gt;genericstring( &lt;code&gt;int[]&lt;/code&gt; )&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt; , and &lt;em&gt;genericstring( &lt;code&gt; List&amp;lt;String&amp;gt;[][]&lt;/code&gt; )&lt;/em&gt; is &lt;code&gt; &quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fc604f0af1a190516ca2a3a164921e85df65901" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt;. For example, &lt;em&gt;genericstring(&lt;code&gt;int[]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt;, and &lt;em&gt;genericstring(&lt;code&gt;List&amp;lt;String&amp;gt;[][]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T는&lt;/em&gt; 어레이 인 &lt;em&gt;E []를&lt;/em&gt; , &lt;em&gt;genericstring (T)가&lt;/em&gt; 된다 &lt;em&gt;(E) genericstring&lt;/em&gt; 뒤에 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; . 예를 들어, &lt;em&gt;genericstring ( &lt;code&gt;int[]&lt;/code&gt; )&lt;/em&gt; 은 &lt;code&gt;&quot;int[]&quot;&lt;/code&gt; 이고 &lt;em&gt;genericstring ( &lt;code&gt;List&amp;lt;String&amp;gt;[][]&lt;/code&gt; )&lt;/em&gt; 은 &lt;code&gt;&quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a5ada396ebd42f6281b2f214e6a5eb260e1d65b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;opendata(J)&lt;/em&gt; is &lt;code&gt;CompositeData&lt;/code&gt; for a Java type &lt;em&gt;J&lt;/em&gt;, then either an instance of &lt;em&gt;J&lt;/em&gt; can be reconstructed from a &lt;code&gt;CompositeData&lt;/code&gt;, or &lt;em&gt;J&lt;/em&gt; is not reconstructible. If any item in the &lt;code&gt;CompositeData&lt;/code&gt; is not reconstructible, then &lt;em&gt;J&lt;/em&gt; is not reconstructible either.</source>
          <target state="translated">경우 &lt;em&gt;opendata (J)이&lt;/em&gt; 있다 &lt;code&gt;CompositeData&lt;/code&gt; 자바 타입 &lt;em&gt;J&lt;/em&gt; 후 하나의 인스턴스 &lt;em&gt;J는&lt;/em&gt; (A)로부터 재구성 될 수 &lt;code&gt;CompositeData&lt;/code&gt; 또는 &lt;em&gt;J는&lt;/em&gt; reconstructible 아니다. &lt;code&gt;CompositeData&lt;/code&gt; 의 항목을 재구성 할 수없는 경우 &lt;em&gt;J&lt;/em&gt; 도 재구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8262855ebc180b3d6778bf226e7f53f50f72af47" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType()&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType()&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; . This means that:</target>
        </trans-unit>
        <trans-unit id="55e80b82ba0e613e2bb9e96436b7f7884b762e6f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 의 인스턴스 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , 다음하자 &lt;code&gt;ct&lt;/code&gt; 그 수 &lt;code&gt;CompositeType&lt;/code&gt; 에 의해 반환 &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt; . 경우, 결과는 사실 &lt;code&gt;this&lt;/code&gt; 이다 &lt;em&gt;에서 할당 &lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; . 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e4299f574b0825744c73fc58489cb793e0aeb31f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;
 td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType()&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue(java.lang.Object)&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; , say &lt;code&gt; td&lt;/code&gt; , the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType()&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue(java.lang.Object)&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c5b21be35113bc2c3c5695016e41e7a8961aa607" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 의 인스턴스 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 말 &lt;code&gt;td&lt;/code&gt; 이되면 그 결과는 true입니다 &lt;code&gt;TabularType&lt;/code&gt; 의가 있습니다 &lt;em&gt;에서 할당 &lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt; 에 정의 된대로, &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bc555f2367ab62f427bf89fb970ff34e2a7eac" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 널 (null)이거나의 인스턴스가 아닌 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , &lt;code&gt;isValue&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fca7400d753ab2ac94fb4572ae69584ddad617" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 널 (null)이거나의 인스턴스가 아닌 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; , &lt;code&gt;isValue&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee964581c68796c9de47e0f9fcc18bb6c0cdfe3" translate="yes" xml:space="preserve">
          <source>If B 'requires transitive' C, then A &quot;reads&quot; C as well as B. This augmentation is recursive: since A &quot;reads&quot; C, if C 'requires transitive' D, then A &quot;reads&quot; D as well as C and B.</source>
          <target state="translated">If B 'requires transitive' C, then A &quot;reads&quot; C as well as B. This augmentation is recursive: since A &quot;reads&quot; C, if C 'requires transitive' D, then A &quot;reads&quot; D as well as C and B.</target>
        </trans-unit>
        <trans-unit id="217ddf9447b9b7371675e7e32d2dda97e83ca937" translate="yes" xml:space="preserve">
          <source>If B is an automatic module, then A &quot;reads&quot; every other enumerated automatic module. (It is &quot;as if&quot; an automatic module has 'requires transitive' directives for every other enumerated automatic module).</source>
          <target state="translated">If B is an automatic module, then A &quot;reads&quot; every other enumerated automatic module. (It is &quot;as if&quot; an automatic module has 'requires transitive' directives for every other enumerated automatic module).</target>
        </trans-unit>
        <trans-unit id="f6eb29fd93b0c765afc3bd3b512f90a195dcbb2f" translate="yes" xml:space="preserve">
          <source>If BeanContext parameter is null, then it shall associate the Applet with its appropriate Container by adding that Applet to its Container via an invocation of add(). If the BeanContext parameter is non-null, then it is the responsibility of the BeanContext to associate the Applet with its Container during the subsequent invocation of its addChildren() method.</source>
          <target state="translated">BeanContext 파라미터가 null의 경우, add ()의 호출을 사용해 그 애플릿을 컨테이너에 추가하는 것으로 애플릿을 적절한 컨테이너에 관련 짓습니다. BeanContext 매개 변수가 널이 아닌 경우, 이후 addChildren () 메소드 호출 중에 애플릿을 컨테이너와 연관시키는 것은 BeanContext의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b3801f11fd37bcce7f8fba639fe8d4ee887aad7e" translate="yes" xml:space="preserve">
          <source>If C declares a public field with the name specified, that is the field to be reflected.</source>
          <target state="translated">C가 지정된 이름으로 공개 필드를 선언하면 해당 필드가 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="e74b12226ef970b004e90369d97d9ef001f09d83" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then include the result of invoking this algorithm recursively on the superclass of C.</source>
          <target state="translated">If C is a class other than &lt;code&gt;Object&lt;/code&gt; , then include the result of invoking this algorithm recursively on the superclass of C.</target>
        </trans-unit>
        <trans-unit id="ca26ee5702ced758c636159001396b48df22d8a6" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then this algorithm is invoked recursively on the superclass of C.</source>
          <target state="translated">C가 &lt;code&gt;Object&lt;/code&gt; 이외의 클래스 인 경우이 알고리즘은 C의 수퍼 클래스에서 재귀 적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9b9649ab976d62198d1ec3dfed66527d11d467" translate="yes" xml:space="preserve">
          <source>If C is the class &lt;code&gt;Object&lt;/code&gt;, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected.</source>
          <target state="translated">C가 &lt;code&gt;Object&lt;/code&gt; 클래스 이거나 C가 인터페이스 인 경우 C (있는 경우)의 수퍼 인터페이스에서 일치하는 메소드를 검색합니다. 그러한 방법이 발견되면 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="2d85abeeeb1aa21f2267ac0f2f921e008ecb6b5d" translate="yes" xml:space="preserve">
          <source>If CPU time measurement is enabled after the thread has started, the Java virtual machine implementation may choose any time up to and including the time that the capability is enabled as the point where CPU time measurement starts.</source>
          <target state="translated">스레드가 시작된 후 CPU 시간 측정이 사용 가능한 경우, JVM (Java Virtual Machine) 구현은 기능이 사용 가능한 시간을 포함하여 CPU 시간 측정이 시작되는 시점을 포함하여 언제든지 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b2e184e73a9f507b63cab71f6b6a0fc51255aa" translate="yes" xml:space="preserve">
          <source>If CredentialClass is &quot;*&quot;, then access is granted to all private Credentials belonging to the specified &lt;code&gt;Subject&lt;/code&gt;. If &quot;PrincipalName&quot; is &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has the specified &lt;code&gt;Principal&lt;/code&gt; (the actual PrincipalName doesn't matter). For example, the following grants access to the a.b.Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has an a.b.Principal.</source>
          <target state="translated">CredentialClass가 &quot;*&quot;이면 지정된 &lt;code&gt;Subject&lt;/code&gt; 에 속하는 모든 개인 자격 증명에 액세스 권한이 부여됩니다 . &quot;PrincipalName&quot;이 &quot;*&quot;이면 지정된 &lt;code&gt;Principal&lt;/code&gt; 이있는 모든 &lt;code&gt;Subject&lt;/code&gt; 가 소유 한 지정된 자격 증명에 대한 액세스 권한이 부여됩니다 (실제 PrincipalName은 중요하지 않음). 예를 들어, 다음 은 abPrincipal이있는 모든 &lt;code&gt;Subject&lt;/code&gt; 소유 한 abCredential에 대한 액세스 권한을 부여합니다 .</target>
        </trans-unit>
        <trans-unit id="a62e7a3eb9436a575105ab492afe79c76ff1b2cd" translate="yes" xml:space="preserve">
          <source>If Flight Recorder is already initialized when the listener is added, then the method &lt;a href=&quot;flightrecorderlistener#recorderInitialized(jdk.jfr.FlightRecorder)&quot;&gt;&lt;code&gt;FlightRecorderListener.recorderInitialized(FlightRecorder)&lt;/code&gt;&lt;/a&gt; method is invoked before returning from this method.</source>
          <target state="translated">리스너가 추가 될 때 Flight Recorder가 이미 초기화 된 경우이 메서드에서 반환하기 전에 &lt;a href=&quot;flightrecorderlistener#recorderInitialized(jdk.jfr.FlightRecorder)&quot;&gt; &lt;code&gt;FlightRecorderListener.recorderInitialized(FlightRecorder)&lt;/code&gt; &lt;/a&gt; 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6a39eb1a01812d32c33a1ca34fe7c0a3f9fe824c" translate="yes" xml:space="preserve">
          <source>If January 1st is Friday then week 1 starts on January 4th</source>
          <target state="translated">1 월 1 일이 금요일이면 1 주차는 1 월 4 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="8212bef3cde7fd918667a428a4beb2926b2aaf30" translate="yes" xml:space="preserve">
          <source>If January 1st is Monday then week 1 starts on January 1st</source>
          <target state="translated">1 월 1 일이 월요일이면 1 월 1 일에 1 주차가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1d8c7e06d2ed477961cc6b9bf02767f72d2e8e" translate="yes" xml:space="preserve">
          <source>If January 1st is Saturday then week 1 starts on January 3rd</source>
          <target state="translated">1 월 1 일이 토요일이면 1 주차는 1 월 3 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="93384845075a732cc09f28c1fdb3a1493434370f" translate="yes" xml:space="preserve">
          <source>If January 1st is Sunday then week 1 starts on January 2nd</source>
          <target state="translated">1 월 1 일이 일요일이면 1 주차는 1 월 2 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d773a45b8b76332ac1c9cf30d6d26cbed25b1ef6" translate="yes" xml:space="preserve">
          <source>If January 1st is Thursday then week 1 starts on December 29th of the previous standard year</source>
          <target state="translated">1 월 1 일이 목요일이면 1 주차는 이전 표준 연도의 12 월 29 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="dff679f893694acfcb5844ad440b7fd91f379885" translate="yes" xml:space="preserve">
          <source>If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year</source>
          <target state="translated">1 월 1 일이 화요일이면 1 주차는 이전 표준 연도의 12 월 31 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4487b7e39c0d7129e69d67e0df2749862989ef" translate="yes" xml:space="preserve">
          <source>If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year</source>
          <target state="translated">1 월 1 일이 수요일이면 1 주차는 전년도의 12 월 30 일에 시작됩니다</target>
        </trans-unit>
        <trans-unit id="f38e0c7c32dd408bc04c87c04c2100fa3feb4c90" translate="yes" xml:space="preserve">
          <source>If N equals &lt;code&gt;className&lt;/code&gt;, the result is true.</source>
          <target state="translated">N이 &lt;code&gt;className&lt;/code&gt; 인 경우 결과는 true입니다.</target>
        </trans-unit>
        <trans-unit id="0ba990b0a52d90609129011e460cfce22958559a" translate="yes" xml:space="preserve">
          <source>If Q is not a primitive wrapper, cast Q to the base Wrapper(S); for example Number for numeric types</source>
          <target state="translated">Q가 기본 랩퍼가 아닌 경우 Q를 기본 랩퍼로 캐스트하십시오. 예를 들어 숫자 유형의 경우 Number</target>
        </trans-unit>
        <trans-unit id="703cac5535402dfbacd6e10480e5c86732963b2a" translate="yes" xml:space="preserve">
          <source>If SQL distinct or structured types are supported, then information on the individual types may be obtained from the getUDTs() method.</source>
          <target state="translated">If SQL distinct or structured types are supported, then information on the individual types may be obtained from the getUDTs() method.</target>
        </trans-unit>
        <trans-unit id="b161924f4e548ad87c34d6fc35e9d529b38669ec" translate="yes" xml:space="preserve">
          <source>If TMFAIL is specified, the portion of work has failed. The resource manager may mark the transaction as rollback-only</source>
          <target state="translated">If TMFAIL is specified, the portion of work has failed. The resource manager may mark the transaction as rollback-only</target>
        </trans-unit>
        <trans-unit id="34e620dd9f663543c0cd6de489c85fce57f1d753" translate="yes" xml:space="preserve">
          <source>If TMSUCCESS is specified, the portion of work has completed successfully.</source>
          <target state="translated">If TMSUCCESS is specified, the portion of work has completed successfully.</target>
        </trans-unit>
        <trans-unit id="666f46da82bcae259e1d59dba9446d046eb56729" translate="yes" xml:space="preserve">
          <source>If TMSUSPEND is specified in the flags, the transaction branch is temporarily suspended in an incomplete state. The transaction context is in a suspended state and must be resumed via the &lt;code&gt;start&lt;/code&gt; method with TMRESUME specified.</source>
          <target state="translated">If TMSUSPEND is specified in the flags, the transaction branch is temporarily suspended in an incomplete state. The transaction context is in a suspended state and must be resumed via the &lt;code&gt;start&lt;/code&gt; method with TMRESUME specified.</target>
        </trans-unit>
        <trans-unit id="d4e43d0787d6a1f0ea103acb6274a424055f2393" translate="yes" xml:space="preserve">
          <source>If UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">UDP 소켓을 사용하는 경우 TCP / IP 관련 소켓 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d35b5e2d84fd7cadfe9d220ae2dd518e06e9f2d7" translate="yes" xml:space="preserve">
          <source>If XInclude markup is found in the document instance, should it be processed as specified in &lt;a href=&quot;http://www.w3.org/TR/xinclude/&quot;&gt; XML Inclusions (XInclude) Version 1.0&lt;/a&gt;.</source>
          <target state="translated">If XInclude markup is found in the document instance, should it be processed as specified in &lt;a href=&quot;http://www.w3.org/TR/xinclude/&quot;&gt; XML Inclusions (XInclude) Version 1.0&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="44f2e533c81b55c008b79c7820101bd6e4826567" translate="yes" xml:space="preserve">
          <source>If XInclude markup is found in the document instance, should it be processed as specified in &lt;a href=&quot;https://www.w3.org/TR/xinclude/&quot;&gt; XML Inclusions (XInclude) Version 1.0&lt;/a&gt;.</source>
          <target state="translated">문서 인스턴스에서 XInclude 마크 업이 발견되면 &lt;a href=&quot;https://www.w3.org/TR/xinclude/&quot;&gt;XML Inclusions (XInclude) 버전 1.0에&lt;/a&gt; 지정된대로 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf93dc358d8e904b576e25277f8f25bb773404f0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d758c373d5c33100c18bb64f511e7cfa9ca774b0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7ff99926f4a6706109dc64ddd976098f7dbb7eca" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0e9892804baed9af42e82a13b8ef76149b94c399" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present and no factory is specified, then the default pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. The system class loader is used to load these classes. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">경우 &lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; 존재하고 어떤 공장이 지정되지 않은, 디폴트 풀은 더 한 스레드 공급하는 공장 사용 &lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt; 활성화되지합니다. 시스템 클래스 로더는 이러한 클래스를로드하는 데 사용됩니다. 이러한 설정을 설정하는 중 오류가 발생하면 기본 매개 변수가 사용됩니다. parallelism 속성을 0으로 설정하거나 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수있는 팩토리를 사용하여 공통 풀에서 스레드 사용을 비활성화하거나 제한 할 수 있습니다 . 그러나 이렇게하면 결합되지 않은 작업이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56cfbf9c11a3bf93497432039e845c2caa01626" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&quot;..&quot;&lt;/code&gt; segment is preceded by a non-&lt;code&gt;&quot;..&quot;&lt;/code&gt; segment then both of these segments are removed. This step is repeated until it is no longer applicable.</source>
          <target state="translated">경우 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 세그먼트가 비 앞에는 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 다음 부분이 세그먼트는 모두 제거된다. 이 단계는 더 이상 적용되지 않을 때까지 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a595fa88f9f83de3f8fcc49ca39b0b97a48f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CONCURRENT&lt;/code&gt; collector is not also &lt;code&gt;UNORDERED&lt;/code&gt;, then it should only be evaluated concurrently if applied to an unordered data source.</source>
          <target state="translated">경우 &lt;code&gt;CONCURRENT&lt;/code&gt; 콜렉터도되지 &lt;code&gt;UNORDERED&lt;/code&gt; 정렬되지 않은 데이터 소스에인가하는 경우, 그것은 동시에 만 평가되어야한다.</target>
        </trans-unit>
        <trans-unit id="889b6a11619fbd0768ef25d463af6d6d1eb26b68" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CachedRowSet&lt;/code&gt; object becomes part of a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the keys defined by this method and the resulting constraints are maintained if the columns designated as key columns also become match columns.</source>
          <target state="translated">If a &lt;code&gt;CachedRowSet&lt;/code&gt; object becomes part of a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the keys defined by this method and the resulting constraints are maintained if the columns designated as key columns also become match columns.</target>
        </trans-unit>
        <trans-unit id="023e1ebdfb712240675bc329abb0aeba8c03fd80" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Comparator&lt;/code&gt; has been specified for the column by the &lt;code&gt;setComparator&lt;/code&gt; method, use it.</source>
          <target state="translated">If a &lt;code&gt;Comparator&lt;/code&gt; has been specified for the column by the &lt;code&gt;setComparator&lt;/code&gt; method, use it.</target>
        </trans-unit>
        <trans-unit id="87a0262c290ea66e1e4a3ee02285d9a618034184" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataLine&lt;/code&gt; is requested, and &lt;code&gt;info&lt;/code&gt; is an instance of &lt;code&gt;DataLine.Info&lt;/code&gt; specifying at least one fully qualified audio format, the last one will be used as the default format of the returned &lt;code&gt;DataLine&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;DataLine&lt;/code&gt; 요구되며, &lt;code&gt;info&lt;/code&gt; 의 인스턴스 &lt;code&gt;DataLine.Info&lt;/code&gt; 적어도 하나의 완전한 오디오 형식을 지정, 마지막은 반환의 기본 형식으로 사용됩니다 &lt;code&gt;DataLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="822fd67bb76ff6305db4ff466cd709d70f4144a8" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DriverAction&lt;/code&gt; instance was specified when the JDBC driver was registered, its deregister method will be called prior to the driver being removed from the list of registered drivers.</source>
          <target state="translated">If a &lt;code&gt;DriverAction&lt;/code&gt; instance was specified when the JDBC driver was registered, its deregister method will be called prior to the driver being removed from the list of registered drivers.</target>
        </trans-unit>
        <trans-unit id="0307105d00c9e2e53f227a7583fda0f66d0bdfee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;FilteredRowSet&lt;/code&gt; implementation is shared using the inherited &lt;code&gt;createShared&lt;/code&gt; method in parent interfaces, the &lt;code&gt;Predicate&lt;/code&gt; should be shared without modification by all &lt;code&gt;FilteredRowSet&lt;/code&gt; instance clones.</source>
          <target state="translated">If a &lt;code&gt;FilteredRowSet&lt;/code&gt; implementation is shared using the inherited &lt;code&gt;createShared&lt;/code&gt; method in parent interfaces, the &lt;code&gt;Predicate&lt;/code&gt; should be shared without modification by all &lt;code&gt;FilteredRowSet&lt;/code&gt; instance clones.</target>
        </trans-unit>
        <trans-unit id="738e1b86e8d51219176a3aef7355506e4b762fc6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JButton&lt;/code&gt; is being added, it is initially set to be disabled.</source>
          <target state="translated">If a &lt;code&gt;JButton&lt;/code&gt; is being added, it is initially set to be disabled.</target>
        </trans-unit>
        <trans-unit id="baa9e0dcc52392fc3cfab576edd859e0065fab5d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt;, it is positioned along the upper edge of the frame. The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to fill the remaining area. (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the &lt;code&gt;layeredPane&lt;/code&gt; component at the &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)</source>
          <target state="translated">If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt; , it is positioned along the upper edge of the frame. The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to fill the remaining area. (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the &lt;code&gt;layeredPane&lt;/code&gt; component at the &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)</target>
        </trans-unit>
        <trans-unit id="1d76683d65c14154863276b53c328991a5b273fb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JOptionPane&lt;/code&gt; has configured to all input &lt;code&gt;setWantsInput&lt;/code&gt; the bound property &lt;code&gt;JOptionPane.INPUT_VALUE_PROPERTY&lt;/code&gt; can also be listened to, to determine when the user has input or selected a value.</source>
          <target state="translated">If a &lt;code&gt;JOptionPane&lt;/code&gt; has configured to all input &lt;code&gt;setWantsInput&lt;/code&gt; the bound property &lt;code&gt;JOptionPane.INPUT_VALUE_PROPERTY&lt;/code&gt; can also be listened to, to determine when the user has input or selected a value.</target>
        </trans-unit>
        <trans-unit id="88dd2d3eceec11295d7042c434141f4e15854a11" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JobPriority&lt;/code&gt; attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">If a &lt;code&gt;JobPriority&lt;/code&gt; attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</target>
        </trans-unit>
        <trans-unit id="789dd14e5349e6a03d7591e97c806c5a4a9cec5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;#getUnboundInstance()&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#getUnboundInstance(java.io.File)&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal)&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal,java.io.File)&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;#getUnboundInstance()&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#getUnboundInstance(java.io.File)&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal)&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal,java.io.File)&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</target>
        </trans-unit>
        <trans-unit id="96e5812f9668e1871b3f46e04c3c43773aa3cf41" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">하면 &lt;code&gt;KeyTab&lt;/code&gt; 개체로부터 얻어진다 &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt; , 그 바인딩 해제하고 따라서 모든 서비스 주체에 의해 사용될 수있다. 그렇지 않은 경우, &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt; 에서 확보 한 경우 특정 서비스 프린시 펄에 바인드되어 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2450fb5c5add16e3fc12db422f9262f86c62d3c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Lookup&lt;/code&gt; on &lt;code&gt;LC&lt;/code&gt; in &lt;code&gt;M1&lt;/code&gt; has a previous lookup class &lt;code&gt;PLC&lt;/code&gt; on &lt;code&gt;M0&lt;/code&gt;, the lookup with &lt;a href=&quot;#PUBLIC&quot;&gt;&lt;code&gt;PUBLIC&lt;/code&gt;&lt;/a&gt; mode can access the intersection of all public types that are accessible to &lt;code&gt;M1&lt;/code&gt; with all public types that are accessible to &lt;code&gt;M0&lt;/code&gt;. &lt;code&gt;M0&lt;/code&gt; reads &lt;code&gt;M1&lt;/code&gt; and hence the set of accessible types includes:</source>
          <target state="translated">경우 &lt;code&gt;Lookup&lt;/code&gt; 에 &lt;code&gt;LC&lt;/code&gt; 에서 &lt;code&gt;M1&lt;/code&gt; 은 이전 조회 클래스가 &lt;code&gt;PLC&lt;/code&gt; 에 &lt;code&gt;M0&lt;/code&gt; 를 가진 조회 &lt;a href=&quot;#PUBLIC&quot;&gt; &lt;code&gt;PUBLIC&lt;/code&gt; 의&lt;/a&gt; 모드에 액세스 할 수있는 모든 public 형식의 교차로에 액세스 할 수 있습니다 &lt;code&gt;M1&lt;/code&gt; 에 액세스 할 수있는 모든 public 형식과 &lt;code&gt;M0&lt;/code&gt; 를 . &lt;code&gt;M0&lt;/code&gt; 은 &lt;code&gt;M1&lt;/code&gt; 을 읽으 므로 액세스 가능한 유형 집합에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5b7a23be9db2dbf18af4ecce5e36c009a96a3d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Lookup&lt;/code&gt; on &lt;code&gt;LC&lt;/code&gt; in &lt;code&gt;M1&lt;/code&gt; has no previous lookup class, the lookup with &lt;a href=&quot;#PUBLIC&quot;&gt;&lt;code&gt;PUBLIC&lt;/code&gt;&lt;/a&gt; mode can access all public types in modules that are readable to &lt;code&gt;M1&lt;/code&gt; and the type is in a package that is exported at least to &lt;code&gt;M1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;M1&lt;/code&gt; 의 &lt;code&gt;LC&lt;/code&gt; 에 대한 &lt;code&gt;Lookup&lt;/code&gt; 에 이전 조회 클래스가없는 경우 &lt;a href=&quot;#PUBLIC&quot;&gt; &lt;code&gt;PUBLIC&lt;/code&gt; &lt;/a&gt; 모드를 사용한 조회는 &lt;code&gt;M1&lt;/code&gt; 에서 읽을 수있는 모듈의 모든 공용 유형에 액세스 할 수 있으며 유형은 최소한 &lt;code&gt;M1&lt;/code&gt; 로 내 보내진 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="169583703e821554fd005ef25ad00c1501c82436" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;MarshalException&lt;/code&gt; occurs during a remote method call, the call may or may not have reached the server. If the call did reach the server, parameters may have been deserialized. A call may not be retransmitted after a &lt;code&gt;MarshalException&lt;/code&gt; and reliably preserve &quot;at most once&quot; call semantics.</source>
          <target state="translated">If a &lt;code&gt;MarshalException&lt;/code&gt; occurs during a remote method call, the call may or may not have reached the server. If the call did reach the server, parameters may have been deserialized. A call may not be retransmitted after a &lt;code&gt;MarshalException&lt;/code&gt; and reliably preserve &quot;at most once&quot; call semantics.</target>
        </trans-unit>
        <trans-unit id="7341cf2f876d3c7a46c61b0becb56d0668f2a5a7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;MaskFormatter&lt;/code&gt; is configured to only allow valid characters (&lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;) literal characters will be skipped as necessary when editing. Consider a &lt;code&gt;MaskFormatter&lt;/code&gt; with the mask &quot;###-####&quot; and current value &quot;555-1212&quot;. Using the right arrow key to navigate through the field will result in (| indicates the position of the caret):</source>
          <target state="translated">If a &lt;code&gt;MaskFormatter&lt;/code&gt; is configured to only allow valid characters ( &lt;code&gt;setAllowsInvalid(false)&lt;/code&gt; ) literal characters will be skipped as necessary when editing. Consider a &lt;code&gt;MaskFormatter&lt;/code&gt; with the mask &quot;###-####&quot; and current value &quot;555-1212&quot;. Using the right arrow key to navigate through the field will result in (| indicates the position of the caret):</target>
        </trans-unit>
        <trans-unit id="ead077860ccdc5ff506c0098c7c9fa85462cc96f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;ModuleDescriptor&lt;/code&gt; cannot be created (by means of the &lt;a href=&quot;moduledescriptor.builder&quot;&gt;&lt;code&gt;ModuleDescriptor.Builder&lt;/code&gt;&lt;/a&gt; API) for an automatic module then &lt;code&gt;FindException&lt;/code&gt; is thrown. This can arise when the value of the &quot;&lt;code&gt;Automatic-Module-Name&lt;/code&gt;&quot; attribute is not a legal module name, a legal module name cannot be derived from the file name of the JAR file, where the JAR file contains a &lt;code&gt;.class&lt;/code&gt; in the top-level directory of the JAR file, where an entry in a service configuration file is not a legal class name or its package name is not in the set of packages derived for the module.</source>
          <target state="translated">If a &lt;code&gt;ModuleDescriptor&lt;/code&gt; cannot be created (by means of the &lt;a href=&quot;moduledescriptor.builder&quot;&gt; &lt;code&gt;ModuleDescriptor.Builder&lt;/code&gt; &lt;/a&gt; API) for an automatic module then &lt;code&gt;FindException&lt;/code&gt; is thrown. This can arise when the value of the &quot; &lt;code&gt;Automatic-Module-Name&lt;/code&gt; &quot; attribute is not a legal module name, a legal module name cannot be derived from the file name of the JAR file, where the JAR file contains a &lt;code&gt;.class&lt;/code&gt; in the top-level directory of the JAR file, where an entry in a service configuration file is not a legal class name or its package name is not in the set of packages derived for the module.</target>
        </trans-unit>
        <trans-unit id="441cc4fd494fbe5b1ad39c7fa559b1582982d101" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Node&lt;/code&gt; is used in a different document than the one that created it (that doesn't support it).</source>
          <target state="translated">If a &lt;code&gt;Node&lt;/code&gt; is used in a different document than the one that created it (that doesn't support it).</target>
        </trans-unit>
        <trans-unit id="4644effb4a6d5ba07fcf8513d9d0cd6f314112a7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PageRanges&lt;/code&gt; attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the &lt;code&gt;PageRanges&lt;/code&gt; attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">If a &lt;code&gt;PageRanges&lt;/code&gt; attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the &lt;code&gt;PageRanges&lt;/code&gt; attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3283302ea3f0883d87077d68bd9cbb226e3ffd4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;ParseException&lt;/code&gt; has not been thrown, and the value is outside the min/max a &lt;code&gt;ParseException&lt;/code&gt; is thrown.</source>
          <target state="translated">If a &lt;code&gt;ParseException&lt;/code&gt; has not been thrown, and the value is outside the min/max a &lt;code&gt;ParseException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="6ea4836a2a47cbda56eec3b84a8b5aa80316b7db" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt; , then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</target>
        </trans-unit>
        <trans-unit id="d851531cc7c0ba18b4dbffa855d090b319da4df2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">경우 &lt;code&gt;PreferencesFactory&lt;/code&gt; 구현 클래스 파일이에 볼 수있는 jar 파일에 설치되어있는 &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt; , 그 jar 파일이 이름의 프로 바이더 구성 파일이 포함되어 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 그러한 jar 파일이 두 개 이상 제공되면 처음 발견 된 jar 파일이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="622c2551e9494318dc465bf15dd37446b19792a2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RenderingHints&lt;/code&gt; object is specified in the constructor, the interpolation hint and the rendering quality hint are used to set the interpolation type for this operation. The color rendering hint and the dithering hint can be used when color conversion is required.</source>
          <target state="translated">If a &lt;code&gt;RenderingHints&lt;/code&gt; object is specified in the constructor, the interpolation hint and the rendering quality hint are used to set the interpolation type for this operation. The color rendering hint and the dithering hint can be used when color conversion is required.</target>
        </trans-unit>
        <trans-unit id="ef39b802886ff9b6ff97af1ea901d5330b3307e6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; implementation is instantiated with a specified provider and the specified provider has been properly registered, the requested provider is supplied. Otherwise a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown.</source>
          <target state="translated">If a &lt;code&gt;RowSet&lt;/code&gt; implementation is instantiated with a specified provider and the specified provider has been properly registered, the requested provider is supplied. Otherwise a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="da1a08658f1dbe589bccb3ea8d557b60263f9878" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; object attempts to obtain a &lt;code&gt;MyProvider&lt;/code&gt; object, the &lt;code&gt;SyncFactory&lt;/code&gt; will try to locate it. First it searches for it in the system properties, then it looks in the resource files, and finally it checks the JNDI context that has been set. The &lt;code&gt;SyncFactory&lt;/code&gt; instance verifies that the requested provider is a valid extension of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class and then gives it to the &lt;code&gt;RowSet&lt;/code&gt; object. In the following code fragment, a new &lt;code&gt;CachedRowSet&lt;/code&gt; object is created and initialized with</source>
          <target state="translated">If a &lt;code&gt;RowSet&lt;/code&gt; object attempts to obtain a &lt;code&gt;MyProvider&lt;/code&gt; object, the &lt;code&gt;SyncFactory&lt;/code&gt; will try to locate it. First it searches for it in the system properties, then it looks in the resource files, and finally it checks the JNDI context that has been set. The &lt;code&gt;SyncFactory&lt;/code&gt; instance verifies that the requested provider is a valid extension of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class and then gives it to the &lt;code&gt;RowSet&lt;/code&gt; object. In the following code fragment, a new &lt;code&gt;CachedRowSet&lt;/code&gt; object is created and initialized with</target>
        </trans-unit>
        <trans-unit id="85924d6f4f84b3110f734f518f0de7bf01d0e847" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; object does not specify a &lt;code&gt;SyncProvider&lt;/code&gt; implementation and no additional &lt;code&gt;SyncProvider&lt;/code&gt; implementations are available, the reference implementation providers are supplied.</source>
          <target state="translated">If a &lt;code&gt;RowSet&lt;/code&gt; object does not specify a &lt;code&gt;SyncProvider&lt;/code&gt; implementation and no additional &lt;code&gt;SyncProvider&lt;/code&gt; implementations are available, the reference implementation providers are supplied.</target>
        </trans-unit>
        <trans-unit id="005a68567a9c263db1c792152177b5d5b3c37e24" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the calling thread must be granted the &lt;code&gt;AWTPermission&lt;/code&gt; &quot;replaceKeyboardFocusManager&quot; in order to replace the the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If this permission is not granted, this method will throw a &lt;code&gt;SecurityException&lt;/code&gt;, and the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will be unchanged.</source>
          <target state="translated">If a &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the calling thread must be granted the &lt;code&gt;AWTPermission&lt;/code&gt; &quot;replaceKeyboardFocusManager&quot; in order to replace the the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; . If this permission is not granted, this method will throw a &lt;code&gt;SecurityException&lt;/code&gt; , and the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will be unchanged.</target>
        </trans-unit>
        <trans-unit id="bf0127e04708633ff438380e9063019f694d008f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains</source>
          <target state="translated">If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains</target>
        </trans-unit>
        <trans-unit id="4f2c61caf99510b2cab1bf9c38fbc6348259df28" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains a reference to the provider, the requested provider is supplied.</source>
          <target state="translated">If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains a reference to the provider, the requested provider is supplied.</target>
        </trans-unit>
        <trans-unit id="6536cee7d50ac1adadff34bddda00e1d72420e1a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProviderException&lt;/code&gt; object is thrown, an application may use this method to generate a &lt;code&gt;SyncResolver&lt;/code&gt; object with which to resolve the conflict or conflicts that caused the exception to be thrown.</source>
          <target state="translated">If a &lt;code&gt;SyncProviderException&lt;/code&gt; object is thrown, an application may use this method to generate a &lt;code&gt;SyncResolver&lt;/code&gt; object with which to resolve the conflict or conflicts that caused the exception to be thrown.</target>
        </trans-unit>
        <trans-unit id="a2c0481cf37e4b6df1c957fb1176bf4576ce6d06" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;TableStringConverter&lt;/code&gt; has been specified, use it to convert the values to &lt;code&gt;String&lt;/code&gt;s and then use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt;.</source>
          <target state="translated">If a &lt;code&gt;TableStringConverter&lt;/code&gt; has been specified, use it to convert the values to &lt;code&gt;String&lt;/code&gt; s and then use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88f021219bb5adbaaf305230bab58b361bbbf62e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;WebRowSet&lt;/code&gt; object does not specify a provider in its constructor, the &lt;code&gt;SyncFactory&lt;/code&gt; will give it an instance of &lt;code&gt;RIOptimisticProvider&lt;/code&gt;. However, the constructor for &lt;code&gt;WebRowSet&lt;/code&gt; is implemented to set the provider to the &lt;code&gt;RIXMLProvider&lt;/code&gt;, which reads and writes a &lt;code&gt;RowSet&lt;/code&gt; object in XML format.</source>
          <target state="translated">If a &lt;code&gt;WebRowSet&lt;/code&gt; object does not specify a provider in its constructor, the &lt;code&gt;SyncFactory&lt;/code&gt; will give it an instance of &lt;code&gt;RIOptimisticProvider&lt;/code&gt; . However, the constructor for &lt;code&gt;WebRowSet&lt;/code&gt; is implemented to set the provider to the &lt;code&gt;RIXMLProvider&lt;/code&gt; , which reads and writes a &lt;code&gt;RowSet&lt;/code&gt; object in XML format.</target>
        </trans-unit>
        <trans-unit id="c6d143f1c9666cc7913e46a053fe559e1a96fe26" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null Cursor&lt;/code&gt; is specified no exception will be thrown and default drag cursors will be used instead.</source>
          <target state="translated">If a &lt;code&gt;null Cursor&lt;/code&gt; is specified no exception will be thrown and default drag cursors will be used instead.</target>
        </trans-unit>
        <trans-unit id="8f4b45cbcd2002bbfaa5e00b1ed409af80135472" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null Transferable&lt;/code&gt; is specified &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If a &lt;code&gt;null Transferable&lt;/code&gt; is specified &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="4e14b0a6b6bb76cc2c0b6e35711b0ecf985814b3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null&lt;/code&gt; value is specified for the driver to be removed, then no action is taken.</source>
          <target state="translated">If a &lt;code&gt;null&lt;/code&gt; value is specified for the driver to be removed, then no action is taken.</target>
        </trans-unit>
        <trans-unit id="e52e706791f96fcec7c06d42e023ea2edd9c9435" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="fee0a461ccedb0cec1c346f64b81ad734d6b4474" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="1ca6fa88cbddfe8774a575dd729aff8c4c1ff45e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="439453cd55d4370948e1a390997169512de7d762" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="c287b4bb12cc003fe3dff0af6571caedd594b2e6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="23ec38983597030f5c01de386bdcfad6f3c016aa" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is not inside the &lt;code&gt;shape&lt;/code&gt;, then it might still be contained in the &lt;code&gt;bounds&lt;/code&gt; object:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is not inside the &lt;code&gt;shape&lt;/code&gt; , then it might still be contained in the &lt;code&gt;bounds&lt;/code&gt; object:</target>
        </trans-unit>
        <trans-unit id="cb3f45e83272884b8fce5d6e7cf093613a1f0235" translate="yes" xml:space="preserve">
          <source>If a Class has been set for the values (&lt;code&gt;setValueClass&lt;/code&gt;), supers implementation is invoked to convert the value returned from &lt;code&gt;parseObject&lt;/code&gt; to the appropriate class.</source>
          <target state="translated">If a Class has been set for the values ( &lt;code&gt;setValueClass&lt;/code&gt; ), supers implementation is invoked to convert the value returned from &lt;code&gt;parseObject&lt;/code&gt; to the appropriate class.</target>
        </trans-unit>
        <trans-unit id="c22024a55d98f2d5bfb4a62cbb3885fd92657704" translate="yes" xml:space="preserve">
          <source>If a DRBG is not instantiated with a &lt;a href=&quot;drbgparameters.instantiation&quot;&gt;&lt;code&gt;DrbgParameters.Instantiation&lt;/code&gt;&lt;/a&gt; object explicitly, this implementation instantiates it with a default requested strength of 128 bits, no prediction resistance request, and no personalization string. These default instantiation parameters can also be customized with the &lt;code&gt;securerandom.drbg.config&lt;/code&gt; security property.</source>
          <target state="translated">If a DRBG is not instantiated with a &lt;a href=&quot;drbgparameters.instantiation&quot;&gt; &lt;code&gt;DrbgParameters.Instantiation&lt;/code&gt; &lt;/a&gt; object explicitly, this implementation instantiates it with a default requested strength of 128 bits, no prediction resistance request, and no personalization string. These default instantiation parameters can also be customized with the &lt;code&gt;securerandom.drbg.config&lt;/code&gt; security property.</target>
        </trans-unit>
        <trans-unit id="95e527be19ab2827e077013513499ad6b9cbcff0" translate="yes" xml:space="preserve">
          <source>If a GUI control is both an active &lt;code&gt;DropTarget&lt;/code&gt; and is also scrollable, it can receive notifications of autoscrolling gestures by the user from the DnD system by implementing this interface.</source>
          <target state="translated">If a GUI control is both an active &lt;code&gt;DropTarget&lt;/code&gt; and is also scrollable, it can receive notifications of autoscrolling gestures by the user from the DnD system by implementing this interface.</target>
        </trans-unit>
        <trans-unit id="99e2b5ed00fcac649fe3f3623264074d666a2942" translate="yes" xml:space="preserve">
          <source>If a JobPriority attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">인쇄 작업에 JobPriority 속성이 지정된 경우 작업 예약 우선 순위를 지정합니다. 값이 클수록 우선 순위가 높습니다. 값 1은 가능한 최저 우선 순위를 나타냅니다. 값 100은 가능한 가장 높은 우선 순위를 나타냅니다. 인쇄 준비가 된 작업 중에서 프린터는 우선 순위 값이 모든 작업을 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="efa62e398135fa151e6296eb9565e2ee0a846e6d" translate="yes" xml:space="preserve">
          <source>If a PageRanges attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the PageRanges attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">인쇄 작업에 PageRanges 속성을 지정하지 않으면 문서의 모든 페이지가 인쇄됩니다. 즉, PageRanges 속성의 기본값은 항상 &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56fcf828deb12fa7c8d023153792b45f6be1b50b" translate="yes" xml:space="preserve">
          <source>If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used to control color conversion.</source>
          <target state="translated">If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used to control color conversion.</target>
        </trans-unit>
        <trans-unit id="4df78250cfd2d96c297fc417911e5b1721cfe666" translate="yes" xml:space="preserve">
          <source>If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.</source>
          <target state="translated">If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.</target>
        </trans-unit>
        <trans-unit id="68b1d4751c3a4fe9ee24ce1abe018576aed949a4" translate="yes" xml:space="preserve">
          <source>If a SAX application needs information about notations and unparsed entities, then the application implements this interface and registers an instance with the SAX parser using the parser's setDTDHandler method. The parser uses the instance to report notation and unparsed entity declarations to the application.</source>
          <target state="translated">If a SAX application needs information about notations and unparsed entities, then the application implements this interface and registers an instance with the SAX parser using the parser's setDTDHandler method. The parser uses the instance to report notation and unparsed entity declarations to the application.</target>
        </trans-unit>
        <trans-unit id="3ba5b890d7e1cdc89fd5a6bca00ab40e11acebb0" translate="yes" xml:space="preserve">
          <source>If a SAX application needs to implement customized error handling, it must implement this interface and then register an instance with the XML reader using the &lt;a href=&quot;xmlreader#setErrorHandler(org.xml.sax.ErrorHandler)&quot;&gt;&lt;code&gt;setErrorHandler&lt;/code&gt;&lt;/a&gt; method. The parser will then report all errors and warnings through this interface.</source>
          <target state="translated">If a SAX application needs to implement customized error handling, it must implement this interface and then register an instance with the XML reader using the &lt;a href=&quot;xmlreader#setErrorHandler(org.xml.sax.ErrorHandler)&quot;&gt; &lt;code&gt;setErrorHandler&lt;/code&gt; &lt;/a&gt; method. The parser will then report all errors and warnings through this interface.</target>
        </trans-unit>
        <trans-unit id="699d691146da85f7d6329e02b5ea8958eea65fcb" translate="yes" xml:space="preserve">
          <source>If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the &lt;a href=&quot;xmlreader#setEntityResolver(org.xml.sax.EntityResolver)&quot;&gt;&lt;code&gt;setEntityResolver&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the &lt;a href=&quot;xmlreader#setEntityResolver(org.xml.sax.EntityResolver)&quot;&gt; &lt;code&gt;setEntityResolver&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="0cc9dd15259390fb3e7ac0a12e455bdc750c4cf5" translate="yes" xml:space="preserve">
          <source>If a SAX application requires the customized handling which this interface defines for external entities, it must ensure that it uses an XMLReader with the &lt;em&gt;http://xml.org/sax/features/use-entity-resolver2&lt;/em&gt; feature flag set to &lt;em&gt;true&lt;/em&gt; (which is its default value when the feature is recognized). If that flag is unrecognized, or its value is false, or the resolver does not implement this interface, then only the &lt;a href=&quot;../entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt; method will be used.</source>
          <target state="translated">If a SAX application requires the customized handling which this interface defines for external entities, it must ensure that it uses an XMLReader with the &lt;em&gt;http://xml.org/sax/features/use-entity-resolver2&lt;/em&gt; feature flag set to &lt;em&gt;true&lt;/em&gt; (which is its default value when the feature is recognized). If that flag is unrecognized, or its value is false, or the resolver does not implement this interface, then only the &lt;a href=&quot;../entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt; method will be used.</target>
        </trans-unit>
        <trans-unit id="36e370cda70c2e439141820154cd61632fd96375" translate="yes" xml:space="preserve">
          <source>If a SAX parser provides location information to the SAX application, it does so by implementing this interface and then passing an instance to the application using the content handler's &lt;a href=&quot;contenthandler#setDocumentLocator(org.xml.sax.Locator)&quot;&gt;&lt;code&gt;setDocumentLocator&lt;/code&gt;&lt;/a&gt; method. The application can use the object to obtain the location of any other SAX event in the XML source document.</source>
          <target state="translated">If a SAX parser provides location information to the SAX application, it does so by implementing this interface and then passing an instance to the application using the content handler's &lt;a href=&quot;contenthandler#setDocumentLocator(org.xml.sax.Locator)&quot;&gt; &lt;code&gt;setDocumentLocator&lt;/code&gt; &lt;/a&gt; method. The application can use the object to obtain the location of any other SAX event in the XML source document.</target>
        </trans-unit>
        <trans-unit id="33790afd26c1ed1a1a9f56f095ee280b02987ed3" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to create a &lt;code&gt;TrayIcon&lt;/code&gt;. Otherwise the constructor will throw a SecurityException.</source>
          <target state="translated">If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to create a &lt;code&gt;TrayIcon&lt;/code&gt; . Otherwise the constructor will throw a SecurityException.</target>
        </trans-unit>
        <trans-unit id="23738716044ec44efb04a5c326db73bc15c62530" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to get the &lt;code&gt;SystemTray&lt;/code&gt; instance. Otherwise this method will throw a SecurityException.</source>
          <target state="translated">If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to get the &lt;code&gt;SystemTray&lt;/code&gt; instance. Otherwise this method will throw a SecurityException.</target>
        </trans-unit>
        <trans-unit id="d6dfd5ce3a3f3a54e3b033911ffb2f2c1d054b1a" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus cycle root will not be changed.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus cycle root will not be changed.</target>
        </trans-unit>
        <trans-unit id="12612b7cb4320c32adc61321ec0710dfbe600dab" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus owner will not be cleared.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus owner will not be cleared.</target>
        </trans-unit>
        <trans-unit id="1b4ef801a419d4c91c8ce0f0fe4a7ae44b83b337" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;replaceKeyboardFocusManager&quot; in order to replace the the current KeyboardFocusManager. If this permission is not granted, this method will throw a SecurityException, and the current KeyboardFocusManager will be unchanged.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;replaceKeyboardFocusManager&quot; in order to replace the the current KeyboardFocusManager. If this permission is not granted, this method will throw a SecurityException, and the current KeyboardFocusManager will be unchanged.</target>
        </trans-unit>
        <trans-unit id="3c085f80770d9292364ba49610a3d688b254c596" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in order to set the value of this property. If this permission is not granted, this method will throw a SecurityException, and the current value of the property will be left unchanged.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in order to set the value of this property. If this permission is not granted, this method will throw a SecurityException, and the current value of the property will be left unchanged.</target>
        </trans-unit>
        <trans-unit id="419f51299062e187ed812366bb64fa93ee056e2e" translate="yes" xml:space="preserve">
          <source>If a Set of traversal keys has not been explicitly defined for this Component, then this Component's parent's Set is returned. If no Set has been explicitly defined for any of this Component's ancestors, then the current KeyboardFocusManager's default Set is returned.</source>
          <target state="translated">If a Set of traversal keys has not been explicitly defined for this Component, then this Component's parent's Set is returned. If no Set has been explicitly defined for any of this Component's ancestors, then the current KeyboardFocusManager's default Set is returned.</target>
        </trans-unit>
        <trans-unit id="877904e5a9d9ff637ebc73df19af808b92b14754" translate="yes" xml:space="preserve">
          <source>If a Set of traversal keys has not been explicitly defined for this Container, then this Container's parent's Set is returned. If no Set has been explicitly defined for any of this Container's ancestors, then the current KeyboardFocusManager's default Set is returned.</source>
          <target state="translated">If a Set of traversal keys has not been explicitly defined for this Container, then this Container's parent's Set is returned. If no Set has been explicitly defined for any of this Container's ancestors, then the current KeyboardFocusManager's default Set is returned.</target>
        </trans-unit>
        <trans-unit id="54875f0ae002ae009f6261e6ee89713bac0fc513" translate="yes" xml:space="preserve">
          <source>If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</source>
          <target state="translated">Spliterator가 일관되지 않은 특성 세트 (단일 호출에서 또는 여러 호출에서 리턴 된 특성)를보고하면이 Spliterator를 사용한 계산에 대해 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a91c9f9234bda5620ef4d3e6ac923de910e62499" translate="yes" xml:space="preserve">
          <source>If a UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">UDP 소켓을 사용하는 경우 TCP / IP 관련 소켓 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22b4fec2b9413e137341f86ae67c8350043b7d53" translate="yes" xml:space="preserve">
          <source>If a UDT does not have a direct super type, it is not listed here. A row of the &lt;code&gt;ResultSet&lt;/code&gt; object returned by this method describes the designated UDT and a direct supertype. A row has the following columns:</source>
          <target state="translated">If a UDT does not have a direct super type, it is not listed here. A row of the &lt;code&gt;ResultSet&lt;/code&gt; object returned by this method describes the designated UDT and a direct supertype. A row has the following columns:</target>
        </trans-unit>
        <trans-unit id="27875d35d17c64c41e9933d166925700a1b171f4" translate="yes" xml:space="preserve">
          <source>If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.</source>
          <target state="translated">바인딩이이 컨텍스트에 추가되거나이 컨텍스트에서 제거되면 이전에 리턴 된 열거에 대한 영향은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d7601c05999ae661b9aa6d9768d23b6fac1b78b" translate="yes" xml:space="preserve">
          <source>If a border has been set on this component, returns the border's insets, else calls super.getInsets.</source>
          <target state="translated">If a border has been set on this component, returns the border's insets, else calls super.getInsets.</target>
        </trans-unit>
        <trans-unit id="60267cd6f737fd6024fc6b14a87a199eac11a918" translate="yes" xml:space="preserve">
          <source>If a border has been set on this component, returns the border's insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt;.</source>
          <target state="translated">If a border has been set on this component, returns the border's insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4d13fb061d48c8e4e28fb887ecf8598eb732db" translate="yes" xml:space="preserve">
          <source>If a borrow occurs in the days field (in other words, if the computation needs to borrow 1 or -1 month to compensate days), then the computation fails by throwing an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a borrow occurs in the days field (in other words, if the computation needs to borrow 1 or -1 month to compensate days), then the computation fails by throwing an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2b8644225e60775049f73144977a4d20b30637be" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;engineSetSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom implementation to seed itself. This self-seeding will not occur if &lt;code&gt;engineSetSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">&lt;code&gt;engineSetSeed&lt;/code&gt; 에 대한 호출 이 이전에 발생하지 않은 경우, 이 메소드에 대한 첫 번째 호출은이 SecureRandom 구현을 강제로 시드합니다. &lt;code&gt;engineSetSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자동 시딩이 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="911ec002bf686d39657f3069553cf1c3b5b5def4" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;setSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">&lt;code&gt;setSeed&lt;/code&gt; 에 대한 호출 이 이전에 발생하지 않은 경우, 이 메소드에 대한 첫 번째 호출은이 SecureRandom 오브젝트를 강제로 시드합니다. &lt;code&gt;setSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자체 시드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="17ddc7ad6d330841c65c3723b7bd2743059a6602" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done.</source>
          <target state="translated">If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done.</target>
        </trans-unit>
        <trans-unit id="334736f49b8d7e0587d8194db7199baa9d06b47d" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done. This code is used in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt;] . Refer to this specification for further information.</source>
          <target state="translated">If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done. This code is used in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt;] . Refer to this specification for further information.</target>
        </trans-unit>
        <trans-unit id="4c4426a7db97055f91d096bc421ebd9b8de25263" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done. This code is used in [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt;] . Refer to this specification for further information.</source>
          <target state="translated">&lt;code&gt;insertBefore&lt;/code&gt; 또는 &lt;code&gt;removeChild&lt;/code&gt; 와 같은 메서드에 대한 호출이 &quot;부분 유효성&quot;과 관련 하여 &lt;code&gt;Node&lt;/code&gt; 유효하지 않게 만드는 경우이 예외가 발생하고 작업이 수행되지 않습니다. 이 코드는 [ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt; ]에서 사용됩니다. 자세한 내용은이 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12d3ca455a566616659c43d38fa4c19d72a68ea1" translate="yes" xml:space="preserve">
          <source>If a card is present in this terminal when this method is called, it returns immediately.</source>
          <target state="translated">If a card is present in this terminal when this method is called, it returns immediately.</target>
        </trans-unit>
        <trans-unit id="05d89b94bbc85cf7d77886e27828d6c62151d272" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;\u0000&lt;/code&gt; or is in the range &lt;code&gt;\u0080&lt;/code&gt; through &lt;code&gt;\u07ff&lt;/code&gt;, then it is represented by two bytes, to be written in the order shown:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0000&lt;/code&gt; 이거나 &lt;code&gt;\u0080&lt;/code&gt; ~ &lt;code&gt;\u07ff&lt;/code&gt; 범위에있는 경우 , 표시된 순서대로 기록되도록 2 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cced7ce9329a5beb13d9d0de6d94d760dcc0c4e8" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0001&lt;/code&gt; through &lt;code&gt;\u007f&lt;/code&gt;, it is represented by one byte:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0001&lt;/code&gt; ~ &lt;code&gt;\u007f&lt;/code&gt; 범위에 있으면 1 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="07952f6eaca135b300da4ff28ea9b192ef542fea" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0800&lt;/code&gt; through &lt;code&gt;uffff&lt;/code&gt;, then it is represented by three bytes, to be written in the order shown:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0800&lt;/code&gt; 에서 &lt;code&gt;uffff&lt;/code&gt; 까지 의 범위에있는 경우, 표시된 순서대로 3 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0d5494a676f207ae321fc2c494aa6a96120e143c" translate="yes" xml:space="preserve">
          <source>If a character with value &lt;code&gt;ch&lt;/code&gt; occurs in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object at an index no smaller than &lt;code&gt;fromIndex&lt;/code&gt;, then the index of the first such occurrence is returned. For values of &lt;code&gt;ch&lt;/code&gt; in the range from 0 to 0xFFFF (inclusive), this is the smallest value</source>
          <target state="translated">값이 &lt;code&gt;ch&lt;/code&gt; 인 문자 가 &lt;code&gt;fromIndex&lt;/code&gt; 보다 작은 인덱스 에서이 &lt;code&gt;String&lt;/code&gt; 객체가 나타내는 문자 시퀀스에서 발생하는 경우 , 그러한 첫 번째 발생의 인덱스가 리턴됩니다. 0에서 0xFFFF (포함) 범위 의 &lt;code&gt;ch&lt;/code&gt; 값의 경우 가장 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="88d64da6fa30bc481b1c1898ad57b4a92324448a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA&lt;/i&gt;&lt;/a&gt; 문자 세트 &lt;i&gt;레지스트리에&lt;/i&gt; 나열된 문자 세트 가 Java 플랫폼의 구현에서 지원되는 경우 표준 이름은 레지스트리에 나열된 이름이어야합니다. 많은 문자 집합에 레지스트리에 둘 이상의 이름이 지정됩니다.이 경우 레지스트리는 이름 중 하나를</target>
        </trans-unit>
        <trans-unit id="835ccd3a2f50b48c8dbdc664f50805c5e332968a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</target>
        </trans-unit>
        <trans-unit id="cf9fdc46f7fdee2fea015ce250e33d2faa3ab015" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;https://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry에&lt;/i&gt;&lt;/a&gt; 나열된 문자 &lt;i&gt;집합&lt;/i&gt; 이 Java 플랫폼 구현에서 지원되는 경우 정식 이름은 레지스트리에 나열된 이름이어야합니다. 많은 문자 세트는 레지스트리에서 둘 이상의 이름이 지정되며,이 경우 레지스트리는 이름 중 하나를 다음과 같이 식별합니다.</target>
        </trans-unit>
        <trans-unit id="7a4670c109b4e15f0dcd8e95409c55e92f7d1ad1" translate="yes" xml:space="preserve">
          <source>If a class is defined in an &lt;em&gt;unnamed module&lt;/em&gt; then the second element is omitted as shown in &quot;&lt;code&gt;com.foo.loader//com.foo.bar.App.run(App.java:12)&lt;/code&gt;&quot;.</source>
          <target state="translated">If a class is defined in an &lt;em&gt;unnamed module&lt;/em&gt; then the second element is omitted as shown in &quot; &lt;code&gt;com.foo.loader//com.foo.bar.App.run(App.java:12)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="6fc4948186617f7bd346a9a17fd3789662107304" translate="yes" xml:space="preserve">
          <source>If a class loader wishes to define a package with specific properties, such as version information, then the class loader should call this &lt;code&gt;definePackage&lt;/code&gt; method before calling &lt;code&gt;defineClass&lt;/code&gt;. Otherwise, the &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; method will define a package in this class loader corresponding to the package of the newly defined class; the properties of this defined package are specified by &lt;a href=&quot;package&quot;&gt;&lt;code&gt;Package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a class loader wishes to define a package with specific properties, such as version information, then the class loader should call this &lt;code&gt;definePackage&lt;/code&gt; method before calling &lt;code&gt;defineClass&lt;/code&gt; . Otherwise, the &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; &lt;/a&gt; method will define a package in this class loader corresponding to the package of the newly defined class; the properties of this defined package are specified by &lt;a href=&quot;package&quot;&gt; &lt;code&gt;Package&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2e1f6c2a012c9ee1480d2aea7e18a07e1c842c87" translate="yes" xml:space="preserve">
          <source>If a class provides explicit BeanInfo about itself then we add that to the BeanInfo information we obtained from analyzing any derived classes, but we regard the explicit information as being definitive for the current class and its base classes, and do not proceed any further up the superclass chain.</source>
          <target state="translated">클래스가 자신에 대한 명시 적 BeanInfo를 제공하는 경우 파생 클래스를 분석하여 얻은 BeanInfo 정보에 해당 정보를 추가하지만 명시 적 정보는 현재 클래스 및 기본 클래스에 대해 결정적인 것으로 간주하고 더 이상 진행하지 않습니다. 슈퍼 클래스 체인.</target>
        </trans-unit>
        <trans-unit id="2cd6058bf392d70f519fdd4e9472bf934b1511bc" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a &lt;code&gt;PrintQuality&lt;/code&gt; attribute which often controls resolution.</source>
          <target state="translated">If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a &lt;code&gt;PrintQuality&lt;/code&gt; attribute which often controls resolution.</target>
        </trans-unit>
        <trans-unit id="acece6c1313b9c506151182d4c10bc5adcf63087" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a PrintQuality attribute which often controls resolution.</source>
          <target state="translated">클라이언트가 필요한 최소값보다 큰 해상도를 지원하는 프린터를 찾으려면이 속성을 조회 요청에서 제외하고 지원되는 해상도를 직접 쿼리하고 클라이언트의 요구 사항에 가장 적합한 프린터를 지정해야합니다. 요구 사항. 경우에 따라 종종 해상도를 제어하는 ​​PrintQuality 속성을 지정하여보다 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ce72ead2f2b5aae2c69c76ea112e52bebf52e8" translate="yes" xml:space="preserve">
          <source>If a collection refuses to add a particular element for any reason other than that it already contains the element, it</source>
          <target state="translated">컬렉션이 이미 요소를 포함하고있는 것 이외의 다른 이유로 특정 요소 추가를 거부하면 컬렉션</target>
        </trans-unit>
        <trans-unit id="41ab0ee2bc38c356fcd8956baea5b131f76b3cf6" translate="yes" xml:space="preserve">
          <source>If a component hierarchy contains validate roots and the new optimized &lt;code&gt;invalidate()&lt;/code&gt; behavior is enabled, the &lt;code&gt;validate()&lt;/code&gt; method must be invoked on the validate root of a previously invalidated component to restore the validity of the hierarchy later. Otherwise, calling the &lt;code&gt;validate()&lt;/code&gt; method on the top-level container (such as a &lt;code&gt;Frame&lt;/code&gt; object) should be used to restore the validity of the component hierarchy.</source>
          <target state="translated">If a component hierarchy contains validate roots and the new optimized &lt;code&gt;invalidate()&lt;/code&gt; behavior is enabled, the &lt;code&gt;validate()&lt;/code&gt; method must be invoked on the validate root of a previously invalidated component to restore the validity of the hierarchy later. Otherwise, calling the &lt;code&gt;validate()&lt;/code&gt; method on the top-level container (such as a &lt;code&gt;Frame&lt;/code&gt; object) should be used to restore the validity of the component hierarchy.</target>
        </trans-unit>
        <trans-unit id="0d2698c7a918c9b4b3b198d13142ac40d60315ae" translate="yes" xml:space="preserve">
          <source>If a component spans rows it is aligned either to the baseline of the start row (if the baseline-resize behavior is &lt;code&gt;
 CONSTANT_ASCENT&lt;/code&gt;) or the end row (if the baseline-resize behavior is &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt;). The row that the component is aligned to is called the &lt;em&gt;prevailing row&lt;/em&gt;.</source>
          <target state="translated">If a component spans rows it is aligned either to the baseline of the start row (if the baseline-resize behavior is &lt;code&gt; CONSTANT_ASCENT&lt;/code&gt; ) or the end row (if the baseline-resize behavior is &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt; ). The row that the component is aligned to is called the &lt;em&gt;prevailing row&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="6d2eb7a73c51f56dc6865791e43b959fff2b8eaf" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;#connectFailed(java.net.URI,java.net.SocketAddress,java.io.IOException)&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;#connectFailed(java.net.URI,java.net.SocketAddress,java.io.IOException)&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</target>
        </trans-unit>
        <trans-unit id="c4776000b1707ea1d8288ccc9e65458bb1c58a2d" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">프록시 (PROXY 또는 SOCKS) 서버에 연결할 수없는 경우 호출자는 프록시 선택기 에게 프록시 서버를 사용할 수 없음을 알리기 위해 프록시 선택기 의 &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4eae2f1f9567895366b2134e4a320c3d0b03090" translate="yes" xml:space="preserve">
          <source>If a constructor is annotated by the both &lt;code&gt;@java.beans.ConstructorProperties&lt;/code&gt; and &lt;code&gt;@javax.management.ConstructorParameters&lt;/code&gt; annotations the JMX introspection will give an absolute precedence to the latter one.</source>
          <target state="translated">If a constructor is annotated by the both &lt;code&gt;@java.beans.ConstructorProperties&lt;/code&gt; and &lt;code&gt;@javax.management.ConstructorParameters&lt;/code&gt; annotations the JMX introspection will give an absolute precedence to the latter one.</target>
        </trans-unit>
        <trans-unit id="66d389f1702f33b50016c87da612c3454fb27ac7" translate="yes" xml:space="preserve">
          <source>If a cookie corresponding to the given URI already exists, then it is replaced with the new one.</source>
          <target state="translated">주어진 URI에 해당하는 쿠키가 이미 존재하면 새로운 쿠키로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="a0e617630717a0b35f702c38de0ff62f4e555322" translate="yes" xml:space="preserve">
          <source>If a custom system class loader is configured (by means of the system property &lt;code&gt;java.system.class.loader&lt;/code&gt; as specified in the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;getSystemClassLoader&lt;/code&gt;&lt;/a&gt; method) then it must define the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method as specified in &lt;a href=&quot;instrumentation#appendToSystemClassLoaderSearch(java.util.jar.JarFile)&quot;&gt;&lt;code&gt;appendToSystemClassLoaderSearch&lt;/code&gt;&lt;/a&gt;. In other words, a custom system class loader must support the mechanism to add an agent JAR file to the system class loader search.</source>
          <target state="translated">If a custom system class loader is configured (by means of the system property &lt;code&gt;java.system.class.loader&lt;/code&gt; as specified in the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;getSystemClassLoader&lt;/code&gt; &lt;/a&gt; method) then it must define the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method as specified in &lt;a href=&quot;instrumentation#appendToSystemClassLoaderSearch(java.util.jar.JarFile)&quot;&gt; &lt;code&gt;appendToSystemClassLoaderSearch&lt;/code&gt; &lt;/a&gt;. In other words, a custom system class loader must support the mechanism to add an agent JAR file to the system class loader search.</target>
        </trans-unit>
        <trans-unit id="df8f1040f8046d584674ec649bf9175bb489aff9" translate="yes" xml:space="preserve">
          <source>If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">데이터 그램을 즉시 사용할 수 있거나이 채널이 블로킹 모드에 있고 결국 하나를 사용할 수있게되면 데이터 그램이 지정된 바이트 버퍼에 복사되고 소스 주소가 반환됩니다. 이 채널이 비 블로킹 모드에 있고 데이터 그램을 즉시 사용할 수없는 경우이 메서드는 즉시 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0818faad6aab3d19f4e535d7f7f60ce1951d12ec" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator()&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator()&quot;&gt;decimal separator&lt;/a&gt; is substituted.</target>
        </trans-unit>
        <trans-unit id="1a7a080897c03d2a2dec7ade95e887516b9ac13d" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">소수 구분 기호가 있으면 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;소수 구분 기호&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c1f9b7f79d8ec91fb01ae3268899c778ab68a65" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;#setDefault(javax.net.ssl.SSLContext)&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">If a default context was set using the &lt;a href=&quot;#setDefault(javax.net.ssl.SSLContext)&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; . If successful, that object is made the default SSL context and returned.</target>
        </trans-unit>
        <trans-unit id="ef151b03b8bdfd0c5b1285060dc05b180bd41b5a" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">&lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 기본 컨텍스트를 설정 한 경우 리턴됩니다. 그렇지 않은 경우,이 메소드의 첫 번째 호출은 &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; 호출을 트리거합니다 . 성공하면 해당 오브젝트가 기본 SSL 컨텍스트가되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="51c46ada07dadd84ce5e7fda86de6679eac1d1c4" translate="yes" xml:space="preserve">
          <source>If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls &lt;code&gt;revalidate&lt;/code&gt;, validate from here on down.</source>
          <target state="translated">If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls &lt;code&gt;revalidate&lt;/code&gt; , validate from here on down.</target>
        </trans-unit>
        <trans-unit id="6749109880140700857e250f0be8ceceea7ff072" translate="yes" xml:space="preserve">
          <source>If a destination &lt;code&gt;URI&lt;/code&gt; is specified in a PrintRequest and it is not accessible for output by the &lt;code&gt;PrintService&lt;/code&gt;, a &lt;code&gt;PrintException&lt;/code&gt; will be thrown. The &lt;code&gt;PrintException&lt;/code&gt; may implement &lt;code&gt;URIException&lt;/code&gt; to provide a more specific cause.</source>
          <target state="translated">If a destination &lt;code&gt;URI&lt;/code&gt; is specified in a PrintRequest and it is not accessible for output by the &lt;code&gt;PrintService&lt;/code&gt; , a &lt;code&gt;PrintException&lt;/code&gt; will be thrown. The &lt;code&gt;PrintException&lt;/code&gt; may implement &lt;code&gt;URIException&lt;/code&gt; to provide a more specific cause.</target>
        </trans-unit>
        <trans-unit id="14abd8b4a751858e76b43b1c734186c7f7ef97b3" translate="yes" xml:space="preserve">
          <source>If a destination URI is specified in a PrintRequest and it is not accessible for output by the PrintService, a PrintException will be thrown. The PrintException may implement URIException to provide a more specific cause.</source>
          <target state="translated">목적지 URI가 PrintRequest에 지정되고 PrintService에서 출력 할 수없는 경우 PrintException이 발생합니다. PrintException은보다 구체적인 원인을 제공하기 위해 URIException을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a783065a0322b1d63fdf38ac08e5357d228c2b53" translate="yes" xml:space="preserve">
          <source>If a destination is &lt;em&gt;not&lt;/em&gt; set, Flight Recorder retains the recording data until this recording is closed. Use the &lt;a href=&quot;#dump(java.nio.file.Path)&quot;&gt;&lt;code&gt;dump(Path)&lt;/code&gt;&lt;/a&gt; method to manually write data to a file.</source>
          <target state="translated">목적지가 설정 &lt;em&gt;되지 않은&lt;/em&gt; 경우 Flight Recorder는이 기록이 종료 될 때까지 기록 데이터를 유지합니다. 파일에 데이터를 수동으로 쓰 려면 &lt;a href=&quot;#dump(java.nio.file.Path)&quot;&gt; &lt;code&gt;dump(Path)&lt;/code&gt; &lt;/a&gt; 메서드를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="6ce74666e9897477c3b28e650ebfa449dd59159a" translate="yes" xml:space="preserve">
          <source>If a destination is set, this recording is automatically closed after data is successfully copied to the destination path.</source>
          <target state="translated">대상이 설정된 경우 데이터가 대상 경로에 성공적으로 복사 된 후이 기록이 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="ce1a2c4f98ff2d6af0860f8597c46c4d0b903836" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively.</source>
          <target state="translated">If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively.</target>
        </trans-unit>
        <trans-unit id="8bacc9e3344a41d79a4651f2c7e9da527b4943d5" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively. For example, the property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getReceiver&lt;/code&gt; is called: if the class &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; exists in the list of installed MIDI device providers, the first &lt;code&gt;Receiver&lt;/code&gt; device with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Receiver&lt;/code&gt; from that provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Receiver&lt;/code&gt; with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; in the list of all devices (as returned by &lt;code&gt;getMidiDeviceInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Receiver&lt;/code&gt; that can be found in the list of all devices is returned. If that fails, too, a &lt;code&gt;MidiUnavailableException&lt;/code&gt; is thrown.</source>
          <target state="translated">장치 이름을 지정하면 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체 의 결과 목록 이 검색됩니다. 이름이 일치하고 &lt;code&gt;MidiDevice&lt;/code&gt; 가 해당 인터페이스를 구현 하는 첫 번째 목록 이 반환됩니다. 일치하는 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체가 없거나 장치 이름을 지정하지 않으면 결과 목록에서 첫 번째로 적합한 장치가 반환됩니다. 시퀀서 및 신시사이저의 경우, 각 인터페이스를 구현하는 경우 장치가 적합합니다. 수신기와 송신기의 경우 장치는 시퀀서 나 신시사이저를 구현하지 않고 각각 하나 이상의 수신기 나 송신기를 제공하는 경우에 적합합니다. 예를 들어, 값이있는 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 특성 &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; 때 다음과 같은 결과를 초래할 &lt;code&gt;getReceiver&lt;/code&gt; 가 호출됩니다 클래스의 경우 &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; 가 설치된 MIDI 장치 공급자 목록에있는 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 장치를 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 이라는 이름 이 반환됩니다. 찾을 수 없으면 이름에 관계없이 해당 제공자 의 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 가 리턴됩니다. 없는 경우, 모든 장치 목록에서 이름이 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 인 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; ( &lt;code&gt;getMidiDeviceInfo&lt;/code&gt; 가 리턴 한 )가 리턴되거나 발견되지 않은 경우 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 가 리턴됩니다.모든 장치 목록에서 찾을 수 있습니다. 이것도 실패하면 &lt;code&gt;MidiUnavailableException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c348cf79394a1b079ec5b17aaca7e9df6caf0f51" translate="yes" xml:space="preserve">
          <source>If a disconnected &lt;code&gt;RowSet&lt;/code&gt; object modifies some of its data, and it has a writer associated with it, it may be implemented so that it calls on the writer's &lt;code&gt;writeData&lt;/code&gt; method internally to write the updates back to the data source. In order to do this, the writer must first establish a connection with the rowset's data source.</source>
          <target state="translated">If a disconnected &lt;code&gt;RowSet&lt;/code&gt; object modifies some of its data, and it has a writer associated with it, it may be implemented so that it calls on the writer's &lt;code&gt;writeData&lt;/code&gt; method internally to write the updates back to the data source. In order to do this, the writer must first establish a connection with the rowset's data source.</target>
        </trans-unit>
        <trans-unit id="e9228071e448b214400800711814c0f475387695" translate="yes" xml:space="preserve">
          <source>If a doclet object is created and used without the above protocol being followed, then the doclet's behavior is not defined by this interface specification.</source>
          <target state="translated">위의 프로토콜을 따르지 않고 doclet 객체를 만들고 사용하는 경우 doclet의 동작은이 인터페이스 사양에 의해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96852e06c1dca016e17f4895cd5c8ddd5ec791ac" translate="yes" xml:space="preserve">
          <source>If a document is valid, or if a document contains some errors but none of them were fatal and the &lt;code&gt;ErrorHandler&lt;/code&gt; didn't throw any exception, then the method returns normally.</source>
          <target state="translated">If a document is valid, or if a document contains some errors but none of them were fatal and the &lt;code&gt;ErrorHandler&lt;/code&gt; didn't throw any exception, then the method returns normally.</target>
        </trans-unit>
        <trans-unit id="1dc1d0d7d632f8adb52a90a5d33de0f5ebfd86ab" translate="yes" xml:space="preserve">
          <source>If a factory is instantiated, it is invoked with the following parameters to produce the resulting context.</source>
          <target state="translated">팩토리가 인스턴스화되면 결과 매개 변수를 생성하기 위해 다음 매개 변수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="61b02e48c383e6261e3240e4271679924e0689b0" translate="yes" xml:space="preserve">
          <source>If a fieldValue is an object then the toString() method is called on it and its returned value is used as the value for the field enclosed in parenthesis.</source>
          <target state="translated">fieldValue가 객체이면 toString () 메서드가 호출되고 반환 된 값이 괄호로 묶인 필드의 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fbb5e24d20d361c0ea0a62c5f3f2f90aea684d9" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;documentationtool.location&quot;&gt;&lt;code&gt;DocumentationTool.Location&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt;&lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 관리자가 제공되면 &lt;a href=&quot;documentationtool.location&quot;&gt; &lt;code&gt;DocumentationTool.Location&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 위치 와 &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt; &lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt; &lt;/a&gt; 를 처리 할 수 ​​있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdbf6cb18404a64f45d2b8abf710d01eb9d7f2cb" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;standardlocation&quot;&gt;&lt;code&gt;StandardLocation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 관리자가 제공되면 &lt;a href=&quot;standardlocation&quot;&gt; &lt;code&gt;StandardLocation&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 위치를 처리 할 수 ​​있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e77610d088ca1d95b7392fcd2274aef9c2f8d21" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;F&lt;/code&gt; applies to the &lt;code&gt;N&lt;/code&gt;th argument of the target, then &lt;code&gt;F&lt;/code&gt; must be a method handle which takes exactly one argument. The type of &lt;code&gt;F&lt;/code&gt;'s sole argument replaces the corresponding argument type of the target in the resulting adapted method handle. The return type of &lt;code&gt;F&lt;/code&gt; must be identical to the corresponding parameter type of the target.</source>
          <target state="translated">필터하면 &lt;code&gt;F&lt;/code&gt; 가 받는 적용 &lt;code&gt;N&lt;/code&gt; 타겟의 번째 인수 후 &lt;code&gt;F&lt;/code&gt; 는 한 인자를 취하는 방법 핸들이어야한다. 의 타입 &lt;code&gt;F&lt;/code&gt; 의 유일한 인자 생성하도록 핸들 방법에서 대상의 대응하는 인수 유형을 대체한다. &lt;code&gt;F&lt;/code&gt; 의 리턴 유형은 대상의 해당 매개 변수 유형과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8312dbe0498425dc3e432f47a6cc52909ff0f4aa" translate="yes" xml:space="preserve">
          <source>If a fini function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the loop return type.</source>
          <target state="translated">If a fini function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the loop return type.</target>
        </trans-unit>
        <trans-unit id="0f0b37f0970ece4cf3ea7a2708e4bc36a7d62db5" translate="yes" xml:space="preserve">
          <source>If a font in this environment has multiple programmable variations, such as Multiple-Master fonts, only one instance of that font is returned in the &lt;code&gt;Font&lt;/code&gt; array. The other variations must be derived by the application.</source>
          <target state="translated">If a font in this environment has multiple programmable variations, such as Multiple-Master fonts, only one instance of that font is returned in the &lt;code&gt;Font&lt;/code&gt; array. The other variations must be derived by the application.</target>
        </trans-unit>
        <trans-unit id="ecbf1c32c9e3b6f42844e1b54331ad5f191681f7" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type arguments used in the source code.</source>
          <target state="translated">형식 매개 변수 유형이 매개 변수화 된 유형 인 경우 이에 대해 반환 된 &lt;code&gt;Type&lt;/code&gt; 개체는 소스 코드에서 사용되는 실제 유형 인수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="77fff40663a1f21028623e35281e042a8419f5f8" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">형식 매개 변수 유형이 매개 변수화 된 유형 인 경우, 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="48218943f2a8994e2b422a9456a012477f87f4f0" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">형식 매개 변수 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa45ce5030fe67e696cd9c90f1c3d32a9e26312" translate="yes" xml:space="preserve">
          <source>If a format specifier contains a conversion character that is not applicable to the corresponding argument, then an &lt;a href=&quot;illegalformatconversionexception&quot;&gt;&lt;code&gt;IllegalFormatConversionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">형식 지정자에 해당 인수에 적용 할 수없는 변환 문자가 포함 된 경우 &lt;a href=&quot;illegalformatconversionexception&quot;&gt; &lt;code&gt;IllegalFormatConversionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47e2137fd18da09bdd7e054d7015bc33023b31e0" translate="yes" xml:space="preserve">
          <source>If a given &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies no static arguments, the instruction's bootstrap method will be invoked on three arguments, conveying the instruction's caller class, name, and method type. If the &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies one or more static arguments, those values will be passed as additional arguments to the method handle. (Note that because there is a limit of 255 arguments to any method, at most 251 extra arguments can be supplied, since the bootstrap method handle itself and its first three arguments must also be stacked.) The bootstrap method will be invoked as if by either &lt;code&gt;MethodHandle.invoke&lt;/code&gt; or &lt;code&gt;invokeWithArguments&lt;/code&gt;. (There is no way to tell the difference.)</source>
          <target state="translated">주어진 &lt;code&gt;invokedynamic&lt;/code&gt; 명령이 정적 인수를 지정하지 않으면 명령의 부트 스트랩 메소드는 명령의 호출자 클래스, 이름 및 메소드 유형을 전달하는 세 개의 인수에서 호출됩니다. 경우] &lt;code&gt;invokedynamic&lt;/code&gt; 명령이 하나 개 이상의 정적 인수 지정이 값은 방법 핸들 추가적인 인수로 전달한다. (모든 메소드에는 255 개의 인수가 제한되어 있기 때문에 부트 스트랩 메소드 자체를 처리하고 처음 세 개의 인수도 스택해야하므로 최대 251 개의 추가 인수를 제공 할 수 있습니다.) 부트 스트랩 메소드는 다음과 같이 호출됩니다. &lt;code&gt;MethodHandle.invoke&lt;/code&gt; 또는 &lt;code&gt;invokeWithArguments&lt;/code&gt; 중 하나 입니다. (차이를 알 수있는 방법이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="a80d4c3ad4e53040c1a39d7a7bdca9679c68c78f" translate="yes" xml:space="preserve">
          <source>If a horizontal scrollbar is needed, it is treated like the column header (see the paragraph above regarding the vertical scrollbar).</source>
          <target state="translated">If a horizontal scrollbar is needed, it is treated like the column header (see the paragraph above regarding the vertical scrollbar).</target>
        </trans-unit>
        <trans-unit id="1b302c4fa309e55608aa77d71aa898540e38e284" translate="yes" xml:space="preserve">
          <source>If a host is given then it is appended. If the host is a literal IPv6 address but is not enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;) then the square brackets are added.</source>
          <target state="translated">호스트가 제공되면 호스트가 추가됩니다. 호스트가 리터럴 IPv6 주소이지만 대괄호 ( &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; )로 묶이지 않은 경우 대괄호가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3c059615b57ed62378344964e37548f3b0e6335b" translate="yes" xml:space="preserve">
          <source>If a list of several images was specified as a Window's icon, this method will return the first item of the list.</source>
          <target state="translated">If a list of several images was specified as a Window's icon, this method will return the first item of the list.</target>
        </trans-unit>
        <trans-unit id="7a15cd0977f55c58d7c0850d3c01c8a63da1d40d" translate="yes" xml:space="preserve">
          <source>If a logical line is spread across several natural lines, the backslash escaping the line terminator sequence, the line terminator sequence, and any white space at the start of the following line have no affect on the key or element values. The remainder of the discussion of key and element parsing (when loading) will assume all the characters constituting the key and element appear on a single natural line after line continuation characters have been removed. Note that it is</source>
          <target state="translated">논리적 선이 여러 개의 자연 선으로 분산 된 경우 선 종결 자 시퀀스, 선 종결 자 시퀀스 및 다음 줄의 시작 부분의 공백을 이스케이프하는 백 슬래시는 키 또는 요소 값에 영향을 미치지 않습니다. 키 및 요소 구문 분석 (로드시)에 대한 나머지 설명에서는 키와 요소를 구성하는 모든 문자가 줄 연속 문자가 제거 된 후 하나의 자연 줄에 나타나는 것으로 가정합니다. 참고</target>
        </trans-unit>
        <trans-unit id="cd8e0bbcc783eadd4865fc925b200f06558d3ae6" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the component's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the component's &lt;code&gt;TransferHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6cc836fe190aff287b75e0daabe7ceb48e9d86e" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the list's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">이 속성을 무시하는 룩앤필이 사용 된 경우에도 목록의 &lt;code&gt;TransferHandler&lt;/code&gt; 에서 &lt;code&gt;exportAsDrag&lt;/code&gt; 를 호출하여 드래그 앤 드롭 작업을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfc09a82d3ef30f5685534ffe059fc2caa38aa88" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the table's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">이 속성을 무시하는 룩앤필이 사용 된 경우에도 테이블의 &lt;code&gt;TransferHandler&lt;/code&gt; 에서 &lt;code&gt;exportAsDrag&lt;/code&gt; 를 호출하여 끌어서 놓기 작업을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccd26ad32dd26739826327f4b3d5f7134a7882ee" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the tree's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">이 속성을 무시하는 룩앤필이 사용 된 경우에도 트리의 &lt;code&gt;TransferHandler&lt;/code&gt; 에서 &lt;code&gt;exportAsDrag&lt;/code&gt; 를 호출하여 끌어서 놓기 작업을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2255669d20b77ac21c330711ce13f6ea363e0b8f" translate="yes" xml:space="preserve">
          <source>If a mapping for &lt;code&gt;uiClassID&lt;/code&gt; exists or if the specified class can't be found, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uiClassID&lt;/code&gt; 에 대한 매핑 이 존재하거나 지정된 클래스를 찾을 수없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3a82003bc08000c8f46219ed82ab846fd6727cbe" translate="yes" xml:space="preserve">
          <source>If a match to the specified pattern is not found at the current position, then no input is skipped and a &lt;code&gt;NoSuchElementException&lt;/code&gt; is thrown.</source>
          <target state="translated">지정된 패턴과 일치하는 항목이 현재 위치에 없으면 입력을 건너 뛰지 않고 &lt;code&gt;NoSuchElementException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e40a20d79d378f273949a8affbffa48e1bdad009" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;public&lt;/code&gt; entry is found, it is returned immediately.</source>
          <target state="translated">일치하는 경우 &lt;code&gt;public&lt;/code&gt; 항목이 발견되면 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f69b5cff049ebc9630323ba63bb4d652364d38f2" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;system&lt;/code&gt; entry exists, it is returned immediately.</source>
          <target state="translated">매칭 &lt;code&gt;system&lt;/code&gt; 항목이 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="42a4c103812a63e5b048b88e9e4af583a5c904c6" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;uri&lt;/code&gt; entry is found, it is returned immediately.</source>
          <target state="translated">일치하는 &lt;code&gt;uri&lt;/code&gt; 항목이 발견되면 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="041906718779e0735497b8d8a4420c278fc6dbb9" translate="yes" xml:space="preserve">
          <source>If a mechanism is listed in the &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; security property, it will be ignored and won't be negotiated.</source>
          <target state="translated">메커니즘이 &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; 에 나열되는 경우 보안 속성에 있으면 무시되고 협상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ce32eacabe9190e4c01f4f8f502405a2477637b" translate="yes" xml:space="preserve">
          <source>If a message or notification is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the message or notification is returned or handled, respectively. If this channel is in non-blocking mode and a message or notification is not immediately available then this method immediately returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">메시지 또는 알림을 즉시 사용할 수 있거나이 채널이 차단 모드에 있고 결국 사용할 수있게되면 메시지 또는 알림이 각각 반환되거나 처리됩니다. 이 채널이 비 차단 모드이고 메시지 또는 알림을 즉시 사용할 수없는 경우이 메서드는 즉시 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="03f7ab2c34aa311345e83cbc387505226e713e48" translate="yes" xml:space="preserve">
          <source>If a method handle for a caller-sensitive method is requested, the general rules for &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply, but they take account of the lookup class in a special way. The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class. (By contrast, the invoker of the method handle is disregarded.) Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles.</source>
          <target state="translated">호출자 구분 메소드에 대한 메소드 핸들이 요청되면 &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;바이트 코드 동작에&lt;/a&gt; 대한 일반 규칙이 적용되지만 특수한 방식으로 조회 클래스를 고려합니다. 결과 메소드 핸들은 조회 클래스에 포함 된 명령에서 호출 된 것처럼 작동하므로 호출자 감지 메소드는 조회 클래스를 감지합니다. 대조적으로, 메소드 핸들의 호출자는 무시됩니다. 따라서 호출자 감지 메소드의 경우, 다른 검색 클래스가 다르게 작동하는 메소드 핸들을 야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de9caf9128a5abc525b8ff949c024d6c3b7462b7" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned.</source>
          <target state="translated">믹서 이름이 지정되면 &lt;code&gt;Mixer.Info&lt;/code&gt; 개체 의 결과 목록 이 검색됩니다. 일치하는 이름을 가진 첫 번째 목록 과 해당 &lt;code&gt;Mixer&lt;/code&gt; 가 해당 라인 인터페이스를 제공 하는 믹서 가 반환됩니다. 일치하는 &lt;code&gt;Mixer.Info&lt;/code&gt; 가 없는 경우 개체가 없거나 믹서 이름이 지정되지 않은 경우 결과 목록에서 각 라인 인터페이스를 제공하는 첫 번째 믹서가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4e595c2df825132a51481c97b50495434dfe5e" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned. For example, the property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getLine&lt;/code&gt; is called requesting a &lt;code&gt;Clip&lt;/code&gt; instance: if the class &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; exists in the list of installed mixer providers, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer of the specified provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Clip&lt;/code&gt; from the first &lt;code&gt;Mixer&lt;/code&gt; with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; in the list of all mixers (as returned by &lt;code&gt;getMixerInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Clip&lt;/code&gt; of the first &lt;code&gt;Mixer&lt;/code&gt;that can be found in the list of all mixers is returned. If that fails, too, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">믹서 이름을 지정하면 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체 의 결과 목록 이 검색됩니다. 이름이 일치하고 &lt;code&gt;Mixer&lt;/code&gt; 가 해당 회선 인터페이스를 제공 하는 첫 번째 목록 이 반환됩니다. 일치하는 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체가 없거나 믹서 이름을 지정하지 않으면 결과 목록에서 각 라인 인터페이스를 제공하는 첫 번째 믹서가 반환됩니다. 예를 들어, 값이 &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; 인 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 등록 정보 는 &lt;code&gt;getLine&lt;/code&gt; 이 &lt;code&gt;Clip&lt;/code&gt; 인스턴스 요청 시 호출 될 때 다음과 같은 결과를 초래 합니다. 클래스 &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; 설치된 믹서 제공 업체 목록에 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 이라는 이름을 가진 첫 번째 믹서의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 반환됩니다. 찾을 수 없으면 지정된 공급자의 첫 번째 믹서의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 이름에 관계없이 반환됩니다. 없는 경우, 모든 믹서 목록에서 이름이 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 인 첫 번째 &lt;code&gt;Mixer&lt;/code&gt; 의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; ( &lt;code&gt;getMixerInfo&lt;/code&gt; 에서 반환 됨 )이 반환되거나 발견되지 않으면 첫 번째 &lt;code&gt;Mixer&lt;/code&gt; 의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 발견 될 수 있습니다 모든 믹서 목록에 반환됩니다. 이것도 실패하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57d4cb4422179df06d85df6edeaf036f2c77e296" translate="yes" xml:space="preserve">
          <source>If a module declares more than one provider then the providers are located in the order that its module descriptor &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;lists the providers&lt;/a&gt;. Providers added dynamically by instrumentation agents (see &lt;a href=&quot;../../../java.instrument/java/lang/instrument/instrumentation#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)&quot;&gt;&lt;code&gt;redefineModule&lt;/code&gt;&lt;/a&gt;) are always located after providers declared by the module.</source>
          <target state="translated">모듈이 둘 이상의 공급자를 선언하면 공급자는 해당 모듈 설명자가 &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;공급자를 나열하는&lt;/a&gt; 순서대로 배치됩니다 . 계측 에이전트에 의해 동적으로 추가 된 공급자 ( &lt;a href=&quot;../../../java.instrument/java/lang/instrument/instrumentation#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)&quot;&gt; &lt;code&gt;redefineModule&lt;/code&gt; &lt;/a&gt; 참조) )에 는 항상 모듈에서 선언 한 공급자 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="efaf60a7b1c87aa4ff2f97aa446a4442865cc86e" translate="yes" xml:space="preserve">
          <source>If a module declares more than one provider then the providers are located in the order that its module descriptor &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;lists the providers&lt;/a&gt;. Providers added dynamically by instrumentation agents are always located after providers declared by the module.</source>
          <target state="translated">모듈이 둘 이상의 공급자를 선언하면 공급자는 해당 모듈 설명자가 &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;공급자를 나열하는&lt;/a&gt; 순서대로 배치됩니다. . 계측 에이전트에 의해 동적으로 추가 된 공급자는 항상 모듈에서 선언 한 공급자 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2898de51e2cf727ad3969c2fe5a2e8ee04593e2d" translate="yes" xml:space="preserve">
          <source>If a mouse has more than three enabled buttons then more values are admissible (4, 5, etc.). There is no assigned constants for these extended buttons. The button masks for the extra buttons returned by this method have no assigned names like the first three button masks.</source>
          <target state="translated">마우스에 3 개 이상의 활성화 된 버튼이있는 경우 더 많은 값이 허용됩니다 (4, 5 등). 이러한 확장 버튼에는 지정된 상수가 없습니다. 이 메서드가 반환하는 추가 버튼의 버튼 마스크에는 처음 세 개의 버튼 마스크와 같이 할당 된 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8a0c1b372f5ed387a77d0a8139d565c090fb292" translate="yes" xml:space="preserve">
          <source>If a mutable target is not required, an &lt;code&gt;invokedynamic&lt;/code&gt; instruction may be permanently bound by means of a &lt;a href=&quot;constantcallsite&quot;&gt;constant call site&lt;/a&gt;.</source>
          <target state="translated">변경 가능한 대상이 필요하지 않은 경우 &lt;code&gt;invokedynamic&lt;/code&gt; 명령은 &lt;a href=&quot;constantcallsite&quot;&gt;상수 호출 사이트를&lt;/a&gt; 통해 영구적으로 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d153e3199dbf3a239e1e74edc668dcfac7b620a7" translate="yes" xml:space="preserve">
          <source>If a mutable target is required which has volatile variable semantics, because updates to the target must be immediately and reliably witnessed by other threads, a &lt;a href=&quot;volatilecallsite&quot;&gt;volatile call site&lt;/a&gt; may be used.</source>
          <target state="translated">휘발성 변수 의미가있는 가변 대상이 필요한 경우 다른 스레드가 대상에 대한 업데이트를 즉시 확실하게 감시해야하므로 &lt;a href=&quot;volatilecallsite&quot;&gt;휘발성 호출 사이트를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeca574c1ffd9cbc5b38291c6b65f0adb833dc01" translate="yes" xml:space="preserve">
          <source>If a name for the desired display language is not available, the method may fall back to some other language.</source>
          <target state="translated">원하는 표시 언어의 이름을 사용할 수없는 경우 메서드가 다른 언어로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="657a9f6756d750ee4adc0e4bbc100a654dce7128" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7be17e75afa7fb0ce61b9792a5c8387c175a86f7" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 고유 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="82b7eb3aeab5135e75a853270d3a38d65b14ccb2" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 문서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96afaaa19f7e5c5798f8d8403e551ecc219a3743" translate="yes" xml:space="preserve">
          <source>If a native receiver provided by the default device does not implement the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface. The corresponding &lt;code&gt;Receiver&lt;/code&gt; method calls will be forwarded to the native receiver.</source>
          <target state="translated">기본 장치에서 제공하는 기본 수신기가 구현하지 않는 경우 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 의 인터페이스를, 그것은 래퍼 클래스가 구현하는 것을 감싸됩니다 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 의 인터페이스를 제공합니다. 해당 &lt;code&gt;Receiver&lt;/code&gt; 메소드 호출은 기본 수신자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f15617aacf84e28d7719762bc77a6e2a240fb2d8" translate="yes" xml:space="preserve">
          <source>If a native transmitter provided by the default device does not implement the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface. The corresponding &lt;code&gt;Transmitter&lt;/code&gt; method calls will be forwarded to the native transmitter.</source>
          <target state="translated">기본 장치에서 제공하는 기본 송신기가 구현하지 않는 경우 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 의 인터페이스를, 그것은 래퍼 클래스가 구현하는 것을 감싸됩니다 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 의 인터페이스를 제공합니다. 해당 &lt;code&gt;Transmitter&lt;/code&gt; 메소드 호출은 기본 송신기로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5e81249a7f19b34aae5c963bc81798bff7133902" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will be configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 생성되면 로그 수준이 LogManager를 기반으로 구성되며 로깅 출력도 부모의 처리기로 보내도록 구성됩니다. LogManager 전역 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e885f68e1bc095b374d6b1ebbe1a47153753c95e" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 작성되면 로그 레벨은 LogManager를 기반으로 구성되며 로깅 출력을 상위 핸들러로 보내도록 구성됩니다. LogManager 글로벌 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="88b90c99db81cefd92b6c450a7c98a50da340a3f" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will be configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 생성되면 로그 수준이 LogManager 구성을 기반으로 구성되며 로깅 출력도 부모의 처리기로 보내도록 구성됩니다. LogManager 전역 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="5e945b5d1146ab0148461e7bb66b4cc1b6317073" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 작성되면 로그 레벨은 LogManager 구성을 기반으로 구성되며 로깅 출력을 상위 핸들러로 보내도록 구성됩니다. LogManager 글로벌 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a4f0b05b5c2d22a20b05a71a5d7c135620cfeb" translate="yes" xml:space="preserve">
          <source>If a non-null &lt;code&gt;AbstractFormatter&lt;/code&gt; has not been found, use the default formatter.</source>
          <target state="translated">널 이 아닌 &lt;code&gt;AbstractFormatter&lt;/code&gt; 를 찾지 못한 경우 기본 포맷터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e4374be394b79479c7e1fa5bcc1e8102ae6664e5" translate="yes" xml:space="preserve">
          <source>If a non-null CodeSource is supplied a ProtectionDomain is constructed and associated with the class being defined.</source>
          <target state="translated">널이 아닌 코드 소스가 제공되면 ProtectionDomain이 구성되고 정의중인 클래스와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="12aed712a666305d6484724aaf08bd2e1171c900" translate="yes" xml:space="preserve">
          <source>If a non-null message was supplied in a constructor it is returned. Otherwise, an implementation specific message or &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">생성자에 널이 아닌 메시지가 제공된 경우 리턴됩니다. 그렇지 않으면 구현 특정 메시지 또는 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ed948d67e59d3b1ab1a6ab69b72cf90841f818b2" translate="yes" xml:space="preserve">
          <source>If a non-null value is returned, then the PropertyEditor should be prepared to parse that string back in setAsText().</source>
          <target state="translated">널이 아닌 값이 리턴되면 PropertyEditor는 해당 문자열을 다시 setAsText ()로 구문 분석 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="f75d62399906604e72f84182bca91703960c54bf" translate="yes" xml:space="preserve">
          <source>If a null dispatcher is specified, if the specified dispatcher is not in the dispatcher chain, or if this KeyboardFocusManager is specified without having been explicitly re-registered, no action is taken and no exception is thrown.</source>
          <target state="translated">널 디스패처가 지정된 경우, 지정된 디스패처가 디스패처 체인에 없거나 명시 적으로 다시 등록되지 않고이 KeyboardFocusManager가 지정된 경우에는 작업이 수행되지 않고 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f7c58a9060f8818a2c1c94eb51743d12a9a275a" translate="yes" xml:space="preserve">
          <source>If a null dispatcher is specified, no action is taken and no exception is thrown.</source>
          <target state="translated">널 디스패처가 지정되면 조치가 수행되지 않고 예외도 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9858a7d611d85aa9445822454181b23692a649db" translate="yes" xml:space="preserve">
          <source>If a null post-processor is specified, if the specified post-processor is not in the post-processor chain, or if this KeyboardFocusManager is specified without having been explicitly added, no action is taken and no exception is thrown.</source>
          <target state="translated">널 포스트 프로세서가 지정되거나 지정된 포스트 프로세서가 포스트 프로세서 체인에 없거나 명시 적으로 추가되지 않고이 KeyboardFocusManager가 지정된 경우에는 작업이 수행되지 않고 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80e5e24189da6aec4a702f1b11675b7d716e2c68" translate="yes" xml:space="preserve">
          <source>If a null post-processor is specified, no action is taken and no exception is thrown.</source>
          <target state="translated">널 포스트 프로세서가 지정되면 조치가 수행되지 않고 예외도 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9d7fb43a6f9ab347881ca798d47872764ac074f" translate="yes" xml:space="preserve">
          <source>If a number is preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and a year has already been recognized, then the number is a time-zone offset. If the number is less than 24, it is an offset measured in hours. Otherwise, it is regarded as an offset in minutes, expressed in 24-hour time format without punctuation. A preceding &lt;code&gt;-&lt;/code&gt; means a westward offset. Time zone offsets are always relative to UTC (Greenwich). Thus, for example, &lt;code&gt;-5&lt;/code&gt; occurring in the string would mean &quot;five hours west of Greenwich&quot; and &lt;code&gt;+0430&lt;/code&gt; would mean &quot;four hours and thirty minutes east of Greenwich.&quot; It is permitted for the string to specify &lt;code&gt;GMT&lt;/code&gt;, &lt;code&gt;UT&lt;/code&gt;, or &lt;code&gt;UTC&lt;/code&gt; redundantly-for example, &lt;code&gt;GMT-5&lt;/code&gt; or &lt;code&gt;utc+0430&lt;/code&gt;.</source>
          <target state="translated">숫자 앞에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 가 있고 연도가 이미 인식 된 경우 숫자는 시간대 오프셋입니다. 숫자가 24보다 작 으면 시간 단위로 측정 된 오프셋입니다. 그렇지 않으면 구두점없이 24 시간 형식으로 표현 된 분 단위 오프셋으로 간주됩니다. 앞에 &lt;code&gt;-&lt;/code&gt; 는 서쪽 방향 오프셋을 의미합니다. 시간대 오프셋은 항상 UTC (그리니치)를 기준으로합니다. 예를 들어, 문자열에서 &lt;code&gt;-5&lt;/code&gt; 가 발생하면 &quot;그리니치에서 서쪽으로 5 시간&quot; 을 의미 하고 &lt;code&gt;+0430&lt;/code&gt; 은 &quot;그리니치에서 동쪽으로 4 시간 30 분&quot;을 의미합니다. 문자열이 &lt;code&gt;GMT&lt;/code&gt; , &lt;code&gt;UT&lt;/code&gt; 또는 &lt;code&gt;UTC&lt;/code&gt; 를 중복 으로 지정할 수 있습니다 (예 : &lt;code&gt;GMT-5&lt;/code&gt; 또는 &lt;code&gt;utc+0430&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">기본 개체가 매개 변수 또는 작업을 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="81c0651f2b5e452650a2ea674b863476cc997e33" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;#getDeclaredType(javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeElement,javax.lang.model.type.TypeMirror...)&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수가있는 형식이 반환되는 경우 해당 형식 요소는 일반 외부 클래스에 포함되지 않아야합니다. 예를 들어 매개 변수화 된 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; 유형을 가져온 다음 &lt;a href=&quot;#getDeclaredType(javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeElement,javax.lang.model.type.TypeMirror...)&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 생성 할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="a7e7b1f4d4e8c47890d4e04c211a6340b6dc972a" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수화 된 유형이 리턴되는 경우 해당 유형 요소는 일반 외부 클래스 내에 포함되지 않아야합니다. 예를 들어, 매개 변수화 된 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; 메소드를 사용하여 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; 을 가져온 후 &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43ccbd75a69c5df862ae14549f2be12f58f6705e" translate="yes" xml:space="preserve">
          <source>If a parsing error occurs, the exception that is thrown will include information about the location of the error in the original XML document.</source>
          <target state="translated">구문 분석 오류가 발생하면 throw되는 예외에 원본 XML 문서의 오류 위치에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b860cee6c1daa1284a85c7a9b7c1c7d6c9380907" translate="yes" xml:space="preserve">
          <source>If a particular concrete charset provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">특정 콘크리트 문자 세트 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 반드시 파일을로드 한 클래스 로더는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fbd441057e8700833c9533c87ba431e637f763c4" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.</source>
          <target state="translated">특정 구체적 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 이것은 파일이 실제로로드 된 클래스 로더 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5da4bf007198af6025012fc0fecd914082583539" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">특정 구체적 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 반드시 파일을로드 한 클래스 로더는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="11cee8d3b1bf0c5f932f0904e55f7a8ab8555e41" translate="yes" xml:space="preserve">
          <source>If a particular provider is specified by a &lt;code&gt;RowSet&lt;/code&gt; object, and the &lt;code&gt;SyncFactory&lt;/code&gt; does not contain a reference to this provider, a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown stating that the synchronization provider could not be found.</source>
          <target state="translated">특정 공급자가 &lt;code&gt;RowSet&lt;/code&gt; 개체에 의해 지정되고 &lt;code&gt;SyncFactory&lt;/code&gt; 에이 공급자에 대한 참조가 포함되지 않은 경우 동기화 공급자를 찾을 수 없음을 나타내는 &lt;code&gt;SyncFactoryException&lt;/code&gt; 이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="29590084579273dadce0a572331ee22aa9d1bda8" translate="yes" xml:space="preserve">
          <source>If a partition has no elements, its value in the result Map will be an empty List.</source>
          <target state="translated">파티션에 요소가없는 경우 결과 맵의 해당 값은 빈 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="42129ba221a5197a6e8db6241f12cd2c90200f85" translate="yes" xml:space="preserve">
          <source>If a partition has no elements, its value in the result Map will be obtained by calling the downstream collector's supplier function and then applying the finisher function.</source>
          <target state="translated">파티션에 요소가없는 경우 결과 맵의 값은 다운 스트림 수집기의 공급 업체 함수를 호출 한 다음 마무리 기능을 적용하여 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d5668fe10c0723c5fca50dcc78c1b35e4b358bc9" translate="yes" xml:space="preserve">
          <source>If a path is given then it is appended. Any character not in the</source>
          <target state="translated">경로가 제공되면 추가됩니다. 에없는 모든 문자</target>
        </trans-unit>
        <trans-unit id="0e5a965d6474edf02c5830767daff8c0d82cf26d" translate="yes" xml:space="preserve">
          <source>If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.</source>
          <target state="translated">패턴을 여러 번 사용하는 경우 한 번 컴파일 한 후 재사용하면 매번이 메소드를 호출하는 것보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="89b4c008a45797eef3268e7fe508720bf307f893" translate="yes" xml:space="preserve">
          <source>If a permit is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">허가가 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="42b24fec51a71ad010963ae360a48a8c5d862862" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;#setPersistenceDelegate(java.lang.Class,java.beans.PersistenceDelegate)&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">지속성 위임이 &lt;a href=&quot;#setPersistenceDelegate(java.lang.Class,java.beans.PersistenceDelegate)&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 주어진 유형과 연관되면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="619e1dee8db482adbcc19510b522caad9b3dd86b" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">지속성 대리자가 &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 지정된 유형과 연관되어 있으면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="11d9ed1e56dc29ed992752f78c70910959ce2ab4" translate="yes" xml:space="preserve">
          <source>If a port number is given then a colon character (&lt;code&gt;':'&lt;/code&gt;) is appended, followed by the port number in decimal.</source>
          <target state="translated">포트 번호가 제공되면 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; )가 추가되고 그 뒤에 포트 번호가 10 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d701428b48ae7874b54baebebd1df48be574b193" translate="yes" xml:space="preserve">
          <source>If a pred function is omitted, use a constant &lt;code&gt;true&lt;/code&gt; function. (This will keep the loop going, as far as this clause is concerned. Note that in such cases the corresponding fini function is unreachable.)</source>
          <target state="translated">pred 함수가 생략 된 경우 상수 &lt;code&gt;true&lt;/code&gt; 함수를 사용하십시오. (이것은이 절에 관한 한 루프를 계속 진행할 것입니다. 이러한 경우 해당 fini 함수에 도달 할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="1e2d6f69246267134b84e23e4dd1a1f828cae635" translate="yes" xml:space="preserve">
          <source>If a pred function returns &lt;code&gt;false&lt;/code&gt;, the corresponding fini function is called, and the resulting value (of type &lt;code&gt;R&lt;/code&gt;) is returned from the loop as a whole.</source>
          <target state="translated">pred 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 해당 fini 함수가 호출되고 결과 값 ( &lt;code&gt;R&lt;/code&gt; 유형 )이 전체 루프에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caf5336d5c7e67a44f03340f4fbe7da00052aa6b" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel &lt;code&gt;Component&lt;/code&gt;. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the &lt;code&gt;AttributeSet&lt;/code&gt;. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">인쇄 서비스에서 공급 업체 확장을 제공하는 경우 공급 업체에서 제공하는 탭 패널 &lt;code&gt;Component&lt;/code&gt; 통해 사용자가 액세스 할 수 있습니다 . 이러한 공급 업체 확장은 Swing을 사용하는 것이 좋습니다! 접근성 API를 지원합니다. 공급 업체 확장은 &lt;code&gt;AttributeSet&lt;/code&gt; 의 일부로 설정을 반환해야합니다 . 사용자 설정을 보존하려는 응용 프로그램은 해당 설정을 사용하여 인쇄 작업을 지정해야합니다. 이 클래스는 Java Print Service의 다른 부분에서 참조되지 않으며 AWT 패키지의 존재 여부에 의존 할 수없는 프로파일에 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d056108653d02210141b2a751f0e69e31fb1fd" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel Component. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the AttributeSet. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">인쇄 서비스가 공급 업체 확장을 제공하는 경우 공급 업체 제공 탭 패널 구성 요소를 통해 사용자가 액세스 할 수 있습니다. 이러한 공급 업체 확장 프로그램은 Swing! 접근성 API를 지원합니다. 공급 업체 확장은 설정을 AttributeSet의 일부로 반환해야합니다. 사용자 설정을 유지하려는 응용 프로그램은 해당 설정을 사용하여 인쇄 작업을 지정해야합니다. 이 클래스는 Java 인쇄 서비스의 다른 부분에서 참조되지 않으며 AWT 패키지의 존재에 의존 할 수없는 프로파일에는 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59af891bcb7ad7848a092781a278ba855f208533" translate="yes" xml:space="preserve">
          <source>If a printer does not support the &lt;code&gt;SheetCollate&lt;/code&gt; attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though &lt;code&gt;SheetCollate&lt;/code&gt; were always set to &lt;code&gt;COLLATED&lt;/code&gt;.</source>
          <target state="translated">프린터가 &lt;code&gt;SheetCollate&lt;/code&gt; 속성을 지원하지 않는 경우 (클라이언트가 특정 시트 데이터 정렬을 지정할 수 없음) 프린터는 &lt;code&gt;SheetCollate&lt;/code&gt; 가 항상 &lt;code&gt;COLLATED&lt;/code&gt; 로 설정된 것처럼 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f29ea7b220242b9cb8462cb83e9acfd3082297b2" translate="yes" xml:space="preserve">
          <source>If a printer does not support the SheetCollate attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though SheetCollate were always set to COLLATED.</source>
          <target state="translated">프린터가 SheetCollate 특성을 지원하지 않으면 (클라이언트가 특정 시트 정렬을 지정할 수 없음을 의미) 프린터는 SheetCollate가 항상 COLLATED로 설정된 것처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="49665e43d0c605dc9888cfc626aa1ab47db7f814" translate="yes" xml:space="preserve">
          <source>If a processor object is created and used without the above protocol being followed, then the processor's behavior is not defined by this interface specification.</source>
          <target state="translated">위의 프로토콜을 따르지 않고 프로세서 객체를 만들어 사용하는 경우이 인터페이스 사양에 따라 프로세서의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81af254ec927065b733bde24b627fbd0490e34d9" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised()&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">프로세서에서 포착되지 않은 예외가 발생하면 도구가 다른 활성 주석 프로세서를 중지 할 수 있습니다. 프로세서에서 오류가 발생하면 현재 라운드가 완료 될 때까지 실행되고 후속 라운드에서 &lt;a href=&quot;roundenvironment#errorRaised()&quot;&gt;오류가 발생&lt;/a&gt; 했음을 나타냅니다 . 주석 프로세서는 협력 환경에서 실행되기 때문에 프로세서는 오류 복구 나보고가 불가능한 상황에서만 포착되지 않은 예외를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="ca6e8c92cea494ed3f4a024c3b0fdf6756539fd3" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">프로세서가 포착되지 않은 예외를 처리하면 도구가 다른 활성 주석 프로세서를 중지 할 수 있습니다. 프로세서에서 오류가 발생하면 현재 라운드가 완료되고 다음 라운드에서 &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;오류가 발생&lt;/a&gt; 했음을 나타냅니다 . 어노테이션 프로세서는 협업 환경에서 실행되므로 오류 복구 또는보고가 불가능한 상황에서만 프로세서가 포착되지 않은 예외를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb6c65b34b95b44418e49ca6b3559cef82f09432" translate="yes" xml:space="preserve">
          <source>If a property has been set using &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, that value will be returned. Otherwise, if a property is explicitly specified in the stylesheet, that value will be returned. If the value of the property has been defaulted, that is, if no value has been set explicitly either with &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt; or in the stylesheet, the result may vary depending on implementation and input stylesheet.</source>
          <target state="translated">&lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; 사용하여 속성을 설정 한 경우 해당 값이 반환됩니다. 그렇지 않고 속성이 스타일 시트에 명시 적으로 지정되면 해당 값이 반환됩니다. 속성 값이 기본값으로 설정된 경우, 즉 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; 또는 스타일 시트에 명시 적으로 값이 설정되지 않은 경우 결과는 구현 및 입력에 따라 달라질 수 있습니다. 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="fe881171d1c239ccd44b6c4f0b3100103c51b330" translate="yes" xml:space="preserve">
          <source>If a property is indexed, then its entry in the result array belongs to the &lt;a href=&quot;indexedpropertydescriptor&quot;&gt;&lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;&lt;/a&gt; subclass of the &lt;a href=&quot;propertydescriptor&quot;&gt;&lt;code&gt;PropertyDescriptor&lt;/code&gt;&lt;/a&gt; class. A client of the &lt;code&gt;getPropertyDescriptors&lt;/code&gt; method can use the &lt;code&gt;instanceof&lt;/code&gt; operator to check whether a given &lt;code&gt;PropertyDescriptor&lt;/code&gt; is an &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;.</source>
          <target state="translated">특성이 색인화되는 경우 결과 배열의 해당 항목 은 &lt;a href=&quot;propertydescriptor&quot;&gt; &lt;code&gt;PropertyDescriptor&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;indexedpropertydescriptor&quot;&gt; &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; &lt;/a&gt; 서브 클래스에 속합니다 . &lt;code&gt;getPropertyDescriptors&lt;/code&gt; 메소드 의 클라이언트는 &lt;code&gt;instanceof&lt;/code&gt; 연산자를 사용하여 지정된 &lt;code&gt;PropertyDescriptor&lt;/code&gt; 가 &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; 인지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73b5d72f7f083f370b03d87e8286e01120577634" translate="yes" xml:space="preserve">
          <source>If a property value is a directory name, all files under that directory will be passed also.</source>
          <target state="translated">특성 값이 디렉토리 이름 인 경우 해당 디렉토리 아래의 모든 파일도 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b052521b488218cd7b9b35156c5fdb24478e5826" translate="yes" xml:space="preserve">
          <source>If a prototype display value is specified, the preferred size of the combo box is calculated by configuring the renderer with the prototype display value and obtaining its preferred size. Specifying the preferred display value is often useful when the combo box will be displaying large amounts of data. If no prototype display value has been specified, the renderer must be configured for each value from the model and its preferred size obtained, which can be relatively expensive.</source>
          <target state="translated">프로토 타입 디스플레이 값이 지정되면 콤보 상자의 선호 크기는 프로토 타입 디스플레이 값으로 렌더러를 구성하고 선호하는 크기를 가져 와서 계산됩니다. 선호하는 표시 값을 지정하면 콤보 상자에 많은 양의 데이터가 표시 될 때 유용합니다. 프로토 타입 표시 값이 지정되지 않은 경우 렌더러는 모델의 각 값에 대해 구성해야하며 선호하는 크기를 얻어야하므로 상대적으로 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1b2c9101e57a9172a322b33cabb0f6d7243ba95" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;com.sun.net.httpserver.HttpServerProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified unchecked error or exception is thrown.</source>
          <target state="translated">공급자 클래스가 시스템 클래스 로더에 표시되는 jar 파일에 설치되어 있고 해당 jar 파일 에 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;com.sun.net.httpserver.HttpServerProvider&lt;/code&gt; 라는 공급자 구성 파일이 포함되어있는 경우 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 확인되지 않은 오류 또는 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c4d961909cb1d8509dc7e80ad518ce9be7c9742" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">제공자 클래스가 시스템 클래스 로더가 볼 수있는 jar 파일에 설치되었고 해당 jar 파일 에 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 라는 제공자 구성 파일이 포함 된 경우 , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fdfa29d9e3e5dd048f606f387c561e986beb3b1f" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">제공자 클래스가 시스템 클래스 로더가 볼 수있는 jar 파일에 설치되었고 해당 jar 파일 에 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 라는 제공자 구성 파일이 포함 된 경우 , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40aff6af09d58df40b7fd9256b872b6c75872438" translate="yes" xml:space="preserve">
          <source>If a proxy class implements a non-public interface, then it will be defined in the same package as that interface. Otherwise, the package of a proxy class is also unspecified. Note that package sealing will not prevent a proxy class from being successfully defined in a particular package at runtime, and neither will classes already defined by the same class loader and the same package with particular signers.</source>
          <target state="translated">프록시 클래스가 공용 인터페이스를 구현하지 않으면 해당 인터페이스와 동일한 패키지에 정의됩니다. 그렇지 않으면 프록시 클래스의 패키지도 지정되지 않습니다. 패키지 씰링은 프록시 클래스가 런타임에 특정 패키지에서 성공적으로 정의되는 것을 막지 않으며, 동일한 클래스 로더에 의해 이미 정의 된 클래스와 특정 서명자와 동일한 패키지가 이미 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="796aaf5cfdf7fbf122008c7936a12a38e2eb7d28" translate="yes" xml:space="preserve">
          <source>If a proxy interface contains a method with the same name and parameter signature as the &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt;, or &lt;code&gt;toString&lt;/code&gt; methods of &lt;code&gt;java.lang.Object&lt;/code&gt;, when such a method is invoked on a proxy instance, the &lt;code&gt;Method&lt;/code&gt; object passed to the invocation handler will have &lt;code&gt;java.lang.Object&lt;/code&gt; as its declaring class. In other words, the public, non-final methods of &lt;code&gt;java.lang.Object&lt;/code&gt; logically precede all of the proxy interfaces for the determination of which &lt;code&gt;Method&lt;/code&gt; object to pass to the invocation handler.</source>
          <target state="translated">프록시 인터페이스 에 &lt;code&gt;java.lang.Object&lt;/code&gt; 의 &lt;code&gt;hashCode&lt;/code&gt; , &lt;code&gt;equals&lt;/code&gt; 또는 &lt;code&gt;toString&lt;/code&gt; 메소드 와 이름 및 매개 변수 특성이 동일한 메소드가 포함 된 경우, 해당 &lt;code&gt;Method&lt;/code&gt; 가 프록시 인스턴스 에서 호출 될 때 호출 핸들러에 전달 된 Method 오브젝트는 선언 클래스로 &lt;code&gt;java.lang.Object&lt;/code&gt; 가 있습니다 . 다시 말해, &lt;code&gt;java.lang.Object&lt;/code&gt; 의 최종 비 최종 메소드 는 호출 핸들러에 전달할 &lt;code&gt;Method&lt;/code&gt; 오브젝트를 판별하기 위해 모든 프록시 인터페이스보다 논리적으로 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="1d6e567397cafeb01c674366adf43d058fe31b2c" translate="yes" xml:space="preserve">
          <source>If a pushed value is a primitive type, it may be converted to a reference by boxing conversion. If the bootstrap method is a variable arity method (its modifier bit &lt;code&gt;0x0080&lt;/code&gt; is set), then some or all of the arguments specified here may be collected into a trailing array parameter. (This is not a special rule, but rather a useful consequence of the interaction between &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constants, the modifier bit for variable arity methods, and the &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; transformation.)</source>
          <target state="translated">푸시 된 값이 기본 유형이면 복싱 변환을 통해 참조로 변환 될 수 있습니다. 부트 스트랩 메서드가 가변 arity 메서드 (수정 자 비트 &lt;code&gt;0x0080&lt;/code&gt; 이 설정 됨)이면 여기에 지정된 일부 또는 모든 인수가 후행 배열 매개 변수로 수집 될 수 있습니다. (이것은 특별한 규칙이 아니라 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수, 가변 arity 메서드에 대한 수정 자 비트 및 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt; 변환 간의 상호 작용의 유용한 결과입니다 .)</target>
        </trans-unit>
        <trans-unit id="da20e235784a287eb944654e195ab8c9e647b20d" translate="yes" xml:space="preserve">
          <source>If a query is given then a question-mark character (&lt;code&gt;'?'&lt;/code&gt;) is appended, followed by the query. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.</source>
          <target state="translated">쿼리가 제공되면 물음표 문자 ( &lt;code&gt;'?'&lt;/code&gt; )가 추가되고 그 뒤에 쿼리가옵니다. &lt;a href=&quot;#legal-chars&quot;&gt;유효한 URI 문자&lt;/a&gt; 가 아닌 문자 는 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="01ac00789cb87665540b49de8050c0c6e5eace44" translate="yes" xml:space="preserve">
          <source>If a redefined class has instances then all those instances will have the fields defined by the redefined class at the completion of the call. Preexisting fields will retain their previous values. Any new fields will have their default values; no instance initializers or constructors are run.</source>
          <target state="translated">재정의 된 클래스에 인스턴스가있는 경우 이러한 모든 인스턴스에는 호출 완료시 재정의 된 클래스에 의해 정의 된 필드가 있습니다. 기존 필드는 이전 값을 유지합니다. 새 필드에는 기본값이 있습니다. 인스턴스 이니셜 라이저 또는 생성자가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd66988b876e62bc3940fc9fa272fb4aa056a6e8" translate="yes" xml:space="preserve">
          <source>If a redefined method has active stack frames, those active frames continue to run the bytecodes of the original method. The redefined method will be used on new invokes.</source>
          <target state="translated">재정의 된 메소드에 활성 스택 프레임이있는 경우 해당 활성 프레임은 원래 메소드의 바이트 코드를 계속 실행합니다. 재정의 된 메소드는 새로운 호출에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a353f255cddb3e5f45349ee73fbfca26933c3382" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">남아있는 요소가 존재하는 경우 해당 요소에 대해 지정된 작업을 수행하고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c3cb610dc9a4ccd073a7cbb93e3b0cbe1831a23f" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">남아있는 요소가 존재하는 경우 해당 요소에 대해 지정된 작업을 수행하고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 Spliterator가 &lt;a href=&quot;#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에서 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="24ef3bceba0cb2aab5212a59ddb1c10b5a5728ca" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">나머지 요소가 존재하면 주어진 조치를 수행하여 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . else는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 스플리터가&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에 의해 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e159606ce958fbbed771df76f4f0eabd266798cd" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">나머지 요소가 존재하면 주어진 조치를 수행하여 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . else는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 스플리터가&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에 의해 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1839ce02fdf0a084101d2dedb7a7ec30b1eddf93" translate="yes" xml:space="preserve">
          <source>If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</source>
          <target state="translated">요청을 대기열에 넣을 수 없으면 maximumPoolSize를 초과하지 않는 한 새 스레드가 만들어지며이 경우 작업이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8dcd6f2eb2f000d41479fe75ebb34b375f18a3c4" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">요청 된 액세스가 허용되면 &lt;code&gt;checkPermission&lt;/code&gt; 이 자동으로 리턴됩니다. 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="887186d0f2e36f1ee7e723c9cc603e07ae277a39" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, an AccessControlException is thrown. AccessControlException can also be thrown if the requested permission is of an incorrect type or contains an invalid value. Such information is given whenever possible. Suppose the current thread traversed m callers, in the order of caller 1 to caller 2 to caller m. Then caller m invoked the &lt;code&gt;checkPermission&lt;/code&gt; method. The &lt;code&gt;checkPermission&lt;/code&gt; method determines whether access is granted or denied based on the following algorithm:</source>
          <target state="translated">요청 된 액세스가 허용되면 &lt;code&gt;checkPermission&lt;/code&gt; 이 자동으로 리턴됩니다. 거부되면 AccessControlException이 발생합니다. 요청 된 권한이 올바르지 않은 유형이거나 유효하지 않은 값을 포함하는 경우 AccessControlException이 발생할 수도 있습니다. 그러한 정보는 가능할 때마다 제공됩니다. 현재 스레드가 호출자 1-호출자 2-호출자 m의 순서로 m 호출자를 순회한다고 가정하십시오. 그런 다음 호출자 m은 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출했습니다 . &lt;code&gt;checkPermission&lt;/code&gt; 방법은 액세스가 부여되거나 다음과 같은 알고리즘을 기반으로 거부 여부를 결정합니다 :</target>
        </trans-unit>
        <trans-unit id="d5d7514de1aef2342f9130eb5c0a7ab75fbed7e9" translate="yes" xml:space="preserve">
          <source>If a resource named &lt;code&gt;META-INF/services/java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; is visible to the system class loader, then the contents of that resource are interpreted as a provider-configuration file, and the first class name specified in that file is used as the provider class name. If a class with that name can be loaded by the system class loader and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the resource is found but a provider cannot be instantiated as described, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">&lt;code&gt;META-INF/services/java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; 라는 리소스 가 시스템 클래스 로더에 표시되면 해당 리소스의 내용이 공급자 구성 파일로 해석되고 해당 파일에 지정된 첫 번째 클래스 이름은 다음과 같습니다. 공급자 클래스 이름으로 사용됩니다. 해당 이름의 클래스가 시스템 클래스 로더에 의해로드 될 수 있고 해당 클래스가 &lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; 에&lt;/a&gt; 할당 가능하고 인수가없는 공용 생성자가있는 경우 해당 생성자가 호출되어 공급자 인스턴스를 생성합니다. 리소스를 찾았지만 설명 된대로 공급자를 인스턴스화 할 수없는 경우 &lt;code&gt;RMIClassLoader&lt;/code&gt; 사용을 시도하는 코드에 지정되지 않은 &lt;code&gt;Error&lt;/code&gt; 가 발생 하여 공급자 인스턴스를 가져 오지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef31bdb236c1be020d8ae03fbd2d0a2a44475408" translate="yes" xml:space="preserve">
          <source>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</source>
          <target state="translated">결과가 컴 바이 너 또는 피니셔 함수로 전달되고 해당 함수에서 동일한 오브젝트가 리턴되지 않으면 다시 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f6485f2810241e1f59964a0306f13fb66de588c" translate="yes" xml:space="preserve">
          <source>If a retransformed method has active stack frames, those active frames continue to run the bytecodes of the original method. The retransformed method will be used on new invokes.</source>
          <target state="translated">재 변환 된 메소드에 활성 스택 프레임이있는 경우 해당 활성 프레임은 원래 메소드의 바이트 코드를 계속 실행합니다. 재 변환 된 메소드는 새로운 호출에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14bfd111544b6485485ff232a946c27189f15782" translate="yes" xml:space="preserve">
          <source>If a scheme is given then it is appended to the result, followed by a colon character (&lt;code&gt;':'&lt;/code&gt;).</source>
          <target state="translated">체계가 제공되면 결과에 추가되고 그 뒤에 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; )가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e5292412b3ee897a572e5c7195ad6e65ff3c8f5e" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter or, in the case of the &lt;code&gt;port&lt;/code&gt; parameter, by passing &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">구성표가 제공되면 경로도 지정되거나 비어 있거나 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작해야합니다 . 그렇지 않으면 새 URI의 구성 요소는 해당 매개 변수에 대해 &lt;code&gt;null&lt;/code&gt; 을 전달 하거나 &lt;code&gt;port&lt;/code&gt; 매개 변수 의 경우 &lt;code&gt;-1&lt;/code&gt; 을 전달 하여 정의되지 않은 채로 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7eb7b84865919239961f0fcc50c50d09850970cc" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter.</source>
          <target state="translated">구성표가 제공되면 경로도 지정되거나 비어 있거나 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작해야합니다 . 그렇지 않으면 새 URI의 구성 요소 는 해당 매개 변수에 대해 &lt;code&gt;null&lt;/code&gt; 을 전달하여 정의되지 않은 채로있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="952cc358b56318941d6e6ab799e6dc4bef4fa5ce" translate="yes" xml:space="preserve">
          <source>If a scheme-specific part is given then it is appended. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.</source>
          <target state="translated">구성표 별 부품이 제공되면 추가됩니다. &lt;a href=&quot;#legal-chars&quot;&gt;유효한 URI 문자&lt;/a&gt; 가 아닌 문자 는 &lt;a href=&quot;#quote&quot;&gt;인용&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="13bf2d89737ab4f9e4f3365daa8c4a8a75373b41" translate="yes" xml:space="preserve">
          <source>If a search filter with invalid variable substitutions is provided to this method, the result is undefined. When changes are made to this DirContext, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">유효하지 않은 변수 대체가있는 검색 필터가이 메소드에 제공되면 결과는 정의되지 않습니다. 이 DirContext가 변경되면,이 메소드에 대한 이전 호출에 의해 리턴 된 열거에 대한 영향은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21aa33f224ffda676da8658661118410003b3a1d" translate="yes" xml:space="preserve">
          <source>If a second-based field is present, but &lt;code&gt;LocalTime&lt;/code&gt; was not parsed, then the resolver ensures that milli, micro and nano second values are available to meet the contract of &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. These will be set to zero if missing.</source>
          <target state="translated">초 기반 필드가 있지만 &lt;code&gt;LocalTime&lt;/code&gt; 이 구문 분석되지 않은 경우 해석기는 밀리, 마이크로 및 나노초 값이 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 의 계약을 충족하는 데 사용할 수 있는지 확인 합니다. 누락 된 경우 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e18b76d1fe5541051eb8484610c674d8c7326195" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 검사가 실패하면 메서드는 &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e97fd2ab90897223be3d44a61e5dac3ab116baef" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 검사에 실패하면, 메소드는 &lt;a href=&quot;../../java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="221b98a86674d566a65e15145ec84aa3ec7800d3" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드는 배열 &lt;code&gt;cmdarray&lt;/code&gt; 의 첫 번째 구성 요소를 인수로 사용하여 호출됩니다. 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9dea5876966fa5396ec8f16c92b8e2f701b1ace9" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재 하면 배열 &lt;code&gt;cmdarray&lt;/code&gt; 의 첫 번째 구성 요소를 인수로 사용하여 &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 이 발생 .</target>
        </trans-unit>
        <trans-unit id="f62df6f0d1a2b5825cab2050a4ec3aeebeb23980" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;getenv.&quot;+name)&lt;/code&gt;&lt;/a&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;getenv.&quot;+name)&lt;/code&gt; &lt;/a&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 . 예외가 발생하지 않으면 변수 &lt;code&gt;name&lt;/code&gt; 의 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f1619a19a25be011be70c741cc0c43a2226d965a" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;getenv.*&quot;)&lt;/code&gt;&lt;/a&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;getenv.*&quot;)&lt;/code&gt; &lt;/a&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e6026eb4f64490fabd44f7ccd2cafba99ebb3a0" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 있으면 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53168f421aa4d312fe84c343c76a94712c016bae" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2be9fb106610b30c8cb7f763862c74ced2b9d9be" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 . 예외가 발생하지 않으면 변수 &lt;code&gt;name&lt;/code&gt; 의 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="799c889390e9c989ec60d735a9738bf280d5b1a4" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2278e2e0ebd6f6139022aa0c469fba80c78c2df6" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;deregisterDriver&quot;)&lt;/code&gt; permission to check that the caller is allowed to deregister a JDBC Driver.</source>
          <target state="translated">보안 관리자가 존재하면 먼저 &lt;code&gt;SQLPermission(&quot;deregisterDriver&quot;)&lt;/code&gt; 권한 과 함께 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출 하여 호출자가 JDBC 드라이버를 등록 취소 할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="44b4a416183d3454eaa000dc618d86aeea1d6cfb" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; permission to check that the caller is allowed to call &lt;code&gt;setLogStream&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 존재하면 먼저 &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; 권한 과 함께 &lt;code&gt;checkPermission&lt;/code&gt; 메소드 를 호출하여 호출자가 &lt;code&gt;setLogStream&lt;/code&gt; 을 호출 할 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e94ff9d44d0443fcf36a01243a61054d009a97a3" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; permission to check that the caller is allowed to call &lt;code&gt;setLogWriter&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 존재하면 먼저 &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; 권한 과 함께 &lt;code&gt;checkPermission&lt;/code&gt; 메소드 를 호출하여 호출자가 &lt;code&gt;setLogWriter&lt;/code&gt; 를 호출 할 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b8aaf18bef197785207f9f2d71a7845893529d83" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then for each new association setup this method verifies that the associations source address and port number are permitted by the security manager's &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">보안 관리자가 설치된 경우 각 새 연결 설정에 대해이 방법은 연결 소스 주소 및 포트 번호가 보안 관리자의 &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드에 의해 허용되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b24ae23ffa5fda73be9414955876b95df729521b" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then for each new association setup this method verifies that the given remote peers address and port number are permitted by the security manager's &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">보안 관리자가 설치된 경우 각 새 연결 설정에 대해이 방법은 지정된 원격 피어 주소 및 포트 번호가 보안 관리자의 &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 방법에 의해 허용되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ac15baf176232c8309b6dd5f252ba3a1e35fdc0a" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then for each new association this method verifies that the address and port number of the assocaitions's remote peer are permitted by the security manager's &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">보안 관리자가 설치된 경우 각 새 연결에 대해이 방법은 연결의 원격 피어 주소 및 포트 번호가 보안 관리자의 &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드에 의해 허용되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2028007eeb90e55bc59c501b744cac8fe55582db" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress()&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast(java.net.InetAddress)&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">보안 관리자가 설치된 경우 원격 주소에 대한 액세스를 확인하기 위해 호출됩니다. 특히, 주어진 &lt;code&gt;address&lt;/code&gt; 가 &lt;a href=&quot;inetaddress#isMulticastAddress()&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt; 이면 보안 관리자의 &lt;a href=&quot;../lang/securitymanager#checkMulticast(java.net.InetAddress)&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt; 메소드가 주어진 &lt;code&gt;address&lt;/code&gt; 호출됩니다 . 그렇지 않으면 보안 관리자의 &lt;a href=&quot;../lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드가 주어진 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 와 함께 호출 되어 데이터 그램의 송수신이 각각 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a1659595caad59762dfff687e8404d52f631d93f" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">보안 관리자가 설치된 경우 원격 주소에 대한 액세스를 확인하기 위해 호출됩니다. 주어진 경우 특히, &lt;code&gt;address&lt;/code&gt; A는 &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt; , 보안 매니저의 &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt; 방법은 주어진를 호출 &lt;code&gt;address&lt;/code&gt; . 그렇지 않으면, 주어진 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 로 보안 관리자의 &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되어 데이터 그램이 각각 송수신 될 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5ec3f03393550037c5eee923c4fe6688b7340633" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가 설치된 경우 연결 원격 엔드 포인트의 주소 및 포트 번호가 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드에 의해 허용되는지 확인합니다 . 권한 검사는이 메서드의 호출 컨텍스트에 의해 제한되는 권한으로 수행됩니다. 권한 검사가 실패하면 연결이 닫히고 작업이 &lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 으로&lt;/a&gt; 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="e62ef67bcdaa9aa21e31d7d487c07bd914492ed8" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가 설치된 경우 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드 가 연결 원격 엔드 포인트의 주소 및 포트 번호를 허용하는지 확인합니다 . 권한 확인은이 메소드의 호출 컨텍스트에 의해 제한된 권한으로 수행됩니다. 권한 점검에 실패하면 연결이 닫히고 조작이 &lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 으로&lt;/a&gt; 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="6578d6ef881b16cbb3b208f98bde343d77e471ed" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then this method verifies that its &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; method permits connecting to the address and port number of the given remote peer.</source>
          <target state="translated">보안 관리자가 설치된 경우이 메서드는 &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 메서드가 지정된 원격 피어의 주소 및 포트 번호에 대한 연결을 허용 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3f4c4a17220ef5e90aea04a442f8bc074ebea3c6" translate="yes" xml:space="preserve">
          <source>If a security manager is already set in the group VM, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method. This could result in a &lt;code&gt;SecurityException&lt;/code&gt;. If your application needs to set a different security manager, you must ensure that the policy file specified by the group's &lt;code&gt;ActivationGroupDesc&lt;/code&gt; grants the group the necessary permissions to set a new security manager. (Note: This will be necessary if your group downloads and sets a security manager).</source>
          <target state="translated">보안 관리자가 이미 그룹 VM에 설정되어있는 경우이 메소드는 먼저 보안 관리자의 &lt;code&gt;checkSetFactory&lt;/code&gt; 메소드를 호출합니다 . 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 . 애플리케이션이 다른 보안 관리자를 설정해야하는 경우 그룹의 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 에 지정된 정책 파일이 그룹 에 새 보안 관리자를 설정하는 데 필요한 권한을 부여 하는지 확인해야합니다 . (참고 : 그룹이 보안 관리자를 다운로드하고 설정하는 경우 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="774bb30d85acccb9e7832ec0c0d531eef6b9e9b6" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (where &lt;code&gt;name&lt;/code&gt; is the provider name) to see if it's ok to clear this provider.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 임) 문자열로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출 되어이 제공자를 지울 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f35e03213aea8a9f7162a4e6061b476c733a84f5" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 문자열 ( 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 임 )로 호출 되어이 제공자의 특성 값을 설정해도 괜찮은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97b050d112e298b259d22c6b122aa0f103951b1a" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to remove this provider's properties.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; 문자열과 함께 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출됩니다 . 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 이며이 제공자의 특성을 제거 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ece65adbb64e89095abfe9c2349b473bbf31084f" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the strings &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; and &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values and remove this provider's properties.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, 문자열 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 및 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; 으로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출됩니다 . 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름입니다.이 제공자의 특성 값을 설정하고이를 제거해도 괜찮은지 확인하십시오. 공급자의 속성.</target>
        </trans-unit>
        <trans-unit id="cf20f936473755f39be868cd9845f771cb103a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed and the specified &lt;code&gt;AccessControlContext&lt;/code&gt; was not created by system code and the caller's &lt;code&gt;ProtectionDomain&lt;/code&gt; has not been granted the &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt;&lt;code&gt;SecurityPermission&lt;/code&gt;&lt;/a&gt;, then the action is performed with no permissions.</source>
          <target state="translated">보안 관리자가 설치되어 있고 지정된 &lt;code&gt;AccessControlContext&lt;/code&gt; 가 시스템 코드로 작성되지 않고 호출자의 &lt;code&gt;ProtectionDomain&lt;/code&gt; 에 &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt; &lt;code&gt;SecurityPermission&lt;/code&gt; &lt;/a&gt; 이 부여되지 않은 경우, 권한없이 조치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dd8d2c5d44a3aa942e5df643c8cc56f8591079d9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 공급자 구현은 기존 파일 시스템에 대한 참조를 반환하기 전에 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3b5b0dd2a87988fc996fb7a1ac5c2588c90d706" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 공급자 구현은 기존 파일 시스템에 대한 참조를 반환하기 전에 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;../filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71505a5d56a109fcf20595110953779d866b2e80" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 기존 파일 시스템에 대한 참조를 리턴하기 전에 권한을 점검해야합니다. &lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94817a0d003779bd7b3676c9e779ce36983364b9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 기존 파일 시스템에 대한 참조를 리턴하기 전에 권한을 점검해야합니다. &lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e04465cdbf974bbd5f8ba0a91561e8dc8debf9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 공급자 구현은 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;../filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d8b4d6a644688d37bf4f42e678ef49d5a579de5" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="143f1755f82fd54bafd1bbd2d643a9b8c831879a" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:</source>
          <target state="translated">보안 관리자가 설치되어 있고 연결을 시도하는 메서드가 호출되면 호출자는 다음 중 하나를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0d87efa51aa6969d6f0da372f01e957e877983c" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-</source>
          <target state="translated">보안 관리자가 설치되어 있고 연결을 시도하는 메소드가 호출 된 경우 호출자는 다음 중 하나를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d45c9e8f126e9404c3d2b7c327aa338dc699327" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, in order to create a &lt;code&gt;GSSName&lt;/code&gt; that contains a Kerberos name element without providing its realm, a &lt;a href=&quot;../../../javax/security/auth/kerberos/servicepermission&quot;&gt;&lt;code&gt;ServicePermission&lt;/code&gt;&lt;/a&gt; must be granted and the service principal of the permission must minimally be inside the Kerberos name element's realm. For example, if the result of &lt;a href=&quot;gssmanager#createName(java.lang.String,org.ietf.jgss.Oid)&quot;&gt;&lt;code&gt;createName(&quot;user&quot;, NT_USER_NAME)&lt;/code&gt;&lt;/a&gt; contains a Kerberos name element &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt;, then a &lt;code&gt;ServicePermission&lt;/code&gt; with service principal &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (and any action) must be granted. Otherwise, the creation will throw a &lt;a href=&quot;gssexception&quot;&gt;&lt;code&gt;GSSException&lt;/code&gt;&lt;/a&gt; containing the &lt;code&gt;GSSException.FAILURE&lt;/code&gt; error code.</source>
          <target state="translated">보안 관리자가 설치된 경우 영역을 제공하지 않고 Kerberos 이름 요소를 포함 하는 &lt;code&gt;GSSName&lt;/code&gt; 을 만들려면 &lt;a href=&quot;../../../javax/security/auth/kerberos/servicepermission&quot;&gt; &lt;code&gt;ServicePermission&lt;/code&gt; &lt;/a&gt; 을 부여해야하며 권한의 서비스 주체는 최소한 Kerberos 이름 요소의 영역 내에 있어야합니다. 예를 들어 &lt;a href=&quot;gssmanager#createName(java.lang.String,org.ietf.jgss.Oid)&quot;&gt; &lt;code&gt;createName(&quot;user&quot;, NT_USER_NAME)&lt;/code&gt; &lt;/a&gt; 의 결과에 Kerberos 이름 요소 &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt; 이 포함 된 경우 서비스 주체 &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (및 모든 작업)이 있는 &lt;code&gt;ServicePermission&lt;/code&gt; 은 부여. 그렇지 않으면, 창조가 발생합니다 &lt;a href=&quot;gssexception&quot;&gt; &lt;code&gt;GSSException&lt;/code&gt; 가&lt;/a&gt; 포함하는 &lt;code&gt;GSSException.FAILURE&lt;/code&gt; 의 오류 코드를.</target>
        </trans-unit>
        <trans-unit id="2cf065c4d0904a0cb44740e8e70a65fae00e790f" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPrincipals&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 반환 된 집합을 수정하기 위해 &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPrincipals&quot;)&lt;/code&gt; &lt;/a&gt; 권한이 있어야합니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d705115f8db059c39a12d168cf6ae0c2ae12a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPrivateCredentials&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 반환 된 집합을 수정하기 위해 &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPrivateCredentials&quot;)&lt;/code&gt; &lt;/a&gt; 권한이 있어야합니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="277c3aef4348bc841723740d60214a68d5615799" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPublicCredentials&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPublicCredentials&quot;)&lt;/code&gt; &lt;/a&gt;반환 된 집합을 수정하기 위해 AuthPermission ( &quot;modifyPublicCredentials&quot;) 권한이 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf6549af10b8e67c5c26a129534c96167f417bb6" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;privatecredentialpermission&quot;&gt;&lt;code&gt;PrivateCredentialPermission&lt;/code&gt;&lt;/a&gt; to access all of the requested Credentials, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 &lt;a href=&quot;privatecredentialpermission&quot;&gt; &lt;code&gt;PrivateCredentialPermission&lt;/code&gt; &lt;/a&gt;요청 된 모든 자격 증명에 액세스 할 PrivateCredentialPermission 이 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e951d48b2804e2b72e838d29cf84001eb9605eaa" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectInputStream.readFields or ObjectInputStream.readUnshared methods.</source>
          <target state="translated">보안 관리자가 설치된 경우이 생성자는 ObjectInputStream.readFields 또는 ObjectInputStream.readUnshared 메소드를 대체하는 서브 클래스의 생성자가 직접 또는 간접적으로 호출 할 때 &quot;enableSubclassImplementation&quot;SerializablePermission을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97bae6ffb96e1d4b174839ef22d4e1aad74be094" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared methods.</source>
          <target state="translated">보안 관리자가 설치된 경우이 생성자는 ObjectOutputStream.putFields 또는 ObjectOutputStream.writeUnshared 메소드를 대체하는 서브 클래스의 생성자가 직접 또는 간접적으로 호출 할 때 &quot;enableSubclassImplementation&quot;SerializablePermission을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d92bb3509ac791abbf0139a9c7f57cc935e83b78" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this method is caller sensitive. During any invocation of the target method handle via the returned wrapper, the original creator of the wrapper (the caller) will be visible to context checks requested by the security manager.</source>
          <target state="translated">보안 관리자가 설치된 경우이 방법은 호출자에 민감합니다. 리턴 된 랩퍼를 통해 대상 메소드 핸들을 호출하는 동안 랩퍼의 원래 작성자 (호출자)는 보안 관리자가 요청한 컨텍스트 확인에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="747d29f4f67e3454f8c693e4e2a5bfb35d6699fd" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the current lookup object does not have &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;full privilege access&lt;/a&gt;, then &lt;a href=&quot;#defineClass(byte%5B%5D)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;smgr.checkPermission&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt;.</source>
          <target state="translated">보안 매니저가 존재하고 현재 조회 오브젝트가없는 경우 &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;모든 권한 액세스&lt;/a&gt; , 다음 &lt;a href=&quot;#defineClass(byte%5B%5D)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; 는이&lt;/a&gt; 호출 &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;smgr.checkPermission&lt;/code&gt; 을&lt;/a&gt; 함께 &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65b3db194eedd1b31a2888097e8d1e43da0bb0ea" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the given &lt;code&gt;option&lt;/code&gt; is &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt;&lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;, it calls its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method for &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 있고 주어진 &lt;code&gt;option&lt;/code&gt; 이 &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt; &lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt; &lt;/a&gt; 인 경우&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt; 에 대한 checkPermission 메서드를.</target>
        </trans-unit>
        <trans-unit id="1670cbe57d528fea2424601e7c9d68d106c819ac" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the given &lt;code&gt;options&lt;/code&gt; contains &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt;&lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;, it calls its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method for &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 있고 지정된 &lt;code&gt;options&lt;/code&gt; 에 &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt; &lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt; &lt;/a&gt; 가 포함 된 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt; 에 대한 checkPermission 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f235ec91b53b01416e59e95836269f2b24928eee" translate="yes" xml:space="preserve">
          <source>If a security manager is present then security checks are performed by the HTTP Client's sending methods. An appropriate &lt;a href=&quot;../../../../java.base/java/net/urlpermission&quot;&gt;&lt;code&gt;URLPermission&lt;/code&gt;&lt;/a&gt; is required to access the destination server, and proxy server if one has been configured. The form of the &lt;code&gt;URLPermission&lt;/code&gt; required to access a proxy has a &lt;code&gt;method&lt;/code&gt; parameter of &lt;code&gt;&quot;CONNECT&quot;&lt;/code&gt; (for all kinds of proxying) and a &lt;code&gt;URL&lt;/code&gt; string of the form &lt;code&gt;&quot;socket://host:port&quot;&lt;/code&gt; where host and port specify the proxy's address.</source>
          <target state="translated">보안 관리자가있는 경우 HTTP 클라이언트의 전송 방법에 의해 보안 검사가 수행됩니다. 대상 서버 및 프록시 서버 (구성된 경우)에 액세스하려면 적절한 &lt;a href=&quot;../../../../java.base/java/net/urlpermission&quot;&gt; &lt;code&gt;URLPermission&lt;/code&gt; &lt;/a&gt; 이 필요합니다. 프록시에 액세스하는 데 필요한 &lt;code&gt;URLPermission&lt;/code&gt; 의 형식에는 &lt;code&gt;&quot;CONNECT&quot;&lt;/code&gt; (모든 종류의 프록시 용) &lt;code&gt;method&lt;/code&gt; 매개 변수 와 &lt;code&gt;&quot;socket://host:port&quot;&lt;/code&gt; 형식 의 &lt;code&gt;URL&lt;/code&gt; 문자열이 있습니다. 여기서 host 및 port는 프록시 주소를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d8a665c3d954d0fc47740977c830812c0a85b298" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the class loader for the class.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 널 (null)이 아니고 호출자의 클래스 로더가 클래스 로더가 요청 된 클래스에 대한 클래스 로더의 조상과 같거나 같지 않은 경우,이 메소드는 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출합니다. 로모그래퍼 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 의 허가는 클래스의 클래스 로더에 액세스 할 수있는 것을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="fae23e2153f023848b4e6ff03b38daa20b992dd7" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not an ancestor of this class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the parent class loader is permitted. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고이 클래스 로더 의 조상이 아닌 경우이 메소드는 상위 클래스에 대한 액세스를 확인하기 위해 &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 권한으로 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. 로더가 허용됩니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d340f476b6c3ae11657fddd0392b049fcfa29b4e" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not the same as or an ancestor of the context class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; permission to verify that retrieval of the context class loader is permitted.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고 컨텍스트 클래스 로더의 조상과 같거나 같지 않은 경우이 메소드는 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. 컨텍스트 클래스 로더 검색이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7bab9ae3bc48ceb4d26ca9f16abf87e363a12c" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and the invoker's class loader is not the same as or an ancestor of the system class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the system class loader. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고 호출자의 클래스 로더가 시스템 클래스 로더와 동일하거나 상위 클래스가 아닌 경우,이 메소드는 &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 사용하여 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. ) 시스템 클래스 로더에 대한 액세스를 확인하는 권한 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c67e806fb2de6670301476b333eef74af4db7033" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;
 (&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 경우 컨텍스트 ClassLoader 설정이 허용되는지 확인하기 위해 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt; (&quot;setContextClassLoader&quot;)&lt;/code&gt; 권한으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="459bc04b32cd4cdbb41e230932994ba0a7971ad8" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">보안 관리자가 존재하면 해당 클래스의 컨텍스트 설정이 허용되는지 확인하기 위해 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; 권한으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="78cdc9b5f5eda6e8145be430c39c840d355e0828" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member and class lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. (If a class or other type is being accessed, the &lt;code&gt;refc&lt;/code&gt; and &lt;code&gt;defc&lt;/code&gt; values are the class itself.) The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;full privilege access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">보안 관리자가있는 경우 구성원 및 클래스 조회는 추가 검사의 대상이 될 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 보안 관리자에게 한 번에서 세 번의 호출이 이루어집니다. 이러한 호출은 &lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 액세스를 거부 할 수 있습니다 . 정의 &lt;code&gt;smgr&lt;/code&gt; 보안 관리자와 같은 &lt;code&gt;lookc&lt;/code&gt; 룩업 현재 룩업 객체의 클래스로서 &lt;code&gt;refc&lt;/code&gt; 부재가 모색되고있는 함유 클래스로하고 &lt;code&gt;defc&lt;/code&gt; 부재 실제로 정의 된 클래스로한다. (클래스 또는 다른 유형이 액세스되는 경우 &lt;code&gt;refc&lt;/code&gt; 및 &lt;code&gt;defc&lt;/code&gt; 값 클래스 자체이다.) 값 &lt;code&gt;lookc&lt;/code&gt; 는 로 정의 &lt;em&gt;없는&lt;/em&gt;현재 조회 개체에 &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;전체 권한 액세스 권한&lt;/a&gt; 이없는 경우 . 호출은 다음 규칙에 따라 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="e624bb62f16bc940f5cf53be80f8d86fd6570fa0" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member and class lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. (If a class or other type is being accessed, the &lt;code&gt;refc&lt;/code&gt; and &lt;code&gt;defc&lt;/code&gt; values are the class itself.) The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">보안 관리자가있는 경우 구성원 및 클래스 조회는 추가 검사를받습니다. 보안 관리자에게 1 ~ 3 회의 호출이 이루어집니다. 이러한 호출은 &lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 액세스를 거부 할 수 있습니다 . 정의 &lt;code&gt;smgr&lt;/code&gt; 보안 관리자와 같은 &lt;code&gt;lookc&lt;/code&gt; 룩업 현재 룩업 객체의 클래스로서 &lt;code&gt;refc&lt;/code&gt; 부재가 모색되고있는 함유 클래스로하고 &lt;code&gt;defc&lt;/code&gt; 부재 실제로 정의 된 클래스로한다. (클래스 또는 다른 유형이 액세스되는 경우 &lt;code&gt;refc&lt;/code&gt; 및 &lt;code&gt;defc&lt;/code&gt; 값 클래스 자체이다.) 값 &lt;code&gt;lookc&lt;/code&gt; 는 로 정의&lt;em&gt; 없는&lt;/em&gt;현재 조회 개체에 이없는 경우&lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;개인 액세스&lt;/a&gt; . 호출은 다음 규칙에 따라 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="944477a6804441726a3b8f252f78eae83726e3a4" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">보안 관리자가있는 경우 멤버 조회에는 추가 검사가 적용됩니다. 1 ~ 3 번의 보안 관리자 호출 이러한 호출은 &lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 액세스를 거부 할 수 있습니다 . &lt;code&gt;smgr&lt;/code&gt; 을 보안 관리자로 정의 하고, &lt;code&gt;lookc&lt;/code&gt; 를 현재 조회 오브젝트의 검색 클래스로, &lt;code&gt;refc&lt;/code&gt; 를 멤버를 찾는 포함 클래스로, &lt;code&gt;defc&lt;/code&gt; 를 멤버를 실제로 정의한 클래스로 정의하십시오. 현재 조회 오브젝트에 &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;개인 액세스 권한&lt;/a&gt; 이없는 경우 &lt;code&gt;lookc&lt;/code&gt; 값 은 &lt;em&gt;존재하지 않는 것으로&lt;/em&gt; 정의됩니다 . 다음 규칙에 따라 전화를 겁니다.</target>
        </trans-unit>
        <trans-unit id="d370048efbe2c926a15f430ef8f627c5e5941de0" translate="yes" xml:space="preserve">
          <source>If a sequence of nodes is needed, the node contained in the &lt;code&gt;DOMStructure&lt;/code&gt; is the first node of the sequence and successive nodes can be accessed by invoking &lt;a href=&quot;../../../../../java.xml/org/w3c/dom/node#getNextSibling()&quot;&gt;&lt;code&gt;Node.getNextSibling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">노드 시퀀스가 ​​필요한 경우 &lt;code&gt;DOMStructure&lt;/code&gt; 에 포함 된 노드가 시퀀스의 첫 번째 노드이며 Node.getNextSibling &lt;a href=&quot;../../../../../java.xml/org/w3c/dom/node#getNextSibling()&quot;&gt; &lt;code&gt;Node.getNextSibling()&lt;/code&gt; &lt;/a&gt; 을 호출하여 연속 노드에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d5767eefb23c399e8079e08277dddc58e247bf9" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java Object Serialization Specification. This specification defines the serialVersionUID of an enum type to be 0L. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes other than enum types explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</source>
          <target state="translated">직렬화 가능한 클래스가 명시 적으로 serialVersionUID를 선언하지 않는 경우 직렬화 런타임은 Java 객체 직렬화 사양에 설명 된대로 클래스의 다양한 측면을 기반으로 해당 클래스의 기본 serialVersionUID 값을 계산합니다. 이 사양은 enum 유형의 serialVersionUID를 0L로 정의합니다. 그러나 기본 serialVersionUID 계산은 컴파일러 구현에 따라 달라질 수있는 클래스 세부 정보에 매우 민감하여 예기치 않은 &lt;code&gt;InvalidClassException&lt;/code&gt; 이 발생할 수 있으므로 열거 형 유형 이외의 모든 직렬화 가능한 클래스는 명시 적으로 serialVersionUID 값을 선언 &lt;em&gt;하는 것이 좋습니다.&lt;/em&gt;s 역 직렬화 중. 따라서 서로 다른 Java 컴파일러 구현에서 일관된 serialVersionUID 값을 보장하려면 직렬화 가능한 클래스가 명시 적 serialVersionUID 값을 선언해야합니다. 또한 명시 적 serialVersionUID 선언 은 가능한 경우 &lt;code&gt;private&lt;/code&gt; 한정자를 사용하는 것이 좋습니다. 이러한 선언은 즉시 선언하는 클래스에만 적용되므로 serialVersionUID 필드는 상속 된 멤버로 유용하지 않습니다. 배열 클래스는 명시 적 serialVersionUID를 선언 할 수 없으므로 항상 기본 계산 된 값을 갖지만 배열 클래스의 경우 serialVersionUID 값 일치에 대한 요구 사항이 면제됩니다.</target>
        </trans-unit>
        <trans-unit id="401c7fd6161f35837fa11c7a250b7f821910874a" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</source>
          <target state="translated">직렬화 가능 클래스가 serialVersionUID를 명시 적으로 선언하지 않으면 직렬화 런타임은 Java (TM) 객체 직렬화 스펙에 설명 된대로 클래스의 다양한 측면을 기반으로 해당 클래스의 기본 serialVersionUID 값을 계산합니다. 그러나 기본 serialVersionUID 계산은 컴파일러 구현에 따라 달라질 수있는 클래스 세부 사항에 매우 민감하므로 예기치 않은 &lt;code&gt;InvalidClassException&lt;/code&gt; 이 발생할 수 있으므로 모든 serializable 클래스는 serialVersionUID 값을 명시 적으로 선언 &lt;em&gt;하는 것이 좋습니다.&lt;/em&gt;직렬화 해제 중입니다. 따라서 다른 Java 컴파일러 구현에서 일관된 serialVersionUID 값을 보장하려면 직렬화 가능 클래스가 명시 적 serialVersionUID 값을 선언해야합니다. 또한 명시 적 serialVersionUID 선언 은 가능한 경우 &lt;code&gt;private&lt;/code&gt; 수정자를 사용하는 것이 좋습니다. 이러한 선언은 즉시 선언하는 클래스에만 적용되므로 serialVersionUID 필드는 상속 된 멤버로 유용하지 않습니다. 배열 클래스는 명시적인 serialVersionUID를 선언 할 수 없으므로 항상 기본 계산 된 값을 갖지만 serialVersionUID 값과 일치하는 요구 사항은 배열 클래스에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8a284373bcb59e24e39e3dac459820aaa1124e2" translate="yes" xml:space="preserve">
          <source>If a service only supports registration for existing targets, an attempt to register for a nonexistent target results in a &lt;code&gt;NameNotFoundException&lt;/code&gt; being thrown as early as possible, preferably at the time &lt;code&gt;addNamingListener()&lt;/code&gt; is called, or if that is not possible, the listener will receive the exception through the &lt;code&gt;NamingExceptionEvent&lt;/code&gt;.</source>
          <target state="translated">서비스가 기존 대상에 대한 등록 만 지원하는 경우 존재하지 않는 대상에 대한 등록을 시도하면 바람직하게 &lt;code&gt;addNamingListener()&lt;/code&gt; 가 호출되거나 가능하지 않은 경우 리스너가 수신 할 때 &lt;code&gt;NameNotFoundException&lt;/code&gt; 이 가능한 빨리 발생 합니다 관통 예외 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="f0a93070904cd7e6062d269f73ed4cf640917a73" translate="yes" xml:space="preserve">
          <source>If a service supports this method it cannot be concluded that job cancellation will always succeed. A job may not be able to be cancelled once it has reached and passed some point in its processing. A successful cancellation means only that the entire job was not printed, some portion may already have printed when cancel returns.</source>
          <target state="translated">서비스가이 방법을 지원하면 작업 취소가 항상 성공할 것이라고 결론을 내릴 수 없습니다. 처리 중 어느 시점에 도달하여 작업을 통과 한 후에는 작업을 취소하지 못할 수 있습니다. 성공적으로 취소한다는 것은 전체 작업이 인쇄되지 않았 음을 의미하며, 취소가 반환되면 일부 부분이 이미 인쇄되었을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2255c8ae3c0e253b4d1c3edfe6c7951b6b7652" translate="yes" xml:space="preserve">
          <source>If a signer, or codesource is granted this permission, then it is considered a trusted source for MBeans. Only MBeans from trusted sources may be registered in the MBeanServer.</source>
          <target state="translated">서명자 또는 코드 소스에이 권한이 부여되면 MBean의 신뢰할 수있는 소스로 간주됩니다. 신뢰할 수있는 소스의 MBean 만 MBeanServer에 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03ecf67fc16b1bbea18316b3fee73e9a01230e4e" translate="yes" xml:space="preserve">
          <source>If a single argument is parsed more than once in the string, then the later parse wins.</source>
          <target state="translated">문자열에서 단일 인수가 두 번 이상 구문 분석되면 나중에 구문 분석이 승리합니다.</target>
        </trans-unit>
        <trans-unit id="f7c81fc364f1f00a7430bc8ff3d40572c48b36c2" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">&lt;code&gt;InetSocketAddress &lt;/code&gt; 가 나타내는 끝점에 바인딩 된 소켓 이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 이 메서드는 소켓이 닫힌 후에도 &lt;code&gt;InetSocketAddress&lt;/code&gt; 를 계속 반환합니다 . 이 경우 반환 된 &lt;code&gt;InetSocketAddress&lt;/code&gt; 의 주소는 &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt; 주소이고 해당 포트는 바인딩 된 로컬 포트입니다.</target>
        </trans-unit>
        <trans-unit id="31689da1ab6eb24083df20cceed8f165c2b092ae" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">&lt;code&gt;InetSocketAddress &lt;/code&gt; 로 표시되는 엔드 포인트에 바인드 된 소켓 이 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 이 메소드는 소켓이 닫힌 후에도 &lt;code&gt;InetSocketAddress&lt;/code&gt; 를 계속 리턴합니다 . 이 경우 반환 된 &lt;code&gt;InetSocketAddress&lt;/code&gt; 의 주소는 &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt; 주소이고 해당 포트는 바인딩 된 로컬 포트입니다.</target>
        </trans-unit>
        <trans-unit id="bb0809c0cf763cd6b646a20d3b4af68f3b750ce9" translate="yes" xml:space="preserve">
          <source>If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is specified it applies to the whole collator object.</source>
          <target state="translated">&amp;lt;modifier&amp;gt;에 의해 제어되는 특수 데이터 정렬 규칙이 지정된 경우 전체 데이터 정렬 기 개체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="427f94ff7874e329986bda9d7fe7b3d120876900" translate="yes" xml:space="preserve">
          <source>If a specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the data transfer subsystem, then invoking this method will establish a mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt; and an encoded version of its MIME type as its native.</source>
          <target state="translated">지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 가 가 이전에 데이터 전송 하위 시스템에 알려지지 않은 경우이 메서드를 호출하면 지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 와 해당 MIME 유형의 인코딩 된 버전 사이의 양방향 매핑 이 네이티브로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cdffd367cf1c3286a3204c998849759d715a852b" translate="yes" xml:space="preserve">
          <source>If a specified native is previously unknown to the data transfer subsystem, and that native has been properly encoded, then invoking this method will establish a mapping in both directions between the specified native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded version of the native.</source>
          <target state="translated">지정된 네이티브가 이전에 데이터 전송 하위 시스템에 알려지지 않았고 해당 네이티브가 올바르게 인코딩 된 경우이 메서드를 호출하면 지정된 네이티브와 서버 사이의 양방향 매핑이 설정됩니다. &lt;code&gt;DataFlavor&lt;/code&gt; MIME 유형이 네이티브의 디코딩 된 버전 인 DataFlavor .</target>
        </trans-unit>
        <trans-unit id="5dcefe732742542e44af9fa0d4a6e91c269fcc8e" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator()&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">spliterator는 그 이상 다음에 요소 추가 특성 값의보고를 포함하지 않는 경우 &lt;code&gt;SIZED&lt;/code&gt; 와 &lt;code&gt;SUBSIZED&lt;/code&gt; 을 제어 전문화 또는 단순화 계산에 클라이언트를 도움이되지 않습니다. 그러나 이렇게하면 변경 불가능하고 빈 분할기 인스턴스를 공유 할 수 있습니다 (&lt;a href=&quot;spliterators#emptySpliterator()&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt;빈 컬렉션 Spliterators.emptySpliterator ())를할 수 있으며 클라이언트가 이러한 분할기가 요소를 포함하지 않는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde854bb0f9389f51a8a547bcdbab6e693c555ad" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">spliterator는 그 이상 다음에 요소 추가 특성 값의보고를 포함하지 않는 경우 &lt;code&gt;SIZED&lt;/code&gt; 와 &lt;code&gt;SUBSIZED&lt;/code&gt; 을 제어 전문화 또는 단순화 계산에 클라이언트를 도움이되지 않습니다. 그러나 이렇게하면 빈 컬렉션 에 대해 불변의 빈 스플리터 인스턴스 ( &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt; 참조 )를 공유하여 사용할 수 있으며 클라이언트가 그러한 스플리터가 요소를 포함하지 않는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b9f294ae09940094318e9c13a1774353137fae2" translate="yes" xml:space="preserve">
          <source>If a step function is omitted, use an &lt;a href=&quot;#identity(java.lang.Class)&quot;&gt;identity function&lt;/a&gt; of the clause's iteration variable type; insert dropped argument parameters before the identity function parameter for the non-&lt;code&gt;void&lt;/code&gt; iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)</source>
          <target state="translated">단계 함수가 생략 된 경우 절의 반복 변수 유형의 &lt;a href=&quot;#identity(java.lang.Class)&quot;&gt;식별 함수&lt;/a&gt; 를 사용하십시오. 삭제 된 인수 매개 변수를 식별 기능 매개 변수 앞에 삽입하십시오. &lt;code&gt;void&lt;/code&gt; 이전 절의 무효 반복 변수에 . (이렇게하면 루프 변수가 로컬 루프 불변으로 바뀝니다.)</target>
        </trans-unit>
        <trans-unit id="377c4e71a3077730a1c7765115b7830cff588ee5" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput(java.lang.Object,boolean,boolean)&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">스트림에 테이블이 포함 된 경우 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 제공된 테이블 은 무시됩니다. 또한 스트림의 첫 번째 이미지에 테이블이 포함되어 있고 후속 이미지에는 포함되지 않은 경우 첫 번째 이미지에 제공된 테이블이 모든 축약 된 이미지에 사용됩니다. 스트림에서 테이블을 읽은 후에는 동일한 스트림에서 읽은 테이블에 의해서만 재정의 될 수 있습니다. 새 테이블을 지정하려면&lt;a href=&quot;../../imagereader#setInput(java.lang.Object,boolean,boolean)&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt;하려면 판독기 setInput 메서드를 호출하여 스트림을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="eceb3e8bdd7aa7928b72e084cf57d623f635838d" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">스트림에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 지정된 테이블 이 무시됩니다. 또한 스트림의 첫 번째 이미지에 테이블이 포함되고 후속 이미지에 테이블이 포함되지 않은 경우 첫 번째 이미지에 제공된 테이블이 모든 약어 이미지에 사용됩니다. 스트림에서 테이블을 읽은 후에는 동일한 스트림에서 읽은 테이블 만 재정의 할 수 있습니다. 새 테이블을 지정 하려면 스트림을 변경하기 위해 리더 의 &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2750feeb92c351bda0cd825237cf381d71b3604" translate="yes" xml:space="preserve">
          <source>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;[1, 2, 3]&lt;/code&gt;, then the result of executing &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; must be &lt;code&gt;[2, 4, 6]&lt;/code&gt;. However, if the source has no defined encounter order, then any permutation of the values &lt;code&gt;[2, 4, 6]&lt;/code&gt; would be a valid result.</source>
          <target state="translated">스트림이 정렬되면 대부분의 작업은 요소에 대해 발생 순서대로 작동하도록 제한됩니다. 스트림의 소스가 &lt;code&gt;List&lt;/code&gt; 인 경우 가 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 포함 경우 &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; 실행 결과는 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 이어야합니다 . 그러나 소스에 정의 된 조우 순서가 없으면 값 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 순열이 올바른 결과가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b6959cca21a486ec06d3cce1668ff1458159cb0" translate="yes" xml:space="preserve">
          <source>If a stream is started, asynchronously or synchronously, it is stopped immediately or after the next flush. This method does &lt;em&gt;NOT&lt;/em&gt; guarantee that all registered actions are completed before return.</source>
          <target state="translated">스트림이 비동기 적으로 또는 동 기적으로 시작되면 즉시 또는 다음 플러시 후에 중지됩니다. 이 방법은 등록 된 모든 작업이 반환되기 전에 완료된다는 것을 보장 하지 &lt;em&gt;못합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ&lt;/em&gt; ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="ec3da9f5ed3a50caf2ebc15ff55bbd7387d78001" translate="yes" xml:space="preserve">
          <source>If a string quote character is encountered, then a string is recognized, consisting of all characters after (but not including) the string quote character, up to (but not including) the next occurrence of that same string quote character, or a line terminator, or end of file. The usual escape sequences such as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and &lt;code&gt;&quot;\t&quot;&lt;/code&gt; are recognized and converted to single characters as the string is parsed.</source>
          <target state="translated">문자열 따옴표 문자가 발견되면 문자열 따옴표 문자 다음의 모든 문자 (포함되지는 않음), 같은 문자열 따옴표 문자의 다음 발생 (또는 포함하지 않음)까지의 문자열이 인식됩니다. 또는 파일 끝입니다. &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 와 같은 일반적인 이스케이프 시퀀스 는 문자열을 구문 분석 할 때 인식되어 단일 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9282cd8e98665287e6b1f89eff4485a0a4410646" translate="yes" xml:space="preserve">
          <source>If a style name field is not one of the valid style strings, it is interpreted as part of the font name, and the default style is used.</source>
          <target state="translated">스타일 이름 필드가 유효한 스타일 문자열 중 하나가 아닌 경우 글꼴 이름의 일부로 해석되고 기본 스타일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b339629857a7b6f3977e054ffb46a3342349d262" translate="yes" xml:space="preserve">
          <source>If a suitable MIDI port is not available, the Receiver is retrieved from an installed synthesizer.</source>
          <target state="translated">적합한 MIDI 포트를 사용할 수없는 경우 설치된 신디사이저에서 수신기를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f22bb50ef0204e8a05930a1ff9dfbe8e25939ae5" translate="yes" xml:space="preserve">
          <source>If a superinterface is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type arguments used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types.</source>
          <target state="translated">수퍼 인터페이스가 매개 변수화 된 유형 인 경우 이에 대해 반환 되는 &lt;code&gt;Type&lt;/code&gt; 객체는 소스 코드에 사용 된 실제 유형 인수를 정확하게 반영해야합니다. 각 수퍼 인터페이스를 나타내는 매개 변수화 된 유형이 이전에 생성되지 않은 경우 생성됩니다. 매개 변수화 된 유형에 대한 생성 프로세스의 의미 는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 의 선언을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cee086fbf4e72f394e2cd369d7a1a31214c885ef" translate="yes" xml:space="preserve">
          <source>If a superinterface is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types.</source>
          <target state="translated">수퍼 인터페이스가 매개 변수화 된 유형 인 경우 &lt;code&gt;Type&lt;/code&gt; 리턴 Type 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다. 각 슈퍼 인터페이스를 나타내는 매개 변수화 된 유형은 이전에 작성되지 않은 경우 작성됩니다. 매개 변수화 된 유형에 대한 작성 프로세스의 시맨틱에 대해서는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 선언을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1534d214fc89bef5391048993cff1403fb779faa" translate="yes" xml:space="preserve">
          <source>If a supported attribute-value is specified in this attribute set, it will take precedence over the API settings for this print() operation only. The following behaviour is specified for PageFormat: If a client uses the Printable interface, then the &lt;code&gt;attributes&lt;/code&gt; parameter to this method is examined for attributes which specify media (by size), orientation, and imageable area, and those are used to construct a new PageFormat which is passed to the Printable object's print() method. See &lt;a href=&quot;printable&quot;&gt;&lt;code&gt;Printable&lt;/code&gt;&lt;/a&gt; for an explanation of the required behaviour of a Printable to ensure optimal printing via PrinterJob. For clients of the Pageable interface, the PageFormat will always be as supplied by that interface, on a per page basis.</source>
          <target state="translated">이 속성 세트에 지원되는 속성 값이 지정되면이 print () 작업에 대해서만 API 설정보다 우선합니다. PageFormat에 대해 다음 동작이 지정됩니다. 클라이언트가 Printable 인터페이스를 사용하는 경우이 메서드에 대한 &lt;code&gt;attributes&lt;/code&gt; 매개 변수는 미디어 (크기별), 방향 및 이미지 가능 영역을 지정하는 속성에 대해 검사되며 새 PageFormat을 구성하는 데 사용됩니다. Printable 객체의 print () 메서드에 전달됩니다. PrinterJob을 통해 최적의 인쇄를 보장하기 위해 Printable의 필수 동작에 대한 설명은 &lt;a href=&quot;printable&quot;&gt; &lt;code&gt;Printable&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 . Pageable 인터페이스의 클라이언트의 경우 PageFormat은 항상 페이지별로 해당 인터페이스에서 제공하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="155d85c2f3acb3ff96d47d191351e45387cd2b50" translate="yes" xml:space="preserve">
          <source>If a system property named &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then the headless implementation of &lt;code&gt;Toolkit&lt;/code&gt; is used, otherwise the default platform-specific implementation of &lt;code&gt;Toolkit&lt;/code&gt; is used.</source>
          <target state="translated">시스템 프로퍼티라는 이름의 경우 &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; 로 설정 &lt;code&gt;true&lt;/code&gt; 다음의 헤드리스 구현 &lt;code&gt;Toolkit&lt;/code&gt; , 사용의 다른 기본 플랫폼 별 구현 &lt;code&gt;Toolkit&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2961ca3d285dda3c14ae9d20b0882642edd01c16" translate="yes" xml:space="preserve">
          <source>If a taglet object is created and used without the above protocol being followed, then the taglet's behavior is not defined by this interface specification.</source>
          <target state="translated">위의 프로토콜을 따르지 않고 taglet 객체를 생성하고 사용하는 경우 taglet의 동작은이 인터페이스 사양에 의해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="879203c3fd36988e5bf767edbe8300f47a6e226a" translate="yes" xml:space="preserve">
          <source>If a target class &lt;code&gt;X&lt;/code&gt; is not accessible to &lt;code&gt;Lookup::in&lt;/code&gt; all access modes are dropped.</source>
          <target state="translated">대상 클래스 &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;Lookup::in&lt;/code&gt; 액세스 할 수없는 경우 모든 액세스 모드에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6f96de5e57069f6d14d17aca38943e0fdc8ff7" translate="yes" xml:space="preserve">
          <source>If a thread does not lock any object monitor or &lt;code&gt;lockedMonitors&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;MonitorInfo&lt;/code&gt; array. Similarly, if a thread does not lock any synchronizer or &lt;code&gt;lockedSynchronizers&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;LockInfo&lt;/code&gt; array.</source>
          <target state="translated">스레드가 객체 모니터를 잠그지 않거나 &lt;code&gt;lockedMonitors&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 반환 된 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체는 빈 &lt;code&gt;MonitorInfo&lt;/code&gt; 배열을 갖습니다 . 마찬가지로 스레드가 동기화 프로그램을 잠그지 않거나 &lt;code&gt;lockedSynchronizers&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 반환 된 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체에는 빈 &lt;code&gt;LockInfo&lt;/code&gt; 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="423d67d62c33ea4b987acaba9861af6927d6c017" translate="yes" xml:space="preserve">
          <source>If a thread initiates the loading of the installed file system providers and another thread invokes a method that also attempts to load the providers then the method will block until the loading completes.</source>
          <target state="translated">스레드가 설치된 파일 시스템 제공자의로드를 시작하고 다른 스레드가 제공자를로드하려고 시도하는 메소드를 호출하면로드가 완료 될 때까지 메소드가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c16eea84f6a093216a1f6035633219e642c6696f" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">대기 중 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 대기가 종료되고 &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt; 이 발생하며 스레드의 중단 상태가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="c7ba95dc1b6c41c9659ab72fa979fc5c3b29d122" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">기다리는 동안 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 대기가 종료됩니다.&lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt; 이 발생하며 스레드의 중단 상태가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="26eeddc8ed4e366f2633c02e1ace6b55601c08d7" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 차단 된 스레드의 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다 . 이로 인해 채널이 닫히고 차단 된 스레드가 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt; 을 수신하며 차단 된 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9af6babb2d89b7b1bcb5f61c939d4682bb0b8bf3" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 차단 된 스레드의 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 . 그러면 채널이 닫히고 차단 된 스레드가 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt; 을 수신 하고 차단 된 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b319d96f8fb779e6cf6dbc96644a4c37d14e3fed" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 채널의 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다 . 이로 인해 차단 된 스레드가 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 을 수신하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd99bc1eee5eed72f1e348ec811d11b7678f072e" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;interruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 채널의 &lt;a href=&quot;interruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 . 차단 된 스레드가 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 을 수신하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="741c512b0e9856c5e2dfc36c34abb9cce44c9e8d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;#wakeup()&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드가 현재이 선택기의 선택 방법 중 하나에서 차단 된 경우 선택기의 &lt;a href=&quot;#wakeup()&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 방법 을 호출하는 것처럼 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="da330aea3c98594d1083e77da98a318f71baeb0d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드가이 선택기의 선택 방법 중 하나에서 현재 차단 된 경우 선택기의 호출을 호출하는 것처럼 스레드가 중단됩니다. &lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="dd825fe40f49db3b150afa3490d105cbd6aabd48" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;#take()&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#poll(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid()&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스레드가 현재 &lt;a href=&quot;#take()&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 에서 차단 된 경우 또는 &lt;a href=&quot;#poll(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 메서드 키가 대기열에 추가되기를 기다리는 경우 즉시 &lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; 을&lt;/a&gt; 수신합니다 . 이 감시 서비스와 관련된 모든 유효한 키는 &lt;a href=&quot;watchkey#isValid()&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d5afbadf14eba91b88bef9af2e17ba1b04cf7b04" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;watchservice#take--&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid--&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스레드가 현재 키 대기를 기다리는 &lt;a href=&quot;watchservice#take--&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 경우 즉시 &lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; 을&lt;/a&gt; 수신합니다 . 이 시계 서비스와 관련된 모든 유효한 키는&lt;a href=&quot;watchkey#isValid--&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="79a80fec9ac0e51a906db8a969589f57b8d53771" translate="yes" xml:space="preserve">
          <source>If a thread of the given ID is not alive or does not exist, this method will return &lt;code&gt;null&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">주어진 ID의 스레드가 존재하지 않거나 존재하지 않으면이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c7367fdf45de9116c0531a4eb673c46e4df10f0d" translate="yes" xml:space="preserve">
          <source>If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;; its interrupt status will remain set.</source>
          <target state="translated">스레드의 인터럽트 상태가 이미 설정되어 있고 채널에서 차단 I / O 작업을 호출하면 채널이 닫히고 스레드는 즉시 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; 을&lt;/a&gt;. 인터럽트 상태는 설정된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f20c8ec4cbcd889326c0ec36148d75b1de4b78c0" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 예외와 함께 완료됩니다. &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;. 시간 초과가 발생하고 구현에서 바이트를 읽지 못했거나 채널에서 지정된 버퍼로 읽지 않는다고 보장 할 수없는 경우 채널에서 계속 읽으려고하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="085511ee4e6f8838601b8420555dabe5caf417db" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 예외와 함께 완료됩니다. &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;. 시간 초과가 발생하고 구현시 바이트가 기록되지 않았거나 지정된 버퍼에서 채널에 기록되지 않을 것을 보장 할 수없는 경우 채널에 쓰려고 시도하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1e6a9ea34cc15cb7dc234bc610d3da7fd2fd1d7" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt; 예외와 함께 완료됩니다. . 시간 초과가 발생하고 구현시 바이트가 기록되지 않았거나 지정된 버퍼에서 채널에 기록되지 않을 것을 보장 할 수없는 경우 채널에 쓰려고하면 추가로 런타임에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aeea9b2c990269d554f71236286a06879279f31" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">제한 시간이 지정되고 조작이 완료되기 전에 제한 시간이 경과하면 &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt; 예외로 조작이 완료됩니다 . 시간 초과가 발생하고 구현에서 바이트를 읽지 못했거나 채널에서 지정된 버퍼로 읽지 않을 것을 보장 할 수없는 경우 채널에서 계속 읽으려고하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b059429e7b4fbc4030cc099662067f32b6c7ab30" translate="yes" xml:space="preserve">
          <source>If a type is annotated with this annotation type, compilers are required to generate an error message unless:</source>
          <target state="translated">이 주석 유형으로 유형에 주석이 달린 경우 다음과 같은 경우를 제외하고 컴파일러는 오류 메시지를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="30a46db240d4202d821461d90b26ad19eebaf078" translate="yes" xml:space="preserve">
          <source>If a type map is explicitly supplied to a method that can perform custom mapping, that type map supersedes the connection's type map.</source>
          <target state="translated">사용자 지정 매핑을 수행 할 수있는 메서드에 형식 맵이 명시 적으로 제공되면 해당 형식 맵이 연결의 형식 맵을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="cec90847ba71497dbb8ac58a8a03e00d0d13737f" translate="yes" xml:space="preserve">
          <source>If a value attribute is not specified for a FORM input element of type &quot;reset&quot;, then this default string is used.</source>
          <target state="translated">&quot;reset&quot;유형의 FORM 입력 요소에 값 속성이 지정되지 않은 경우이 기본 문자열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0d011a6bf2d15325c296c503e117073be6dd16" translate="yes" xml:space="preserve">
          <source>If a value attribute is not specified for a FORM input element of type &quot;submit&quot;, then this default string is used.</source>
          <target state="translated">&quot;제출&quot;유형의 FORM 입력 요소에 값 속성이 지정되지 않은 경우이 기본 문자열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9870e38cea09b6406ac14017d5c924cd67267c1" translate="yes" xml:space="preserve">
          <source>If a value is not present, returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 없으면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="860fe4e2923a6695add73192da6784b1d700c654" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;Optional&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Optional&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="ac19fb5ed0433a6a84bbf9870c3d0508394c1ec9" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalDouble&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalDouble&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="77f8284a88fc486cd8c49e73e5157ec4382cced0" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalInt&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalInt&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="b442beaf0679fd03d92130f9d3a16dff8abc1a47" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalLong&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalLong&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="b332c643a29d3b80d91478304a9a05ebfa61d296" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;Optional&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 존재하는 &lt;code&gt;Optional&lt;/code&gt; 은 분명하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc6398511731b6bf47b59801abf764ae618774f0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalDouble&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 현재 &lt;code&gt;OptionalDouble&lt;/code&gt; 은 명확하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d13847496ad6374cf53cad3b090b540d8f97008c" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalInt&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 현재 &lt;code&gt;OptionalInt&lt;/code&gt; 는 분명하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="32534cbdba6aa1b3be53d4a1e4bd73d3c27b87e1" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalLong&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 현재 &lt;code&gt;OptionalLong&lt;/code&gt; 은 명확하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e270a2bbe380815af7730e0b32eed7b9b310b0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present Optionals must be unambiguously differentiable.</source>
          <target state="translated">값이 있으면 결과에 문자열 표현이 포함되어야합니다. 비어 있고 존재하는 옵션은 명확하게 구분할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="53843db157010fe9437f6ec6848ceaa2431d68a8" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present instances must be unambiguously differentiable.</source>
          <target state="translated">값이 있으면 결과에 문자열 표현이 포함되어야합니다. 비어있는 인스턴스와 현재 인스턴스는 명확하게 구분할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0706b2c7911a55318a829716b41ba2d3be31b10d" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, return an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하고 값이 주어진 술어와 일치 하면 값을 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 리턴하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f1f67ed14ddaf89a0a9fae6c94b2add61c02da04" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, returns an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하고 값이 주어진 술어와 일치하면 &lt;code&gt;Optional&lt;/code&gt; 리턴합니다. 하면 값을 설명 을 반환하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="891603f3a0de1e1f312f4666b625f9fb23d2e9c9" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to it, return that result, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;. This method is similar to &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt;&lt;code&gt;map(Function)&lt;/code&gt;&lt;/a&gt;, but the provided mapper is one whose result is already an &lt;code&gt;Optional&lt;/code&gt;, and if invoked, &lt;code&gt;flatMap&lt;/code&gt; does not wrap it with an additional &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하면 제공된 &lt;code&gt;Optional&lt;/code&gt; 베어링 맵핑 함수를 적용하고 결과를 리턴하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 리턴하십시오 . 이 메소드는 &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt; &lt;code&gt;map(Function)&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 제공된 매퍼는 결과가 이미 &lt;code&gt;Optional&lt;/code&gt; 인 결과이며 , 호출 된 경우 &lt;code&gt;flatMap&lt;/code&gt; 은 추가 &lt;code&gt;Optional&lt;/code&gt; 로 랩핑하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b5560d2bb98c2edc06f003311054df22294d95" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an &lt;code&gt;Optional&lt;/code&gt; describing the result. Otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 제공된 맵핑 함수를 적용하고 결과가 널이 아닌 경우 결과를 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 리턴 하십시오. 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fad40f63b1a2a9bdb013e89c0f84f329771e8703" translate="yes" xml:space="preserve">
          <source>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</source>
          <target state="translated">값이 존재하면 지정된 소비자를 값으로 호출하십시오. 그렇지 않으면 아무 것도 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5d567ac49757fc0782070c29f442b2ed3c10a3dd" translate="yes" xml:space="preserve">
          <source>If a value is present, performs the given action with the value, otherwise does nothing.</source>
          <target state="translated">값이 있으면 해당 값으로 지정된 작업을 수행하고 그렇지 않으면 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80f1d15f081a557c0c89dfe542e08e6466937a4a" translate="yes" xml:space="preserve">
          <source>If a value is present, performs the given action with the value, otherwise performs the given empty-based action.</source>
          <target state="translated">값이 있으면 해당 값으로 지정된 작업을 수행하고, 그렇지 않으면 지정된 빈 기반 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7c76eb4f4aed61ec0dcaef4e6193ded7df1448b7" translate="yes" xml:space="preserve">
          <source>If a value is present, returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . .</target>
        </trans-unit>
        <trans-unit id="990df4fbcc05f42f66d4bdbbd223d271fecafc58" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/doublestream&quot;&gt;&lt;code&gt;DoubleStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;DoubleStream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차 &lt;a href=&quot;stream/doublestream&quot;&gt; &lt;code&gt;DoubleStream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;DoubleStream&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="385631a2bb5e8e2699a3121cde109d9d5c428c7c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/intstream&quot;&gt;&lt;code&gt;IntStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;IntStream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차적 &lt;a href=&quot;stream/intstream&quot;&gt; &lt;code&gt;IntStream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;IntStream&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="866cb2164afa2f09d3d5f20e37c35481f6eb4412" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/longstream&quot;&gt;&lt;code&gt;LongStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;LongStream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차 &lt;a href=&quot;stream/longstream&quot;&gt; &lt;code&gt;LongStream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;LongStream&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5d3bb8d4c843a69020ffe62321e3f9054e0b137e" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;Stream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차 &lt;a href=&quot;stream/stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;Stream&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="80b22e4088b80520ac0af98bec76415b35276b8f" translate="yes" xml:space="preserve">
          <source>If a value is present, returns an &lt;code&gt;Optional&lt;/code&gt; describing (as if by &lt;a href=&quot;#ofNullable(T)&quot;&gt;&lt;code&gt;ofNullable(T)&lt;/code&gt;&lt;/a&gt;) the result of applying the given mapping function to the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 주어진 매핑 함수를 값에 적용한 결과를 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 반환하고 ( &lt;a href=&quot;#ofNullable(T)&quot;&gt; &lt;code&gt;ofNullable(T)&lt;/code&gt; &lt;/a&gt; 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="abd4d4cf8da044effb78b2adaaded70498203413" translate="yes" xml:space="preserve">
          <source>If a value is present, returns an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise returns an &lt;code&gt;Optional&lt;/code&gt; produced by the supplying function.</source>
          <target state="translated">값이 있으면 값을 설명하는 &lt;code&gt;Optional&lt;/code&gt; 을 반환하고 그렇지 않으면 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다. 제공하는 함수에 의해 생성 된 합니다.</target>
        </trans-unit>
        <trans-unit id="d4b5e82c51b8cf385fd5db9aef6045fbce1f3044" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the result of applying the given &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 주어진 &lt;code&gt;Optional&lt;/code&gt; -bearing 매핑 함수를 값 에 적용한 결과를 반환하고 , 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f14d878112134ffc9ff4d14f0e3174e5576c31bb" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise returns &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 값을 반환하고 그렇지 않으면 &lt;code&gt;other&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8c50641617ef0d200da8db393fec3586af58ae1c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise returns the result produced by the supplying function.</source>
          <target state="translated">값이 있으면 값을 반환하고, 그렇지 않으면 제공하는 함수에서 생성 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56c949f365a2890532569468d612418290144d9c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="ae9bed738425dfb5a5a5674c68f5303dddc05d71" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise throws an exception produced by the exception supplying function.</source>
          <target state="translated">값이 있으면 값을 반환하고, 그렇지 않으면 예외 제공 함수에서 생성 한 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="8eddee0588c954a17deb099f9dd61de2515231b4" translate="yes" xml:space="preserve">
          <source>If a value of null is specified for the Set, this Component inherits the Set from its parent. If all ancestors of this Component have null specified for the Set, then the current KeyboardFocusManager's default Set is used.</source>
          <target state="translated">Set에 null 값이 지정되면이 컴포넌트는 부모로부터 Set을 상속합니다. 이 컴포넌트의 모든 조상이 Set에 대해 null을 지정하면 현재 KeyboardFocusManager의 기본 Set이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f16c24760d5749166bc98a390f507c2d3216615" translate="yes" xml:space="preserve">
          <source>If a value of null is specified for the Set, this Container inherits the Set from its parent. If all ancestors of this Container have null specified for the Set, then the current KeyboardFocusManager's default Set is used.</source>
          <target state="translated">Set에 null 값이 지정되면이 컨테이너는 부모로부터 Set를 상속합니다. 이 컨테이너의 모든 조상이 Set에 대해 null을 지정하면 현재 KeyboardFocusManager의 기본 Set이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="387ee9cb7e9e0be3dd6915fcd912184178dc89a4" translate="yes" xml:space="preserve">
          <source>If a vertical scrollbar is needed, i.e. if the viewport's extent height is smaller than its view height or if the &lt;code&gt;displayPolicy&lt;/code&gt; is ALWAYS, it's treated like the row header with respect to its dimensions and is made visible.</source>
          <target state="translated">수직 스크롤바가 필요한 경우, 즉 뷰포트의 범위 높이가 뷰 높이보다 작거나 &lt;code&gt;displayPolicy&lt;/code&gt; 가 ALWAYS 인 경우, 치수와 관련하여 행 헤더처럼 처리되고 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc4cf82efa4121c970d3bd205365e50de294c4b" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;
 NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">방문자가의 결과를 돌려주는 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt; NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="92cb4d374f2fe9448ca335ac55aeaabe71a1f569" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">방문자가의 결과를 돌려주는 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="5e01b98873a0cadbbe64c47b2b726716a54e9964" translate="yes" xml:space="preserve">
          <source>If a watched file is not located on a local storage device then it is implementation specific if changes to the file can be detected. In particular, it is not required that changes to files carried out on remote systems be detected.</source>
          <target state="translated">감시 된 파일이 로컬 저장 장치에 없으면 파일 변경이 감지 될 수있는 경우 구현에 따라 다릅니다. 특히, 원격 시스템에서 수행 된 파일의 변경을 감지 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5650a3db9a7e2000acade2b25c2be5c4db496f6e" translate="yes" xml:space="preserve">
          <source>If a writer isRepairingNamespaces it will create a namespace declaration on the current StartElement for any attribute that does not currently have a namespace declaration in scope. If the StartElement has a uri but no prefix specified a prefix will be assigned, if the prefix has not been declared in a parent of the current StartElement it will be declared on the current StartElement. If the defaultNamespace is bound and in scope and the default namespace matches the URI of the attribute or StartElement QName no prefix will be assigned.</source>
          <target state="translated">작성자가 isRepairingNamespaces이면 현재 범위에 네임 스페이스 선언이없는 속성에 대해 현재 StartElement에 네임 스페이스 선언을 만듭니다. StartElement에 uri가 있지만 접두사가 지정되지 않은 경우 접두사가 할당되고 접두사가 현재 StartElement의 부모에서 선언되지 않은 경우 현재 StartElement에서 선언됩니다. defaultNamespace가 바인딩되고 범위 내에 있고 기본 네임 스페이스가 특성의 URI 또는 ​​StartElement QName과 일치하면 접두사가 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73a81112b02af25fafd5aeb53509af8b9467d422" translate="yes" xml:space="preserve">
          <source>If aContainer is &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;, the focus is always transferred down-cycle.</source>
          <target state="translated">aContainer가 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;포커스 순회 정책 공급자&lt;/a&gt; 인 경우 포커스는 항상 다운 사이클로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="740f7c5f8d2ce7496496f12eb476ff1f2e840f4c" translate="yes" xml:space="preserve">
          <source>If aContainer is &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;, the focus is always transferred down-cycle.</source>
          <target state="translated">aContainer가 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;포커스 순회 정책 공급자&lt;/a&gt; 인 경우 포커스는 항상 다운 사이클로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="bee200d444da7e51810a8f81ba5dffe16cc316fc" translate="yes" xml:space="preserve">
          <source>If addr specifies an IPv4 address an instance of Inet4Address will be returned; otherwise, an instance of Inet6Address will be returned.</source>
          <target state="translated">addr이 IPv4 주소를 지정하면 Inet4Address의 인스턴스가 리턴됩니다. 그렇지 않으면 Inet6Address의 인스턴스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="923186511eab92209b32f15d3fb01aaacb2e442c" translate="yes" xml:space="preserve">
          <source>If adjacent parsing is active, then parsing must match exactly the specified number of digits in both strict and lenient modes. In addition, no positive or negative sign is permitted.</source>
          <target state="translated">인접 구문 분석이 활성화 된 경우 구문 분석은 엄격 모드와 무성 모드에서 지정된 자릿수와 정확히 일치해야합니다. 또한 양수 또는 음수 부호는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="200dbc311565e1132ebe3228cefc3d9aab1c06b2" translate="yes" xml:space="preserve">
          <source>If adjacent runs of text with the same &lt;code&gt;InputMethodHighlight&lt;/code&gt; need to be rendered separately, the &lt;code&gt;InputMethodHighlights&lt;/code&gt; should be wrapped in &lt;code&gt;Annotation&lt;/code&gt; instances.</source>
          <target state="translated">동일한 &lt;code&gt;InputMethodHighlight&lt;/code&gt; 를 가진 인접 텍스트 실행을 별도로 렌더링해야하는 경우 &lt;code&gt;InputMethodHighlights&lt;/code&gt; 를 &lt;code&gt;Annotation&lt;/code&gt; 인스턴스 로 래핑해야 합니다.</target>
        </trans-unit>
        <trans-unit id="716099ad8a55cb2a7c2b3773b52c94f64ee203cb" translate="yes" xml:space="preserve">
          <source>If after the window location has been calculated, the upper, left, or right edge of the window is out of the screen, then the window is located in such a way that the upper, left, or right edge of the window coincides with the corresponding edge of the screen. If both left and right edges of the window are out of the screen, the window is placed at the left side of the screen. The similar placement will occur if both top and bottom edges are out of the screen. In that case, the window is placed at the top side of the screen.</source>
          <target state="translated">창 위치를 계산 한 후 창의 위쪽, 왼쪽 또는 오른쪽 가장자리가 화면 밖에 있으면 창의 위쪽, 왼쪽 또는 오른쪽 가장자리가 일치하는 방식으로 창이 배치됩니다. 화면의 해당 가장자리. 창의 왼쪽과 오른쪽 가장자리가 모두 화면 밖에있는 경우 창은 화면 왼쪽에 배치됩니다. 위쪽과 아래쪽 가장자리가 모두 화면을 벗어나면 유사한 배치가 발생합니다. 이 경우 창은 화면 상단에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="44d02905089e1694a5a3552ec8bae0d4cda874a1" translate="yes" xml:space="preserve">
          <source>If agent classes need to link to classes in platform (or other) modules that are not in the boot layer then the application may need to be started in a way that ensures that these modules are in the boot layer. In the JDK implementation for example, the &lt;code&gt;--add-modules&lt;/code&gt; command line option can be used to add modules to the set of root modules to resolve at startup.</source>
          <target state="translated">에이전트 클래스가 부트 계층에없는 플랫폼 (또는 기타) 모듈의 클래스에 링크해야하는 경우 이러한 모듈이 부트 계층에 있는지 확인하는 방식으로 애플리케이션을 시작해야 할 수 있습니다. 예를 들어 JDK 구현에서 &lt;code&gt;--add-modules&lt;/code&gt; 명령 줄 옵션을 사용하여 시작시 확인할 루트 모듈 집합에 모듈을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa34a3f881c3ffb5525522b340dad76550fa33e" translate="yes" xml:space="preserve">
          <source>If all inputs are null, the &lt;code&gt;LSParser&lt;/code&gt; will report a &lt;code&gt;DOMError&lt;/code&gt; with its &lt;code&gt;DOMError.type&lt;/code&gt; set to &lt;code&gt;&quot;no-input-specified&quot;&lt;/code&gt; and its &lt;code&gt;DOMError.severity&lt;/code&gt; set to &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt;.</source>
          <target state="translated">모든 입력이 null의 경우, &lt;code&gt;LSParser&lt;/code&gt; 에이 보고서 것 &lt;code&gt;DOMError&lt;/code&gt; 을 그와 함께 &lt;code&gt;DOMError.type&lt;/code&gt; 의 로 세트 &lt;code&gt;&quot;no-input-specified&quot;&lt;/code&gt; 과 &lt;code&gt;DOMError.severity&lt;/code&gt; 의 로 설정 &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8c6c1fd23bed92157c4876b59e8a94de5ba0fe9" translate="yes" xml:space="preserve">
          <source>If all of the keys in the key set at the start of this step have empty interest sets then neither the selected-key set nor any of the keys' ready-operation sets will be updated.</source>
          <target state="translated">이 단계를 시작할 때 키 세트의 모든 키에 비어있는 관심 세트가 있으면 선택한 키 세트와 키의 준비 작업 세트가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="785bd1a03946e5c11649c06831e14c3b158e51f0" translate="yes" xml:space="preserve">
          <source>If all samples of both source and destination Rasters are of integral type and less than or equal to 32 bits in size, then calling this method is equivalent to executing the following code for all &lt;code&gt;x,y&lt;/code&gt; addresses valid in both Rasters.</source>
          <target state="translated">소스 및 대상 Raster의 모든 샘플이 정수 유형이고 크기가 32 비트 이하인 경우이 메서드를 호출하는 것은 두 Raster에서 유효한 모든 &lt;code&gt;x,y&lt;/code&gt; 주소에 대해 다음 코드를 실행하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f4ad16a03d874b1099d86cc284527a5d0fd4f2c9" translate="yes" xml:space="preserve">
          <source>If all that is desired is the simple identity transformation of a source to a result, then &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; provides a &lt;a href=&quot;transformerfactory#newTransformer()&quot;&gt;&lt;code&gt;TransformerFactory.newTransformer()&lt;/code&gt;&lt;/a&gt; method with no arguments. This method creates a Transformer that effectively copies the source to the result. This method may be used to create a DOM from SAX events or to create an XML or HTML stream from a DOM or SAX events.</source>
          <target state="translated">원하는 것이 소스를 결과로 단순 ID 변환 하는 것 &lt;a href=&quot;transformerfactory#newTransformer()&quot;&gt; &lt;code&gt;TransformerFactory.newTransformer()&lt;/code&gt; &lt;/a&gt; 이라면 &lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt; 는 인수없이 TransformerFactory.newTransformer () 메서드를 제공합니다 . 이 메서드는 소스를 결과에 효과적으로 복사하는 Transformer를 만듭니다. 이 메서드는 SAX 이벤트에서 DOM을 생성하거나 DOM 또는 SAX 이벤트에서 XML 또는 HTML 스트림을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478f44b721763a191efa4a005ca8cf8c23dac1b2" translate="yes" xml:space="preserve">
          <source>If all the date objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date is used. To compare the dates of two &lt;code&gt;TemporalAccessor&lt;/code&gt; instances, including dates in two different chronologies, use &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as a comparator.</source>
          <target state="translated">비교되는 모든 날짜 개체가 동일한 연대기 인 경우 추가 연대기 단계가 필요하지 않으며 현지 날짜 만 사용됩니다. 두 개의 다른 연대기 날짜를 포함하여 두 &lt;code&gt;TemporalAccessor&lt;/code&gt; 인스턴스 의 날짜를 비교하려면 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 를 비교 자로 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="920032b96bedf78cb11745b4b01ea2b9da62f86c" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date-time is used.</source>
          <target state="translated">비교되는 모든 날짜-시간 객체가 동일한 연대기에있는 경우 추가 연대기 단계가 필요하지 않으며 로컬 날짜-시간 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91e24b45b1050248e3d9b0f32a1bfe41649a4f37" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required.</source>
          <target state="translated">비교되는 모든 날짜-시간 객체가 동일한 연대기이면 추가 연대기 단계가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eed6c18a7529e057741cc5ea4bc802b1033492a2" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo(java.time.chrono.ChronoLocalDateTime)&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교되는 모든 날짜-시간이 &lt;code&gt;LocalDateTime&lt;/code&gt; 의 인스턴스 인 경우 비교는 전적으로 날짜-시간을 기반으로합니다. 비교되는 일부 날짜가 다른 연대기에있는 경우 연대기도 고려됩니다. &lt;a href=&quot;chrono/chronolocaldatetime#compareTo(java.time.chrono.ChronoLocalDateTime)&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7af80a78ccebdf694054065e68649e1c92533dff" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교중인 모든 날짜-시간이 &lt;code&gt;LocalDateTime&lt;/code&gt; 의 인스턴스 인 경우 비교는 전적으로 날짜-시간을 기반으로합니다. 비교중인 일부 날짜가 다른 연대기 인 경우 연대기도 고려됩니다. &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8b68f4d96414def1c9a247a1feae8028274ccf8" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo(java.time.chrono.ChronoLocalDate)&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교되는 모든 날짜가 &lt;code&gt;LocalDate&lt;/code&gt; 의 인스턴스 인 경우 비교는 전적으로 날짜를 기반으로합니다. 비교되는 일부 날짜가 다른 연대기에있는 경우 연대기도 고려됩니다 . &lt;a href=&quot;chrono/chronolocaldate#compareTo(java.time.chrono.ChronoLocalDate)&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c70daeec02ec422b3471ddc6193b4b37b8cb8342" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교중인 모든 날짜가 &lt;code&gt;LocalDate&lt;/code&gt; 인스턴스 인 경우 비교는 전적으로 날짜를 기준으로합니다. 비교되는 일부 날짜가 다른 연대기 인 경우 연대기도 고려됩니다 . &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95938a0cd815321f6453791f7f4283d94220e212" translate="yes" xml:space="preserve">
          <source>If all the docs have the same binding specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">모든 문서에 지정된 바인딩이 동일 하면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의&lt;/a&gt; 값 이 의미가 있으며 프린터 처리는 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7869c5e4ed330a875f3cd70b80530f1cdf968256" translate="yes" xml:space="preserve">
          <source>If all the docs have the same number up value</source>
          <target state="translated">모든 문서의 번호가 같은 값을 갖는 경우</target>
        </trans-unit>
        <trans-unit id="323feabb33d09245620f68d33109a728cd260051" translate="yes" xml:space="preserve">
          <source>If all the docs have the same page ranges specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">모든 문서에 동일한 페이지 범위가 지정되어 있으면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 이 의미가 있으며 프린터 처리는 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7632f9c77b81ad5d1b5d6f09a7736f43de381a75" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of &lt;code&gt;SheetCollate&lt;/code&gt; and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">모든 문서에 동일한 시트 정렬이 지정된 경우 다음과 같은 &lt;code&gt;SheetCollate&lt;/code&gt; 및 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 조합 이 허용되며 다른 조합이 지정된 경우 작업이 제출 될 때 프린터가 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="43de23ce23841ef0c6a6fa16c30e0adac32dff5f" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of SheetCollate and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">모든 문서에 동일한 시트 데이터 정렬이 지정된 경우 다음 SheetCollate 및 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 조합 이 허용되며 다른 조합이 지정된 경우 작업이 제출 될 때 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="53f4aefa8b3b18b801db7105e517f135c3160808" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sides value</source>
          <target state="translated">모든 문서의 측면 값이 동일한 경우</target>
        </trans-unit>
        <trans-unit id="3b7bb19ce2d8fc8ee789c0716e2955f9d1adbc31" translate="yes" xml:space="preserve">
          <source>If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit except by throwing an exception.</source>
          <target state="translated">모든 pred 함수가 항상 true를 반환하면 fini 함수가 호출되지 않으며 루프는 예외를 throw하는 경우를 제외하고는 종료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5b294fc85ac6bc7caf05040784ae5fbc6fd93b1" translate="yes" xml:space="preserve">
          <source>If all the proxy interfaces are in &lt;em&gt;exported&lt;/em&gt; or &lt;em&gt;open&lt;/em&gt; packages:</source>
          <target state="translated">모든 프록시 인터페이스가 &lt;em&gt;내보내&lt;/em&gt; 거나 &lt;em&gt;열려있는&lt;/em&gt; 패키지에있는 경우 :</target>
        </trans-unit>
        <trans-unit id="13b164fb9c908e01dba066b8fc6c58bae1a8266f" translate="yes" xml:space="preserve">
          <source>If all the weights are zero, all the extra space appears between the grids of the cell and the left and right edges.</source>
          <target state="translated">모든 가중치가 0이면 셀의 그리드와 왼쪽 및 오른쪽 가장자리 사이에 모든 추가 공간이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="75e3f80e58848d10fc7b05443ed5b045728e7ed1" translate="yes" xml:space="preserve">
          <source>If all the weights are zero, all the extra space appears between the grids of the cell and the top and bottom edges.</source>
          <target state="translated">모든 가중치가 0이면 셀의 그리드와 위쪽 및 아래쪽 가장자리 사이에 모든 추가 공간이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e98b6cadfd0e47989a3a1fb253438638f5a39323" translate="yes" xml:space="preserve">
          <source>If already detached from the virtual machine then invoking this method has no effect.</source>
          <target state="translated">가상 머신에서 이미 분리 된 경우이 메소드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb8a32bf1903f2512087dd34b708c9f237e4fae2" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#parsedExcessDays()&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">는 IF &lt;a href=&quot;#parsedExcessDays()&quot;&gt;일을 초과하는 수는&lt;/a&gt; 다음 구문 분석 그것은 날짜가 사용할 수있는 경우 날짜에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4098503fbcb241fe10627044b2064dc72f141550" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after returned from this method, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이는&lt;/a&gt; 이 메서드에서 반환 후 디렉토리에 액세스 할 때 발생합니다, 그것은는에 싸여 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 자리를 차지할 액세스의 원인이 된 방법에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="088dd2d19f784625275b483d3f0f4f2ddbb175e3" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after this method has returned, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이는&lt;/a&gt; 이 방법이 리턴 한 후 디렉토리에 액세스 할 때 발생합니다, 그것은는에 싸여 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 자리를 차지할 액세스의 원인이 된 방법에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="448273579cd0c1573f50adb27cc551f6240ac792" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">는 IF &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;일을 초과하는 수는&lt;/a&gt; 다음 구문 분석 그것은 날짜가 사용할 수있는 경우 날짜에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f440d6e16437287ae444b44920a0eee99c549130" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the underlying &lt;code&gt;BufferedReader&lt;/code&gt;, it is wrapped in an &lt;a href=&quot;uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the &lt;code&gt;Stream&lt;/code&gt; method that caused the read to take place. This method will return a Stream if invoked on a BufferedReader that is closed. Any operation on that stream that requires reading from the BufferedReader after it is closed, will cause an UncheckedIOException to be thrown.</source>
          <target state="translated">경우 &lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 가이&lt;/a&gt; 기본에 액세스 할 때 발생합니다 &lt;code&gt;BufferedReader&lt;/code&gt; 로를 , 그것은에 싸여 &lt;a href=&quot;uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 으로부터 발생합니다 &lt;code&gt;Stream&lt;/code&gt; 읽기가 발생하는 원인 방법. 이 메소드는 닫힌 BufferedReader에서 호출 된 경우 스트림을 리턴합니다. 해당 스트림에서 BufferedReader를 닫은 후 읽기가 필요한 작업을 수행하면 UncheckedIOException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="959df27348a054da287e538a4f7d1a74313d32f5" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is not present on an annotation type &lt;code&gt;T&lt;/code&gt; , then an annotation of type &lt;code&gt;T&lt;/code&gt; may be written as a modifier for any declaration except a type parameter declaration.</source>
          <target state="translated">는 IF &lt;code&gt;@Target&lt;/code&gt; 의 메타 주석이 주석 형에 존재하지 않는 &lt;code&gt;T&lt;/code&gt; 를 입력 한 다음의 주석 &lt;code&gt;T&lt;/code&gt; 는 타입 파라미터 선언 제외한 선언 개질제로서 기록 될 수있다.</target>
        </trans-unit>
        <trans-unit id="7444a73ead79fffd1052783fd985fdbe7c5cdbb4" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is not present on an annotation type &lt;code&gt;T&lt;/code&gt;, then an annotation of type &lt;code&gt;T&lt;/code&gt; may be written as a modifier for any declaration except a type parameter declaration.</source>
          <target state="translated">는 IF &lt;code&gt;@Target&lt;/code&gt; 의 메타 주석이 주석 형에 존재하지 않는 &lt;code&gt;T&lt;/code&gt; 를 입력 한 다음의 주석 &lt;code&gt;T&lt;/code&gt; 는 타입 파라미터 선언 제외한 선언 개질제로서 기록 될 수있다.</target>
        </trans-unit>
        <trans-unit id="8371b963c2b6f04360837c6404d40bc176c92b9b" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is present, the compiler will enforce the usage restrictions indicated by &lt;code&gt;ElementType&lt;/code&gt; enum constants, in line with JLS 9.7.4.</source>
          <target state="translated">는 IF &lt;code&gt;@Target&lt;/code&gt; 의 메타 주석이 존재하는, 사용 제한을 적용합니다 컴파일러에 의해 표시 &lt;code&gt;ElementType&lt;/code&gt; 에의 JLS 9.7.4에 맞춰, 열거 상수.</target>
        </trans-unit>
        <trans-unit id="0c49dc23b8bd2062de89ca86518931b5b9024793" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; has not been explicitly set, one will be set based on the &lt;code&gt;Class&lt;/code&gt; of the value type after &lt;code&gt;setValue&lt;/code&gt; has been invoked (assuming value is non-null). For example, in the following code an appropriate &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; and &lt;code&gt;AbstractFormatter&lt;/code&gt; will be created to handle formatting of numbers:</source>
          <target state="translated">&lt;code&gt;AbstractFormatterFactory&lt;/code&gt; 가 명시 적으로 설정되지 않은 경우 &lt;code&gt;setValue&lt;/code&gt; 가 호출 된 후 값 유형 의 &lt;code&gt;Class&lt;/code&gt; 를 기반으로 하나가 설정 됩니다 (값이 널이 아닌 것으로 가정). 예를 들어, 다음 코드에서 적절한 &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; 및 &lt;code&gt;AbstractFormatter&lt;/code&gt; 는 숫자 형식을 처리하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2413517d9fd5745a82ae6ddf00cd7489151ba27f" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AffineTransform&lt;/code&gt; is passed to &lt;a href=&quot;#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)&quot;&gt;&lt;code&gt;drawImage(Image, AffineTransform, ImageObserver)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;AffineTransform&lt;/code&gt; is used to transform the bounding box from image space to user space. If no &lt;code&gt;AffineTransform&lt;/code&gt; is supplied, the bounding box is treated as if it is already in user space.</source>
          <target state="translated">는 IF &lt;code&gt;AffineTransform&lt;/code&gt; 전달됩니다 &lt;a href=&quot;#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)&quot;&gt; &lt;code&gt;drawImage(Image, AffineTransform, ImageObserver)&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;AffineTransform&lt;/code&gt; 이미지 공간으로부터 사용자 공간에 바운딩 박스를 변환하는 데 사용됩니다. &lt;code&gt;AffineTransform&lt;/code&gt; 이 제공 되지 않으면 경계 상자가 이미 사용자 공간에있는 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9496a4d3cf27eda519ac141e2a00e405156b6ffb" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the particular type of the input stream.</source>
          <target state="translated">는 IF &lt;code&gt;IOException&lt;/code&gt; 가이 발생되지 않고, 그 스트림은 입력 스트림의 특정 유형에 따라 고정 된 상태로 리셋되고 그것이 어떻게 만들어졌다. &lt;code&gt;read&lt;/code&gt; 메소드 의 후속 호출자에게 제공 될 바이트 는 입력 스트림의 특정 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8be497ebd5fad36819e8bdb92f6d004796dc73ce" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IndexColorModel&lt;/code&gt; object has a transparency value of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;, then the &lt;code&gt;hasAlpha&lt;/code&gt; and &lt;code&gt;getNumComponents&lt;/code&gt; methods (both inherited from &lt;code&gt;ColorModel&lt;/code&gt;) return false and 3, respectively. For any other transparency value, &lt;code&gt;hasAlpha&lt;/code&gt; returns true and &lt;code&gt;getNumComponents&lt;/code&gt; returns 4.</source>
          <target state="translated">는 IF &lt;code&gt;IndexColorModel&lt;/code&gt; 오브젝트의 투명도 값 갖는다 &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; 가를 다음 &lt;code&gt;hasAlpha&lt;/code&gt; 및 &lt;code&gt;getNumComponents&lt;/code&gt; 방법 (모두로부터 상속 &lt;code&gt;ColorModel&lt;/code&gt; 에 각각 복귀 거짓 및도 3). 다른 투명도 값의 경우 &lt;code&gt;hasAlpha&lt;/code&gt; 는 true를 반환하고 &lt;code&gt;getNumComponents&lt;/code&gt; 는 4를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6de50cf0b5b005c73f2b22f23092356cfbc265a6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; reference was previously allowed, the previous settings are overwritten.</source>
          <target state="translated">경우 &lt;code&gt;Object&lt;/code&gt; 참조가 이전에 허용 된 이전 설정을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ce889769df21717dff5602aeddeab9f3a68fa96a" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;RMIServerImpl&lt;/code&gt; was supplied to the constructor, it is used.</source>
          <target state="translated">&lt;code&gt;RMIServerImpl&lt;/code&gt; 이 생성자에 제공된 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c147456e60cfbfb343d2b171d44a03397a71498d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optionType&lt;/code&gt; was specified to this &lt;code&gt;ConfirmationCallback&lt;/code&gt;, this option may be specified as a &lt;code&gt;defaultOption&lt;/code&gt; or returned as the selected index.</source>
          <target state="translated">&lt;code&gt;optionType&lt;/code&gt; 이이 &lt;code&gt;ConfirmationCallback&lt;/code&gt; 에 지정된 경우 ,이 옵션은 &lt;code&gt;defaultOption&lt;/code&gt; 으로 지정 되거나 선택된 색인으로 리턴 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8447b90738960e5c08b7001e6598b18a44c5ae38" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal()&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">ACL 항목 에이 속성보기와 동일한 제공자와 연관되지 않은 &lt;a href=&quot;aclentry#principal()&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt; 이 포함 된 경우 &lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 추가 검증 (있는 경우)은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bddc19f4e2a7499584504adbd2e120339e8a9d2c" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal--&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">ACL 항목 에이 속성보기와 동일한 제공자와 연관되지 않은 &lt;a href=&quot;aclentry#principal--&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt; 이 포함 된 경우 &lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 추가 검증 (있는 경우)은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6e691cd0ee7a41eeed3186a97648a8370581048b" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered when accessing the directory then it causes the &lt;code&gt;Iterator&lt;/code&gt;'s &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; methods to throw &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; as the cause. As stated above, the &lt;code&gt;hasNext&lt;/code&gt; method is guaranteed to read-ahead by at least one element. This means that if &lt;code&gt;hasNext&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, and is followed by a call to the &lt;code&gt;next&lt;/code&gt; method, then it is guaranteed that the &lt;code&gt;next&lt;/code&gt; method will not fail with a &lt;code&gt;DirectoryIteratorException&lt;/code&gt;.</source>
          <target state="translated">디렉토리에 액세스 할 때 I / O 오류가 발생하면 &lt;code&gt;Iterator&lt;/code&gt; 의 &lt;code&gt;hasNext&lt;/code&gt; 또는 &lt;code&gt;next&lt;/code&gt; 메소드가 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 을 원인으로하여 &lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt; 을 발생시킵니다. 위에서 언급 한 바와 같이, &lt;code&gt;hasNext&lt;/code&gt; 방법은 적어도 하나의 요소에 의해 미리 읽히도록 보장된다. 즉, &lt;code&gt;hasNext&lt;/code&gt; 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 한 후 &lt;code&gt;next&lt;/code&gt; 메소드를 호출 하면 &lt;code&gt;next&lt;/code&gt; 메소드가 &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 과 함께 실패하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="feeedb640cf4499009e04bb26412c9322b88b5ad" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the file or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the output stream may be in an inconsistent state. It is strongly recommended that the output stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">파일에서 읽거나 출력 스트림에 쓰는 동안 I / O 오류가 발생하면 일부 바이트를 읽거나 쓴 후에 오류가 발생할 수 있습니다. 결과적으로 출력 스트림이 일치하지 않는 상태에있을 수 있습니다. I / O 오류가 발생하면 출력 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9c872125a1307797d25e4f9f64998713cf5ca5f3" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the file, then it may do so after the target file has been created and after some bytes have been read or written. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the input stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 읽거나 파일에 쓰는 동안 I / O 오류가 발생하면 대상 파일을 작성한 후 일부 바이트를 읽거나 쓴 후에 발생할 수 있습니다. 결과적으로, 입력 스트림은 스트림의 끝에 있지 않을 수 있으며 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 입력 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e4515b55c84516838e1780f2824973489fcfac02" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the input stream may not be at end of stream and one, or both, streams may be in an inconsistent state. It is strongly recommended that both streams be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 읽거나 출력 스트림에 쓰는 I / O 오류가 발생하면 일부 바이트를 읽거나 쓴 후에 오류가 발생할 수 있습니다. 결과적으로 입력 스트림은 스트림의 끝이 아닐 수 있으며 스트림 중 하나 또는 둘 모두가 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 두 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6575b29bb7b7702708e4556bb126e11740cace5" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream, then it may do so after some, but not all, bytes have been read. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 I / O 오류가 발생하면 일부 바이트를 읽은 후에 발생할 수 있습니다. 결과적으로 입력 스트림은 스트림의 끝에 있지 않을 수 있으며 일관성없는 상태에있을 수 있습니다. I / O 오류가 발생하면 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8650ce7705399aaaa8cc71478fcf996136dfacc1" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream, then it may do so after some, but not all, bytes of &lt;code&gt;b&lt;/code&gt; have been updated with data from the input stream. Consequently the input stream and &lt;code&gt;b&lt;/code&gt; may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 읽기 I / O 오류가 발생하면 전체가 아닌 일부 &lt;code&gt;b&lt;/code&gt; 바이트가 입력 스트림의 데이터로 업데이트 된 후에 발생할 수 있습니다 . 결과적으로 입력 스트림과 &lt;code&gt;b&lt;/code&gt; 는 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b10fec173abaf89ed742106df0192bdc5dd2cd41" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the reader or writing to the writer, then it may do so after some characters have been read or written. Consequently the reader may not be at end of the stream and one, or both, streams may be in an inconsistent state. It is strongly recommended that both streams be promptly closed if an I/O error occurs.</source>
          <target state="translated">판독기에서 읽거나 기록기에 쓰는 I / O 오류가 발생하면 일부 문자를 읽거나 쓴 후에 오류가 발생할 수 있습니다. 결과적으로 판독기는 스트림의 끝에 있지 않을 수 있으며 스트림 중 하나 또는 둘 모두가 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 두 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22ab8147923c63cb080ea7642bb58cee303b4eaf" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs, then the input stream may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">I / O 오류가 발생하면 입력 스트림이 일관성없는 상태 일 수 있습니다. I / O 오류가 발생하면 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8e94181111a51e17f16b6ca91b979e4213744c5a" translate="yes" xml:space="preserve">
          <source>If an I/O error or signing error occurs during the signing, then it may do so after some bytes have been written. Consequently, the output stream may be in an inconsistent state. It is strongly recommended that it be promptly closed in this case.</source>
          <target state="translated">서명 중에 I / O 오류 또는 서명 오류가 발생하면 일부 바이트가 기록 된 후에 발생할 수 있습니다. 결과적으로 출력 스트림은 불일치 상태에있을 수 있습니다. 이 경우 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e0e0bbd8cf71d8f39745254a8443c1668c16acb" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context</source>
          <target state="translated">InitialContextFactoryBuilder가 설치되어 있으면 초기 컨텍스트를 만들기위한 팩토리를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="190c966c8992a3839001e7e1af1d2b89e9457c04" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context. Otherwise, the class specified in the &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; environment property is used. Note that an initial context factory (an object that implements the InitialContextFactory interface) must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">InitialContextFactoryBuilder가 설치된 경우 초기 컨텍스트를 작성하기위한 팩토리를 작성하는 데 사용됩니다. 그렇지 않으면 &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; 환경 특성에 가 사용됩니다. 초기 컨텍스트 팩토리 (InitialContextFactory 인터페이스를 구현하는 객체)는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="98657208ee304eaeabe25e126ff14f176c167883" translate="yes" xml:space="preserve">
          <source>If an MBean implements the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, then it is not added to the class loader repository. The class &lt;a href=&quot;privatemlet&quot;&gt;&lt;code&gt;PrivateMLet&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;code&gt;MLet&lt;/code&gt; that implements &lt;code&gt;PrivateClassLoader&lt;/code&gt;.</source>
          <target state="translated">MBean가 &lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 , 클래스 로더 저장소에 추가되지 않습니다. 클래스 &lt;a href=&quot;privatemlet&quot;&gt; &lt;code&gt;PrivateMLet&lt;/code&gt; 를는&lt;/a&gt; 의 서브 클래스 &lt;code&gt;MLet&lt;/code&gt; 를 그 구현의 &lt;code&gt;PrivateClassLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7dbdf0d0215e39ffb9e056dc435071a7e3d1afd" translate="yes" xml:space="preserve">
          <source>If an ObjectName is not a pattern, it must contain at least one key with its associated value.</source>
          <target state="translated">ObjectName이 패턴이 아닌 경우 연관된 값을 가진 하나 이상의 키를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="3170aa0e22af44ef0aa7402074972e3d2fb9806f" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=rmi_guide&quot;&gt;Java RMI Guide&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">RMI 커넥터 클라이언트 또는 서버가 알지 못하는 클래스의 인스턴스를 피어로부터 수신하고 RMI 연결에 대해 동적 코드 다운로드가 활성화 된 경우 피어가 지정한 코드베이스에서 클래스를 다운로드 할 수 있습니다. &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=rmi_guide&quot;&gt;Java RMI 가이드에서는 이에&lt;/a&gt; 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="58773dafdf455bae89181c8eface9c51e941a81b" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=rmi_guide&quot;&gt;Java RMI Guide&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">RMI 커넥터 클라이언트 또는 서버가 자신이 모르는 클래스의 인스턴스를 피어로부터 수신하고 RMI 연결에 대해 동적 코드 다운로드가 활성화 된 경우 피어가 지정한 코드베이스에서 클래스를 다운로드 할 수 있습니다. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=rmi_guide&quot;&gt;Java RMI 가이드에서는 이에&lt;/a&gt; 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0bc3775989ff9a0fa2129381bf0e75ba0c93374" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. The article &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Dynamic code downloading using Java RMI&lt;/em&gt;&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">RMI 커넥터 클라이언트 또는 서버가 자신의 피어에서 알 수없는 클래스의 인스턴스를 수신하고 RMI 연결에 대해 동적 코드 다운로드가 활성화 된 경우 피어가 지정한 코드베이스에서 클래스를 다운로드 할 수 있습니다. &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Java RMI를 사용한 동적 코드 다운로드&lt;/em&gt;&lt;/a&gt; 기사&lt;em&gt;&lt;/em&gt; 에서이를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="08988225aef79e54029028850710dc91fcab9d17" translate="yes" xml:space="preserve">
          <source>If an action has already been registered for the receiving container, with the same charCode and the same modifiers, &lt;code&gt;anAction&lt;/code&gt; will replace the action.</source>
          <target state="translated">동일한 charCode 및 동일한 수정자를 사용하여 수신 컨테이너에 대한 조치가 이미 등록 된 경우 &lt;code&gt;anAction&lt;/code&gt; 이 조치를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="7baff14a90d603c3ca1182261c5d5d4493ea8f8d" translate="yes" xml:space="preserve">
          <source>If an action is not registered, an exception stack trace is printed to standard error.</source>
          <target state="translated">조치가 등록되지 않은 경우 예외 스택 추적이 표준 오류로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="04d753d52266244d553b5ee79ecbe1175044fb7f" translate="yes" xml:space="preserve">
          <source>If an address does not have any associated segment, it is said to be &lt;em&gt;unchecked&lt;/em&gt;. Unchecked memory addresses do not feature known spatial or temporal bounds; as such, attempting a memory dereference operation using an unchecked memory address will result in a runtime exception. Unchecked addresses can be obtained e.g. by calling the &lt;a href=&quot;#ofLong(long)&quot;&gt;&lt;code&gt;ofLong(long)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주소에 연관된 세그먼트가없는 경우 &lt;em&gt;선택 취소 된&lt;/em&gt; 것으로 간주 됩니다. 확인되지 않은 메모리 주소에는 알려진 공간 또는 시간 경계가 없습니다. 따라서 확인되지 않은 메모리 주소를 사용하여 메모리 역 참조 작업을 시도하면 런타임 예외가 발생합니다. 체크되지 않은 주소는 예를 들어 &lt;a href=&quot;#ofLong(long)&quot;&gt; &lt;code&gt;ofLong(long)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac4ee4e3be7f792562359278f4f57ab7faea7f57" translate="yes" xml:space="preserve">
          <source>If an alpha sample is present, it corresponds the last index.</source>
          <target state="translated">알파 샘플이있는 경우 마지막 인덱스에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9c4c5268bcffbf9c0c5b98ecb4ed28911043818e" translate="yes" xml:space="preserve">
          <source>If an annotation of type</source>
          <target state="translated">유형이 주석 인 경우</target>
        </trans-unit>
        <trans-unit id="9df83510632408ed0d5232c4209c863ed75fc2b2" translate="yes" xml:space="preserve">
          <source>If an annotation returned by a method in this interface contains (directly or indirectly) a &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;-valued member referring to a class that is not accessible in this VM, attempting to read the class by calling the relevant Class-returning method on the returned annotation will result in a &lt;a href=&quot;../typenotpresentexception&quot;&gt;&lt;code&gt;TypeNotPresentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스의 메소드에 의해 리턴 된 주석 이이 VM에서 액세스 할 수없는 클래스를 참조 하는 &lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 값 멤버를 (직접 또는 간접적으로) 포함하는 경우, 리턴 된 주석 에서 관련 클래스 리턴 메소드를 호출하여 클래스를 읽으려고합니다. &lt;a href=&quot;../typenotpresentexception&quot;&gt; &lt;code&gt;TypeNotPresentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0227ca62999d931b56d6f6658a6e345f41f26f21" translate="yes" xml:space="preserve">
          <source>If an annotation type</source>
          <target state="translated">주석 유형 인 경우</target>
        </trans-unit>
        <trans-unit id="ed99bca3e6f592b88e87557055d253e0c0b22f1a" translate="yes" xml:space="preserve">
          <source>If an application caches method handles for broad sharing, it should use &lt;code&gt;publicLookup()&lt;/code&gt; to create them. If there is a lookup of &lt;code&gt;Class.forName&lt;/code&gt;, it will fail, and the application must take appropriate action in that case. It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible.</source>
          <target state="translated">응용 프로그램이 광범위한 공유를 위해 메서드 핸들을 캐시하는 경우 &lt;code&gt;publicLookup()&lt;/code&gt; 을 사용하여 만들어야합니다. 조회가있는 경우 &lt;code&gt;Class.forName&lt;/code&gt; 실패하고 애플리케이션은 적절한 조치를 취해야합니다. 아마도 부트 스트랩 메서드를 호출하는 동안 나중에 조회하면 호출자의 특정 ID를 통합하여 메서드에 액세스 할 수있게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517b0d95c98c17f7230f34f43d8c177b399282df" translate="yes" xml:space="preserve">
          <source>If an application does &lt;em&gt;not&lt;/em&gt; register its own custom &lt;code&gt;ErrorListener&lt;/code&gt;, the default &lt;code&gt;ErrorListener&lt;/code&gt; is used which reports all warnings and errors to &lt;code&gt;System.err&lt;/code&gt; and does not throw any &lt;code&gt;Exception&lt;/code&gt;s. Applications are &lt;em&gt;strongly&lt;/em&gt; encouraged to register and use &lt;code&gt;ErrorListener&lt;/code&gt;s that insure proper behavior for warnings and errors.</source>
          <target state="translated">응용 프로그램이 자체 사용자 정의 &lt;code&gt;ErrorListener&lt;/code&gt; 를 등록 하지 &lt;em&gt;않으면&lt;/em&gt; 모든 경고 및 오류를 &lt;code&gt;System.err&lt;/code&gt; 에보 고하고 &lt;code&gt;Exception&lt;/code&gt; 을 발생 시키지 않는 기본 &lt;code&gt;ErrorListener&lt;/code&gt; 가 사용됩니다 . 응용 프로그램은 경고 및 오류에 대한 적절한 동작을 보장 하는 &lt;code&gt;ErrorListener&lt;/code&gt; 를 등록하고 사용 &lt;em&gt;하는&lt;/em&gt; 것이 좋습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="607a97ae51696a6fd94c9201bbd08e82f31c7cfe" translate="yes" xml:space="preserve">
          <source>If an application does not provide a listener, the &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;transformer&quot;&gt;&lt;code&gt;Transformer&lt;/code&gt;&lt;/a&gt; shall create one on its own. The default &lt;code&gt;ErrorListener&lt;/code&gt; may take no action for warnings and recoverable errors, and allow the transformation to continue. However, the &lt;code&gt;TransformerFactory&lt;/code&gt; or &lt;code&gt;Transformer&lt;/code&gt; may still throw &lt;code&gt;TransformerException&lt;/code&gt; when it decides it can not continue processing.</source>
          <target state="translated">애플리케이션이 리스너를 제공하지 않는 경우 &lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;transformer&quot;&gt; &lt;code&gt;Transformer&lt;/code&gt; &lt;/a&gt; 는 자체적 으로 리스너를 생성해야합니다. 기본 &lt;code&gt;ErrorListener&lt;/code&gt; 는 경고 및 복구 가능한 오류에 대해 조치를 취하지 않고 변환을 계속할 수 있습니다. 그러나 &lt;code&gt;TransformerFactory&lt;/code&gt; 또는 &lt;code&gt;Transformer&lt;/code&gt; 는 처리를 계속할 수 없다고 결정할 때 여전히 &lt;code&gt;TransformerException&lt;/code&gt; 을 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dbacd8fdd96aa697bee57950998d0a96108abc1" translate="yes" xml:space="preserve">
          <source>If an application or a system is internationalized and provides localized resources for multiple locales, it sometimes needs to find one or more locales (or language tags) which meet each user's specific preferences. Note that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this locale matching documentation.</source>
          <target state="translated">응용 프로그램 또는 시스템이 국제화되어 있고 여러 로캘에 대한 지역화 된 리소스를 제공하는 경우 각 사용자의 특정 기본 설정을 충족하는 하나 이상의 로캘 (또는 언어 태그)을 찾아야하는 경우가 있습니다. 이 로케일 일치 문서에서 &quot;언어 태그&quot;라는 용어는 &quot;로케일&quot;과 상호 교환 적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="95627f13c311b8727d628cb2f5a559e1e571b551" translate="yes" xml:space="preserve">
          <source>If an application wants to perform some action based on a button being pressed and released, it should implement &lt;code&gt;ActionListener&lt;/code&gt; and register the new listener to receive events from this button, by calling the button's &lt;code&gt;addActionListener&lt;/code&gt; method. The application can make use of the button's action command as a messaging protocol.</source>
          <target state="translated">애플리케이션이 버튼을 눌렀다 놓는 것에 따라 어떤 작업을 수행 하려면 버튼의 &lt;code&gt;addActionListener&lt;/code&gt; 메서드를 호출하여 &lt;code&gt;ActionListener&lt;/code&gt; 를 구현 하고이 버튼에서 이벤트를 수신 할 새 리스너를 등록 해야합니다 . 응용 프로그램은 단추의 작업 명령을 메시징 프로토콜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2dd9b01f32a7dbe5dfc9a2ba9f8a990861694b9" translate="yes" xml:space="preserve">
          <source>If an application wants to perform some action based on an item in this list being selected or activated by the user, it should implement &lt;code&gt;ItemListener&lt;/code&gt; or &lt;code&gt;ActionListener&lt;/code&gt; as appropriate and register the new listener to receive events from this list.</source>
          <target state="translated">응용 프로그램이이 목록의 항목이 사용자에 의해 선택되거나 활성화되는 것을 기반으로 일부 작업을 수행하려면 &lt;code&gt;ItemListener&lt;/code&gt; 또는 &lt;code&gt;ActionListener&lt;/code&gt; 를 적절하게 구현 하고이 목록에서 이벤트를 수신 할 새 리스너를 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c765f1f20083db8a0a74030169afc641514a1ce" translate="yes" xml:space="preserve">
          <source>If an application wants to set the ErrorHandler or EntityResolver for an XMLReader used during a transformation, it should use a URIResolver to return the SAXSource which provides (with getXMLReader) a reference to the XMLReader.</source>
          <target state="translated">애플리케이션이 변환 중에 사용되는 XMLReader에 대해 ErrorHandler 또는 EntityResolver를 설정하려면 URIResolver를 사용하여 XMLReader에 대한 참조를 제공하는 SAXSource를 반환해야합니다 (getXMLReader 포함).</target>
        </trans-unit>
        <trans-unit id="f6d7860179acd56276c79c3590549cb4c6e64204" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the corresponding new format is used for all such format elements. If an argument index is not used for any format element in the pattern string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the formats for argument indices less than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</source>
          <target state="translated">패턴 문자열에서 둘 이상의 형식 요소에 인수 색인이 사용되면 해당하는 모든 형식 요소에 해당하는 새 형식이 사용됩니다. 패턴 문자열의 형식 요소에 인수 색인이 사용되지 않으면 해당하는 새 형식이 무시됩니다. 필요한 것보다 적은 형식이 제공되는 경우 인수 색인의 형식 만 &lt;code&gt;newFormats.length&lt;/code&gt; 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="1f72387046823cf7698e1a0b6d176b89054ec4a7" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the format used for the last such format element is returned in the array. If an argument index is not used for any format element in the pattern string, then null is returned in the array.</source>
          <target state="translated">패턴 문자열에서 둘 이상의 형식 요소에 인수 색인이 사용되면 마지막 형식 요소에 사용 된 형식이 배열에 리턴됩니다. 패턴 문자열의 형식 요소에 인수 색인이 사용되지 않으면 배열에서 널이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="60e1dcd8583415c6d79ee79aff279d16dea818d7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere.</source>
          <target state="translated">이미 다른 곳에서 사용중인 속성을 추가하려는 경우.</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">네임 스페이스와 관련하여 잘못된 방식으로 객체를 만들거나 변경하려는 경우</target>
        </trans-unit>
        <trans-unit id="24724cffc57a37c811ffa42d73d239354e6db8a1" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed.</source>
          <target state="translated">수정이 허용되지 않는 개체를 수정하려는 경우.</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">기본 개체의 유형을 수정하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="2a0bd5db21e0237af0e5f242375953f6a02b04f7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a &lt;code&gt;Node&lt;/code&gt; in a context where it does not exist.</source>
          <target state="translated">존재하지 않는 컨텍스트에서 &lt;code&gt;Node&lt;/code&gt; 를 참조하려는 경우 .</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">사용할 수 없거나 더 이상 사용할 수없는 객체를 사용하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="a897beabf4b5ef8fb695d39602ed612135397241" translate="yes" xml:space="preserve">
          <source>If an attempt was made to load a document, or an XML Fragment, using &lt;code&gt;LSParser&lt;/code&gt; and the processing has been stopped.</source>
          <target state="translated">&lt;code&gt;LSParser&lt;/code&gt; 를 사용하여 문서 또는 XML 단편을로드하려고 시도 하고 처리가 중지 된 경우.</target>
        </trans-unit>
        <trans-unit id="e5cccc7a6e78ca84d0519ccae83f8865c3f31cba" translate="yes" xml:space="preserve">
          <source>If an attempt was made to serialize a &lt;code&gt;Node&lt;/code&gt; using &lt;code&gt;LSSerializer&lt;/code&gt; and the processing has been stopped.</source>
          <target state="translated">&lt;code&gt;LSSerializer&lt;/code&gt; 를 사용하여 &lt;code&gt;Node&lt;/code&gt; 직렬화를 시도 하고 처리가 중지 된 경우.</target>
        </trans-unit>
        <trans-unit id="bd454c7aa8c21821eb903a4d4d4438d54e9d0c75" translate="yes" xml:space="preserve">
          <source>If an attribute class extends &lt;code&gt;EnumSyntax&lt;/code&gt;, and the value of the attribute is an IPP-compatible value, the attribute's &lt;code&gt;toString&lt;/code&gt; method returns the IPP string representation of the attribute value, such as &quot;processing-stopped&quot; for the &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; attribute. However, because the &lt;code&gt;EnumSyntax&lt;/code&gt; class is extensible, vendors can define their own attribute values. If an attribute uses the &lt;code&gt;EnumSyntax&lt;/code&gt; class and is set to one of these vendor-defined values then the &lt;code&gt;toString&lt;/code&gt; method will not return the IPP string representation of the value.</source>
          <target state="translated">속성 클래스가 &lt;code&gt;EnumSyntax&lt;/code&gt; 를 확장 하고 속성 값이 IPP 호환 값인 경우 속성의 &lt;code&gt;toString&lt;/code&gt; 메소드는 &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; 속성에 대한 &quot;processing-stopped&quot;와 같은 속성 값의 IPP 문자열 표시를 리턴 합니다. 그러나 &lt;code&gt;EnumSyntax&lt;/code&gt; 클래스는 확장 가능 하므로 공급 업체가 고유 한 속성 값을 정의 할 수 있습니다. 속성이 &lt;code&gt;EnumSyntax&lt;/code&gt; 클래스를 사용하고 이러한 공급 업체 정의 값 중 하나로 설정된 경우 &lt;code&gt;toString&lt;/code&gt; 메소드는 의 IPP 문자열 표시를 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4623c2eee5d41a35f73f5f405c0c8600ff819521" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as &lt;code&gt;PrintRequestAttribute&lt;/code&gt;, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">속성이 &lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;PrintRequestAttribute&lt;/code&gt; 를 구현하는 경우 클라이언트는 해당 문서에만 속하는 작업 설정을 지정하기 위해 &lt;code&gt;Doc&lt;/code&gt; 속성 집합에 속성을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2271d961817d69ed166f3999b4fca55a2a3bfd1" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as PrintRequestAttribute, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;}'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">속성이 &lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt; 및 PrintRequestAttribute를 구현하는 경우 클라이언트는 속성을 &lt;code&gt;Doc&lt;/code&gt; 해당 문서에만 관련된 작업 설정을 지정하기 위해 Doc 의 속성 세트에 .</target>
        </trans-unit>
        <trans-unit id="8553a6030a41f0e392620a86588d848a2d5646af" translate="yes" xml:space="preserve">
          <source>If an attribute of the given name already exists then its value is replaced. If the attribute does not exist then it is created. If it implementation specific if a test to check for the existence of the attribute and the creation of attribute are atomic with respect to other file system activities.</source>
          <target state="translated">주어진 이름의 속성이 이미 존재하면 그 값이 대체됩니다. 속성이 존재하지 않으면 작성됩니다. 속성의 존재와 속성의 생성을 검사하는 테스트가 다른 파일 시스템 활동과 관련하여 원자적인 경우 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8a01717d98769d18078234570b7f435e850c09eb" translate="yes" xml:space="preserve">
          <source>If an authenticator is set on the HttpContext that owns this exchange, then this method will return the &lt;a href=&quot;httpprincipal&quot;&gt;&lt;code&gt;HttpPrincipal&lt;/code&gt;&lt;/a&gt; that represents the authenticated user for this HttpExchange.</source>
          <target state="translated">이 교환을 소유하는 HttpContext에 인증자가 설정된 경우이 메서드는 이 HttpExchange에 대해 인증 된 사용자를 나타내는 &lt;a href=&quot;httpprincipal&quot;&gt; &lt;code&gt;HttpPrincipal&lt;/code&gt; &lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="27440a763ede5ab8ba752691c8d7cfa12b2cc574" translate="yes" xml:space="preserve">
          <source>If an authority is given then the string &lt;code&gt;&quot;//&quot;&lt;/code&gt; is appended, followed by the authority. If the authority contains a literal IPv6 address then the address must be enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;). Any character not in the</source>
          <target state="translated">권한이 주어지면 문자열 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 이 추가되고 그 뒤에 권한이옵니다. 기관에 리터럴 IPv6 주소가 포함 된 경우 주소는 대괄호로 묶어야합니다 ( &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; ) . 에없는 모든 문자</target>
        </trans-unit>
        <trans-unit id="6b54c42030a2b2622209db57c79949e15fb60f06" translate="yes" xml:space="preserve">
          <source>If an child element is insert into a parent element, the parent element should report a change. If the child element also had elements inserted into it (grandchildren to the parent) these elements need not report change.</source>
          <target state="translated">하위 요소가 상위 요소에 삽입되는 경우 상위 요소는 변경 사항을보고해야합니다. 자식 요소에도 요소가 삽입 된 경우 (부모의 손자) 이러한 요소는 변경을보고 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="30c03b38fd51437f34d169d8c1845e0f976cba81" translate="yes" xml:space="preserve">
          <source>If an element &lt;code&gt;e&lt;/code&gt; is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of &lt;code&gt;Arrays.toString(e)&lt;/code&gt;. If an element &lt;code&gt;e&lt;/code&gt; is an array of a reference type, it is converted to a string as by invoking this method recursively.</source>
          <target state="translated">요소 &lt;code&gt;e&lt;/code&gt; 가 프리미티브 유형의 배열 인 경우, 적절한 &lt;code&gt;Arrays.toString(e)&lt;/code&gt; 오버로드를 호출하여 문자열로 변환됩니다 . 요소 &lt;code&gt;e&lt;/code&gt; 가 참조 유형의 배열 인 경우,이 메소드를 재귀 적으로 호출하여 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7fadd0956f2848503358e60b1e94c3a6c5020fa1" translate="yes" xml:space="preserve">
          <source>If an element is a path to a directory of modules then each entry in the directory is a packaged module or the top-level directory of an exploded module. It is an error if a directory contains more than one module with the same name. If an element is a path to a directory, and that directory contains a file named &lt;code&gt;module-info.class&lt;/code&gt;, then the directory is treated as an exploded module rather than a directory of modules.</source>
          <target state="translated">요소가 모듈 디렉토리의 경로 인 경우 디렉토리의 각 항목은 패키지 모듈이거나 분해 된 모듈의 최상위 디렉토리입니다. 디렉토리에 동일한 이름의 모듈이 둘 이상 포함되어 있으면 오류입니다. 요소가 디렉토리 경로이고 해당 디렉토리에 &lt;code&gt;module-info.class&lt;/code&gt; 라는 파일이 포함되어 있으면 해당 디렉토리는 모듈 디렉토리가 아닌 확장 된 모듈로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4c8b1aa9c76b0a6c06cd6d1249058d6819f7727d" translate="yes" xml:space="preserve">
          <source>If an element or attribute name has a prefix, but is not bound to any namespace URI, then the prefix will be removed during serialization.</source>
          <target state="translated">요소 또는 속성 이름에 접두사가 있지만 네임 스페이스 URI에 바인딩되지 않은 경우 접두사는 직렬화 중에 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9604ec88c64afb1d9f67cf4516415fedcdca634f" translate="yes" xml:space="preserve">
          <source>If an element or attribute name is bound to a prefix and there is a namespace declaration that binds that prefix to a different URI then that namespace declaration is either removed if the correct mapping is inherited from the parent context of that element, or changed to the namespace URI of the element or attribute using that prefix.</source>
          <target state="translated">요소 또는 속성 이름이 접두사에 바인딩되어 있고 해당 접두사를 다른 URI에 바인딩하는 네임 스페이스 선언이있는 경우 해당 요소의 부모 컨텍스트에서 올바른 매핑이 상속되면 해당 네임 스페이스 선언이 제거되거나 해당 접두사를 사용하는 요소 또는 속성의 네임 스페이스 URI입니다.</target>
        </trans-unit>
        <trans-unit id="c29918c5773fbdbf37d6f7f698f089f0789ff358" translate="yes" xml:space="preserve">
          <source>If an element or attribute name uses a prefix that is bound to a different URI than that inherited from the namespace context of the parent of that element and there is no namespace declaration in the context of the current element then such a namespace declaration is added.</source>
          <target state="translated">요소 또는 특성 이름이 해당 요소의 부모의 네임 스페이스 컨텍스트에서 상속 된 것과 다른 URI에 바인딩 된 접두사를 사용하고 현재 요소의 컨텍스트에 네임 스페이스 선언이없는 경우 이러한 네임 스페이스 선언이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="261e54ff065700a24467a3b37a05bc35f1bc1e0e" translate="yes" xml:space="preserve">
          <source>If an entry already exists for the specified alias, it is overridden.</source>
          <target state="translated">지정된 별명에 대한 항목이 이미 있으면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9f14cb55aec7f7c0b7e951ed92525cdc983689" translate="yes" xml:space="preserve">
          <source>If an error occurs during the initial handshake, this method returns an invalid session object which reports an invalid cipher suite of &quot;SSL_NULL_WITH_NULL_NULL&quot;.</source>
          <target state="translated">초기 핸드 셰이크 중에 오류가 발생하면이 메소드는 유효하지 않은 세션 스위트 &quot;SSL_NULL_WITH_NULL_NULL&quot;을보고하는 유효하지 않은 세션 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff4bf02a9e9b23d87b04df576e60bab4d6f37a68" translate="yes" xml:space="preserve">
          <source>If an error occurs in setting any of the client info properties, a &lt;code&gt;SQLClientInfoException&lt;/code&gt; is thrown. The &lt;code&gt;SQLClientInfoException&lt;/code&gt; contains information indicating which client info properties were not set. The state of the client information is unknown because some databases do not allow multiple client info properties to be set atomically. For those databases, one or more properties may have been set before the error occurred.</source>
          <target state="translated">클라이언트 정보 속성을 설정할 때 오류가 발생하면 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 이 throw됩니다. &lt;code&gt;SQLClientInfoException&lt;/code&gt; 에는,이 클라이언트 정보 속성이 설정되지 않은 있는지를 나타내는 정보가 포함되어 있습니다. 일부 데이터베이스에서는 여러 클라이언트 정보 속성을 원자 적으로 설정할 수 없기 때문에 클라이언트 정보의 상태를 알 수 없습니다. 이러한 데이터베이스의 경우 오류가 발생하기 전에 하나 이상의 속성이 설정되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1773b2b10f572a15df1a83f51dfc4260cdf90a56" translate="yes" xml:space="preserve">
          <source>If an error occurs then the SSL socket is closed and an IOException is thrown. The underlying connection remains intact.</source>
          <target state="translated">오류가 발생하면 SSL 소켓이 닫히고 IOException이 발생합니다. 기본 연결은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0571b6ce6440517f906763cbff3a06c35743d89b" translate="yes" xml:space="preserve">
          <source>If an error occurs while parsing, the caller is notified through the &lt;code&gt;ErrorHandler&lt;/code&gt; instance associated with the &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter of the &lt;code&gt;DOMConfiguration&lt;/code&gt;.</source>
          <target state="translated">구문 분석 중에 오류가 발생하면 호출자에게 &lt;code&gt;DOMConfiguration&lt;/code&gt; 의 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt; &quot;매개 변수 와 연관된 &lt;code&gt;ErrorHandler&lt;/code&gt; 인스턴스를 통해 알림을 받습니다.</target>
        </trans-unit>
        <trans-unit id="c6ef064ac38936491ed2c3e376ac7740ad6dc231" translate="yes" xml:space="preserve">
          <source>If an event doesn't have the annotation, then by default the event is enabled.</source>
          <target state="translated">이벤트에 주석이 없으면 기본적으로 이벤트가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6560375df8c26d01983629f3966222dadc471a6f" translate="yes" xml:space="preserve">
          <source>If an event is cancelable, the &lt;code&gt;preventDefault&lt;/code&gt; method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur.</source>
          <target state="translated">이벤트가 취소 할 수있는 경우 &lt;code&gt;preventDefault&lt;/code&gt; 방법은 이벤트가 일반적으로 발생하지 않는 이벤트의 결과로 구현 취한 기본 동작을 의미 취소되어야 함을 의미하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="61a7893cf4ef57d2ac863b712446f1ad303120a8" translate="yes" xml:space="preserve">
          <source>If an event is cancelable, the &lt;code&gt;preventDefault&lt;/code&gt; method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur. If, during any stage of event flow, the &lt;code&gt;preventDefault&lt;/code&gt; method is called the event is canceled. Any default action associated with the event will not occur. Calling this method for a non-cancelable event has no effect. Once &lt;code&gt;preventDefault&lt;/code&gt; has been called it will remain in effect throughout the remainder of the event's propagation. This method may be used during any stage of event flow.</source>
          <target state="translated">이벤트가 취소 할 수있는 경우 &lt;code&gt;preventDefault&lt;/code&gt; 방법은 이벤트가 일반적으로 발생하지 않는 이벤트의 결과로 구현 취한 기본 동작을 의미 취소되어야 함을 의미하는 데 사용됩니다. 이벤트 흐름 단계에서 &lt;code&gt;preventDefault&lt;/code&gt; 메서드가 호출되면 이벤트가 취소됩니다. 이벤트와 관련된 기본 동작은 발생하지 않습니다. 취소 할 수없는 이벤트에 대해이 메서드를 호출해도 효과가 없습니다. &lt;code&gt;preventDefault&lt;/code&gt; 가 호출 되면 이벤트 전파의 나머지 기간 동안 계속 유효합니다. 이 방법은 이벤트 흐름의 모든 단계에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50c4239d3f5ba08fc26d40f5cf9ea945de22195" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by &lt;code&gt;RemoteRef.invoke&lt;/code&gt; and that exception is a checked exception that is not assignable to any exception in the &lt;code&gt;throws&lt;/code&gt; clause of the method implemented by the &lt;code&gt;proxy&lt;/code&gt;'s class, then that exception is wrapped in an &lt;a href=&quot;../unexpectedexception&quot;&gt;&lt;code&gt;UnexpectedException&lt;/code&gt;&lt;/a&gt; and the wrapped exception is thrown. Otherwise, the exception thrown by &lt;code&gt;invoke&lt;/code&gt; is thrown by this method.</source>
          <target state="translated">&lt;code&gt;RemoteRef.invoke&lt;/code&gt; 에 의해 예외가 발생 하고 해당 예외가 &lt;code&gt;proxy&lt;/code&gt; 클래스에 의해 구현 된 메서드 의 &lt;code&gt;throws&lt;/code&gt; 절 에서 예외에 할당 할 수없는 검사 된 예외 인 경우 해당 예외는 &lt;a href=&quot;../unexpectedexception&quot;&gt; &lt;code&gt;UnexpectedException&lt;/code&gt; &lt;/a&gt; 및 래핑 된 예외로 래핑됩니다. 던져집니다. 그렇지 않으면 &lt;code&gt;invoke&lt;/code&gt; 에 의해 발생 된 예외 가이 메소드에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0469e2eb38e10c985523abc8d2b5541786c72d7d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during an enumeration, the enumeration becomes invalid. Subsequent invocation of any method on that enumeration will yield undefined results.</source>
          <target state="translated">열거 중에 예외가 발생하면 열거가 유효하지 않게됩니다. 해당 열거에서 메소드를 계속 호출하면 정의되지 않은 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b9719db0ece122f09c48cc72299d47645e3e63" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from this method, it is considered to be equivalent of returning &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 메서드에서 예외가 발생하면 &lt;code&gt;true&lt;/code&gt; 를 반환하는 것과 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="baf28062714220f5e512946ca5d9f8fcc778ea9f" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from this method, resulting behavior is undefined.</source>
          <target state="translated">이 메서드에서 예외가 발생하면 결과 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4edf72f63744ff4e52753a8efa7493d7a0576ed0" translate="yes" xml:space="preserve">
          <source>If an exception type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">예외 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 예외 유형이 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="383733cb23b40d1a57028c685e2f09b242e4957b" translate="yes" xml:space="preserve">
          <source>If an exception, &lt;code&gt;E&lt;/code&gt; say, occurs during execution of the bootstrap method, then resolution fails and terminates abnormally. &lt;code&gt;E&lt;/code&gt; is rethrown if the type of &lt;code&gt;E&lt;/code&gt; is &lt;code&gt;Error&lt;/code&gt; or a subclass, otherwise a &lt;code&gt;BootstrapMethodError&lt;/code&gt; that wraps &lt;code&gt;E&lt;/code&gt; is thrown. If this happens, the same error will be thrown for all subsequent attempts to execute the &lt;code&gt;invokedynamic&lt;/code&gt; instruction or load the dynamically-computed constant.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 는 부트 스트랩 메소드 실행 중에 예외 가 발생하면 해결이 실패하고 비정상적으로 종료됩니다. &lt;code&gt;E&lt;/code&gt; 는 유형 경우 던져 준다 &lt;code&gt;E&lt;/code&gt; 가 인 &lt;code&gt;Error&lt;/code&gt; 또는 서브 클래스는 달리, &lt;code&gt;BootstrapMethodError&lt;/code&gt; 랩 &lt;code&gt;E&lt;/code&gt; 가 발생합니다. 이 경우 &lt;code&gt;invokedynamic&lt;/code&gt; 명령어 를 실행 하거나 동적으로 계산 된 상수를로드 하려는 모든 후속 시도에 대해 동일한 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="daaa77166dccaba4fc56b68f0c67338ce9025815" translate="yes" xml:space="preserve">
          <source>If an existing &lt;code&gt;Processor&lt;/code&gt; object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</source>
          <target state="translated">기존 &lt;code&gt;Processor&lt;/code&gt; 개체를 사용하지 않는 경우 프로세서 인스턴스를 만들기 위해 도구는 프로세서 클래스의 인수 없음 생성자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e6c975a8f1f73672a8298c66b4c9a0fbbf3cedc1" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;a href=&quot;httpclient.builder#executor(java.util.concurrent.Executor)&quot;&gt;executor&lt;/a&gt; has not been set for an &lt;code&gt;HttpClient&lt;/code&gt;, and a security manager has been installed, then the default executor will execute asynchronous and dependent tasks in a context that is granted no permissions. Custom &lt;a href=&quot;httprequest.bodypublisher&quot;&gt;request body publishers&lt;/a&gt;, &lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;response body handlers&lt;/a&gt;, &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;response body subscribers&lt;/a&gt;, and &lt;a href=&quot;websocket.listener&quot;&gt;WebSocket Listeners&lt;/a&gt;, if executing operations that require privileges, should do so within an appropriate &lt;a href=&quot;../../../../java.base/java/security/accesscontroller#doPrivileged(java.security.PrivilegedAction)&quot;&gt;privileged context&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HttpClient&lt;/code&gt; 에 대해 명시 적 &lt;a href=&quot;httpclient.builder#executor(java.util.concurrent.Executor)&quot;&gt;실행기&lt;/a&gt; 가 설정되지 않았고 보안 관리자가 설치된 경우 기본 실행기는 권한이 부여되지 않은 컨텍스트에서 비동기 및 종속 작업을 실행합니다. 사용자 지정 &lt;a href=&quot;httprequest.bodypublisher&quot;&gt;요청 본문 게시자&lt;/a&gt; , &lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;응답 본문 처리기&lt;/a&gt; 권한이 필요한 작업을 실행하는 경우 , &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;응답 본문 구독자&lt;/a&gt; 및 &lt;a href=&quot;websocket.listener&quot;&gt;WebSocket Listeners&lt;/a&gt; 는 적절한 &lt;a href=&quot;../../../../java.base/java/security/accesscontroller#doPrivileged(java.security.PrivilegedAction)&quot;&gt;권한이있는 컨텍스트&lt;/a&gt; 내에서 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="334f0a371bfe2e32de25175071515e6114979f87" translate="yes" xml:space="preserve">
          <source>If an implementation does implement this interface, it is expected to understand the specific syntax of the shorthand properties, and apply their semantics; when the &lt;code&gt;margin&lt;/code&gt; property is set, for example, the &lt;code&gt;marginTop&lt;/code&gt;, &lt;code&gt;marginRight&lt;/code&gt;, &lt;code&gt;marginBottom&lt;/code&gt; and &lt;code&gt;marginLeft&lt;/code&gt; properties are actually being set by the underlying implementation.</source>
          <target state="translated">구현에서이 인터페이스를 구현하는 경우 속기 속성의 특정 구문을 이해하고 해당 의미를 적용해야합니다. 때 &lt;code&gt;margin&lt;/code&gt; 속성이 설정되고, 예를 들면, &lt;code&gt;marginTop&lt;/code&gt; , &lt;code&gt;marginRight&lt;/code&gt; , &lt;code&gt;marginBottom&lt;/code&gt; 및 &lt;code&gt;marginLeft&lt;/code&gt; 특성 실제로 기본 구현에 의해 설정되고있다.</target>
        </trans-unit>
        <trans-unit id="7d315c92816e5851e4dc9c39278030e06b4e20d6" translate="yes" xml:space="preserve">
          <source>If an implementation does not support schemas, it should throw OperationNotSupportedException. If an implementation does support schemas, it should define this method to return the appropriate information.</source>
          <target state="translated">구현이 스키마를 지원하지 않으면 OperationNotSupportedException을 발생시켜야합니다. 구현이 스키마를 지원하는 경우 적절한 정보를 리턴하도록이 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4c73fde229aaf78d628130cf2dc942c93b26494" translate="yes" xml:space="preserve">
          <source>If an implementation has not been specified with the system property, then the system-default implementation class is instantiated, and the result is returned.</source>
          <target state="translated">시스템 특성으로 구현을 지정하지 않은 경우 시스템 기본 구현 클래스가 인스턴스화되고 결과가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0790bd1055cd2781acb9f390ec8d77d9efcbd487" translate="yes" xml:space="preserve">
          <source>If an implementation of this method returns &lt;code&gt;false&lt;/code&gt;, then the KeyEvent is passed to the next KeyEventDispatcher in the chain, ending with the current KeyboardFocusManager. If an implementation returns &lt;code&gt;true&lt;/code&gt;, the KeyEvent is assumed to have been dispatched (although this need not be the case), and the current KeyboardFocusManager will take no further action with regard to the KeyEvent. In such a case, &lt;code&gt;KeyboardFocusManager.dispatchEvent&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt; as well. If an implementation consumes the KeyEvent, but returns &lt;code&gt;false&lt;/code&gt;, the consumed event will still be passed to the next KeyEventDispatcher in the chain. It is important for developers to check whether the KeyEvent has been consumed before dispatching it to a target. By default, the current KeyboardFocusManager will not dispatch a consumed KeyEvent.</source>
          <target state="translated">이 메서드의 구현이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 KeyEvent는 현재 KeyboardFocusManager로 끝나는 체인의 다음 KeyEventDispatcher로 전달됩니다. 구현이 반환되는 경우 &lt;code&gt;true&lt;/code&gt; 를 하면 KeyEvent가 전달 된 것으로 간주되며 (이럴 필요는 없음) 현재 KeyboardFocusManager는 KeyEvent와 관련하여 추가 작업을 수행하지 않습니다. 이 경우 &lt;code&gt;KeyboardFocusManager.dispatchEvent&lt;/code&gt; 도 &lt;code&gt;true&lt;/code&gt; 를 반환해야 합니다. 구현에서 KeyEvent를 사용하지만 &lt;code&gt;false&lt;/code&gt; 를 반환하는 경우, 소비 된 이벤트는 여전히 체인의 다음 KeyEventDispatcher로 전달됩니다. 개발자는 KeyEvent를 대상에 전달하기 전에 사용되었는지 여부를 확인하는 것이 중요합니다. 기본적으로 현재 KeyboardFocusManager는 소비 된 KeyEvent를 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e13652b1c7db8e5309427a9d44bc7e8f9963245a" translate="yes" xml:space="preserve">
          <source>If an implementation of this method returns &lt;code&gt;false&lt;/code&gt;, then the KeyEvent is passed to the next KeyEventPostProcessor in the chain, ending with the current KeyboardFocusManager. If an implementation returns &lt;code&gt;true&lt;/code&gt;, the KeyEvent is assumed to have been fully handled (although this need not be the case), and the AWT will take no further action with regard to the KeyEvent. If an implementation consumes the KeyEvent but returns &lt;code&gt;false&lt;/code&gt;, the consumed event will still be passed to the next KeyEventPostProcessor in the chain. It is important for developers to check whether the KeyEvent has been consumed before performing any post-processing of the KeyEvent. By default, the current KeyboardFocusManager will perform no post- processing in response to a consumed KeyEvent.</source>
          <target state="translated">이 메서드의 구현이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 KeyEvent는 현재 KeyboardFocusManager로 끝나는 체인의 다음 KeyEventPostProcessor로 전달됩니다. 구현이 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우 KeyEvent는 완전히 처리 된 것으로 간주되며 (이럴 필요는 없음) AWT는 KeyEvent와 관련하여 추가 조치를 취하지 않습니다. 구현에서 KeyEvent를 사용하지만 &lt;code&gt;false&lt;/code&gt; 를 반환 하는 경우 사용 된 이벤트는 체인의 다음 KeyEventPostProcessor로 계속 전달됩니다. 개발자는 KeyEvent의 사후 처리를 수행하기 전에 KeyEvent가 사용되었는지 확인하는 것이 중요합니다. 기본적으로 현재 KeyboardFocusManager는 소비 된 KeyEvent에 대한 응답으로 사후 처리를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f55248539ebf4b603fcbf731a4a482fec2765dd7" translate="yes" xml:space="preserve">
          <source>If an implementation performs any type of modification or &quot;normalization&quot; of a path, it should never move the coordinates by more than half a pixel in any direction.</source>
          <target state="translated">구현에서 경로의 수정 또는 &quot;정규화&quot;를 수행하는 경우 어떤 방향으로도 좌표를 반 픽셀 이상 이동해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="043b26dca2264b1abb0bfae84593fcda3d702603" translate="yes" xml:space="preserve">
          <source>If an implementation represents a field that can be simplified, or combined with others, then this method must be implemented.</source>
          <target state="translated">구현이 단순화되거나 다른 필드와 결합 될 수있는 필드를 나타내는 경우이 방법을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1d164fb2f90283981eb219956ff98c6a957bd3f" translate="yes" xml:space="preserve">
          <source>If an implementation supports a mechanism to start agents sometime after the VM has started then this attribute specifies the agent class. That is, the class containing the &lt;code&gt;agentmain&lt;/code&gt; method. This attribute is required if it is not present the agent will not be started. Note: this is a class name, not a file name or path.</source>
          <target state="translated">구현이 VM이 시작된 후 에이전트를 시작하는 메커니즘을 지원하는 경우이 속성은 에이전트 클래스를 지정합니다. 즉, &lt;code&gt;agentmain&lt;/code&gt; 이 포함 된 클래스 메서드가 입니다. 이 속성이 없으면 에이전트가 시작되지 않습니다. 참고 : 이것은 파일 이름이나 경로가 아닌 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c11093045a54063bd397d3d34918f97a76bef04b" translate="yes" xml:space="preserve">
          <source>If an implementation supports a mechanism to start an application as an executable JAR then the main manifest may include this attribute to specify the class name of an agent to start before the application &lt;code&gt;main&lt;/code&gt; method is invoked.</source>
          <target state="translated">구현이 애플리케이션을 실행 가능한 JAR로 시작하는 메커니즘을 지원하는 경우 기본 매니페스트에이 속성을 포함하여 애플리케이션 &lt;code&gt;main&lt;/code&gt; 이전에 시작할 에이전트의 클래스 이름을 지정할 수 있습니다. 메서드가 호출 .</target>
        </trans-unit>
        <trans-unit id="c89b3cdaab7f58f456c7aa47faa134eee7f364ef" translate="yes" xml:space="preserve">
          <source>If an init function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the clause's iteration variable type.</source>
          <target state="translated">init 함수가 생략 된 경우 &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;기본값을&lt;/a&gt; 사용하십시오. 경우 절의 반복 변수 유형에 .</target>
        </trans-unit>
        <trans-unit id="3462188196e65e0014ae45d5a7fe6a01be0280ee" translate="yes" xml:space="preserve">
          <source>If an input method provides its own windows, it should make sure at this point that all necessary windows are open and visible.</source>
          <target state="translated">입력 방법이 자체 창을 제공하는 경우이 시점에서 필요한 모든 창이 열려 있고 표시되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf5c43ab6dc0cdfce9e73d966f2af0a3e27508c4" translate="yes" xml:space="preserve">
          <source>If an input method provides its own windows, only windows that relate to the current composition (such as a lookup choice window) should be closed at this point. It is possible that the input method will be immediately activated again for a different client component, and closing and reopening more persistent windows (such as a control panel) would create unnecessary screen flicker. Before an instance of a different input method class is activated, &lt;a href=&quot;#hideWindows()&quot;&gt;&lt;code&gt;hideWindows()&lt;/code&gt;&lt;/a&gt; is called on the current input method.</source>
          <target state="translated">입력 방법이 자체 창을 제공하는 경우 현재 컴포지션과 관련된 창 (예 : 조회 선택 창) 만이 시점에서 닫아야합니다. 다른 클라이언트 구성 요소에 대해 입력 방법이 즉시 다시 활성화 될 수 있으며 더 영구적 인 창 (예 : 제어판)을 닫았다가 다시 열면 불필요한 화면 깜박임이 발생할 수 있습니다. 다른 입력 메서드 클래스의 인스턴스가 활성화되기 전에 현재 입력 메서드에서 &lt;a href=&quot;#hideWindows()&quot;&gt; &lt;code&gt;hideWindows()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0b10ca0277b7493d6ebe1c11b70f79c82379ba" translate="yes" xml:space="preserve">
          <source>If an input stream is open for the current row, a call to the method &lt;code&gt;next&lt;/code&gt; will implicitly close it. A &lt;code&gt;ResultSet&lt;/code&gt; object's warning chain is cleared when a new row is read.</source>
          <target state="translated">현재 행에 대해 입력 스트림이 열려있는 경우 &lt;code&gt;next&lt;/code&gt; 메서드를 호출 하면 암시 적 으로 해당 행 이 닫힙니다. &lt;code&gt;ResultSet&lt;/code&gt; 새로운 행이 읽힐 때, 오브젝트의 경고 체인은 클리어됩니다.</target>
        </trans-unit>
        <trans-unit id="582a161abac221d4fa47ae48f7051334a4e87df5" translate="yes" xml:space="preserve">
          <source>If an input stream is open for the current row, a call to the method &lt;code&gt;previous&lt;/code&gt; will implicitly close it. A &lt;code&gt;ResultSet&lt;/code&gt; object's warning change is cleared when a new row is read.</source>
          <target state="translated">현재 행에 대해 입력 스트림이 열려있는 경우 &lt;code&gt;previous&lt;/code&gt; 메서드를 호출 하면 암시 적으로 닫힙니다. &lt;code&gt;ResultSet&lt;/code&gt; 새로운 행이 읽힐 때, 객체의 경고 변경은 지워집니다.</target>
        </trans-unit>
        <trans-unit id="f303c1f0d6c8117bfe8230a427e47b48a68363b7" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal character is specified, such as in an XML name.</source>
          <target state="translated">XML 이름과 같이 유효하지 않거나 잘못된 문자가 지정된 경우.</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">유효하지 않거나 잘못된 문자열이 지정된 경우</target>
        </trans-unit>
        <trans-unit id="3b30c559fc9c71304701a7f40146dfcf10b6d44b" translate="yes" xml:space="preserve">
          <source>If an object factory builder has been installed, it is used to create a factory for creating the object. Otherwise, the following rules are used to create the object:</source>
          <target state="translated">오브젝트 팩토리 빌더가 설치된 경우 오브젝트 작성을위한 팩토리를 작성하는 데 사용됩니다. 그렇지 않으면 다음 규칙을 사용하여 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4831201808691533c49676c4c6acf9ec77b746a0" translate="yes" xml:space="preserve">
          <source>If an operation that calculates the bounding box of this &lt;code&gt;Polygon&lt;/code&gt; has already been performed, such as &lt;code&gt;getBounds&lt;/code&gt; or &lt;code&gt;contains&lt;/code&gt;, then this method updates the bounding box.</source>
          <target state="translated">이 &lt;code&gt;Polygon&lt;/code&gt; 의 경계 상자를 계산하는 작업 ( 예 : &lt;code&gt;getBounds&lt;/code&gt; 또는 &lt;code&gt;contains&lt;/code&gt; ) 이 이미 수행 된 경우이 메서드는 경계 상자를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="55e5619029a147bf5b114e97cd80de4c090961fa" translate="yes" xml:space="preserve">
          <source>If an option is omitted from the map the default value is used.</source>
          <target state="translated">맵에서 옵션을 생략하면 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8baf09fa7c9f197ad74c665fba2d5cc5c6506ab1" translate="yes" xml:space="preserve">
          <source>If an optional &lt;code&gt;AffineTransform&lt;/code&gt; is specified, the coordinates returned in the iteration are transformed accordingly.</source>
          <target state="translated">선택적 &lt;code&gt;AffineTransform&lt;/code&gt; 이 지정되면 반복에서 반환 된 좌표가 그에 따라 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2b3be881430739dc065ccc4b9432e347d8bc309f" translate="yes" xml:space="preserve">
          <source>If an override is added, then any date that is formatted or parsed will be affected.</source>
          <target state="translated">재정의가 추가되면 형식이 지정되거나 구문 분석 된 날짜가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="255c469340eb5e4421672d0f2a54c086d1b3a334" translate="yes" xml:space="preserve">
          <source>If an override is added, then any instant that is formatted or parsed will be affected.</source>
          <target state="translated">재정의가 추가되면 형식이 지정되거나 구문 분석 된 모든 인스턴트가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="0fbebb5dc8d306792468bfb85d5fadc68fc9bcac" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the method returns the raw offset value of the current date. In Honolulu, for example, its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and this method always returns -36000000 milliseconds (i.e., -10 hours).</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 히스토리 GMT 오프셋 변경을 지원 , 메소드는 현재 날짜의 원시 오프셋 값을 리턴합니다. 예를 들어, 호놀룰루에서는 1947 년에 원시 오프셋이 GMT-10 : 30에서 GMT-10 : 00으로 변경되었으며이 방법은 항상 -36000000 밀리 초 (예 : -10 시간)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a926ad586a71b3f84679e24d71e358a0ff83b65" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the specified GMT offset is set as the latest GMT offset and the difference from the known latest GMT offset value is used to adjust all historical GMT offset values.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 히스토리 GMT 오프셋 변경을 지원하는 경우 지정된 GMT 오프셋이 최신 GMT 오프셋으로 설정되고 알려진 최신 GMT 오프셋 값과의 차이가 모든 히스토리 GMT 오프셋 값을 조정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ceaf11fd23c3b657da62f21ad506f54d009695c" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;#observesDaylightTime()&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 구현 하위 클래스가 과거 및 미래의 일광 절약 시간 일정 변경을 지원하는 경우이 메서드는 미래 예측 일 수 있으며 현재 규칙과 동일하지 않을 수있는 마지막으로 알려진 일광 절약 시간 규칙을 참조합니다. 현재 규칙도 고려해야하는 경우 &lt;a href=&quot;#observesDaylightTime()&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt; 호출을 고려 하세요.</target>
        </trans-unit>
        <trans-unit id="e0ae28c236839ff6f2827de1f4455a2f8e23e12d" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 구현 서브 클래스가 과거 및 미래 일광 절약 시간제 스케줄 변경을 지원 하는 경우 ,이 방법은 미래 예측 일 수 있고 현재 규칙과 동일하지 않을 수있는 마지막으로 알려진 일광 절약 시간제 규칙을 참조합니다. 현재 규칙도 고려해야하는 경우 &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt; 호출을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceae883a33c038a59aa9297cd34719c700a68dfa" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method returns the amount of saving time of the last known Daylight Saving Time rule that can be a future prediction.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 과거 및 미래 일광 절약 시간제 스케줄 변경을 지원 ,이 메소드는 미래 예측이 될 수있는 마지막으로 알려진 일광 절약 시간제 규칙의 절약 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0c1866d41d7ee0ee47390cc53354c5fdd6a734fb" translate="yes" xml:space="preserve">
          <source>If an unexpected exception occurs in an action, it is possible to catch the exception in an error handler. An error handler can be registered using the &lt;a href=&quot;#onError(java.util.function.Consumer)&quot;&gt;&lt;code&gt;onError(Consumer)&lt;/code&gt;&lt;/a&gt; method. If no error handler is registered, the default behavior is to print the exception and its backtrace to the standard error stream.</source>
          <target state="translated">조치에서 예기치 않은 예외가 발생하면 오류 처리기에서 예외를 포착 할 수 있습니다. &lt;a href=&quot;#onError(java.util.function.Consumer)&quot;&gt; &lt;code&gt;onError(Consumer)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 오류 처리기를 등록 할 수 있습니다 . 오류 핸들러가 등록되지 않은 경우 기본 동작은 예외 및 역 추적을 표준 오류 스트림에 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cdd60a91ecf0c51d8f3876be3d469659d44d29f5" translate="yes" xml:space="preserve">
          <source>If an update between a disconnected &lt;code&gt;RowSet&lt;/code&gt; object and a data source violates the original query or the underlying data source constraints, this will result in undefined behavior for all disconnected &lt;code&gt;RowSet&lt;/code&gt; implementations and their designated &lt;code&gt;SyncProvider&lt;/code&gt; implementations. Not defining the behavior when such violations occur offers greater flexibility for a &lt;code&gt;SyncProvider&lt;/code&gt; implementation to determine its own best course of action.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체와 데이터 소스 간의 업데이트가 원래 쿼리 또는 기본 데이터 소스 제약 조건을 위반하는 경우 연결이 끊어진 모든 &lt;code&gt;RowSet&lt;/code&gt; 구현 및 지정된 &lt;code&gt;SyncProvider&lt;/code&gt; 구현에 대해 정의되지 않은 동작이 발생 합니다. 이러한 위반이 발생할 때 동작을 정의하지 않으면 &lt;code&gt;SyncProvider&lt;/code&gt; 구현이 자신의 최선의 작업 과정을 결정 하는 데 더 큰 유연성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e6cdcb6abb3fe6a57aabba3c4945a777923f2bd3" translate="yes" xml:space="preserve">
          <source>If another thread is already waiting at the exchange point then it is resumed for thread scheduling purposes and receives the object passed in by the current thread. The current thread returns immediately, receiving the object passed to the exchange by that other thread.</source>
          <target state="translated">다른 스레드가 교환 지점에서 이미 대기중인 경우 스레드 스케줄링을 위해 재개되고 현재 스레드가 전달한 오브젝트를 수신합니다. 현재 스레드는 다른 스레드가 교환으로 전달한 오브젝트를 수신하여 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="864c1c31a0758e674e7daf1e62b8414fbaaecf21" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in a selection operation then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of a selection operation will return immediately unless &lt;a href=&quot;#selectNow()&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#selectNow(java.util.function.Consumer)&quot;&gt;&lt;code&gt;selectNow(Consumer)&lt;/code&gt;&lt;/a&gt; is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent selection operations will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">현재 선택 작업에서 다른 스레드가 차단 된 경우 해당 호출은 즉시 반환됩니다. 현재 진행중인 선택 작업이없는 경우 &lt;a href=&quot;#selectNow()&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#selectNow(java.util.function.Consumer)&quot;&gt; &lt;code&gt;selectNow(Consumer)&lt;/code&gt; &lt;/a&gt; 아니면 다음 선택 작업 호출이 즉시 반환됩니다. 그 동안 가 호출 됩니다. 어떤 경우에도 해당 호출에서 반환 된 값은 0이 아닐 수 있습니다. 그동안이 메서드를 다시 호출하지 않으면 후속 선택 작업이 평소와 같이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="55a602e52f31c6fce149aff8e6c8a2bb72960c45" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in an invocation of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of one of these methods will return immediately unless the &lt;a href=&quot;selector#selectNow--&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; method is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent invocations of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">다른 스레드가 현재 &lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt; 메소드 호출에서 차단 된 경우 해당 호출이 즉시 리턴됩니다. 현재 진행중인 선택 작업이 없으면 그 동안 &lt;a href=&quot;selector#selectNow--&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하지 않으면 이러한 메서드 중 하나를 다음에 호출하면 즉시 반환 됩니다. 어쨌든 해당 호출에 의해 리턴되는 값은 0이 아닐 수 있습니다. &lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt; 의 후속 호출 메소드 이 메소드가 다시 호출되지 않는 한 평소와 같이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="24dce4584d013d177ede8c23a6bf0925338f6147" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes) is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will be thrown the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">모든 경우 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; (또는 파생 된 클래스의 인스턴스)를으로부터 슬로우 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 를&lt;/a&gt; 상기 호출자 &lt;code&gt;newSchema&lt;/code&gt; 있어서 동일한 발생한다 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; 를&lt;/a&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="91666a635abb2638c7825fa9ea881422a3247df9" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the caller of the &lt;code&gt;validate&lt;/code&gt; method will be thrown the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">어떤 경우 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; 를&lt;/a&gt; 에서 슬로우 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 를&lt;/a&gt; 상기 호출자의 &lt;code&gt;validate&lt;/code&gt; 방법은 동일한 발생한다 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="e6031198ebfde35221603864bd5de80044d9f210" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object will be thrown toward the root of the call stack.</source>
          <target state="translated">어떤 경우 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 에서 발생합니다 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 를&lt;/a&gt; , 동일 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 객체는 호출 스택의 루트를 향해 던져 질 것이다.</target>
        </trans-unit>
        <trans-unit id="ce3583ad9e889a8cf74d60ff219db12bf7e3d646" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Node&lt;/code&gt; is inserted somewhere it doesn't belong.</source>
          <target state="translated">어떤 경우 &lt;code&gt;Node&lt;/code&gt; 어딘가에 삽입이 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cec544a5e88401b63adc132ef371ce82ab888d7" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;PropertyChangeListeners&lt;/code&gt; have been registered, the &lt;code&gt;changeSupport&lt;/code&gt; field describes them.</source>
          <target state="translated">어떤 경우 &lt;code&gt;PropertyChangeListeners&lt;/code&gt; 등록되었습니다 &lt;code&gt;changeSupport&lt;/code&gt; 필드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6d4dcb2cdde65186e714c3856839d4722a4381c8" translate="yes" xml:space="preserve">
          <source>If any Subscriber method throws an exception, its subscription is cancelled. If a handler is supplied as a constructor argument, it is invoked before cancellation upon an exception in method &lt;a href=&quot;flow.subscriber#onNext(T)&quot;&gt;&lt;code&gt;onNext&lt;/code&gt;&lt;/a&gt;, but exceptions in methods &lt;a href=&quot;flow.subscriber#onSubscribe(java.util.concurrent.Flow.Subscription)&quot;&gt;&lt;code&gt;onSubscribe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;flow.subscriber#onError(java.lang.Throwable)&quot;&gt;&lt;code&gt;onError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;flow.subscriber#onComplete()&quot;&gt;&lt;code&gt;onComplete&lt;/code&gt;&lt;/a&gt; are not recorded or handled before cancellation. If the supplied Executor throws &lt;a href=&quot;rejectedexecutionexception&quot;&gt;&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/a&gt; (or any other RuntimeException or Error) when attempting to execute a task, or a drop handler throws an exception when processing a dropped item, then the exception is rethrown. In these cases, not all subscribers will have been issued the published item. It is usually good practice to &lt;a href=&quot;#closeExceptionally(java.lang.Throwable)&quot;&gt;&lt;code&gt;closeExceptionally&lt;/code&gt;&lt;/a&gt; in these cases.</source>
          <target state="translated">Subscriber 메서드가 예외를 throw하면 해당 구독이 취소됩니다. 핸들러가 생성자 인수로 제공되는 경우 &lt;a href=&quot;flow.subscriber#onNext(T)&quot;&gt; &lt;code&gt;onNext&lt;/code&gt; &lt;/a&gt; 메서드의 예외가 발생하면 취소되기 전에 호출 되지만 &lt;a href=&quot;flow.subscriber#onSubscribe(java.util.concurrent.Flow.Subscription)&quot;&gt; &lt;code&gt;onSubscribe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;flow.subscriber#onError(java.lang.Throwable)&quot;&gt; &lt;code&gt;onError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;flow.subscriber#onComplete()&quot;&gt; &lt;code&gt;onComplete&lt;/code&gt; &lt;/a&gt; 메서드의 예외는 취소 전에 기록되거나 처리되지 않습니다. 제공된 Executor가 태스크 실행을 시도 할 때 &lt;a href=&quot;rejectedexecutionexception&quot;&gt; &lt;code&gt;RejectedExecutionException&lt;/code&gt; &lt;/a&gt; (또는 기타 RuntimeException 또는 오류)을 발생 시키거나 삭제 된 항목을 처리 할 때 삭제 핸들러가 예외를 발생 시키면 예외가 다시 발생합니다. 이 경우 모든 구독자에게 게시 된 항목이 발급되지는 않습니다. 이러한 경우에는 일반적으로 &lt;a href=&quot;#closeExceptionally(java.lang.Throwable)&quot;&gt; &lt;code&gt;closeExceptionally&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="21b5ebd6273984daf6721915e81fb9ec02d87b85" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="8b8c2ef8a9bb952f18badf3b5ecafae0a465fefa" translate="yes" xml:space="preserve">
          <source>If any attributes are unsupported only because they are in conflict with other attributes then it is at the discretion of the service to select the attribute(s) to be identified as the cause of the conflict.</source>
          <target state="translated">속성이 다른 속성과 충돌하여 지원되지 않는 속성 인 경우 서비스의 재량에 따라 충돌의 원인으로 식별 할 속성을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ebc8985caafe276614f95fc78ffd3e5249f1603" translate="yes" xml:space="preserve">
          <source>If any bits of a particular byte have never been set at the time the byte is flushed to the destination, those bits will be set to 0 automatically.</source>
          <target state="translated">바이트가 대상으로 플러시 될 때 특정 바이트의 비트가 설정되지 않은 경우 해당 비트는 자동으로 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="000b0cb48e2461281a9efe32d05592010817bcfd" translate="yes" xml:space="preserve">
          <source>If any element is a NaN, then the final sum will be NaN.</source>
          <target state="translated">요소가 NaN이면 최종 합계는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="7043446a887039defab2fc7d623983a8ed813ef6" translate="yes" xml:space="preserve">
          <source>If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.</source>
          <target state="translated">이 작업의 실행이 해당 기간보다 오래 걸리면 후속 실행이 늦게 시작될 수 있지만 동시에 실행되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="702be5b9ebfbe3a5f1d1aa77356733e4327d5c79" translate="yes" xml:space="preserve">
          <source>If any keys were added to the cancelled-key set while step (2) was in progress then they are processed as in step (1).</source>
          <target state="translated">단계 (2)가 진행되는 동안 취소 된 키 세트에 키가 추가되면 단계 (1)에서와 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="39449a473dc6d7f957e4a256a3a7386489d76cfc" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;
 lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">임의의 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 또는 &lt;code&gt;createTime&lt;/code&gt; 파라미터 값을 갖는 &lt;code&gt;null&lt;/code&gt; 그 대응하는 타임 스탬프는 변경되지 않는다. 구현시 타임 스탬프 속성 중 일부만 업데이트 할 때 파일 속성의 기존 값을 읽어야 할 수 있습니다. 따라서이 방법은 다른 파일 시스템 작업과 관련하여 원자 적 작업이 아닐 수 있습니다. 기존 값을 읽고 다시 쓰면 정밀도가 손실 될 수도 있습니다. 의 모든 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt; lastAccessTime&lt;/code&gt; 및 &lt;code&gt;createTime&lt;/code&gt; 매개 변수는 &lt;code&gt;null&lt;/code&gt; 이 메소드는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="51f61f6cbbe9d425e171c7d86f0b2ee40a25ba9f" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">임의의 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 또는 &lt;code&gt;createTime&lt;/code&gt; 파라미터 값을 갖는 &lt;code&gt;null&lt;/code&gt; 그 대응하는 타임 스탬프는 변경되지 않는다. 타임 스탬프 속성 중 일부만 업데이트 될 때 구현시 파일 속성의 기존 값을 읽어야 할 수도 있습니다. 결과적으로이 방법은 다른 파일 시스템 작업과 관련하여 원 자성 작업이 아닐 수 있습니다. 기존 값을 읽고 다시 쓰면 정밀도 손실이 발생할 수 있습니다. 의 모든 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 및 &lt;code&gt;createTime&lt;/code&gt; 매개 변수는 &lt;code&gt;null&lt;/code&gt; 이 메소드는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8c0135add7c8b60bb88502e1753b104e3e7777d" translate="yes" xml:space="preserve">
          <source>If any of the CA certificates contain the &lt;code&gt;BasicConstraintsExtension&lt;/code&gt;, the value of the &lt;code&gt;pathLenConstraint&lt;/code&gt; field of the extension overrides the maximum path length parameter whenever the result is a certification path of smaller length.</source>
          <target state="translated">CA 인증서 중 하나에 &lt;code&gt;BasicConstraintsExtension&lt;/code&gt; 이 포함 된 경우 확장 의 &lt;code&gt;pathLenConstraint&lt;/code&gt; 필드 값은 결과가 더 작은 길이의 인증 경로 일 때마다 최대 경로 길이 매개 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="f654f25aabeed51a280aa0d1931bee62f73651f8" translate="yes" xml:space="preserve">
          <source>If any of the above checks is not met, this method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">위의 검사 중 하나라도 충족되지 않으면이 메서드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="fe6e3fb63dc7863f33b7b6e2532bfa71a11dd503" translate="yes" xml:space="preserve">
          <source>If any of the above checks is violated, this method fails with an exception.</source>
          <target state="translated">위의 검사 중 하나라도 위반되면이 메서드는 예외와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2322580274e59c704b7ceb052b845f94fd2c310a" translate="yes" xml:space="preserve">
          <source>If any of the argument keys are not recognized and are not namespace qualified, the property will be ignored and not returned. In other words the behaviour is not orthogonal with &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수 키 중 하나라도 인식되지 않고 네임 스페이스가 한정되지 않은 경우 속성이 무시되고 반환되지 않습니다. 즉, 동작이 &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties&lt;/code&gt; &lt;/a&gt; 와 직교하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="782a50f5eb20d11713521429c1b0847fdaaf876b" translate="yes" xml:space="preserve">
          <source>If any of the following conditions occur in the readability graph, then resolution fails:</source>
          <target state="translated">가독성 그래프에서 다음 조건 중 하나가 발생하면 해결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8a96b6f648f1a586b2a9b7cb064808b149ba531a" translate="yes" xml:space="preserve">
          <source>If any of the following conditions occur, then resolution fails:</source>
          <target state="translated">다음 조건 중 하나가 발생하면 해결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7e865b4e10f0873b268aaea1e6ba64ad4ef091c4" translate="yes" xml:space="preserve">
          <source>If any of the parameter types or return type cannot be described nominally, i.e. &lt;a href=&quot;../class#describeConstable()&quot;&gt;&lt;code&gt;Class::describeConstable&lt;/code&gt;&lt;/a&gt; returns an empty optional for that type, then the method type cannot be described nominally:</source>
          <target state="translated">매개 변수 유형 또는 반환 유형을 명목상으로 설명 할 수없는 경우, 즉 &lt;a href=&quot;../class#describeConstable()&quot;&gt; &lt;code&gt;Class::describeConstable&lt;/code&gt; &lt;/a&gt; 이 해당 유형에 대해 빈 옵션을 반환하면 메소드 유형을 명목상으로 설명 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ec333633e17c9be083cec2c06b962a41326b457" translate="yes" xml:space="preserve">
          <source>If any of the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;s contain optional setting values not supported by this reader (</source>
          <target state="translated">제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에이 리더에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="76839c59491d34773c4207ef0c1d778a11ef3546" translate="yes" xml:space="preserve">
          <source>If any of these conversions proves impossible, fail with either a &lt;code&gt;ClassCastException&lt;/code&gt; if any trailing element cannot be cast to &lt;code&gt;A&lt;/code&gt; or a &lt;code&gt;NullPointerException&lt;/code&gt; if any trailing element is &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is not a reference type.</source>
          <target state="translated">이러한 변환 중 하나가 불가능 증명하는 경우 중 하나와 함께 실패 &lt;code&gt;ClassCastException&lt;/code&gt; 이 후행 요소로 캐스팅 할 수없는 경우 또는 &lt;code&gt;NullPointerException&lt;/code&gt; 이 후행 요소 인 경우, &lt;code&gt;null&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 참조 형식이 아닙니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21a8f6cbf8da0180ca327e40df0d37c1951e9068" translate="yes" xml:space="preserve">
          <source>If any of these restrictions are violated, &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. If the &lt;code&gt;interfaces&lt;/code&gt; array argument or any of its elements are &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">이러한 제한 사항 중 하나라도 위반하면 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 에서 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생 합니다. 는 IF &lt;code&gt;interfaces&lt;/code&gt; 배열 인수 또는 요소 중 하나가 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="ff3b12e4e909401d37518b8a3b2f0f268050f07d" translate="yes" xml:space="preserve">
          <source>If any one of the given (name, filter) pairs cannot be registered, then the operation fails with an exception, and no names or filters are registered.</source>
          <target state="translated">주어진 (이름, 필터) 쌍 중 하나를 등록 할 수 없으면 예외로 작업이 실패하고 이름이나 필터가 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aeed51a14c6f63342415cdd77d994dcbb7bd2135" translate="yes" xml:space="preserve">
          <source>If any recorded value is a NaN, then the final sum will be NaN.</source>
          <target state="translated">기록 된 값이 NaN이면 최종 합계는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="c41f89efd65d6831c5b78321674605fbf8e57d9a" translate="yes" xml:space="preserve">
          <source>If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">스트림 요소가 NaN이거나 합계가 NaN 인 경우 합계는 NaN이됩니다. 부동 소수점 합의 값은 입력 값과 덧셈 연산 순서 모두의 함수입니다. 이 방법의 추가 연산 순서는 계산 결과의 속도와 정확성을 향상시키기 위해 구현 유연성을 허용하도록 의도적으로 정의되지 않았습니다. 특히,이 방법은 보상 된 합산 또는 다른 기술을 사용하여 구현되어 &lt;code&gt;double&lt;/code&gt; 값 의 단순한 합산과 비교하여 수치 합의 오차 한계를 감소시킬 수있다 .</target>
        </trans-unit>
        <trans-unit id="d6e5c13d5caa4d3b73ae2556eecfd7419724c86e" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">대기하는 동안 스레드가 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 다른 모든 대기 스레드는 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt; 을 발생시키고 장벽은 끊어진 상태에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="0366cecb1a7ed3c3842ffb9c2ca86a1363dd9a67" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">기다리는 동안 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 다른 모든 대기 스레드에서 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; 이 발생합니다.&lt;/a&gt; 을 발생시키고 장벽이 중단 된 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="4afdb9645427c72b2b449dab0d6dc64d70f5f7ed" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">이 상태에서 대기중인 스레드가 있으면 깨우기 위해 선택됩니다. 그러면 해당 스레드는 &lt;code&gt;await&lt;/code&gt; 에서 돌아 오기 전에 잠금을 다시 확보해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c78a7fa649adbc90dbb23129fc74d5e1c06006a" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">스레드가이 상태에서 대기중인 경우 모두 깨어납니다. 각 스레드는 &lt;code&gt;await&lt;/code&gt; 에서 복귀하기 전에 잠금을 다시 확보해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6def6409810618378abfde7ccc3db7a4a9969cbb" translate="yes" xml:space="preserve">
          <source>If any updates or modifications have been applied to the JoinRowSet the CachedRowSet returned by the method will not be able to persist it's changes back to the originating rows and tables in the in the datasource. The CachedRowSet instance returned should not contain modification data and it should clear all properties of it's originating SQL statement. An application should reset the SQL statement using the &lt;code&gt;RowSet.setCommand&lt;/code&gt; method.</source>
          <target state="translated">JoinRowSet에 업데이트 나 수정이 적용된 경우 메서드에서 반환 된 CachedRowSet은 데이터 소스의 원래 행과 테이블에 변경 사항을 다시 유지할 수 없습니다. 반환 된 CachedRowSet 인스턴스는 수정 데이터를 포함해서는 안되며 원래 SQL 문의 모든 속성을 지워야합니다. 애플리케이션은 &lt;code&gt;RowSet.setCommand&lt;/code&gt; 메소드를 사용하여 SQL 문을 재설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ad420704ce0b8b6310a781cf438247c5b08c1d6" translate="yes" xml:space="preserve">
          <source>If application-layer protocols are supported by the underlying SSL/TLS implementation, this method configures which values can be negotiated by protocols such as &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">기본 SSL / TLS 구현에서 응용 프로그램 계층 프로토콜을 지원하는 경우이 방법은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt; 과 같은 프로토콜에서 협상 할 수있는 값을 구성합니다. , ALPN (Application Layer Protocol Negotiation) .</target>
        </trans-unit>
        <trans-unit id="3322bc5f2673498ec497fcaeb0d9efa220e8632f" translate="yes" xml:space="preserve">
          <source>If application-layer protocols are supported by the underlying SSL/TLS implementation, this method configures which values can be negotiated by protocols such as &lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">기본 SSL / TLS 구현에서 애플리케이션 계층 프로토콜을 지원하는 경우이 방법은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt; , ALPN (Application Layer Protocol Negotiation) 과 같은 프로토콜에서 협상 할 수있는 값을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="f0d6dca8e18fd60ae506385307a9dc90b88e0396" translate="yes" xml:space="preserve">
          <source>If arbitrary parameter type conversions are required, the method &lt;code&gt;setObject&lt;/code&gt; should be used with a target SQL type.</source>
          <target state="translated">임의의 매개 변수 유형 변환이 필요한 경우 &lt;code&gt;setObject&lt;/code&gt; 메소드를 대상 SQL 유형과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc5b8f67def8251eae02d8e53ae706abfba5145a" translate="yes" xml:space="preserve">
          <source>If argument to this function is null, any properties previously set are removed, and the value will revert to the value defined in the templates object.</source>
          <target state="translated">이 함수에 대한 인수가 null이면 이전에 설정 한 모든 속성이 제거되고 값이 템플릿 개체에 정의 된 값으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="b5244f53177f68a2b3ed5e4985bb324825bd1a66" translate="yes" xml:space="preserve">
          <source>If assistive technology service providers are not specified with a system property this implementation will look in a properties file located as follows:</source>
          <target state="translated">보조 기술 서비스 공급자가 시스템 속성으로 지정되지 않은 경우이 구현은 다음 위치에있는 속성 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="18a3bd0c38bccf34c6827e5596cec04cb57b5219" translate="yes" xml:space="preserve">
          <source>If at least one automatic module is enumerated by this algorithm, then every observable automatic module must be enumerated, regardless of whether any of their names are given by 'requires' directives of explicit module declarations.</source>
          <target state="translated">이 알고리즘에 의해 적어도 하나의 자동 모듈이 열거되는 경우, 명시 적 모듈 선언의 'requires'지시문에 의해 이름이 제공되는지 여부에 관계없이 모든 관찰 가능한 자동 모듈이 열거되어야합니다.</target>
        </trans-unit>
        <trans-unit id="39bc70b09921ff4ffa0b8bd08071b807a4a817ff" translate="yes" xml:space="preserve">
          <source>If at least one proxy interface is in a package that is &lt;em&gt;non-exported&lt;/em&gt; and &lt;em&gt;non-open&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;내보내기&lt;/em&gt; 및 &lt;em&gt;개방되지 &lt;/em&gt;&lt;em&gt;않은&lt;/em&gt; 패키지에 프록시 인터페이스가 하나 이상있는 경우 :</target>
        </trans-unit>
        <trans-unit id="2b0406f18bc56c48dc76b9e9165ced413b0430b2" translate="yes" xml:space="preserve">
          <source>If attachToInputContext is true, the new window will share the input context that corresponds to this input method context, so that events for components in the window are automatically dispatched to the input method. Also, when the window is opened using setVisible(true), the input context will prevent deactivate and activate calls to the input method that might otherwise be caused.</source>
          <target state="translated">attachToInputContext가 true 인 경우 새 창은이 입력 메서드 컨텍스트에 해당하는 입력 컨텍스트를 공유하므로 창의 구성 요소에 대한 이벤트가 자동으로 입력 메서드로 전달됩니다. 또한 setVisible (true)를 사용하여 창이 열리면 입력 컨텍스트는 다른 방법으로 발생할 수있는 입력 메서드에 대한 호출을 비활성화하고 활성화하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="47fbfc22f0224fd32a90e5910c55321028c1907f" translate="yes" xml:space="preserve">
          <source>If attribute already exists, replaces all existing values with new specified values. If the attribute does not exist, creates it. If no value is specified, deletes all the values of the attribute. Removal of the last value will remove the attribute if the attribute is required to have at least one value. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">속성이 이미 존재하는 경우 기존의 모든 값을 지정된 새 값으로 바꿉니다. 속성이 존재하지 않으면 작성합니다. 값을 지정하지 않으면 속성의 모든 값을 삭제합니다. 속성에 하나 이상의 값이 필요한 경우 마지막 값을 제거하면 속성이 제거됩니다. 단일 값 특성에 둘 이상의 값을 추가하려고하면 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="a71ec53a572d41f56b8978727aaa4319a3583553" translate="yes" xml:space="preserve">
          <source>If attribute does not exist, create the attribute. The resulting attribute has a union of the specified value set and the prior value set. Adding an attribute with no value will throw &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; if the attribute must have at least one value. For a single-valued attribute where that attribute already exists, throws &lt;code&gt;AttributeInUseException&lt;/code&gt;. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">속성이 존재하지 않으면 속성을 작성하십시오. 결과 속성에는 지정된 값 세트와 이전 값 세트의 합집합이 있습니다. 값이없는 속성을 추가하면 속성에 하나 이상의 값이 있어야하는 경우 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생합니다. 해당 속성이 이미 존재하는 단일 값 속성의 경우 &lt;code&gt;AttributeInUseException&lt;/code&gt; 을 발생 시킵니다. 단일 값 속성에 둘 이상의 값을 추가하려고 시도하면 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f3d3f8aee9c476b735dd96255aa064b6dd2f681b" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../../java.base/java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">인증이 성공하면 다음 인증 된 &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt; 관련으로 채워 &lt;a href=&quot;../../../../java.base/java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt; 반환됩니다. 그런 다음 주어진 주체 집합을 기반으로 권한 부여 확인이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3989b3dfcf79c0772b368fc99263d6921c534321" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">인증이 성공하면 연관된 &lt;a href=&quot;../../../java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt; 채워진 인증 된 주제가 리턴됩니다. 그런 다음 지정된 프린시 펄 세트를 기반으로 권한 확인이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="656e2a66175d25267b8bfdd6e344b28552a242bb" translate="yes" xml:space="preserve">
          <source>If auto-size is &lt;code&gt;false&lt;/code&gt;, and the image size doesn't match the tray icon space, the image is painted as-is inside that space &amp;mdash; if larger than the allocated space, it will be cropped.</source>
          <target state="translated">auto-size가 &lt;code&gt;false&lt;/code&gt; 이고 이미지 크기가 트레이 아이콘 공간과 일치하지 않으면 해당 공간 내부에있는 그대로 이미지가 그려집니다. 할당 된 공간보다 크면 잘립니다.</target>
        </trans-unit>
        <trans-unit id="291b41936e512575859370f076451751c340db33" translate="yes" xml:space="preserve">
          <source>If auto-size is &lt;code&gt;true&lt;/code&gt;, the image is stretched or shrunk to fit the tray icon space.</source>
          <target state="translated">자동 크기가 &lt;code&gt;true&lt;/code&gt; 인 경우 이미지가 트레이 아이콘 공간에 맞게 늘어나거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="384a750120cc655c818a55ff4a92437e6d8b5336" translate="yes" xml:space="preserve">
          <source>If automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL.</source>
          <target state="translated">자동 리디렉션이 활성화되어 있고이 요청이 다른 대상으로 리디렉션되면 호출자에게 리디렉션 된 호스트 / URL에 연결할 수있는 권한도 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e1a72e75cda6642170c4e7a072c7c777581c7f64" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">두 &lt;code&gt;Path&lt;/code&gt; 객체가 모두 &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt; 이 메서드는 파일이 있는지 확인하지 않고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 두 &lt;code&gt;Path&lt;/code&gt; 개체가 다른 공급자와 연결되어있는 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면이 메서드는 두 &lt;code&gt;Path&lt;/code&gt; 개체가 동일한 파일을 찾는 지 확인 하고 구현에 따라 두 파일을 모두 열거 나 액세스해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="214c67c3b5c1b48a5612e6002691988064bf0ec4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">두 &lt;code&gt;Path&lt;/code&gt; 객체가 &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt; 이 메서드는 파일이 있는지 확인하지 않고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 두 &lt;code&gt;Path&lt;/code&gt; 객체가 서로 다른 공급자와 연결되어 있으면 이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면이 메소드는 두 &lt;code&gt;Path&lt;/code&gt; 객체가 동일한 파일을 찾는 지 확인 하고 구현에 따라 두 파일을 열거 나 액세스해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4547af366065ff735c348a2ae9741324e8b7ac" translate="yes" xml:space="preserve">
          <source>If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power of the second argument if that result can in fact be represented exactly as a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">두 인수가 모두 정수인 경우 결과는 실제로 &lt;code&gt;double&lt;/code&gt; 인수로 거듭 제곱 할 수있는 경우 첫 번째 인수를 두 번째 인수의 거듭 제곱으로 올린 수학적 결과와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9e16fe4a0bb9164db40801221f5bd4724181b86e" translate="yes" xml:space="preserve">
          <source>If both arguments are negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -3*</source>
          <target state="translated">두 인수가 모두 음의 무한대이면 결과는 -3 *에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="bfd7882093d9bf21c1a62a7634c6a186d1b60176" translate="yes" xml:space="preserve">
          <source>If both arguments are positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">두 인수가 모두 양의 무한대이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="fc50ec0abca10e371c02173b94982f3dab4ec295" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, &lt;code&gt;direction&lt;/code&gt; is returned unchanged (as implied by the requirement of returning the second argument if the arguments compare as equal).</source>
          <target state="translated">두 인수 모두 0 &lt;code&gt;direction&lt;/code&gt; 부호 가 지정된 경우 방향 이 변경되지 않은 상태로 리턴됩니다 (인수가 동일한 것으로 비교되는 경우 두 번째 인수를 리턴해야 함을 의미 함).</target>
        </trans-unit>
        <trans-unit id="1ae942765abc7210f5202cbe952dc04cbb521ee9" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, a value equivalent to &lt;code&gt;direction&lt;/code&gt; is returned.</source>
          <target state="translated">두 인수 모두 0으로 부호가 지정된 경우 &lt;code&gt;direction&lt;/code&gt; 에 해당하는 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="70f5cab03df99b6ce504b587920dfb5e98d8aa1e" translate="yes" xml:space="preserve">
          <source>If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports.</source>
          <target state="translated">두 권한 구성 요소가 모두 서버 기반 인 경우 URI는 사용자 정보 구성 요소에 따라 정렬됩니다. 이러한 구성 요소가 동일하면 URI는 호스트의 순서에 따라 대소 문자를 구분하지 않고 정렬됩니다. 호스트가 동일하면 포트 순서에 따라 URI가 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="6f5d44c367ff5b5081fe504e77935fe0c93a1c15" translate="yes" xml:space="preserve">
          <source>If both date and time were parsed and either an offset or zone is present, the field &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; is created. If an offset was parsed then the offset will be combined with the &lt;code&gt;LocalDateTime&lt;/code&gt; to form the instant, with any zone ignored. If a &lt;code&gt;ZoneId&lt;/code&gt; was parsed without an offset then the zone will be combined with the &lt;code&gt;LocalDateTime&lt;/code&gt; to form the instant using the rules of &lt;a href=&quot;../chrono/chronolocaldatetime#atZone(java.time.ZoneId)&quot;&gt;&lt;code&gt;ChronoLocalDateTime.atZone(ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">날짜와 시간이 모두 구문 분석되고 오프셋 또는 영역이있는 경우 &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt; 필드 가 생성됩니다. 오프셋이 구문 분석 된 경우 오프셋은 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 결합되어 인스턴트를 형성하며 모든 영역은 무시됩니다. &lt;code&gt;ZoneId&lt;/code&gt; 가 오프셋없이 구문 분석 된 경우 영역은 &lt;a href=&quot;../chrono/chronolocaldatetime#atZone(java.time.ZoneId)&quot;&gt; &lt;code&gt;ChronoLocalDateTime.atZone(ZoneId)&lt;/code&gt; &lt;/a&gt; 규칙을 사용하여 순간을 형성하기 위해 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a0b7a5fda83b5b4e68fb0e1c58f9d3e3a0f17bf" translate="yes" xml:space="preserve">
          <source>If both functions are omitted, there is no iteration variable for the corresponding clause (&lt;code&gt;void&lt;/code&gt; is used as the type to indicate that). If one of them is omitted, the other's return type defines the clause's iteration variable type. If both are given, the common return type (they must be identical) defines the clause's iteration variable type.</source>
          <target state="translated">두 함수를 모두 생략하면 해당 절에 대한 반복 변수가 없습니다 ( &lt;code&gt;void&lt;/code&gt; 가이 를 나타내는 유형으로 사용됨). 그중 하나가 생략되면 다른 반환 유형이 절의 반복 변수 유형을 정의합니다. 둘 다 제공되는 경우 공통 반환 유형 (동일해야 함)이 절의 반복 변수 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="35daff90f12a3fdfb2ee7aaec5156a628122493a" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;' '&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">두 경우 &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;' '&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="77fe9618329cbe1c02136a891b425c89e9010bfc" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">두 경우 &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="86fead13194ade589a2825bc28cba12789046f04" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 플래그가 둘 다 제공되면 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37322522f6007d5f007c17ebbe89695f06d7d158" translate="yes" xml:space="preserve">
          <source>If both the PrincipalClass and &quot;PrincipalName&quot; are &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">PrincipalClass 및 &quot;PrincipalName&quot;이 모두 &quot;*&quot;이면 모든 &lt;code&gt;Subject&lt;/code&gt; 가 소유 한 지정된 신임 정보에 대한 액세스 권한이 부여됩니다 .</target>
        </trans-unit>
        <trans-unit id="905c92d5f8cc252cd790d5c0e9c59aa390231cea" translate="yes" xml:space="preserve">
          <source>If both the icon and text properties are set, this property defines the space between them.</source>
          <target state="translated">아이콘 및 텍스트 속성이 모두 설정된 경우이 속성은 둘 사이의 공간을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7f1f59b1990a9778560b4bab37a8896d7e2ca6a4" translate="yes" xml:space="preserve">
          <source>If both the language and country fields are missing, this function will return the empty string, even if the variant, script, or extensions field is present (you can't have a locale with just a variant, the variant must accompany a well-formed language or country code).</source>
          <target state="translated">언어 및 국가 필드가 모두 누락 된 경우 변형, 스크립트 또는 확장 필드가있는 경우에도이 함수는 빈 문자열을 반환합니다 (변형 만 포함하는 로캘을 가질 수없는 경우 변형은 형성된 언어 또는 국가 코드).</target>
        </trans-unit>
        <trans-unit id="198c8792365f76a0effc383dff9d0f2e3f4c671c" translate="yes" xml:space="preserve">
          <source>If button 1 is pressed, this is implemented to request focus on the associated text component, and to set the caret position.</source>
          <target state="translated">버튼 1을 누르면 연관된 텍스트 구성 요소에 포커스를 요청하고 캐럿 위치를 설정하기 위해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1c5cd838d41d438b8c0b687719a88a74c90d50" translate="yes" xml:space="preserve">
          <source>If button 1 is pressed, this is implemented to request focus on the associated text component, and to set the caret position. If the shift key is held down, the caret will be moved, potentially resulting in a selection, otherwise the caret position will be set to the new location. If the component is not enabled, there will be no request for focus.</source>
          <target state="translated">버튼 1을 누르면 연관된 텍스트 구성 요소에 포커스를 요청하고 캐럿 위치를 설정하기 위해 구현됩니다. Shift 키를 누르고 있으면 캐럿이 이동되어 잠재적으로 선택이되고 그렇지 않으면 캐럿 위치가 새 위치로 설정됩니다. 구성 요소가 활성화되지 않은 경우 포커스 요청이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f923d1532c20f84a25813e955834f5127ccc56bb" translate="yes" xml:space="preserve">
          <source>If c is a JRootPane descendant return its JRootPane ancestor.</source>
          <target state="translated">c가 JRootPane 자손이면 JRootPane 조상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4941c81aaff08fa305d979d6a292103fdf2015a" translate="yes" xml:space="preserve">
          <source>If c is a JRootPane descendant return its JRootPane ancestor. If c is a RootPaneContainer then return its JRootPane.</source>
          <target state="translated">c가 JRootPane 자손이면 JRootPane 조상을 반환합니다. c가 RootPaneContainer이면 JRootPane을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="297ea4154bf357de478f2a9da3045f4e48159d4d" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 풀에서 작동하는 ForkJoinTask에 의해 호출되면 &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt; 와 동일합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="3383616e30ed133f8b457a9e998c8762f65d5b51" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;#isQuiescent()&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">이 풀에서 작동하는 ForkJoinTask에 의해 호출되면 &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 그렇지 않으면이 풀이 &lt;a href=&quot;#isQuiescent()&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt; 될 때까지 대기 및 / 또는 작업 수행 지원을 시도합니다. 되거나 표시된 제한 시간이 경과 .</target>
        </trans-unit>
        <trans-unit id="f17a471a0efa20dccdfd9df73789528ef03ee4cd" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">이 풀에서 작동하는 ForkJoinTask에 의해 호출되면 &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 그렇지 않으면,이 풀이 &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt; 이거나 지정된 시간 종료가 경과 할 때까지 작업 수행을 대기 및 / 또는 지원하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5c8be13a39c3ce6b65d510654f24b14ebdee6bb3" translate="yes" xml:space="preserve">
          <source>If called on a connection that sets the same header multiple times with possibly different values, only the last value is returned.</source>
          <target state="translated">다른 값으로 동일한 헤더를 여러 번 설정하는 연결에서 호출 된 경우 마지막 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c482125ee1539de1724656d21516fd3060b7e464" translate="yes" xml:space="preserve">
          <source>If cipher suites have been set via &lt;code&gt;setEnabledCipherSuites&lt;/code&gt; then they are enabled before the TLS handshake begins.</source>
          <target state="translated">&lt;code&gt;setEnabledCipherSuites&lt;/code&gt; 를 통해 암호 스위트가 설정된 경우 TLS 핸드 셰이크가 시작되기 전에 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="0722074a59b34b3ba484f8bc879b29bc05ad8807" translate="yes" xml:space="preserve">
          <source>If client code has explicitly set the focusability of a Component by either overriding &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; or &lt;code&gt;Component.isFocusable()&lt;/code&gt;, or by calling &lt;code&gt;Component.setFocusable()&lt;/code&gt;, then a DefaultFocusTraversalPolicy behaves exactly like a ContainerOrderFocusTraversalPolicy. If, however, the Component is relying on default focusability, then a DefaultFocusTraversalPolicy will reject all Components with non-focusable peers. This is the default FocusTraversalPolicy for all AWT Containers.</source>
          <target state="translated">클라이언트 코드가 명시 적 중 하나를 대체하여 구성 요소의 포커스 특성을 설정 한 경우 &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; 또는 &lt;code&gt;Component.isFocusable()&lt;/code&gt; , 또는 호출하여 &lt;code&gt;Component.setFocusable()&lt;/code&gt; , 후 정확히 ContainerOrderFocusTraversalPolicy가 같은 DefaultFocusTraversalPolicy의 동작합니다. 그러나 구성 요소가 기본 초점 기능에 의존하는 경우 DefaultFocusTraversalPolicy는 초점을 맞출 수없는 피어가있는 모든 구성 요소를 거부합니다. 이는 모든 AWT 컨테이너에 대한 기본 FocusTraversalPolicy입니다.</target>
        </trans-unit>
        <trans-unit id="6e53a4db1482395c02ce01ebbf19081343f35a43" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 생성되는 경우 해당 예외는이 메서드에서 throw되지 않습니다. &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; &lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="aa5def33651e6193aa37639feee2e1bacd4151be" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 발생하면이 메소드에서 해당 예외가 발생하지 않습니다. &lt;a href=&quot;../jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 을&lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="239b3d190809a5bb14183b924e8a7fef0e270a8a" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; with type &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt;&lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 발생하면이 메소드에서 해당 예외가 발생하지 않습니다. &lt;a href=&quot;jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; &lt;/a&gt; 유형 &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt; &lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt; 을&lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="e50776b9b1e158d35a0ee5b01de8d5ed7f3a4764" translate="yes" xml:space="preserve">
          <source>If concurrency support is desired, there are the following additional implications. The code path for any DocumentListener implementation and any UndoListener implementation must be threadsafe, and not access the component lock if trying to be safe from deadlocks. The &lt;code&gt;repaint&lt;/code&gt; and &lt;code&gt;revalidate&lt;/code&gt; methods on JComponent are safe.</source>
          <target state="translated">동시성 지원이 필요한 경우 다음과 같은 추가 의미가 있습니다. DocumentListener 구현 및 UndoListener 구현에 대한 코드 경로는 스레드로부터 안전해야하며 교착 상태로부터 보호하려는 경우 구성 요소 잠금에 액세스하지 않아야합니다. JComponent 의 &lt;code&gt;repaint&lt;/code&gt; 및 &lt;code&gt;revalidate&lt;/code&gt; 메서드는 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6cc58710f7a52a62031b39086a811bf5c62f9be6" translate="yes" xml:space="preserve">
          <source>If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.</source>
          <target state="translated">corePoolSize 이상의 스레드가 실행중인 경우 실행자는 항상 새 스레드를 추가하는 대신 요청 큐를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="cb543f07d153ad84e16f6614709ff0723e83f00b" translate="yes" xml:space="preserve">
          <source>If currencyTimeLimit is &amp;gt; 0, then the new value for the attribute is cached in the attribute descriptor's 'value' field and the 'lastUpdatedTimeStamp' field is set to the current time stamp.</source>
          <target state="translated">currencyTimeLimit이&amp;gt; 0이면 속성의 새 값이 속성 설명 자의 'value'필드에 캐시되고 'lastUpdatedTimeStamp'필드가 현재 시간 소인으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="318a070d46817b0d3e2904d4f73faabc24bf182e" translate="yes" xml:space="preserve">
          <source>If current thread is interrupted, throw InterruptedException.</source>
          <target state="translated">현재 스레드가 중단 된 경우 InterruptedException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d2831e950ddf2d38fc039e2e83359dc77d52eecc" translate="yes" xml:space="preserve">
          <source>If data has already been sent on the connection, it continues to flow during this handshake. When the handshake completes, this will be signaled with an event. This method is synchronous for the initial handshake on a connection and returns when the negotiated handshake is complete. Some protocols may not support multiple handshakes on an existing socket and may throw an IOException.</source>
          <target state="translated">연결에서 데이터가 이미 전송 된 경우이 핸드 셰이크 동안 데이터가 계속 흐릅니다. 핸드 셰이크가 완료되면 이벤트가 표시됩니다. 이 메소드는 연결의 초기 핸드 셰이크와 동기화되며 협상 된 핸드 셰이크가 완료되면 리턴합니다. 일부 프로토콜은 기존 소켓에서 다중 핸드 셰이크를 지원하지 않을 수 있으며 IOException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9eaed7fbd77713f034b874df556fc6a3657252" translate="yes" xml:space="preserve">
          <source>If data is specified for a &lt;code&gt;Node&lt;/code&gt; which does not support data.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 대한 데이터가 지정된 경우 지원하지 않는 .</target>
        </trans-unit>
        <trans-unit id="a23edc5313c1114129c0451e0f085c188db85181" translate="yes" xml:space="preserve">
          <source>If different docs have different bindings specified, then only two values of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; make sense, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">다른 문서에 서로 다른 바인딩이 지정되어 있으면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의&lt;/a&gt; 두 값만 의미가 있으며 다른 값을 지정하면 작업이 제출 될 때 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6a5c3e077d48f57da30ae30c448c6f813a923be7" translate="yes" xml:space="preserve">
          <source>If different docs have different sheet collations specified, then only one value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; is permitted, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">다른 문서에 다른 시트 데이터 정렬이 지정된 경우 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값은 하나만 허용되며 다른 값이 지정된 경우 작업을 제출하면 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4cc730ea4ab4177fe6780dd6b3762cbb0dc9f71f" translate="yes" xml:space="preserve">
          <source>If disabled, only the name and class of the object is returned. If enabled, the object will be returned.</source>
          <target state="translated">비활성화하면 개체의 이름과 클래스 만 반환됩니다. 활성화하면 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="768caddc9c01e6493ed6902aeea52fa3f4bd3950" translate="yes" xml:space="preserve">
          <source>If dragger is not null it is messaged with completeDrag.</source>
          <target state="translated">dragger가 null이 아닌 경우 completeDrag 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ee0a7ef7d597d86c66ef2b09b41b3a0ba000faa" translate="yes" xml:space="preserve">
          <source>If dragger is not null it is messaged with continueDrag.</source>
          <target state="translated">dragger가 null이 아닌 경우 continueDrag로 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1db332f67d0fafd5b3b4396fdcc2262e8b0c8b" translate="yes" xml:space="preserve">
          <source>If dump on exit is not set, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">종료시 덤프가 설정되지 않은 경우 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="db742d57b076cafc55a417d3693f22f0799621fd" translate="yes" xml:space="preserve">
          <source>If dynamic layout is currently inactive then Containers re-layout their components when resizing is completed. As a result the &lt;code&gt;Component.validate()&lt;/code&gt; method will be invoked only once per resize. If dynamic layout is currently active then Containers re-layout their components on every native resize event and the &lt;code&gt;validate()&lt;/code&gt; method will be invoked each time. The OS/WM support can be queried using the getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) method. This property will reflect the platform capability but is not sufficient to tell if it is presently enabled.</source>
          <target state="translated">동적 레이아웃이 현재 비활성화 된 경우 컨테이너는 크기 조정이 완료 될 때 구성 요소를 다시 레이아웃합니다. 결과적으로 &lt;code&gt;Component.validate()&lt;/code&gt; 메서드는 크기 조정 당 한 번만 호출됩니다. 동적 레이아웃이 현재 활성화 된 경우 컨테이너는 모든 기본 크기 조정 이벤트에서 구성 요소를 다시 레이아웃하고 &lt;code&gt;validate()&lt;/code&gt; 메서드가 매번 호출됩니다. OS / WM 지원은 getDesktopProperty ( &quot;awt.dynamicLayoutSupported&quot;) 메서드를 사용하여 쿼리 할 수 ​​있습니다. 이 속성은 플랫폼 기능을 반영하지만 현재 활성화되어 있는지 여부를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c6f6022b3d9e0a350f4a712d1847c54f77b4d41" translate="yes" xml:space="preserve">
          <source>If editing, the &lt;code&gt;Component&lt;/code&gt; that is handling the editing.</source>
          <target state="translated">편집하는 경우 편집을 처리하는 &lt;code&gt;Component&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f896ef7bc7275d3c393aa1c9ea95576d1ef92625" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than 0, the result will have the dimensions of the other &lt;code&gt;Rectangle&lt;/code&gt;. If both &lt;code&gt;Rectangle&lt;/code&gt;s have at least one dimension less than 0, the result will have at least one dimension less than 0.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 이 0보다 작은 차원을 갖는 경우 결과는 다른 &lt;code&gt;Rectangle&lt;/code&gt; 의 차원을 갖습니다 . 모두 &lt;code&gt;Rectangle&lt;/code&gt; 경우 0보다 작은 차원이 하나 이상 결과는 0보다 작은 차원이 하나 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="39bac83a50271cce4e40efc5165cbf9b9a9d7c02" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. If only one has a dimension less than zero, then the result will be a copy of the other &lt;code&gt;Rectangle&lt;/code&gt;. If both have dimension less than zero, then the result will have at least one dimension less than zero.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 중 하나에 0보다 작은 치수가 있으면 &lt;a href=&quot;#NonExistent&quot;&gt;존재하지 않는&lt;/a&gt; 직사각형에 대한 규칙이 적용됩니다. 하나의 차원이 0보다 작은 경우 결과는 다른 &lt;code&gt;Rectangle&lt;/code&gt; 의 복사본이 됩니다. 둘 다 0보다 작은 차원이 있으면 결과에 0보다 작은 차원이 하나 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="76142416fc4a8b368750309700f44557ecfd75c6" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has one or both dimensions equal to 0, the result along those axes with 0 dimensions will be equivalent to the results obtained by adding the corresponding origin coordinate to the result rectangle along that axis, similar to the operation of the &lt;a href=&quot;#add(java.awt.Point)&quot;&gt;&lt;code&gt;add(Point)&lt;/code&gt;&lt;/a&gt; method, but contribute no further dimension beyond that.</source>
          <target state="translated">어느 경우 &lt;code&gt;Rectangle&lt;/code&gt; 을 가지고 또는 두 차원 모두가 0, 0 크기와 그 축에 따른 결과는 대응 기원의 동작과 유사한 그 축에 따라 결과 직사각형의 좌표를 가산 한 결과에 해당 할 것이다 &lt;a href=&quot;#add(java.awt.Point)&quot;&gt; &lt;code&gt;add(Point)&lt;/code&gt; &lt;/a&gt; 방법이지만 그 이상의 차원은 기여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e4a2225fea7b35153360c5ca3721807756a8d75" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.</source>
          <target state="translated">어느 경우 &lt;code&gt;elem&lt;/code&gt; 또는 &lt;code&gt;htmlText&lt;/code&gt; 매개 변수가 &lt;code&gt;null&lt;/code&gt; , 변경은 문서에 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b1071c4cdf25b92ce3f411ba460944872014a99" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;fixedCellWidth&lt;/code&gt; or &lt;code&gt;fixedCellHeight&lt;/code&gt; haven't been specified, heuristics are used. If the model is empty, the width is the &lt;code&gt;fixedCellWidth&lt;/code&gt;, if greater than &lt;code&gt;0&lt;/code&gt;, or a hard-coded value of &lt;code&gt;256&lt;/code&gt;. The height is the &lt;code&gt;fixedCellHeight&lt;/code&gt; multiplied by &lt;code&gt;visibleRowCount&lt;/code&gt;, if &lt;code&gt;fixedCellHeight&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;, otherwise it is a hard-coded value of &lt;code&gt;16&lt;/code&gt; multiplied by &lt;code&gt;visibleRowCount&lt;/code&gt;.</source>
          <target state="translated">어느 경우 &lt;code&gt;fixedCellWidth&lt;/code&gt; 또는 &lt;code&gt;fixedCellHeight&lt;/code&gt; 프로퍼티가 지정되지 않은, 발견 적 방법이 사용된다. 모델이 비어있는 경우 너비는 &lt;code&gt;fixedCellWidth&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; 보다 크면 ) 또는 하드 코딩 된 값 &lt;code&gt;256&lt;/code&gt; 입니다. 높이는 &lt;code&gt;fixedCellHeight&lt;/code&gt; 에 &lt;code&gt;visibleRowCount&lt;/code&gt; 를 곱한 값 이고, &lt;code&gt;fixedCellHeight&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 보다 크면 , 그렇지 않으면 하드 코딩 된 &lt;code&gt;16&lt;/code&gt; 값에 &lt;code&gt;visibleRowCount&lt;/code&gt; 를 곱한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="332d8e7d0f59b9812b7d8680ca5e21ee5e3a7a49" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;sourceXSubsampling&lt;/code&gt; or &lt;code&gt;sourceYSubsampling&lt;/code&gt; is 0 or negative, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">어느 경우 &lt;code&gt;sourceXSubsampling&lt;/code&gt; 또는 &lt;code&gt;sourceYSubsampling&lt;/code&gt; 가 0 또는 음수, &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="10859c24a221b0a1a8f8c2d45e2dd5f29f7ffaa0" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;subsamplingXOffset&lt;/code&gt; or &lt;code&gt;subsamplingYOffset&lt;/code&gt; is negative or greater than or equal to the corresponding period, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">어느 쪽이든 &lt;code&gt;subsamplingXOffset&lt;/code&gt; 또는 &lt;code&gt;subsamplingYOffset&lt;/code&gt; 가 네거티브 이상을 초과하거나 동기 같 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 발생한다.</target>
        </trans-unit>
        <trans-unit id="8c9e3a00ed69f539de04dcde556ef5fedbed9bf1" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is a negative number then a value is substituted to maintain the aspect ratio of the original image dimensions. If both &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are negative, then the original image dimensions are used.</source>
          <target state="translated">어느 경우 &lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 음수 인 다음 값은 원래 화상 크기의 종횡비를 유지하기 위해 치환된다. 두 경우 &lt;code&gt;width&lt;/code&gt; 과 &lt;code&gt;height&lt;/code&gt; 제외하고, 그 원 화상 사이즈가 사용된다.</target>
        </trans-unit>
        <trans-unit id="f1bccf0359c9d2523582443e154621147124c9b2" translate="yes" xml:space="preserve">
          <source>If either argument is NaN and neither argument is infinite, then the result is NaN.</source>
          <target state="translated">인수가 NaN이고 인수가 모두 무한대 인 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="a87ec8779fbe2da84925808f31ac1112c6261d11" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, or the first argument is infinite, or the second argument is positive zero or negative zero, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 첫 번째 인수가 무한하거나 두 번째 인수가 양의 0 또는 음의 0이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="b78f08e2975896437871c452fd60393fe6909b91" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, then the result is NaN.</source>
          <target state="translated">인수 중 하나가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="34eb1a13a1d41fedad71ac94304afaf4d3b30061" translate="yes" xml:space="preserve">
          <source>If either argument is a NaN, then NaN is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1dead44a3b56a54e43e3eaa910e00403c25df167" translate="yes" xml:space="preserve">
          <source>If either argument is infinite, then the result is positive infinity.</source>
          <target state="translated">인수 중 하나가 무한하면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="41bc9309c0f8d33aae679550f8327f3ba41d91bd" translate="yes" xml:space="preserve">
          <source>If either index is &lt;code&gt;-1&lt;/code&gt;, this method does nothing and returns without exception. Otherwise, if either index is less than &lt;code&gt;-1&lt;/code&gt;, an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown.</source>
          <target state="translated">인덱스가 &lt;code&gt;-1&lt;/code&gt; 이면이 메서드는 아무 작업도 수행하지 않고 예외없이 반환합니다. 두 지수 미만이면 그렇지 않으면, &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2a88d05f4fde9c492de3341283adf63bc8f2e9c" translate="yes" xml:space="preserve">
          <source>If either of the destination offsets are negative, the source region is clipped so that its top left will coincide with the top left of the destination image, taking subsampling into account. Then the result is clipped to the destination image on the right and bottom, if one is specified, taking subsampling and destination offsets into account.</source>
          <target state="translated">대상 오프셋 중 하나가 음수이면 소스 영역이 클리핑되어 서브 샘플링을 고려하여 왼쪽 상단이 대상 이미지의 왼쪽 상단과 일치합니다. 그런 다음 서브 샘플링 및 대상 오프셋을 고려하여 지정된 경우 오른쪽과 아래쪽의 대상 이미지에 결과가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="03f21ceb73c687836a6489d537281750ea1dd4dd" translate="yes" xml:space="preserve">
          <source>If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.</source>
          <target state="translated">지정된 배열 중 하나 이상이 하나 이상의 배열 수준을 통해 직접 또는 간접적으로 요소로 포함 된 경우이 메서드의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="180e76f99201ee9fe15021c8ef7f28c26ec9a151" translate="yes" xml:space="preserve">
          <source>If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true.</source>
          <target state="translated">useParentHandlers 특성의 결과 또는 이전 값이 널이 아닌 경우 로거가 존재하거나 해당 로거의 하위가 존재하면 해당 로거가 결과 값으로 업데이트됩니다. useParentHandlers 속성의 값은 구성에 지정된 값입니다. 지정하지 않으면 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="e3db76a27295abd8950cde00cc86a08c8f4f37d6" translate="yes" xml:space="preserve">
          <source>If either the source or destination regions end up having a width or height of 0, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">소스 또는 대상 영역 중 하나의 너비 또는 높이가 0이면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16d93984ca72bf8d13d016fde295c0c3effdeb16" translate="yes" xml:space="preserve">
          <source>If either this URI or the given URI are opaque, or if the scheme and authority components of the two URIs are not identical, or if the path of this URI is not a prefix of the path of the given URI, then the given URI is returned.</source>
          <target state="translated">이 URI 또는 ​​제공된 URI가 불투명하거나 두 URI의 체계 및 권한 구성 요소가 동일하지 않거나이 URI의 경로가 지정된 URI 경로의 접 두부가 아닌 경우 제공된 URI는 다음과 같습니다. 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="9aa050dc79127dc702ac7f7af9f8c09a95bedff5" translate="yes" xml:space="preserve">
          <source>If element and/or attribute names in the same start or empty-element tag are bound to different namespace URIs and are using the same prefix then the element or the first occurring attribute retains the original prefix and the following attributes have their prefixes replaced with a new prefix that is bound to the namespace URIs of those attributes.</source>
          <target state="translated">동일한 시작 또는 빈 요소 태그의 요소 및 / 또는 속성 이름이 서로 다른 네임 스페이스 URI에 바인딩되고 동일한 접두사를 사용하는 경우 요소 또는 첫 번째 발생 속성은 원래 접두사를 유지하고 다음 속성은 접두사가 해당 속성의 네임 스페이스 URI에 바인딩 된 새 접두사.</target>
        </trans-unit>
        <trans-unit id="5f2bce0ea72e2df5a3161327906870e899626cea" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then a &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 파일의 끝이 언제라도 발견되면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ec3c5e0a4dd72da9a56884a1749a8ec51b24003" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 언제라도 파일 끝이 발견되면 &lt;code&gt;EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e02489afb24dcd898ea786f1764d129a6f696e32" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 언제라도 파일 끝이 발견되면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69e5b4feef83c14b8462d2220d828694ae4230e4" translate="yes" xml:space="preserve">
          <source>If end of file is encountered before even one byte can be read, then &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, each byte that is read is converted to type &lt;code&gt;char&lt;/code&gt; by zero-extension. If the character &lt;code&gt;'\n'&lt;/code&gt; is encountered, it is discarded and reading ceases. If the character &lt;code&gt;'\r'&lt;/code&gt; is encountered, it is discarded and, if the following byte converts to the character &lt;code&gt;'\n'&lt;/code&gt;, then that is discarded also; reading then ceases. If end of file is encountered before either of the characters &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\r'&lt;/code&gt; is encountered, reading ceases. Once reading has ceased, a &lt;code&gt;String&lt;/code&gt; is returned that contains all the characters read and not discarded, taken in order. Note that every character in this string will have a value less than &lt;code&gt;\u0100&lt;/code&gt;, that is, &lt;code&gt;(char)256&lt;/code&gt;.</source>
          <target state="translated">1 바이트라도 읽기 전에 파일 끝이 발견되면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 읽은 각 바이트는 0 확장에 의해 &lt;code&gt;char&lt;/code&gt; 유형으로 변환됩니다 . 문자 &lt;code&gt;'\n'&lt;/code&gt; 이 있으면 문자 가 삭제되고 읽기가 중단됩니다. 문자 &lt;code&gt;'\r'&lt;/code&gt; 이 발견 되면 해당 문자 는 버리고 다음 바이트가 문자 &lt;code&gt;'\n'&lt;/code&gt; 변환되면 파기됩니다. 그런 다음 독서가 중단됩니다. 문자 &lt;code&gt;'\n'&lt;/code&gt; 및 &lt;code&gt;'\r'&lt;/code&gt; 중 하나가 발견되기 전에 파일 끝 이 발견되면 읽기가 중단됩니다. 독서가 끝나면 &lt;code&gt;String&lt;/code&gt; 을 읽고 삭제하지 않은 모든 문자를 순서대로 가져 오는을 반환합니다. 이 문자열의 모든 문자는 &lt;code&gt;\u0100&lt;/code&gt; 보다 작은 값 , 즉 &lt;code&gt;(char)256&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="203a2360aef1ee92b807e282408d3018f93d728c" translate="yes" xml:space="preserve">
          <source>If end of stream is reached before the stream is at the desired position, then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">스트림이 원하는 위치에 도달하기 전에 스트림 끝에 도달하면 &lt;code&gt;EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c4bef5ed2f034c6a6bf34fec9b291f4c50c29549" translate="yes" xml:space="preserve">
          <source>If errors occur during the invocation of this method, such as an attempt to update a read-only node or a &lt;code&gt;Node.nodeName&lt;/code&gt; contains an invalid character according to the XML version in use, errors or warnings (&lt;code&gt;DOMError.SEVERITY_ERROR&lt;/code&gt; or &lt;code&gt;DOMError.SEVERITY_WARNING&lt;/code&gt;) will be reported using the &lt;code&gt;DOMErrorHandler&lt;/code&gt; object associated with the &quot;error-handler &quot; parameter. Note this method might also report fatal errors ( &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt;) if an implementation cannot recover from an error.</source>
          <target state="translated">읽기 전용 노드를 업데이트하려는 시도와 &lt;code&gt;Node.nodeName&lt;/code&gt; 메서드를 호출하는 동안 오류가 발생하거나 Node.nodeName 에 사용중인 XML 버전에 따라 잘못된 문자가 포함 된 경우 오류 또는 경고 ( &lt;code&gt;DOMError.SEVERITY_ERROR&lt;/code&gt; 또는 &lt;code&gt;DOMError.SEVERITY_WARNING&lt;/code&gt; ) &quot;error-handler&quot;매개 변수와 연관된 &lt;code&gt;DOMErrorHandler&lt;/code&gt; 객체를 사용하여보고 됩니다. 이 메서드 는 구현이 오류에서 복구 할 수없는 경우 치명적인 오류 ( &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt; )를 보고 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b674afa2ba891dd7a58dfaa94a5d64325a48496" translate="yes" xml:space="preserve">
          <source>If everything fails, &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">모든 것이 실패하면 &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="84787651c093f5940bda88b1a55845848cbc36dc" translate="yes" xml:space="preserve">
          <source>If everything fails, an &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">모든 것이 실패하면 &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ddbf63c0804dc6b273bd6e5b1e8254dbc36ee91" translate="yes" xml:space="preserve">
          <source>If execution environment is out of process, as is the default case, then if the evaluated code causes the execution environment to terminate, this &lt;code&gt;JShell&lt;/code&gt; instance will be closed but the calling process and VM remain valid.</source>
          <target state="translated">기본 사례와 같이 실행 환경이 프로세스를 벗어난 경우 평가 된 코드로 인해 실행 환경이 종료되면이 &lt;code&gt;JShell&lt;/code&gt; 인스턴스는 닫히지 만 호출 프로세스와 VM은 계속 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a3e73ecba896208f50db9710798b46a965a908cf" translate="yes" xml:space="preserve">
          <source>If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.</source>
          <target state="translated">corePoolSize 스레드보다 적은 수의 스레드가 실행중인 경우 실행자는 항상 큐 대신 새 스레드를 추가하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="f250a59034e1c489b9abe228c4a6bad44105503f" translate="yes" xml:space="preserve">
          <source>If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, calling the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method with a &lt;code&gt;FocusEvent&lt;/code&gt; as the argument will result in a call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt; method regardless of the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 에 대해 포커스 이벤트가 활성화 된 경우 &lt;code&gt;FocusEvent&lt;/code&gt; 를 인수로 사용 하여 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;dispatchEvent&lt;/code&gt; 메서드를 호출 하면 현재 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 에 관계없이 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;processFocusEvent&lt;/code&gt; 메서드 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="40fc17409e4ee706dff7b6c91533503275fb1e4d" translate="yes" xml:space="preserve">
          <source>If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines whether or not a focus event should be dispatched to registered &lt;code&gt;FocusListener&lt;/code&gt; objects. If the events are to be dispatched, the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; calls the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method, which results in a call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 에 포커스 이벤트가 활성화 된 경우 현재 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 는 포커스 이벤트를 등록 된 &lt;code&gt;FocusListener&lt;/code&gt; 객체 로 전달해야하는지 여부를 결정합니다 . 이벤트를 전달해야하는 경우 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 는 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;dispatchEvent&lt;/code&gt; 메서드를 호출하여 &lt;code&gt;Component&lt;/code&gt; 의 &lt;code&gt;processFocusEvent&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ca5a8548f3fbffd915bbf435ebb21f7a97c206bb" translate="yes" xml:space="preserve">
          <source>If for the URL's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">URL의 프로토콜 (예 : HTTP 또는 JAR)의 경우 java.lang, java.io, java.util, java.net, 리턴 된 연결은 해당 서브 클래스의 연결입니다. 예를 들어, HTTP의 경우 HttpURLConnection이 리턴되고 JAR의 경우 JarURLConnection이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ecc3cf47c73dc6fc1a7d51257f1c70d39038a258" translate="yes" xml:space="preserve">
          <source>If for the handler's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">처리기 프로토콜 (예 : HTTP 또는 JAR)의 경우 java.lang, java.io, java.util, java.net 패키지 중 하나 또는 해당 하위 패키지 중 하나에 속하는 공용 특수 URLConnection 서브 클래스가 있습니다. 리턴 된 연결은 해당 서브 클래스의 연결입니다. 예를 들어, HTTP의 경우 HttpURLConnection이 리턴되고 JAR의 경우 JarURLConnection이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6acb316f2f02233537ab314b2b515a379c378b40" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the given socket addresses IP address and port number, except that the &lt;code&gt;SocketException&lt;/code&gt; that may be raised is not wrapped in an &lt;code&gt;UncheckedIOException&lt;/code&gt;. Datagrams in the socket's &lt;a href=&quot;standardsocketoptions#SO_RCVBUF&quot;&gt;socket receive buffer&lt;/a&gt;, which have not been &lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt;received&lt;/a&gt; before invoking this method, may be discarded.</source>
          <target state="translated">&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; 가&lt;/a&gt; 주어지면 ,이 메서드 는 지정된 소켓 주소 IP 주소 및 포트 번호로 &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것처럼 동작 합니다. 단, 발생할 수 있는 &lt;code&gt;SocketException&lt;/code&gt; 은 &lt;code&gt;UncheckedIOException&lt;/code&gt; 에 래핑되지 않습니다 . 이 메소드를 호출하기 전에 &lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt;수신&lt;/a&gt; 되지 않은 소켓의 &lt;a href=&quot;standardsocketoptions#SO_RCVBUF&quot;&gt;소켓 수신 버퍼&lt;/a&gt; 에있는 데이터 그램은 폐기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a8a04deb6efc63b4ca14bf4a5640a470b9eb6a3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the given socket addresses IP address and port number.</source>
          <target state="translated">&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; 가&lt;/a&gt; 주어지면 이 메서드 는 지정된 소켓 주소 IP 주소 및 포트 번호로 &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a4abed1287821693f6da736875b1dd20090fd9c3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the the given socket addresses IP address and port number.</source>
          <target state="translated">&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; 가&lt;/a&gt; 제공된 경우 ,이 메소드 는, 지정된 소켓 주소 IP 주소 및 포트 번호로 &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="e516526c9c2357988df1234780c497763164fab1" translate="yes" xml:space="preserve">
          <source>If handshaking fails for any reason, the &lt;code&gt;SSLSocket&lt;/code&gt; is closed, and no further communications can be done.</source>
          <target state="translated">어떤 이유로 든 핸드 셰이 킹에 실패하면 &lt;code&gt;SSLSocket&lt;/code&gt; 이 닫히고 더 이상 통신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a00d8a2054c6cca37fdcf90a95f1f7f1ad5e5f0" translate="yes" xml:space="preserve">
          <source>If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate.</source>
          <target state="translated">후크 또는 콜백 메소드에서 예외가 발생하면 내부 작업자 스레드가 실패하고 갑자기 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2a7481f1636ab9a24c9018af1fcad7f07157bdd" translate="yes" xml:space="preserve">
          <source>If hook, callback, or BlockingQueue methods throw exceptions, internal worker threads may in turn fail, abruptly terminate, and possibly be replaced.</source>
          <target state="translated">후크, 콜백 또는 BlockingQueue 메서드에서 예외가 발생하면 내부 작업자 스레드가 실패하고 갑작스럽게 종료되고 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="085d6508b165d7efeb827d901170784516d5c017" translate="yes" xml:space="preserve">
          <source>If horizon is &lt;code&gt;0&lt;/code&gt;, then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern.</source>
          <target state="translated">수평선이 &lt;code&gt;0&lt;/code&gt; 이면 horizon이 무시되고이 메소드는 입력을 통해 계속해서 지정된 패턴을 경계없이 찾습니다. 이 경우 패턴을 검색하는 모든 입력을 버퍼링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e185e59957de1a2d9502a435e3bf5d9b3e15599e" translate="yes" xml:space="preserve">
          <source>If horizon is negative, then an IllegalArgumentException is thrown.</source>
          <target state="translated">수평선이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c1e650eb5f2174a711da5a09bfcd316b4c0f07f" translate="yes" xml:space="preserve">
          <source>If however, the serialization is not possible because the Java object is not immediately serializable, this class will attempt to serialize all non-static members to permit the object state to be serialized. Static or transient fields cannot be serialized; an attempt to serialize them will result in a &lt;code&gt;SerialException&lt;/code&gt; object being thrown.</source>
          <target state="translated">그러나 Java 객체를 즉시 직렬화 할 수 없기 때문에 직렬화가 불가능한 경우이 클래스는 객체 상태를 직렬화 할 수 있도록 모든 비 정적 멤버를 직렬화하려고 시도합니다. 정적 또는 임시 필드는 직렬화 할 수 없습니다. 직렬화를 시도하면 &lt;code&gt;SerialException&lt;/code&gt; 객체가 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="31e1ede01add4d64dba9a3481e31fdf9753b8a4c" translate="yes" xml:space="preserve">
          <source>If however, the serialization is not possible in the case where the Java object is not immediately serializable, this class will attempt to serialize all non static members to permit the object instance state to be serialized. Static or transient fields cannot be serialized and attempting to do so will result in a &lt;code&gt;SerialException&lt;/code&gt; being thrown.</source>
          <target state="translated">그러나 Java 객체를 즉시 직렬화 할 수없는 경우 직렬화가 불가능한 경우이 클래스는 객체 인스턴스 상태를 직렬화 할 수 있도록 모든 비 정적 멤버를 직렬화하려고 시도합니다. 정적 또는 임시 필드는 직렬화 할 수 없으며 그렇게하면 &lt;code&gt;SerialException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="272ee6aa9e995da35c3e7f8f88e4b02553afd186" translate="yes" xml:space="preserve">
          <source>If i == 0 returns the action description fetched from UIManager.getString(&quot;AbstractButton.clickText&quot;); otherwise returns null.</source>
          <target state="translated">i == 0이면 UIManager.getString ( &quot;AbstractButton.clickText&quot;);에서 가져온 작업 설명을 반환합니다. 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c3c9e4ade0cd42fbb5a5e7d40ca8bfb9569f944c" translate="yes" xml:space="preserve">
          <source>If i == 0 selects this AccessibleJListChild by calling JList.this.setSelectedIndex(indexInParent) and then returns true; otherwise returns false.</source>
          <target state="translated">i == 0이면 JList.this.setSelectedIndex (indexInParent)를 호출하여이 AccessibleJListChild를 선택한 다음 true를 반환합니다. 그렇지 않으면 거짓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c672e7792e737065f944dcb4cec0eb9d5372d1e1" translate="yes" xml:space="preserve">
          <source>If implementing JavaSound on a I3DL2-compliant device:</source>
          <target state="translated">I3DL2 호환 장치에서 JavaSound를 구현하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3fd0a906cb89e2de9c5076d850930cae34f103b9" translate="yes" xml:space="preserve">
          <source>If implementing an unusual calendar system that is not based on years, months and days, or where you want direct control, then the &lt;code&gt;ChronoPeriod&lt;/code&gt; interface must be directly implemented.</source>
          <target state="translated">연도, 월, 일을 기준으로하지 않거나 직접 제어 할 위치가 아닌 비정상적인 달력 시스템을 구현하는 경우 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인터페이스를 직접 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="07b0ad2086ad124aeb2593860505d4dc09bcafc2" translate="yes" xml:space="preserve">
          <source>If implicit and explicit opening and closing are mixed on the same &lt;code&gt;MidiDevice&lt;/code&gt; instance, the following rules apply:</source>
          <target state="translated">암시 적 및 명시 적 개폐가 동일한 &lt;code&gt;MidiDevice&lt;/code&gt; 에서 혼합 된 경우 인스턴스에서 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="58b430e8bf58bb5b6e8fdbf80a0cd30f4538db11" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value.</source>
          <target state="translated">색인 또는 크기가 음수이거나 허용 된 값보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="c635ec7df61e52aeac84e0512f36bd12bd58d35c" translate="yes" xml:space="preserve">
          <source>If inputComponent is non-null, the focus is requested on that, otherwise request focus on the default value</source>
          <target state="translated">inputComponent가 null이 아닌 경우 포커스가 요청되고 그렇지 않으면 기본값에 포커스가 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="1b6c1ac0801d0f32085f65cf19851af72a8b38e1" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">사용 권한이 충분하지 않으면 현재 스레드가 스레드 예약 용도로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="41f0c20f43c3bf64e0efed44e2fb775806ea99b7" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면 현재 스레드가 스레드 예약 용도로 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="0d316920d5718f1bd7a8baa6604a77f96ebb5665" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore and the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">사용 가능한 허용이 충분하지 않은 경우 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다른 스레드 가이 세마포어 에 대한 &lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 방법 중 하나를 호출 하고 현재 스레드가 다음으로 허용을 할당하고 사용 가능한 허용 수가이 요청을 충족 할 때까지 휴면 상태 에 있습니다. .</target>
        </trans-unit>
        <trans-unit id="6392fbf3bc8eb96daeacf7450eb84b4b39a684c9" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면 현재 스레드가 스레드 스케줄링 목적으로 사용 불가능하게되고 다른 스레드 가이 세마포어 에 대한 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 호출 할 때까지 휴면 상태 가됩니다. .</target>
        </trans-unit>
        <trans-unit id="2f81c133b1f0b74c30d4d20073c4db1886f54e67" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt; and the number of available permits is unchanged.</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면이 방법은 값 &lt;code&gt;false&lt;/code&gt; 와 함께 즉시 반환되며 사용 가능한 허용 수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6917340a867ad875b7b2abf8931c9a665a0bbc79" translate="yes" xml:space="preserve">
          <source>If integer math were being used and this value were being composited in &lt;a href=&quot;#SRC&quot;&gt;&lt;code&gt;SRC&lt;/code&gt;&lt;/a&gt; mode with no extra alpha, then the math would indicate that the results were (in integer format):</source>
          <target state="translated">정수 수학이 사용되고이 값이 추가 알파없이 &lt;a href=&quot;#SRC&quot;&gt; &lt;code&gt;SRC&lt;/code&gt; &lt;/a&gt; 모드 에서 합성되는 경우 수학은 결과가 다음과 같음을 나타냅니다 (정수 형식).</target>
        </trans-unit>
        <trans-unit id="3ee886087a23f0ef283d53172b5a86b2108daa86" translate="yes" xml:space="preserve">
          <source>If interrupted while blocked in step 4, throw InterruptedException.</source>
          <target state="translated">4 단계에서 차단 된 동안 인터럽트 된 경우 InterruptedException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3a74fc2cc725f0cf0347bdb572b4ec73b5f5ad65" translate="yes" xml:space="preserve">
          <source>If invokeLater is called from the event dispatching thread -- for example, from a JButton's ActionListener -- the</source>
          <target state="translated">invokeLater가 이벤트 디스패치 스레드 (예 : JButton의 ActionListener)에서 호출되면</target>
        </trans-unit>
        <trans-unit id="8d2bc19f50633c8c0c8e271655bc0f3233284658" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active subgroup in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">이 스레드 그룹에서 모든 활성 하위 그룹을 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;list&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc469862baa4b5e3d18bc2ca8c5358c4773f7d5f" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in the current thread's thread group and its subgroups, the invoker should verify that the returned int value is strictly less than the length of &lt;code&gt;tarray&lt;/code&gt;.</source>
          <target state="translated">현재 스레드의 스레드 그룹 및 해당 하위 그룹에있는 모든 활성 스레드를 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;tarray&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22683bf338326eeebb95e34c255b900a9e0a2f93" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">이 스레드 그룹의 모든 활성 스레드를 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;list&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="c685c0ba10c68c8f1f3a8c193feb8d700f179cf1" translate="yes" xml:space="preserve">
          <source>If it is false, then expose &lt;b&gt;[member type definition name]&lt;/b&gt; and &lt;b&gt;[member type definition namespace]&lt;/b&gt; properties;</source>
          <target state="translated">false이면 &lt;b&gt;[멤버 유형 정의 이름]&lt;/b&gt; 및 &lt;b&gt;[멤버 유형 정의 네임 스페이스]&lt;/b&gt; 속성 을 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="15b4ed739e5d26e30a9b9b0921ac056bf0af4f7b" translate="yes" xml:space="preserve">
          <source>If it is false, then expose &lt;b&gt;[type definition name]&lt;/b&gt; and &lt;b&gt;[type definition namespace]&lt;/b&gt; properties;</source>
          <target state="translated">false이면 &lt;b&gt;[유형 정의 이름]&lt;/b&gt; 및 &lt;b&gt;[유형 정의 네임 스페이스]&lt;/b&gt; 속성 을 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="54d0672abd6341128d9d7ad099fd323b0c8ef7b4" translate="yes" xml:space="preserve">
          <source>If it is implemented to do so, the &lt;code&gt;SyncProvider&lt;/code&gt; object may also create a &lt;code&gt;SyncResolver&lt;/code&gt; object and either initialize the &lt;code&gt;SyncProviderException&lt;/code&gt; object with it at construction time or set it with the &lt;code&gt;SyncProvider&lt;/code&gt; object at a later time.</source>
          <target state="translated">그렇게하도록 구현 된 경우 &lt;code&gt;SyncProvider&lt;/code&gt; 개체는 &lt;code&gt;SyncResolver&lt;/code&gt; 개체를 만들고 생성시 &lt;code&gt;SyncProviderException&lt;/code&gt; 개체를 초기화 하거나 나중에 &lt;code&gt;SyncProvider&lt;/code&gt; 개체로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e7088330e477594f46099a50c9ebf8a9c61981" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">&lt;a href=&quot;#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt; 로 설정 되면 패커는 요소를 재정렬하고 Java 애플리케이션에 대한 유용한 정보가없는 JAR 디렉토리 항목도 제거 할 수 있습니다. (일반적으로 이것은 더 나은 압축을 가능하게합니다.)</target>
        </trans-unit>
        <trans-unit id="a8a140e583fff0cfc9d06bbb68afa76210088042" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;pack200.packer#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">&lt;a href=&quot;pack200.packer#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt; 로 설정 되면 패커는 요소를 재정렬하고 JAR 디렉토리 항목을 제거하여 Java 애플리케이션에 유용한 정보를 제공하지 않습니다. 일반적으로 압축률이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="349c3ce48f2850808153616db77878ba7dc35133" translate="yes" xml:space="preserve">
          <source>If iterables and sets containing &lt;code&gt;null&lt;/code&gt; are passed as arguments to methods in this class, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 포함 된 iterables 및 세트 가이 클래스의 메소드에 인수로 전달되면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b5e36e15c72143d9f79d44bccee481b6c8b7952" translate="yes" xml:space="preserve">
          <source>If key events are enabled for a &lt;code&gt;Component&lt;/code&gt;, the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines whether or not a key event should be dispatched to registered &lt;code&gt;KeyListener&lt;/code&gt; objects. The &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; will not dispatch key events to a &lt;code&gt;Component&lt;/code&gt; that is not the focus owner or is not showing.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 에 키 이벤트가 활성화 된 경우 현재 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 는 등록 된 &lt;code&gt;KeyListener&lt;/code&gt; 객체에 키 이벤트를 전달할지 여부를 결정합니다 . &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; 는 A를 키 이벤트를 전달하지 않습니다 &lt;code&gt;Component&lt;/code&gt; 가 포커스 소유자가 아니거나 표시되지 않도록.</target>
        </trans-unit>
        <trans-unit id="578dfd2269ad5f68f754865852ba3828ba552206" translate="yes" xml:space="preserve">
          <source>If l is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is performed.</source>
          <target state="translated">l이 &lt;code&gt;null&lt;/code&gt; 이면 예외가 발생하지 않고 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f1683e5b5f316b42c49560377be91252becd81d" translate="yes" xml:space="preserve">
          <source>If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is performed.</source>
          <target state="translated">리스너 &lt;code&gt;l&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이면 예외가 발생하지 않고 조치가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7b8214ffef472fc8e7c1e2311b38613b16b1726" translate="yes" xml:space="preserve">
          <source>If listener is already registered, it will be registered again.</source>
          <target state="translated">리스너가 이미 등록되어 있으면 다시 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="0102c4bf84a1e8f5da988caa52f2807997272c61" translate="yes" xml:space="preserve">
          <source>If listener is null, no exception is thrown and no action is performed.</source>
          <target state="translated">listener가 null이면 예외가 발생하지 않고 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f90529506d3a0958fad7a3ecbf1c1171a153e5b" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform and that are in the usual extension directories (installed extensions) are loaded.</source>
          <target state="translated">loader가 &lt;code&gt;null&lt;/code&gt; 인 경우 플랫폼과 함께 번들로 제공되고 일반적인 확장 디렉토리 (설치된 확장)에있는 스크립트 엔진 팩토리가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="6e767135edebb75b3957eb1a33bb637fe33bf252" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform are loaded.</source>
          <target state="translated">loader가 &lt;code&gt;null&lt;/code&gt; 이면 플랫폼과 함께 번들로 제공되는 스크립트 엔진 팩토리가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ee069a1e9967d9348b8218cc73e384bb53741058" translate="yes" xml:space="preserve">
          <source>If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.</source>
          <target state="translated">많은 수의 항목을 &lt;code&gt;Hashtable&lt;/code&gt; 로 만들려면 충분히 큰 용량으로 입력하면 테이블을 확장하는 데 필요한 자동 재해시를 수행하는 것보다 더 효율적으로 항목을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc60d765a093b43a6239eb2d5685c05051e44ee" translate="yes" xml:space="preserve">
          <source>If many mappings are to be stored in a &lt;code&gt;HashMap&lt;/code&gt; instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">많은 매핑을 &lt;code&gt;HashMap&lt;/code&gt; 인스턴스에 저장해야하는 경우 충분한 대용량으로 매핑하면 테이블을 확장하는 데 필요한 자동 재해시를 수행하는 것보다 매핑을보다 효율적으로 저장할 수 있습니다. 동일한 &lt;code&gt;hashCode()&lt;/code&gt; 와 함께 많은 키를 사용 하면 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 키가 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때 영향을 개선하기 위해이 클래스는 키 간 비교 순서를 사용하여 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d3048870d83219010add9711bb4dd7ca3f2a54" translate="yes" xml:space="preserve">
          <source>If module &lt;code&gt;X&lt;/code&gt; exports a package to &lt;code&gt;Y&lt;/code&gt;, and if the runtime &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;X&lt;/code&gt; does not read &lt;code&gt;Y&lt;/code&gt; then target &lt;code&gt;Y&lt;/code&gt; is located as if by invoking &lt;a href=&quot;#findModule(java.lang.String)&quot;&gt;&lt;code&gt;findModule&lt;/code&gt;&lt;/a&gt; to find the module in the layer or its parent layers. If &lt;code&gt;Y&lt;/code&gt; is found then the package is exported to the instance of &lt;code&gt;Y&lt;/code&gt; that was found. If &lt;code&gt;Y&lt;/code&gt; is not found then the qualified export is ignored.</source>
          <target state="translated">모듈 &lt;code&gt;X&lt;/code&gt; 가 패키지를 &lt;code&gt;Y&lt;/code&gt; 로 내보내고 런타임 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;Y&lt;/code&gt; 를 읽지 않으면 &lt;a href=&quot;#findModule(java.lang.String)&quot;&gt; &lt;code&gt;findModule&lt;/code&gt; &lt;/a&gt; 을 호출 하여 레이어 또는 상위 레이어에서 모듈을 찾는 것처럼 대상 &lt;code&gt;Y&lt;/code&gt; 를 찾습니다. 경우 &lt;code&gt;Y&lt;/code&gt; 는 다음 발견 된 패키지의 인스턴스에 수출되고 &lt;code&gt;Y&lt;/code&gt; 발견되었다. 경우 &lt;code&gt;Y&lt;/code&gt; 는 다음을 찾을 수없는 자격을 갖춘 수출은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d390f7b0fed59c2ff1380a1ceb798db4d298ae1b" translate="yes" xml:space="preserve">
          <source>If module &lt;code&gt;X&lt;/code&gt; exports a package to &lt;code&gt;Y&lt;/code&gt;, and if the runtime &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;X&lt;/code&gt; reads &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;Y&lt;/code&gt;, then the package is exported to &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;Y&lt;/code&gt; (which may be in the same layer as &lt;code&gt;X&lt;/code&gt; or a parent layer).</source>
          <target state="translated">모듈 &lt;code&gt;X&lt;/code&gt; 가 패키지를 &lt;code&gt;Y&lt;/code&gt; 로 내보내고 런타임 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Y&lt;/code&gt; 를 읽는 경우 패키지는 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Y&lt;/code&gt; ( &lt;code&gt;X&lt;/code&gt; 또는 상위 계층 과 동일한 계층에있을 수 있음)로 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="403efbf3d99b9a55860af122e7ea1fa369ccd1ea" translate="yes" xml:space="preserve">
          <source>If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats are provided than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt; formats are replaced.</source>
          <target state="translated">패턴 문자열에 필요한 것보다 많은 형식이 제공되면 나머지 형식은 무시됩니다. 필요한 것보다 적은 형식이 제공되면 첫 번째 &lt;code&gt;newFormats.length&lt;/code&gt; 형식 만 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="88fc14eaff46a9dd5b43fbbfdf0127ddfea55823" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegatePublic&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;publicIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;delegatePublic&lt;/code&gt; 항목이 일치하는 경우 일치하는 가장 긴 &lt;code&gt;publicIdStartString&lt;/code&gt; 값이 있는 일치하는 항목 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="59651f5fa4d31880a671cf0ce022bc0fa42ba699" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegatePublic&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;uriStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;delegatePublic&lt;/code&gt; 항목이 일치하면 일치하는 가장 긴 &lt;code&gt;uriStartString&lt;/code&gt; 값이 있는 일치하는 항목 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="297b17bdac784aa0adbfddd9b55d1bbb6d8ed4e3" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegateSystem&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;systemIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;delegateSystem&lt;/code&gt; 항목이 일치하면 일치하는 가장 긴 &lt;code&gt;systemIdStartString&lt;/code&gt; 값이 있는 일치하는 항목 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5f1964f8ab19e3a1d9048d9994e12715e3e82bb8" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;rewriteSystem&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;systemIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;rewriteSystem&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;systemIdStartString&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="493c294f5c18b9360394be2f1230acb929c4efe8" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;rewriteURI&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;uriStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;rewriteURI&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;uriStartString&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f645ec9f2894ffb6e64d13303f47e749823b0e9" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;systemSuffix&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;systemIdSuffix&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;systemSuffix&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;systemIdSuffix&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16b11a7c5339b99b84c48f7fe6a5331cc8851de5" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;uriSuffix&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;uriSuffix&lt;/code&gt; value is returned.</source>
          <target state="translated">둘 이상의 &lt;code&gt;uriSuffix&lt;/code&gt; 항목이 일치하면 정규화 된 &lt;code&gt;uriSuffix&lt;/code&gt; 값이 가장 긴 일치 항목 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f81dba9cec8cf743a82c5f4acc275a929c8964b3" translate="yes" xml:space="preserve">
          <source>If more than one listener terminates with an uncaught error or exception, an implementation may record the additional errors or exceptions as &lt;a href=&quot;../../../../java.base/java/lang/throwable#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed exceptions&lt;/a&gt;.</source>
          <target state="translated">둘 이상의 리스너가 포착되지 않은 오류 또는 예외로 종료되는 경우 구현에서 추가 오류 또는 예외를 &lt;a href=&quot;../../../../java.base/java/lang/throwable#addSuppressed(java.lang.Throwable)&quot;&gt;억제 된 예외&lt;/a&gt; 로 기록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca2bc26c1a10450fbbbc1b4da5d4954e22c3c85b" translate="yes" xml:space="preserve">
          <source>If more than one prefix is currently mapped to the same URI, this method will make an arbitrary selection; if you want all of the prefixes, use the &lt;a href=&quot;#getPrefixes()&quot;&gt;&lt;code&gt;getPrefixes()&lt;/code&gt;&lt;/a&gt; method instead.</source>
          <target state="translated">두 개 이상의 접두사가 현재 동일한 URI에 매핑 된 경우이 메서드는 임의 선택을 수행합니다. 모든 접두사를 원하면 &lt;a href=&quot;#getPrefixes()&quot;&gt; &lt;code&gt;getPrefixes()&lt;/code&gt; &lt;/a&gt; 메서드를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4db95816febda6de7835e87bdeaef107c21d9eea" translate="yes" xml:space="preserve">
          <source>If multiple catalog files are specified through the &lt;code&gt;uris&lt;/code&gt; argument or &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property, the first entry is considered the main catalog, while others are treated as alternative catalogs after those referenced by the &lt;code&gt;nextCatalog&lt;/code&gt; elements in the main catalog.</source>
          <target state="translated">&lt;code&gt;uris&lt;/code&gt; 인수 또는 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 특성을 통해 여러 카탈로그 파일이 지정된 경우 첫 번째 항목은 기본 카탈로그로 간주되고 다른 항목은 기본 카탈로그의 &lt;code&gt;nextCatalog&lt;/code&gt; 요소가 참조하는 항목 이후에 대체 카탈로그로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b42ca8cc8280b3ca185d72fc9765dbc058c02c1" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program.</source>
          <target state="translated">여러 클래스 로더가 서로에 위임하고 동일한 패키지 이름으로 클래스를 정의하고, 하나의 로더의 조회 동작에 의존하는 경우 &lt;code&gt;getPackage&lt;/code&gt; 반환 &lt;code&gt;Package&lt;/code&gt; 부모 로더에서, 다음에 의해 노출 된 속성 &lt;code&gt;Package&lt;/code&gt; 예상되지 않을 수 있습니다로 나머지 프로그램.</target>
        </trans-unit>
        <trans-unit id="f2cf1bf7c92db59422c4dbe0cefb78945b19c3fa" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program. For example, the &lt;code&gt;Package&lt;/code&gt; will only expose annotations from the &lt;code&gt;package-info.class&lt;/code&gt; file defined by the parent loader, even if annotations exist in a &lt;code&gt;package-info.class&lt;/code&gt; file defined by a child loader. A more robust approach is to use the &lt;a href=&quot;#getDefinedPackage(java.lang.String)&quot;&gt;&lt;code&gt;getDefinedPackage(java.lang.String)&lt;/code&gt;&lt;/a&gt; method which returns a &lt;code&gt;Package&lt;/code&gt; for the specified class loader.</source>
          <target state="translated">여러 클래스 로더가 서로에 위임하고 동일한 패키지 이름으로 클래스를 정의하고, 하나의 로더의 조회 동작에 의존하는 경우 &lt;code&gt;getPackage&lt;/code&gt; 반환 &lt;code&gt;Package&lt;/code&gt; 부모 로더에서, 다음에 의해 노출 된 속성 &lt;code&gt;Package&lt;/code&gt; 예상되지 않을 수 있습니다로 나머지 프로그램. 예를 들어, &lt;code&gt;Package&lt;/code&gt; 단지에서 주석을 노출 할 &lt;code&gt;package-info.class&lt;/code&gt; 주석이 존재하는 경우에도, 부모 로더에 의해 정의 된 파일 &lt;code&gt;package-info.class&lt;/code&gt; 아이 로더에 의해 정의 파일. 보다 강력한 접근 방식은 지정된 클래스 로더에 대한 &lt;code&gt;Package&lt;/code&gt; 를 반환하는 &lt;a href=&quot;#getDefinedPackage(java.lang.String)&quot;&gt; &lt;code&gt;getDefinedPackage(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3eff7fa36e61e7e0bac30eb94dfd47ccf1823466" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program. For example, the &lt;code&gt;Package&lt;/code&gt; will only expose annotations from the &lt;code&gt;package-info.class&lt;/code&gt; file defined by the parent loader, even if annotations exist in a &lt;code&gt;package-info.class&lt;/code&gt; file defined by a child loader. A more robust approach is to use the &lt;a href=&quot;classloader#getDefinedPackage(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getDefinedPackage(java.lang.String)&lt;/code&gt;&lt;/a&gt; method which returns a &lt;code&gt;Package&lt;/code&gt; for the specified class loader.</source>
          <target state="translated">여러 클래스 로더가 서로에 위임하고 동일한 패키지 이름으로 클래스를 정의하고, 하나의 로더의 조회 동작에 의존하는 경우 &lt;code&gt;getPackage&lt;/code&gt; 반환 &lt;code&gt;Package&lt;/code&gt; 부모 로더에서, 다음에 의해 노출 된 속성 &lt;code&gt;Package&lt;/code&gt; 예상되지 않을 수 있습니다로 나머지 프로그램. 예를 들어, &lt;code&gt;Package&lt;/code&gt; 단지에서 주석을 노출 할 &lt;code&gt;package-info.class&lt;/code&gt; 주석이 존재하는 경우에도, 부모 로더에 의해 정의 된 파일 &lt;code&gt;package-info.class&lt;/code&gt; 아이 로더에 의해 정의 파일. 보다 강력한 접근 방식은 지정된 클래스 로더에 대해 를 반환하는 &lt;a href=&quot;classloader#getDefinedPackage(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getDefinedPackage(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하는 것 &lt;code&gt;Package&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cee9f9e59ed8b4cfd7dc142950cdc7c34a80861f" translate="yes" xml:space="preserve">
          <source>If multiple collated copies of a document are requested, and the printer cannot natively support this, then the document may be imaged multiple times. Printing will start each copy from the lowest print stream page index page.</source>
          <target state="translated">문서의 한 부씩 인쇄 된 사본이 여러 개 요청되고 프린터가 기본적으로이를 지원할 수없는 경우 문서 이미지가 여러 번 생성 될 수 있습니다. 인쇄는 가장 낮은 인쇄 스트림 페이지 색인 페이지에서 각 사본을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6d13e2f0df7e6d3a17be4e5ef8a9ee6fedfa2e88" translate="yes" xml:space="preserve">
          <source>If multiple events have the same name (for example, the same class is loaded in different class loaders), then all events that match the name are enabled. To enable a specific class, use the &lt;a href=&quot;#enable(java.lang.Class)&quot;&gt;&lt;code&gt;enable(Class)&lt;/code&gt;&lt;/a&gt; method or a &lt;code&gt;String&lt;/code&gt; representation of the event type ID.</source>
          <target state="translated">여러 이벤트의 이름이 같은 경우 (예 : 동일한 클래스가 다른 클래스 로더에로드 됨) 이름과 일치하는 모든 이벤트가 활성화됩니다. 특정 클래스를 활성화하려면 enable &lt;a href=&quot;#enable(java.lang.Class)&quot;&gt; &lt;code&gt;enable(Class)&lt;/code&gt; &lt;/a&gt; 메서드 또는 이벤트 유형 ID 의 &lt;code&gt;String&lt;/code&gt; 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7377c5aa68707efe0e0822c9b171e4b08d3677df" translate="yes" xml:space="preserve">
          <source>If multiple events with same name (for example, the same class is loaded in different class loaders), then all events that match the name are disabled. To disable a specific class, use the &lt;a href=&quot;#disable(java.lang.Class)&quot;&gt;&lt;code&gt;disable(Class)&lt;/code&gt;&lt;/a&gt; method or a &lt;code&gt;String&lt;/code&gt; representation of the event type ID.</source>
          <target state="translated">동일한 이름을 가진 여러 이벤트 (예 : 동일한 클래스가 다른 클래스 로더에로드 됨) 인 경우 이름과 일치하는 모든 이벤트가 비활성화됩니다. 특정 클래스를 비활성화하려면 disable &lt;a href=&quot;#disable(java.lang.Class)&quot;&gt; &lt;code&gt;disable(Class)&lt;/code&gt; &lt;/a&gt; 메서드 또는 이벤트 유형 ID 의 &lt;code&gt;String&lt;/code&gt; 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5df491cfbb3a3e94daaced15c03303a9a76071f8" translate="yes" xml:space="preserve">
          <source>If multiple events with same name (for example, the same class is loaded in different class loaders), then all events that match the name is disabled. To disable a specific class, use the &lt;a href=&quot;#disable(java.lang.Class)&quot;&gt;&lt;code&gt;disable(Class)&lt;/code&gt;&lt;/a&gt; method or a &lt;code&gt;String&lt;/code&gt; representation of the event type ID.</source>
          <target state="translated">동일한 이름을 가진 여러 이벤트 (예 : 동일한 클래스가 다른 클래스 로더에로드 됨) 인 경우 이름과 일치하는 모든 이벤트가 비활성화됩니다. 특정 클래스를 비활성화하려면 disable &lt;a href=&quot;#disable(java.lang.Class)&quot;&gt; &lt;code&gt;disable(Class)&lt;/code&gt; &lt;/a&gt; 메서드 또는 이벤트 유형 ID 의 &lt;code&gt;String&lt;/code&gt; 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="362678d61121ba55b56c2cd8e3a33ea5e494ed6c" translate="yes" xml:space="preserve">
          <source>If multiple identical &lt;code&gt;EventListener&lt;/code&gt;s are registered on the same &lt;code&gt;EventTarget&lt;/code&gt; with the same parameters the duplicate instances are discarded. They do not cause the &lt;code&gt;EventListener&lt;/code&gt; to be called twice and since they are discarded they do not need to be removed with the &lt;code&gt;removeEventListener&lt;/code&gt; method.</source>
          <target state="translated">여러 개의 동일한 &lt;code&gt;EventListener&lt;/code&gt; 가 동일한 매개 변수 를 사용하여 동일한 &lt;code&gt;EventTarget&lt;/code&gt; 에 등록 된 경우 중복 인스턴스는 삭제됩니다. 그들은 발생하지 않습니다 &lt;code&gt;EventListener&lt;/code&gt; 를 두 번 호출해야하고 폐기되기 때문에 그들은 제거 할 필요가 없습니다 &lt;code&gt;removeEventListener&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="d6b342590893d7d01546097e9b3ca381aee04072" translate="yes" xml:space="preserve">
          <source>If multiple language tags match as a result of the subtag &lt;code&gt;'*'&lt;/code&gt; included in a language range, the first matching language tag returned by an &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; of language tags is treated as the best matching one.</source>
          <target state="translated">여러 언어 태그가 서브 태그의 결과로 일치하면 &lt;code&gt;'*'&lt;/code&gt; 언어의 범위에 포함 된 첫 번째 일치하는 언어 태그는에 의해 반환 된 &lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 이상 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 최고 매칭 하나로 처리 언어 태그의.</target>
        </trans-unit>
        <trans-unit id="f0c9c2c53685bc393a3507bfc1abe85ece354d92" translate="yes" xml:space="preserve">
          <source>If multiple namespaces are specified, the namespaces are treated as alternatives to each other in order of preference. The semantics of such operation is &quot;first applicable&quot;. That is, a composite of &lt;code&gt;GET:PROPERTY|ELEMENT:color&lt;/code&gt; should be interpreted as</source>
          <target state="translated">여러 네임 스페이스가 지정된 경우 네임 스페이스는 우선 순위에 따라 서로 대안으로 처리됩니다. 이러한 작업의 의미는 &quot;최초 적용&quot;입니다. 즉, &lt;code&gt;GET:PROPERTY|ELEMENT:color&lt;/code&gt; 의 합성은 다음 과 같이 해석되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9110f9cffafe9e6ee4b1350deb1a1949682093b" translate="yes" xml:space="preserve">
          <source>If multiple property entries with same currency code but different numeric code and/or minor unit are encountered, those entries are ignored and the remainder of entries in file are processed.</source>
          <target state="translated">통화 코드는 같지만 숫자 코드 및 / 또는 부 단위가 다른 속성 항목이 여러 개 있으면 해당 항목이 무시되고 파일의 나머지 항목이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3470d9ff472d48efc8994801c6d8589feb1153c4" translate="yes" xml:space="preserve">
          <source>If multiple recordings are running at the same time, more data could be recorded than what is specified in the &lt;code&gt;Map&lt;/code&gt; object.</source>
          <target state="translated">여러 기록이 동시에 실행되는 경우 &lt;code&gt;Map&lt;/code&gt; 개체에 지정된 것보다 더 많은 데이터가 기록 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e11014b61e4bf68a9834bb242ccbe0daf8328a8f" translate="yes" xml:space="preserve">
          <source>If necessary paints the background of the component, then invokes &lt;code&gt;paint&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 구성 요소의 배경을 &lt;code&gt;paint&lt;/code&gt; 다음 paint 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d13023cd4e8fcc2d288092b2cc22c117c42c1426" translate="yes" xml:space="preserve">
          <source>If necessary paints the background of the currently selected item.</source>
          <target state="translated">필요한 경우 현재 선택한 항목의 배경을 그립니다.</target>
        </trans-unit>
        <trans-unit id="502a7634dd4fbb85fac2085ee478540e682a31a5" translate="yes" xml:space="preserve">
          <source>If necessary paints the currently selected item.</source>
          <target state="translated">필요한 경우 현재 선택한 항목을 그립니다.</target>
        </trans-unit>
        <trans-unit id="8a47d40ac17dd40421ec44cb538636a1094721bf" translate="yes" xml:space="preserve">
          <source>If necessary, invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;audioAction&lt;/code&gt; to play a sound.</source>
          <target state="translated">필요한 경우 &lt;code&gt;audioAction&lt;/code&gt; 에서 &lt;code&gt;actionPerformed&lt;/code&gt; 를 호출 하여 사운드를 재생합니다.</target>
        </trans-unit>
        <trans-unit id="8ed84b12e8b4451f9860f8aeb95a2d9783b84f78" translate="yes" xml:space="preserve">
          <source>If necessary, invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;audioAction&lt;/code&gt; to play a sound. The &lt;code&gt;actionPerformed&lt;/code&gt; method is invoked if the value of the &lt;code&gt;&quot;AuditoryCues.playList&quot;&lt;/code&gt; default is a &lt;code&gt;
 non-null&lt;/code&gt;&lt;code&gt;Object[]&lt;/code&gt; containing a &lt;code&gt;String&lt;/code&gt; entry equal to the name of the &lt;code&gt;audioAction&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 &lt;code&gt;actionPerformed&lt;/code&gt; 를 호출합니다. &lt;code&gt;audioAction&lt;/code&gt; 에서 를 하여 사운드를 재생합니다. &lt;code&gt;actionPerformed&lt;/code&gt; 의 값 경우 메소드 호출 &lt;code&gt;&quot;AuditoryCues.playList&quot;&lt;/code&gt; 기본이있다 &lt;code&gt; non-null&lt;/code&gt; &lt;code&gt;Object[]&lt;/code&gt; 함유 &lt;code&gt;String&lt;/code&gt; 의 이름과 동일한 항목을 &lt;code&gt;audioAction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31a786a4b9ebe666db90e8ced8967b23f743b698" translate="yes" xml:space="preserve">
          <source>If necessary, perform Namespace processing.</source>
          <target state="translated">필요한 경우 네임 스페이스 처리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d8f13b5330308bc60cf99460dc77123faeb1fbfe" translate="yes" xml:space="preserve">
          <source>If negative values are supplied for &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;, the size of the &lt;code&gt;Rectangle&lt;/code&gt; decreases accordingly. The &lt;code&gt;grow&lt;/code&gt; method will check for integer overflow and underflow, but does not check whether the resulting values of &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; grow from negative to non-negative or shrink from non-negative to negative.</source>
          <target state="translated">음수 값이 제공된 경우 &lt;code&gt;h&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 에 하면 &lt;code&gt;Rectangle&lt;/code&gt; 의 크기가 그에 따라 감소합니다. &lt;code&gt;grow&lt;/code&gt; 방법은 정수 오버플로 및 언더 플로를 확인하지만, 결과 값의 여부를 확인하지 않은 &lt;code&gt;width&lt;/code&gt; 과 &lt;code&gt;height&lt;/code&gt; 비 마이너스 음극에서 성장 또는 마이너스 음수에서 수축.</target>
        </trans-unit>
        <trans-unit id="66da3f0b7e5afbcd4723f96279bb8164621f660a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;err&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;err(System.err)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;err&lt;/code&gt; 메서드가 호출 되지 않으면 동작은 &lt;code&gt;err(System.err)&lt;/code&gt; 을 호출하는 것과 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="edb532e6a48d23f957eb13c3344fd638c7d951c7" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;err&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;err(System.err, System.err, System.err)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;err&lt;/code&gt; 메서드가 모두 호출 되지 않으면 동작은 &lt;code&gt;err(System.err, System.err, System.err)&lt;/code&gt; 을 호출하는 것과 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a5f7b9af35b12b1c65b7cca8d70baba4ca05361d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;out&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;out(System.out)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 메서드가 모두 호출 되지 않으면 동작은 &lt;code&gt;out(System.out)&lt;/code&gt; 을 호출 하는 것과 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c63a06f49648aaff833ac84658eb7762ee71c2f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;out&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;out(System.out, System.out, System.out)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 메서드가 호출 되지 않은 경우 동작은 &lt;code&gt;out(System.out, System.out, System.out)&lt;/code&gt; 을 호출 하는 것과 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="96deacbcbd603234beac87ed146d981937aeee1c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;persistence&lt;/code&gt; method is called, the behavior should be to use the tool's standard persistence mechanism.</source>
          <target state="translated">&lt;code&gt;persistence&lt;/code&gt; 메서드가 호출 되지 않으면 도구의 표준 지속성 메커니즘을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="42cad56717cf7e20c21c3541b4a9c191951fc2c2" translate="yes" xml:space="preserve">
          <source>If neither maximum limit or the maximum age is set, the size of the recording may grow indefinitely if events are on</source>
          <target state="translated">최대 제한 또는 최대 기간이 설정되지 않은 경우 이벤트가 켜져 있으면 녹화 크기가 무한정 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc5113d43716ce4f8833ac1056d11a0ad512ade" translate="yes" xml:space="preserve">
          <source>If neither maximum limit or the maximum age is set, the size of the recording may grow indefinitely.</source>
          <target state="translated">최대 제한 또는 최대 기간이 설정되지 않은 경우 녹화 크기가 무한정 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fbfbdd8794986ee056ce3b4b224daa409c09c76" translate="yes" xml:space="preserve">
          <source>If neither of these properties is defined then the LogManager uses its default configuration. The default configuration is typically loaded from the properties file &quot;&lt;code&gt;lib/logging.properties&lt;/code&gt;&quot; in the Java installation directory.</source>
          <target state="translated">이 특성 중 어느 것도 정의되지 않으면 LogManager는 기본 구성을 사용합니다. 기본 구성은 일반적으로 Java 설치 디렉토리의 &quot; &lt;code&gt;lib/logging.properties&lt;/code&gt; &quot; 특성 파일에서로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3ae7424666e0772e32faa1585ee99d03123f286" translate="yes" xml:space="preserve">
          <source>If no &quot;%g&quot; field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.</source>
          <target state="translated">&quot;% g&quot;필드가 지정되지 않고 파일 수가 1보다 큰 경우 생성 번호는 생성 된 파일 이름 끝에 점 뒤에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c49e64ec417bf53b53b9cae02beab8814230bf7f" translate="yes" xml:space="preserve">
          <source>If no 'getMethod' field is defined then the default value of the attribute is returned. If the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">'getMethod'필드가 정의되어 있지 않으면 속성의 기본값이 리턴됩니다. 반환 된 값이 선언 된 속성 유형과 호환되지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9225d15e7619420ba47ebcf86e79d42187eb2a62" translate="yes" xml:space="preserve">
          <source>If no &lt;a id=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a id=&quot;floatdFlags&quot;&gt;플래그&lt;/a&gt; 가 지정 되지 않은 경우 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78c4da8fa7e0254c8812c85bb272ccfe8cae4bea" translate="yes" xml:space="preserve">
          <source>If no &lt;a id=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a id=&quot;intdFlags&quot;&gt;플래그&lt;/a&gt; 가 지정 되지 않은 경우 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf903b34c15e4e7c1e0d072f0b913417b22851de" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a name=&quot;floatdFlags&quot;&gt;플래그&lt;/a&gt; 가 제공 되지 않으면 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25494f57433f4174256b8e508bd8d48cd34d752d" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a name=&quot;intdFlags&quot;&gt;플래그&lt;/a&gt; 가 제공 되지 않으면 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a454d687e36b47d42fe06ade51852e5f906999d0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContentHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt; mechanism is used to locate &lt;a href=&quot;contenthandlerfactory&quot;&gt;ContentHandlerFactory&lt;/a&gt; implementations using the system class loader. The order that factories are located is implementation specific, and an implementation is free to cache the located factories. A &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;, &lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;RuntimeException&lt;/code&gt; thrown from the &lt;code&gt;createContentHandler&lt;/code&gt;, if encountered, will be propagated to the calling thread. The &lt;code&gt;
     createContentHandler&lt;/code&gt; method of each factory, if instantiated, is invoked, with the content type, until a factory returns non-null, or all factories have been exhausted.</source>
          <target state="translated">어떤 경우 &lt;code&gt;ContentHandlerFactory&lt;/code&gt; 를가 아직 설정되어 있지 않은 공장의 경우, 또는 &lt;code&gt;createContentHandler&lt;/code&gt; 의 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader의&lt;/a&gt; 메커니즘을 찾는 데 사용됩니다&lt;a href=&quot;contenthandlerfactory&quot;&gt; ContentHandlerFactory를&lt;/a&gt; 시스템 클래스 로더를 사용하여 구현. 팩토리가 위치하는 순서는 구현에 따라 다르며 배치 된 팩토리를 자유롭게 캐시 할 수 있습니다. &lt;code&gt;createContentHandler&lt;/code&gt; 에서 throw 된 &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt; , &lt;code&gt;Error&lt;/code&gt; 또는 &lt;code&gt;RuntimeException&lt;/code&gt; 이 발생 하면 호출 스레드로 전파됩니다. &lt;code&gt; createContentHandler&lt;/code&gt; 인스턴스화 된 경우 각 팩토리의 메소드는 팩토리가 널이 아닌 값을 리턴하거나 모든 팩토리가 소진 될 때까지 컨텐츠 유형으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dd48417e371ab33de209406773a687b4b7228a04" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;LoggerFinder&lt;/code&gt; provider is found, the system default &lt;code&gt;LoggerFinder&lt;/code&gt; implementation will be used.</source>
          <target state="translated">&lt;code&gt;LoggerFinder&lt;/code&gt; 공급자가 없으면 시스템 기본 &lt;code&gt;LoggerFinder&lt;/code&gt; 구현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce2df46d03f068b49d97f68dc89d5e9b2960ee5" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SSLContext&lt;/code&gt; was set in this client's builder, then the &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#getDefault()&quot;&gt;default context&lt;/a&gt; is returned.</source>
          <target state="translated">이 클라이언트의 빌더에 &lt;code&gt;SSLContext&lt;/code&gt; 가 설정 되지 않은 경우 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#getDefault()&quot;&gt;기본 컨텍스트&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="13df2cedfcaa3a22fc1954dda64acbabb2c44e93" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SSLParameters&lt;/code&gt; were set in the client's builder, then an implementation specific default set of parameters, that the client will use, is returned.</source>
          <target state="translated">클라이언트 빌더에 &lt;code&gt;SSLParameters&lt;/code&gt; 가 설정 되지 않은 경우 클라이언트가 사용할 구현 특정 기본 매개 변수 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1aacf1b45616404046adf43e5124614b11f8bf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SyncProvider&lt;/code&gt; object is specified, the reference implementation provider &lt;code&gt;RIOptimisticProvider&lt;/code&gt; is supplied.</source>
          <target state="translated">아니라면 &lt;code&gt;SyncProvider&lt;/code&gt; 개체가 지정 참조 구현 공급자 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0991a62933ecfd2bd1a1cdacfe077cecaa408e5f" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt; mechanism is used to locate &lt;a href=&quot;spi/urlstreamhandlerprovider&quot;&gt;URLStreamHandlerProvider&lt;/a&gt; implementations using the system class loader. The order that providers are located is implementation specific, and an implementation is free to cache the located providers. A &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;, &lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;RuntimeException&lt;/code&gt; thrown from the &lt;code&gt;createURLStreamHandler&lt;/code&gt;, if encountered, will be propagated to the calling thread. The &lt;code&gt;
     createURLStreamHandler&lt;/code&gt; method of each provider, if instantiated, is invoked, with the protocol string, until a provider returns non-null, or all providers have been exhausted.</source>
          <target state="translated">어떤 경우 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 를가 아직 설정되어 있지 않은 공장의 경우, 또는 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 의 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader의&lt;/a&gt; 메커니즘을 찾는 데 사용됩니다 &lt;a href=&quot;spi/urlstreamhandlerprovider&quot;&gt;URLStreamHandlerProvider&lt;/a&gt; 시스템 클래스 로더를 사용하여 구현. 공급자를 찾는 순서는 구현에 따라 다르며 구현은 찾은 공급자를 자유롭게 캐시 할 수 있습니다. &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;것은, ServiceConfigurationError&lt;/a&gt; , &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;createURLStreamHandler&lt;/code&gt; 에서 throw 또는 &lt;code&gt;RuntimeException&lt;/code&gt; 이 발생 하면 호출 스레드로 전파됩니다. &lt;code&gt; createURLStreamHandler&lt;/code&gt; 인스턴스화 된 경우 각 공급자의 메서드는 공급자가 null이 아닌 값을 반환하거나 모든 공급자가 소진 될 때까지 프로토콜 문자열과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48c606520866ed3b5c7ab60dadf8ce7019bfde30" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the constructor finds the value of the system property:</source>
          <target state="translated">어떤 경우 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 를가 아직 설정되어 있지 않은 공장의 경우, 또는 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 의 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; , 다음 생성자는 시스템 프로퍼티의 값을 찾습니다</target>
        </trans-unit>
        <trans-unit id="e563df7258f13a8f225773d813627e3543639a63" translate="yes" xml:space="preserve">
          <source>If no Configuration object has been installed in the runtime, a call to &lt;code&gt;getConfiguration&lt;/code&gt; installs an instance of the default Configuration implementation (a default subclass implementation of this abstract class). The default Configuration implementation can be changed by setting the value of the &lt;code&gt;login.configuration.provider&lt;/code&gt; security property to the fully qualified name of the desired Configuration subclass implementation.</source>
          <target state="translated">런타임에 Configuration 객체가 설치되지 않은 경우 &lt;code&gt;getConfiguration&lt;/code&gt; 을 호출 하면 기본 Configuration 구현 (이 추상 클래스의 기본 서브 클래스 구현)의 인스턴스가 설치됩니다. &lt;code&gt;login.configuration.provider&lt;/code&gt; 보안 특성 값을 원하는 구성 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 구성 구현을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f28da2d05be1c33c6f8a1b624ec1c4eb508ea0e9" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation.</source>
          <target state="translated">런타임에 Policy 객체가 설치되어 있지 않은 경우, &lt;code&gt;getPolicy&lt;/code&gt; 를 호출 하면 기본 Policy 구현의 인스턴스 (이 추상 클래스의 기본 서브 클래스 구현)가 설치됩니다. &lt;code&gt;policy.provider&lt;/code&gt; 보안 특성 의 값을 원하는 Policy 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 Policy 구현을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ff9c3a3e2b449d9fdfd8119017b2beec1065ca4" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation. The system class loader is used to load this class.</source>
          <target state="translated">런타임에 Policy 객체가 설치되지 않은 경우 &lt;code&gt;getPolicy&lt;/code&gt; 를 호출 하면 기본 Policy 구현 (이 추상 클래스의 기본 서브 클래스 구현)의 인스턴스가 설치됩니다. &lt;code&gt;policy.provider&lt;/code&gt; 보안 특성 의 값을 원하는 Policy 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 정책 구현을 변경할 수 있습니다 . 시스템 클래스 로더는이 클래스를로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef589a356e1913a9ee01360e4dbbec446e431cfd" translate="yes" xml:space="preserve">
          <source>If no System ID was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, String systemId)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt;&lt;code&gt;setSystemId(String systemId)&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, String systemId)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt; &lt;code&gt;setSystemId(String systemId)&lt;/code&gt; &lt;/a&gt; 를 통해 시스템 ID가 설정되지 않은 경우 , 다음 &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d8103a3ac14929d0ea6f76a89ffe79e5d895f4e5" translate="yes" xml:space="preserve">
          <source>If no access is allowed, the suffix is &quot;/noaccess&quot;.</source>
          <target state="translated">액세스가 허용되지 않으면 접미 부는 &quot;/ noaccess&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="51d8e33d13184ce0c057a13cfc7fd7024a488d5d" translate="yes" xml:space="preserve">
          <source>If no array is specified on the constructor, but tiling is allowed, then this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">생성자에 배열이 지정되지 않았지만 타일링이 허용되는 경우이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c0cfda8bbfe14b8fb38a9ed37f0082a13f36c5b4" translate="yes" xml:space="preserve">
          <source>If no attribute with this local name and namespace URI is found, this method has no effect.</source>
          <target state="translated">이 로컬 이름 및 네임 스페이스 URI가있는 속성이 없으면이 메서드는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8225a781e6aeb21876e42212e39dd339fac75791" translate="yes" xml:space="preserve">
          <source>If no attribute with this name is found, this method has no effect.</source>
          <target state="translated">이 이름을 가진 속성이 없으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4bff44b972295c18222a6d267bf9bd47ae29d380" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;#setCalendarType(java.lang.String)&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">&lt;a href=&quot;#setCalendarType(java.lang.String)&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt; 메서드 에 대한 호출로 달력 유형이 명시 적으로 지정되지 않은 경우 &lt;code&gt;Locale&lt;/code&gt; 값을 사용하여 &lt;code&gt;Calendar&lt;/code&gt; 유형을 결정합니다. 빌드 할 .</target>
        </trans-unit>
        <trans-unit id="f57aed5ec85446dac8b881e2e9691de38db155c7" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">&lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 호출로 일정 관리 유형이 명시 적으로 제공되지 않으면 &lt;code&gt;Locale&lt;/code&gt; 값을 사용하여 빌드 할 &lt;code&gt;Calendar&lt;/code&gt; 유형을 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="935be8843834b9a2add0a2c48a0401f80247fd8f" translate="yes" xml:space="preserve">
          <source>If no card is present in this terminal when this method is called, it returns immediately.</source>
          <target state="translated">이 메서드가 호출 될 때이 터미널에 카드가 없으면 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="635db19022015f7488d5435599c4fb48937a985a" translate="yes" xml:space="preserve">
          <source>If no class can be found in this way, this method will use an implementation-specific way to locate an implementation. If none is found, a NamingException is thrown.</source>
          <target state="translated">이런 방식으로 클래스를 찾을 수 없으면이 메소드는 구현 별 방법을 사용하여 구현을 찾습니다. 아무것도 발견되지 않으면 NamingException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ca30507c3453e7a86b86ecc80fdbdb06caf5ff95" translate="yes" xml:space="preserve">
          <source>If no compiler is available, these methods do nothing.</source>
          <target state="translated">사용 가능한 컴파일러가없는 경우이 메소드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03a20d9ed1179b7d5a03dd542c674e1b486901d" translate="yes" xml:space="preserve">
          <source>If no content handler could be &lt;a href=&quot;urlconnection#getContent()&quot;&gt;found&lt;/a&gt;, URLConnection will look for a content handler in a user-definable set of places. Users can define a vertical-bar delimited set of class prefixes to search through by defining the</source>
          <target state="translated">컨텐츠 핸들러를 &lt;a href=&quot;urlconnection#getContent()&quot;&gt;찾을&lt;/a&gt; 수없는 경우 URLConnection은 사용자 정의 가능한 위치 세트에서 컨텐츠 핸들러를 찾습니다. 사용자는 세로줄로 구분 된 클래스 접두사 집합을 정의하여 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="243bf1d6846d6372968ae561b146475eecd8f1fd" translate="yes" xml:space="preserve">
          <source>If no content handler could be found, URLConnection will look for a content handler in a user-defineable set of places. By default it looks in sun.net.www.content, but users can define a vertical-bar delimited set of class prefixes to search through in addition by defining the java.content.handler.pkgs property. The class name must be of the form:</source>
          <target state="translated">컨텐츠 핸들러를 찾을 수없는 경우 URLConnection은 사용자가 정의 할 수있는 장소 세트에서 컨텐츠 핸들러를 찾습니다. 기본적으로 sun.net.www.content에 있지만 사용자는 java.content.handler.pkgs 등록 정보를 정의하여 검색 할 세로 막대로 구분 된 클래스 접두사 세트를 정의 할 수 있습니다. 클래스 이름은 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="521ced0b1e8fb5511e3ff3521639bbd2e1d892dd" translate="yes" xml:space="preserve">
          <source>If no content handler factory has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the application loads the class named:</source>
          <target state="translated">컨텐츠 핸들러 팩토리가 아직 설정되지 않았거나 팩토리의 &lt;code&gt;createContentHandler&lt;/code&gt; 메소드가 &lt;code&gt;null&lt;/code&gt; 을 리턴 하면 애플리케이션은 다음과 같은 이름의 클래스를로드합니다.</target>
        </trans-unit>
        <trans-unit id="8116296a26510935b6c10d95ea6e65ff6f455a64" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 설명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;null&lt;/code&gt; 에서 반환 &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; ,이 방법은 반환해야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2514c39dc0080097bab43387d9c7ddb3546f473f" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityValues&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 설명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;null&lt;/code&gt; 에서 반환 &lt;code&gt;getCompressionQualityValues&lt;/code&gt; ,이 방법은 반환해야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78db565fdb9cf670cbeb4a07cf3f94628d766f5b" translate="yes" xml:space="preserve">
          <source>If no encoding is reachable through the above properties, a default encoding of &quot;UTF-8&quot; will be used. If the specified encoding is not supported an &quot;unsupported-encoding&quot; fatal error is raised.</source>
          <target state="translated">위의 속성을 통해 연결할 수있는 인코딩이 없으면 기본 인코딩 인 &quot;UTF-8&quot;이 사용됩니다. 지정된 인코딩이 지원되지 않으면 &quot;지원되지 않는 인코딩&quot;치명적 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d14c96365230fe95d4c170b5d326eb6ff39f4595" translate="yes" xml:space="preserve">
          <source>If no enough field parameters are given for determining date and/or time, calendar specific default values are used when building a &lt;code&gt;Calendar&lt;/code&gt;. For example, if the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; value isn't given for the Gregorian calendar, 1970 will be used. If there are any conflicts among field parameters, the &lt;a href=&quot;calendar#resolution&quot;&gt; resolution rules&lt;/a&gt; are applied. Therefore, the order of field setting matters.</source>
          <target state="translated">날짜 및 / 또는 시간을 결정하기위한 충분한 필드 매개 변수가 제공되지 않으면 &lt;code&gt;Calendar&lt;/code&gt; 를 작성할 때 달력 특정 기본값이 사용됩니다 . 예를 들어, Gregorian 달력에 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 값을 지정하지 않으면 1970이 사용됩니다. 필드 매개 변수간에 충돌이 있으면 &lt;a href=&quot;calendar#resolution&quot;&gt;해결 규칙&lt;/a&gt; 이 적용됩니다. 따라서 필드 설정 순서가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ecdf3b396a4d73a803538806745ca75e8449f4aa" translate="yes" xml:space="preserve">
          <source>If no explicit alignment constraint was set on this layout (see &lt;a href=&quot;#withBitAlignment(long)&quot;&gt;&lt;code&gt;withBitAlignment(long)&lt;/code&gt;&lt;/a&gt;), then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.</source>
          <target state="translated">이 레이아웃에 명시적인 정렬 제약이 설정되지 않은 경우 ( &lt;a href=&quot;#withBitAlignment(long)&quot;&gt; &lt;code&gt;withBitAlignment(long)&lt;/code&gt; &lt;/a&gt; 참조 ),이 메서드는 이 레이아웃과 관련된 &lt;a href=&quot;#layout-align&quot;&gt;자연스러운 정렬&lt;/a&gt; 제약 (비트 단위)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0906309ddd60b1034d32d8d0f776c48d2d58f7bb" translate="yes" xml:space="preserve">
          <source>If no explicit alignment constraint was set on this layout (see &lt;a href=&quot;#withBitAlignment(long)&quot;&gt;&lt;code&gt;withBitAlignment(long)&lt;/code&gt;&lt;/a&gt;), then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.</source>
          <target state="translated">이 레이아웃에 명시적인 정렬 제약이 설정되지 않은 경우 ( &lt;a href=&quot;#withBitAlignment(long)&quot;&gt; &lt;code&gt;withBitAlignment(long)&lt;/code&gt; &lt;/a&gt; 참조 ),이 메서드는 이 레이아웃과 관련된 &lt;a href=&quot;#layout-align&quot;&gt;자연적인 정렬&lt;/a&gt; 제약 (바이트 단위)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="16ff43ae37cee58fd3b00cbf5ccc1d2576fdf523" translate="yes" xml:space="preserve">
          <source>If no explicit alignment constraint was set on this layout (see &lt;a href=&quot;memorylayout#withBitAlignment(long)&quot;&gt;&lt;code&gt;MemoryLayout.withBitAlignment(long)&lt;/code&gt;&lt;/a&gt;), then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.</source>
          <target state="translated">이 레이아웃에 명시적인 정렬 제약이 설정되지 않은 경우 ( &lt;a href=&quot;memorylayout#withBitAlignment(long)&quot;&gt; &lt;code&gt;MemoryLayout.withBitAlignment(long)&lt;/code&gt; &lt;/a&gt; 참조 ),이 메서드는 이 레이아웃과 관련된 &lt;a href=&quot;#layout-align&quot;&gt;자연적인 정렬&lt;/a&gt; 제약 (비트 단위)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="849cb058e66c932aa175578e9e055d9949f3ca41" translate="yes" xml:space="preserve">
          <source>If no explicit message was passed to the constructor, and as long as certain internal information is available, a verbose description of the null reference is returned. The internal information is not available in deserialized NullPointerExceptions.</source>
          <target state="translated">생성자에 전달 된 명시 적 메시지가없고 특정 내부 정보를 사용할 수있는 한 널 참조에 대한 자세한 설명이 리턴됩니다. 내부 정보는 deserialized NullPointerExceptions에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98b4a446eb39aa005a8ac1b8be8c197590e7249d" translate="yes" xml:space="preserve">
          <source>If no explicit module prefix is given and modules are supported in the environment, a suitable module is inferred. If a suitable module cannot be inferred &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference.</source>
          <target state="translated">명시적인 모듈 접두사가 지정되지 않고 모듈이 환경에서 지원되는 경우 적절한 모듈이 유추됩니다. 적합한 모듈을 유추 할 수없는 경우 &lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 구현은 추론의 일부로 주석 처리 도구의 구성에 대한 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c83500feb8ee5817fa7b2052c71d1bfe69e3f6ba" translate="yes" xml:space="preserve">
          <source>If no face for the requested style can be found, the font system may apply algorithmic styling to achieve the desired style. For example, if &lt;code&gt;ITALIC&lt;/code&gt; is requested, but no italic face is available, glyphs from the plain face may be algorithmically obliqued (slanted).</source>
          <target state="translated">요청한 스타일의 얼굴을 찾을 수없는 경우 글꼴 시스템은 알고리즘 스타일을 적용하여 원하는 스타일을 얻을 수 있습니다. 예를 들어, &lt;code&gt;ITALIC&lt;/code&gt; 이 요청되었지만 사용 가능한 기울임 꼴면이없는 경우 일반면의 글리프가 알고리즘 적으로 기울어 질 수 있습니다 (경사).</target>
        </trans-unit>
        <trans-unit id="3c3b8e9ce2ba433f5bd56b760aee79cd23850c9f" translate="yes" xml:space="preserve">
          <source>If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.</source>
          <target state="translated">위의 1 단계에서 필드를 찾지 못하면이 알고리즘은 C의 각 직접 슈퍼 인터페이스에 재귀 적으로 적용됩니다. 직접 슈퍼 인터페이스는 선언 된 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="3a478bf1473f7f2d59cb1ae1a418bd4cb78d9c7e" translate="yes" xml:space="preserve">
          <source>If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a &lt;code&gt;NoSuchFieldException&lt;/code&gt; is thrown.</source>
          <target state="translated">위의 1, 2 단계에서 필드를 찾을 수없고 C에 수퍼 클래스 S가 있으면이 알고리즘은 S에 대해 재귀 적으로 호출됩니다. C에 수퍼 클래스가 없으면 &lt;code&gt;NoSuchFieldException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="157bac57c7c9bc8f974ce96ebf0d2865b133b27f" translate="yes" xml:space="preserve">
          <source>If no input methods are available or the current input method does not provide an input method control object, then null is returned.</source>
          <target state="translated">사용할 수있는 입력 방법이 없거나 현재 입력 방법이 입력 방법 제어 개체를 제공하지 않는 경우 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="85d8b2f1396493ecd88a1cad4f6f3c76ce079715" translate="yes" xml:space="preserve">
          <source>If no localization information is available, the non-localized name is returned.</source>
          <target state="translated">현지화 정보가 없으면 현지화되지 않은 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22fd3bbeb9c5dbaa32c21b11f1b89bc4bd8ecdd6" translate="yes" xml:space="preserve">
          <source>If no mapping rules exist to derive &lt;em&gt;opentype(J)&lt;/em&gt; from &lt;em&gt;J&lt;/em&gt;, then &lt;em&gt;J&lt;/em&gt; cannot be the type of a method parameter or return value in an MXBean interface.</source>
          <target state="translated">맵핑 규칙을 도출하도록 없으면 &lt;em&gt;오픈 (J)&lt;/em&gt; 에서 &lt;em&gt;J&lt;/em&gt; 후 &lt;em&gt;J는&lt;/em&gt; MXBean의 인터페이스 메소드 파라미터 나 리턴 값의 타입이 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="b5ddd6654d9c602c5f7f5aebb431141368be7c43" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">마크가 설정되어 있지 않은 경우, mark의 값은 생성자에게 건네지는 오프셋 (또는 오프셋이 제공되지 않은 경우는 0)입니다.</target>
        </trans-unit>
        <trans-unit id="bebf4b9fd62e0e0e062741afac69f1752343555c" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of the mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">마크가 설정되어 있지 않은 경우, 마크의 값은 생성자에게 건네지는 오프셋 (또는 오프셋이 제공되어 있지 않은 경우는 0)입니다.</target>
        </trans-unit>
        <trans-unit id="c4e2dfab8e70fdd67fdbf85be3aefb24cc2ae831" translate="yes" xml:space="preserve">
          <source>If no match is found with the &lt;code&gt;systemId&lt;/code&gt; and &lt;code&gt;public&lt;/code&gt; identifier, the resolver will continue searching &lt;code&gt;uri&lt;/code&gt; entries with the specified &lt;code&gt;systemId&lt;/code&gt; or &lt;code&gt;href&lt;/code&gt;. The &lt;code&gt;uri&lt;/code&gt; entries include &lt;code&gt;uri&lt;/code&gt;, &lt;code&gt;rewriteURI&lt;/code&gt;, and &lt;code&gt;uriSuffix&lt;/code&gt; entries.</source>
          <target state="translated">&lt;code&gt;systemId&lt;/code&gt; 및 &lt;code&gt;public&lt;/code&gt; 식별자 와 일치하는 항목이 없으면 확인자는 지정된 &lt;code&gt;systemId&lt;/code&gt; 또는 &lt;code&gt;href&lt;/code&gt; 를 사용하여 &lt;code&gt;uri&lt;/code&gt; 항목을 계속 검색 합니다 . &lt;code&gt;uri&lt;/code&gt; 항목이 포함 &lt;code&gt;uri&lt;/code&gt; , &lt;code&gt;rewriteURI&lt;/code&gt; 및 &lt;code&gt;uriSuffix&lt;/code&gt; 을 항목을.</target>
        </trans-unit>
        <trans-unit id="ca0a82059235a2192c2af72074baf7ab9d68bd42" translate="yes" xml:space="preserve">
          <source>If no match is found, &lt;code&gt;public&lt;/code&gt; entries may be searched in accordance with the &lt;code&gt;prefer&lt;/code&gt; attribute.</source>
          <target state="translated">일치하는 항목이없는 경우 &lt;code&gt;prefer&lt;/code&gt; 항목에 따라 &lt;code&gt;public&lt;/code&gt; 항목을 검색 할 수 있습니다. 속성 .</target>
        </trans-unit>
        <trans-unit id="04e67c9a77bba1f9d49ec8d97898bd5df73e6e1e" translate="yes" xml:space="preserve">
          <source>If no matching method is found by step 1 then:</source>
          <target state="translated">1 단계에서 일치하는 방법을 찾지 못하면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="98b1341ab5d1352e8c92eb553367593ccb7794fd" translate="yes" xml:space="preserve">
          <source>If no node was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, String systeId)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setNode(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;setNode(Node node)&lt;/code&gt;&lt;/a&gt;, then the node will be set by the transformation, and may be obtained from this method once the transformation is complete. Calling this method before the transformation will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">어떤 노드로 설정되어 있지 않은 경우 &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, String systeId)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setNode(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;setNode(Node node)&lt;/code&gt; &lt;/a&gt; 후, 노드는 변환에 의해 설정되며 변환이 완료되면이 메서드에서 얻을 수 있습니다. 변환 전에이 메서드를 호출하면 &lt;code&gt;null&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2c6ebb366cc139ff51efee5ce5b414347a8bb8" translate="yes" xml:space="preserve">
          <source>If no node was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setNextSibling(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;setNextSibling(Node nextSibling)&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">어떤 노드를 통해 설정되어 있지 않은 경우 &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setNextSibling(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;setNextSibling(Node nextSibling)&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd216b7387fe2dee5dd00b4fdaab3ce4feee3b7f" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">다른 스레드가 교환을 기다리고 있지 않은 경우, 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하며 다음 세 가지 중 하나가 발생할 때까지 휴면 상태입니다.</target>
        </trans-unit>
        <trans-unit id="f82da2a19e504b2d12c547c6cd21c732ba85238d" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">다른 스레드가 교환을 기다리고 있지 않으면 스레드 예약을 위해 현재 스레드가 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="1d8f5c6897dfd0200026687e7449f5e103ba0680" translate="yes" xml:space="preserve">
          <source>If no output DOM source is set, the transformation will create a Document node as the holder for the result of the transformation, which may be retrieved with &lt;a href=&quot;#getNode()&quot;&gt;&lt;code&gt;getNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">출력 DOM 소스가 설정되지 않은 경우 변환은 &lt;a href=&quot;#getNode()&quot;&gt; &lt;code&gt;getNode()&lt;/code&gt; &lt;/a&gt; 하여 검색 할 수있는 변환 결과에 대한 홀더로 Document 노드를 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="60a5d7e2c9421527851b4de33c50dfcdd772e870" translate="yes" xml:space="preserve">
          <source>If no output is specified in the &lt;code&gt;LSOutput&lt;/code&gt;, a &quot;no-output-specified&quot; fatal error is raised.</source>
          <target state="translated">&lt;code&gt;LSOutput&lt;/code&gt; 에 출력이 지정되지 않은 경우 &quot;no-output-specified&quot;치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8c99a978e37655f05ece5d09a50cf601a4c0974" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">사용 가능한 허가가없는 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="05c5dee407f95ed89e404e9d431ede44a984e5d6" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">사용 가능한 허가가없는 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="f257165424661099344b4c148a094fafc4e79eea" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">사용 가능한 허용이 없으면 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다른 스레드가 &lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 휴면 상태가됩니다. 가이 세마포어에 대한 메서드를 하고 현재 스레드에 다음으로 허용이 할당 가됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0c61688e7523da669464298c2f1d9cfc1f08b7" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">사용 가능한 허가가없는 경우, 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다른 스레드 가이 세마포어에 대한 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하고 현재 스레드에 허가가 할당 될 때까지 휴면 상태 가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd133845b033ac7223fae8a2a495d3b108c36d1d" translate="yes" xml:space="preserve">
          <source>If no permit is available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 허가가없는 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="bde780014066de098cdda5d04ec6eced915d4e68" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 경우를 포함하여 위 단계에서 공급자를 찾을 수없는 경우 구현은 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 대해 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 throw합니다 . 구현은 다른 방법으로 공급자를 찾을 수 있습니다. 예를 들어 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;서비스 공급자를&lt;/a&gt; 지원할 수 있으며 서비스 인터페이스는 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18a2e308f5b1571e4657b57bf184f7a6e5967fc5" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 경우를 포함하여 위 단계에서 공급자를 찾을 수없는 경우 구현은 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 대해 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 throw합니다 . 구현은 다른 방법으로 공급자를 찾을 수 있습니다. 예를 들어 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;서비스 공급자를&lt;/a&gt; 지원할 수 있으며 서비스 인터페이스는 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d71b912edbe329f77d7b28fabf9c3de6a91d65f" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 경우를 포함하여 위 단계에서 공급자를 찾을 수없는 경우 구현은 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 throw합니다 . 구현은 다른 방법으로 공급자를 찾을 수 있습니다. 예를 들어 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;서비스 제공 업체를&lt;/a&gt; 지원할 수 있으며 서비스 인터페이스는 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40de0681afbfe30c5174ef02550d9cb4e2c2be74" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 경우를 포함하여 위 단계에서 공급자를 찾을 수없는 경우 구현은 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 throw합니다 . 구현은 다른 방법으로 공급자를 찾을 수 있습니다. 예를 들어 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;서비스 공급자를&lt;/a&gt; 지원할 수 있으며 서비스 인터페이스는 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91b1ae1535d1f33ae0e732627166d15b6a2cc1cc" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 사례를 포함하여 위의 단계에서 공급자를 찾지 못하면 구현시 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 발생시킵니다. 구현은 다른 방법으로 공급자를 찾도록 선택할 수 있습니다. 예를 들어, 서비스 인터페이스가 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 인&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;서비스 제공자에 대한 JAR 규칙을&lt;/a&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70dda654250368e808b6b425e672a82e81efe712" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 사례를 포함하여 위의 단계에서 공급자를 찾지 못하면 구현시 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 발생시킵니다. 구현은 다른 방법으로 공급자를 찾도록 선택할 수 있습니다. 예를 들어, 서비스 인터페이스가 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 인&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;서비스 제공자에 대한 JAR 규칙을&lt;/a&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="358e4b9d7ce6402f029c918e9fe871624205bf53" translate="yes" xml:space="preserve">
          <source>If no schema is being used, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">사용중인 스키마가 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="89a0da88ba5bf3412472b759b494b06f9be9b46e" translate="yes" xml:space="preserve">
          <source>If no settings are set for this recording, an empty &lt;code&gt;Map&lt;/code&gt; is returned.</source>
          <target state="translated">이 기록에 대한 설정이 없으면 빈 &lt;code&gt;Map&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c002ff099715a2c9ace5d7c19ec125719ebb67" translate="yes" xml:space="preserve">
          <source>If no special set-up is needed, just use &lt;code&gt;JShell.builder().build()&lt;/code&gt; or the short-cut equivalent &lt;code&gt;JShell.create()&lt;/code&gt;.</source>
          <target state="translated">특별한 설정이 필요하지 않으면 &lt;code&gt;JShell.builder().build()&lt;/code&gt; 또는 바로 가기에 해당하는 &lt;code&gt;JShell.create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="913b2ab905dfc209e536f0bbc14b4b2d62954ca4" translate="yes" xml:space="preserve">
          <source>If no such listeners exist, this method returns an empty array.</source>
          <target state="translated">그러한 리스너가 없으면이 메서드는 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4f99c7ebdd694b15a7a1884c5882e8188c69e3f" translate="yes" xml:space="preserve">
          <source>If no such value of</source>
          <target state="translated">그러한 가치가 없다면</target>
        </trans-unit>
        <trans-unit id="b1a3c651aeb30026243d1fce39999de76ba1d1b7" translate="yes" xml:space="preserve">
          <source>If no such value of &lt;code&gt;k&lt;/code&gt; exists, then &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">이러한 값의 경우 &lt;code&gt;k&lt;/code&gt; 존재하지 후 &lt;code&gt;-1&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="403db4222f81e0d75b794b78755dc9fe44d7a29f" translate="yes" xml:space="preserve">
          <source>If no system or security properties were set, try to read from the file, ${user.home}/.java.login.config, where ${user.home} is the value represented by the &quot;user.home&quot; System property.</source>
          <target state="translated">시스템 또는 보안 등록 정보가 설정되지 않은 경우 $ {user.home} /. java.login.config 파일에서 읽으십시오. 여기서 $ {user.home}은 &quot;user.home&quot;시스템 등록 정보가 나타내는 값입니다. .</target>
        </trans-unit>
        <trans-unit id="6ba9d8d2bfd2921beec7b4626cc18a496f95ecd1" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;#getId()&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;#getId()&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="14f661da1d4c4d0449092dff36f1322744a317c5" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;#getValue()&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;#getValue()&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8098cc1dcdc7eef18c37176303f3d539ee64942f" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;dayofweek#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;dayofweek#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="de90c966ff366bae8a6ebf647919730e37775606" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue()&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;era#getValue()&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="172481aa19fb2665297fe8e01e1a105abb6a4821" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;era#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="36c6de59e58640f47a0ec5a526b903e6cdb5056b" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;month#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;month#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="26dec5e0aab4853771305a15bb1f061f803aacdf" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;zoneid#getId--&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;zoneid#getId--&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9627881d92575480927b9f03e39660f159d5d615" translate="yes" xml:space="preserve">
          <source>If no thread factory is supplied via a system property, then the common pool uses a factory that uses the system class loader as the &lt;a href=&quot;../../lang/thread#getContextClassLoader()&quot;&gt;thread context class loader&lt;/a&gt;. In addition, if a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present, then the common pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">시스템 속성을 통해 스레드 팩토리가 제공되지 않으면 공통 풀은 시스템 클래스 로더를 &lt;a href=&quot;../../lang/thread#getContextClassLoader()&quot;&gt;스레드 컨텍스트 클래스 로더&lt;/a&gt; 로 사용하는 팩토리를 사용합니다 . 또한 &lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; 가있는 경우 공용 풀은 사용 &lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt; 활성화 되지 않은 스레드를 제공하는 팩토리를 사용합니다. 이러한 설정을 구성하는 데 오류가 발생하면 기본 매개 변수가 사용됩니다. parallelism 속성을 0으로 설정하거나 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수있는 팩토리를 사용하여 공용 풀에서 스레드 사용을 비활성화하거나 제한 할 수 있습니다 . 그러나 이렇게하면 결합되지 않은 작업이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2720f481dd9e3309673a042872b8da0c6951d663" translate="yes" xml:space="preserve">
          <source>If no update listeners are present, the reader may choose to perform fewer updates to the pixels of the destination images and/or thumbnails, which may result in more efficient decoding.</source>
          <target state="translated">업데이트 리스너가 존재하지 않으면, 리더기는 목적지 이미지 및 / 또는 썸네일의 픽셀에 대해 더 적은 업데이트를 수행하도록 선택할 수 있으며, 이는 더 효율적인 디코딩을 초래할 수있다.</target>
        </trans-unit>
        <trans-unit id="659fa912faf7661e5693f814302e025b38ad17a1" translate="yes" xml:space="preserve">
          <source>If no user-defined content handler is found, then the system tries to load a specific</source>
          <target state="translated">사용자 정의 컨텐츠 핸들러를 찾을 수없는 경우 시스템은 특정</target>
        </trans-unit>
        <trans-unit id="3e962568371cc4db5f1331d80b7b2ea3d69bf501" translate="yes" xml:space="preserve">
          <source>If no value is set, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">값을 설정하지 않으면 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="65635a172a1530aa46f43e5e3e59c9e001180baa" translate="yes" xml:space="preserve">
          <source>If no value is specified, a system or implementation default value will be applied.</source>
          <target state="translated">값을 지정하지 않으면 시스템 또는 구현 기본값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3443f1520516224d5cac9f52fd3f3bc9e3c3f5f9" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">&lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt; 메서드 에 대한 호출로 주 정의 매개 변수가 명시 적으로 제공되지 않으면 &lt;code&gt;Locale&lt;/code&gt; 의 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e2d9f63d3b68d988634ea3a7fd560c86f5e146" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">&lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 주 정의 매개 변수를 명시 적으로 지정하지 않으면 &lt;code&gt;Locale&lt;/code&gt; 의 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4076d96bb4d80dea21dec4f9083af903b3282c51" translate="yes" xml:space="preserve">
          <source>If none of the above are true, &lt;code&gt;implies&lt;/code&gt; returns false.</source>
          <target state="translated">위의 어느 것도 해당하지 않는 경우, &lt;code&gt;implies&lt;/code&gt; 를 반환 거짓을.</target>
        </trans-unit>
        <trans-unit id="aa27ae8e73e51a59ee422ae500f77a07374ba6be" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, module, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup()&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">위의 경우에 해당되지 않는 경우 전체 액세스 (공개, 모듈, 패키지, 개인 및 보호)가 허용되는 경우입니다. 이 경우 접미사가 추가되지 않습니다. 이것은 원래 &lt;a href=&quot;methodhandles#lookup()&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt; 에서 가져온 객체에만 해당됩니다 . &lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; 에서&lt;/a&gt; 만든 개체 항상 액세스가 제한되며 접미사를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="65b4b808e5f83fdac6e6f8fa54fe10637573639b" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">위의 어느 경우에도 해당되지 않는 경우 전체 액세스 (공용, 패키지, 개인 및 보호)가 허용되는 경우입니다. 이 경우 접미사가 추가되지 않습니다. 이것은 원래 &lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt; 에서 얻은 객체에만 해당됩니다 . &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; 으로&lt;/a&gt; 만든 개체는 항상 액세스가 제한되며 접미사를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9afb92f74699e092dd43aa6f4a4f20ab8baaf008" translate="yes" xml:space="preserve">
          <source>If none of the package prefixes work, null is returned.</source>
          <target state="translated">작동하는 패키지 접두사가 없으면 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa3a39e0c5471c8e92b9112af6f11814ae21d0e" translate="yes" xml:space="preserve">
          <source>If none of the previous conditions hold then this thread's interrupt status will be set.</source>
          <target state="translated">이전 조건 중 어느 것도 유지되지 않으면이 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="346f69aa8643809549df322ad150080572449fc7" translate="yes" xml:space="preserve">
          <source>If none of these conditions is met, the MBean is invalid and the attempt to register it will generate &lt;a href=&quot;notcompliantmbeanexception&quot;&gt;&lt;code&gt;NotCompliantMBeanException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 조건 중 어느 것도 충족되지 않으면 MBean이 유효하지 않으며 등록을 시도하면 &lt;a href=&quot;notcompliantmbeanexception&quot;&gt; &lt;code&gt;NotCompliantMBeanException&lt;/code&gt; &lt;/a&gt; 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee9f8a416324d0ea9e24a3249a1da2412abc73d7" translate="yes" xml:space="preserve">
          <source>If not already closed, the input remains open until a Close message &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;received&lt;/a&gt;, or &lt;code&gt;abort&lt;/code&gt; is invoked, or an &lt;a href=&quot;websocket.listener#onError(java.net.http.WebSocket,java.lang.Throwable)&quot;&gt;error&lt;/a&gt; occurs.</source>
          <target state="translated">아직 닫히지 않은 경우 Close 메시지가 &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;수신&lt;/a&gt; 되거나 &lt;code&gt;abort&lt;/code&gt; 이 호출되거나 &lt;a href=&quot;websocket.listener#onError(java.net.http.WebSocket,java.lang.Throwable)&quot;&gt;오류가 발생할&lt;/a&gt; 때까지 입력이 열린 상태로 유지 됩니다. 가 발생할 .</target>
        </trans-unit>
        <trans-unit id="9f8a9a330958ea8b81d0d1085cfbfef23cbec83f" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메서드를 호출 하여 지정된 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="2c5743411e869e01038b5d76b71612dce8dfd329" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메소드의 호출로 지정된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf1d0245b93227342f069b480c62ecce5abc272e" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 완료되지 않은 경우, &lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt; 으로이 CompletableFuture를 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="716a361131a6632fa2e7d2e54111159994780e51" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;. Dependent CompletableFutures that have not already completed will also complete exceptionally, with a &lt;a href=&quot;completionexception&quot;&gt;&lt;code&gt;CompletionException&lt;/code&gt;&lt;/a&gt; caused by this &lt;code&gt;CancellationException&lt;/code&gt;.</source>
          <target state="translated">아직 완료하지 않은 경우,이 CompletableFuture를 &lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt; 과 함께 완료하십시오 . 아직 완료되지 않은 종속 CompletableFuture는 이 &lt;code&gt;CancellationException&lt;/code&gt; 으로 인한 &lt;a href=&quot;completionexception&quot;&gt; &lt;code&gt;CompletionException&lt;/code&gt; &lt;/a&gt; 과 함께 예외적으로 완료 됩니다 .</target>
        </trans-unit>
        <trans-unit id="3336ef80734923602b92caaa54e44a6a44b10fdf" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메서드에서 반환 된 값을 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2f1a9e000d1c1d155d951430a94c358745c05ace" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메소드가 리턴 한 값을 제공된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2832c345bb20d08c6428b67a080d7bc676ec986f" translate="yes" xml:space="preserve">
          <source>If not overriden, the resolving parent defaults to the parent element.</source>
          <target state="translated">재정의되지 않은 경우 해결 부모는 기본적으로 부모 요소로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="06df59153329c54021d8f318749947771342b429" translate="yes" xml:space="preserve">
          <source>If not running in a ForkJoinPool, this method is behaviorally equivalent to</source>
          <target state="translated">ForkJoinPool에서 실행되지 않는 경우이 방법은 동작과 동일합니다</target>
        </trans-unit>
        <trans-unit id="33cb4eee9f72e7c592a0781119cfa5815c0c26bf" translate="yes" xml:space="preserve">
          <source>If not specified, the Namespace URI is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. If not specified, the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정되지 않은 경우 네임 스페이스 URI는 &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 . 지정되지 않은 경우 접두사는 &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdc33934659b2005c4bd2af74fa05dccbb573691" translate="yes" xml:space="preserve">
          <source>If obj is non-null, it should be a primitive array of type TransferType. Otherwise, a ClassCastException is thrown. An ArrayIndexOutOfBoundsException may be thrown if the coordinates are not in bounds, or if obj is non-null and is not large enough to hold the pixel data.</source>
          <target state="translated">obj가 널이 아닌 경우 TransferType 유형의 기본 배열이어야합니다. 그렇지 않으면 ClassCastException이 발생합니다. 좌표가 경계 내에 있지 않거나 obj가 null이 아니고 픽셀 데이터를 저장할만큼 크지 않은 경우 ArrayIndexOutOfBoundsException이 throw 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4963d6f03243f1b1eefc52d1ee78e3de46655e5a" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompositeName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 CompositeName 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cfed25f27277239376cbbd5795fd1f2017c24525" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompoundName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 CompoundName의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1c9d5558d685db1a02cae49432f75e2eb93c619" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of LdapName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 LdapName의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bf13cf38688995f01fe92d7c8213b9203d51d95" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 Rdn의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b1bd38492a7c5fc97a66ea1dc538a1fb693b2c3" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, false is returned.</source>
          <target state="translated">obj가 null이거나 Rdn 인스턴스가 아닌 경우 false가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db27cf2143ef5e69d57f054992bd236034dac929" translate="yes" xml:space="preserve">
          <source>If object replacement is currently not enabled, and &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to ensure that the caller is permitted to enable the stream to do replacement of objects read from the stream.</source>
          <target state="translated">객체 교체가 현재 사용하고 있지 않은 경우 &lt;code&gt;enable&lt;/code&gt; 사실 및 설치된 보안 매니저가 존재하는,이 메소드는 최초로 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 과 방법을 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; 호출자가 스트림을 가능하게 할 수 있다는 것을 보증합니다 스트림에서 읽은 객체를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c47a2363c1646e07fb7efdcb6b37946f1291ed86" translate="yes" xml:space="preserve">
          <source>If object replacement is currently not enabled, and &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to ensure that the caller is permitted to enable the stream to do replacement of objects written to the stream.</source>
          <target state="translated">객체 교체가 현재 사용하고 있지 않은 경우 &lt;code&gt;enable&lt;/code&gt; 사실 및 설치된 보안 매니저가 존재하는,이 메소드는 최초로 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 과 방법을 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; 호출자가 스트림을 가능하게 할 수 있다는 것을 보증합니다 스트림에 기록 된 객체를 교체합니다.</target>
        </trans-unit>
        <trans-unit id="6bc0bc4fab7d5c4262f47e32108a9c0ec0a06d6f" translate="yes" xml:space="preserve">
          <source>If one is not found, it searches the set of &lt;code&gt;ScriptEngineFactory&lt;/code&gt; instances stored by the constructor for one with the specified name. If a &lt;code&gt;ScriptEngineFactory&lt;/code&gt; is found by either method, it is used to create instance of &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">하나를 찾지 못하면 생성자가 저장 한 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 인스턴스 세트 에서 지정된 이름을 가진 인스턴스를 검색합니다 . 경우 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 에이 중 하나의 방법으로 발견,의 인스턴스를 생성하는 데 사용됩니다 &lt;code&gt;ScriptEngine&lt;/code&gt; 를 검색 .</target>
        </trans-unit>
        <trans-unit id="624173e017b005ddaae7fe37b2623ee7c893a0a0" translate="yes" xml:space="preserve">
          <source>If one of the arguments does not occur in the pattern.</source>
          <target state="translated">패턴에서 인수 중 하나가 발생하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="491c4f907fd22e40d7d0381d99943007b7f1cc80" translate="yes" xml:space="preserve">
          <source>If one of the commands in a batch update fails to execute properly, this method throws a &lt;code&gt;BatchUpdateException&lt;/code&gt;, and a JDBC driver may or may not continue to process the remaining commands in the batch. However, the driver's behavior must be consistent with a particular DBMS, either always continuing to process commands or never continuing to process commands. If the driver continues processing after a failure, the array returned by the method &lt;code&gt;BatchUpdateException.getLargeUpdateCounts&lt;/code&gt; will contain as many elements as there are commands in the batch, and at least one of the elements will be the following:</source>
          <target state="translated">배치 업데이트의 명령 중 하나가 제대로 실행되지 않으면이 메서드는 &lt;code&gt;BatchUpdateException&lt;/code&gt; 을 발생시키고 JDBC 드라이버는 배치의 나머지 명령을 계속 처리하거나 처리하지 않을 수 있습니다. 그러나 드라이버의 동작은 항상 명령 처리를 계속하거나 명령 처리를 계속하지 않는 특정 DBMS와 일치해야합니다. 드라이버가 실패 후에도 처리를 계속하면 &lt;code&gt;BatchUpdateException.getLargeUpdateCounts&lt;/code&gt; 메서드에서 반환 된 배열 에 일괄 처리에있는 명령 수만큼의 요소가 포함되며 요소 중 하나 이상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a07c16265df1b097f41111154f5c947cf4a13b17" translate="yes" xml:space="preserve">
          <source>If one of the commands in a batch update fails to execute properly, this method throws a &lt;code&gt;BatchUpdateException&lt;/code&gt;, and a JDBC driver may or may not continue to process the remaining commands in the batch. However, the driver's behavior must be consistent with a particular DBMS, either always continuing to process commands or never continuing to process commands. If the driver continues processing after a failure, the array returned by the method &lt;code&gt;BatchUpdateException.getUpdateCounts&lt;/code&gt; will contain as many elements as there are commands in the batch, and at least one of the elements will be the following:</source>
          <target state="translated">일괄 업데이트의 명령 중 하나가 제대로 실행되지 않으면이 메서드는 &lt;code&gt;BatchUpdateException&lt;/code&gt; 을 발생시키고 JDBC 드라이버는 일괄 처리의 나머지 명령을 계속 처리 할 수도 있고 처리하지 않을 수도 있습니다. 그러나 드라이버의 동작은 항상 명령 처리를 계속하거나 명령 처리를 계속하지 않는 특정 DBMS와 일치해야합니다. 드라이버가 실패 후에도 처리를 계속하는 경우 &lt;code&gt;BatchUpdateException.getUpdateCounts&lt;/code&gt; 메서드에서 반환 된 배열 에는 일괄 처리에있는 명령 수만큼의 요소가 포함되며 요소 중 하나 이상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbb26d8aea49aec8452c4aea8b4bbd3bc4797c37" translate="yes" xml:space="preserve">
          <source>If one of the first two arguments is infinite and the other is zero, the result is NaN.</source>
          <target state="translated">처음 두 인수 중 하나가 무한이고 다른 인수가 0이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="4cca3576585cdb352327bec138c88e3a7951d775" translate="yes" xml:space="preserve">
          <source>If one of the provided element count is the special value &lt;code&gt;-1&lt;/code&gt;, then the element count in that position will be inferred from the remaining element counts and the element count of the flattened projection of this layout. For instance, a layout equivalent to the above &lt;code&gt;reshapeSeq&lt;/code&gt; can also be computed in the following ways:</source>
          <target state="translated">제공된 요소 개수 중 하나가 특수 값 &lt;code&gt;-1&lt;/code&gt; 이면 해당 위치의 요소 개수는 나머지 요소 개수와이 레이아웃의 평면 투영의 요소 개수에서 유추됩니다. 예를 들어, 위의 &lt;code&gt;reshapeSeq&lt;/code&gt; 에 해당하는 레이아웃 은 다음과 같은 방법으로도 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2cb09ff6c56a4c92e19e76c548f38b158889e4b" translate="yes" xml:space="preserve">
          <source>If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components.</source>
          <target state="translated">하나 또는 두 개의 권한 구성 요소가 레지스트리 기반 인 경우 URI는 해당 권한 구성 요소의 순서에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1cdcf3eae93e731adef7dce9b1512efd07547e12" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">어떤 이유로 든 하나 이상의 속성을 검색 할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 목록이 &lt;code&gt;attributes&lt;/code&gt; 배열 과 동일한 크기인지 확인해야합니다 . 주어진 속성이 검색되지 못하게하는 문제를 발견하려면 해당 속성에 대해 &lt;a href=&quot;#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6e2411b61caee1b0fdbbdceb845f12804209588" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">어떤 이유로 든 하나 이상의 속성을 검색 할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 목록이 &lt;code&gt;attributes&lt;/code&gt; 배열 과 동일한 크기인지 확인해야합니다 . 주어진 속성이 검색되지 못하게하는 문제를 발견하려면 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fb7857e904a130ed28ddd9eed419d0b930d6e9e" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 검색 할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 목록이 &lt;code&gt;attributes&lt;/code&gt; 배열 과 동일한 크기인지 확인해야합니다 . 주어진 속성을 검색 할 수없는 문제점을 발견하려면 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a570e550931dc8b2096c4798b37ec71a67373125" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 설정할 수없는 경우 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 입력 &lt;code&gt;AttributeList&lt;/code&gt; 가 출력과 동일한 크기인지 확인해야합니다 . 어떤 문제로 인해 주어진 속성이 검색 되지 않았 는지 알아 보려면 일반적으로 해당 속성에 대해 &lt;a href=&quot;#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다. (예를 들어, 두 속성의 값이 서로 일치하지 않아 거부되었을 수 있습니다. 둘 중 하나만 설정해도됩니다.)</target>
        </trans-unit>
        <trans-unit id="230dbeb4c4a040a775eadcb4d42ecfa395b556e8" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 설정할 수없는 경우 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 입력 &lt;code&gt;AttributeList&lt;/code&gt; 가 출력과 동일한 크기인지 확인해야합니다 . 어떤 문제로 인해 주어진 속성이 검색 되지 않았 는지 알아 보려면 일반적으로 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다. (예를 들어, 두 속성의 값이 서로 일치하지 않아 거부되었을 수 있습니다. 둘 중 하나만 설정해도됩니다.)</target>
        </trans-unit>
        <trans-unit id="1cb46e59026371f237c846d747b96cfab81aa6f7" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 설정할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 입력 된 &lt;code&gt;AttributeList&lt;/code&gt; 가 출력되는 것과 동일한 크기인지 확인해야합니다 . 주어진 속성을 검색 할 수없는 문제점을 발견하기 위해 일반적으로 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 는 있지만 작동하지 않을 수도 있습니다. 예를 들어, 두 속성의 값이 서로 일치하지 않아 거부되었을 수 있습니다. 둘 중 하나만 설정하는 것이 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab57ba0e0e796f21f0a41d005906eb71fb4cd0d" translate="yes" xml:space="preserve">
          <source>If one or more disconnected &lt;code&gt;RowSet&lt;/code&gt; objects are participating in a global transaction, they may wish to coordinate their synchronization commits to preserve data integrity and reduce the number of synchronization exceptions. If this is the case, an application should set the &lt;code&gt;CachedRowSet&lt;/code&gt; constant &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; and use the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;rollback&lt;/code&gt; methods defined in this interface to manage transaction boundaries.</source>
          <target state="translated">하나 이상의 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체가 전역 트랜잭션에 참여하는 경우 데이터 무결성을 유지하고 동기화 예외 수를 줄이기 위해 동기화 커밋을 조정할 수 있습니다. 이 경우 애플리케이션은 &lt;code&gt;CachedRowSet&lt;/code&gt; 상수 &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하고이 인터페이스에 정의 된 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;rollback&lt;/code&gt; 메서드를 사용하여 트랜잭션 경계를 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="fea5108f8ecd0c55ef6981d1ca12427bdd2d199c" translate="yes" xml:space="preserve">
          <source>If one value is a primitive array then the other must be a primitive array of the same type with the same elements.</source>
          <target state="translated">하나의 값이 기본 배열 인 경우 다른 값은 동일한 요소를 가진 동일한 유형의 기본 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="23324c117f5f2583f364f13ab7b02fbef6103829" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">한 값이 객체 배열이면 다른 값도 있어야하며 &lt;a href=&quot;../../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2342ef0932b8de2cf5319fdb221bf8d24533db0" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">한 값이 객체 배열이면 다른 값도 있어야하며 &lt;a href=&quot;../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="83b598a4bb6d8d15d44e8e6f9778b65445620655" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">한 값이 객체 배열이면 다른 값도 있어야하고 &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca221d63216bb033111f2713610351d2376eca45" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">하나의 값이 객체 배열이면 다른 값도 같아야하며 &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8317f7140fbe4d8e0a19dbbc989d6c95b4bba3de" translate="yes" xml:space="preserve">
          <source>If one value is null then the other must be too.</source>
          <target state="translated">하나의 값이 null이면 다른 값도 null이어야합니다.</target>
        </trans-unit>
        <trans-unit id="73766e9e928dc54454acb02c297d1f4e58f13c99" translate="yes" xml:space="preserve">
          <source>If only public access and unconditional access are allowed, the suffix is &quot;/publicLookup&quot;.</source>
          <target state="translated">공용 액세스 및 무조건 액세스 만 허용되는 경우 접미사는 &quot;/ publicLookup&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="46ccc3cea31a77de6874e4d69188651ef3350460" translate="yes" xml:space="preserve">
          <source>If only public access is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">공개 액세스 만 허용되는 경우 접미사는 &quot;/ public&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6d7a4b935aaeac5d27171aa447cb0be5037b635a" translate="yes" xml:space="preserve">
          <source>If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">내 보낸 패키지의 유형에 대한 공용 액세스 만 허용되는 경우 접미사는 &quot;/ public&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5b887737a3d95a66cbb55d332a4697c243ecd0a7" translate="yes" xml:space="preserve">
          <source>If only public and module access are allowed, the suffix is &quot;/module&quot;.</source>
          <target state="translated">공용 및 모듈 액세스 만 허용되는 경우 접미사는 &quot;/ module&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="17e35151d3a9c5e62004f06cdd120c3d5af02427" translate="yes" xml:space="preserve">
          <source>If only public and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">공개 및 패키지 액세스 만 허용되는 경우 접미사는 &quot;/ package&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="69d58dad869cac05ad492aa9acfab56072768dd8" translate="yes" xml:space="preserve">
          <source>If only public, module and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">공용, 모듈 및 패키지 액세스 만 허용되는 경우 접미사는 &quot;/ package&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5a749739e2c519e03259e6286361548abdc9b6a8" translate="yes" xml:space="preserve">
          <source>If only public, module, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">공용, 모듈, 패키지 및 개인 액세스 만 허용되는 경우 접미사는 &quot;/ private&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="78a5d707938565d1ab21a382651974405944eeaa" translate="yes" xml:space="preserve">
          <source>If only public, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">공개, 패키지 및 개인 액세스 만 허용되는 경우 접미사는 &quot;/ private&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a5e2e852e4e1da31c48b61f04aadf0f8e9d48694" translate="yes" xml:space="preserve">
          <source>If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.</source>
          <target state="translated">무조건 액세스 만 허용되는 경우 접미사는 &quot;/ publicLookup&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b505d5ce8be021b34190ba8758c0f40cdae3cfbe" translate="yes" xml:space="preserve">
          <source>If other values are desired, an application must set the property values explicitly. For example, the following line of code sets the maximum number of rows for the &lt;code&gt;CachedRowSet&lt;/code&gt; object</source>
          <target state="translated">다른 값이 필요한 경우 응용 프로그램에서 속성 값을 명시 적으로 설정해야합니다. 예를 들어 다음 코드 줄은 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체 의 최대 행 수를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="5ff5bcea26eb9f57c1f61e4d4b69139bd9e67391" translate="yes" xml:space="preserve">
          <source>If passed to the appropriate variant of java.beans.Beans.instantiate this method will be called in order to associate the newly instantiated Applet (JavaBean) with its AppletContext, AppletStub, and Container.</source>
          <target state="translated">적절한 java.beans.Beans.instantiate 변형에 전달되면 새로 인스턴스화 된 애플릿 (JavaBean)을 AppletContext, AppletStub 및 Container와 연관시키기 위해이 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63592e8ff0ed49f336b285894d4830d793307f4a" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; subsequent start requests are not affected by an interrupted loop operation.</source>
          <target state="translated">루핑 중에 재생이 중지되면 현재 루프 상태가 지워집니다. 후속 시작 요청은 인터럽트 된 루프 작업의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9cbc94cbe4e5c51dea79fe6a36851f807b7c43f" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; the behavior of subsequent loop and start requests is not affected by an interrupted loop operation.</source>
          <target state="translated">루핑 중에 재생이 중지되면 현재 루프 상태가 지워집니다. 후속 루프 및 시작 요청의 동작은 인터럽트 된 루프 작업의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e381a3ab9ce40b66156b275b2ddf1afe5445d87" translate="yes" xml:space="preserve">
          <source>If possible, display this frame in an appropriate location.</source>
          <target state="translated">가능하면이 프레임을 적절한 위치에 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="b532b85dabe94af369148e9d31febd94ae2e1477" translate="yes" xml:space="preserve">
          <source>If possible, display this frame in an appropriate location. Normally, this is not called, as the creator of the JInternalFrame will add the frame to the appropriate parent.</source>
          <target state="translated">가능하면이 프레임을 적절한 위치에 표시하십시오. 일반적으로 이것은 JInternalFrame의 생성자가 적절한 부모에 프레임을 추가하기 때문에 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d85adb7142d0513e17f4f180e854c7f586b64e2a" translate="yes" xml:space="preserve">
          <source>If possible, the SAX driver should provide the line position of the first character after the text associated with the document event. The first column in each line is column 1.</source>
          <target state="translated">가능한 경우 SAX 드라이버는 문서 이벤트와 관련된 텍스트 뒤의 첫 번째 문자의 줄 위치를 제공해야합니다. 각 줄의 첫 번째 열은 열 1입니다.</target>
        </trans-unit>
        <trans-unit id="04cf22c6258b3cdaaa6e80d2a29b8433dceb3a5d" translate="yes" xml:space="preserve">
          <source>If possible, the SAX driver should provide the line position of the first character after the text associated with the document event. The first line is line 1.</source>
          <target state="translated">가능한 경우 SAX 드라이버는 문서 이벤트와 관련된 텍스트 뒤의 첫 번째 문자의 줄 위치를 제공해야합니다. 첫 번째 줄은 1 번 줄입니다.</target>
        </trans-unit>
        <trans-unit id="f641bda12a9def737dfac1c3fb2b8970de8a9feb" translate="yes" xml:space="preserve">
          <source>If prehash is true, then the mode is Ed25519ph or Ed448ph</source>
          <target state="translated">prehash가 true이면 모드는 Ed25519ph 또는 Ed448ph입니다.</target>
        </trans-unit>
        <trans-unit id="49bbc2bd93bc284a0af94a66587e35a5d285e02f" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means ignore the case when comparing name components. If its value is not &quot;true&quot;, or if the property is not present, case is considered when comparing name components.</source>
          <target state="translated">있는 경우 &quot;true&quot;는 이름 구성 요소를 비교할 때 대소 문자를 무시 함을 의미합니다. 값이 &quot;true&quot;가 아니거나 속성이 없으면 이름 구성 요소를 비교할 때 대 / 소문자가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="76f581deb106b2ac36d486ca5972b20b2708e882" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means trim any leading and trailing whitespaces in a name component for comparison purposes. If its value is not &quot;true&quot;, or if the property is not present, blanks are significant.</source>
          <target state="translated">있는 경우 &quot;true&quot;는 비교 목적으로 이름 구성 요소에서 선행 및 후행 공백을 제거하는 것을 의미합니다. 값이 &quot;true&quot;가 아니거나 속성이 없으면 공백이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f71c029405d6c4413ebcbb2a962ddc2c412a1ce0" translate="yes" xml:space="preserve">
          <source>If present, specifies the escape string for overriding separator, escapes and quotes.</source>
          <target state="translated">존재하는 경우 구분 기호, 이스케이프 및 따옴표를 재정의하는 이스케이프 문자열을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b3051402e5a243fd5b4ebf35b610a599bf72fd9d" translate="yes" xml:space="preserve">
          <source>If present, specifies the string delimiting start of a quoted string.</source>
          <target state="translated">있는 경우 인용 문자열의 문자열 구분 시작을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="53a1150c587a660e881fe7821fcb847d00c55297" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">있는 경우 속성과 값을 구분하는 문자열을 지정합니다 (예 : &quot;age = 65&quot;의 &quot;=&quot;).</target>
        </trans-unit>
        <trans-unit id="ac3c844cdeac2520127d85d40f83a50ed68f9c88" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute-value-assertions when specifying multiple attribute/value pairs. (e.g. &quot;,&quot; in age=65,gender=male).</source>
          <target state="translated">있는 경우 여러 속성 / 값 쌍을 지정할 때 속성-값-어설 션을 구분하는 문자열을 지정합니다. (예 : 연령 = 65, 성별 = 남성에서 &quot;,&quot;).</target>
        </trans-unit>
        <trans-unit id="839f44a4939d27c69ac39a75a7ee01b1f1bbc830" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separators attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">존재하는 경우 속성을 값과 구분하는 문자열을 지정합니다 (예 : &quot;age = 65&quot;의 &quot;=&quot;).</target>
        </trans-unit>
        <trans-unit id="4e033c3e596848d293e0852aa5e0284f4620f551" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling &lt;code&gt;Doc&lt;/code&gt;'s &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an &lt;code&gt;InputStream&lt;/code&gt; or &lt;code&gt;Reader&lt;/code&gt;, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that &lt;code&gt;Doc&lt;/code&gt; implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">&lt;code&gt;Doc&lt;/code&gt; 의 &lt;code&gt;getReaderForText()&lt;/code&gt; 또는 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 메서드 를 호출 하거나 인쇄 데이터 소스가 이미 &lt;code&gt;InputStream&lt;/code&gt; 또는 &lt;code&gt;Reader&lt;/code&gt; 이기 때문에 클라이언트에서 스트림으로 인쇄 데이터를 가져 오는 경우 인쇄 서비스는 항상 이러한 스트림을 닫아야합니다. 모든 작업 완료 조건에서 클라이언트. 다음과 같은주의 사항이 있습니다. 인쇄 데이터 자체가 스트림 인 경우 서비스는 항상이를 닫습니다. 인쇄 데이터가 스트림으로 요청 될 수있는 것이라면 서비스는 종료하기 전에 스트림을 얻은 경우에만 스트림을 닫습니다. 즉, 인쇄 서비스가 데이터를 스트림으로 요청할 수 있다고해서 데이터를 요청한다는 의미는 아닙니다. &lt;code&gt;Doc&lt;/code&gt; 서비스를 닫기 위해 서비스에 의존하는 구현자는 서비스의 요청에 대한 응답으로 만 이러한 스트림을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="a8b99e1ebf742f5bd861cd2fd56fba8c921820bf" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling Doc's &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an InputStream or Reader, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that Doc implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">클라이언트에서 스트림으로 인쇄 데이터를 얻는 경우 Doc의 &lt;code&gt;getReaderForText()&lt;/code&gt; 또는 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 를 호출하여인쇄 데이터 소스가 이미 InputStream 또는 Reader이기 때문에 인쇄 서비스는 모든 작업 완료 조건에서 클라이언트에 대해 항상 이러한 스트림을 닫아야합니다. 다음과 같은 경고가 있습니다. 인쇄 데이터 자체가 스트림 인 경우 서비스는 항상 데이터를 닫습니다. 인쇄 데이터가 스트림으로 요청 될 수있는 것이면 서비스는 스트림을 종료하기 전에 스트림을 얻은 경우에만 스트림을 닫습니다. 즉, 인쇄 서비스가 데이터를 스트림으로 요청할 수 있다고해서 데이터를 닫기 위해 서비스에 의존하는 Doc 구현자가 서비스의 요청에 대한 응답으로 만 해당 스트림을 작성해야 함을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e52617ffc7a119c98adb4f2641d106944c6408e3" translate="yes" xml:space="preserve">
          <source>If public and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">공용 및 패키지 액세스가 허용되는 경우 접미사는 &quot;/ package&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e557a0139389c49d0d62c39321c1775efbceecee" translate="yes" xml:space="preserve">
          <source>If public, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">공용, 패키지 및 개인 액세스가 허용되는 경우 접미사는 &quot;/ private&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="698e747d05614178dfac851043daa01f20a613ea" translate="yes" xml:space="preserve">
          <source>If readUnshared is called to deserialize a back-reference (the stream representation of an object which has been written previously to the stream), an ObjectStreamException will be thrown.</source>
          <target state="translated">역 참조를 직렬화 해제하기 위해 readUnshared를 호출하면 (이전에 스트림에 기록 된 객체의 스트림 표현) ObjectStreamException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4f57444325034269269b979e9040fba82af28a1" translate="yes" xml:space="preserve">
          <source>If readUnshared returns successfully, then any subsequent attempts to deserialize back-references to the stream handle deserialized by readUnshared will cause an ObjectStreamException to be thrown.</source>
          <target state="translated">readUnshared가 성공적으로 리턴되면, readUnshared에 의해 역 직렬화 된 스트림 핸들에 대한 역 참조를 역 직렬화하려고 시도하면 ObjectStreamException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa301e6f70a966a031213bd64c45f05d89ac7164" translate="yes" xml:space="preserve">
          <source>If resolution should be possible, but the data is invalid, the resolver style should be used to determine an appropriate level of leniency, which may require throwing a &lt;code&gt;DateTimeException&lt;/code&gt; or &lt;code&gt;ArithmeticException&lt;/code&gt;. If no resolution is possible, the resolve method must return null.</source>
          <target state="translated">확인이 가능하지만 데이터가 유효하지 않은 경우, 리졸버 스타일을 사용하여 적절한 수준의 신뢰도를 결정해야합니다 . &lt;code&gt;DateTimeException&lt;/code&gt; 또는 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생해야 할 수도 있습니다 . 해결 방법이 없으면 resolve 메서드는 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="837d6a0cf6ebc9ea0b7b6f419729d9668f063846" translate="yes" xml:space="preserve">
          <source>If reuse is set to &lt;code&gt;true&lt;/code&gt;, an action should not keep a reference to the event object after the action has completed.</source>
          <target state="translated">재사용이 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 , 액션이 완료된 후 액션은 이벤트 객체에 대한 참조를 유지하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3812495ff2c8cc9bdfa1044d03962dc8bf6711c5" translate="yes" xml:space="preserve">
          <source>If running in a ForkJoinPool, the pool may first be expanded to ensure sufficient parallelism available during the call to &lt;code&gt;blocker.block()&lt;/code&gt;.</source>
          <target state="translated">ForkJoinPool에서 실행중인 경우 &lt;code&gt;blocker.block()&lt;/code&gt; 호출하는 동안 사용 가능한 병렬 처리를 보장하기 위해 풀을 먼저 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b345c507b8eb5308663521a467d3fdf7b2c7424" translate="yes" xml:space="preserve">
          <source>If screen devices are reconfigured such that the coordinate system is affected, the behavior of existing Robot objects is undefined.</source>
          <target state="translated">좌표계가 영향을 받도록 화면 장치를 재구성하면 기존 로봇 객체의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae78817156ff952aba10e581c466f3b983c1decc" translate="yes" xml:space="preserve">
          <source>If script or extensions are present and variant is missing, no underscore is added before the &quot;#&quot;.</source>
          <target state="translated">스크립트 또는 확장자가 존재하고 변형이 누락 된 경우 &quot;#&quot;앞에 밑줄이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bacc3b39afe6555d76b04639e544a3a769989526" translate="yes" xml:space="preserve">
          <source>If set on an &lt;a href=&quot;objectinputstream&quot;&gt;&lt;code&gt;ObjectInputStream&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt;&lt;code&gt;checkInput(FilterInfo)&lt;/code&gt;&lt;/a&gt; method is called to validate classes, the length of each array, the number of objects being read from the stream, the depth of the graph, and the total number of bytes read from the stream.</source>
          <target state="translated">온 설정 한 경우 &lt;a href=&quot;objectinputstream&quot;&gt; &lt;code&gt;ObjectInputStream&lt;/code&gt; &lt;/a&gt; 상기 &lt;a href=&quot;#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt; &lt;code&gt;checkInput(FilterInfo)&lt;/code&gt; &lt;/a&gt; 방법은 유효성 클래스를 호출하고, 각각의 어레이의 길이는, 오브젝트의 개수가 스트림으로부터 판독되며, 상기 그래프의 깊이와 총 바이트 스트림으로부터 판독 .</target>
        </trans-unit>
        <trans-unit id="d68a475ad0b21c04ea65cb73ab3824fc6e8e1d2f" translate="yes" xml:space="preserve">
          <source>If set to &lt;a href=&quot;httpclient.version#HTTP_2&quot;&gt;HTTP/2&lt;/a&gt;, then each request will attempt to upgrade to HTTP/2. If the upgrade succeeds, then the response to this request will use HTTP/2 and all subsequent requests and responses to the same &lt;a href=&quot;https://tools.ietf.org/html/rfc6454#section-4&quot;&gt;origin server&lt;/a&gt; will use HTTP/2. If the upgrade fails, then the response will be handled using HTTP/1.1</source>
          <target state="translated">&lt;a href=&quot;httpclient.version#HTTP_2&quot;&gt;HTTP / 2로&lt;/a&gt; 설정된 경우 각 요청은 HTTP / 2로 업그레이드를 시도합니다. 업그레이드가 성공하면이 요청에 대한 응답은 HTTP / 2를 사용하고 동일한 &lt;a href=&quot;https://tools.ietf.org/html/rfc6454#section-4&quot;&gt;원본 서버에&lt;/a&gt; 대한 모든 후속 요청 및 응답 은 HTTP / 2를 사용합니다. 업그레이드에 실패하면 HTTP / 1.1을 사용하여 응답이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a63684a8335dacd2334257d6490511210af93630" translate="yes" xml:space="preserve">
          <source>If set to true, assume that the input is certified (see section 2.13 in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;]) when parsing [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;].</source>
          <target state="translated">True로 설정이 입력이 인증되는 것을 가정하면 ([섹션 2.13를 참조 &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]) 구문 분석 할 때 &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="d2c6e214cdfb887d470d9d97c680958dc9ffb627" translate="yes" xml:space="preserve">
          <source>If set to true, assume that the input is certified (see section 2.13 in [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;]) when parsing [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;].</source>
          <target state="translated">True로 설정이 입력이 인증되는 것을 가정하면 ([섹션 2.13를 참조 &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]) 구문 분석 할 때 &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="aca1859a49861db1474a56d8e3d2f23a51a9b08b" translate="yes" xml:space="preserve">
          <source>If set, the creation time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">설정된 경우, 생성 시간은 ZIP 파일 또는 ZIP 파일 형식의 스트림으로 출력 될 때 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 의 확장 된 타임 스탬프 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="254aa9b5d6babc55c52a29bf015e860182b09607" translate="yes" xml:space="preserve">
          <source>If set, the data will be written out in a top-down manner, the first scanline being written first.</source>
          <target state="translated">설정된 경우 데이터는 하향식으로 기록되며 첫 번째 스캔 라인이 먼저 기록됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
