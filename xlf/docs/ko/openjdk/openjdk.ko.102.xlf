<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="d3fe3fca46a00d556efb3e52ff334ccc25f6d2f2" translate="yes" xml:space="preserve">
          <source>If set, the last access time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">설정된 경우, 마지막 액세스 시간은 ZIP 파일 또는 ZIP 파일 형식의 스트림으로 출력 될 때 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 의 확장 된 타임 스탬프 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f308d30cc56ad52b3bab469509470a688175d5d" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamic call site, the JVM must choose one &lt;code&gt;CallSite&lt;/code&gt; object and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored, and their dynamic call site invocations proceed with the originally chosen target object.</source>
          <target state="translated">여러 스레드가 단일 동적 호출 사이트에 대해 부트 스트랩 메소드를 동시에 실행하는 경우 JVM은 하나의 &lt;code&gt;CallSite&lt;/code&gt; 오브젝트를 선택 하여 모든 스레드에 시각적으로 설치해야합니다. 다른 부트 스트랩 메소드 호출은 완료 할 수 있지만 결과는 무시되고 동적 호출 사이트 호출은 원래 선택된 대상 오브젝트로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="18b1b4b5ea1cd9ac6c8f6934c943af5a9030e95e" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamically-computed call site or constant, the JVM must choose one bootstrap method result and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored.</source>
          <target state="translated">여러 스레드가 동적으로 계산 된 단일 호출 사이트 또는 상수에 대해 부트 스트랩 메소드를 동시에 실행하는 경우 JVM은 하나의 부트 스트랩 메소드 결과를 선택하고 모든 스레드에 가시적으로 설치해야합니다. 다른 부트 스트랩 메서드 호출은 완료 할 수 있지만 그 결과는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="653e73bbef0b2a0664fc9c6111cdb7e33befdd39" translate="yes" xml:space="preserve">
          <source>If simply changing the name of the given node is not possible, the following operations are performed: a new node is created, any registered event listener is registered on the new node, any user data attached to the old node is removed from that node, the old node is removed from its parent if it has one, the children are moved to the new node, if the renamed node is an &lt;code&gt;Element&lt;/code&gt; its attributes are moved to the new node, the new node is inserted at the position the old node used to have in its parent's child nodes list if it has one, the user data that was attached to the old node is attached to the new node.</source>
          <target state="translated">단순히 주어진 노드의 이름을 변경할 수없는 경우 다음 작업이 수행됩니다. 새 노드가 생성되고 등록 된 이벤트 리스너가 새 노드에 등록되고 이전 노드에 연결된 모든 사용자 데이터가 해당 노드에서 제거됩니다. 이전 노드가있는 경우 상위 노드에서 제거되고, 하위 노드가 새 노드로 이동하고, 이름이 바뀐 노드가 &lt;code&gt;Element&lt;/code&gt; 이면 해당 속성이 새 노드로 이동되고, 새 노드가 이전 노드가 사용 된 위치에 삽입됩니다. 부모의 자식 노드 목록에 포함하려면 이전 노드에 연결된 사용자 데이터가 새 노드에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c65182d3cadba09ddb23fbbd8a75757afd7c8e" translate="yes" xml:space="preserve">
          <source>If size requirements are explicitly specified for the paragraph, use that requirements. Otherwise, use the requirements of the superclass &lt;a href=&quot;../paragraphview&quot;&gt;&lt;code&gt;ParagraphView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단락에 대해 크기 요구 사항이 명시 적으로 지정된 경우 해당 요구 사항을 사용합니다. 그렇지 않으면 수퍼 클래스 &lt;a href=&quot;../paragraphview&quot;&gt; &lt;code&gt;ParagraphView&lt;/code&gt; &lt;/a&gt; 의 요구 사항을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a30312a3ee2ee2f769f60fddc7aed8e6e676a91e" translate="yes" xml:space="preserve">
          <source>If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns as required.</source>
          <target state="translated">그렇다면 SQL AS 절을 사용하여 계산 된 열의 이름을 제공하거나 필요에 따라 열의 별칭 이름을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3080743f4d15c8fc1f75465fc6801e428e44fe7c" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of PropertyChangeListeners and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">명명 된 속성으로 일부 리스너가 추가 된 경우 반환되는 배열은 PropertyChangeListeners와 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 의 혼합입니다 . 호출 메소드가 리스너를 구별하는 데 관심이있는 경우 각 요소를 테스트하여 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 인지 확인 하고 캐스트를 수행 한 후 매개 변수를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cf497c1785865189fe796ed0e1d220915d011be" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of VetoableChangeListeners and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">명명 된 속성으로 일부 리스너가 추가 된 경우 반환 된 배열은 VetoableChangeListeners와 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 의 혼합입니다 . 호출 메소드가 리스너를 구별하는 데 관심이있는 경우 각 요소를 테스트하여 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 인지 확인 하고 캐스트를 수행하고 매개 변수를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc3c7dd73763675362089e6dbd76aa79687340e" translate="yes" xml:space="preserve">
          <source>If some of the clause functions are virtual methods on an instance, the instance itself can be conveniently placed in an initial invariant loop &quot;variable&quot;, using an initial clause like &lt;code&gt;new MethodHandle[]{identity(ObjType.class)}&lt;/code&gt;. In that case, the instance reference will be the first iteration variable value, and it will be easy to use virtual methods as clause parts, since all of them will take a leading instance reference matching that value.</source>
          <target state="translated">절 함수 중 일부가 인스턴스의 가상 메서드 인 경우 인스턴스 자체는 &lt;code&gt;new MethodHandle[]{identity(ObjType.class)}&lt;/code&gt; 와 같은 초기 절을 사용하여 초기 고정 루프 &quot;변수&quot;에 편리하게 배치 할 수 있습니다 . 이 경우 인스턴스 참조는 첫 번째 반복 변수 값이되며 가상 메서드는 모두 해당 값과 일치하는 선행 인스턴스 참조를 사용하므로 절 부분으로 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4809b1b1dafea4dfced97329f0d27180c7e418e7" translate="yes" xml:space="preserve">
          <source>If some other window is already always-on-top then the relative order between these windows is unspecified (depends on platform). No window can be brought to be over the always-on-top window except maybe another always-on-top window.</source>
          <target state="translated">다른 창이 이미 항상 맨 위에있는 경우이 창 사이의 상대적 순서는 지정되지 않습니다 (플랫폼에 따라 다름). 다른 항상 위에있는 창을 제외하고는 항상 위에있는 창 위에 창을 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c852ab67f6ae0af547293dc6511f0705244b787" translate="yes" xml:space="preserve">
          <source>If specified, these insets act as padding around the cell renderer when laying out and painting the &quot;selected&quot; item in the combo box.</source>
          <target state="translated">지정된 경우 이러한 인세 트는 콤보 상자에서 &quot;선택된&quot;항목을 레이아웃하고 칠할 때 셀 렌더러 주위의 패딩 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5a8e20a8b6edf9f99ddfa05066dd30cd8c55b9b1" translate="yes" xml:space="preserve">
          <source>If specified, these insets act as padding around the cell renderer when laying out and painting the &quot;selected&quot; item in the combo box. These insets add to those specified by the cell renderer.</source>
          <target state="translated">지정된 경우 이러한 인세 트는 콤보 상자에서 &quot;선택된&quot;항목을 레이아웃하고 칠할 때 셀 렌더러 주위의 패딩 역할을합니다. 이러한 삽입은 셀 렌더러에서 지정한 삽입에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a5c010eef59c15644a375468c16c24a59e5c43de" translate="yes" xml:space="preserve">
          <source>If starting any of the processes throws an Exception, all processes are forcibly destroyed.</source>
          <target state="translated">프로세스를 시작할 때 예외가 발생하면 모든 프로세스가 강제로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ee377394ee6fe11a94b05880ae8a4e56e23eb11b" translate="yes" xml:space="preserve">
          <source>If state is &lt;a href=&quot;cardterminals.state#ALL&quot;&gt;&lt;code&gt;State.ALL&lt;/code&gt;&lt;/a&gt;, this method returns all CardTerminals encapsulated by this object. If state is &lt;a href=&quot;cardterminals.state#CARD_PRESENT&quot;&gt;&lt;code&gt;State.CARD_PRESENT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cardterminals.state#CARD_ABSENT&quot;&gt;&lt;code&gt;State.CARD_ABSENT&lt;/code&gt;&lt;/a&gt;, it returns all CardTerminals where a card is currently present or absent, respectively.</source>
          <target state="translated">state가 &lt;a href=&quot;cardterminals.state#ALL&quot;&gt; &lt;code&gt;State.ALL&lt;/code&gt; &lt;/a&gt; 이면이 메서드는이 개체에 의해 캡슐화 된 모든 CardTerminals를 반환합니다. state가 &lt;a href=&quot;cardterminals.state#CARD_PRESENT&quot;&gt; &lt;code&gt;State.CARD_PRESENT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cardterminals.state#CARD_ABSENT&quot;&gt; &lt;code&gt;State.CARD_ABSENT&lt;/code&gt; &lt;/a&gt; 이면 카드가 현재 존재하거나 존재하지 않는 모든 CardTerminals를 각각 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97e2c677edafae44cb499869bec55d8b0b28cb2c" translate="yes" xml:space="preserve">
          <source>If state is &lt;a href=&quot;cardterminals.state#CARD_INSERTION&quot;&gt;&lt;code&gt;State.CARD_INSERTION&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cardterminals.state#CARD_REMOVAL&quot;&gt;&lt;code&gt;State.CARD_REMOVAL&lt;/code&gt;&lt;/a&gt;, it returns all CardTerminals for which an insertion (or removal, respectively) was detected during the last call to &lt;a href=&quot;#waitForChange()&quot;&gt;waitForChange()&lt;/a&gt;. If &lt;code&gt;waitForChange()&lt;/code&gt; has not been called on this object, &lt;code&gt;CARD_INSERTION&lt;/code&gt; is equivalent to &lt;code&gt;CARD_PRESENT&lt;/code&gt; and &lt;code&gt;CARD_REMOVAL&lt;/code&gt; is equivalent to &lt;code&gt;CARD_ABSENT&lt;/code&gt;. For an example of the use of &lt;code&gt;CARD_INSERTION&lt;/code&gt;, see &lt;a href=&quot;#waitForChange()&quot;&gt;&lt;code&gt;waitForChange()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">state가 &lt;a href=&quot;cardterminals.state#CARD_INSERTION&quot;&gt; &lt;code&gt;State.CARD_INSERTION&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cardterminals.state#CARD_REMOVAL&quot;&gt; &lt;code&gt;State.CARD_REMOVAL&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#waitForChange()&quot;&gt;waitForChange ()에&lt;/a&gt; 대한 마지막 호출 중에 삽입 (또는 제거)이 감지 된 모든 CardTerminals를 반환합니다 . 경우 &lt;code&gt;waitForChange()&lt;/code&gt; 이 객체에 호출되지, &lt;code&gt;CARD_INSERTION&lt;/code&gt; 은 동일합니다 &lt;code&gt;CARD_PRESENT&lt;/code&gt; 및 &lt;code&gt;CARD_REMOVAL&lt;/code&gt; 은 동일합니다 &lt;code&gt;CARD_ABSENT&lt;/code&gt; . &lt;code&gt;CARD_INSERTION&lt;/code&gt; 사용의 예는 &lt;a href=&quot;#waitForChange()&quot;&gt; &lt;code&gt;waitForChange()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36119d6ef751d0ba1a40bc06d8c08c0232acb626" translate="yes" xml:space="preserve">
          <source>If still no result bundle is found, the base name alone is looked up. If this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.</source>
          <target state="translated">여전히 결과 번들이 없으면 기본 이름 만 찾습니다. 여전히 실패하면 &lt;code&gt;MissingResourceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49c2d956b15c160db2755278d76b95411d1638e9" translate="yes" xml:space="preserve">
          <source>If such a service has been registered with the context, or one of its nesting context's, in the case where a context delegate to its context to satisfy a service request, then the BeanContextServiceProvider associated with the service is asked to provide an instance of that service.</source>
          <target state="translated">이러한 서비스가 컨텍스트 또는 중첩 컨텍스트 중 하나에 등록 된 경우 컨텍스트가 컨텍스트에 위임되어 서비스 요청을 충족시키는 경우 서비스와 연관된 BeanContextServiceProvider는 해당 서비스의 인스턴스를 제공하도록 요청됩니다. .</target>
        </trans-unit>
        <trans-unit id="94b0570a3ef5bacc1df2844b6f6f55155f5164cd" translate="yes" xml:space="preserve">
          <source>If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by any bytes that otherwise would have been the next input data as of the time of the call to &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;code&gt;IOException&lt;/code&gt; 이 발생하지 않으면, 스트림은 가장 최근의 &lt;code&gt;mark&lt;/code&gt; 호출 이후 (또는 &lt;code&gt;mark&lt;/code&gt; 가 호출되지 않은 경우 파일의 시작 이후) 읽은 모든 바이트 가 후속으로 재 공급되도록 상태로 재설정됩니다. &lt;code&gt;read&lt;/code&gt; 메소드의 호출자 다음에, &lt;code&gt;reset&lt;/code&gt; 호출의 시점에서 다음의 입력 데이터가 된 바이트가 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba67a915702ddd93a2439399e9e5620bf22a0c62" translate="yes" xml:space="preserve">
          <source>If such an error is thrown then subsequent invocations of the iterator will make a best effort to locate and instantiate the next available provider, but in general such recovery cannot be guaranteed.</source>
          <target state="translated">이러한 오류가 발생하면 이후 반복자를 호출하면 사용 가능한 다음 제공자를 찾고 인스턴스화하기 위해 최선을 다하지만 일반적으로 이러한 복구를 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ca56d49fb83daa43c8cab6e57a0bc195c1fa094" translate="yes" xml:space="preserve">
          <source>If support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use only the following standard button masks: &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt;.</source>
          <target state="translated">확장 마우스 버튼에 대한 지원 이 Java에 의해 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; 된 경우 다음 표준 버튼 마스크 만 사용할 수 있습니다 : &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d39904b337a524b3be8e74dcbdcdc3b283655905" translate="yes" xml:space="preserve">
          <source>If support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use the standard button masks and masks for existing extended mouse buttons, if the mouse has more then three buttons. In that way, it is allowed to use the button masks corresponding to the buttons in the range from 1 to &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장 마우스 버튼에 대한 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에 의해 활성화 된 경우 마우스에 버튼이 세 개 이상있는 경우 기존 확장 마우스 버튼에 대한 표준 버튼 마스크 및 마스크를 사용할 수 있습니다. 이렇게하면 1부터 &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt; 까지의 범위에서 버튼에 해당하는 버튼 마스크를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="486f3c00239a42cba8b1916fb667e0081bff0684" translate="yes" xml:space="preserve">
          <source>If support for the extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to create &lt;code&gt;MouseEvent&lt;/code&gt; objects only with the standard buttons: &lt;code&gt;NOBUTTON&lt;/code&gt;, &lt;code&gt;BUTTON1&lt;/code&gt;, &lt;code&gt;BUTTON2&lt;/code&gt;, and &lt;code&gt;BUTTON3&lt;/code&gt;.</source>
          <target state="translated">확장 된 마우스 버튼에 대한 지원 이 Java에 의해 &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; 된 경우 표준 버튼 인 &lt;code&gt;NOBUTTON&lt;/code&gt; , &lt;code&gt;BUTTON1&lt;/code&gt; , &lt;code&gt;BUTTON2&lt;/code&gt; 및 &lt;code&gt;BUTTON3&lt;/code&gt; 으로 만 &lt;code&gt;MouseEvent&lt;/code&gt; 객체 를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65884caffeef70616af6ac015fb22950976842d5" translate="yes" xml:space="preserve">
          <source>If support for the extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to create &lt;code&gt;MouseEvent&lt;/code&gt; objects with the standard buttons. In case the support for extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java, then in addition to the standard buttons, &lt;code&gt;MouseEvent&lt;/code&gt; objects can be created using buttons from the range starting from 4 to &lt;a href=&quot;../mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt; if the mouse has more than three buttons.</source>
          <target state="translated">확장 마우스 버튼에 대한 &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에서 활성화 된 경우 표준 버튼으로 &lt;code&gt;MouseEvent&lt;/code&gt; 객체 를 생성 할 수 있습니다 . 확장 된 마우스 버튼에 대한 &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에 의해 활성화 된 경우 표준 버튼 외에도 마우스에 3 개 이상의 버튼이있는 경우 4부터 &lt;a href=&quot;../mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt; 까지 범위의 버튼을 사용하여 &lt;code&gt;MouseEvent&lt;/code&gt; 객체를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d3c9f547885ed5dc664bee523aaf2e97a59a19a" translate="yes" xml:space="preserve">
          <source>If supported by the underlying SSL/TLS/DTLS implementation, application name negotiation mechanisms such as &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application-Layer Protocol Negotiation (ALPN), can negotiate application-level values between peers.</source>
          <target state="translated">기본 SSL / TLS / DTLS 구현에서 지원하는 경우 &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt; , ALPN (Application-Layer Protocol Negotiation) 과 같은 애플리케이션 이름 협상 메커니즘 은 피어간에 애플리케이션 수준 값을 협상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b56b6a2c479a52bb0285125852b4bd46d6cc96d3" translate="yes" xml:space="preserve">
          <source>If supported by the underlying SSL/TLS/DTLS implementation, application name negotiation mechanisms such as &lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application-Layer Protocol Negotiation (ALPN), can negotiate application-level values between peers.</source>
          <target state="translated">기본 SSL / TLS / DTLS 구현에서 지원하는 경우 &lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt; , ALPN (Application-Layer Protocol Negotiation) 과 같은 애플리케이션 이름 협상 메커니즘 은 피어간에 애플리케이션 수준 값을 협상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="483297556e0d86a729fc879bc3d6a3a654a16eca" translate="yes" xml:space="preserve">
          <source>If system exclusive data from &lt;code&gt;SysexMessages&lt;/code&gt; objects is being transmitted using MIDI wire protocol, only the initial 0xF0 status byte, the system exclusive data itself, and the final 0xF7 (EOX) byte should be propagated; any 0xF7 status bytes used to indicate that a &lt;code&gt;SysexMessage&lt;/code&gt; contains continuing system exclusive data should not be propagated via MIDI wire protocol.</source>
          <target state="translated">&lt;code&gt;SysexMessages&lt;/code&gt; 객체의 시스템 독점 데이터가 MIDI 유선 프로토콜을 사용하여 전송되는 경우 초기 0xF0 상태 바이트, 시스템 독점 데이터 자체 및 최종 0xF7 (EOX) 바이트 만 전파되어야합니다. &lt;code&gt;SysexMessage&lt;/code&gt; 에 지속적인 시스템 독점 데이터가 포함되어 있음을 나타내는 데 사용되는 0xF7 상태 바이트는 MIDI 와이어 프로토콜을 통해 전파되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8a60148766d9542dcdda7613f880094d44b2ef2c" translate="yes" xml:space="preserve">
          <source>If system properties &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; and &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; are defined or they are defined in the file &quot;sound.properties&quot;, they are used to retrieve default lines. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If the respective property is not set, or the mixer requested in the property is not installed or does not provide the requested line, all installed mixers are queried for the requested line type. A Line will be returned from the first mixer providing the requested line type.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; , &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt; , &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 및 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 이 정의되거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 줄을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 해당 속성이 설정되지 않았거나 속성에서 요청 된 믹서가 설치되지 않았거나 요청 된 라인을 제공하지 않으면 설치된 모든 믹서가 요청 된 라인 유형에 대해 쿼리됩니다. 요청 된 라인 유형을 제공하는 첫 번째 믹서에서 라인이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a8e3d47700ce7e07788d64cbfa2cd41b86d9c136" translate="yes" xml:space="preserve">
          <source>If target is _self, the action is to change the value of the &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute and fires a &lt;code&gt;ChangedUpdate&lt;/code&gt; event.</source>
          <target state="translated">target이 _self 인 경우 작업은 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 속성 의 값을 변경하고 &lt;code&gt;ChangedUpdate&lt;/code&gt; 이벤트를 발생시키는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="1f583398dc1f86dc2870e17e17525bfe7bcb7fe2" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">&quot;java.util.logging.config.class&quot;특성이 설정되면 특성 값이 클래스 이름으로 처리됩니다. 지정된 클래스가로드되고 객체가 인스턴스화되며 해당 객체의 생성자가 초기 구성을 읽습니다. 이 객체는 다른 시스템 속성을 사용하여 구성을 제어 할 수 있습니다. 대체 구성 클래스는 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 을 사용하여 LogManager에서 속성을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c21737341f78d589edcf2b473c1e9d4710529e7" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; system property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">&quot;java.util.logging.config.class&quot;시스템 속성이 설정된 경우 속성 값은 클래스 이름으로 처리됩니다. 지정된 클래스가로드되고 객체가 인스턴스화되며 해당 객체의 생성자가 초기 구성에서 읽기를 담당합니다. (이 객체는 다른 시스템 속성을 사용하여 구성을 제어 할 수 있습니다.) 대체 구성 클래스는 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 을 사용하여 LogManager에서 속성을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee9a28b9f37694fc322c18e7908dd9236e4f1f5e" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.file&quot; system property is set, then the property value specifies the properties file to be read as the new configuration. Otherwise, the LogManager default configuration is used.</source>
          <target state="translated">&quot;java.util.logging.config.file&quot;시스템 특성이 설정된 경우 특성 값은 새 구성으로 읽을 특성 파일을 지정합니다. 그렇지 않으면 LogManager 기본 구성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3e35bcf72871950c117a29249ba322eaf7916a" translate="yes" xml:space="preserve">
          <source>If the 'getMethod' field contains the name of a valid operation descriptor, then the method described by the operation descriptor is executed. The response from the method is returned as the value of the attribute. If the operation fails or the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">'getMethod'필드에 유효한 작업 설명 자의 이름이 포함되어 있으면 작업 설명자가 설명하는 방법이 실행됩니다. 메소드의 응답은 속성 값으로 리턴됩니다. 작업이 실패하거나 반환 된 값이 선언 된 속성 유형과 호환되지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e0d548ba22d2542cb9fd6382914ac5396917edaa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#%3Cinit%3E(java.security.SecureRandomParameters)&quot;&gt;&lt;code&gt;SecureRandomSpi(SecureRandomParameters)&lt;/code&gt;&lt;/a&gt; constructor is overridden in an implementation, it will always be called whenever a &lt;code&gt;SecureRandom&lt;/code&gt; is instantiated. Precisely, if an object is instantiated with one of &lt;code&gt;SecureRandom&lt;/code&gt;'s &lt;code&gt;getInstance&lt;/code&gt; methods &lt;em&gt;without&lt;/em&gt; a &lt;a href=&quot;securerandomparameters&quot;&gt;&lt;code&gt;SecureRandomParameters&lt;/code&gt;&lt;/a&gt; parameter, the constructor will be called with a &lt;code&gt;null&lt;/code&gt; argument and the implementation is responsible for creating its own &lt;code&gt;SecureRandomParameters&lt;/code&gt; parameter for use when &lt;a href=&quot;#engineGetParameters()&quot;&gt;&lt;code&gt;engineGetParameters()&lt;/code&gt;&lt;/a&gt; is called. If an object is instantiated with one of &lt;code&gt;SecureRandom&lt;/code&gt;'s &lt;code&gt;getInstance&lt;/code&gt; methods &lt;em&gt;with&lt;/em&gt; a &lt;code&gt;SecureRandomParameters&lt;/code&gt; argument, the constructor will be called with that argument. The &lt;a href=&quot;#engineGetParameters()&quot;&gt;&lt;code&gt;engineGetParameters()&lt;/code&gt;&lt;/a&gt; method must not return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;#%3Cinit%3E(java.security.SecureRandomParameters)&quot;&gt; &lt;code&gt;SecureRandomSpi(SecureRandomParameters)&lt;/code&gt; &lt;/a&gt; 생성자 구현에서 재정의되는 때마다 항상 호출됩니다 &lt;code&gt;SecureRandom&lt;/code&gt; 의이 인스턴스화됩니다. 객체가 하나 인스턴스화하면 정확하게, &lt;code&gt;SecureRandom&lt;/code&gt; 의 의 &lt;code&gt;getInstance&lt;/code&gt; 방법 &lt;em&gt;이없는 &lt;/em&gt;&lt;a href=&quot;securerandomparameters&quot;&gt; &lt;code&gt;SecureRandomParameters&lt;/code&gt; 의&lt;/a&gt; 매개 변수, 생성자가 호출됩니다 &lt;code&gt;null&lt;/code&gt; 인수 및 구현은 자신의 창조에 대한 책임 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 을 할 때 사용하는 매개 변수 &lt;a href=&quot;#engineGetParameters()&quot;&gt; &lt;code&gt;engineGetParameters()&lt;/code&gt; &lt;/a&gt; 호출된다. 대상은 중 하나를 인스턴스화하는 경우 &lt;code&gt;SecureRandom&lt;/code&gt; 의 의 &lt;code&gt;getInstance&lt;/code&gt; 메소드&lt;em&gt;와 &lt;/em&gt; &lt;code&gt;SecureRandomParameters&lt;/code&gt; 의 인수 생성자는 해당 인수로 호출됩니다. &lt;a href=&quot;#engineGetParameters()&quot;&gt; &lt;code&gt;engineGetParameters()&lt;/code&gt; &lt;/a&gt; 메서드는 반환하지 않아야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd0e8651509209ab66f4363379a0875ab48d6ad" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#FOREGROUND&quot;&gt;&lt;code&gt;FOREGROUND&lt;/code&gt;&lt;/a&gt; attribute is set, its &lt;code&gt;Paint&lt;/code&gt; will be used as the background, otherwise the &lt;code&gt;Paint&lt;/code&gt; currently on the &lt;code&gt;Graphics&lt;/code&gt; will be used. If the &lt;a href=&quot;#BACKGROUND&quot;&gt;&lt;code&gt;BACKGROUND&lt;/code&gt;&lt;/a&gt; attribute is set, its &lt;code&gt;Paint&lt;/code&gt; will be used as the foreground, otherwise the system will find a contrasting color to the (resolved) background so that the text will be visible.</source>
          <target state="translated">&lt;a href=&quot;#FOREGROUND&quot;&gt; &lt;code&gt;FOREGROUND&lt;/code&gt; &lt;/a&gt; 속성이 설정되어 있으면 해당 &lt;code&gt;Paint&lt;/code&gt; 가 배경으로 사용되고 그렇지 않으면 현재 &lt;code&gt;Graphics&lt;/code&gt; 에있는 &lt;code&gt;Paint&lt;/code&gt; 가 사용됩니다. &lt;a href=&quot;#BACKGROUND&quot;&gt; &lt;code&gt;BACKGROUND&lt;/code&gt; &lt;/a&gt; 속성이 설정되어 있으면 해당 &lt;code&gt;Paint&lt;/code&gt; 가 전경으로 사용됩니다. 그렇지 않으면 시스템이 (해결 된) 배경과 대조되는 색상을 찾아 텍스트가 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="266d9b29b8861792af1fe586314983e8903d9fa3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#eval(java.lang.String)&quot;&gt;&lt;code&gt;eval(java.lang.String)&lt;/code&gt;&lt;/a&gt; method is not running, does nothing.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;#eval(java.lang.String)&quot;&gt; &lt;code&gt;eval(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메소드가 실행되고 있지 않은, 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86337241a9668cc6a25c97b5de65d911d14a1894" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#redirectErrorStream()&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">는 IF &lt;a href=&quot;#redirectErrorStream()&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; 의&lt;/a&gt; 속성이 설정되어있는 &lt;code&gt;true&lt;/code&gt; ,이 방법으로 재 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b85fc122285cb0d2f89cc05f312ee0e46a0a070d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;setInput(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method was called to provide a buffer for input, the input buffer's position will be advanced by the number of bytes consumed by this operation, even in the event that a &lt;a href=&quot;dataformatexception&quot;&gt;&lt;code&gt;DataFormatException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우] &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;setInput(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 방법은 입력 버퍼를 제공하기 위해 호출 된, 입력 버퍼의 위치에도있는 경우에는,이 조작에 의해 소비 된 바이트의 수에 의해 전진 될 것이다 &lt;a href=&quot;dataformatexception&quot;&gt; &lt;code&gt;DataFormatException&lt;/code&gt; 가&lt;/a&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="beaa63bfc2c275017816960a621f79d777650f26" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;setInput(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method was called to provide a buffer for input, the input buffer's position will be advanced by the number of bytes consumed by this operation.</source>
          <target state="translated">경우] &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;setInput(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 방법은 입력 버퍼를 제공하기 위해 호출 된, 입력 버퍼의 위치는이 동작에 의해 소비 된 바이트의 수에 의해 전진 될 것이다.</target>
        </trans-unit>
        <trans-unit id="89d95c390fbfbed6f9512b14bde317e19394155e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt;&lt;code&gt;staticPermissionsOnly()&lt;/code&gt;&lt;/a&gt; method returns true, then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">는 IF &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt; &lt;code&gt;staticPermissionsOnly()&lt;/code&gt; &lt;/a&gt; 메소드가 true를 돌려, 그 권한은, 구축시에 제공된 PermissionCollection에 대해서 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3202df3f64a60f68be2f6e8445b0bee61ca858" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../java.base/java/util/properties&quot;&gt;&lt;code&gt;Properties&lt;/code&gt;&lt;/a&gt; file &lt;code&gt;swing.properties&lt;/code&gt; exists and contains the key &lt;code&gt;swing.defaultlaf&lt;/code&gt;, use its value as the default look and feel class name. The location that is checked for &lt;code&gt;swing.properties&lt;/code&gt; may vary depending upon the implementation of the Java platform. Typically the &lt;code&gt;swing.properties&lt;/code&gt; file is located in the &lt;code&gt;conf&lt;/code&gt; subdirectory of the Java installation directory. Refer to the release notes of the implementation being used for further details.</source>
          <target state="translated">경우 &lt;a href=&quot;../../../java.base/java/util/properties&quot;&gt; &lt;code&gt;Properties&lt;/code&gt; &lt;/a&gt; 파일의 &lt;code&gt;swing.properties&lt;/code&gt; 가 존재하고 키 포함 &lt;code&gt;swing.defaultlaf&lt;/code&gt; 가를 기본 모양과 느낌 클래스 이름으로 그 값을 사용합니다. &lt;code&gt;swing.properties&lt;/code&gt; 를 확인하는 위치 는 Java 플랫폼의 구현에 따라 다를 수 있습니다. 일반적으로 &lt;code&gt;swing.properties&lt;/code&gt; 파일은 Java 설치 디렉토리 의 &lt;code&gt;conf&lt;/code&gt; 하위 디렉토리에 있습니다. 자세한 내용은 사용중인 구현의 릴리스 정보를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0cf976d251facbb1b28639a31b11358b94746e84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;beaninfo&quot;&gt;&lt;code&gt;BeanInfo&lt;/code&gt;&lt;/a&gt; for this type has a &lt;a href=&quot;beandescriptor&quot;&gt;&lt;code&gt;BeanDescriptor&lt;/code&gt;&lt;/a&gt; which defined a &quot;persistenceDelegate&quot; attribute, the value of this named attribute is returned.</source>
          <target state="translated">이 유형 의 &lt;a href=&quot;beaninfo&quot;&gt; &lt;code&gt;BeanInfo&lt;/code&gt; &lt;/a&gt; 에 &quot;persistenceDelegate&quot;속성을 정의한 &lt;a href=&quot;beandescriptor&quot;&gt; &lt;code&gt;BeanDescriptor&lt;/code&gt; &lt;/a&gt; 가 있으면 이 이름 지정된 속성의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f7796e655e99564bb42833b6c22ae781567c8b7e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">는 IF &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; 의&lt;/a&gt; 속성이 설정되어있는 &lt;code&gt;true&lt;/code&gt; ,이 방법으로 재 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6369ec721b8ca4ab5fda1157ad5cc4775754c615" translate="yes" xml:space="preserve">
          <source>If the &lt;a id=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">IF로 &lt;a id=&quot;floatDPrec&quot;&gt;변환&lt;/a&gt; 인 &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'E'&lt;/code&gt; 또는 &lt;code&gt;'f'&lt;/code&gt; , 그 정밀도의 소수점 이하의 자리수이다. 정밀도가 지정되지 않은 경우 &lt;code&gt;6&lt;/code&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="69cea4d19b20fb91d97db82c5ca57aaf842e28d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a name=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">IF로 &lt;a name=&quot;floatDPrec&quot;&gt;변환&lt;/a&gt; 인 &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'E'&lt;/code&gt; 또는 &lt;code&gt;'f'&lt;/code&gt; , 그 정밀도의 소수점 이하의 자리수이다. 정밀도가 지정되지 않으면 &lt;code&gt;6&lt;/code&gt; 으로 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5059e8ee90e4d07843498ec51dc8abef786de5aa" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[member type definition anonymous]&lt;/b&gt; exists:</source>
          <target state="translated">경우] &lt;b&gt;[회원 유형 정의 익명]&lt;/b&gt; 존재한다 :</target>
        </trans-unit>
        <trans-unit id="b3bdad546a4d7a971b883151ac70a2ccbe1f0095" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[type definition anonymous]&lt;/b&gt; exists:</source>
          <target state="translated">경우] &lt;b&gt;[유형 정의 익명]&lt;/b&gt; 존재한다 :</target>
        </trans-unit>
        <trans-unit id="224235c33cd803b74bad7dc5b6641bf25c3410c2" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[type definition]&lt;/b&gt; property exists:</source>
          <target state="translated">경우] &lt;b&gt;[유형 정의]&lt;/b&gt; 속성이 존재 :</target>
        </trans-unit>
        <trans-unit id="ea735b3ad144dc0d3c88616e2055c7a3baba85a5" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[validity]&lt;/b&gt; property exists AND is &lt;em&gt;&quot;invalid&quot;&lt;/em&gt; or &lt;em&gt;&quot;notKnown&quot;&lt;/em&gt;: the {target namespace} and {name} properties of the declared type if available, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;b&gt;[유효 기간]&lt;/b&gt; 속성이 존재하고있다 &lt;em&gt;&quot;무효&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;notKnown&quot;&lt;/em&gt; 다음 {대상 네임 스페이스} 및 가능한 경우 선언 된 형태의 {이름} 속성, 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5654c5178b9647add1bfe15b4562bdf804149ac" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[validity]&lt;/b&gt; property exists and is &lt;em&gt;&quot;valid&quot;&lt;/em&gt;:</source>
          <target state="translated">는 IF &lt;b&gt;[유효 기간]&lt;/b&gt; 속성이 존재하고있다 &lt;em&gt;&quot;유효&quot;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="244d88b2fe1f7cc3d006bcc6bed47c61fe2ec794" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;zh&quot;&lt;/code&gt;-to-&lt;code&gt;&quot;zh&quot;&lt;/code&gt; mapping isn't included in the map, a simple replacement will be performed and the customized list won't include &lt;code&gt;&quot;zh&quot;&lt;/code&gt; and &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&quot;zh&quot;&lt;/code&gt; Di의 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 매핑이 맵에 포함되지 않은 단순 교체가 수행되고 사용자 정의 목록은 포함되지 않습니다 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f4d1d76d4c61640485815093054acc02ce819f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="1c680cd1a5cd595f752bed838baa38292f42bbcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given and the argument is not a &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt; , then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하고 인수가되지이다 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 가&lt;/a&gt; , 다음 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="6a276179b3d9aede60085715e083872d2bc9bb28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given and the argument is not a &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하고 인수가되지이다 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 가&lt;/a&gt; , 다음 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3ca6b4a24528a74561304ff78b46e45f7ce091" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="95f5e2ee606537dc80cd0c08600e71779319b292" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="705393d5e4190c15bb4ded3f92e669b7967af3af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with &lt;code&gt;'0'&lt;/code&gt; prefix.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 출력은 항상 시작됩니다 &lt;code&gt;'0'&lt;/code&gt; 접두사.</target>
        </trans-unit>
        <trans-unit id="d94fd5d1c396bfff4fed3e4917313944fa0d8ce4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;&quot;0x&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되었을 경우, 출력은 항상 기수 지시자로 시작됩니다 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af351499ffe1eb584449ad1db1312af2f6169806" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;'0'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되었을 경우, 출력은 항상 기수 지시자로 시작됩니다 &lt;code&gt;'0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e2b33eac4b29de7dc276798ef6bb121e0f191c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 다음 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="193a49527f28f69b767038d67c1984e036b12529" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then the decimal separator will always be present.</source>
          <target state="translated">경우] &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 소수점이 항상 존재할 것이다.</target>
        </trans-unit>
        <trans-unit id="170d2f39d6b7a451069152ef956aa45571ac5f4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'('&lt;/code&gt; or &lt;code&gt;','&lt;/code&gt; flags are given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;'('&lt;/code&gt; 또는 &lt;code&gt;','&lt;/code&gt; 플래그가 지정되고있는 경우, &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="25f8f50b77134591d75e17a674bec028e9c6e997" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'+'&lt;/code&gt; flag is given and the value is positive or zero (or floating-point positive zero), then a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;) will be prepended.</source>
          <target state="translated">경우] &lt;code&gt;'+'&lt;/code&gt; 플래그가 지정하고, 값이 양수 또는 제로 (또는 부동 소수점 긍정적 영) 다음, &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;'\u002b'&lt;/code&gt; ) 붙을.</target>
        </trans-unit>
        <trans-unit id="dd8701b10b903c76286404a520374517bcb6cb05" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a id=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize()&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;','&lt;/code&gt; ( &lt;code&gt;'\u002c'&lt;/code&gt; ) &lt;a id=&quot;L10nGroup&quot;&gt;플래그는&lt;/a&gt; , 그 로케일 특정 주어진다 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;세퍼레이터 그룹화&lt;/a&gt; 로케일에 의해 정의 된 간격으로 세퍼레이터를 적어도 상당한 최상위 자릿수의 문자열의 정수 부분을 스캐닝하고 삽입하여 삽입 &lt;a href=&quot;../text/decimalformat#getGroupingSize()&quot;&gt;그룹핑 크기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="910241aebecc3c9182f2e0462c8f58f123333d6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a name=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;','&lt;/code&gt; ( &lt;code&gt;'\u002c'&lt;/code&gt; ) &lt;a name=&quot;L10nGroup&quot;&gt;플래그는&lt;/a&gt; , 그 로케일 특정 주어진다 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;세퍼레이터 그룹화&lt;/a&gt; 로케일에 의해 정의 된 간격으로 세퍼레이터를 적어도 상당한 최상위 자릿수의 문자열의 정수 부분을 스캐닝하고 삽입하여 삽입 &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;그룹핑 크기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44a9f549cf29b75acc2fdec3fc183e7f16568846" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;','&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="45726f7fab2e09c7f3869df2e50226749801e01e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given, then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;','&lt;/code&gt; 플래그가 지정되고있는 경우, &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="970c69f921423c9cb9e926402bc01ce17c9690e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'-'&lt;/code&gt; flag is not given, then the space padding will occur before the sign.</source>
          <target state="translated">경우 &lt;code&gt;'-'&lt;/code&gt; 플래그가 지정되어 있지 않은 경우, 공간 패딩은 기호 앞에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4999add0ec4ab7e8f065de52e1702ab41f20c0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given and the value is negative, then the zero padding will occur after the sign.</source>
          <target state="translated">경우 &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되어 값이 부의되어, 다음 제로 패딩은 기호 다음에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c36904575776fe73769eda50759d8e13da3acc3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 부여되는 출력 기수 지시자 또는 기호 (존재하는 경우) 이후의 선두에 제로 필드 폭으로 패딩한다.</target>
        </trans-unit>
        <trans-unit id="b5e7f4a54ddb769b1293d2814dfdf865f8198b97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded with leading zeros to the field width following any indication of sign.</source>
          <target state="translated">경우 &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되는 출력 기호의 표시를 다음과 폭 필드에 0을 선도하는 패딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f0743f520ad52ab8654c0fd8007d4814742634" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit()&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되고, 그 로케일 특정 &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit()&quot;&gt;제로 숫자&lt;/a&gt; 기호 문자 뒤에 삽입되어있는 경우와되어 제 비제 자리 전에, 문자열의 길이가 요구 된 필드 폭과 동일 할 때까지.</target>
        </trans-unit>
        <trans-unit id="ba1bcf00b5c45bf451134d21adaed5e63f1fcd56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되고, 그 로케일 특정 &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;제로 숫자&lt;/a&gt; 기호 문자 뒤에 삽입되어있는 경우와되어 제 비제 자리 전에, 문자열의 길이가 요구 된 필드 폭과 동일 할 때까지.</target>
        </trans-unit>
        <trans-unit id="e6f16828d0308872e7e04a7c1ddeb45e9f4f1750" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt; point lies outside the grid, the following rules are used. The column index is returned as zero if &lt;code&gt;x&lt;/code&gt; lies to the left of the layout for a left-to-right container or to the right of the layout for a right-to-left container. The column index is returned as the number of columns if &lt;code&gt;x&lt;/code&gt; lies to the right of the layout in a left-to-right container or to the left in a right-to-left container. The row index is returned as zero if &lt;code&gt;y&lt;/code&gt; lies above the layout, and as the number of rows if &lt;code&gt;y&lt;/code&gt; lies below the layout. The orientation of a container is determined by its &lt;code&gt;ComponentOrientation&lt;/code&gt; property.</source>
          <target state="translated">경우] &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt; 격자 점 밖에 놓여은 다음의 규칙이 사용된다. &lt;code&gt;x&lt;/code&gt; 가 왼쪽에서 오른쪽 컨테이너의 경우 레이아웃의 왼쪽에 있거나 오른쪽에서 왼쪽 컨테이너의 경우 레이아웃의 오른쪽에있는 경우 열 인덱스는 0으로 반환됩니다 . &lt;code&gt;x&lt;/code&gt; 가 왼쪽에서 오른쪽 컨테이너의 레이아웃 오른쪽에 있거나 오른쪽에서 왼쪽 컨테이너의 왼쪽에있는 경우 열 인덱스는 열 수로 반환됩니다 . &lt;code&gt;y&lt;/code&gt; 가 레이아웃 위에 있으면 행 인덱스는 0으로 반환되고 , &lt;code&gt;y&lt;/code&gt; 가 레이아웃 아래에 있으면 행 수로 반환됩니다 . 컨테이너의 방향은 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="63ecf98d0ab81bb97ce68818ba3aa39c86211b49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; function in the agent library returns an error then an &lt;a href=&quot;agentinitializationexception&quot;&gt;&lt;code&gt;AgentInitializationException&lt;/code&gt;&lt;/a&gt; is thrown. The return value from the &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; can then be obtained by invoking the &lt;a href=&quot;agentinitializationexception#returnValue()&quot;&gt;&lt;code&gt;returnValue&lt;/code&gt;&lt;/a&gt; method on the exception.</source>
          <target state="translated">에이전트 라이브러리 의 &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; 함수가 오류를 반환하면 &lt;a href=&quot;agentinitializationexception&quot;&gt; &lt;code&gt;AgentInitializationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 그런 다음 예외에 대해 &lt;a href=&quot;agentinitializationexception#returnValue()&quot;&gt; &lt;code&gt;returnValue&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; 의 반환 값을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ecc4eb34ec8dfb382771373ad86df4d2c178e13" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Collection&lt;/code&gt; will be modified by one thread while another thread is calling a method of a Collection &lt;code&gt;CertStore&lt;/code&gt; that has been initialized with this &lt;code&gt;Collection&lt;/code&gt;, the &lt;code&gt;Collection&lt;/code&gt; must have fail-fast iterators.</source>
          <target state="translated">는 IF &lt;code&gt;Collection&lt;/code&gt; 다른 스레드가 수집하는 방법 호출되는 동안 하나 개의 스레드에 의해 수정되는 &lt;code&gt;CertStore&lt;/code&gt; 에 이로 초기화 된 &lt;code&gt;Collection&lt;/code&gt; 의 &lt;code&gt;Collection&lt;/code&gt; 르파 반복자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="810e8374c563e183f8b4590c3bc968fbd81b2167" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CompositeData&lt;/code&gt; came from an earlier version of &lt;em&gt;J&lt;/em&gt;, some items might not be present. In this case, the corresponding setters will not be called.</source>
          <target state="translated">&lt;code&gt;CompositeData&lt;/code&gt; 가 이전 버전의 &lt;em&gt;J&lt;/em&gt; 에서 온 경우 일부 항목이 없을 수 있습니다. 이 경우 해당 세터가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71b4bf78e68bc6776b7a8f7a0eb4ed1d04a8d512" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Event&lt;/code&gt;'s type was not specified by initializing the event before the method was called.</source>
          <target state="translated">메소드가 호출되기 전에 이벤트를 초기화 하여 &lt;code&gt;Event&lt;/code&gt; 유형이 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="203c00aa85f63e7b6b9375fddd15c02205fb7dda" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Event&lt;/code&gt;'s type was not specified by initializing the event before the method was called. Specification of the Event's type as &lt;code&gt;null&lt;/code&gt; or an empty string will also trigger this exception.</source>
          <target state="translated">메소드가 호출되기 전에 이벤트를 초기화 하여 &lt;code&gt;Event&lt;/code&gt; 유형이 지정되지 않은 경우. 이벤트 유형을 &lt;code&gt;null&lt;/code&gt; 또는 빈 문자열로 지정하면이 예외도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="02b4cc8da4d2810c0fbe1d7c64fd610170148d2b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;
 ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">&lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 지연이 아직 경과되지 않은 기존 지연 작업이 취소됩니다. &lt;code&gt; ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않으면 기존 정기 작업의 향후 실행이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="179c5197a088bdfb3577b89615e0f80069ec54a3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">는 IF &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 이 설정되어있는 &lt;code&gt;false&lt;/code&gt; , 지연 시간이 경과하고 있지 않는 기존의 지연 태스크는 삭제됩니다. &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않으면 향후 기존 작업의 향후 실행이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="924b95b5bc360f5419eb164ad25c4917e3384c4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Graphics2D&lt;/code&gt; object cannot handle the curved segments that the &lt;code&gt;PathIterator&lt;/code&gt; object returns then it can call the alternate &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform,double)&quot;&gt;&lt;code&gt;getPathIterator&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Shape&lt;/code&gt;, which flattens the &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;Graphics2D&lt;/code&gt; 객체가 곡선 세그먼트 (segment)를 처리 할 수 있음을 &lt;code&gt;PathIterator&lt;/code&gt; 객체 반환 다음은 대체 호출 할 수 있습니다 &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform,double)&quot;&gt; &lt;code&gt;getPathIterator&lt;/code&gt; 의&lt;/a&gt; 방법 &lt;code&gt;Shape&lt;/code&gt; 평평하게, &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d9438386cfe32fda0c1181ccd31aab76978f092" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;InvocationHandler&lt;/code&gt; is for an MXBean, then the parameters of a method are converted from the type declared in the MXBean interface into the corresponding mapped type, and the return value is converted from the mapped type into the declared type. For example, with the method</source>
          <target state="translated">상기 중간 &lt;code&gt;InvocationHandler&lt;/code&gt; MXBean에위한 다음 방법의 파라미터는 해당 타입에 매핑 MXBean의 인터페이스에서 선언 된 형태로 변환되고, 복귀 값은 선언 된 유형에 맵핑 형태로 변환된다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="db17038cfaa4ef45c73437ed292d512029f6bfe8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JInternalFrame&lt;/code&gt; is not in maximized state, returns &lt;code&gt;getBounds()&lt;/code&gt;; otherwise, returns the bounds that the &lt;code&gt;JInternalFrame&lt;/code&gt; would be restored to.</source>
          <target state="translated">는 IF &lt;code&gt;JInternalFrame&lt;/code&gt; 의가 최대화 상태가 아닌 반환 &lt;code&gt;getBounds()&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;JInternalFrame&lt;/code&gt; 이 복원 될 경계를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f060428dfdce4f587aa2a33814a603772ec95345" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this calls the view's &lt;code&gt;getBaseline()&lt;/code&gt; method.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 뷰의 호출 &lt;code&gt;getBaseline()&lt;/code&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="2d2acc95bb253287fb1fd9ad280f5e3c68a344b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this calls the view's &lt;code&gt;getBaseline()&lt;/code&gt; method. Otherwise, the default implementation is called.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 뷰의 호출 &lt;code&gt;getBaseline()&lt;/code&gt; 메소드를. 그렇지 않으면 기본 구현이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3f2bc6a4dfcf47dbe29117aa68de225f1c61e8cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; method.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 반환 뷰의 결과 &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="1bd4ebb8a1743bab39929e4ec06130e5519f66ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; method. Otherwise, the default implementation is called.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 반환 뷰의 결과 &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; 방법. 그렇지 않으면 기본 구현이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b88a2323263a45207c7b90c89107a58d6356d56a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method.</source>
          <target state="translated">는 IF &lt;code&gt;JLayer&lt;/code&gt; 의 견해 구성 요소가 아닌 &lt;code&gt;null&lt;/code&gt; 이 반환 뷰의 결과 &lt;code&gt;getMaximumSize()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="78f3308c92a131ac53ba0a2b91ae5625bc8378a8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</target>
        </trans-unit>
        <trans-unit id="30e2482d382c7844747a1e9c47c53ce8993e3afa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="cd6e2b2d459272e76855c9dfdd3c3d186a8512b9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</target>
        </trans-unit>
        <trans-unit id="3e114e0c18eb9a3a04e50b88c65e47b3d1177a2d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="1909e9311585c50274c3f90139597ea7f32cfbeb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">If the &lt;code&gt;JLayer&lt;/code&gt; 's view component is not &lt;code&gt;null&lt;/code&gt; , this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</target>
        </trans-unit>
        <trans-unit id="b773147646e5d6ae4684d585a997f76f520542ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="3f268e97c59dcc626388a2e991c9c9562516a82d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; uses the directory syntax, as described above under &lt;a href=&quot;#directory&quot;&gt;&quot;connector addresses based on directory entries&quot;&lt;/a&gt;, then the client may obtain it as just explained, or client and server may both know the appropriate directory entry to use. For example, if the connector server for the Whatsit agent uses the entry &lt;code&gt;whatsit-agent-connector&lt;/code&gt; in the RMI registry on host &lt;code&gt;myhost&lt;/code&gt;, then client and server can both know that the appropriate &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 이 위에서 &lt;a href=&quot;#directory&quot;&gt;&quot;디렉토리 항목을 기반으로하는 커넥터 주소&quot;에&lt;/a&gt; 설명 된대로 디렉토리 구문을 사용하는 경우, 클라이언트는 방금 설명한대로이를 얻거나 클라이언트와 서버가 사용할 적절한 디렉토리 항목을 알 수 있습니다. 예를 들어, Whatsit 에이전트의 커넥터 서버가 호스트 &lt;code&gt;myhost&lt;/code&gt; 의 RMI 레지스트리에있는 &lt;code&gt;whatsit-agent-connector&lt;/code&gt; 항목을 사용하는 경우 클라이언트와 서버는 적절한 &lt;code&gt;JMXServiceURL&lt;/code&gt; 이 다음과 같은 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f826af6b5dd95bfc92e77f04fdf460591da5f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; was generated by the server, as described above under &lt;a href=&quot;#servergen&quot;&gt;&quot;connector addresses generated by the server&quot;&lt;/a&gt;, then the client will need to obtain it directly or indirectly from the server. Typically, the server makes the &lt;code&gt;JMXServiceURL&lt;/code&gt; available by storing it in a file or a lookup service.</source>
          <target state="translated">는 IF &lt;code&gt;JMXServiceURL&lt;/code&gt; 서버에서 생성하고, 같은에서 설명한 &lt;a href=&quot;#servergen&quot;&gt;&quot;서버에서 생성 커넥터 주소&quot;&lt;/a&gt; , 클라이언트는 서버로부터 직접 또는 간접적으로 획득해야한다. 일반적으로 서버는 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 파일 또는 검색 서비스에 저장하여 사용 가능 하게합니다 .</target>
        </trans-unit>
        <trans-unit id="19e53ac3ee0ca858d684bd217c73cfeb534f1225" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt;, the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned, or &lt;code&gt;null&lt;/code&gt; if an error occured. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</source>
          <target state="translated">If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt; , the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned, or &lt;code&gt;null&lt;/code&gt; if an error occured. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</target>
        </trans-unit>
        <trans-unit id="7fc52b341e17306f0b31074b4f7a8dcfcbafb512" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt;, the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</source>
          <target state="translated">If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt; , the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</target>
        </trans-unit>
        <trans-unit id="b5e161a884b01a34270547339690293148ba8fa6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LayoutManager&lt;/code&gt; installed on this container is an instance of the &lt;code&gt;LayoutManager2&lt;/code&gt; interface, then the &lt;a href=&quot;layoutmanager2#invalidateLayout(java.awt.Container)&quot;&gt;&lt;code&gt;LayoutManager2.invalidateLayout(Container)&lt;/code&gt;&lt;/a&gt; method is invoked on it supplying this &lt;code&gt;Container&lt;/code&gt; as the argument.</source>
          <target state="translated">If the &lt;code&gt;LayoutManager&lt;/code&gt; installed on this container is an instance of the &lt;code&gt;LayoutManager2&lt;/code&gt; interface, then the &lt;a href=&quot;layoutmanager2#invalidateLayout(java.awt.Container)&quot;&gt; &lt;code&gt;LayoutManager2.invalidateLayout(Container)&lt;/code&gt; &lt;/a&gt; method is invoked on it supplying this &lt;code&gt;Container&lt;/code&gt; as the argument.</target>
        </trans-unit>
        <trans-unit id="e3f171d07666393092d63f7170ed5ec052f7118d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Level&lt;/code&gt; of the specified logger is &lt;code&gt;null&lt;/code&gt;, which means that this logger's effective level is inherited from its parent, an empty string will be returned.</source>
          <target state="translated">지정된 로거 의 &lt;code&gt;Level&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 ,이 로거의 유효 레벨이 부모로부터 상속되는 경우는 빈 캐릭터 라인이 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="6ebbc0e52293490f8f9b76660317e3c20fc9979e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../../java.base/java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../../java.base/java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="458d82c56d9fb33c66e562fe6ab97aea8cc80904" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;MBeanPermission&lt;/code&gt; 의 확인에 성공, MBean에의 클래스는 그 것을 확인하여 검증 &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt; 의미한다 &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f890b35cefa98c94269d1a9a764077652d426848" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Object&lt;/code&gt; to be tested is not a &lt;code&gt;QName&lt;/code&gt; or is &lt;code&gt;null&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;Object&lt;/code&gt; to be tested is not a &lt;code&gt;QName&lt;/code&gt; or is &lt;code&gt;null&lt;/code&gt; , then this method returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="021af7bb755cf93cf54c9f5f352c98d0f4ca4622" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ObservedAttribute&lt;/code&gt; contains more than one period, for example &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt;, then the above rules are applied iteratively. Here,</source>
          <target state="translated">경우] &lt;code&gt;ObservedAttribute&lt;/code&gt; 는 예를 들어, 하나 이상의주기를 포함 &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt; 후 상기 규칙은 반복적으로 적용된다. 여기,</target>
        </trans-unit>
        <trans-unit id="ea89dee9c534a6485cf68abb91d3ac324905d7e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; method, it is unbound from the directory by this method.</target>
        </trans-unit>
        <trans-unit id="7cb7f5f842a73d2190c2e8a4561e728aa057bb8f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">경우 &lt;code&gt;RMIServerImpl&lt;/code&gt; 의이 바이는 JNDI 디렉토리에 바인드 된 &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; 방법,이 방법으로 디렉토리에서 언 바운드입니다.</target>
        </trans-unit>
        <trans-unit id="5e181fd53600dcd77e327b5091e7925935330a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;LENIENT&lt;/code&gt; and a time is parsed without a date, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; and an excess &lt;code&gt;Period&lt;/code&gt; in days.</source>
          <target state="translated">경우 &lt;code&gt;ResolverStyle&lt;/code&gt; 가 있다 &lt;code&gt;LENIENT&lt;/code&gt; 하고 시간이 날없이 구문 분석, 다음 구문 분석의 전체 결과는 구성 &lt;code&gt;LocalTime&lt;/code&gt; 과 초과 &lt;code&gt;Period&lt;/code&gt; 일이다.</target>
        </trans-unit>
        <trans-unit id="801480d1156ab6ed42af2047f9f67f81a9ed2968" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;SMART&lt;/code&gt; and a time is parsed without a date where the time is 24:00:00, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; of 00:00:00 and an excess &lt;code&gt;Period&lt;/code&gt; of one day.</source>
          <target state="translated">경우 &lt;code&gt;ResolverStyle&lt;/code&gt; 가 있다 &lt;code&gt;SMART&lt;/code&gt; 과 시간이 24:00:00이고 시간은 날짜없이 구문 분석하고 해석의 전체 결과는 구성 &lt;code&gt;LocalTime&lt;/code&gt; 00:00:00 및 초과 &lt;code&gt;Period&lt;/code&gt; 1 일.</target>
        </trans-unit>
        <trans-unit id="ea383b2cd69ecf52b9ec7ee59229284018a85985" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;String&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or does not conform to &lt;a href=&quot;#toString()&quot;&gt;&lt;code&gt;QName.toString()&lt;/code&gt;&lt;/a&gt; formatting, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">If the &lt;code&gt;String&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or does not conform to &lt;a href=&quot;#toString()&quot;&gt; &lt;code&gt;QName.toString()&lt;/code&gt; &lt;/a&gt; formatting, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="679d594737099d64f4c8a7bd67a360d72bcf8bdd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">는 IF &lt;code&gt;Type&lt;/code&gt; 파라미터 화 된 형태의 인 &lt;code&gt;Type&lt;/code&gt; 정확하게 소스 코드로 사용되는 실제의 형태 파라미터를 반영해야합니다 반환 된 객체가.</target>
        </trans-unit>
        <trans-unit id="9c0eea94ebf724c08a182505b07f4b40fc26c467" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UndoManager&lt;/code&gt; contains edits it will call &lt;code&gt;addEdit&lt;/code&gt; on the current edit passing in the new edit as the argument. If &lt;code&gt;addEdit&lt;/code&gt; returns true the new edit is assumed to have been incorporated into the current edit and the new edit will not be added to the list of current edits. Edits can use &lt;code&gt;addEdit&lt;/code&gt; as a way for smaller edits to be incorporated into a larger edit and treated as a single edit.</source>
          <target state="translated">If the &lt;code&gt;UndoManager&lt;/code&gt; contains edits it will call &lt;code&gt;addEdit&lt;/code&gt; on the current edit passing in the new edit as the argument. If &lt;code&gt;addEdit&lt;/code&gt; returns true the new edit is assumed to have been incorporated into the current edit and the new edit will not be added to the list of current edits. Edits can use &lt;code&gt;addEdit&lt;/code&gt; as a way for smaller edits to be incorporated into a larger edit and treated as a single edit.</target>
        </trans-unit>
        <trans-unit id="35ff53d86b4bc68486f63c50ba3db4d56f3b6812" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;#of(java.time.LocalDateTime,java.time.ZoneId)&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt; , this method is equivalent to &lt;a href=&quot;#of(java.time.LocalDateTime,java.time.ZoneId)&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="be1a0f77a615842bdf82ef7b9ebede6a9bce0b3f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;code&gt;ZoneId&lt;/code&gt; 사용될는 인 &lt;code&gt;ZoneOffset&lt;/code&gt; ,이 방법은 동일하다 &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d86f839b1695227093964559a355f46055cbd60" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;abort&lt;/code&gt; phase fails for any reason, then this method propagates the original exception thrown either during the &lt;code&gt;login&lt;/code&gt; phase or the &lt;code&gt;commit&lt;/code&gt; phase. In either case, the overall authentication fails.</source>
          <target state="translated">는 IF &lt;code&gt;abort&lt;/code&gt; 단계는 어떤 이유로 실패,이 메소드는 동안 하나 던져 원래 예외 전파 &lt;code&gt;login&lt;/code&gt; 단계 또는이 &lt;code&gt;commit&lt;/code&gt; 단계. 두 경우 모두 전체 인증이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a7b16f00ee4043e4aeba76ef6283f2971eb30418" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;acceptor&lt;/code&gt; function is not successfully invoked, then the push promise is rejected. The &lt;code&gt;acceptor&lt;/code&gt; function will throw an &lt;code&gt;IllegalStateException&lt;/code&gt; if invoked more than once.</source>
          <target state="translated">If the &lt;code&gt;acceptor&lt;/code&gt; function is not successfully invoked, then the push promise is rejected. The &lt;code&gt;acceptor&lt;/code&gt; function will throw an &lt;code&gt;IllegalStateException&lt;/code&gt; if invoked more than once.</target>
        </trans-unit>
        <trans-unit id="446c80fa5bc5f4e37afc5fc9e155b09818c5562f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll()&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">경우] &lt;code&gt;addAll()&lt;/code&gt; 연산이 예외를 발생이 속성 세트의 상태에 대한 영향은 구현 의존적이다; 예외 시점 이전에 지정된 세트의 요소가이 속성 세트에 추가되었거나 추가되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ef5598f3ce002caa707d0e8dab5fc3e129e43c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">경우] &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; 연산이 예외를 발생이 속성 세트의 상태에 대한 영향은 구현 의존적이다; 예외 시점 이전에 지정된 세트의 요소가이 속성 세트에 추가되었거나 추가되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0511263cbc485e9efb3be19eb199baa7484f96" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">경우 &lt;code&gt;algorithm&lt;/code&gt; 매개 변수가 null 또는 비 비어, 엔드 포인트 식별은 / 검증 절차는 SSL / TLS 핸드 쉐이크 동안 처리해야합니다. 이는 중간자 공격을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6834dc9ff0b8ff599b86ecc51718d6f5b5574c58" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS/DTLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS/DTLS handshaking. This is to prevent man-in-the-middle attacks.</target>
        </trans-unit>
        <trans-unit id="ce642f2bb7f80adee08e960922be3c55ad9db8fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an &lt;code&gt;Attribute&lt;/code&gt; whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the &lt;code&gt;AttributeSet&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an &lt;code&gt;Attribute&lt;/code&gt; whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the &lt;code&gt;AttributeSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df2ce529fb9d0af1fa8bdee431df9ad0c85e4344" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an Attribute whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the AttributeSet.</source>
          <target state="translated">는 IF &lt;code&gt;attributes&lt;/code&gt; 카테고리의 속성을 보관 매개 변수와 동일한 &lt;code&gt;category&lt;/code&gt; 매개 변수, 서비스는 속성 세트에이 속성을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="98b6741e1086600d52bcba89af328ea50edfba2c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt;, &lt;a href=&quot;../../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</source>
          <target state="translated">If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt; , &lt;a href=&quot;../../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</target>
        </trans-unit>
        <trans-unit id="560ee03306807fcb6258a99873dd7c023d6a7244" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt;, &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</source>
          <target state="translated">If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt; , &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</target>
        </trans-unit>
        <trans-unit id="717cef07fc5b446c1f7069da0b2b9e9376ef7862" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;body&lt;/code&gt; handle returns a non-&lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt;, a leading loop iteration variable of that type is also present. This variable is initialized using the optional &lt;code&gt;init&lt;/code&gt; handle, or to the &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; of type &lt;code&gt;V&lt;/code&gt; if that handle is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;body&lt;/code&gt; handle returns a non- &lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt; , a leading loop iteration variable of that type is also present. This variable is initialized using the optional &lt;code&gt;init&lt;/code&gt; handle, or to the &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; of type &lt;code&gt;V&lt;/code&gt; if that handle is &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66b2ac942fdab810011fedc70461bf42a1dedd98" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;boolean&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;, this method causes the virtual machine to stop performing the detailed instruction trace it is performing.</source>
          <target state="translated">경우 &lt;code&gt;boolean&lt;/code&gt; 인수가 &lt;code&gt;false&lt;/code&gt; 이 방법은 수행하는 상세 명령 추적을 중단 가상 머신됩니다.</target>
        </trans-unit>
        <trans-unit id="88001e51dd6c79b8369de89a8cbe2fdfe3865e70" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index - 1)&lt;/code&gt; is in the low-surrogate range, &lt;code&gt;(index - 2)&lt;/code&gt; is not negative, and the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index -
 2)&lt;/code&gt; is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;index -
 1&lt;/code&gt; is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 의 값 &lt;code&gt;(index - 1)&lt;/code&gt; 저 대리 범위이고, &lt;code&gt;(index - 2)&lt;/code&gt; 네거티브 아니며, &lt;code&gt;char&lt;/code&gt; 의 값 &lt;code&gt;(index - 2)&lt;/code&gt; 높은 surrogate 범위에있는 경우, 부가 코드 포인트 대리 쌍의 값이 반환됩니다. &lt;code&gt;index - 1&lt;/code&gt; 의 &lt;code&gt;char&lt;/code&gt; 값 이 짝을 이루지 않은 낮은 서로 게이트 또는 높은 서로 게이트 인 경우 서로 게이트 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc1506abc2a5f78b19fe3dd96f18038b15e4e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this &lt;code&gt;String&lt;/code&gt;, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 지정된 인덱스 지정된 값이 높은 대리 범위에 다음 인덱스는 이것의 길이보다 짧은 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;char&lt;/code&gt; 다음 인덱스의 값은, 저 대리 범위에서 보조 코드 포인트 인 이 대리 쌍에 해당하는이 반환됩니다. 그렇지 않으면 주어진 인덱스 의 &lt;code&gt;char&lt;/code&gt; 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c3a606e3f3d827b22e0257098f87d4bbd176eb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this sequence, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 지정된 인덱스 지정된 값이 높은 대리 범위에 다음 인덱스는이 시퀀스의 길이보다 작은, 상기 &lt;code&gt;char&lt;/code&gt; 다음 인덱스의 값은, 저 대리 범위에서 보조 코드 포인트 인 이 대리 쌍에 해당하는이 반환됩니다. 그렇지 않으면 주어진 인덱스 의 &lt;code&gt;char&lt;/code&gt; 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="adfa6cd0e81b003e1bb2d5b808729dc1489e6300" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;../../../../java.base/java/lang/character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;../../../../java.base/java/lang/character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</target>
        </trans-unit>
        <trans-unit id="7059bfb26c628d831ae809e02477cb1879e60f94" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">경우 &lt;code&gt;char&lt;/code&gt; 인덱스로 지정된 값이 인 &lt;a href=&quot;character#unicode&quot;&gt;대리&lt;/a&gt; , 대리 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8250d512b905f35c6a410fcb5609b7900e346a5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;commit&lt;/code&gt; phase of the authentication process fails, then the overall authentication fails and this method invokes the &lt;code&gt;abort&lt;/code&gt; method for each configured &lt;code&gt;LoginModule&lt;/code&gt;.</source>
          <target state="translated">인증 프로세스 의 &lt;code&gt;commit&lt;/code&gt; 단계가 실패하면 전체 인증이 실패하고이 메소드는 구성된 각 &lt;code&gt;LoginModule&lt;/code&gt; 에 대한 &lt;code&gt;abort&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="84555e61977552659f8d8d7542bd52057f6a2286" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;connect&lt;/code&gt; method is called when the connection has already been opened (indicated by the &lt;code&gt;connected&lt;/code&gt; field having the value &lt;code&gt;true&lt;/code&gt;), the call is ignored.</source>
          <target state="translated">상기 중간 &lt;code&gt;connect&lt;/code&gt; 접속이 이미 개방되었을 때 메소드가 호출된다 (의해 표시된 &lt;code&gt;connected&lt;/code&gt; 값을 갖는 필드 &lt;code&gt;true&lt;/code&gt; ), 호는 무시된다.</target>
        </trans-unit>
        <trans-unit id="342ba2fb4627294d3b781daa9697b718b5c068d6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;, the component is added in the first available position (left/top if open, else right/bottom).</source>
          <target state="translated">If the &lt;code&gt;constraints&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt; , the component is added in the first available position (left/top if open, else right/bottom).</target>
        </trans-unit>
        <trans-unit id="671e297a3a1ea6f0c42770e029c80abaa60e1bfb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS handshake must be permitted by the constraints.</source>
          <target state="translated">&lt;code&gt;constraints&lt;/code&gt; 매개 변수가 널이 아닌 경우, SSL / TLS 핸드 쉐이크에 사용 된 모든 암호화 알고리즘, 키 및 알고리즘 매개 변수는 제한 조건에 의해 허용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b40b2d9ff34a0913ffad16fe301b6eeb61865ff0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS/DTLS handshake must be permitted by the constraints.</source>
          <target state="translated">If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS/DTLS handshake must be permitted by the constraints.</target>
        </trans-unit>
        <trans-unit id="6a5dce44bc4531313d43efc02c3d4e5307173391" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;deep&lt;/code&gt; option was set to &lt;code&gt;true&lt;/code&gt;, the descendants of the source &lt;code&gt;DocumentFragment&lt;/code&gt; are recursively imported and the resulting nodes reassembled under the imported &lt;code&gt;DocumentFragment&lt;/code&gt; to form the corresponding subtree. Otherwise, this simply generates an empty &lt;code&gt;DocumentFragment&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;deep&lt;/code&gt; option was set to &lt;code&gt;true&lt;/code&gt; , the descendants of the source &lt;code&gt;DocumentFragment&lt;/code&gt; are recursively imported and the resulting nodes reassembled under the imported &lt;code&gt;DocumentFragment&lt;/code&gt; to form the corresponding subtree. Otherwise, this simply generates an empty &lt;code&gt;DocumentFragment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c20fefbf5f84e3a9d83640712edb423384c25b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;defaultLoader&lt;/code&gt; argument is non-&lt;code&gt;null&lt;/code&gt; and all of the named interfaces can be resolved through that loader, then,</source>
          <target state="translated">If the &lt;code&gt;defaultLoader&lt;/code&gt; argument is non- &lt;code&gt;null&lt;/code&gt; and all of the named interfaces can be resolved through that loader, then,</target>
        </trans-unit>
        <trans-unit id="b0dd399ffadc3a633c7172c0f219386bda780906" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;defaultLoader&lt;/code&gt; argument is non-&lt;code&gt;null&lt;/code&gt;, it first attempts to load the class with the specified &lt;code&gt;name&lt;/code&gt; using the &lt;code&gt;defaultLoader&lt;/code&gt;, such as by evaluating</source>
          <target state="translated">는 IF &lt;code&gt;defaultLoader&lt;/code&gt; 가의 인수가 비입니다 &lt;code&gt;null&lt;/code&gt; , 그 첫 번째 시도는 지정된 가지는 클래스로드 &lt;code&gt;name&lt;/code&gt; 은 Using &lt;code&gt;defaultLoader&lt;/code&gt; 가이 같은 평가에 의해로서,</target>
        </trans-unit>
        <trans-unit id="e999b0a3f9b176b6320891b00b86e62b47b692fe" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dereference&lt;/code&gt; method of user-specified &lt;code&gt;
 URIDereferencer&lt;/code&gt;s returns &lt;code&gt;NodeSetData&lt;/code&gt; objects, the &lt;code&gt;iterator&lt;/code&gt; method MUST return an iteration over objects of type &lt;code&gt;
 org.w3c.dom.Node&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;dereference&lt;/code&gt; 사용자 지정 방법 &lt;code&gt; URIDereferencer&lt;/code&gt; 의 반환 &lt;code&gt;NodeSetData&lt;/code&gt; 의 객체는 &lt;code&gt;iterator&lt;/code&gt; 방법은 타입의 객체의 반복 리턴해야한다 &lt;code&gt; org.w3c.dom.Node&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="44563c51972a22c15c4aac96132c92755f5fb940" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the system-dependent default temporary-file directory will be used. The default temporary-file directory is specified by the system property &lt;code&gt;java.io.tmpdir&lt;/code&gt;. On UNIX systems the default value of this property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;. A different value may be given to this system property when the Java virtual machine is invoked, but programmatic changes to this property are not guaranteed to have any effect upon the temporary directory used by this method.</source>
          <target state="translated">는 IF &lt;code&gt;directory&lt;/code&gt; 인수가 &lt;code&gt;null&lt;/code&gt; 다음 시스템에 의존하는 기본 임시 파일 디렉토리가 사용됩니다. 기본 임시 파일 디렉토리는 시스템 특성 &lt;code&gt;java.io.tmpdir&lt;/code&gt; 에 의해 지정됩니다 . UNIX 시스템에서이 특성의 기본값은 일반적으로 &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 일반적으로 &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt; 입니다. JVM (Java Virtual Machine)이 호출 될 때이 시스템 특성에 다른 값이 제공 될 수 있지만이 특성의 프로그래밍 방식 변경이이 메소드가 사용하는 임시 디렉토리에 영향을 미치지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2c4e3bcad43dd7e533a7fbe7a4541570c19bd7c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="61b3f5e27ccdfa6299b991fa9397c7fbc31d2c50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;emitter&lt;/code&gt; 생성자에 매개 변수의 인스턴스이었다 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 이 메소드는 호출 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab969fd58c84fba8fefef4d68297aff8fba763d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this engine.</source>
          <target state="translated">는 IF &lt;code&gt;engine&lt;/code&gt; 매개 변수를 사용할 수 있으며의 알고리즘 제약 &lt;code&gt;SSLParameters&lt;/code&gt; 인증 경로에있는 모든 인증서, null가 아닌, 같은 주제의 공개 키, 서명 알고리즘, 키 사용, 확장 키 사용 등을 준수하기 위해 필요로 필드 이 엔진의 알고리즘 제약 조건에</target>
        </trans-unit>
        <trans-unit id="4eab346c804a32d54771d78aef5cb1081f3a8a5a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;engine&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">는 IF &lt;code&gt;engine&lt;/code&gt; 매개 변수를 사용할 수 있으며의 엔드 포인트 식별 알고리즘 &lt;code&gt;SSLParameters&lt;/code&gt; 비 비어, man-in-the-middle 공격은 그 주소를 방지하기 위해 &lt;code&gt;engine&lt;/code&gt; 에 연결이 최종 제시 피어의 식별 정보에 대해 확인되어야한다 엔드 포인트 식별 알고리즘에 지정된 엔티티 X509 인증서.</target>
        </trans-unit>
        <trans-unit id="c489bda8ac51d0adb2cd2ea9ed206915eaf00580" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="def3bb99565bff52201998cb9934892d1dd9c8bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</target>
        </trans-unit>
        <trans-unit id="6b551db3025e219ae99ad787aed372f0514c1f97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="c01021b847664573167d59264418973e495b23f1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</target>
        </trans-unit>
        <trans-unit id="56c06cc3e424dcdff076cdd1bf18f2a3b0d87e7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자를로드하는 데 사용할 클래스 로더입니다. 연관된 값이 &lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 인스턴스가 아닌 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d005cee8b528479b05c0be85b9c4205d983a4967" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자 패키지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="826709e7b964ff5f55e8bba64d589128adee0453" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자를로드하는 데 사용할 클래스 로더입니다. 연관된 값이 &lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 인스턴스가 아닌 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57ace146c6c02d090ae1128a0850bf8c4adb9e91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자 패키지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6ad40577697d2d3214b29500713b40249dcf0017" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;execute&lt;/code&gt; method is called at this point, the query sent to the DBMS will be:</source>
          <target state="translated">If the &lt;code&gt;execute&lt;/code&gt; method is called at this point, the query sent to the DBMS will be:</target>
        </trans-unit>
        <trans-unit id="d7e356babec0dbd66ed893c5d593e3b80f2c4c69" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;execute&lt;/code&gt; method is successful, it will set the appropriate private &lt;code&gt;JdbcRowSet&lt;/code&gt; fields with the following:</source>
          <target state="translated">If the &lt;code&gt;execute&lt;/code&gt; method is successful, it will set the appropriate private &lt;code&gt;JdbcRowSet&lt;/code&gt; fields with the following:</target>
        </trans-unit>
        <trans-unit id="f6b8bda61da14baa6de0517de831488bd2ee3ae0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flag&lt;/code&gt; is false, end-of-line characters are treated as white space and serve only to separate tokens.</source>
          <target state="translated">&lt;code&gt;flag&lt;/code&gt; 가 false 인 경우 줄 끝 문자는 공백으로 처리되며 별도의 토큰에만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1442b96066ac814d95028e3d47c625abac13dd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;handleError&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the DOM implementation should stop the current processing when possible. If the method returns &lt;code&gt;true&lt;/code&gt;, the processing may continue depending on &lt;code&gt;DOMError.severity&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;handleError&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; , the DOM implementation should stop the current processing when possible. If the method returns &lt;code&gt;true&lt;/code&gt; , the processing may continue depending on &lt;code&gt;DOMError.severity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e167f1b0b7b6f2ec44852a0a73f6c3eeb0559e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;hsbvals&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt;, then a new array is allocated to return the result. Otherwise, the method returns the array &lt;code&gt;hsbvals&lt;/code&gt;, with the values put into that array.</source>
          <target state="translated">If the &lt;code&gt;hsbvals&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; , then a new array is allocated to return the result. Otherwise, the method returns the array &lt;code&gt;hsbvals&lt;/code&gt; , with the values put into that array.</target>
        </trans-unit>
        <trans-unit id="57070b75c38e47f9bec4e11be8d75f04d3e68264" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt;&lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt; , and each call to &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt; &lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt; &lt;/a&gt; returns a new clone.</target>
        </trans-unit>
        <trans-unit id="f96a39d4789943d7d6902746fb2340490af74ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">경우 &lt;code&gt;info&lt;/code&gt; 배열이 비어 있지 않은, 다음은 경우와 같이 생성자에 의해 복제됩니다 &lt;code&gt;info.clone()&lt;/code&gt; 및 호출 할 때마다 &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt; 새로운 복제를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="fc7fb96d1c52310781ca0701cabfa84235cc6cad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initialize&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;C&lt;/code&gt; is initialized by the Java Virtual Machine.</source>
          <target state="translated">경우 &lt;code&gt;initialize&lt;/code&gt; 매개 변수가 &lt;code&gt;true&lt;/code&gt; 로 , 다음 &lt;code&gt;C&lt;/code&gt; 는 자바 가상 머신에 의해 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="3eb68d70f873d065dccf85e83072633accafa5b8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;iterator&lt;/code&gt; handle is non-&lt;code&gt;null&lt;/code&gt;, it must have the return type &lt;code&gt;java.util.Iterator&lt;/code&gt; or a subtype thereof. The iterator it produces when the loop is executed will be assumed to yield values which can be converted to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;iterator&lt;/code&gt; handle is non- &lt;code&gt;null&lt;/code&gt; , it must have the return type &lt;code&gt;java.util.Iterator&lt;/code&gt; or a subtype thereof. The iterator it produces when the loop is executed will be assumed to yield values which can be converted to type &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2eafd26f57a8ac8bfe07dee9777924ccc1ddeef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is specified and does not point to an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 를의 속성이 지정되고 가리 키지 않는 &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="f447975377ba6d22540be764d0328fb281a024f7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;java.naming.provider.url&lt;/code&gt; property of the supplied environment consists of a URL (or a list of URLs) using the ldap protocol the resulting &lt;a href=&quot;../ldap/ldapcontext&quot;&gt;&lt;code&gt;LdapContext&lt;/code&gt;&lt;/a&gt; will use an LDAP server resolved by the configured &lt;a href=&quot;../ldap/spi/ldapdnsprovider&quot;&gt;&lt;code&gt;LdapDnsProviders&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">제공된 환경 의 &lt;code&gt;java.naming.provider.url&lt;/code&gt; 속성이 ldap 프로토콜을 사용하는 URL (또는 URL 목록)로 구성된 경우 결과 &lt;a href=&quot;../ldap/ldapcontext&quot;&gt; &lt;code&gt;LdapContext&lt;/code&gt; &lt;/a&gt; 는 구성된 &lt;a href=&quot;../ldap/spi/ldapdnsprovider&quot;&gt; &lt;code&gt;LdapDnsProviders&lt;/code&gt; 에&lt;/a&gt; 의해 확인 된 LDAP 서버를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c4278296c23500bf6c0cea864ef00fd56ed5236d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; key is not present in the &lt;code&gt;environment&lt;/code&gt; parameter, the calling thread's context class loader is used.</source>
          <target state="translated">는 IF &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 의 키에 존재하지 않는 &lt;code&gt;environment&lt;/code&gt; 매개 변수, 호출 thread의 문맥 클래스 로더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3056297b7728c6033d8b58edc893075abdeaf0f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;listenerMethodName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;all&lt;/em&gt; methods in the interface trigger the &lt;code&gt;action&lt;/code&gt; to be executed on the &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;listenerMethodName&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 인터페이스의 &lt;em&gt;모든&lt;/em&gt; 메소드 가 &lt;code&gt;target&lt;/code&gt; 실행되도록 &lt;code&gt;action&lt;/code&gt; 를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c26cc70217e4df47d29c0c2d3d16af4b3ed49f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the bootstrap class loader.</source>
          <target state="translated">는 IF &lt;code&gt;loader&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 및 시큐리티 매니저가 존재 해, 호출 측의 클래스 로더가 null는 아니고,이 메소드는 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 와 방법 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 는 부트 스트랩 클래스 로더에 액세스 할 수있는 것을 보증 할 수있는 권한 .</target>
        </trans-unit>
        <trans-unit id="883de64909ad64380525bc73b0b1943d2957d4ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;login&lt;/code&gt; method returns without throwing an exception, then the overall authentication succeeded. The caller can then retrieve the newly authenticated Subject by invoking the &lt;code&gt;getSubject&lt;/code&gt; method. Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective &lt;code&gt;getPrincipals&lt;/code&gt;, &lt;code&gt;getPublicCredentials&lt;/code&gt;, and &lt;code&gt;getPrivateCredentials&lt;/code&gt; methods.</source>
          <target state="translated">경우 &lt;code&gt;login&lt;/code&gt; 메소드가 예외를 throw하지 않고 반환, 인증 전체가 성공했다. 그러면 호출자는 &lt;code&gt;getSubject&lt;/code&gt; 메소드 를 호출하여 새로 인증 된 주제를 검색 할 수 있습니다 . 주제와 연관된 프린시 펄 및 신임은 주제의 해당 &lt;code&gt;getPrincipals&lt;/code&gt; , &lt;code&gt;getPublicCredentials&lt;/code&gt; 및 &lt;code&gt;getPrivateCredentials&lt;/code&gt; 메소드 를 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60cd069f53c1777bbf4cf31f1344fe37a4dd9ac1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mimeType&lt;/code&gt; is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">If the &lt;code&gt;mimeType&lt;/code&gt; is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b49049ac47e926595641db8085788c19725bedae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;minimumCapacity&lt;/code&gt; argument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here.</source>
          <target state="translated">는 IF &lt;code&gt;minimumCapacity&lt;/code&gt; 의 인수가 정의 값이 아닌,이 메소드는 아무 작업도 간단하게 수익을지지 않습니다. 이 개체에 대한 후속 작업으로 인해 여기에서 요청한 것보다 실제 용량이 줄어들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="848f1dae842a9e3e26ccb5fe35a5a76ed09b5792" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modes&lt;/code&gt; parameter is of length zero, then the existence of the file is checked.</source>
          <target state="translated">는 IF &lt;code&gt;modes&lt;/code&gt; 매개 변수는 길이가 0이며, 파일의 존재가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="26efd0bf17769d06237d7690d4aec1e552ef72d2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modifiers&lt;/code&gt; passed to the constructor are invalid, this method returns them unchanged.</source>
          <target state="translated">If the &lt;code&gt;modifiers&lt;/code&gt; passed to the constructor are invalid, this method returns them unchanged.</target>
        </trans-unit>
        <trans-unit id="68e361de8335b69d5e82c2e65544790404d5fa01" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mouseX&lt;/code&gt; and &lt;code&gt;mouseY&lt;/code&gt; are in the expand/collapse region of the &lt;code&gt;row&lt;/code&gt;, this will toggle the row.</source>
          <target state="translated">If the &lt;code&gt;mouseX&lt;/code&gt; and &lt;code&gt;mouseY&lt;/code&gt; are in the expand/collapse region of the &lt;code&gt;row&lt;/code&gt; , this will toggle the row.</target>
        </trans-unit>
        <trans-unit id="d2a314f2aa28a80e456c2b1019bb7151fb7190ec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; begins with a &lt;code&gt;'/'&lt;/code&gt; (&lt;code&gt;'\u002f'&lt;/code&gt;), then the absolute name of the resource is the portion of the &lt;code&gt;name&lt;/code&gt; following the &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;name&lt;/code&gt; 로 시작할 &lt;code&gt;'/'&lt;/code&gt; ( &lt;code&gt;'\u002f'&lt;/code&gt; ), 그 자원의 절대 이름의 부분 인 &lt;code&gt;name&lt;/code&gt; 다음 &lt;code&gt;'/'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64bdc0e92c398401f342c415851da39654a29de8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is &quot;&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;&quot; or &quot;&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;&quot; a &lt;code&gt;NoSuchMethodException&lt;/code&gt; is raised. Otherwise, the method to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:</source>
          <target state="translated">상기 중간 &lt;code&gt;name&lt;/code&gt; &quot;입니다 &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; &quot;는 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 발생합니다. 그렇지 않으면, 반영 될 방법은 다음 알고리즘에 의해 결정됩니다. C를이 객체가 나타내는 클래스 또는 인터페이스라고하자.</target>
        </trans-unit>
        <trans-unit id="cf8f40175e230701ae0b215435cd687b9dbe0a2f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; parameter represents something other than a logical font, i.e. is interpreted as a physical font face or family, and this cannot be mapped by the implementation to a physical font or a compatible alternative, then the font system will map the Font instance to &quot;Dialog&quot;, such that for example, the family as reported by &lt;a href=&quot;#getFamily()&quot;&gt;&lt;code&gt;getFamily&lt;/code&gt;&lt;/a&gt; will be &quot;Dialog&quot;.</source>
          <target state="translated">If the &lt;code&gt;name&lt;/code&gt; parameter represents something other than a logical font, i.e. is interpreted as a physical font face or family, and this cannot be mapped by the implementation to a physical font or a compatible alternative, then the font system will map the Font instance to &quot;Dialog&quot;, such that for example, the family as reported by &lt;a href=&quot;#getFamily()&quot;&gt; &lt;code&gt;getFamily&lt;/code&gt; &lt;/a&gt; will be &quot;Dialog&quot;.</target>
        </trans-unit>
        <trans-unit id="83d37bcba2e6c3af77d7d4ae04d7689d9a46d013" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute with the same local name and namespace URI, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;newAttr&lt;/code&gt; 속성이 같은 로컬 명과 이름 공간 URI와 기존 속성을 대체, 교체 &lt;code&gt;Attr&lt;/code&gt; 노드는 달리, 반환되는 &lt;code&gt;null&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c99c4ecff1480f789773edec7e413ca2eabcdc6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;newAttr&lt;/code&gt; 속성이 기존의 속성을 대체, 교체 &lt;code&gt;Attr&lt;/code&gt; 노드는 달리, 반환되는 &lt;code&gt;null&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e562c3377bc531b17a3856d97697e38d3cf5595e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newLength&lt;/code&gt; argument is greater than or equal to the current length, sufficient null characters (&lt;code&gt;'\u0000'&lt;/code&gt;) are appended so that length becomes the &lt;code&gt;newLength&lt;/code&gt; argument.</source>
          <target state="translated">경우] &lt;code&gt;newLength&lt;/code&gt; 인수보다 크거나 현재의 길이와 동일 충분한 널 문자 ( &lt;code&gt;'\u0000'&lt;/code&gt; 그 길이는가되도록) 추가된다 &lt;code&gt;newLength&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="31c964b999377de0a92c3ddd622adf97746585c7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;notifier.notifyAll()&lt;/code&gt; happens before the waiting thread enters the &lt;code&gt;notifier.wait()&lt;/code&gt; method, the &lt;code&gt;while&lt;/code&gt; loop ensures that the waiting thread will not enter the &lt;code&gt;notifier.wait()&lt;/code&gt; method. Otherwise, there is no guarantee that the waiting thread will ever be woken from the wait.</source>
          <target state="translated">If the &lt;code&gt;notifier.notifyAll()&lt;/code&gt; happens before the waiting thread enters the &lt;code&gt;notifier.wait()&lt;/code&gt; method, the &lt;code&gt;while&lt;/code&gt; loop ensures that the waiting thread will not enter the &lt;code&gt;notifier.wait()&lt;/code&gt; method. Otherwise, there is no guarantee that the waiting thread will ever be woken from the wait.</target>
        </trans-unit>
        <trans-unit id="cd7d35bb1b07a6fa45d7d92b3c84889d6cce40ac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="301c55c1d2d5648b427ee3a645ab8146cd1a941a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 포함 매개 변수 &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; 의&lt;/a&gt; 옵션은 다음 스트림이 너무 사이클이 검출 될 수 있음을 방문한 디렉토리를 추적합니다. 디렉토리의 조상 인 디렉토리에 항목이있을 때주기가 발생합니다. 디렉토리 탐지는 디렉토리 의 &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; 를 기록 하거나 파일 키를 사용할 수없는 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 디렉토리가 상위 파일과 동일한 파일인지 테스트하여 수행됩니다. 주기가 감지되면 &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt; 인스턴스의 입출력 오류로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="c55674bb2b5b73e671fc2ec40dcb555e23d9e8d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed(T,java.io.IOException)&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed(T,java.io.IOException)&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; &lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ecea4dec8dcb1fadb716a28cf7ec70ca81e1d565" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 포함 매개 변수 &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; 의&lt;/a&gt; 옵션은 다음이 방법은 너무 사이클이 검출 될 수 있음을 방문한 디렉토리를 추적합니다. 디렉토리의 조상 인 디렉토리에 항목이있을 때주기가 발생합니다. 디렉토리 탐지는 디렉토리 의 &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; 를 기록 하거나 파일 키를 사용할 수없는 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 디렉토리가 상위 파일과 동일한 파일인지 테스트하여 수행됩니다. 사이클이 검출 될 때는 I / O 에러로 처리하고, &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; 의&lt;/a&gt; 방법의 인스턴스를 호출 &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31072125bfcecae8a94f901f25b6fafec9dc2ff7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;#isAbsolute()&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;#isAbsolute()&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt; . If &lt;code&gt;other&lt;/code&gt; is an</target>
        </trans-unit>
        <trans-unit id="88ff2d156a33a9f0f1f1ee553f98ff8909648b12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">경우] &lt;code&gt;other&lt;/code&gt; 파라미터가있다 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로가이 메소드는 반환 소소 &lt;code&gt;other&lt;/code&gt; . 경우 &lt;code&gt;other&lt;/code&gt; 인</target>
        </trans-unit>
        <trans-unit id="9865b3d772f73983f404112e79623aa8e389cc36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="4c153c7b1ed1d9892cc1783d56a0214ceb0e6260" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#engineGetOutputSize(int)&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#engineGetOutputSize(int)&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt; to determine how big the output buffer should be.</target>
        </trans-unit>
        <trans-unit id="e5001b62a3fa0f461f2cf7ef6760eeea626b5baf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#getOutputSize(int)&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#getOutputSize(int)&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; to determine how big the output buffer should be.</target>
        </trans-unit>
        <trans-unit id="3573d5215011c7d840ccb006ba46e8ea91465ab0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4e86a833a3d986a22969c431219896e2f0d39b7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="04b14a126287c47f1542560e798db984f2eaa1bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="89fab518710d4b47a17308246643c8e2a1ae9311" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non- &lt;code&gt;null&lt;/code&gt; value just returns it.</target>
        </trans-unit>
        <trans-unit id="e3f72f3125072f59960bf1220d641055ff086775" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getPreferredSize&lt;/code&gt; method returns a non &lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non- &lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getPreferredSize&lt;/code&gt; method returns a non &lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</target>
        </trans-unit>
        <trans-unit id="e09b11d717ca9d2b9db6e423c314021366d5f96d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;pri&lt;/code&gt; argument is less than &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt;&lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt;&lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt;&lt;/a&gt;, the maximum priority of the group remains unchanged.</source>
          <target state="translated">경우] &lt;code&gt;pri&lt;/code&gt; 인수 미만이다 &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt; &lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt; &lt;/a&gt; 또는보다 &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt; &lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt; &lt;/a&gt; 그룹의 최고 우선 순위는 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="c2d320fca5e0359eb42dfb70629d91de0ba8bdc2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;prototypeCellValue&lt;/code&gt; property is &lt;code&gt;non-null&lt;/code&gt;, setting the cell renderer also causes the &lt;code&gt;fixedCellWidth&lt;/code&gt; and &lt;code&gt;fixedCellHeight&lt;/code&gt; properties to be re-calculated. Only one &lt;code&gt;PropertyChangeEvent&lt;/code&gt; is generated however - for the &lt;code&gt;cellRenderer&lt;/code&gt; property.</source>
          <target state="translated">If the &lt;code&gt;prototypeCellValue&lt;/code&gt; property is &lt;code&gt;non-null&lt;/code&gt; , setting the cell renderer also causes the &lt;code&gt;fixedCellWidth&lt;/code&gt; and &lt;code&gt;fixedCellHeight&lt;/code&gt; properties to be re-calculated. Only one &lt;code&gt;PropertyChangeEvent&lt;/code&gt; is generated however - for the &lt;code&gt;cellRenderer&lt;/code&gt; property.</target>
        </trans-unit>
        <trans-unit id="7ab6fa23ab907d0e5b9b458534eaceb7cc5333a4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realEditor&lt;/code&gt; returns true to this message, &lt;code&gt;prepareForEditing&lt;/code&gt; is messaged and true is returned.</source>
          <target state="translated">If the &lt;code&gt;realEditor&lt;/code&gt; returns true to this message, &lt;code&gt;prepareForEditing&lt;/code&gt; is messaged and true is returned.</target>
        </trans-unit>
        <trans-unit id="7083b5d57e80daca82c9ea7e4f69ee995d29855a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realEditor&lt;/code&gt; will allow editing to stop, the &lt;code&gt;realEditor&lt;/code&gt; is removed and true is returned, otherwise false is returned.</source>
          <target state="translated">If the &lt;code&gt;realEditor&lt;/code&gt; will allow editing to stop, the &lt;code&gt;realEditor&lt;/code&gt; is removed and true is returned, otherwise false is returned.</target>
        </trans-unit>
        <trans-unit id="72da6eb0f51543265c08bfdc0d2bc08c5c28b9d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it indicates that this method is being called because the previously loaded resource bundle has expired.</source>
          <target state="translated">경우 &lt;code&gt;reload&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; , 그것은 이전에로드 된 자원 번들이 만료 되었기 때문에이 메소드가 호출되고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f1c25c2d5a4c3be0ad0ceae100cbbd46dd49166c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;resizingColumn&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it is one of the columns in the table that has changed size rather than the table itself. In this case the auto-resize modes govern the way the extra (or deficit) space is distributed amongst the available columns.</source>
          <target state="translated">If the &lt;code&gt;resizingColumn&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; , it is one of the columns in the table that has changed size rather than the table itself. In this case the auto-resize modes govern the way the extra (or deficit) space is distributed amongst the available columns.</target>
        </trans-unit>
        <trans-unit id="9cf1a2b060b2436670293c7813d34eef4b639e76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then the delimiter characters are also returned as tokens. Each delimiter is returned as a string of length one. If the flag is &lt;code&gt;false&lt;/code&gt;, the delimiter characters are skipped and only serve as separators between tokens.</source>
          <target state="translated">는 IF &lt;code&gt;returnDelims&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; 를 , 단락 문자도 토큰으로 반환됩니다. 각 분리 문자는 길이가 1 인 문자열로 리턴됩니다. 플래그가 &lt;code&gt;false&lt;/code&gt; 인 경우 구분 문자는 건너 뛰고 토큰 사이의 구분자 역할 만합니다.</target>
        </trans-unit>
        <trans-unit id="13d413d3ee252e112f59337a3ad9bdce1bc727e1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;rootVisible&lt;/code&gt; setting specifies that the root node is to be displayed, then that is the only node at the topmost level. If the root node is not displayed, then all of its children are at the topmost level of the tree. Handles are always displayed for nodes other than the topmost.</source>
          <target state="translated">If the &lt;code&gt;rootVisible&lt;/code&gt; setting specifies that the root node is to be displayed, then that is the only node at the topmost level. If the root node is not displayed, then all of its children are at the topmost level of the tree. Handles are always displayed for nodes other than the topmost.</target>
        </trans-unit>
        <trans-unit id="814c644fd80ff6c6cfb5225d71687f0ea854f3a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; looks like:</source>
          <target state="translated">경우] &lt;code&gt;serviceURL&lt;/code&gt; 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="135f589d26f864ce90f30a25047418b479d5f710" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; you specify has an empty URL path (after the optional host and port), or if you do not specify a &lt;code&gt;serviceURL&lt;/code&gt;, then the connector server will fabricate a new &lt;code&gt;JMXServiceURL&lt;/code&gt; that clients can use to connect:</source>
          <target state="translated">는 IF &lt;code&gt;serviceURL&lt;/code&gt; 지정은 (옵션의 호스트와 포트) 하늘의 URL 경로가 당신이 지정하지 않은 경우, 또는 &lt;code&gt;serviceURL&lt;/code&gt; 다음 커넥터 서버는 새로운 제조됩니다 &lt;code&gt;JMXServiceURL&lt;/code&gt; 를 클라이언트가 연결하는 데 사용할 수를 :</target>
        </trans-unit>
        <trans-unit id="7de93d07441877a38ae86e0b1d48750f6d309642" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;setSize&lt;/code&gt; or &lt;code&gt;setBounds&lt;/code&gt; methods are called afterwards with a width or height less than that was specified by the &lt;code&gt;setMinimumSize&lt;/code&gt; method the window is automatically enlarged to meet the &lt;code&gt;minimumSize&lt;/code&gt; value. The &lt;code&gt;minimumSize&lt;/code&gt; value also affects the behaviour of the &lt;code&gt;pack&lt;/code&gt; method.</source>
          <target state="translated">If the &lt;code&gt;setSize&lt;/code&gt; or &lt;code&gt;setBounds&lt;/code&gt; methods are called afterwards with a width or height less than that was specified by the &lt;code&gt;setMinimumSize&lt;/code&gt; method the window is automatically enlarged to meet the &lt;code&gt;minimumSize&lt;/code&gt; value. The &lt;code&gt;minimumSize&lt;/code&gt; value also affects the behaviour of the &lt;code&gt;pack&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="a4c7fe60b96360a2fce6906e7dfb1015497d385d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sharedSecret&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, this call should be repeated with a larger output buffer.</source>
          <target state="translated">는 IF &lt;code&gt;sharedSecret&lt;/code&gt; 에 버퍼가 너무 작아 결과를 보관 유지할 수하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생합니다. 이 경우이 호출은 더 큰 출력 버퍼로 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="a59bde6bd9cfdf4f9c0e2000a8690929361fab50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this socket.</source>
          <target state="translated">는 IF &lt;code&gt;socket&lt;/code&gt; 매개 변수의 인스턴스 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 와의 알고리즘 제약 &lt;code&gt;SSLParameters&lt;/code&gt; 인증 경로에있는 모든 인증서, null가 아닌, 등 주제의 공개 키, 서명 알고리즘, 키 사용, 확장 키 사용으로 필드 이 소켓에있는 알고리즘 제약 조건을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9eeaa551ce6db761bfe71fcd9d95ed24d11d58e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;socket&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">경우 &lt;code&gt;socket&lt;/code&gt; 매개 변수의 인스턴스 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 와의 엔드 포인트 식별 알고리즘 &lt;code&gt;SSLParameters&lt;/code&gt; 비 비어, man-in-the-middle 공격은 그 주소를 방지하기 위해 &lt;code&gt;socket&lt;/code&gt; 에 연결이 제시 피어의 식별 정보에 대해 확인되어야한다 엔드 포인트 식별 알고리즘에 지정된 엔드 엔티티 X509 인증서</target>
        </trans-unit>
        <trans-unit id="a8ad5fb90dd67b864239c52c78d91a33b02bcd3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</source>
          <target state="translated">If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</target>
        </trans-unit>
        <trans-unit id="1326d1ae8f7029fe206d3181337e183fd5b2f733" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;targetClass&lt;/code&gt; is in the same module as the lookup class, the lookup class is &lt;code&gt;LC&lt;/code&gt; in module &lt;code&gt;M1&lt;/code&gt; and the previous lookup class is in module &lt;code&gt;M0&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if not present, &lt;code&gt;targetClass&lt;/code&gt; is accessible if and only if one of the following is true:</source>
          <target state="translated">경우] &lt;code&gt;targetClass&lt;/code&gt; 룩업 클래스와 같은 모듈에 룩업 클래스는 &lt;code&gt;LC&lt;/code&gt; 모듈 &lt;code&gt;M1&lt;/code&gt; 이전 룩업 클래스 모듈에 &lt;code&gt;M0&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; , 존재하지 않는 경우 &lt;code&gt;targetClass&lt;/code&gt; 다음 중 하나에 해당되는 경우에만, 액세스 :</target>
        </trans-unit>
        <trans-unit id="50552460698026ff8f20b17c1d4139edc635e7a4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;verify&lt;/code&gt; flag is on when opening a signed jar file, the content of the jar entry is verified against the signature embedded inside the manifest that is associated with its &lt;a href=&quot;jarentry#getRealName()&quot;&gt;&lt;code&gt;path name&lt;/code&gt;&lt;/a&gt;. For a multi-release jar file, the content of a versioned entry is verfieid against its own signature and &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt;&lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt;&lt;/a&gt; returns its own signers. Please note that the verification process does not include validating the signer's certificate. A caller should inspect the return value of &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt;&lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt;&lt;/a&gt; to further determine if the signature can be trusted.</source>
          <target state="translated">If the &lt;code&gt;verify&lt;/code&gt; flag is on when opening a signed jar file, the content of the jar entry is verified against the signature embedded inside the manifest that is associated with its &lt;a href=&quot;jarentry#getRealName()&quot;&gt; &lt;code&gt;path name&lt;/code&gt; &lt;/a&gt;. For a multi-release jar file, the content of a versioned entry is verfieid against its own signature and &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt; &lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt; &lt;/a&gt; returns its own signers. Please note that the verification process does not include validating the signer's certificate. A caller should inspect the return value of &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt; &lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt; &lt;/a&gt; to further determine if the signature can be trusted.</target>
        </trans-unit>
        <trans-unit id="384a467e1b3d5e62425baa603c92bb9909dbf0dc" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of the characters asterisk or question mark and they are not preceded by a backslash, then they are considered as wildcard characters and the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">는 IF &lt;em&gt;인용 값이&lt;/em&gt; 문자의 별표 (*) 또는 물음표 중 하나 개 이상 발생을 포함하고는 앞에 백 슬래시되지 않습니다, 그들은이 와일드 카드 문자로 간주하고 개체 이름은이다하는 &lt;em&gt;속성 값 패턴&lt;/em&gt; . 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="383d196bbc70848d6d2a83c15bee341a49633abd" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence of the wildcard characters asterisk or question mark, then the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">&lt;em&gt;따옴표없는 값&lt;/em&gt; 에 와일드 카드 문자 별표 또는 물음표가 하나 이상 포함 된 경우 개체 이름은 &lt;em&gt;속성 값 pattern&lt;/em&gt; 입니다. 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8fc60c08a8c50456909645784a1769d622137e78" translate="yes" xml:space="preserve">
          <source>If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted can contain code points that are unassigned in Unicode 3.2, which is the Unicode version on which IDN conversion is based. If the flag is not used, the presence of such unassigned code points is treated as an error.</source>
          <target state="translated">ALLOW_UNASSIGNED 플래그가 사용되는 경우, 변환 될 도메인 이름 문자열은 유니 코드 3.2에서 할당되지 않은 코드 포인트를 포함 할 수 있으며, 이는 IDN 변환이 기반으로하는 유니 코드 버전입니다. 플래그를 사용하지 않으면 할당되지 않은 코드 포인트가 존재하는 것은 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="700fc7ae106ff84c28cd4140489739bfdaaa88d6" translate="yes" xml:space="preserve">
          <source>If the API can not be used to configure a &lt;code&gt;JarFile&lt;/code&gt; (e.g. to override the configuration of a compiled application or library), two &lt;code&gt;System&lt;/code&gt; properties are available.</source>
          <target state="translated">If the API can not be used to configure a &lt;code&gt;JarFile&lt;/code&gt; (e.g. to override the configuration of a compiled application or library), two &lt;code&gt;System&lt;/code&gt; properties are available.</target>
        </trans-unit>
        <trans-unit id="2a7c711b7120183f899af59849df74982f595de0" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="27052094f3a72a9f04c55988b8fcc4b55c99cb46" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments, then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="bf6802705f363000e83d105cf3b075ebc1fbcacb" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 이전에 내부 검사 된 경우 BeanInfo 캐시에서 BeanInfo 클래스가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="74b13711d7aed1bc07acd1271fe358967b6f6726" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="2d00c2a268a3801edc2c4c099c48a140b0fd8461" translate="yes" xml:space="preserve">
          <source>If the CleaningExample is used in a try-finally block then the &lt;code&gt;close&lt;/code&gt; method calls the cleaning action. If the &lt;code&gt;close&lt;/code&gt; method is not called, the cleaning action is called by the Cleaner when the CleaningExample instance has become phantom reachable.</source>
          <target state="translated">If the CleaningExample is used in a try-finally block then the &lt;code&gt;close&lt;/code&gt; method calls the cleaning action. If the &lt;code&gt;close&lt;/code&gt; method is not called, the cleaning action is called by the Cleaner when the CleaningExample instance has become phantom reachable.</target>
        </trans-unit>
        <trans-unit id="454995cc2e260c1d06757623f1b5ad1b2feb2e38" translate="yes" xml:space="preserve">
          <source>If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods.</source>
          <target state="translated">If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods.</target>
        </trans-unit>
        <trans-unit id="a17b4fd0fc3c2da711064a3199127d020c189ac1" translate="yes" xml:space="preserve">
          <source>If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods. If the ColorModel is not an IndexColorModel or is null, this method overrides the default ColorModel used by the ImageProducer and specifies the default RGB ColorModel instead.</source>
          <target state="translated">If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods. If the ColorModel is not an IndexColorModel or is null, this method overrides the default ColorModel used by the ImageProducer and specifies the default RGB ColorModel instead.</target>
        </trans-unit>
        <trans-unit id="ebb62725402f17c9f293bd13a4222501b92b1afb" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</target>
        </trans-unit>
        <trans-unit id="b15f89fd97901ee1fb24930f37e7ae4ef300f4ae" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one. Converts a buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one. Converts a buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method.</target>
        </trans-unit>
        <trans-unit id="a2d4a4e4912ac5e9ff71960aac1cb3d98b8ae728" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel.</target>
        </trans-unit>
        <trans-unit id="f5b2b08b4860ee3f58dfbccb3e9b728f83daa433" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel. Otherwise converts the buffer of byte pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</source>
          <target state="translated">If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel. Otherwise converts the buffer of byte pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</target>
        </trans-unit>
        <trans-unit id="2fc0046f2b504de87c74868c9d33ea3f35f1d246" translate="yes" xml:space="preserve">
          <source>If the DTD contains an explicit value, as in: &lt;code&gt;&amp;lt;!ATTLIST OPTION selected (selected) #IMPLIED&amp;gt;&lt;/code&gt; this value from the dtd (in this case selected) will be used.</source>
          <target state="translated">If the DTD contains an explicit value, as in: &lt;code&gt;&amp;lt;!ATTLIST OPTION selected (selected) #IMPLIED&amp;gt;&lt;/code&gt; this value from the dtd (in this case selected) will be used.</target>
        </trans-unit>
        <trans-unit id="2cb72115f8155cafe91c7be2e683edb1180ccb8f" translate="yes" xml:space="preserve">
          <source>If the DTD does not contain an definition for the element, or the definition does not have an explicit value then the value in the AttributeSet will be &lt;code&gt;HTML.NULL_ATTRIBUTE_VALUE&lt;/code&gt;.</source>
          <target state="translated">If the DTD does not contain an definition for the element, or the definition does not have an explicit value then the value in the AttributeSet will be &lt;code&gt;HTML.NULL_ATTRIBUTE_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f28761ed1b352634ef38205fef3a87519af308" translate="yes" xml:space="preserve">
          <source>If the Document structure changed as result of the insertion, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to an insertion.</source>
          <target state="translated">If the Document structure changed as result of the insertion, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to an insertion.</target>
        </trans-unit>
        <trans-unit id="030cb95378711b1636920c7d0827ed5b14eb88fe" translate="yes" xml:space="preserve">
          <source>If the Document structure changed as result of the removal, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to a remove.</source>
          <target state="translated">If the Document structure changed as result of the removal, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to a remove.</target>
        </trans-unit>
        <trans-unit id="80ce8c0f1c1c211a90c8b7e66061c58778167da6" translate="yes" xml:space="preserve">
          <source>If the Document supports undo/redo, an UndoableEditEvent will also be generated.</source>
          <target state="translated">If the Document supports undo/redo, an UndoableEditEvent will also be generated.</target>
        </trans-unit>
        <trans-unit id="b0a6b6c38e66debb2926492a33b326ecee7be585" translate="yes" xml:space="preserve">
          <source>If the Drag and Drop System is unable to initiate a drag operation for some reason, the startDrag() method throws a &lt;code&gt;java.awt.dnd.InvalidDnDOperationException&lt;/code&gt; to signal such a condition. Typically this exception is thrown when the underlying platform system is either not in a state to initiate a drag, or the parameters specified are invalid.</source>
          <target state="translated">If the Drag and Drop System is unable to initiate a drag operation for some reason, the startDrag() method throws a &lt;code&gt;java.awt.dnd.InvalidDnDOperationException&lt;/code&gt; to signal such a condition. Typically this exception is thrown when the underlying platform system is either not in a state to initiate a drag, or the parameters specified are invalid.</target>
        </trans-unit>
        <trans-unit id="b36a3a37ab405a50245f8ca60d31eb1f24fccf64" translate="yes" xml:space="preserve">
          <source>If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, or the drop handler throws an exception when processing a dropped item, then this exception is rethrown.</source>
          <target state="translated">If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, or the drop handler throws an exception when processing a dropped item, then this exception is rethrown.</target>
        </trans-unit>
        <trans-unit id="b41cd91e530f36a9b0da3d978e7ece27002c8489" translate="yes" xml:space="preserve">
          <source>If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, then this exception is rethrown, in which case not all subscribers will have been issued this item.</source>
          <target state="translated">If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, then this exception is rethrown, in which case not all subscribers will have been issued this item.</target>
        </trans-unit>
        <trans-unit id="0a887cc255dc4733cf1b5653b5998661c76f2b20" translate="yes" xml:space="preserve">
          <source>If the GSSManager implementation does not support an SPI with a pluggable provider architecture it should throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.</source>
          <target state="translated">If the GSSManager implementation does not support an SPI with a pluggable provider architecture it should throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.</target>
        </trans-unit>
        <trans-unit id="da20e7ea76a9a643faf6481a32f3400ecce492d3" translate="yes" xml:space="preserve">
          <source>If the IP address is a &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address, or is &lt;code&gt;null&lt;/code&gt;, the socket will be bound to the wildcard address.</source>
          <target state="translated">IP 주소가 &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt; 주소이거나 &lt;code&gt;null&lt;/code&gt; 인 경우 소켓은 와일드 카드 주소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="ad4939c5094269e4f9d10a41688acc1a518009fa" translate="yes" xml:space="preserve">
          <source>If the JAR file has a &lt;code&gt;Main-Class&lt;/code&gt; attribute in its main manifest, its value is a legal class name, and its package is in the set of packages derived for the module, then the value is the module &lt;a href=&quot;moduledescriptor#mainClass()&quot;&gt;main class&lt;/a&gt;.</source>
          <target state="translated">If the JAR file has a &lt;code&gt;Main-Class&lt;/code&gt; attribute in its main manifest, its value is a legal class name, and its package is in the set of packages derived for the module, then the value is the module &lt;a href=&quot;moduledescriptor#mainClass()&quot;&gt;main class&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c9ace20d58b64f9f5ea681de79599cbf699eebec" translate="yes" xml:space="preserve">
          <source>If the JAR file has the attribute &quot;&lt;code&gt;Automatic-Module-Name&lt;/code&gt;&quot; in its main manifest then its value is the &lt;a href=&quot;moduledescriptor#name()&quot;&gt;module name&lt;/a&gt;. The module name is otherwise derived from the name of the JAR file.</source>
          <target state="translated">If the JAR file has the attribute &quot; &lt;code&gt;Automatic-Module-Name&lt;/code&gt; &quot; in its main manifest then its value is the &lt;a href=&quot;moduledescriptor#name()&quot;&gt;module name&lt;/a&gt;. The module name is otherwise derived from the name of the JAR file.</target>
        </trans-unit>
        <trans-unit id="bce7057e5b6fdd5c5ebdea045f965918043cd418" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; may be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; may be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver. The method &lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt; retrieves the value.</target>
        </trans-unit>
        <trans-unit id="eaed8c58c642d50f6930fd66554c7e5248239528" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver.. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver.. The method &lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt; retrieves the value.</target>
        </trans-unit>
        <trans-unit id="b6b43fc4ae5c3356c9a39c1f15c9fcd8a5ed346a" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;java.sql.Types.OTHER&lt;/code&gt;. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;java.sql.Types.OTHER&lt;/code&gt; . The method &lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt; retrieves the value.</target>
        </trans-unit>
        <trans-unit id="d8e121332002fc8657fe1d312a926bed5da0268b" translate="yes" xml:space="preserve">
          <source>If the Java implementation provides the command-line interface and you run your application by using the command line or a shortcut, use the Java application launcher option to show a splash screen. The Oracle reference implementation allows you to specify the splash screen image location with the &lt;code&gt;-splash:&lt;/code&gt; option.</source>
          <target state="translated">If the Java implementation provides the command-line interface and you run your application by using the command line or a shortcut, use the Java application launcher option to show a splash screen. The Oracle reference implementation allows you to specify the splash screen image location with the &lt;code&gt;-splash:&lt;/code&gt; option.</target>
        </trans-unit>
        <trans-unit id="540e105812b408574fe65500e02fda28804c6512" translate="yes" xml:space="preserve">
          <source>If the List allows multiple selections, then clicking on an item that is already selected deselects it. In the preceding example, only one item from the scrolling list can be selected at a time, since the second argument when creating the new scrolling list is &lt;code&gt;false&lt;/code&gt;. If the List does not allow multiple selections, selecting an item causes any other selected item to be deselected.</source>
          <target state="translated">If the List allows multiple selections, then clicking on an item that is already selected deselects it. In the preceding example, only one item from the scrolling list can be selected at a time, since the second argument when creating the new scrolling list is &lt;code&gt;false&lt;/code&gt; . If the List does not allow multiple selections, selecting an item causes any other selected item to be deselected.</target>
        </trans-unit>
        <trans-unit id="b9320150224d23795105d0b84d8ba0219f014f46" translate="yes" xml:space="preserve">
          <source>If the LoginContext's overall authentication failed (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed), then the &lt;code&gt;abort&lt;/code&gt; method for each &lt;code&gt;LoginModule&lt;/code&gt; gets invoked. In this case, the &lt;code&gt;LoginModule&lt;/code&gt; removes/destroys any authentication state originally saved.</source>
          <target state="translated">LoginContext의 전체 인증에 실패한 경우 (관련된 REQUIRED, REQUISITE, SUFFICIENT 및 OPTIONAL LoginModules가 실패한 경우) 각 &lt;code&gt;LoginModule&lt;/code&gt; 에 대한 &lt;code&gt;abort&lt;/code&gt; 메소드 가 호출됩니다. 이 경우 &lt;code&gt;LoginModule&lt;/code&gt; 은 원래 저장된 인증 상태를 제거 / 파기합니다.</target>
        </trans-unit>
        <trans-unit id="8b1ca264c954dc0a754372106598096735c9ddf1" translate="yes" xml:space="preserve">
          <source>If the MXBean is a notification emitter (i.e., it implements &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt;), both the &lt;code&gt;mxbeanInterface&lt;/code&gt; and &lt;code&gt;NotificationEmitter&lt;/code&gt; will be implemented by this proxy.</source>
          <target state="translated">MXBean가 통지 이미 터 인 경우 (즉, &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; 를&lt;/a&gt; 구현 하는 경우) &lt;code&gt;mxbeanInterface&lt;/code&gt; 와 &lt;code&gt;NotificationEmitter&lt;/code&gt; 가이 프록시에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="474328420a397c96b5f80aa5f7aa2f2d53878174" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; &lt;/a&gt; wrapping an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b43d6c84cc6fb1e54fa1b85884c057f4a6774967" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ModelMBean가 현재 등록되어있는 경우,이 메소드는 &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 을&lt;/a&gt; 랩핑하는 &lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="0961519d04df02ef89d0ae88943ca50d0c3606b3" translate="yes" xml:space="preserve">
          <source>If the Namespace URI is &lt;code&gt;null&lt;/code&gt;, it is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. This value represents no explicitly defined Namespace as defined by the &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;Namespaces in XML&lt;/a&gt; specification. This action preserves compatible behavior with QName 1.0. Explicitly providing the &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; value is the preferred coding style.</source>
          <target state="translated">If the Namespace URI is &lt;code&gt;null&lt;/code&gt; , it is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;. This value represents no explicitly defined Namespace as defined by the &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;Namespaces in XML&lt;/a&gt; specification. This action preserves compatible behavior with QName 1.0. Explicitly providing the &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; value is the preferred coding style.</target>
        </trans-unit>
        <trans-unit id="dabcc8898ed3cdd7dba813817a17b3c719cbc02b" translate="yes" xml:space="preserve">
          <source>If the Namespace URI is &lt;code&gt;null&lt;/code&gt;, it is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. This value represents no explicitly defined Namespace as defined by the &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;Namespaces in XML&lt;/a&gt; specification. This action preserves compatible behavior with QName 1.0. Explicitly providing the &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; value is the preferred coding style.</source>
          <target state="translated">네임 스페이스 URI가 &lt;code&gt;null&lt;/code&gt; 이면&lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 . 이 값은 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;XML&lt;/a&gt; 사양 의 네임 스페이스에 정의 된대로 명시 적으로 정의 된 네임 스페이스가 없음을 나타냅니다 . 이 작업은 QName 1.0과 호환되는 동작을 유지합니다. &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; 값을 명시 적으로 제공하는 것이 선호되는 코딩 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="e5cc0b4b6523113fb60bbdd890e2ed587190e3eb" translate="yes" xml:space="preserve">
          <source>If the PropertyEditor doesn't honor paint requests (see isPaintable) this method should be a silent noop.</source>
          <target state="translated">PropertyEditor가 페인트 요청을 준수하지 않으면 (isPaintable 참조)이 메소드는 자동 스킵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="edc7ecb68896dc99cf3bfe6d1c68065fc233cc04" translate="yes" xml:space="preserve">
          <source>If the ProtectionDomain was constructed to a &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt;&lt;code&gt;statically bound&lt;/code&gt;&lt;/a&gt; PermissionCollection then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">ProtectionDomain이 &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt; &lt;code&gt;statically bound&lt;/code&gt; &lt;/a&gt; PermissionCollection 으로 구성된 경우 권한은 구성시 제공된 PermissionCollection에 대해서만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="a847aec68a3d5a379f34ca3fc370c158f7a9888a" translate="yes" xml:space="preserve">
          <source>If the Result is not to be written to a file, the system identifier is optional. The application may still want to provide one, however, for use in error messages and warnings, or to resolve relative output identifiers.</source>
          <target state="translated">If the Result is not to be written to a file, the system identifier is optional. The application may still want to provide one, however, for use in error messages and warnings, or to resolve relative output identifiers.</target>
        </trans-unit>
        <trans-unit id="d85ecd870d90f0c4db4acd7de59edc66dc5f937f" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorservermbean#getAddress()&quot;&gt;&lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash ( &lt;code&gt;/&lt;/code&gt; ), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorservermbean#getAddress()&quot;&gt; &lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt; &lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1eb3e9bfa37e0fb36cbe25f740fc69395067b33e" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt;&lt;code&gt;getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; and &lt;code&gt;iiop&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 의 URL 경로 부분 이 비어 있거나 단일 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 인 경우 RMI 오브젝트는 디렉토리에 바인드되지 않습니다. 대신, 이에 대한 참조는 RMIConnectorServer 주소의 URL 경로 ( &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt; &lt;code&gt;getAddress()&lt;/code&gt; &lt;/a&gt; 로 리턴 됨 ) 로 인코딩됩니다 . &lt;code&gt;rmi&lt;/code&gt; 및 &lt;code&gt;iiop&lt;/code&gt; 의 인코딩은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt; 의 패키지 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c88147c00b169cc4a7d700bc22d47ae19dc49b7" translate="yes" xml:space="preserve">
          <source>If the URL specified is &lt;code&gt;null&lt;/code&gt; or is already in the list of URLs, or if this loader is closed, then invoking this method has no effect.</source>
          <target state="translated">지정된 URL이 &lt;code&gt;null&lt;/code&gt; 이거나 이미 URL 목록에 있거나이 로더가 닫혀 있으면이 메소드를 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c0237f144da2fa8c67cb271e88ffe70a6e43f35" translate="yes" xml:space="preserve">
          <source>If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;. It is an error if they don't meet the requirements.</source>
          <target state="translated">USE_STD3_ASCII_RULES 플래그가 사용되면 ASCII 문자열이 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt; 에 대해 검사 됩니다. 요구 사항을 충족하지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b6f15acd38bd7687f1a77e9bf3871ba04075f07a" translate="yes" xml:space="preserve">
          <source>If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;https://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;https://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;. It is an error if they don't meet the requirements.</source>
          <target state="translated">USE_STD3_ASCII_RULES 플래그가 사용되면 ASCII 문자열이 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; 및 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt; 에 대해 확인 됩니다. 요구 사항을 충족하지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="27b1988df75b26444a795d6673a2d8719150a662" translate="yes" xml:space="preserve">
          <source>If the Unicode Standard changes block names, both the previous and current names will be accepted.</source>
          <target state="translated">유니 코드 표준이 블록 이름을 변경하면 이전 이름과 현재 이름이 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4474e2c1fcf43dbf037954df628912501189beb2" translate="yes" xml:space="preserve">
          <source>If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector &lt;em&gt;only&lt;/em&gt; if the caller knows that the Vector does not contain any null elements.)</source>
          <target state="translated">여유 공간이있는 지정된 배열에 Vector가 적합하면 (즉, 배열에 Vector보다 많은 요소가있는 경우) Vector의 끝 바로 뒤에있는 배열의 요소는 null로 설정됩니다. (이것은 호출자가 Vector에 null 요소가 없음을 알고있는 경우 &lt;em&gt;에만&lt;/em&gt; Vector의 길이를 결정하는 데 유용 합니다.)</target>
        </trans-unit>
        <trans-unit id="ce465ff8cda6a5a08541bee73f2366bdc5b6d6b4" translate="yes" xml:space="preserve">
          <source>If the WebSocket's output is not already closed, the &lt;code&gt;CompletionStage&lt;/code&gt; returned by this method will be used as an indication that the WebSocket's output may be closed. The WebSocket will close its output at the earliest of completion of the returned &lt;code&gt;CompletionStage&lt;/code&gt; or invoking either of the &lt;code&gt;sendClose&lt;/code&gt; or &lt;code&gt;abort&lt;/code&gt; methods.</source>
          <target state="translated">If the WebSocket's output is not already closed, the &lt;code&gt;CompletionStage&lt;/code&gt; returned by this method will be used as an indication that the WebSocket's output may be closed. The WebSocket will close its output at the earliest of completion of the returned &lt;code&gt;CompletionStage&lt;/code&gt; or invoking either of the &lt;code&gt;sendClose&lt;/code&gt; or &lt;code&gt;abort&lt;/code&gt; methods.</target>
        </trans-unit>
        <trans-unit id="fa08a72545add7979284f586fe9352374af63dad" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../../java.desktop/java/beans/introspector#getBeanInfo(java.lang.Class)&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../../java.desktop/java/beans/introspector#getBeanInfo(java.lang.Class)&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt;, for the class of</target>
        </trans-unit>
        <trans-unit id="9f95877bd50006d6d00056ef2a51aa22bd21083c" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">위의 규칙이 값을 생성하지 않고 introspection 인 경우 &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt; 를 호출 하여</target>
        </trans-unit>
        <trans-unit id="9b05835af2c154a7c76f77377aa6c52d404cdcb8" translate="yes" xml:space="preserve">
          <source>If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.</source>
          <target state="translated">첫 번째 인수의 절대 값이 1이고 두 번째 인수가 무한하면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="fe0dcdb806d329477c57d32f9509598b1acef0b9" translate="yes" xml:space="preserve">
          <source>If the accelerator is hidden, the method returns &lt;code&gt;true&lt;/code&gt;, otherwise, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">If the accelerator is hidden, the method returns &lt;code&gt;true&lt;/code&gt; , otherwise, returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6775ecd73f74676bf13df91da30c3cc2254a84a5" translate="yes" xml:space="preserve">
          <source>If the action has been registered multiple times, all instances are unregistered.</source>
          <target state="translated">작업이 여러 번 등록 된 경우 모든 인스턴스가 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="e03f3411418a033b6bfa2f883c240355cb3f69a7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6afccfd8739251584afc0914039b51c90ada53f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66516904fde9701dc7f61bc426819fb4f146f708" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e52e55025286a627afde1b1d2b384ea2bee735b" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5601c43da232fcabd407827972e1da20bb1375e" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="69341c18d84e15fb20d184c341ea1d0d7b8cbcda" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0773f07cee5964ddff6a0726a10424e6fde400aa" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6eb467bff49959d09e05c7bab75146704c0dc28d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc7b37b752547334d50d87c5179ebe5f7826e35" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4a7f713f21116ad3b228e0623aa03e2b62a6679" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91611fb9a517d38eefd5a99f44bd0d85a21d0920" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5728c1fd6c7474b8e5ee24332d657e8c59b795d7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="06d370e1cbaab2bb12cd8d0300073053596d5bf6" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="290eeb3f1f54f16b09955c88d8cfd90d14b9557d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0dcd5ef32e41f4bca014a916ec5e3e0e6b1fab7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00bbc10814534bf0219172f193911a9aeadd7e16" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8e64dea02dd187ab7473bf716270a883a77afdc" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2cd031f75c6a92efb253dc0527bb3d0bd986894f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt; , by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt; , and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3b5ff8c69ea26957c669b0830c3787c984d9d074" translate="yes" xml:space="preserve">
          <source>If the action performed in your &lt;code&gt;run&lt;/code&gt; method could throw a &quot;checked&quot; exception (those listed in the &lt;code&gt;throws&lt;/code&gt; clause of a method), then you need to use the &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; interface instead of the &lt;code&gt;PrivilegedAction&lt;/code&gt; interface:</source>
          <target state="translated">작업이 수행되면 &lt;code&gt;run&lt;/code&gt; 던질 수있는 방법 A 예외를 (에 나열된 사람들은 &quot;확인&quot; &lt;code&gt;throws&lt;/code&gt; 방법의 절을), 당신은 사용할 필요가 &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 와의 대신의 인터페이스 &lt;code&gt;PrivilegedAction&lt;/code&gt; 인터페이스를 :</target>
        </trans-unit>
        <trans-unit id="1c19e93235c53e902185c8c29dee0714c658ee6f" translate="yes" xml:space="preserve">
          <source>If the action was registered via &lt;code&gt;registerKeyboardAction&lt;/code&gt;, then the command string passed in (&lt;code&gt;null&lt;/code&gt; will be used if &lt;code&gt;null&lt;/code&gt; was passed in).</source>
          <target state="translated">If the action was registered via &lt;code&gt;registerKeyboardAction&lt;/code&gt; , then the command string passed in ( &lt;code&gt;null&lt;/code&gt; will be used if &lt;code&gt;null&lt;/code&gt; was passed in).</target>
        </trans-unit>
        <trans-unit id="f8b6f3a11b20582c114df00bdb40a1e0e0cbd27f" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an</source>
          <target state="translated">액션의 &lt;code&gt;run&lt;/code&gt; 메소드가</target>
        </trans-unit>
        <trans-unit id="6baa6ffe1bf64066619e4375881dfdc0f383d936" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an (unchecked) exception, it will propagate through this method.</source>
          <target state="translated">액션의 &lt;code&gt;run&lt;/code&gt; 메소드가 (확인되지 ​​않은) 예외를 throw하면이 메소드를 통해 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="81ae8e4005f2526ae09ac862718dd7fa76cfe92e" translate="yes" xml:space="preserve">
          <source>If the activation group for the object's group descriptor does not yet exist, the activator starts an &lt;code&gt;ActivationInstantiator&lt;/code&gt; executing (by spawning a child process, for example). When the activator receives the activation group's call back (via the &lt;code&gt;ActivationSystem&lt;/code&gt;'s &lt;code&gt;activeGroup&lt;/code&gt; method) specifying the activation group's reference, the activator can then invoke that activation instantiator's &lt;code&gt;newInstance&lt;/code&gt; method to forward each pending activation request to the activation group and return the result (a marshalled remote object reference, a stub) to the caller.</source>
          <target state="translated">If the activation group for the object's group descriptor does not yet exist, the activator starts an &lt;code&gt;ActivationInstantiator&lt;/code&gt; executing (by spawning a child process, for example). When the activator receives the activation group's call back (via the &lt;code&gt;ActivationSystem&lt;/code&gt; 's &lt;code&gt;activeGroup&lt;/code&gt; method) specifying the activation group's reference, the activator can then invoke that activation instantiator's &lt;code&gt;newInstance&lt;/code&gt; method to forward each pending activation request to the activation group and return the result (a marshalled remote object reference, a stub) to the caller.</target>
        </trans-unit>
        <trans-unit id="6c727c33b10329c8a55fc35a2c969597ddaf2670" translate="yes" xml:space="preserve">
          <source>If the address is &lt;code&gt;null&lt;/code&gt; an unbound socket will be created.</source>
          <target state="translated">주소가 &lt;code&gt;null&lt;/code&gt; 이면 언 바운드 소켓이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="102269f064fade95ae910ba7bdf983251013c399" translate="yes" xml:space="preserve">
          <source>If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up an ephemeral port and a valid local address to bind the socket.</source>
          <target state="translated">주소가 &lt;code&gt;null&lt;/code&gt; 인 경우 시스템은 임시 포트와 유효한 로컬 주소를 선택하여 소켓을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="deed334073f68c6d00e85a8098ad4ebaa1319066" translate="yes" xml:space="preserve">
          <source>If the agent cannot be started (for example, because the agent class cannot be loaded, or because the agent class does not have an appropriate &lt;code&gt;premain&lt;/code&gt; method), the JVM will abort. If a &lt;code&gt;premain&lt;/code&gt; method throws an uncaught exception, the JVM will abort.</source>
          <target state="translated">If the agent cannot be started (for example, because the agent class cannot be loaded, or because the agent class does not have an appropriate &lt;code&gt;premain&lt;/code&gt; method), the JVM will abort. If a &lt;code&gt;premain&lt;/code&gt; method throws an uncaught exception, the JVM will abort.</target>
        </trans-unit>
        <trans-unit id="3bdc279bcf6c5ee605cac5004f25fb4a4dd94ae8" translate="yes" xml:space="preserve">
          <source>If the agent class does not implement this method then the JVM will attempt to invoke:</source>
          <target state="translated">If the agent class does not implement this method then the JVM will attempt to invoke:</target>
        </trans-unit>
        <trans-unit id="e4c80757c9e2ecb6b75dc0a37636c30cb9490032" translate="yes" xml:space="preserve">
          <source>If the algorithm is the</source>
          <target state="translated">알고리즘이</target>
        </trans-unit>
        <trans-unit id="80ea754a698145f128fdf52efea523a98452381c" translate="yes" xml:space="preserve">
          <source>If the alpha component of the requested background color is less than &lt;code&gt;1.0f&lt;/code&gt;, and any of the above conditions are not met, the background color of this window will not change, the alpha component of the given background color will not affect the mode of operation for this window, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt;
 IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the alpha component of the requested background color is less than &lt;code&gt;1.0f&lt;/code&gt; , and any of the above conditions are not met, the background color of this window will not change, the alpha component of the given background color will not affect the mode of operation for this window, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt; IllegalComponentStateException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="0e8d5a3e745f1450eac261edbc32910b4882938f" translate="yes" xml:space="preserve">
          <source>If the amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must use the ISO chronology.</source>
          <target state="translated">금액이 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인 경우 ISO 연대기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="88b1d50bbaec9f5487c27e8e4cb2386eb42847f9" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;
 TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get(int)&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">주어진 타임 스탬프에서 시간을 절약해야하는 경우이 &lt;code&gt; TimeZone&lt;/code&gt; 및 타임 스탬프를 사용 하여 &lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt; 을 구성하고 &lt;a href=&quot;calendar#get(int)&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="4d740232e114f21d31c73ca4687c4057fb29ccd4" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get-int-&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">지정된 타임 스탬프에서 절약 시간이 필요한 경우이 &lt;code&gt;TimeZone&lt;/code&gt; 과 타임 스탬프를 사용 하여 &lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt; 를 구성하고 &lt;a href=&quot;calendar#get-int-&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; ( Calendar.DST_OFFSET &lt;code&gt;)&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="08afeee4bde07dab89f440c39fce86a0eb463b56" translate="yes" xml:space="preserve">
          <source>If the annotation &lt;code&gt;@Documented&lt;/code&gt; is present on the declaration of an annotation type</source>
          <target state="translated">주석 경우 &lt;code&gt;@Documented&lt;/code&gt; 는 주석 형의 선언에 존재</target>
        </trans-unit>
        <trans-unit id="272549f61fd737d1e73b2c36c4aa004c00079132" translate="yes" xml:space="preserve">
          <source>If the answer is NO, go to the next step.</source>
          <target state="translated">대답이 아니오이면 다음 단계로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f57b79608f2a3ff0ec11e483aaaa3a019d8c2b5b" translate="yes" xml:space="preserve">
          <source>If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; exception.</source>
          <target state="translated">대답이 NO이면 &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="434e3dee0acd3560230fa30595feca5a213bbce4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 및 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="a1eb85cb2614bd41f0d6af38673aa7528bca07f4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="de83ee4eae564494ffc414cfaf8cc18d47b2bed1" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="56a7594c327855897bea9f06e5423ff72ccb1d7b" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it.</source>
          <target state="translated">대답이 예이면 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="160782cdb54c84087be65e0efddfac392e283c77" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate this class, for whose mode and padding scheme default values (as supplied by the provider) are used.</source>
          <target state="translated">대답이 YES 인 경우,이 클래스를 인스턴스화하십시오 (제공자가 제공 한 모드 및 패딩 구성표 기본값이 사용됨).</target>
        </trans-unit>
        <trans-unit id="e4bd31b53dccf5705cdd32f1466082805129fc6c" translate="yes" xml:space="preserve">
          <source>If the application creates a login context using an &lt;em&gt;installed&lt;/em&gt;&lt;a href=&quot;../../../../../../java.base/javax/security/auth/login/configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; then the application must be granted the &lt;a href=&quot;../../../../../../java.base/javax/security/auth/authpermission&quot;&gt;&lt;code&gt;AuthPermission&lt;/code&gt;&lt;/a&gt; to create login contexts. For example, the following security policy allows an application in the user's current directory to instantiate &lt;em&gt;any&lt;/em&gt; login context:</source>
          <target state="translated">애플리케이션이 &lt;em&gt;설치된 &lt;/em&gt;&lt;a href=&quot;../../../../../../java.base/javax/security/auth/login/configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 을 사용하여 로그인 컨텍스트를 생성하는 경우 로그인 컨텍스트를 생성 하려면 애플리케이션에 &lt;a href=&quot;../../../../../../java.base/javax/security/auth/authpermission&quot;&gt; &lt;code&gt;AuthPermission&lt;/code&gt; &lt;/a&gt; 을 부여해야 합니다. 예를 들어 다음 보안 정책은 사용자의 현재 디렉터리에있는 응용 프로그램이 &lt;em&gt;모든&lt;/em&gt; 로그인 컨텍스트 를 인스턴스화하도록 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="5fe99f49bc1a1090e02dd6efd4b8d8fd6a67f30a" translate="yes" xml:space="preserve">
          <source>If the application does not register a DTD handler, all DTD events reported by the SAX parser will be silently ignored (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">애플리케이션이 DTD 핸들러를 등록하지 않으면 SAX 파서가보고 한 모든 DTD 이벤트가 자동으로 무시됩니다 (이는 HandlerBase에서 구현하는 기본 동작입니다).</target>
        </trans-unit>
        <trans-unit id="1c521b3dbb8b44d5fe2bd6f0ccfd70ada67afc00" translate="yes" xml:space="preserve">
          <source>If the application does not register a DTD handler, all DTD events reported by the SAX parser will be silently ignored.</source>
          <target state="translated">애플리케이션이 DTD 핸들러를 등록하지 않으면 SAX 파서가보고 한 모든 DTD 이벤트가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1995f916cc7b7a0f6ced6ac9ec5d117bf0b42738" translate="yes" xml:space="preserve">
          <source>If the application does not register a content handler, all content events reported by the SAX parser will be silently ignored.</source>
          <target state="translated">애플리케이션이 컨텐츠 핸들러를 등록하지 않으면 SAX 파서가보고 한 모든 컨텐츠 이벤트가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a62c70d6bc1bda91dda6bd20cde5a3d284087c97" translate="yes" xml:space="preserve">
          <source>If the application does not register a document handler, all document events reported by the SAX parser will be silently ignored (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">애플리케이션이 문서 핸들러를 등록하지 않으면 SAX 파서가보고하는 모든 문서 이벤트가 자동으로 무시됩니다 (이는 HandlerBase에서 구현하는 기본 동작입니다).</target>
        </trans-unit>
        <trans-unit id="5cbd83d12c880c04a3ca2b1f0acd010cea0950ae" translate="yes" xml:space="preserve">
          <source>If the application does not register an entity resolver, the SAX parser will resolve system identifiers and open connections to entities itself (this is the default behaviour implemented in HandlerBase).</source>
          <target state="translated">응용 프로그램이 엔터티 확인자를 등록하지 않으면 SAX 파서는 시스템 식별자를 확인하고 엔터티 자체에 대한 연결을 엽니 다 (이는 HandlerBase에서 구현되는 기본 동작).</target>
        </trans-unit>
        <trans-unit id="a8af630e8d72ae977eff66966545a162b07a84de" translate="yes" xml:space="preserve">
          <source>If the application does not register an entity resolver, the XMLReader will perform its own default resolution.</source>
          <target state="translated">응용 프로그램이 엔티티 확인자를 등록하지 않으면 XMLReader는 자체 기본 확인을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0b84de5172675bfd46a10466b2f6619156504747" translate="yes" xml:space="preserve">
          <source>If the application does not register an error event handler, all error events reported by the SAX parser will be silently ignored, except for fatalError, which will throw a SAXException (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">응용 프로그램이 오류 이벤트 처리기를 등록하지 않으면 SAX 파서가보고 한 모든 오류 이벤트가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc77f1bc697f56ce88184dfc957115a66d88b958" translate="yes" xml:space="preserve">
          <source>If the application does not register an error handler, all error events reported by the SAX parser will be silently ignored; however, normal processing may not continue. It is highly recommended that all SAX applications implement an error handler to avoid unexpected bugs.</source>
          <target state="translated">애플리케이션이 오류 처리기를 등록하지 않으면 SAX 파서에서보고 한 모든 오류 이벤트가 자동으로 무시됩니다. 그러나 정상적인 처리가 계속되지 않을 수 있습니다. 예기치 않은 버그를 방지하기 위해 모든 SAX 응용 프로그램에서 오류 처리기를 구현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="968a78947275cffe7a67b6a953d091962ffdb8ec" translate="yes" xml:space="preserve">
          <source>If the application has previously set up an instance of &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; as the stream handler factory, then the &lt;code&gt;createURLStreamHandler&lt;/code&gt; method of that instance is called with the protocol string as an argument to create the stream protocol handler.</source>
          <target state="translated">애플리케이션이 이전 에 스트림 핸들러 팩토리로 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 의 인스턴스를 설정 한 경우 해당 인스턴스의 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 메소드가 스트림 문자열 핸들러를 작성하기위한 인수로 프로토콜 문자열과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2070d70078ec2db5e6d48447de6438828f0279ed" translate="yes" xml:space="preserve">
          <source>If the application has set up a content handler factory instance using the &lt;code&gt;setContentHandlerFactory&lt;/code&gt; method, the &lt;code&gt;createContentHandler&lt;/code&gt; method of that instance is called with the content type as an argument; the result is a content handler for that content type.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;setContentHandlerFactory&lt;/code&gt; 메소드를 사용하여 컨텐츠 핸들러 팩토리 인스턴스를 설정 한 경우 &lt;code&gt;createContentHandler&lt;/code&gt; 메소드가 컨텐츠 유형을 인수로 사용하여 호출됩니다. 결과는 해당 컨텐츠 유형에 대한 컨텐츠 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="070f984b52d47c94ac613db630c4269a97e28431" translate="yes" xml:space="preserve">
          <source>If the application has specified a client socket implementation factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a system-default socket implementation is created.</source>
          <target state="translated">응용 프로그램이 클라이언트 소켓 구현 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메서드가 호출되어 실제 소켓 구현을 만듭니다. 그렇지 않으면 시스템 기본 소켓 구현이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="91fdcd973932e65f09e9bdaebd48fb198c503271" translate="yes" xml:space="preserve">
          <source>If the application has specified a server socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">응용 프로그램에서 서버 소켓 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출되어 실제 소켓 구현을 작성합니다. 그렇지 않으면 &quot;일반&quot;소켓이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="465cff58e0c3971e42da1cffbcef9b2b3ac06798" translate="yes" xml:space="preserve">
          <source>If the application has specified a server socket implementation factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a system-default socket implementation is created.</source>
          <target state="translated">애플리케이션이 서버 소켓 구현 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메서드가 호출되어 실제 소켓 구현을 만듭니다. 그렇지 않으면 시스템 기본 소켓 구현이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="221a9611027772cf1f0b3bdc427ffc5e66a9af4e" translate="yes" xml:space="preserve">
          <source>If the application has specified a socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">애플리케이션이 소켓 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출되어 실제 소켓 구현을 작성합니다. 그렇지 않으면 &quot;일반&quot;소켓이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="242a93fe7324bd12593bab009aad2ea56baf1bef" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;#closeOutbound()&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">애플리케이션이 &lt;a href=&quot;#closeOutbound()&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt; 를 호출하여 닫기 프로세스를 시작한 경우 일부 상황에서는 개시자가 피어의 해당 닫기 메시지를 기다릴 필요가 없습니다. ( 종료 경고 대기에 대한 자세한 내용 은 TLS 사양 ( &lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt; ) 의 섹션 7.2.1을 참조하십시오 .) 이러한 경우이 메서드를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eda2dea38deaa01112fb283b1676ae6c672f0afa" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;#closeOutbound()&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;https://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">애플리케이션이 &lt;a href=&quot;#closeOutbound()&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt; 를 호출하여 닫기 프로세스를 시작한 경우 일부 상황에서는 개시자가 피어의 해당 닫기 메시지를 기다릴 필요가 없습니다. ( 종료 경고 대기에 대한 자세한 내용 은 TLS 사양 ( &lt;a href=&quot;https://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt; ) 의 섹션 7.2.1을 참조하십시오 .) 이러한 경우이 메서드를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b8dff9cb695d7cf445c13c7a8630fbe3ce30315" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">응용 프로그램이 &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt; 를 호출하여 종료 프로세스를 시작한 경우, 경우에 따라 초기자가 피어의 해당 닫기 메시지를 기다릴 필요가 없습니다. ( 클로저 경보 대기에 대한 자세한 정보 는 TLS 스펙 ( &lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt; )의 7.2.1 섹션을 참조하십시오 .) 이러한 경우이 메소드를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b49e74988c341dbee66d98c70300f05b412e8ad" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set it with the setEncoding method.</source>
          <target state="translated">응용 프로그램이 바이트 스트림의 문자 인코딩을 알고 있으면 setEncoding 메소드로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="85ff560af776424016a6f3b941fc1f9585879f10" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set the encoding attribute. Setting the encoding in this way will override any encoding specified in an XML declaration in the data.</source>
          <target state="translated">애플리케이션이 바이트 스트림의 문자 인코딩을 알고있는 경우 인코딩 속성을 설정해야합니다. 이러한 방식으로 인코딩을 설정하면 데이터의 XML 선언에 지정된 인코딩이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7cfd6e9f0bb81bae2991028adadfb572b93731b0" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the object pointed to by the system identifier, it can register the encoding using the setEncoding method.</source>
          <target state="translated">응용 프로그램이 시스템 식별자가 가리키는 개체의 문자 인코딩을 알고있는 경우 setEncoding 메서드를 사용하여 인코딩을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059304a89c9e8193f2d1a44c913f61a85c77d63d" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the object pointed to by the system identifier, it can set the encoding using the &lt;code&gt;encoding&lt;/code&gt; attribute.</source>
          <target state="translated">응용 프로그램이 시스템 식별자가 가리키는 개체의 문자 인코딩을 알고있는 경우 &lt;code&gt;encoding&lt;/code&gt; 속성을 사용하여 인코딩을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a649bc726d746209da5a8d07601c510d8a5af68b" translate="yes" xml:space="preserve">
          <source>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</source>
          <target state="translated">응용 프로그램이 다른 유형의 예외를 통과해야하는 경우 해당 예외를 SAXException 또는 SAXException에서 파생 된 예외로 래핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff002a2eb7163e0d2f905c4e93d3942c2cb282be" translate="yes" xml:space="preserve">
          <source>If the appropriate stub class could not be found, or if the stub class could not be loaded, or if a problem occurs creating the stub instance, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt;&lt;code&gt;StubNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">적절한 스텁 클래스를 찾을 수 없거나 스텁 클래스를로드 할 수없는 경우 또는 스텁 인스턴스 생성에 문제가 발생하면 &lt;a href=&quot;../stubnotfoundexception&quot;&gt; &lt;code&gt;StubNotFoundException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9908f3b7f0fcd38e518a64cda27a8bcf7af02eae" translate="yes" xml:space="preserve">
          <source>If the argument</source>
          <target state="translated">인수가</target>
        </trans-unit>
        <trans-unit id="a274d22f689f758fbbc17c1c36e25f56726e9e93" translate="yes" xml:space="preserve">
          <source>If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo(java.util.Formatter,int,int,int)&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 을&lt;/a&gt; 구현하면 해당 &lt;a href=&quot;formattable#formatTo(java.util.Formatter,int,int,int)&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt; 메서드가 호출됩니다. 그렇지 않으면 인수의 &lt;code&gt;toString()&lt;/code&gt; 메서드 를 호출하여 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="18ba07a0dacca161f919bf38b3942c5cbf0de7b4" translate="yes" xml:space="preserve">
          <source>If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored.</source>
          <target state="translated">인수 색인이 패턴 문자열에서 둘 이상의 형식 요소에 사용되는 경우, 모든 형식 요소에 새 형식이 사용됩니다. 패턴 문자열의 형식 요소에 인수 인덱스를 사용하지 않으면 새 형식이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="201ffc4148225e00891b41aafa471a7bc0ae4e31" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.</source>
          <target state="translated">인수가 &amp;plusmn; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; 인 경우 결과는 2 &lt;sup&gt;971&lt;/sup&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0500f3687980d0c066085bfc637859d5a0f94f45" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.</source>
          <target state="translated">인수가 &amp;plusmn; 경우 &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; , 결과는 2와 동일하다 &lt;sup&gt;(104)&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="e418b56eeca30ec55767a713e51154185f73b688" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7f800000&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0x7f800000&lt;/code&gt; 이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="cc33fb1734d8e8472093718dadfa691efa944850" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 인 경우 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="67ad4ce5c4db05b329a5cf076b7ace8df7e07d24" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xff800000&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0xff800000&lt;/code&gt; 이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="44b83a1db6251fafa0226412a16d0a5aa743a573" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 인 경우 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="d97807e539c09446e4934a8ca25166f2ed929f7e" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 이면 결과는 &quot; &lt;code&gt;false&lt;/code&gt; &quot;입니다. 인수가 &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 이면 결과는 &lt;a href=&quot;../lang/string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 문자열 입니다. 그렇지 않으면 결과는 &quot; &lt;code&gt;true&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="970f258bf10d8b6db35da86a6962bea7e6f056c5" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 의 경우, 결과는 &quot; &lt;code&gt;false&lt;/code&gt; &quot;입니다. 인수가 &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 인 경우 결과는 &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt; 반환 한 문자열 입니다. 그렇지 않으면 결과는 &quot; &lt;code&gt;true&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4acdffc199e6f4f9b1d96e0f15f8a4c625bb7edd" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;null&lt;/code&gt;&quot;. If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 인 경우 결과는 &quot; &lt;code&gt;null&lt;/code&gt; &quot;입니다. 인수가 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 을&lt;/a&gt; 구현하면 해당 &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 그렇지 않으면 인수의 &lt;code&gt;toString()&lt;/code&gt; 메소드 를 호출하여 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="fe94a89675405323875ef4ec6ff361112380225e" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">인수가 NaN이거나 무한대 또는 양수 0 또는 음수 0이면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f1490c0a73a4bdc7beee59aa0b2e8886fa1ac76" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 무한대이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="e8d658cc42466718800cf906b23004b8262a330a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt;&lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">인수가 NaN 또는 무한이면 결과는 &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt; &lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1입니다.</target>
        </trans-unit>
        <trans-unit id="cc7b80c9b72e91dff938c54c51871d14f95c81ca" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt;&lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">인수가 NaN 또는 무한이면 결과는 &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt; &lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1입니다.</target>
        </trans-unit>
        <trans-unit id="745e5106ba9365f2bce0539ab810d8720f71215b" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or its absolute value is greater than 1, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 절대 값이 1보다 크면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="07291af92544374b52ef8f433433f39f1dbb80d9" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than -1, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 -1보다 작은 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="13a256cb6eee91493a6f005cfe5cd4ae37f9697f" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than zero, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 0보다 작은 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="31b76fec8c3bc86ab1662b04d7bb45867ec9f9d7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is 0.</source>
          <target state="translated">인수가 NaN이면 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="3aa89491f3556c271cee0931546f3e5660ec7ac7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7fc00000&lt;/code&gt;.</source>
          <target state="translated">인수가 NaN이면 결과는 &lt;code&gt;0x7fc00000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a83c5a6baaa1bd2366e8865b925beaeea4e26b42" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7ff8000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 NaN이면 결과는 &lt;code&gt;0x7ff8000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="118d734407198a907583b63ea2fc64d7c89b2c28" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="e064879a9427f94b4430bb8b2822c39d482f8755" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the &lt;code&gt;long&lt;/code&gt; integer representing the actual NaN value. Unlike the &lt;code&gt;doubleToLongBits&lt;/code&gt; method, &lt;code&gt;doubleToRawLongBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">인수가 NaN이면 결과는 실제 NaN 값을 나타내는 &lt;code&gt;long&lt;/code&gt; 정수입니다. &lt;code&gt;doubleToLongBits&lt;/code&gt; 메서드 와 달리 &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 는 NaN을 인코딩하는 모든 비트 패턴을 단일 &quot;표준&quot;NaN 값으로 축소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bca2d981cbc0638a09fdc8f8c3691bf1f893da00" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the integer representing the actual NaN value. Unlike the &lt;code&gt;floatToIntBits&lt;/code&gt; method, &lt;code&gt;floatToRawIntBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">인수가 NaN 인 경우 결과는 실제 NaN 값을 나타내는 정수입니다. &lt;code&gt;floatToIntBits&lt;/code&gt; 메서드 와 달리 &lt;code&gt;floatToRawIntBits&lt;/code&gt; 는 NaN을 인코딩하는 모든 비트 패턴을 단일 &quot;정식&quot;NaN 값으로 축소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db8eab43bb6026b1e9b4780ecae1f1526f2beff3" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the string &quot;&lt;code&gt;NaN&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 NaN이면 결과는 문자열 &quot; &lt;code&gt;NaN&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c12f1031f1e9c83194d8ac6506dee76af527571a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, then the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="d554a647f92a4934769f60285a8988bfd2109472" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;a href=&quot;font/glyphvector&quot;&gt;&lt;code&gt;GlyphVector&lt;/code&gt;&lt;/a&gt;, then the &lt;code&gt;GlyphVector&lt;/code&gt; object already contains the appropriate font-specific glyph codes with explicit coordinates for the position of each glyph.</source>
          <target state="translated">인수가 &lt;a href=&quot;font/glyphvector&quot;&gt; &lt;code&gt;GlyphVector&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;GlyphVector&lt;/code&gt; 객체에는 각 글리프의 위치에 대한 명시 적 좌표가있는 적절한 글꼴 별 글리프 코드가 이미 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33084cbb24930f6a9f5be37e387df07eb5022040" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;code&gt;String&lt;/code&gt;, then the current &lt;code&gt;Font&lt;/code&gt; in the &lt;code&gt;Graphics2D&lt;/code&gt; context is asked to convert the Unicode characters in the &lt;code&gt;String&lt;/code&gt; into a set of glyphs for presentation with whatever basic layout and shaping algorithms the font implements.</source>
          <target state="translated">인수가 있으면 &lt;code&gt;String&lt;/code&gt; 다음은 현재 &lt;code&gt;Font&lt;/code&gt; 에서 &lt;code&gt;Graphics2D&lt;/code&gt; 컨텍스트에서 유니 코드 문자로 변환하도록 요청 &lt;code&gt;String&lt;/code&gt; 어떤 기본 레이아웃과 알고리즘을 폰트 구현을 형성하여 프리젠 테이션을 위해 상형 문자의 집합으로.</target>
        </trans-unit>
        <trans-unit id="5a923aa0ff948589bbbea2c5c98edba0c8041581" translate="yes" xml:space="preserve">
          <source>If the argument is already a localized stream, it may be returned as the result.</source>
          <target state="translated">인수가 이미 지역화 된 스트림 인 경우 결과로 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e184dfc2be8d0cd0cc281824d50fb9ce2efa94b1" translate="yes" xml:space="preserve">
          <source>If the argument is an &lt;a href=&quot;../../../java.base/java/text/attributedcharacteriterator&quot;&gt;&lt;code&gt;AttributedCharacterIterator&lt;/code&gt;&lt;/a&gt;, the iterator is asked to convert itself to a &lt;a href=&quot;font/textlayout&quot;&gt;&lt;code&gt;TextLayout&lt;/code&gt;&lt;/a&gt; using its embedded font attributes. The &lt;code&gt;TextLayout&lt;/code&gt; implements more sophisticated glyph layout algorithms that perform Unicode bi-directional layout adjustments automatically for multiple fonts of differing writing directions.</source>
          <target state="translated">인수가 &lt;a href=&quot;../../../java.base/java/text/attributedcharacteriterator&quot;&gt; &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; &lt;/a&gt; 인 경우 반복자는 자신을&lt;a href=&quot;font/textlayout&quot;&gt; &lt;code&gt;TextLayout&lt;/code&gt; &lt;/a&gt;포함 된 글꼴 속성을 사용하여 TextLayout. &lt;code&gt;TextLayout&lt;/code&gt; 구현 기입 방향이 다른 복수의 폰트를 자동으로 유니 코드 쌍방향 레이아웃 조정을 실행하는보다 정교한 그래프 레이아웃 알고리즘.</target>
        </trans-unit>
        <trans-unit id="e9264d5fd055500aa5c8726a54e413523844cbaf" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7f800001&lt;/code&gt; through &lt;code&gt;0x7fffffff&lt;/code&gt; or in the range &lt;code&gt;0xff800001&lt;/code&gt; through &lt;code&gt;0xffffffff&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;0x7f800001&lt;/code&gt; ~ &lt;code&gt;0x7fffffff&lt;/code&gt; 범위 또는 &lt;code&gt;0xff800001&lt;/code&gt; ~ &lt;code&gt;0xffffffff&lt;/code&gt; 범위의 값 이면 결과는 NaN입니다. Java가 제공하는 IEEE 754 부동 소수점 연산은 비트 패턴이 다른 동일한 유형의 두 NaN 값을 구별 할 수 없습니다. NaN의 고유 값은 &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; 메소드를 사용하여 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e09c36577e890868103778c6cad080360d9fef25" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; through &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; or in the range &lt;code&gt;0xfff0000000000001L&lt;/code&gt; through &lt;code&gt;0xffffffffffffffffL&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; - &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; 범위 또는 &lt;code&gt;0xfff0000000000001L&lt;/code&gt; - &lt;code&gt;0xffffffffffffffffL&lt;/code&gt; 범위의 값 이면 결과는 NaN입니다. Java가 제공하는 IEEE 754 부동 소수점 연산은 비트 패턴이 다른 동일한 유형의 두 NaN 값을 구별 할 수 없습니다. NaN의 고유 한 값은 &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; 메소드를 사용하여 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="108d000cc41c657851b0d27f0a1ac78cf5e4ee70" translate="yes" xml:space="preserve">
          <source>If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for integer</source>
          <target state="translated">정수 의 인수가 &lt;sup&gt;&lt;i&gt;10n 인&lt;/i&gt;&lt;/sup&gt; 경우</target>
        </trans-unit>
        <trans-unit id="65efe2e81fa8d1ba670e4b1992ae1775f4b62a76" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, the result is positive infinity.</source>
          <target state="translated">인수가 무한한 경우 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="336889ed81a3144be451220af338acfcbb6c9ba3" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is an infinity with the same sign as the argument.</source>
          <target state="translated">인수가 무한하면 결과는 인수와 같은 부호를 가진 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="4691c35189f88af211fb42ae9607c8ae123c02d6" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is positive infinity.</source>
          <target state="translated">인수가 무한하면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ec376818cb2e255655d1881f54f64a5f81a51e7b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이거나 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 값보다 작거나 같은 값이면 결과는 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5a08fe9d371940e4f9d92ad57a75f846bb063ec2" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이거나 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 값보다 작거나 같은 경우 결과는 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f1c38692773d898bd9643813b94e0ae1993eb556" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xff800000&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대 &lt;code&gt;0xff800000&lt;/code&gt; 결과는 0xff800000 입니다.</target>
        </trans-unit>
        <trans-unit id="3bb987ea3c954538087573e2f402d9fdf305369d" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6a939ea1df7c37cb72e17d44d1754a7325b1cce" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is negative infinity.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ba927f3f79a46354d9209dcd811d86b8a661221b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is -1.0.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 -1.0입니다.</target>
        </trans-unit>
        <trans-unit id="20f8e0486c54aeb853e7804b4611ce1c56a73d1b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is &lt;code&gt;-1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 &lt;code&gt;-1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9e3b1cc495f1cc8092755d393fd54a8be9e0bff" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is positive zero.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="d08b29e2ea8c8a74d04b752def011f9cda30c497" translate="yes" xml:space="preserve">
          <source>If the argument is negative one, then the result is negative infinity.</source>
          <target state="translated">인수가 음수 인 경우 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ad3d4a3e9566e2c0df155d95c37161c79599330f" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이거나 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 값보다 크거나 같은 값 이면 결과는 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eff50c12018038db62b68855eb707df57d7cd5ae" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이거나 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값보다 크거나 같은 값 이면 결과는 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a13758d0f976c89623e38e841da2cbc62912670" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7f800000&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;0x7f800000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c05eefbf6b8959edbbea1c8b9a02322d8935ca7" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf429a21c2dc34b66e4269078332483b3641ead6" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="31b9de6b24ff8d5ffbebf56f3f1cecc792456081" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is &lt;code&gt;+1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;+1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f87ee2c0e3d173098373d3990b3903acb3bfadf9" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="96dab47247ae7e1056e56799ef0665e4ab651c26" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative infinity, then the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이거나 음의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="78148cd34a5b7680af0ed6412b4903e44701b46c" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Double.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양수 또는 음수 0이면 결과는 &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c4032eb755d363cebfbea8af5b3c0b4a94596cf" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Float.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양수 또는 음수 0이면 결과는 &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f15f3f96dc5106b38775f4ba76d739b00aa110dd" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, the result is positive zero.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="0553928b250b89074ae0163da0309f356dd0aea5" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is negative infinity.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="f8ad8830694a6f7c940aad7bd91216f8c775287b" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="11b6940276c4e767ac8a361ca5f19636e270c2d9" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt;&lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">인수가 0이거나 비정규이면 결과는 &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt; &lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="3905704a484368c3992190c17ec803f5c9734872" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt;&lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">인수가 0이거나 비정규이면 결과는 &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt; &lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="65b605eea787dfcd26a427a347ea4ad7abd516d5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="82de080d3a1d56fdbaf695d271e223d79695fa9d" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="368d7952fccceed4084cffb62407a857e1140ff5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="e43dae92e6e1f445b98367ed57735c6219a0d0f9" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="5db3ba052bf056b3adf9c2be7e6188d33a4e952e" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8d665f9570f8b5f180ad4bdb572f1e1aab98bad" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is a zero with the same sign as the argument.</source>
          <target state="translated">인수가 0이면 결과는 인수와 같은 부호를 갖는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d1f82cc652138d856ee89a85be827d630ca9f31c" translate="yes" xml:space="preserve">
          <source>If the argument value is already equal to a mathematical integer, then the result is the same as the argument.</source>
          <target state="translated">인수 값이 이미 수학 정수와 같으면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="38b3adaab247759b54b2aa2e88f5b5ce2609340f" translate="yes" xml:space="preserve">
          <source>If the argument value is less than zero but greater than -1.0, then the result is negative zero.</source>
          <target state="translated">인수 값이 0보다 작지만 -1.0보다 큰 경우 결과는 음의 0입니다.</target>
        </trans-unit>
        <trans-unit id="acfd94f24240c24943c8ec432b5700b6212aa09a" translate="yes" xml:space="preserve">
          <source>If the argument,</source>
          <target state="translated">인수가</target>
        </trans-unit>
        <trans-unit id="d16beeb819e4ac6862b921fde8350a257a9f5ad7" translate="yes" xml:space="preserve">
          <source>If the arguments are inconsistent then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. The necessary consistent argument conditions are:</source>
          <target state="translated">인수가 일치하지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. 필요한 일관된 인수 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c14cc5c25518873c4d133fdea60caf8bcd4ae3d" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that reference equal &lt;code&gt;DataFlavor&lt;/code&gt;s, this method will establish new mappings for the first of those elements and ignore the rest of them.</source>
          <target state="translated">배열에 동일한 것을 참조하는 여러 요소가 포함 된 경우 &lt;code&gt;DataFlavor&lt;/code&gt; 경우이 메서드는 해당 요소 중 첫 번째 요소에 대해 새 매핑을 설정하고 나머지 요소는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="cfbcde248a8dade1dd31dd66e1705de02944b301" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that reference equal &lt;code&gt;String&lt;/code&gt; natives, this method will establish new mappings for the first of those elements and ignore the rest of them.</source>
          <target state="translated">배열에 동일한 것을 참조하는 여러 요소가 포함 된 경우 &lt;code&gt;String&lt;/code&gt; 네이티브 경우이 메서드는 해당 요소 중 첫 번째 요소에 대해 새 매핑을 설정하고 나머지 요소는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="9501d16613e807e8eab597eb061cf001422db435" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 요소 유형이 원래 대상의 해당 인수 유형과 다른 경우 원래 대상은 다음을 호출하는 것처럼 배열 요소를 직접 가져 오도록 조정됩니다. &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 을 오도록 조정&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7b613ad1d7b1ad953ca4724e10cf0c2ca14a21e9" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 요소 유형이 원래 대상의 해당 인수 유형과 다른 경우, 원래 대상은 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 호출로 배열 요소를 직접 가져 오도록 조정 됩니다.</target>
        </trans-unit>
        <trans-unit id="50771cd3c005f627dc72ab8c8e5ba994b9a7354f" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 유형이 원래 대상의 최종 인수 유형과 다른 경우 원래 대상은 다음을 호출하는 것처럼 배열 유형을 직접 가져 오도록 조정됩니다. &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 을&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8c623454e44ca641a6c552859181a701097e3dda" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 유형이 원래 대상의 최종 인수 유형과 다른 경우 원래 대상은 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 을&lt;/a&gt; 호출하는 것처럼 배열 유형을 직접 가져 오도록 조정 됩니다.</target>
        </trans-unit>
        <trans-unit id="4602014772a49fdb1a8fa2feb07dd113fad7727a" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../../java.base/java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">이 클래스를로드하려고하면 &lt;a href=&quot;../../../../java.base/java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; 을&lt;/a&gt;하면 목록의 다음 요소에서 핸들러 검색이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="4389eb5f009bdfaeb30b67c701fdcfe35730fb30" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">이 클래스를로드하려고하면 &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; &lt;/a&gt; 이 생성 되면 핸들러 검색은 목록의 다음 요소로 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="27bcadd9ba9512f4ef4c571a9d187c3039f12ed0" translate="yes" xml:space="preserve">
          <source>If the attribute is not set, or is null, then any class is deemed acceptable.</source>
          <target state="translated">속성이 설정되지 않았거나 null이면 모든 클래스가 허용되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="21f75ebcde7181c9e3879b54dc6999c343b75757" translate="yes" xml:space="preserve">
          <source>If the attribute name has a namespace prefix in the document, the application must include the prefix here.</source>
          <target state="translated">속성 이름에 문서에 네임 스페이스 접두사가있는 경우 애플리케이션은 여기에 접두사를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="318b1b00162c20584c04e29ce092027abd6ca2c6" translate="yes" xml:space="preserve">
          <source>If the attribute name has a namespace prefix, the prefix will still be attached.</source>
          <target state="translated">속성 이름에 네임 스페이스 접두사가 있으면 접두사가 계속 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="43f1e5d2810e31afb29d4cbb5b203ff69de05156" translate="yes" xml:space="preserve">
          <source>If the attribute value is a list of tokens (IDREFS, ENTITIES, or NMTOKENS), the tokens will be concatenated into a single string separated by whitespace.</source>
          <target state="translated">속성 값이 토큰 목록 (IDREFS, ENTITIES 또는 NMTOKENS) 인 경우 토큰은 공백으로 구분 된 단일 문자열로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="604294b7c0dd6e4d28df89e25837ca4a62600385" translate="yes" xml:space="preserve">
          <source>If the attribute value is a list of tokens (IDREFS, ENTITIES, or NMTOKENS), the tokens will be concatenated into a single string with each token separated by a single space.</source>
          <target state="translated">속성 값이 토큰 목록 (IDREFS, ENTITIES 또는 NMTOKENS) 인 경우 토큰은 단일 공백으로 구분 된 각 토큰이있는 단일 문자열로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="62a3db83b82f314fea33a46956ad055372005abd" translate="yes" xml:space="preserve">
          <source>If the attribute was not explicitly given a value in the instance document but has a default value provided by the schema associated with the document, an attribute node will be created with &lt;code&gt;specified&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;. Removing attribute nodes for which a default value is defined in the schema generates a new attribute node with the default value and &lt;code&gt;specified&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;. If validation occurred while invoking &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;, attribute nodes with &lt;code&gt;specified&lt;/code&gt; equals to &lt;code&gt;false&lt;/code&gt; are recomputed according to the default attribute values provided by the schema. If no default value is associate with this attribute in the schema, the attribute node is discarded.</source>
          <target state="translated">속성에 인스턴스 문서의 값이 명시 적으로 제공되지 않았지만 문서와 연관된 스키마에서 제공하는 기본값이있는 경우 속성 노드는 &lt;code&gt;specified&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; 로 설정되어 생성됩니다 . 디폴트 값이 스키마에 정의되어있는 속성 노드를 제거하면 기본 값을 가진 새로운 속성 노드 생성 &lt;code&gt;specified&lt;/code&gt; 로 설정 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 를 호출하는 동안 유효성 검사가 발생 하면 스키마에서 제공하는 기본 속성 값에 따라의 속성 노드 가 다시 계산됩니다. 스키마에서이 속성과 연결된 기본값이 없으면 속성 노드가 삭제됩니다. &lt;code&gt;specified&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b24e421bf1afcae52b5b217643f689a5e02c7896" translate="yes" xml:space="preserve">
          <source>If the attributes did not match, we would get the results shown in &lt;u&gt;Figure 12&lt;/u&gt;.</source>
          <target state="translated">속성이 일치하지 않으면 &lt;u&gt;그림 12&lt;/u&gt; 와 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de2839318027a87b01d1160931d4ec1a7e54992" translate="yes" xml:space="preserve">
          <source>If the authority component is present in the spec then the spec is treated as absolute and the spec authority and path will replace the context authority and path. If the authority component is absent in the spec then the authority of the new URL will be inherited from the context.</source>
          <target state="translated">권한 구성 요소가 스펙에 존재하면 스펙이 절대 값으로 처리되고 스펙 권한 및 경로가 컨텍스트 권한 및 경로를 대체합니다. 권한 구성 요소가 스펙에 없으면 새 URL의 권한이 컨텍스트에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="a027f872693de9d0e476629ed221d81049ef3c8e" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;#await()&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">차단 조치가 실행될 때 일시 중단되는 당사자에 의존하지 않는 경우, 당사자의 모든 스레드가 해당 조치가 해제 될 때 해당 조치를 실행할 수 있습니다. 이를 용이하게하기 위해 &lt;a href=&quot;#await()&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt; 의 각 호출은 장벽에서 해당 스레드의 도착 인덱스를 리턴합니다. 그런 다음 차단 작업을 실행할 스레드를 선택할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf5687cbde3be28238012b6e16935454ba496a38" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;cyclicbarrier#await--&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">장벽 조치가 실행될 때 일시 중단 된 당사자에 의존하지 않으면 당사자의 스레드 중 하나가 해제 될 때 해당 조치를 실행할 수 있습니다. 이것을 용이하게하기 위해, &lt;a href=&quot;cyclicbarrier#await--&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt; 의 각 호출은 장벽에서 해당 스레드의 도달 색인을 리턴합니다. 그런 다음 차단 작업을 실행할 스레드를 선택할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="1553601469def15f7ee0f8465070fbc819973117" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;#reset()&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;#isBroken()&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">스레드가 대기하는 동안 장벽이 &lt;a href=&quot;#reset()&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 되거나 &lt;code&gt;await&lt;/code&gt; 가 호출 될 때 장벽 &lt;a href=&quot;#isBroken()&quot;&gt;이 깨지면&lt;/a&gt; , 스레드가 대기하는 동안 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dac9df73081697b7b7531c1d6a0b9c3e69c870d7" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">스레드가 대기 중일 때 장벽이 &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 이거나 &lt;code&gt;await&lt;/code&gt; 가 호출 될 때 장벽 &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;이 끊어 지거나&lt;/a&gt; 스레드가 대기 중일 때 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="575a83a87991707c167ff499c572b2c82c888c2d" translate="yes" xml:space="preserve">
          <source>If the bean also implemented the zero argument get listener method:</source>
          <target state="translated">Bean이 0 인수를 구현 한 경우 리스너 메소드를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="2c223aaa7bd3533fb82949d6d90648ac9350bba7" translate="yes" xml:space="preserve">
          <source>If the bean is a subtype of java.applet.Applet, then it is given some special initialization. First, it is supplied with a default AppletStub and AppletContext. Second, if it was instantiated from a classname the applet's &quot;init&quot; method is called. (If the bean was deserialized this step is skipped.)</source>
          <target state="translated">Bean이 java.applet.Applet의 하위 유형 인 경우 특수 초기화가 제공됩니다. 먼저, 기본 AppletStub 및 AppletContext가 제공됩니다. 둘째, 클래스 이름에서 인스턴스화 된 경우 애플릿의 &quot;init&quot;메소드가 호출됩니다. Bean이 직렬화 해제 된 경우이 단계는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="80874718dd7a5a6c0f974bdb517de9b9cdeaa788" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;visibility&lt;/i&gt;&lt;/a&gt; of those side-effects to other threads, nor are there any guarantees that different operations on the &quot;same&quot; element within the same stream pipeline are executed in the same thread. Further, the ordering of those effects may be surprising. Even when a pipeline is constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream source (for example, &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; must produce &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt;), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</source>
          <target state="translated">동작 매개 변수에 부작용이있는 경우 (특별히 언급되지 않는 한) 다른 스레드에 대한 부작용 의 &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;가시성&lt;/i&gt;&lt;/a&gt; 에 대한 보장이 없으며 동일한 스트림 파이프 라인 내의 &quot;동일한&quot;요소에 대한 다른 조작이 보장되지 않습니다. 같은 스레드에서 실행됩니다. 또한 이러한 효과의 순서는 놀랍습니다. 파이프 라인이 스트림 소스의 발생 순서와 일치 하는 &lt;em&gt;결과&lt;/em&gt; 를 생성하도록 제한되는 경우에도 (예 : &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; 는 &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt; 생성해야합니다 .)의 경우 매퍼 함수가 개별 요소에 적용되는 순서 또는 특정 요소에 대해 동작 매개 변수가 실행되는 스레드에 대해서는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3cae85a2bc3049c2747d3d97aa3594bc11da611" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to:</source>
          <target state="translated">행동 매개 변수에 부작용이있는 경우, 명시 적으로 언급하지 않는 한 다음과 같은 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ccf27e1407104ddd4079359fbf08f2ee48d40b5e" translate="yes" xml:space="preserve">
          <source>If the best MIME type in the array does not support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.</source>
          <target state="translated">배열에서 최상의 MIME 유형이 charset 매개 변수를 지원하지 않는 경우 해당 MIME 유형을 공유하는 플레이버는 다음 순서로 표현 클래스별로 정렬됩니다. &lt;code&gt;java.io.InputStream&lt;/code&gt; , &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt; , &lt;code&gt;[B&lt;/code&gt; , &amp;lt;기타 모든&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ca5ea6c87eee103edbf011257ea8f6318b689500" translate="yes" xml:space="preserve">
          <source>If the best MIME type in the array does support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;, &amp;lt;all others&amp;gt;.</source>
          <target state="translated">배열에서 가장 좋은 MIME 유형이 charset 매개 변수를 지원하는 경우 해당 MIME 유형을 공유하는 플레이버는 다음 순서로 표현 클래스별로 정렬됩니다. &lt;code&gt;java.io.Reader&lt;/code&gt; , &lt;code&gt;java.lang.String&lt;/code&gt; , &lt;code&gt;java.nio.CharBuffer&lt;/code&gt; , &lt;code&gt;[C&lt;/code&gt; , &amp;lt;기타 모든 것&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="e64f9482d0004a103071d818b6eabe3a9e8fa8ce" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one.</source>
          <target state="translated">비트 오프셋이 0이 아니면 현재 바이트의 나머지 비트를 0으로 강제 설정하고 스트림 위치를 1 씩 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="f00562687194200d7d3d4e8dbcd71f247eefddae" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one. This method should be called by subclasses at the beginning of the &lt;code&gt;write(int)&lt;/code&gt; and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods.</source>
          <target state="translated">비트 오프셋이 0이 아닌 경우 현재 바이트의 나머지 비트를 0으로 강제하고 스트림 위치를 1 씩 증가시킵니다. 이 메소드는 &lt;code&gt;write(int)&lt;/code&gt; 및 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 메소드 시작시 서브 클래스에 의해 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="92b946e43c30c152e86047538b9789992732b7fc" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아닌 경우, 현재 바이트의 나머지는 0으로 채워지고 먼저 쓰여집니다. 쓰기 후 비트 오프셋은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="618cf6b5a31a53e5fb031a41327ab959ec20a724" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits()&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아니면 현재 바이트의 나머지 부분이 0으로 채워지고 먼저 기록됩니다. 비트 오프셋은 쓰기 후 0이됩니다. 구현 &lt;a href=&quot;imageoutputstreamimpl#flushBits()&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt; 의 flushBits 메서드를 사용하여 이를 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a17bf4b09c9d50c7630d0558298715e241010710" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아닌 경우, 현재 바이트의 나머지는 0으로 채워지고 먼저 쓰여집니다. 쓰기 후 비트 오프셋은 0이됩니다. 구현 &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt; 의 flushBits 메소드를 사용하여 이를 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5508ed99f9c67a4ebbd4b73e88b50a057b0cdcc0" translate="yes" xml:space="preserve">
          <source>If the boolean system property &lt;code&gt;&lt;span id=&quot;org.openjdk.java.util.stream.tripwire&quot;&gt;org.openjdk.java.util.stream.tripwire&lt;/span&gt;&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</source>
          <target state="translated">부울 시스템 속성 &lt;code&gt;&lt;span id=&quot;org.openjdk.java.util.stream.tripwire&quot;&gt;org.openjdk.java.util.stream.tripwire&lt;/span&gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 기본 하위 유형 전문화에서 작동 할 때 기본 값의 박싱이 발생하면 진단 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="7c99084a7828ec1a975c99c15549a5685147fb7b" translate="yes" xml:space="preserve">
          <source>If the boolean system property &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</source>
          <target state="translated">부울 시스템 특성 &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 기본 서브 타입 특수화에서 조작 할 때 기본 값의 복싱이 발생하면 진단 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="5a92adab1b458e89d84f2de880f27113ac825c1c" translate="yes" xml:space="preserve">
          <source>If the bootstrap class loader is represented as &lt;code&gt;null&lt;/code&gt; in the Java Virtual Machine (JVM), then &lt;code&gt;null&lt;/code&gt; is also the return value of this method.</source>
          <target state="translated">부트 스트랩 클래스 로더가 JVM (Java Virtual Machine)에서 &lt;code&gt;null&lt;/code&gt; 표시되는 경우 &lt;code&gt;null&lt;/code&gt; 은이 메소드의 리턴 값이기도합니다.</target>
        </trans-unit>
        <trans-unit id="1b7842845f7cac936a098919d982da718dd2d664" translate="yes" xml:space="preserve">
          <source>If the border, font, or color property values are not specified in the constructor or by invoking the appropriate set methods, the property values will be defined by the current look and feel, using the following property names in the Defaults Table:</source>
          <target state="translated">테두리, 글꼴 또는 색상 속성 값이 생성자에 지정되지 않았거나 적절한 set 메서드를 호출하여 속성 값이 기본값 테이블에서 다음 속성 이름을 사용하여 현재 모양과 느낌으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="99c31ef671411db209dfcab81af4e78e3e5b165e" translate="yes" xml:space="preserve">
          <source>If the boundary-points of a Range do not meet specific requirements.</source>
          <target state="translated">범위의 경계 지점이 특정 요구 사항을 충족하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="87e5deffba95ab1ac7918aac0643a0fb2206533c" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange(java.util.Date)&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType()&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">달력 유형 인 경우 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#setGregorianChange(java.util.Date)&quot;&gt;그레고리 변경 일&lt;/a&gt; 의 &lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 를가&lt;/a&gt; 로 설정되어 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 로 &lt;em&gt;예 기적&lt;/em&gt; 그레고리 안 달력. 주 정의 매개 변수도 &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;ISO 8601 표준과 호환되도록&lt;/a&gt; 설정됩니다 . &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 로 생성 된 &lt;code&gt;GregorianCalendar&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#getCalendarType()&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="486a42feea23b408f730eefa4db49a5a9bbd4a21" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">달력 유형 인 경우 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;그레고리 변경 일&lt;/a&gt; 의 &lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 를가&lt;/a&gt; 로 설정되어 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 로 &lt;em&gt;예 기적&lt;/em&gt; 그레고리 안 달력. 주 정의 매개 변수도 &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;ISO 8601 표준과 호환되도록&lt;/a&gt; 설정되어 있습니다 . &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 로 작성된 &lt;code&gt;GregorianCalendar&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="533aa6e407d4df4fa84a0752b83c5cc2a43222eb" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;#type()&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 사이트의 기호 유형 설명 &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 메서드 핸들의 &lt;a href=&quot;#type()&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 과 정확히 일치하면 invokeExact 에서처럼 호출이 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa913ecbed54558eb291f0922076e469c78e1e5a" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;methodhandle#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 사이트의 기호 유형 설명 &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 메소드 핸들의 &lt;a href=&quot;methodhandle#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 과 정확히 일치 하면 호출은 invokeExact에 의한 것처럼 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="598d1ca28e965a4e453fe096de8cef9a2d34ea67" translate="yes" xml:space="preserve">
          <source>If the call to sendResponseHeaders() specified a fixed response body length, then the exact number of bytes specified in that call must be written to this stream. If too many bytes are written, then write() will throw an IOException. If too few bytes are written then the stream close() will throw an IOException. In both cases, the exchange is aborted and the underlying TCP connection closed.</source>
          <target state="translated">sendResponseHeaders () 호출이 고정 응답 본문 길이를 지정한 경우 해당 호출에 지정된 정확한 바이트 수를이 스트림에 기록해야합니다. 너무 많은 바이트가 기록되면 write ()는 IOException을 발생시킵니다. 너무 적은 바이트가 기록되면 스트림 close ()에서 IOException이 발생합니다. 두 경우 모두 교환이 중단되고 기본 TCP 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="8da6d1bbefc65f4e59f9e3250b8dcf1e6a450b67" translate="yes" xml:space="preserve">
          <source>If the call was executed on Windows, with SOURCE_PATH set to &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt;, a valid result would be a file object representing the file &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 SOURCE_PATH가 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt; 설정된 상태에서 호출이 실행 된 경우 유효한 결과는 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt; 파일을 나타내는 파일 객체입니다 . src \ share \ classes \ com \ sun \ tools \ javac \ resources \ compiler.properties &quot; .</target>
        </trans-unit>
        <trans-unit id="82c1f7dd616c9fa0f0453a51b6c0d76cd6731897" translate="yes" xml:space="preserve">
          <source>If the caller instantiates the context using the default &lt;code&gt;GSSManager&lt;/code&gt; instance, then the Kerberos v5 GSS-API mechanism is guaranteed to be available for context establishment. This mechanism is identified by the Oid &quot;1.2.840.113554.1.2.2&quot; and is defined in RFC 1964.</source>
          <target state="translated">호출자가 기본 &lt;code&gt;GSSManager&lt;/code&gt; 인스턴스를 사용하여 컨텍스트를 인스턴스화하면 Kerberos v5 GSS-API 메커니즘을 컨텍스트 설정에 사용할 수 있습니다. 이 메커니즘은 Oid &quot;1.2.840.113554.1.2.2&quot;로 식별되며 RFC 1964에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff260529ceaf173f6b333228a7d30097feb002e" translate="yes" xml:space="preserve">
          <source>If the caller module &lt;code&gt;M1&lt;/code&gt; differs from the target module &lt;code&gt;M2&lt;/code&gt; then both of the following must be true:</source>
          <target state="translated">호출자 모듈 &lt;code&gt;M1&lt;/code&gt; 이 대상 모듈 &lt;code&gt;M2&lt;/code&gt; 와 다른 경우 다음 두 가지가 모두 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="76dba0e51a985d3607bdbbe713e1aa4f8e5d2e2f" translate="yes" xml:space="preserve">
          <source>If the caller module is a &lt;a href=&quot;spi/resourcebundleprovider#obtain-resource-bundle&quot;&gt; resource bundle provider&lt;/a&gt;, it does not fall back to the class loader search.</source>
          <target state="translated">호출자 모듈이 &lt;a href=&quot;spi/resourcebundleprovider#obtain-resource-bundle&quot;&gt;리소스 번들 공급자&lt;/a&gt; 인 경우 클래스 로더 검색으로 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="127ed743b798d2c554cd5dbd0da31702ddd38bcb" translate="yes" xml:space="preserve">
          <source>If the caller module is a named module and the given &lt;code&gt;loader&lt;/code&gt; is the caller module's class loader, this method is equivalent to &lt;code&gt;getBundle(baseName, locale)&lt;/code&gt;; otherwise, it may not find resource bundles from named modules. Use &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.Module)&quot;&gt;&lt;code&gt;getBundle(String, Locale, Module)&lt;/code&gt;&lt;/a&gt; to load resource bundles on behalf on a specific module instead.</source>
          <target state="translated">호출자 모듈이 명명 된 모듈이고 지정된 &lt;code&gt;loader&lt;/code&gt; 가 호출자 모듈의 클래스 로더 인 경우이 메소드는 &lt;code&gt;getBundle(baseName, locale)&lt;/code&gt; 과 동일합니다 . 그렇지 않으면 명명 된 모듈에서 리소스 번들을 찾지 못할 수 있습니다. 대신 특정 모듈을 대신하여 자원 번들을로드 하려면 &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.Module)&quot;&gt; &lt;code&gt;getBundle(String, Locale, Module)&lt;/code&gt; &lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9bab532ba6bbba009ffbae752606d6da2e48286a" translate="yes" xml:space="preserve">
          <source>If the caller specifies a &lt;code&gt;null&lt;/code&gt; Subject and a &lt;code&gt;null&lt;/code&gt; value is permitted, the LoginContext instantiates a new Subject.</source>
          <target state="translated">호출자가 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 제목과 &lt;code&gt;null&lt;/code&gt; 값을 허용, LoginContext에 새로운 주제를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="cddd5c45ec5323f48597c6883597894f02cc5d57" translate="yes" xml:space="preserve">
          <source>If the caller supplies values that are inconsistent or out of bounds, the method enforces these constraints silently, and without failure. Specifically, if the start position or end position is greater than the length of the text, it is reset to equal the text length. If the start position is less than zero, it is reset to zero, and if the end position is less than the start position, it is reset to the start position.</source>
          <target state="translated">호출자가 일관성이 없거나 범위를 벗어난 값을 제공하는 경우 메서드는 이러한 제약 조건을 오류없이 자동으로 적용합니다. 특히 시작 위치 또는 끝 위치가 텍스트 길이보다 크면 텍스트 길이와 동일하게 재설정됩니다. 시작 위치가 0보다 작 으면 0으로 재설정되고 끝 위치가 시작 위치보다 작 으면 시작 위치로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d99d89b43899a3641eb5674cead1a33a1d5f371" translate="yes" xml:space="preserve">
          <source>If the caller's class loader defines a &lt;code&gt;Package&lt;/code&gt; of the given name, the &lt;code&gt;Package&lt;/code&gt; is returned. Otherwise, the ancestors of the caller's class loader are searched recursively (parent by parent) for a &lt;code&gt;Package&lt;/code&gt; of the given name.</source>
          <target state="translated">호출자의 클래스 로더 가 지정된 이름 의 &lt;code&gt;Package&lt;/code&gt; 를 정의 하면 &lt;code&gt;Package&lt;/code&gt; 가 반환됩니다. 그렇지 않으면, 호출자의 클래스 로더의 조상은 주어진 이름 의 &lt;code&gt;Package&lt;/code&gt; 에 대해 재귀 적으로 (상위 별 상위) 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="326d2f1653f789cda443686d18377e6514d2a778" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to add a service dependence on the given service type.</source>
          <target state="translated">호출자의 모듈이이 모듈이면이 모듈을 업데이트하여 주어진 서비스 유형에 대한 서비스 종속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0de0313a99182f5f835a0cf120f13fa81db11645" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to add a service dependence on the given service type. This method is intended for use by frameworks that invoke &lt;a href=&quot;../util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; on behalf of other modules or where the framework is passed a reference to the service type by other code. This method is a no-op when invoked on an unnamed module or an automatic module.</source>
          <target state="translated">호출자의 모듈이이 모듈이면이 모듈을 업데이트하여 주어진 서비스 유형에 대한 서비스 종속성을 추가합니다. 이 메소드는 다른 모듈을 대신하여 &lt;a href=&quot;../util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 를 호출하는 프레임 워크에서 사용 하거나 프레임 워크가 다른 코드에 의해 서비스 유형에 대한 참조를 전달하는 경우에 사용됩니다. 이 메서드는 이름이 지정되지 않은 모듈 또는 자동 모듈에서 호출 될 때 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2df2be70297edd88e8c12a7c5f300e9bb81d2b5b" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to export the given package to the given module.</source>
          <target state="translated">호출자의 모듈이이 모듈이면이 모듈을 업데이트하여 주어진 패키지를 주어진 모듈로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6758eb950c4ad23ad7160ebf4f955a5a3f8c692e" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to read the given module.</source>
          <target state="translated">호출자의 모듈이이 모듈이면 주어진 모듈을 읽도록이 모듈을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="360e9083fc3848da89a866e2997b26119a42eb1d" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to read the given module. This method is a no-op if &lt;code&gt;other&lt;/code&gt; is this module (all modules read themselves), this module is an unnamed module (as unnamed modules read all modules), or this module already reads &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">호출자의 모듈이이 모듈이면 주어진 모듈을 읽도록이 모듈을 업데이트합니다. &lt;code&gt;other&lt;/code&gt; 모듈이이 모듈 (모든 모듈이 자신을 읽음)이거나이 모듈이 이름이없는 모듈 (이름이없는 모듈이 모든 모듈을 읽음)이거나이 모듈이 이미 &lt;code&gt;other&lt;/code&gt; 모듈을 읽는 경우이 메서드는 작동하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="269b3f0fe8fb44df4ce0a6fe047dfebd11282f41" translate="yes" xml:space="preserve">
          <source>If the calling method is interested in retrieving the named property then it would have to test the element to see if it is a proxy class.</source>
          <target state="translated">호출 메소드가 이름 지정된 특성을 검색하는 데 관심이있는 경우 요소를 테스트하여 프록시 클래스인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9253130a27a78e3a08350cf89cd42b9d30c402d8" translate="yes" xml:space="preserve">
          <source>If the certificate is of type X.509 and has a</source>
          <target state="translated">인증서가 X.509 유형이고 인증서가</target>
        </trans-unit>
        <trans-unit id="aaacbc8edbe2f8c424f5386b7ac1e0da44e25e33" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;#implCloseChannel()&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">채널이 이미 닫힌 경우이 메서드는 즉시 반환됩니다. 그렇지 않으면 채널을 닫힌 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;#implCloseChannel()&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b697d0518cb0986befd095c4c07f371b7bc19eb6" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">채널이 이미 닫혀 있으면이 메소드는 즉시 리턴합니다. 그렇지 않으면 채널을 닫은 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d252f820f6c574294d1558501615ce3622e72864" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop()&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid()&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 멀티 캐스트 그룹의 구성원이면 구성원 자격이 &lt;a href=&quot;membershipkey#drop()&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt; 됩니다. 반환시 &lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;membershipkey#isValid()&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="258471a2858a2bd50b28d36eb9c0232d73db11d8" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop--&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid--&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 멀티 캐스트 그룹의 구성원 인 경우 멤버 자격이 &lt;a href=&quot;membershipkey#drop--&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt; 됩니다. 돌아 오면 &lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;membershipkey#isValid--&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6196d1052cc76b7a767033a57f3c2ef48c6f463" translate="yes" xml:space="preserve">
          <source>If the channel is connected to a remote peer that is bound to multiple addresses then it is these addresses that the channel's socket is connected.</source>
          <target state="translated">채널이 여러 주소에 바인드 된 원격 피어에 연결되어있는 경우 채널의 소켓이 연결된 주소는이 주소입니다.</target>
        </trans-unit>
        <trans-unit id="fca12487d5034313786755dfdbb1487ee9174606" translate="yes" xml:space="preserve">
          <source>If the channel's key is not already in the selected-key set then it is added to that set and its ready-operation set is modified to identify exactly those operations for which the channel is now reported to be ready. Any readiness information previously recorded in the ready set is discarded.</source>
          <target state="translated">채널 키가 아직 선택된 키 세트에없는 경우 해당 키가 해당 세트에 추가되고 채널이 준비된 것으로보고 된 작업을 정확하게 식별하도록 준비된 작업 세트가 수정됩니다. 준비 세트에 이전에 기록 된 준비 정보는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a74fcb99fe153ea5c299a617e13d7e98b79feb03" translate="yes" xml:space="preserve">
          <source>If the character &lt;code&gt;oldChar&lt;/code&gt; does not occur in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, then a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence identical to the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, except that every occurrence of &lt;code&gt;oldChar&lt;/code&gt; is replaced by an occurrence of &lt;code&gt;newChar&lt;/code&gt;.</source>
          <target state="translated">문자 경우 &lt;code&gt;oldChar&lt;/code&gt; 는 문자 순서가 발생하지 않습니다이로 표현 &lt;code&gt;String&lt;/code&gt; 객체,이에 대한 참조 &lt;code&gt;String&lt;/code&gt; 객체가 돌려 주어집니다. 그렇지 않으면, &lt;code&gt;String&lt;/code&gt; 목적이 나타내는 문자 시퀀스와 동일한 문자 시퀀스 나타내 리턴 &lt;code&gt;String&lt;/code&gt; 마다 발생하는 것을 제외 객체 &lt;code&gt;oldChar&lt;/code&gt; 이 의 발생으로 대체 &lt;code&gt;newChar&lt;/code&gt; 에이 .</target>
        </trans-unit>
        <trans-unit id="2356291f03c93e71b96f7a671fd497dc56ec73d3" translate="yes" xml:space="preserve">
          <source>If the character defined by the mnemonic is found within the button's label string, the first occurrence of it will be underlined to indicate the mnemonic to the user.</source>
          <target state="translated">니모닉에 의해 정의 된 문자가 버튼의 레이블 문자열 내에서 발견되면 그 첫 번째 항목에 밑줄이 표시되어 사용자에게 니모닉을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e2733b75e92ebe16a2ce70438529de312b56641" translate="yes" xml:space="preserve">
          <source>If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned.</source>
          <target state="translated">문자에 숫자 값이 없으면 -1이 반환됩니다. 문자에 음이 아닌 정수 (예 : 분수 값)로 표현할 수없는 숫자 값이 있으면 -2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a94e7ca6896af3627bbb39f5e579611a67b2ce91" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_FINISH&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">특성 &lt;code&gt;IDENTITY_FINISH&lt;/code&gt; 가 설정된 경우이 함수는 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 캐스트가 확인되지 않은 ID 변환으로 간주 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ef817a66adab96584398608e88fbe1d608af344" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; 특성 이 설정된 경우이 함수는 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 캐스트가 검사되지 않은 ID 변환 인 것으로 추정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a0ae11bb0853d1ee68bf0914e7935640792833e" translate="yes" xml:space="preserve">
          <source>If the check box argument is &lt;code&gt;null&lt;/code&gt;, all check boxes in this check box group are deselected. If the check box argument belongs to a different check box group, this method does nothing.</source>
          <target state="translated">선택란 인수가 &lt;code&gt;null&lt;/code&gt; 이면 이 선택란 그룹의 모든 선택란이 선택 취소됩니다. 확인란 인수가 다른 확인란 그룹에 속하면이 메서드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="497068c1a55f2d965c9c1d485ba0e4ac4c0bfb03" translate="yes" xml:space="preserve">
          <source>If the check fails we throw a SecurityException, otherwise we return normally.</source>
          <target state="translated">검사에 실패하면 SecurityException이 발생하고 그렇지 않으면 정상적으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f200f54b8913d720a0fc8f80cb58e7fb832b09" translate="yes" xml:space="preserve">
          <source>If the chronology makes active use of eras, such as &lt;code&gt;JapaneseChronology&lt;/code&gt; then the year-of-era will be validated against the era. For other chronologies, validation is optional.</source>
          <target state="translated">연대기가 &lt;code&gt;JapaneseChronology&lt;/code&gt; 와 같은 시대를 적극적으로 사용하는 경우 시대 를 기준으로 시대가 검증됩니다. 다른 연대기의 경우 유효성 검사는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="907a36ef0b6c060f7a9d6a76251b166f6ce74a74" translate="yes" xml:space="preserve">
          <source>If the class can successfully be loaded, an attempt will be made to create an instance of it by calling &lt;code&gt;Class.newInstance&lt;/code&gt;. An attempt will be made to narrow the instance to type &lt;code&gt;java.awt.Component&lt;/code&gt; to display the object.</source>
          <target state="translated">클래스가 성공적으로로드 될 수있는 경우 &lt;code&gt;Class.newInstance&lt;/code&gt; 를 호출하여 해당 인스턴스를 만들려고 시도 합니다 . 객체를 표시 하기 위해 인스턴스를 &lt;code&gt;java.awt.Component&lt;/code&gt; 유형으로 좁히려 고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="993043b6674c4a35b36d9c742df1bbfe992c7c06" translate="yes" xml:space="preserve">
          <source>If the class has several constructors, &lt;a href=&quot;../standardoperation#NEW&quot;&gt;&lt;code&gt;StandardOperation.NEW&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;StaticClass&lt;/code&gt; will try to select the most specific applicable constructor. You might want to expose a mechanism in your language for selecting a constructor with an explicit signature through &lt;a href=&quot;beanslinker#getConstructorMethod(java.lang.Class,java.lang.String)&quot;&gt;&lt;code&gt;BeansLinker.getConstructorMethod(Class, String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클래스에 여러 생성자가있는 경우 &lt;code&gt;StaticClass&lt;/code&gt; 의&lt;a href=&quot;../standardoperation#NEW&quot;&gt; &lt;code&gt;StandardOperation.NEW&lt;/code&gt; &lt;/a&gt; 는 적용 가능한 가장 구체적인 생성자를 선택하려고합니다. &lt;a href=&quot;beanslinker#getConstructorMethod(java.lang.Class,java.lang.String)&quot;&gt; &lt;code&gt;BeansLinker.getConstructorMethod(Class, String)&lt;/code&gt; &lt;/a&gt; 통해 명시 적 서명이있는 생성자를 선택하기 위해 언어로 메커니즘을 노출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c7a6047da53758486c24b6ceb6b4575875d974a" translate="yes" xml:space="preserve">
          <source>If the class implements the interface &lt;a href=&quot;dynamicmbean&quot;&gt;&lt;code&gt;DynamicMBean&lt;/code&gt;&lt;/a&gt; then the MBean is a Dynamic MBean. Note that the class &lt;code&gt;StandardMBean&lt;/code&gt; implements this interface, so this case applies to a Standard MBean or MXBean created using the class &lt;code&gt;StandardMBean&lt;/code&gt;.</source>
          <target state="translated">클래스가 &lt;a href=&quot;dynamicmbean&quot;&gt; &lt;code&gt;DynamicMBean&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 MBean은 Dynamic MBean입니다. 클래스주의 &lt;code&gt;StandardMBean&lt;/code&gt; 이 인터페이스는,이 경우는 표준의 MBean 또는 MXBean의 적용 구현 클래스 사용하여 만든 &lt;code&gt;StandardMBean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9ebf03c3837794b9118548515dce9c5eeac747f" translate="yes" xml:space="preserve">
          <source>If the class is &lt;code&gt;VarHandle&lt;/code&gt; and the name string corresponds to the name of a signature-polymorphic access mode method, the resulting method handle is equivalent to one produced by &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt; with the access mode corresponding to the name string and with the same &lt;code&gt;type&lt;/code&gt; arguments.</source>
          <target state="translated">클래스가 &lt;code&gt;VarHandle&lt;/code&gt; 이고 이름 문자열이 서명 다형성 액세스 모드 메서드의 이름에 해당하는 경우 결과 메서드 핸들은 &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt; 이름 문자열에 해당하는 액세스 모드와 동일한 &lt;code&gt;type&lt;/code&gt; 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3b8178b28745cbf9a8c356b7ccd5c7490b446121" translate="yes" xml:space="preserve">
          <source>If the class is successfully loaded from the &lt;code&gt;defaultLoader&lt;/code&gt;, that class is returned. If an exception other than &lt;code&gt;ClassNotFoundException&lt;/code&gt; is thrown, that exception is thrown to the caller.</source>
          <target state="translated">클래스가 &lt;code&gt;defaultLoader&lt;/code&gt; 에서 성공적으로로드 되면 해당 클래스가 반환됩니다. &lt;code&gt;ClassNotFoundException&lt;/code&gt; 이외의 예외 가 throw되면 해당 예외가 호출자에게 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="7d4839c4011be06ed972a50b4707c4c87c520b22" translate="yes" xml:space="preserve">
          <source>If the class loader is a &lt;a href=&quot;classloader#builtinLoaders&quot;&gt; built-in class loader&lt;/a&gt; or is not named then the first element and its following &lt;code&gt;&quot;/&quot;&lt;/code&gt; are omitted as shown in &quot;&lt;code&gt;acme@2.1/org.acme.Lib.test(Lib.java:80)&lt;/code&gt;&quot;. If the first element is omitted and the module is an unnamed module, the second element and its following &lt;code&gt;&quot;/&quot;&lt;/code&gt; are also omitted as shown in &quot;&lt;code&gt;MyClass.mash(MyClass.java:9)&lt;/code&gt;&quot;.</source>
          <target state="translated">클래스 로더가 &lt;a href=&quot;classloader#builtinLoaders&quot;&gt;내장 클래스 로더&lt;/a&gt; 이거나 이름이 지정되지 않은 경우 &quot; &lt;code&gt;acme@2.1/org.acme.Lib.test(Lib.java:80)&lt;/code&gt; &quot;에 표시된 것처럼 첫 번째 요소와 그 다음 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 가 생략됩니다. . 첫 번째 요소가 생략되고 모듈이 이름이 지정되지 않은 모듈 인 경우 &quot; &lt;code&gt;MyClass.mash(MyClass.java:9)&lt;/code&gt; 와 같이 두 번째 요소와 그 다음 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 도 생략됩니다. &quot; .</target>
        </trans-unit>
        <trans-unit id="4a4555f48b556983b593c81b2e7a7b846ff92e83" translate="yes" xml:space="preserve">
          <source>If the class loader is the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by &lt;code&gt;null&lt;/code&gt;), then the value of the &lt;code&gt;&lt;span id=&quot;java.rmi.server.codebase&quot;&gt;java.rmi.server.codebase&lt;/span&gt;&lt;/code&gt; property (or possibly an earlier cached value) is returned, or &lt;code&gt;null&lt;/code&gt; is returned if that property is not set.</source>
          <target state="translated">클래스 로더가 시스템 클래스 로더 ( &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt; 참조 ), 설치된 확장에 사용되는 로더와 같은 시스템 클래스 로더의 상위 또는 부트 스트랩 클래스 로더 ( &lt;code&gt;null&lt;/code&gt; 로 표시 될 수 있음 ) 인 경우 &lt;code&gt;&lt;span id=&quot;java.rmi.server.codebase&quot;&gt;java.rmi.server.codebase&lt;/span&gt;&lt;/code&gt; 속성 값 (또는 이전 캐시 된 값)이 반환되거나 해당 속성이 설정되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="572e2e8607da1aaa832eee294d600cd0b74c2f51" translate="yes" xml:space="preserve">
          <source>If the class loader is the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by &lt;code&gt;null&lt;/code&gt;), then the value of the &lt;code&gt;java.rmi.server.codebase&lt;/code&gt; property (or possibly an earlier cached value) is returned, or &lt;code&gt;null&lt;/code&gt; is returned if that property is not set.</source>
          <target state="translated">클래스 로더가 시스템 클래스 로더 ( &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt; 참조 ), 설치된 확장에 사용되는 로더와 같은 시스템 클래스 로더의 상위 또는 부트 스트랩 클래스 로더 ( &lt;code&gt;null&lt;/code&gt; 로 표시 될 수 있음 ) 인 경우 &lt;code&gt;java.rmi.server.codebase&lt;/code&gt; 특성 값 (또는 이전 캐시 된 값)이 리턴되거나 &lt;code&gt;null&lt;/code&gt; 해당 속성이 설정되지 않은 경우 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18dfc6c9d8012fcb4afd5d4cd53b47b6e173ddd4" translate="yes" xml:space="preserve">
          <source>If the class loader of the given module defines other modules and the given name is a class defined in a different module, this method returns &lt;code&gt;null&lt;/code&gt; after the class is loaded.</source>
          <target state="translated">지정된 모듈의 클래스 로더가 다른 모듈을 정의하고 지정된 이름이 다른 모듈에 정의 된 클래스 인 경우이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다. 클래스가로드 된 후 을 .</target>
        </trans-unit>
        <trans-unit id="e1700f5a5e32f3348ed050e68e0d59e005f7128b" translate="yes" xml:space="preserve">
          <source>If the class or interface is &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt;, then the result is a string of the form:</source>
          <target state="translated">클래스 또는 인터페이스가 &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt; 이면 결과는 다음 형식의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7320eb1655071247a7cb27de5cad18feb2e575d5" translate="yes" xml:space="preserve">
          <source>If the class or interface is hidden, then the result is a string of the form: &lt;code&gt;N + '/' + &amp;lt;suffix&amp;gt;&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the &lt;a href=&quot;classloader#binary-name&quot;&gt;binary name&lt;/a&gt; indicated by the &lt;code&gt;class&lt;/code&gt; file passed to &lt;a href=&quot;invoke/methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt;&lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;&amp;lt;suffix&amp;gt;&lt;/code&gt; is an unqualified name.</source>
          <target state="translated">클래스 또는 인터페이스가 숨겨진 경우 결과는 다음 형식의 문자열입니다. &lt;code&gt;N + '/' + &amp;lt;suffix&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;N&lt;/code&gt; 은 &lt;a href=&quot;invoke/methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt; &lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt; &lt;/a&gt; 전달 된 &lt;code&gt;class&lt;/code&gt; 파일에 의해 표시되는 &lt;a href=&quot;classloader#binary-name&quot;&gt;이진 이름&lt;/a&gt; 이고 &lt;code&gt;&amp;lt;suffix&amp;gt;&lt;/code&gt; 는 다음과 같습니다. 규정되지 않은 이름.</target>
        </trans-unit>
        <trans-unit id="647c68d85ca3579e0c43d0d82206a9ec49464973" translate="yes" xml:space="preserve">
          <source>If the class or interface is not &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt;, then the &lt;a href=&quot;classloader#binary-name&quot;&gt;binary name&lt;/a&gt; of the class or interface is returned.</source>
          <target state="translated">클래스 또는 인터페이스가 &lt;a href=&quot;#isHidden()&quot;&gt;숨겨져&lt;/a&gt; 있지 않으면 클래스 또는 인터페이스 의 &lt;a href=&quot;classloader#binary-name&quot;&gt;이진 이름&lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8ad83fe743eecc6f15470c8181d8587012fcdace" translate="yes" xml:space="preserve">
          <source>If the class or interface is not &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt;, then the result is a field descriptor (JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt;) for the class or interface. Calling &lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt;&lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt;&lt;/a&gt; with the result descriptor string produces a &lt;a href=&quot;constant/classdesc&quot;&gt;&lt;code&gt;ClassDesc&lt;/code&gt;&lt;/a&gt; describing this class or interface.</source>
          <target state="translated">클래스 또는 인터페이스가 &lt;a href=&quot;#isHidden()&quot;&gt;숨겨&lt;/a&gt; 지지 않은 경우 결과는 클래스 또는 인터페이스에 대한 필드 설명자 (JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt; )입니다. 결과 설명자 문자열로 &lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt; &lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt; &lt;/a&gt; 를 호출 하면이 클래스 또는 인터페이스를 설명 하는 &lt;a href=&quot;constant/classdesc&quot;&gt; &lt;code&gt;ClassDesc&lt;/code&gt; 가&lt;/a&gt; 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6cbdce4f03e8864e2078a8ebda20df5d53693b1" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 클래스 또는 인터페이스 가 다른 클래스의 구성원이면 &lt;code&gt;Class&lt;/code&gt; 를 반환합니다. 경우 선언 된 클래스를 나타내는 객체를 .</target>
        </trans-unit>
        <trans-unit id="952c977645377144d1e9387499dba9c6a0e6f790" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared. This method returns null if this class or interface is not a member of any other class. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, a primitive type, or void,then this method returns null.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 클래스 또는 인터페이스 가 다른 클래스의 멤버 인 경우 선언 된 클래스를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체를 반환합니다 . 이 클래스 또는 인터페이스가 다른 클래스의 멤버가 아닌 경우이 메소드는 널을 리턴합니다. 이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스, 프리미티브 유형 또는 void를 나타내는 경우이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c4b1d6d0e3e6bf78e4579733a8155fce8794f591" translate="yes" xml:space="preserve">
          <source>If the class path of the class loader includes remote network URLs then those URLs may be dereferenced in the process of searching for provider-configuration files.</source>
          <target state="translated">클래스 로더의 클래스 경로에 원격 네트워크 URL이 포함 된 경우 해당 URL은 공급자 구성 파일을 검색하는 과정에서 역 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5149c7a2ea949082634b5eade9a189fb43ba3574" translate="yes" xml:space="preserve">
          <source>If the class pointed to by the property cannot be loaded, or does not correspond to a valid subclass of MBeanServerBuilder then an exception is propagated, and no MBeanServer can be created until the &lt;b&gt;javax.management.builder.initial&lt;/b&gt; system property is reset to valid value.</source>
          <target state="translated">등록 정보가 가리키는 클래스를로드 할 수 없거나 MBeanServerBuilder의 유효한 서브 클래스에 해당하지 않으면 예외가 전파되고 &lt;b&gt;javax.management.builder.initial&lt;/b&gt; 시스템 등록 정보가 유효한 값으로 재설정 될 때까지 MBeanServer를 작성할 수 없습니다 &lt;b&gt;.&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="255675b731bcc7202d59daefb4cbc3dbea4fde7b" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;#resolveClass(java.lang.Class)&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">위의 단계를 사용하여 클래스를 찾았고 &lt;code&gt;resolve&lt;/code&gt; 플래그가 true이면이 메서드는 결과 &lt;code&gt;Class&lt;/code&gt; 개체 에서 &lt;a href=&quot;#resolveClass(java.lang.Class)&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt; 메서드 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a48f463646ddc67b0927be2d8f5a0d7e6779ec57" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">위의 단계를 사용하여 클래스를 찾았고 &lt;code&gt;resolve&lt;/code&gt; 플래그가 true 인 경우이 메소드는 결과 &lt;code&gt;Class&lt;/code&gt; 오브젝트 에서 &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="003444596c67295858def4a629af62005e80f04a" translate="yes" xml:space="preserve">
          <source>If the client does not specify a &lt;code&gt;JobPriority&lt;/code&gt; attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">클라이언트가 인쇄 작업에 대한 &lt;code&gt;JobPriority&lt;/code&gt; 속성을 지정하지 않고 프린터가 JobPriority 속성을 지원하는 경우 프린터는 구현 정의 기본 JobPriority 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cb1171375f133959d5fe66bf3b2a054030b8896" translate="yes" xml:space="preserve">
          <source>If the client does not specify a JobPriority attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">클라이언트가 인쇄 작업에 JobPriority 속성을 지정하지 않고 프린터가 JobPriority 속성을 지원하는 경우 프린터는 구현 정의 기본 JobPriority 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d048044cc6cddb0cf0dbc1da3f8b399bcca1c52" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default &lt;code&gt;JobHoldUntil&lt;/code&gt; value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">클라이언트가 인쇄 요청에이 속성을 제공하지 않고 프린터가이 속성을 지원하는 경우 프린터는 (구현에 따라) 기본 &lt;code&gt;JobHoldUntil&lt;/code&gt; 을 사용해야합니다. 작업 제출시 값을 사용해야합니다 (작업 처리에 필요한 경우 사용되는 대부분의 작업 템플릿 속성과는 달리) 시각).</target>
        </trans-unit>
        <trans-unit id="8819695d5b9293144506d78213d046dbf29c7943" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default JobHoldUntil value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">클라이언트가 인쇄 요청에이 속성을 제공하지 않고 프린터가이 속성을 지원하는 경우, 프린터는 작업 제출시 필요한 (구현 종속) 기본 JobHoldUntil 값을 사용해야합니다 (작업 처리에 필요한 경우 사용되는 대부분의 작업 템플리트 속성과는 달리) 시각).</target>
        </trans-unit>
        <trans-unit id="b95b0051a1d9e6aeda4cecd24f2f226586dceb7a" translate="yes" xml:space="preserve">
          <source>If the column class as returned by &lt;code&gt;getColumnClass&lt;/code&gt; is &lt;code&gt;String&lt;/code&gt;, use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getColumnClass&lt;/code&gt; 에서 반환 된 열 클래스 가 &lt;code&gt;String&lt;/code&gt; 이면 &lt;code&gt;Collator.getInstance()&lt;/code&gt; 반환 된 &lt;code&gt;Comparator&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1d2bea1ba481bf3017c0de86b5926674c8b57a55" translate="yes" xml:space="preserve">
          <source>If the column class implements &lt;code&gt;Comparable&lt;/code&gt;, use a &lt;code&gt;Comparator&lt;/code&gt; that invokes the &lt;code&gt;compareTo&lt;/code&gt; method.</source>
          <target state="translated">열 클래스가 &lt;code&gt;Comparable&lt;/code&gt; 을 구현 하는 경우 &lt;code&gt;compareTo&lt;/code&gt; 메서드 를 호출 하는 &lt;code&gt;Comparator&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="425608db615fcee29a758153b3f2f63df2fa7cde" translate="yes" xml:space="preserve">
          <source>If the column index is valid but the row index is less than zero the method returns a rectangle with the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values set appropriately and the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; values both set to zero. In general, when either the row or column indices indicate a cell outside the appropriate range, the method returns a rectangle depicting the closest edge of the closest cell that is within the table's range. When both row and column indices are out of range the returned rectangle covers the closest point of the closest cell.</source>
          <target state="translated">열 인덱스가 유효하지만 행 인덱스가 0보다 작은 경우 메서드는 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 값이 적절하게 설정되고 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; 설정된 사각형을 반환합니다. 값이 모두 0으로 설정된 합니다. 일반적으로 행 또는 열 인덱스가 적절한 범위 밖에있는 셀을 나타내는 경우 메서드는 테이블 범위 내에있는 가장 가까운 셀의 가장 가까운 가장자리를 나타내는 사각형을 반환합니다. 행 및 열 인덱스가 모두 범위를 벗어나면 반환 된 사각형이 가장 가까운 셀의 가장 가까운 지점을 덮습니다.</target>
        </trans-unit>
        <trans-unit id="6f068094c0b9101658e1bd4638d11b46b0682d00" translate="yes" xml:space="preserve">
          <source>If the combiner has a void return, no result will be inserted, and the first &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">컴 바이 너에 void 리턴이 있으면 결과가 삽입되지 않으며 대상 의 첫 번째 &lt;code&gt;N&lt;/code&gt; 매개 변수 유형이 컴 바이 너의 매개 변수와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bd33812eb44d59d69e1fa86993dc6c1b417f658" translate="yes" xml:space="preserve">
          <source>If the combiner returns a value, the first parameter type of the target must be identical with the return type of the combiner, and the next &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">결합기가 값을 반환하면 대상의 첫 번째 매개 변수 유형이 결합기의 반환 유형과 동일해야하며 대상의 다음 &lt;code&gt;N&lt;/code&gt; 매개 변수 유형이 결합기의 매개 변수와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a835e3176ef9901dbf657a51a0dc111ab329f96" translate="yes" xml:space="preserve">
          <source>If the combo box is editable, then this value may not have been added to the combo box with &lt;code&gt;addItem&lt;/code&gt;, &lt;code&gt;insertItemAt&lt;/code&gt; or the data constructors.</source>
          <target state="translated">콤보 상자를 편집 할 수있는 경우이 값은 &lt;code&gt;addItem&lt;/code&gt; , &lt;code&gt;insertItemAt&lt;/code&gt; 또는 데이터 생성자 를 사용하여 콤보 상자에 추가되지 않았을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f746d1a0f0f5d1b71eddaef84d93690d98f495a0" translate="yes" xml:space="preserve">
          <source>If the comment is present (not null) it is written, otherwise an an empty comment is written</source>
          <target state="translated">주석이 있으면 (null이 아님) 작성되고, 그렇지 않으면 빈 주석이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="700d0c6d66bdf7dd366a71fc298f1463af466dfa" translate="yes" xml:space="preserve">
          <source>If the comments argument is not null, then an ASCII &lt;code&gt;#&lt;/code&gt; character, the comments string, and a line separator are first written to the output stream. Thus, the &lt;code&gt;comments&lt;/code&gt; can serve as an identifying comment. Any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed in comments is replaced by a line separator generated by the &lt;code&gt;Writer&lt;/code&gt; and if the next character in comments is not character &lt;code&gt;#&lt;/code&gt; or character &lt;code&gt;!&lt;/code&gt; then an ASCII &lt;code&gt;#&lt;/code&gt; is written out after that line separator.</source>
          <target state="translated">comments 인수가 널이 아닌 경우 ASCII &lt;code&gt;#&lt;/code&gt; 문자, 주석 문자열 및 행 구분 기호가 먼저 출력 스트림에 기록됩니다. 따라서, &lt;code&gt;comments&lt;/code&gt; 식별 주석으로서 기능 할 수있다. 줄 바꿈 ( '\ n'), 캐리지 리턴 ( '\ r') 또는 주석에서 줄 바꿈 바로 다음에 오는 캐리지 리턴은 &lt;code&gt;Writer&lt;/code&gt; 가 생성 한 줄 구분자로 대체되며 다음 문자 인 경우 코멘트에서 문자 &lt;code&gt;#&lt;/code&gt; 또는 문자 가 아닙니다 &lt;code&gt;!&lt;/code&gt; 그런 다음 줄 구분 기호 뒤에 ASCII &lt;code&gt;#&lt;/code&gt; 이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d734df054f4a2c1ef528f0ad746950c442305d2a" translate="yes" xml:space="preserve">
          <source>If the component doesn't have composed text, the offset should be ignored, and the location returned should reflect the beginning (in line direction) of the highlight in the last line containing selected text. For example, for horizontal left-to-right text (such as English), the location to the left of the left-most character on the last line containing selected text is returned. For vertical top-to-bottom text, with lines proceeding from right to left, the location to the top of the left-most line containing selected text is returned.</source>
          <target state="translated">구성 요소에 구성된 텍스트가없는 경우 오프셋을 무시해야하며 반환 된 위치는 선택한 텍스트가 포함 된 마지막 줄의 강조 표시 시작 (줄 방향)을 반영해야합니다. 예를 들어, 수평 왼쪽에서 오른쪽 텍스트 (예 : 영어)의 경우 선택한 텍스트를 포함하는 마지막 줄에서 가장 왼쪽 문자의 왼쪽 위치가 반환됩니다. 행이 오른쪽에서 왼쪽으로 진행되는 수직 위에서 아래로 텍스트의 경우 선택한 텍스트를 포함하는 가장 왼쪽 행의 맨 위 위치가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52458478773761d2bba8b8c640a23a52fc2877dc" translate="yes" xml:space="preserve">
          <source>If the component has composed text (because the most recent InputMethodEvent sent to it contained composed text), then the offset is relative to the composed text - offset 0 indicates the first character in the composed text. The location returned should be for this character.</source>
          <target state="translated">구성 요소에 작성된 텍스트가있는 경우 (가장 최근에 보낸 InputMethodEvent에 작성된 텍스트가 포함되어 있기 때문에) 오프셋은 작성된 텍스트를 기준으로합니다. 오프셋 0은 작성된 텍스트의 첫 번째 문자를 나타냅니다. 반환 된 위치는이 캐릭터에 대한 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa083a799f0c4b27fbcd704b725195417a71c40c" translate="yes" xml:space="preserve">
          <source>If the component is &lt;code&gt;null&lt;/code&gt;, or the &lt;code&gt;
 GraphicsConfiguration&lt;/code&gt; associated with this component is &lt;code&gt;null&lt;/code&gt;, the window is placed in the center of the screen. The center point can be obtained with the &lt;a href=&quot;graphicsenvironment#getCenterPoint()&quot;&gt;&lt;code&gt;GraphicsEnvironment.getCenterPoint&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">성분이면 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt; GraphicsConfiguration&lt;/code&gt; 를 이 컴포넌트와 관련이 &lt;code&gt;null&lt;/code&gt; 창을 화면의 중심에 배치된다. 중심점은 &lt;a href=&quot;graphicsenvironment#getCenterPoint()&quot;&gt; &lt;code&gt;GraphicsEnvironment.getCenterPoint&lt;/code&gt; &lt;/a&gt; 메소드 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dd6f4c457146450ded7e20b80ac380bbab18e53" translate="yes" xml:space="preserve">
          <source>If the component is a child of some other container, it is removed from that container before being added to this container. The important difference between this method and &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; is that this method doesn't call &lt;code&gt;removeNotify&lt;/code&gt; on the component while removing it from its previous container unless necessary and when allowed by the underlying native windowing system. This way, if the component has the keyboard focus, it maintains the focus when moved to the new position.</source>
          <target state="translated">구성 요소가 다른 컨테이너의 자식 인 경우이 컨테이너에 추가되기 전에 해당 컨테이너에서 제거됩니다. 이 메소드와 &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; 의 중요한 차이점은이 메소드 는 필요하지 않고 기본 윈도우 시스템에서 허용하는 경우 이전 컨테이너에서 제거하는 동안 컴포넌트에서 &lt;code&gt;removeNotify&lt;/code&gt; 를 호출하지 않는다는 것입니다. 이렇게하면 구성 요소에 키보드 포커스가있는 경우 새 위치로 이동할 때 포커스가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9f28aca33e4b7d20b3d3eab00c327afedf0feed4" translate="yes" xml:space="preserve">
          <source>If the component is marked as opaque, the background is painted in the current background color of the component.</source>
          <target state="translated">구성 요소가 불투명으로 표시된 경우 배경은 구성 요소의 현재 배경색으로 칠해집니다.</target>
        </trans-unit>
        <trans-unit id="49528cc920475018bcff626e6ad10c005e36e46d" translate="yes" xml:space="preserve">
          <source>If the component is not &lt;code&gt;null&lt;/code&gt; and is shown on the screen, then the window is located in such a way that the center of the window coincides with the center of the component.</source>
          <target state="translated">구성 요소가 &lt;code&gt;null&lt;/code&gt; 이 아니고 화면에 표시되면 창의 중심이 구성 요소의 중심과 일치하는 방식으로 창이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="5eda8ad7764dbe33c30b572a11e1b1539c4e718f" translate="yes" xml:space="preserve">
          <source>If the component is not &lt;code&gt;null&lt;/code&gt;, but it is not currently showing, the window is placed in the center of the target screen defined by the &lt;code&gt;
 GraphicsConfiguration&lt;/code&gt; associated with this component.</source>
          <target state="translated">구성 요소가 &lt;code&gt;null&lt;/code&gt; 이 아니지만 현재 표시되지 않는 경우 창은 이 구성 요소와 연결된 &lt;code&gt; GraphicsConfiguration&lt;/code&gt; 에 의해 정의 된 대상 화면의 중앙에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9fde55638308a4ea2d10d2c4b49e0eee2a91067" translate="yes" xml:space="preserve">
          <source>If the component is not an ancestor of this container and has a non-null parent, it is removed from its current parent before it is added to this container.</source>
          <target state="translated">구성 요소가이 컨테이너의 조상이 아니고 null이 아닌 부모가있는 경우이 컨테이너에 추가되기 전에 현재 부모에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a58ff69484b85d5dedc93ea849fe6dfb636f6bc6" translate="yes" xml:space="preserve">
          <source>If the component is of a primitive type, using the corresponding primitive wrapper class &lt;code&gt;PW&lt;/code&gt; (the corresponding wrapper class for &lt;code&gt;int&lt;/code&gt; is &lt;code&gt;
 java.lang.Integer&lt;/code&gt;, and so on), the component is considered equal if and only if &lt;code&gt;
 PW.valueOf(this.c()).equals(PW.valueOf(r.c()))&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">구성 요소가 해당 기본 래퍼 클래스 &lt;code&gt;PW&lt;/code&gt; 를 사용하는 기본 유형 인 경우 ( &lt;code&gt;int&lt;/code&gt; 에 대한 해당 래퍼 클래스 는 &lt;code&gt; java.lang.Integer&lt;/code&gt; 등) &lt;code&gt; PW.valueOf(this.c()).equals(PW.valueOf(r.c()))&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="767273f6356c7f1819c424c6f45b8a2226912dcd" translate="yes" xml:space="preserve">
          <source>If the component is of a reference type, the component is considered equal if and only if &lt;a href=&quot;../util/objects#equals(java.lang.Object,java.lang.Object)&quot;&gt;&lt;code&gt;Objects.equals(this.c(), r.c()&lt;/code&gt;&lt;/a&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">구성 요소가 참조 유형이면 &lt;a href=&quot;../util/objects#equals(java.lang.Object,java.lang.Object)&quot;&gt; &lt;code&gt;Objects.equals(this.c(), r.c()&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우에만 구성 요소가 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8a4141d2aef13471dd4a0e737c385e9dc0e5ad9" translate="yes" xml:space="preserve">
          <source>If the component type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then numeric and atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">구성 요소 유형이 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 이면 숫자 및 원자 업데이트 액세스 모드는 비트 표현을 사용하여 값을 비교합니다 &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt; 각각 &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt; 및 Double.doubleToRawLongBits (double) 참조 ).</target>
        </trans-unit>
        <trans-unit id="2c31ff2ad53aa80158077167d3c0952e042633e3" translate="yes" xml:space="preserve">
          <source>If the compression level is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old level (and may be flushed); the new level will take effect only after that invocation.</source>
          <target state="translated">압축 수준이 변경되면 다음에 &lt;code&gt;deflate&lt;/code&gt; 를 호출 하면 이전 수준으로 사용 가능한 입력이 압축되고 플러시 될 수 있습니다. 새 레벨은 해당 호출 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="392c53482c9474c39ea6e8d51c4ff85e2db64e08" translate="yes" xml:space="preserve">
          <source>If the compression strategy is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old strategy (and may be flushed); the new strategy will take effect only after that invocation.</source>
          <target state="translated">압축 전략이 변경되면 다음에 &lt;code&gt;deflate&lt;/code&gt; 를 호출 하면 이전 전략으로 사용 가능한 입력이 압축됩니다 (플러시 될 수 있음). 새로운 전략은 해당 호출 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e9497f125d07fc51b01287bbc25b0587bcf8337" translate="yes" xml:space="preserve">
          <source>If the configuration entry for &lt;code&gt;KerberosLoginModule&lt;/code&gt; has the option &lt;code&gt;storeKey&lt;/code&gt; set to true, then &lt;code&gt;KerberosKey&lt;/code&gt; or &lt;code&gt;KeyTab&lt;/code&gt; will also be added to the subject's private credentials. &lt;code&gt;KerberosKey&lt;/code&gt;, the principal's key(s) will be derived from user's password, and &lt;code&gt;KeyTab&lt;/code&gt; is the keytab used when &lt;code&gt;useKeyTab&lt;/code&gt; is set to true. The &lt;code&gt;KeyTab&lt;/code&gt; object is restricted to be used by the specified principal unless the principal value is &quot;*&quot;.</source>
          <target state="translated">&lt;code&gt;KerberosLoginModule&lt;/code&gt; 의 구성 항목에 &lt;code&gt;storeKey&lt;/code&gt; 옵션 이 true로 설정된 경우 &lt;code&gt;KerberosKey&lt;/code&gt; 또는 &lt;code&gt;KeyTab&lt;/code&gt; 도 주체의 개인 자격 증명에 추가됩니다. &lt;code&gt;KerberosKey&lt;/code&gt; , 보안 주체의 키는 사용자의 암호에서 파생되며 &lt;code&gt;KeyTab&lt;/code&gt; 은 &lt;code&gt;useKeyTab&lt;/code&gt; 이 true로 설정 될 때 사용되는 키탭 입니다. &lt;code&gt;KeyTab&lt;/code&gt; 주치가 아닌 객체가 &quot;*&quot;특정 주체에 의해 사용되도록 제한된다.</target>
        </trans-unit>
        <trans-unit id="83fc6066134ba11a7853023c02cbbfe0403e55b4" translate="yes" xml:space="preserve">
          <source>If the connection is already closed then invoking this method has no effect. After a connection is closed, any further attempt calls to &lt;a href=&quot;#readPacket()&quot;&gt;&lt;code&gt;readPacket&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#writePacket(byte%5B%5D)&quot;&gt;&lt;code&gt;writePacket&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;closedconnectionexception&quot;&gt;&lt;code&gt;ClosedConnectionException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결이 이미 닫힌 경우이 메서드를 호출해도 효과가 없습니다. 연결이 종료 된 후에 더 시도 통화 &lt;a href=&quot;#readPacket()&quot;&gt; &lt;code&gt;readPacket&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#writePacket(byte%5B%5D)&quot;&gt; &lt;code&gt;writePacket&lt;/code&gt; 는&lt;/a&gt; 던져 것 &lt;a href=&quot;closedconnectionexception&quot;&gt; &lt;code&gt;ClosedConnectionException&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1941e8a43fce582de3711ef131570c2be6988f0c" translate="yes" xml:space="preserve">
          <source>If the connection is not established within the specified duration then building of the &lt;code&gt;WebSocket&lt;/code&gt; will fail with &lt;a href=&quot;httptimeoutexception&quot;&gt;&lt;code&gt;HttpTimeoutException&lt;/code&gt;&lt;/a&gt;. If this method is not invoked then the infinite timeout is assumed.</source>
          <target state="translated">연결이 지정된 기간 내에 설정되지 않으면 &lt;a href=&quot;httptimeoutexception&quot;&gt; &lt;code&gt;HttpTimeoutException&lt;/code&gt; &lt;/a&gt; 과 함께 &lt;code&gt;WebSocket&lt;/code&gt; 빌드 가 실패 합니다. 이 메소드가 호출되지 않으면 무한 제한 시간이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc304512711f4e405bbe651d78fc410942cc454e" translate="yes" xml:space="preserve">
          <source>If the connection pool manager supports &lt;code&gt;Statement&lt;/code&gt; pooling, for &lt;code&gt;PreparedStatements&lt;/code&gt;, which can be determined by invoking the method &lt;code&gt;DatabaseMetaData.supportsStatementPooling&lt;/code&gt;, the connection pool manager will register as a &lt;code&gt;StatementEventListener&lt;/code&gt; object with the new &lt;code&gt;PooledConnection&lt;/code&gt; object. When the &lt;code&gt;PreparedStatement&lt;/code&gt; is closed or there is an error, the connection pool manager (being a listener) gets a notification that includes a &lt;code&gt;StatementEvent&lt;/code&gt; object.</source>
          <target state="translated">연결 풀 관리자가 &lt;code&gt;DatabaseMetaData.supportsStatementPooling&lt;/code&gt; 메서드를 호출하여 확인할 수있는 &lt;code&gt;PreparedStatements&lt;/code&gt; 에 대해 &lt;code&gt;Statement&lt;/code&gt; 풀링을 지원 하는 경우 연결 풀 관리자는 새 &lt;code&gt;PooledConnection&lt;/code&gt; 개체 와 함께 &lt;code&gt;StatementEventListener&lt;/code&gt; 개체로 등록됩니다 . 때 &lt;code&gt;PreparedStatement&lt;/code&gt; 폐쇄되거나 오류가 연결 풀 매니저 (수신기 인)을 포함하는 통지를 취득 &lt;code&gt;StatementEvent&lt;/code&gt; 의 개체.</target>
        </trans-unit>
        <trans-unit id="c056d8bc44889ca1c50db14d914cd7e3d8e99f1b" translate="yes" xml:space="preserve">
          <source>If the connection pool manager wraps or provides a proxy to the logical handle returned from a call to &lt;code&gt;PoolConnection.getConnection&lt;/code&gt;, the pool manager must do one of the following when the connection pool manager closes or returns the &lt;code&gt;PooledConnection&lt;/code&gt; to the pool in response to the application calling &lt;code&gt;Connection.close&lt;/code&gt;:</source>
          <target state="translated">연결 풀 관리자가 &lt;code&gt;PoolConnection.getConnection&lt;/code&gt; 에 대한 호출에서 반환 된 논리적 핸들에 프록시를 래핑하거나 제공하는 경우 연결 풀 관리자가 응용 프로그램에 대한 응답으로 &lt;code&gt;PooledConnection&lt;/code&gt; 을 풀에 닫거나 반환 할 때 풀 관리자는 다음 중 하나를 수행해야합니다. &lt;code&gt;Connection.close&lt;/code&gt; 호출 :</target>
        </trans-unit>
        <trans-unit id="f881d8d4f5f09d46f8c2856b6d2d804f3ec96cc6" translate="yes" xml:space="preserve">
          <source>If the constructor completes normally, returns the newly created and initialized instance.</source>
          <target state="translated">생성자가 정상적으로 완료되면 새로 생성되고 초기화 된 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2aeb09eb6e0fcfe242a17792207492aa120605ac" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a CallbackHandler input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; CallbackHandler object (and a &lt;code&gt;null&lt;/code&gt; value is permitted), the LoginContext queries the &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; security property for the fully qualified class name of a default handler implementation. If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users. The caller thus assumes that the configured modules have alternative means for authenticating the user.</source>
          <target state="translated">생성자 않으면 &lt;b&gt;하지&lt;/b&gt; CallbackHandler를 입력 매개 변수를 가지고, 또는 발신자 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 의 CallbackHandler 객체 (그리고 &lt;code&gt;null&lt;/code&gt; 값이 허용된다), LoginContext에는 쿼리 &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; 의 기본 핸들러의 완전한 클래스 이름에 대한 보안 속성을 이행. 보안 특성이 설정되지 않은 경우 기본 모듈에는 사용자와 통신하는 데 사용할 CallbackHandler가 없습니다. 따라서 호출자는 구성된 모듈에 사용자를 인증하기위한 대체 수단이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="96edcc96b78112d3bb9f9d209b5477cb96759906" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Configuration input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; Configuration object, the constructor uses the following call to get the installed Configuration:</source>
          <target state="translated">생성자 않으면 &lt;b&gt;되지&lt;/b&gt; 구성 입력 매개 변수를 가지고, 또는 발신자가 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 구성 객체를 생성자는 설치된 구성 얻기 위해 다음 호출을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="56ea3a3517b6a27cca0834c9f4eb544d3dc38d39" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Subject input parameter, the LoginContext instantiates a new Subject.</source>
          <target state="translated">생성자 에 Subject 입력 매개 변수 가 &lt;b&gt;없는&lt;/b&gt; 경우 LoginContext는 새 Subject를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="51d999e9fc75b0313b56adf5745b9fffcd061b50" translate="yes" xml:space="preserve">
          <source>If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object.</source>
          <target state="translated">생성자가 CallbackHandler 입력 매개 변수를 갖는 경우 LoginContext는 호출자 지정 CallbackHandler 오브젝트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1e00d077c5cc21a366671e33a8a738802bc618a" translate="yes" xml:space="preserve">
          <source>If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration.</source>
          <target state="translated">생성자가 구성 입력 매개 변수를 가지고 있고 호출자가 널이 아닌 구성을 지정하면 LoginContext는 호출자 지정 구성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3de799a960e7be55aab3ca032d285e2179f3390f" translate="yes" xml:space="preserve">
          <source>If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object.</source>
          <target state="translated">생성자에 Subject 입력 매개 변수가있는 경우 LoginContext는 호출자 지정 Subject 오브젝트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3a99d0a19bc0f8c41b49ce35b93e620433ac8f02" translate="yes" xml:space="preserve">
          <source>If the constructor is declared to throw exceptions, the parameter list is followed by a space, followed by the word &quot;&lt;code&gt;throws&lt;/code&gt;&quot; followed by a comma-separated list of the thrown exception types.</source>
          <target state="translated">생성자가 예외를 throw하도록 선언 된 경우 매개 변수 목록 뒤에 공백이오고 &quot; &lt;code&gt;throws&lt;/code&gt; &quot; 라는 단어 가 뒤 따르고 쉼표로 구분 된 throw 된 예외 유형 목록이옵니다.</target>
        </trans-unit>
        <trans-unit id="8c9ed368492503e51fcc4ae43d3e8d4462771fd7" translate="yes" xml:space="preserve">
          <source>If the constructor's &lt;code&gt;accessible&lt;/code&gt; flag is not set, access checking is performed immediately on behalf of the lookup class.</source>
          <target state="translated">생성자의 &lt;code&gt;accessible&lt;/code&gt; 플래그가 설정되어 있지 않으면 조회 클래스 대신 즉시 액세스 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2473d04d22b81fa38fb3fac97ebfc248b300280e" translate="yes" xml:space="preserve">
          <source>If the constructor's declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see section 15.9.3 of</source>
          <target state="translated">생성자의 선언 클래스가 정적이 아닌 컨텍스트의 내부 클래스 인 경우 생성자의 첫 번째 인수는 둘러싸는 인스턴스 여야합니다. 섹션 15.9.3 참조</target>
        </trans-unit>
        <trans-unit id="f8c1d043cdccb51e8a4ceda740614fe5576a5363" translate="yes" xml:space="preserve">
          <source>If the container of an boundary-point of a Range is being set to either a node of an invalid type or a node with an ancestor of an invalid type.</source>
          <target state="translated">Range 경계 지점의 컨테이너가 잘못된 유형의 노드 또는 잘못된 유형의 조상이있는 노드로 설정되는 경우.</target>
        </trans-unit>
        <trans-unit id="eae554929c7a6131d929bc3da9b88deb58a80b03" translate="yes" xml:space="preserve">
          <source>If the container's &lt;code&gt;ComponentOrientation&lt;/code&gt; property is horizontal and left-to-right, the above example produces the output shown in Figure 1. If the container's &lt;code&gt;ComponentOrientation&lt;/code&gt; property is horizontal and right-to-left, the example produces the output shown in Figure 2.</source>
          <target state="translated">컨테이너의 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성이 수평이고 왼쪽에서 오른쪽이면 위의 예제는 그림 1과 같은 출력을 생성합니다. 컨테이너의 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성이 수평이고 오른쪽에서 왼쪽이면 예제는 그림 2와 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="12ab1266a164c0f6072aaf95e501de64c7ac066d" translate="yes" xml:space="preserve">
          <source>If the containing type is a parameterized type, the number of type arguments must equal the number of &lt;code&gt;typeElem&lt;/code&gt;'s formal type parameters. If it is not parameterized or if it is &lt;code&gt;null&lt;/code&gt;, this method is equivalent to &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt;.</source>
          <target state="translated">포함하는 유형이 매개 변수화 된 유형 인 경우 유형 인수의 수는 &lt;code&gt;typeElem&lt;/code&gt; 의 공식 유형 매개 변수 수와 같아야합니다 . 파라미터 화되어 있지 않은 경우, 또는 &lt;code&gt;null&lt;/code&gt; 의 경우 ,이 메소드는 &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt; 와 동등합니다 .</target>
        </trans-unit>
        <trans-unit id="eba2ca49b1b8640f5521ff4ce667486544415323" translate="yes" xml:space="preserve">
          <source>If the content-length response header has not already been set then this is set to the appropriate value depending on the response length parameter.</source>
          <target state="translated">컨텐츠 길이 응답 헤더가 아직 설정되지 않은 경우 응답 길이 매개 변수에 따라 적절한 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1b29895ec70403fd2e17d250a3c6d70239c8ec92" translate="yes" xml:space="preserve">
          <source>If the contents of the underlying document containing the &lt;code&gt;XMLSignature&lt;/code&gt; are subsequently modified, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;XMLSignature&lt;/code&gt; 를 포함하는 기본 문서의 내용 이 이후에 수정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54595108c68c9e1528174df34d61161ee7d1002c" translate="yes" xml:space="preserve">
          <source>If the context is available and there is a security manager installed, the caller may require permission to access it or a security exception may be thrown. In a Java environment, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">컨텍스트가 사용 가능하고 보안 관리자가 설치되어 있으면 호출자에게 액세스 권한이 필요하거나 보안 예외가 발생할 수 있습니다. Java 환경에서 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드는 &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7936f29deee3d60765c1418e1263abb6aa6cc3c" translate="yes" xml:space="preserve">
          <source>If the context node is a &lt;code&gt;Document&lt;/code&gt; node and the action is &lt;code&gt;ACTION_REPLACE_CHILDREN&lt;/code&gt;, then the document that is passed as the context node will be changed such that its &lt;code&gt;xmlEncoding&lt;/code&gt;, &lt;code&gt;documentURI&lt;/code&gt;, &lt;code&gt;xmlVersion&lt;/code&gt;, &lt;code&gt;inputEncoding&lt;/code&gt;, &lt;code&gt;xmlStandalone&lt;/code&gt;, and all other such attributes are set to what they would be set to if the input source was parsed using &lt;code&gt;LSParser.parse()&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 노드가 &lt;code&gt;Document&lt;/code&gt; 노드이고 조치가 &lt;code&gt;ACTION_REPLACE_CHILDREN&lt;/code&gt; 이면 컨텍스트 노드로 전달되는 문서가 변경되어 &lt;code&gt;xmlEncoding&lt;/code&gt; , &lt;code&gt;documentURI&lt;/code&gt; , &lt;code&gt;xmlVersion&lt;/code&gt; , &lt;code&gt;inputEncoding&lt;/code&gt; , &lt;code&gt;xmlStandalone&lt;/code&gt; 및 기타 모든 속성이 해당 속성으로 설정됩니다. 입력 소스가 &lt;code&gt;LSParser.parse()&lt;/code&gt; 사용하여 구문 분석 된 경우로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a360ee8a79bfd6943a67c78860b71ba39acaa75" translate="yes" xml:space="preserve">
          <source>If the conversion failed, value 0 will be used.</source>
          <target state="translated">변환에 실패하면 값 0이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e4edf267c4c18b01156d4fb736a0d9de264f347" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString(double)&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">변환이 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'A'&lt;/code&gt; 인 경우 정밀도는 기수 포인트 뒤의 16 진수 숫자입니다. 정밀도가 제공되지 않으면 &lt;a href=&quot;../lang/double#toHexString(double)&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt; 의해 반환 된 모든 숫자 가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="6d873373059873c2f9dda2243106e00e462486c8" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">변환이 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'A'&lt;/code&gt; 이면 정밀도는 기수 포인트 뒤의 16 진수 수입니다. 정밀도가 제공되지 않으면 &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 모든 숫자 가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="4920cb3a35e9ffdd181f2cc1c02598946a361975" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'g'&lt;/code&gt; or &lt;code&gt;'G'&lt;/code&gt;, then the precision is the total number of significant digits in the resulting magnitude after rounding. If the precision is not specified, then the default value is &lt;code&gt;6&lt;/code&gt;. If the precision is &lt;code&gt;0&lt;/code&gt;, then it is taken to be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">변환이 &lt;code&gt;'g'&lt;/code&gt; 또는 &lt;code&gt;'G'&lt;/code&gt; 이면 정밀도는 반올림 후 결과 크기에서 유효 자릿수의 총 수입니다. 정밀도가 지정되지 않은 경우 기본값은 &lt;code&gt;6&lt;/code&gt; 입니다. 정밀도가 &lt;code&gt;0&lt;/code&gt; 이면 &lt;code&gt;1&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="5b740696da8433363284a2a09b00def3e5dd32a1" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the base indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">변환이 &lt;code&gt;'o'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'X'&lt;/code&gt; 이고 &lt;code&gt;'#'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 플래그가 둘 다 제공된 경우 결과에 기본 표시기 ( 8 진 및 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 또는 &lt;code&gt;'0'&lt;/code&gt; 의 경우 '0') 또는 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; 16 진수의 경우 0X &quot; ), 폭 (너비를 기준으로 한) 0, 값.</target>
        </trans-unit>
        <trans-unit id="8d9565e696ad547e1a513117ec394adf4606346c" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the radix indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">변환이 경우 &lt;code&gt;'o'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , 또는 &lt;code&gt;'X'&lt;/code&gt; 와 모두 &lt;code&gt;'#'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 을 플래그 후 기수 (지시약 결과에는 주어진 &lt;code&gt;'0'&lt;/code&gt; 진수 및 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; 16 진수의 경우 0X &quot; ), 폭 (너비를 기준으로 한) 0, 값.</target>
        </trans-unit>
        <trans-unit id="f92ee64ab913667741eadac9533a1057cb848b90" translate="yes" xml:space="preserve">
          <source>If the count reaches zero then the method returns with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">카운트가 0에 도달하면 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf6135f725f6abcb2f61e9b10a4d1d32a5ee738" translate="yes" xml:space="preserve">
          <source>If the counter can wrap around its maximum value, the modulus needs to be specified. The modulus is the value at which the counter is reset to zero.</source>
          <target state="translated">카운터가 최대 값을 감쌀 수있는 경우 계수를 지정해야합니다. 계수는 카운터가 0으로 재설정되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="7b2012ddc4ebb24e7045b7a055ac3ae1d060dc81" translate="yes" xml:space="preserve">
          <source>If the counter difference mode is used, the value of the derived gauge is calculated as the difference between the observed counter values for two successive observations. If this difference is negative, the value of the derived gauge is incremented by the value of the modulus. The derived gauge value (V[t]) is calculated using the following method:</source>
          <target state="translated">카운터 차이 모드를 사용하는 경우 파생 게이지 값은 두 개의 연속 관측치에 대한 관측 된 카운터 값의 차이로 계산됩니다. 이 차이가 음수이면 파생 게이지 값이 모듈러스 값만큼 증가합니다. 파생 게이지 값 (V [t])은 다음 방법을 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5d33f0fe4d8b3f6830caa94328f7bd32d5be7376" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close()&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Receiver&lt;/code&gt; 생성 한 결과 기본 장치가 암시 적으로 열리면이 메서드에 의해 장치가 암시 적으로 닫힙니다. 이는 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에 해당됩니다. 이 경우 단말기 &lt;code&gt;Receiver&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close()&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Receiver&lt;/code&gt; 역시 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f1b34ff7dc9bdfbc17c9da13d95b1516d17ebbc" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Receiver&lt;/code&gt; 작성 하여 기본 디바이스를 내재적으로 열면 디바이스는이 메소드에 의해 내재적으로 닫힙니다. 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에도 마찬가지 입니다. 이 경우 단말기 &lt;code&gt;Receiver&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Receiver&lt;/code&gt; 역시 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1af258f9977741775b4573e8cb983831177f305" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close()&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Transmitter&lt;/code&gt; 의 생성으로 인해 기본 장치가 암시 적으로 열리면이 메서드에 의해 장치가 암시 적으로 닫힙니다. 이는 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에 해당됩니다. 이 경우 장치 &lt;code&gt;Transmitter&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close()&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Transmitter&lt;/code&gt; 도 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ae995006fbd46da8baab1bfa646c3f1a74c6123" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Transmitter&lt;/code&gt; 생성 하여 기본 장치를 암시 적으로 열면이 방법으로 장치가 암시 적으로 닫힙니다. 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에도 마찬가지 입니다. 이 경우 장치 &lt;code&gt;Transmitter&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Transmitter&lt;/code&gt; 도 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c179704df7cb8ed1b3ce0d3934ef2876dfdab64" translate="yes" xml:space="preserve">
          <source>If the current capacity of this vector is less than &lt;code&gt;minCapacity&lt;/code&gt;, then its capacity is increased by replacing its internal data array, kept in the field &lt;code&gt;elementData&lt;/code&gt;, with a larger one. The size of the new data array will be the old size plus &lt;code&gt;capacityIncrement&lt;/code&gt;, unless the value of &lt;code&gt;capacityIncrement&lt;/code&gt; is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than &lt;code&gt;minCapacity&lt;/code&gt;, then the new capacity will be &lt;code&gt;minCapacity&lt;/code&gt;.</source>
          <target state="translated">이 벡터의 전류 용량보다 작 으면 &lt;code&gt;minCapacity&lt;/code&gt; 가 다음, 그 용량은 필드에서 유지 내부 데이터 배열로 대체함으로써 증가 &lt;code&gt;elementData&lt;/code&gt; 큰 하나. &lt;code&gt;capacityIncrement&lt;/code&gt; 값이 0보다 작거나 같지 않은 한 새 데이터 배열의 크기는 이전 크기 에 &lt;code&gt;capacityIncrement&lt;/code&gt; 가됩니다.이 경우 새 용량은 이전 용량의 두 배가됩니다. 그러나이 새 크기가 여전히 &lt;code&gt;minCapacity&lt;/code&gt; 보다 작 으면 새 용량은 &lt;code&gt;minCapacity&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="15aa95f18520c9768c5e75e2d00df5cd87e5c814" translate="yes" xml:space="preserve">
          <source>If the current count equals zero then nothing happens.</source>
          <target state="translated">현재 카운트가 0이면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f94ee3549183c062116cda5b26a97df611673964" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</source>
          <target state="translated">현재 카운트가 0보다 크면 감소합니다. 새 개수가 0이면 모든 대기중인 스레드가 스레드 예약 목적으로 다시 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7db62e9957e4a583a5bb47860c808eb80b034b" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happen:</source>
          <target state="translated">현재 카운트가 0보다 큰 경우, 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ac4173a35be7aa72f90b5ce9f676b82ef7108f" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen:</source>
          <target state="translated">현재 카운트가 0보다 큰 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e615f8a82085afa953ed38e8e8581f0bc679866" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">현재 카운트가 0이면이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="bf13f63814d624078b38288a8fd1cdef5534f01f" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately.</source>
          <target state="translated">현재 카운트가 0이면이 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7fd54efda8852abf1726c4425c8e78d3b50cf5d3" translate="yes" xml:space="preserve">
          <source>If the current event is a START_ELEMENT or END_ELEMENT this method returns the URI of the prefix or the default namespace.</source>
          <target state="translated">현재 이벤트가 START_ELEMENT 또는 END_ELEMENT 인 경우이 메소드는 프리픽스 또는 기본 네임 스페이스의 URI를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2cd4616380038d25f830f6fb1b42637233fe3f86" translate="yes" xml:space="preserve">
          <source>If the current event is a START_ELEMENT or END_ELEMENT this method returns the URI of the prefix or the default namespace. Returns null if the event does not have a prefix.</source>
          <target state="translated">현재 이벤트가 START_ELEMENT 또는 END_ELEMENT 인 경우이 메소드는 프리픽스 또는 기본 네임 스페이스의 URI를 반환합니다. 이벤트에 접두사가 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5887879e6691c6cf6cd544bc0267797a7fb44c5c" translate="yes" xml:space="preserve">
          <source>If the current layout manager implements &lt;code&gt;LayoutManager2&lt;/code&gt;, then &lt;a href=&quot;../../java/awt/layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt;&lt;/a&gt; is invoked on it. If the current layout manager does not implement &lt;code&gt;LayoutManager2&lt;/code&gt;, and constraints is a &lt;code&gt;String&lt;/code&gt;, then &lt;a href=&quot;../../java/awt/layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt;&lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt;&lt;/a&gt; is invoked on it.</source>
          <target state="translated">현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현 하면 &lt;a href=&quot;../../java/awt/layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현하지 않고 제약 조건이 &lt;code&gt;String&lt;/code&gt; 이면 &lt;a href=&quot;../../java/awt/layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt; &lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3a447a386debb26576b066a1d7df35582ff0b666" translate="yes" xml:space="preserve">
          <source>If the current layout manager implements &lt;code&gt;LayoutManager2&lt;/code&gt;, then &lt;a href=&quot;layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt;&lt;/a&gt; is invoked on it. If the current layout manager does not implement &lt;code&gt;LayoutManager2&lt;/code&gt;, and constraints is a &lt;code&gt;String&lt;/code&gt;, then &lt;a href=&quot;layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt;&lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt;&lt;/a&gt; is invoked on it.</source>
          <target state="translated">현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현 하면 &lt;a href=&quot;layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 현재 레이아웃 관리자가 &lt;code&gt;LayoutManager2&lt;/code&gt; 를 구현하지 않고 제약 조건이 &lt;code&gt;String&lt;/code&gt; 이면 &lt;a href=&quot;layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt; &lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b49d04a03e7f62716b78c4449ecc798158a3b8" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">현재 메서드 핸들이 &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;변수 arity&lt;/a&gt; 가 아닌 경우 현재 메서드 핸들이 반환됩니다. 현재 메서드 핸들이 &lt;code&gt;asVarargsCollector&lt;/code&gt; 에 대한 유효한 입력이 될 수없는 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="a37f29b7a24ab724ec62dade14ae458a9a6defe6" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">현재 메소드 핸들이 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;가변 arity&lt;/a&gt; 가 아닌 경우 현재 메소드 핸들이 리턴됩니다. 현재 메소드 핸들이 &lt;code&gt;asVarargsCollector&lt;/code&gt; 에 유효한 입력이 아니더라도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="8cbc4f7fe8db524f0e4673c73c93f44a75301142" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the corresponding component types of the old and new method handle types.</source>
          <target state="translated">현재 메서드가 가변 arity 메서드 인 경우 인수 목록 변환은 &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;다른 곳&lt;/a&gt; 에서 설명한대로 여러 인수를 배열로 변환하고 수집하는 작업을 포함 할 수 있습니다 . 다른 모든 경우에는 모든 변환이 &lt;em&gt;쌍&lt;/em&gt; 으로 적용됩니다. 즉, 각 인수 또는 반환 값이 정확히 하나의 인수 또는 반환 값으로 변환됩니다 (또는 반환 값 없음). 적용된 변환은 이전 및 새 메서드 핸들 유형의 해당 구성 요소 유형을 참조하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c10541f1b7a87a46fca0e82cb887f1f5cdfbfc64" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types.</source>
          <target state="translated">현재 메소드가 가변 arity 메소드 인 경우 인수 목록 변환에는 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;다른 곳에 설명 된대로&lt;/a&gt; 여러 인수를 배열로 변환 및 수집하는 작업이 포함될 수 있습니다 . 다른 모든 경우에 모든 변환은 &lt;em&gt;pairwise&lt;/em&gt; 적용됩니다. 즉, 각 인수 또는 반환 값이 정확히 하나의 인수 또는 반환 값 (또는 반환 값 없음)으로 변환됩니다. 적용된 변환은 이전 및 새 메소드 핸들 유형의 해당 구성 요소 유형을 참조하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3234b563a8a8287e5245f9226141091af776f5ee" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback continues to the end of the sequence without looping, unless the loop end point is changed subsequently.</source>
          <target state="translated">이 메소드가 호출 될 때 현재 위치가 루프 종료점보다 큰 경우, 루프 종료 점이 이후에 변경되지 않는 한 반복없이 루프의 끝까지 재생이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="7e2a55a1a8bd4ad8685ae28cb47b45b0f898fa44" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback simply continues to the end of the clip without looping.</source>
          <target state="translated">이 메서드가 호출 될 때 현재 위치가 루프 끝점보다 크면 재생은 단순히 루프없이 클립의 끝까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="53f9e2fbf2a84ba1f43f8095838a4643dc8b642a" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가 이미 잠금을 보유한 경우 보유 횟수는 1 씩 증가하고 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bea401fb42f3ffdcd05852cff501d885235ba3f7" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the write lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가 이미 쓰기 잠금을 보유한 경우 보유 횟수는 1 씩 증가하고 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5d5c6242f9711c787eadd91061f9abc9aef5a8f" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">현재의 thread가 벌써이 락을 보관 유지하는 경우, 홀드 카운트는 1 씩 증가 해 메소드는 &lt;code&gt;true&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="e1db59e340b43fddf7a6d53a8527759fc071b7e9" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가이 잠금을 이미 보유하고 있으면 보유 횟수가 1 씩 증가하고 메소드가 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="de1ccea35bb4ddb6a5d8665f27c10c6698fe0002" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허용을 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하지만 스레드에 허용이 할당 된 시간은 중단이 발생하지 않았을 때 허용을받은 시간에 비해 변경 될 수 있습니다. 스레드가이 메서드에서 반환하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="967846e3a908254c0237f926edc93e8f505ceba6" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허용을 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하고 대기열에서의 위치에 영향을주지 않습니다. 스레드가이 메서드에서 반환하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c86b44509cfe15cabcfd2d4aab1300bc1d4ef97f" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허가를 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하지만 스레드에 허가가 할당 된 시간은 중단이 발생하지 않은 허가를받은 시간과 비교하여 변경 될 수 있습니다. 스레드가이 메소드에서 복귀하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="40fca319282952e93dfb024ecdef67ea1fa9292a" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허용을 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하며 큐의 위치는 영향을받지 않습니다. 스레드가이 메소드에서 복귀하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="161cfbc9814785c409424f6bf227b4259b6505f5" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. The &lt;em&gt;interrupted status&lt;/em&gt; of the current thread is cleared when this exception is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">현재 스레드가 대기 전 또는 대기 중에 스레드에 의해 &lt;a href=&quot;thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 &lt;code&gt;InterruptedException&lt;/code&gt; 이 throw됩니다. 이 예외가 발생하면 현재 스레드 의 &lt;em&gt;중단 된 상태&lt;/em&gt; 가 지워집니다. 이 예외는 위에서 설명한대로이 오브젝트의 잠금 상태가 복원 될 때까지 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1885c7979cce95514869fcb5fe52518650ad751" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">현재 스레드가 대기하기 전 또는 대기중인 스레드에 의해 &lt;a href=&quot;thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 된 경우 &lt;code&gt;InterruptedException&lt;/code&gt; 이 발생합니다. 이 예외는이 객체의 잠금 상태가 위에서 설명한대로 복원 될 때까지 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24ed769eb7f1d50760a5de23563feab0d013a7eb" translate="yes" xml:space="preserve">
          <source>If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens:</source>
          <target state="translated">현재 스레드가 마지막으로 도착하지 않은 경우 스레드 스케줄링을 위해 비활성화되고 다음 중 하나가 발생할 때까지 휴면 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e93c6ed45977774fb9b45dd0f270b3aadbc2d8b5" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동 중이면 실행하지 않고 예약을 취소하고 사용 가능한 경우 풀에 외부 적으로 제출 된 작업을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a9ec92500bb555146f4ac53bbc7fab388d80cf9" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동 중이면 실행하지 않고 예약을 취소하고 사용 가능한 경우 풀에 외부 적으로 제출 된 작업을 반환합니다. 가용성은 일시적 일 수 있으므로 &lt;code&gt;null&lt;/code&gt; 결과가 반드시 풀의 정지를 의미하지는 않습니다. 이 방법은 주로 확장을 지원하도록 설계되었으며 그렇지 않으면 유용하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3e28b29b93f45a59813378f46cf35c86d696607" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동 중이면 현재 스레드에 의해 대기열에 있지만 아직 실행되지 않은 다음 작업, 사용 가능한 경우 또는 사용할 수없는 경우 다른 스레드에 의해 분기 된 작업을 실행하지 않고 예약 취소하고 반환합니다. 가능한 경우.</target>
        </trans-unit>
        <trans-unit id="644fbda54838e93f9bd7f153a0b223117b46c3c3" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool this task is operating in. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동중인 경우, 현재 스레드에 의해 대기 중이지만 아직 실행되지 않은 다음 작업 (사용 가능한 경우 또는 사용 가능한 경우 다른 스레드에 의해 분기 된 작업)을 실행하지 않고 예약을 취소하고 반환합니다. 가능한 경우. 가용성은 일시적 일 수 있으므로 &lt;code&gt;null&lt;/code&gt; 결과가이 작업이 실행중인 풀의 정지를 의미하지는 않습니다.이 방법은 주로 확장을 지원하도록 설계되었으며 다른 방법으로는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d049c03bd38570f1b5a5d1aad9ff5cbfe4db5f0" translate="yes" xml:space="preserve">
          <source>If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">현재 스레드가이 잠금의 홀더 인 경우 보류 횟수가 감소합니다. 보류 카운트가 이제 0이면 잠금이 해제됩니다. 현재 스레드가이 잠금의 홀더가 아닌 경우 &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2cbfc6598ed6d1e50de22bbc3b671f7d2bef7cad" translate="yes" xml:space="preserve">
          <source>If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.</source>
          <target state="translated">현재 스레드가 마지막으로 도착한 스레드이고 생성자에 널이 아닌 배리어 조치가 제공된 경우 현재 스레드는 다른 스레드가 계속되도록 조치를 실행합니다. 장벽 동작 중에 예외가 발생하면 해당 예외가 현재 스레드에서 전파되고 장벽이 파손 된 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e09d61076e9dee8c7eca8604a1a4fdebca47aa" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">이 메소드에 들어갈 때 현재 쓰레드의 인터럽트 상태가 설정되거나 대기 중에 &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;인터럽트&lt;/a&gt; 되면 신호를받을 때까지 계속 대기합니다. 마지막으로이 메서드에서 반환되면 중단 된 상태가 계속 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="480b46196b0983b7baf6bc149cb22ece25ccb0df" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">현재 스레드의 인터럽트 상태가이 메소드에 진입 할 때 설정되거나 대기하는 동안 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 되면 신호가 날 때까지 계속 대기합니다. 이 메소드에서 마지막으로 리턴 될 때 인터럽트 된 상태는 계속 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ceafb860d280bdbbb95ef180a5ebfa010ab70b" translate="yes" xml:space="preserve">
          <source>If the current thread:</source>
          <target state="translated">현재 스레드가</target>
        </trans-unit>
        <trans-unit id="1b6dd611de80c284ec3983e42c194ba2625b5744" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number.</source>
          <target state="translated">현재 토큰이 숫자 인 경우이 필드에는 해당 숫자의 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a766629228a237157e338578f73608fe87ee3533" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number. The current token is a number when the value of the &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_NUMBER&lt;/code&gt;.</source>
          <target state="translated">현재 토큰이 숫자 인 경우이 필드에는 해당 숫자의 값이 포함됩니다. 현재 토큰은 &lt;code&gt;ttype&lt;/code&gt; 필드 의 값 이 &lt;code&gt;TT_NUMBER&lt;/code&gt; 일 때의 숫자 입니다.</target>
        </trans-unit>
        <trans-unit id="b366b28cb0c7e588029e3e176037326753259a0b" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token.</source>
          <target state="translated">현재 토큰이 단어 토큰 인 경우이 필드에는 단어 토큰의 문자를 제공하는 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6e1d9b63def477efdc3e54487d9fe89e9c35bd3c" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token. When the current token is a quoted string token, this field contains the body of the string.</source>
          <target state="translated">현재 토큰이 단어 토큰 인 경우이 필드에는 단어 토큰의 문자를 제공하는 문자열이 포함됩니다. 현재 토큰이 인용 문자열 토큰 인 경우이 필드에는 문자열 본문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b562295eceffafbb5ee1280fac546021ba6d2f83" translate="yes" xml:space="preserve">
          <source>If the currently selected input method or keyboard layout supports the requested locale, it remains selected.</source>
          <target state="translated">현재 선택된 입력 방법 또는 키보드 레이아웃이 요청 된 로케일을 지원하는 경우 선택된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e560277f9d287926b99c30eb8d401571d2c384c5" translate="yes" xml:space="preserve">
          <source>If the data to be updated has already been changed in the data source, there is a conflict, in which case the writer will not write the changes to the data source. The algorithm the writer uses for preventing or limiting conflicts depends entirely on its implementation.</source>
          <target state="translated">업데이트 할 데이터가 데이터 소스에서 이미 변경된 경우 충돌이 발생하며이 경우 작성자가 데이터 소스에 변경 사항을 쓰지 않습니다. 작성자가 충돌을 방지하거나 제한하기 위해 사용하는 알고리즘은 전적으로 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4610902d947f8dfa90bc178c559c33b46139cb9c" translate="yes" xml:space="preserve">
          <source>If the database supports SQL distinct types, then getTypeInfo() will return a single row with a TYPE_NAME of DISTINCT and a DATA_TYPE of Types.DISTINCT. If the database supports SQL structured types, then getTypeInfo() will return a single row with a TYPE_NAME of STRUCT and a DATA_TYPE of Types.STRUCT.</source>
          <target state="translated">데이터베이스가 SQL 구별 유형을 지원하는 경우 getTypeInfo ()는 TYPE_NAME이 DISTINCT이고 DATA_TYPE이 Types.DISTINCT 인 단일 행을 리턴합니다. 데이터베이스가 SQL 구조화 유형을 지원하는 경우 getTypeInfo ()는 TYPE_NAME이 STRUCT이고 DATA_TYPE이 Types.STRUCT 인 단일 행을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a247e695dc806480de65475cdb7e49df5eec14fe" translate="yes" xml:space="preserve">
          <source>If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5735c07ca103e22b6407b4ed7457c3834e66f98c" translate="yes" xml:space="preserve">
          <source>If the day-of-week is not available to format or parse then jump to day-of-month.</source>
          <target state="translated">요일을 형식화하거나 구문 분석 할 수없는 경우에는 요일로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="e4a38749edf09c8d242c279b91b8274b568cddfc" translate="yes" xml:space="preserve">
          <source>If the declared type of the field is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type arguments used in the source code.</source>
          <target state="translated">필드의 선언 된 유형이 매개 변수화 된 유형 인 경우 반환 된 &lt;code&gt;Type&lt;/code&gt; 개체는 소스 코드에서 사용 된 실제 유형 인수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="680a3260a09bc245ba12ad31e3216d2204601bd3" translate="yes" xml:space="preserve">
          <source>If the declared type of the record component is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned reflects the actual type arguments used in the source code.</source>
          <target state="translated">레코드 구성 요소의 선언 된 유형이 매개 변수가있는 유형 인 경우 반환 된 &lt;code&gt;Type&lt;/code&gt; 개체는 소스 코드에 사용 된 실제 유형 인수를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="836dc244145205490ef4ca5e728f09d48ff45702" translate="yes" xml:space="preserve">
          <source>If the decoded byte output of the needed size can not be allocated, the decode methods of this class will cause an &lt;a href=&quot;../lang/outofmemoryerror&quot;&gt;&lt;code&gt;OutOfMemoryError&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">필요한 크기의 디코딩 된 바이트 출력을 할당 할 수없는 경우이 클래스의 디코딩 메서드로 인해 &lt;a href=&quot;../lang/outofmemoryerror&quot;&gt; &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f18de43b225ddbb14630d1c44418bb878cab7e5f" translate="yes" xml:space="preserve">
          <source>If the default &lt;a href=&quot;locale.category#DISPLAY&quot;&gt;&lt;code&gt;DISPLAY&lt;/code&gt;&lt;/a&gt; locale contains &quot;rg&quot; (region override) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbol returned from this method reflects the value specified with that extension.</source>
          <target state="translated">기본 &lt;a href=&quot;locale.category#DISPLAY&quot;&gt; &lt;code&gt;DISPLAY&lt;/code&gt; &lt;/a&gt; 로케일에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우이 메서드에서 반환 된 기호는 해당 확장으로 지정된 값을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="dfa93f2a463d291904aa277d4928f5e5cc774981" translate="yes" xml:space="preserve">
          <source>If the default behavior is not desired, then a Java security property can be set to a different Time-to-live (TTL) value for positive caching. Likewise, a system admin can configure a different negative caching TTL value when needed.</source>
          <target state="translated">기본 동작이 필요하지 않은 경우, 긍정적 인 캐싱을 위해 Java 보안 특성을 다른 TTL (Time-to-live) 값으로 설정할 수 있습니다. 마찬가지로, 시스템 관리자는 필요할 때 다른 네거티브 캐싱 TTL 값을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6889d388923a46b89918d04e5ceb2d2c40c4a81f" translate="yes" xml:space="preserve">
          <source>If the default drag cursor behavior is active, this method sets the default drag cursor for the specified actions supported by the drag source, the drop target action, and status, otherwise this method does nothing.</source>
          <target state="translated">기본 드래그 커서 동작이 활성화 된 경우이 메서드는 드래그 소스, 드롭 대상 동작 및 상태에서 지원하는 지정된 동작에 대한 기본 드래그 커서를 설정합니다. 그렇지 않으면이 메서드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28ec4fb264f4592c3191c9dfa387e6201501d30a" translate="yes" xml:space="preserve">
          <source>If the descriptor encoded in the byte buffer does not indicate a set of packages in the module then the &lt;code&gt;packageFinder&lt;/code&gt; will be invoked. The set of packages that the &lt;code&gt;packageFinder&lt;/code&gt; returns must include all the packages that the module exports, opens, as well as the packages of the service implementations that the module provides, and the package of the main class (if the module has a main class). If the &lt;code&gt;packageFinder&lt;/code&gt; throws an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; then &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; cause will be re-thrown.</source>
          <target state="translated">바이트 버퍼에 인코딩 된 설명자가 모듈의 패키지 집합을 나타내지 않으면 &lt;code&gt;packageFinder&lt;/code&gt; 가 호출됩니다. &lt;code&gt;packageFinder&lt;/code&gt; 가 반환 하는 패키지 세트 에는 모듈이 제공하는 서비스 구현의 패키지와 모듈이 제공하는 서비스 구현의 패키지 (모듈에 기본 클래스가있는 경우)뿐만 아니라 모듈이 내보내고 여는 모든 패키지가 포함되어야합니다. . 는 IF &lt;code&gt;packageFinder&lt;/code&gt; 가 발생 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 을&lt;/a&gt; 다음 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이의&lt;/a&gt; 원인은 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b98052904a44628625b06f819a5054b172f83074" translate="yes" xml:space="preserve">
          <source>If the descriptor encoded in the input stream does not indicate a set of packages in the module then the &lt;code&gt;packageFinder&lt;/code&gt; will be invoked. The set of packages that the &lt;code&gt;packageFinder&lt;/code&gt; returns must include all the packages that the module exports, opens, as well as the packages of the service implementations that the module provides, and the package of the main class (if the module has a main class). If the &lt;code&gt;packageFinder&lt;/code&gt; throws an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; then &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; cause will be re-thrown.</source>
          <target state="translated">입력 스트림에 인코딩 된 설명자가 모듈의 패키지 집합을 나타내지 않으면 &lt;code&gt;packageFinder&lt;/code&gt; 가 호출됩니다. &lt;code&gt;packageFinder&lt;/code&gt; 가 반환 하는 패키지 세트 에는 모듈이 제공하는 서비스 구현의 패키지와 모듈이 제공하는 서비스 구현의 패키지 (모듈에 기본 클래스가있는 경우)뿐만 아니라 모듈이 내보내고 여는 모든 패키지가 포함되어야합니다. . 는 IF &lt;code&gt;packageFinder&lt;/code&gt; 가 발생 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 을&lt;/a&gt; 다음 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이의&lt;/a&gt; 원인은 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b2cac5e3a466b13ae80c01fca973dcf37b93b686" translate="yes" xml:space="preserve">
          <source>If the descriptor is empty the following String is returned: &amp;lt;Descriptor&amp;gt;&amp;lt;/Descriptor&amp;gt;</source>
          <target state="translated">디스크립터가 비어 있으면 다음 문자열이 리턴됩니다. &amp;lt;Descriptor&amp;gt; &amp;lt;/ Descriptor&amp;gt;</target>
        </trans-unit>
        <trans-unit id="873e8f5cab98a9e1326f6e91f9c4bb6efc23d9fb" translate="yes" xml:space="preserve">
          <source>If the designated column has a datatype of CHAR or VARCHAR and contains a &quot;0&quot; or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT and contains a 0, a value of &lt;code&gt;false&lt;/code&gt; is returned. If the designated column has a datatype of CHAR or VARCHAR and contains a &quot;1&quot; or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT and contains a 1, a value of &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 컬럼의 데이터 유형이 CHAR 또는 VARCHAR이고 &quot;0&quot;을 포함하거나 데이터 유형이 BIT, TINYINT, SMALLINT, INTEGER 또는 BIGINT이고 0을 포함하는 경우 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 지정된 열의 데이터 유형이 CHAR 또는 VARCHAR이고 &quot;1&quot;을 포함하거나 데이터 유형이 BIT, TINYINT, SMALLINT, INTEGER 또는 BIGINT이고 1을 포함하는 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8424e147bec876cffc18c36963ed5006f3be55ca" translate="yes" xml:space="preserve">
          <source>If the desired URL is not the one currently being displayed, the &lt;code&gt;getStream&lt;/code&gt; method is called to give subclasses control over the stream provided.</source>
          <target state="translated">원하는 URL이 현재 표시되는 URL이 아닌 경우 &lt;code&gt;getStream&lt;/code&gt; 메서드가 호출되어 제공된 스트림에 대한 제어 권한을 하위 클래스에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e04d7b4037ef0253d1eb9639910efd968b0cd89" translate="yes" xml:space="preserve">
          <source>If the desired member is &lt;code&gt;protected&lt;/code&gt;, the usual JVM rules apply, including the requirement that the lookup class must be either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading &lt;code&gt;this&lt;/code&gt; parameter from &lt;code&gt;C&lt;/code&gt; (which will necessarily be a superclass of the lookup class) to the lookup class itself.</source>
          <target state="translated">원하는 멤버가 &lt;code&gt;protected&lt;/code&gt; 되는 경우 조회 클래스가 원하는 멤버와 동일한 패키지에 있어야하거나 해당 멤버를 상속해야한다는 요구 사항을 포함하여 일반적인 JVM 규칙이 적용됩니다. (Java Virtual Machine 사양, 섹션 4.9.2, 5.4.3.5 및 6.4를 참조하십시오.) 또한 원하는 멤버가 정적이 아닌 필드 또는 다른 패키지의 메소드 인 경우 결과 메소드 핸들은 조회 클래스의 객체 또는 해당 서브 클래스 중 하나 이 요구 사항은 &lt;code&gt;this&lt;/code&gt; 매개 변수 의 선행 유형을 &lt;code&gt;C&lt;/code&gt; (조회 클래스의 수퍼 클래스 임)에서 조회 클래스 자체 로 좁 히면 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="9cfcd353d5f1c2be5e212dcf6a896c2900365e70" translate="yes" xml:space="preserve">
          <source>If the desired member is &lt;code&gt;protected&lt;/code&gt;, the usual JVM rules apply, including the requirement that the lookup class must either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.9.2&quot;&gt;4.9.2&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.3.5&quot;&gt;5.4.3.5&lt;/a&gt;, and &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jls-6.4&quot;&gt;6.4&lt;/a&gt;.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading &lt;code&gt;this&lt;/code&gt; parameter from &lt;code&gt;C&lt;/code&gt; (which will necessarily be a superclass of the lookup class) to the lookup class itself.</source>
          <target state="translated">원하는 멤버가 &lt;code&gt;protected&lt;/code&gt; 되는 경우 검색 클래스가 원하는 멤버와 동일한 패키지에 있거나 해당 멤버를 상속해야한다는 요구 사항을 포함하여 일반적인 JVM 규칙이 적용됩니다. (Java Virtual Machine 사양, 섹션 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.9.2&quot;&gt;4.9.2&lt;/a&gt; , &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.3.5&quot;&gt;5.4.3.5&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jls-6.4&quot;&gt;6.4를 참조하십시오&lt;/a&gt; .) 또한 원하는 멤버가 다른 패키지의 비 정적 필드 또는 메소드 인 경우 결과 메소드 핸들은 다음에 만 적용될 수 있습니다. 조회 클래스 또는 하위 클래스 중 하나의 개체. 이 요구 사항은 선행 &lt;code&gt;this&lt;/code&gt; 매개 변수 의 유형을 &lt;code&gt;C&lt;/code&gt; (조회 클래스의 수퍼 클래스가 될 것임)에서 조회 클래스 자체 로 좁혀서 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff1be7735213926c3d2c892b139efeed267ca86c" translate="yes" xml:space="preserve">
          <source>If the destination &lt;code&gt;Raster&lt;/code&gt; is null, a new &lt;code&gt;Raster&lt;/code&gt; is created. An &lt;code&gt;IllegalArgumentException&lt;/code&gt; may be thrown if the source is the same as the destination or if the number of bands in the source is not equal to the number of bands in the destination.</source>
          <target state="translated">대상 &lt;code&gt;Raster&lt;/code&gt; 가 null이면 새 &lt;code&gt;Raster&lt;/code&gt; 가 생성됩니다. &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 소스가 목적지로 또는 소스의 밴드 수와 목적지의 밴드 수와 같지 않으면 동일한 경우 발생 될 수있다.</target>
        </trans-unit>
        <trans-unit id="562d186cddc9b882f1164e575c0ca6cdd70e8771" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream()&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream()&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값)이면 &lt;a href=&quot;process#getErrorStream()&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 반환 된 입력 스트림을 사용하여 하위 프로세스의 오류 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getErrorStream()&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2f1759b66bcf0473ca1f75eb77e287f807f0be61" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 반환 한 입력 스트림을 사용하여 하위 프로세스의 오류 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="3ca5de5b614e7eb26d543dee9c4a10ca118934c5" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream()&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream()&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값)이면 &lt;a href=&quot;process#getInputStream()&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 반환 된 입력 스트림을 사용하여 하위 프로세스의 표준 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getInputStream()&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b68154bc9bb15cf5c833579d040cf02c8940944f" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 리턴 한 입력 스트림을 사용하여 서브 프로세스의 표준 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="24fa6417e10753014fbf446e67531a964d3dc7f5" translate="yes" xml:space="preserve">
          <source>If the destination is null, it will be created with a number of bands equalling the number of rows in the matrix. No exception is thrown if the operation causes a data overflow.</source>
          <target state="translated">대상이 null이면 행렬의 행 수와 같은 수의 밴드로 생성됩니다. 작업으로 인해 데이터 오버플로가 발생하는 경우 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5814c260a49a2bf524faa7ed1d2bd24188a54959" translate="yes" xml:space="preserve">
          <source>If the destination's &lt;code&gt;append()&lt;/code&gt; method never throws &lt;code&gt;IOException&lt;/code&gt;, then this method will always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">목적지의 &lt;code&gt;append()&lt;/code&gt; 메소드가 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시키지 않는 경우 ,이 메소드는 항상 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="00009ef2f2723f566d5cd7d5ea238cfdfa3f8286" translate="yes" xml:space="preserve">
          <source>If the determinant is non-zero, then this transform is invertible and the various methods that depend on the inverse transform do not need to throw a &lt;a href=&quot;noninvertibletransformexception&quot;&gt;&lt;code&gt;NoninvertibleTransformException&lt;/code&gt;&lt;/a&gt;. If the determinant is zero then this transform can not be inverted since the transform maps all input coordinates onto a line or a point. If the determinant is near enough to zero then inverse transform operations might not carry enough precision to produce meaningful results.</source>
          <target state="translated">결정자가 0이 아닌 경우이 변환은 반전 가능하며 역변환에 의존하는 다양한 메소드는 &lt;a href=&quot;noninvertibletransformexception&quot;&gt; &lt;code&gt;NoninvertibleTransformException&lt;/code&gt; &lt;/a&gt; 을 던질 필요가 없습니다 . 결정자가 0이면 변환이 모든 입력 좌표를 선 또는 점에 매핑하므로이 변환을 반전 할 수 없습니다. 행렬식이 0에 충분히 가까우면 역변환 연산이 의미있는 결과를 생성하기에 충분한 정밀도를 전달하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6980173cd7348cb8d2c24081aedaf81b540b3f" translate="yes" xml:space="preserve">
          <source>If the device does not support setting a specific controller, this method returns 0 for that controller. Calling &lt;code&gt;controlChange&lt;/code&gt; will have no effect then.</source>
          <target state="translated">장치가 특정 컨트롤러 설정을 지원하지 않는 경우이 메서드는 해당 컨트롤러에 대해 0을 반환합니다. 그러면 &lt;code&gt;controlChange&lt;/code&gt; 를 호출 해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df1f0903f6dd8ca3989d88e94f2d77f67eb5ad33" translate="yes" xml:space="preserve">
          <source>If the device does not support setting channel pressure, this method always returns 0. Calling &lt;code&gt;setChannelPressure&lt;/code&gt; will have no effect then.</source>
          <target state="translated">장치가 채널 압력 설정을 지원하지 않는 경우이 메서드는 항상 0을 반환합니다 . 그러면 &lt;code&gt;setChannelPressure&lt;/code&gt; 를 호출 해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8233a3647bc57e6741c1cb20e7987108b8967295" translate="yes" xml:space="preserve">
          <source>If the device does not support setting poly pressure, this method always returns 0. Calling &lt;code&gt;setPolyPressure&lt;/code&gt; will have no effect then.</source>
          <target state="translated">장치가 &lt;code&gt;setPolyPressure&lt;/code&gt; 설정을 지원하지 않는 경우이 메서드는 항상 0을 반환합니다. setPolyPressure 를 호출 해도 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8a2d79cc304a6be8aee1283d70f86196ba6e581" translate="yes" xml:space="preserve">
          <source>If the dialog is modal and is not already visible, this call will not return until the dialog is hidden by calling hide or dispose. It is permissible to show modal dialogs from the event dispatching thread because the toolkit will ensure that another event pump runs while the one which invoked this method is blocked.</source>
          <target state="translated">대화 상자가 모달이고 아직 표시되지 않은 경우이 호출은 hide 또는 dispose를 호출하여 대화 상자를 숨길 때까지 반환되지 않습니다. 툴킷은이 메소드를 호출 한 펌프가 차단 된 동안 다른 이벤트 펌프가 실행되도록 보장하기 때문에 이벤트 디스패치 스레드에서 모달 대화 상자를 표시하는 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec907f76145e8ddd032cdc8267ff559cc1c48182" translate="yes" xml:space="preserve">
          <source>If the digit is less than 10, then &lt;code&gt;'0' + digit&lt;/code&gt; is returned. Otherwise, the value &lt;code&gt;'a' + digit - 10&lt;/code&gt; is returned.</source>
          <target state="translated">숫자가 10보다 작 으면 &lt;code&gt;'0' + digit&lt;/code&gt; 가 반환됩니다. 그렇지 않으면 값 &lt;code&gt;'a' + digit - 10&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d397471c9fa609642a9cc71822d0d3db3f61ef8d" translate="yes" xml:space="preserve">
          <source>If the directory does not support a string representation of some or all of its attributes, the form of &lt;code&gt;search&lt;/code&gt; that accepts filter arguments in the form of Objects can be used instead. The service provider for such a directory would then translate the filter arguments to its service-specific representation for filter evaluation. See &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt;.</source>
          <target state="translated">디렉토리가 일부 또는 모든 속성의 문자열 표현을 지원하지 않으면 Objects 형식의 필터 인수를 허용 하는 &lt;code&gt;search&lt;/code&gt; 형식을 대신 사용할 수 있습니다. 그런 디렉토리에 대한 서비스 제공자는 필터 인수를 필터 평가를 위해 서비스 특정 표시로 변환합니다. 참조 &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77d2e43114de0de16774d5ed4ecd9f6313b3e490" translate="yes" xml:space="preserve">
          <source>If the doctype-public or doctype-system properties are specified, then the html output method should output a document type declaration immediately before the first element. The name following &amp;lt;!DOCTYPE should be HTML or html. If the doctype-public property is specified, then the output method should output PUBLIC followed by the specified public identifier; if the doctype-system property is also specified, it should also output the specified system identifier following the public identifier. If the doctype-system property is specified but the doctype-public property is not specified, then the output method should output SYSTEM followed by the specified system identifier.</source>
          <target state="translated">doctype-public 또는 doctype-system 속성이 지정된 경우 html 출력 메서드는 첫 번째 요소 바로 앞에 문서 유형 선언을 출력해야합니다. &amp;lt;! DOCTYPE 다음의 이름은 HTML 또는 html이어야합니다. doctype-public 속성이 지정된 경우 출력 메서드는 지정된 공용 식별자가 뒤에 오는 PUBLIC을 출력해야합니다. doctype-system 속성도 지정되면 공용 식별자 뒤에 지정된 시스템 식별자도 출력해야합니다. doctype-system 속성이 지정되었지만 doctype-public 속성이 지정되지 않은 경우 출력 메서드는 SYSTEM 뒤에 지정된 시스템 식별자를 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="86b3eab9594a91d2810de348de7dd9c40f4c769d" translate="yes" xml:space="preserve">
          <source>If the doctype-system property is specified, the xml output method should output a document type declaration immediately before the first element. The name following &amp;lt;!DOCTYPE should be the name of the first element. If doctype-public property is also specified, then the xml output method should output PUBLIC followed by the public identifier and then the system identifier; otherwise, it should output SYSTEM followed by the system identifier. The internal subset should be empty. The value of the doctype-public property should be ignored unless the doctype-system property is specified.</source>
          <target state="translated">doctype-system 속성이 지정된 경우 xml 출력 메서드는 첫 번째 요소 바로 앞에 문서 유형 선언을 출력해야합니다. &amp;lt;! DOCTYPE 다음의 이름은 첫 번째 요소의 이름이어야합니다. doctype-public 속성도 지정된 경우 xml 출력 메서드는 PUBLIC과 공용 식별자, 시스템 식별자를 차례로 출력해야합니다. 그렇지 않으면 SYSTEM 다음에 시스템 식별자를 출력해야합니다. 내부 하위 집합은 비어 있어야합니다. doctype-system 속성이 지정되지 않은 경우 doctype-public 속성 값은 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="cee8facf69b90419835e8685cee670049ac617cb" translate="yes" xml:space="preserve">
          <source>If the document is loaded asynchronously, the document will be installed into the editor immediately using a call to &lt;code&gt;setDocument&lt;/code&gt; which will fire a document property change event, then a thread will be created which will begin doing the actual loading. In this case, the page property change event will not be fired by the call to this method directly, but rather will be fired when the thread doing the loading has finished. It will also be fired on the event-dispatch thread. Since the calling thread can not throw an &lt;code&gt;IOException&lt;/code&gt; in the event of failure on the other thread, the page property change event will be fired when the other thread is done whether the load was successful or not.</source>
          <target state="translated">문서가 비동기식으로로드 되면 문서 속성 변경 이벤트를 발생시키는 &lt;code&gt;setDocument&lt;/code&gt; 호출을 사용하여 문서가 편집기에 즉시 설치되고 실제로드를 시작하는 스레드가 생성됩니다. 이 경우 페이지 속성 변경 이벤트는이 메서드에 대한 호출에 의해 직접 시작되지 않고로드를 수행하는 스레드가 완료 될 때 시작됩니다. 이벤트 디스패치 스레드에서도 실행됩니다. 호출 스레드는 다른 스레드에서 실패한 &lt;code&gt;IOException&lt;/code&gt; 을 throw 할 수 없으므로 로드 성공 여부에 관계없이 다른 스레드가 완료되면 페이지 속성 변경 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aa862933af1b586831035ab71ba5bcc647784cc" translate="yes" xml:space="preserve">
          <source>If the document is loaded synchronously, it will be filled in with the stream prior to being installed into the editor with a call to &lt;code&gt;setDocument&lt;/code&gt;, which is bound and will fire a property change event. If an &lt;code&gt;IOException&lt;/code&gt; is thrown the partially loaded document will be discarded and neither the document or page property change events will be fired. If the document is successfully loaded and installed, a view will be built for it by the UI which will then be scrolled if necessary, and then the page property change event will be fired.</source>
          <target state="translated">문서가 동 기적으로로드되면 편집기에 설치되기 전에 바인딩되고 속성 변경 이벤트를 발생시키는 &lt;code&gt;setDocument&lt;/code&gt; 에 대한 호출로 편집기에 설치되기 전에 스트림으로 채워집니다 . 경우 &lt;code&gt;IOException&lt;/code&gt; 가이 발생합니다 부분적으로로드 된 문서는 파기되어 문서 또는 페이지 프로퍼티 변경 이벤트가 트리거됩니다. 문서가 성공적으로로드되고 설치되면 UI에 의해 뷰가 빌드되고 필요한 경우 스크롤 된 다음 페이지 속성 변경 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="662626e1d4e27eb6ce910acdf4f7275869e7a388" translate="yes" xml:space="preserve">
          <source>If the document's schema is a DTD or no schema is associated with the document, this method will always return &lt;code&gt;false&lt;/code&gt; . If the document's schema is an XML Schema, the method will return &lt;code&gt;true&lt;/code&gt; if the reference type definition is derived from the other type definition according to the derivation parameter. If the value of the parameter is &lt;code&gt;0&lt;/code&gt; (no bit is set to &lt;code&gt;1&lt;/code&gt; for the &lt;code&gt;derivationMethod&lt;/code&gt; parameter), the method will return &lt;code&gt;true&lt;/code&gt; if the other type definition can be reached by recursing any combination of {base type definition}, {item type definition}, or {member type definitions} from the reference type definition.</source>
          <target state="translated">문서의 스키마가 DTD이거나 문서와 연결된 스키마가없는 경우이 메서드는 항상 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 문서의 스키마가 XML 스키마 인 경우 참조 유형 정의가 파생 매개 변수에 따라 다른 유형 정의에서 파생 된 경우 메서드는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 매개 변수의 값이 &lt;code&gt;0&lt;/code&gt; 인 경우 ( &lt;code&gt;derivationMethod&lt;/code&gt; 매개 변수에 대해 비트가 &lt;code&gt;1&lt;/code&gt; 로 설정되지 않음 ), {base type definition}, {item type definition}의 조합을 반복하여 다른 유형 정의에 도달 할 수 있으면 메소드는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다. , 또는 참조 유형 정의의 {멤버 유형 정의}.</target>
        </trans-unit>
        <trans-unit id="57aa15be161d274da17fe9d39d1cfb694489d07e" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML DTD [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt;], the values are computed as follows:</source>
          <target state="translated">문서의 스키마가 XML DTD [ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt; ] 인 경우 값은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="2c1b98243027ae1c98645a593d178914a7c6839f" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML DTD [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt;], the values are computed as follows:</source>
          <target state="translated">문서의 스키마가 XML DTD [ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt; ] 인 경우 값은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e10cb29a1e33b183a4131d16eb45066ea4a21c22" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면 스키마 유효성 검사 후 infoset 기여 (PSVI 기여라고도 함)를 사용하여 다음과 같이 값이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="8f795881894f367bf4d53a272b0c02b6372a7907" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;list&lt;/a&gt;.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ] 인 경우이 상수는 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;목록을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d81ff9adf73e073ce8071daca81533194b267a61" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt; union&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면이 상수는 단순 유형이 관련된 경우 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt;공용체를&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f779afced39b6f1300c741f0c131c9d3b3d3d63b" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt; extension&lt;/a&gt;.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ] 인 경우이 상수는 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt;확장에&lt;/a&gt; 의한 파생을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="31d86e81e617797ac0b52ef3cd63e328b705ec68" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt; restriction&lt;/a&gt; if complex types are involved, or a &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt; restriction&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면이 상수는 복잡한 유형이 포함 된 경우 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt;제한에&lt;/a&gt; 의한 파생을 나타내고 단순 유형이 포함 된 경우 &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt;제한에&lt;/a&gt; 의한 파생을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cbe9e7664e4f4017ad96a68076cc598006d5d112" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면 스키마 유효성 검사 후 infoset 기여 (PSVI 기여라고도 함)를 사용하여 다음과 같이 값이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f1168404c7c56d4e8e498e42bad0edb3c4bb73" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;list&lt;/a&gt;.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ] 인 경우이 상수는 &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;목록을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7aae511fcf2af94431f32c6ee8cbcd05c4ea0a08" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt; union&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면이 상수는 단순 유형이 포함 된 경우 &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt;공용체를&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8ba3d777f238d863319685e6c88d4e59e078f28f" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt; extension&lt;/a&gt;.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면이 상수는 &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt;확장에&lt;/a&gt; 의한 파생을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="18883cd53e5a6700508528271465beb712205ee0" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt; restriction&lt;/a&gt; if complex types are involved, or a &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt; restriction&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">문서의 스키마가 XML Schema [ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]이면이 상수는 복잡한 유형이 포함 된 경우 &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt;제한에&lt;/a&gt; 의한 파생을 나타내고 단순 유형이 포함 된 경우 &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt;제한에&lt;/a&gt; 의한 파생을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="762fcdd3511f74261ffaaa36150e2a54b62d2512" translate="yes" xml:space="preserve">
          <source>If the domain includes at least one occurrence of the wildcard characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">도메인에 와일드 카드 문자 별표 ( &lt;code&gt;*&lt;/code&gt; ) 또는 물음표 ( &lt;code&gt;?&lt;/code&gt; )가 하나 이상 포함 된 경우 객체 이름은 패턴입니다. 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b1cec24c27c8efb590156606b357f3a860a3a802" translate="yes" xml:space="preserve">
          <source>If the domain is empty, it will be replaced in certain contexts by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the ObjectName is used.</source>
          <target state="translated">도메인이 비어있는 경우 특정 컨텍스트 에서 ObjectName이 사용되는 MBean 서버 의 &lt;em&gt;기본 도메인&lt;/em&gt; 으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="e3eaf7e155e25958dd79b0ca8cbf2ed30fa28298" translate="yes" xml:space="preserve">
          <source>If the driver does not support catalogs, it will silently ignore this request.</source>
          <target state="translated">드라이버가 카탈로그를 지원하지 않으면이 요청을 자동으로 무시합니다.</target>
        </trans-unit>
        <trans-unit id="49cc5727dc2cc7276bd0bd19c6deedc6d76a47a7" translate="yes" xml:space="preserve">
          <source>If the driver does not support schemas, it will silently ignore this request.</source>
          <target state="translated">드라이버가 스키마를 지원하지 않으면이 요청을 자동으로 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2ec76dcdc78eed5e3ce7b1d5f25a9c8e1223867e" translate="yes" xml:space="preserve">
          <source>If the drop mode is &lt;code&gt;DropMode.INSERT&lt;/code&gt;, the return value refers to the path that should become the parent of the new data, in which case &lt;code&gt;getChildIndex()&lt;/code&gt; indicates where the new item should be inserted into this parent path. A &lt;code&gt;null&lt;/code&gt; path indicates that no parent path has been determined, which can happen for multiple reasons:</source>
          <target state="translated">드롭 모드가 &lt;code&gt;DropMode.INSERT&lt;/code&gt; 인 경우 반환 값은 새 데이터의 부모가되어야하는 경로를 참조하며,이 경우 &lt;code&gt;getChildIndex()&lt;/code&gt; 는 새 항목이이 부모 경로에 삽입되어야하는 위치를 나타냅니다. &lt;code&gt;null&lt;/code&gt; 경로는 부모 경로는 여러 가지 이유로 발생할 수있는 결정되지 않았 음을 나타냅니다 :</target>
        </trans-unit>
        <trans-unit id="7e77cff0b1d03502e9a750d78a9d1c0130ccaafc" translate="yes" xml:space="preserve">
          <source>If the drop mode is &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;, &lt;code&gt;getChildIndex&lt;/code&gt; can be used to determine whether the drop is on top of the path itself (&lt;code&gt;-1&lt;/code&gt;) or the index at which it should be inserted into the path (values other than &lt;code&gt;-1&lt;/code&gt;).</source>
          <target state="translated">드롭 모드 인 경우 &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt; 의 , &lt;code&gt;getChildIndex&lt;/code&gt; 는 드롭 경로 자체 (의 상단에 있는지 여부를 결정하기 위해 사용될 수 &lt;code&gt;-1&lt;/code&gt; 이 경로로 삽입되는) 나 인덱스 (이외의 값 &lt;code&gt;-1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="561e98f303c7dc9236bf9ca6b8c00ec7bcd40ae7" translate="yes" xml:space="preserve">
          <source>If the editor is an instance of &lt;code&gt;DefaultEditor&lt;/code&gt;, the call if forwarded to the editor, otherwise this does nothing.</source>
          <target state="translated">편집기가 &lt;code&gt;DefaultEditor&lt;/code&gt; 의 인스턴스 인 경우 호출은 편집기로 전달되고 그렇지 않으면 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc2230764f1928dcd4435430ac5eacac22d06da" translate="yes" xml:space="preserve">
          <source>If the element contains end-of-content mark (the last &lt;code&gt;
 &quot;\n&quot;&lt;/code&gt; character in document), this character is not removed; instead, preceding leaf element is extended to cover the character. If the last leaf already ends with &lt;code&gt;&quot;\n&quot;,&lt;/code&gt; it is included in content removal.</source>
          <target state="translated">요소에 내용 끝 표시 (문서의 마지막 &lt;code&gt; &quot;\n&quot;&lt;/code&gt; 문자)가 포함 된 경우이 문자는 제거되지 않습니다. 대신 선행 리프 요소가 확장되어 문자를 덮습니다. 마지막 리프가 이미 &lt;code&gt;&quot;\n&quot;,&lt;/code&gt; 끝나는 경우 콘텐츠 제거에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f5906e0e63b8f49e34b6700f88bda4ec0d7f3b19" translate="yes" xml:space="preserve">
          <source>If the element is &lt;code&gt;null,&lt;/code&gt;&lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If the element structure would become invalid after the removal, for example if the element is the document root element, &lt;code&gt;
 IllegalArgumentException&lt;/code&gt; is thrown. If the current element structure is invalid, &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">요소가 &lt;code&gt;null,&lt;/code&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 throw됩니다. 제거 후 요소 구조가 무효화되는 경우 (예 : 요소가 문서 루트 요소 인 경우) &lt;code&gt; IllegalArgumentException&lt;/code&gt; 이 발생합니다. 현재 요소 구조가 유효하지 않으면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="75155a89667cb2237cd0f9e72cff17a55ac4b5e0" translate="yes" xml:space="preserve">
          <source>If the element name has a namespace prefix, the prefix will still be attached to the name.</source>
          <target state="translated">요소 이름에 네임 스페이스 접두사가있는 경우에도 접두사가 이름에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="292c4a6cbb150ef1068ec19842ed8e1904c50655" translate="yes" xml:space="preserve">
          <source>If the element name has a namespace prefix, the prefix will still be attached. Note that the attribute list provided will contain only attributes with explicit values (specified or defaulted): #IMPLIED attributes will be omitted.</source>
          <target state="translated">요소 이름에 네임 스페이스 접두사가있는 경우 접두사가 계속 첨부됩니다. 제공된 속성 목록에는 명시 적 값 (지정 또는 기본값)이있는 속성 만 포함됩니다. #IMPLIED 속성은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="26be7554fade8f3ee174b1c39de7db2088b22346" translate="yes" xml:space="preserve">
          <source>If the element type is a &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt; class or interface, then this array class cannot be described nominally. The result string is not a type descriptor.</source>
          <target state="translated">요소 유형이 &lt;a href=&quot;#isHidden()&quot;&gt;숨겨진&lt;/a&gt; 클래스 또는 인터페이스 인 경우이 배열 클래스를 명목상으로 설명 할 수 없습니다. 결과 문자열이 유형 설명자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="18dd08f74ca34145a1c536a7fe2e41c8bb656227" translate="yes" xml:space="preserve">
          <source>If the element type is not a &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt; class or interface, then this array class can be described nominally. Calling &lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt;&lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt;&lt;/a&gt; with the result descriptor string produces a &lt;a href=&quot;constant/classdesc&quot;&gt;&lt;code&gt;ClassDesc&lt;/code&gt;&lt;/a&gt; describing this array class.</source>
          <target state="translated">요소 유형이 &lt;a href=&quot;#isHidden()&quot;&gt;숨겨진&lt;/a&gt; 클래스 또는 인터페이스 가 아닌 경우이 배열 클래스를 명목상으로 설명 할 수 있습니다. 결과 설명자 문자열로 &lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt; &lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt; &lt;/a&gt; 를 호출 하면이 배열 클래스를 설명 하는 &lt;a href=&quot;constant/classdesc&quot;&gt; &lt;code&gt;ClassDesc&lt;/code&gt; 가&lt;/a&gt; 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="632011698fb01f0e0fc60062d6f97f830dba4d90" translate="yes" xml:space="preserve">
          <source>If the elements contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</source>
          <target state="translated">요소가 하나의 부호의 무한대를 포함하고 중간 합계가 반대 부호의 무한대까지 오버플로되면 합계는 NaN 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925e78d915a458c34d3eb7516f6e0b5010e2a01e" translate="yes" xml:space="preserve">
          <source>If the elements contain infinities of opposite sign, the sum will be NaN.</source>
          <target state="translated">요소에 반대 부호의 무한대가 포함 된 경우 합계는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="be74757b15685dd5fdb4eea579602429c42b5b4c" translate="yes" xml:space="preserve">
          <source>If the elements contain one or more infinities, the sum will be infinite or NaN.</source>
          <target state="translated">요소에 하나 이상의 무한이 포함 된 경우 합계는 무한 또는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="1e256faf6974a8c97c36c1d2dc5a8b6122f7344d" translate="yes" xml:space="preserve">
          <source>If the elements of the source Vector of the ParameterBlock used to construct the RenderableImageOp are instances of RenderedImage, then the CRIF.create() method is called immediately using the original ParameterBlock. This provides a basis case for the recursion.</source>
          <target state="translated">RenderableImageOp를 생성하는 데 사용 된 ParameterBlock의 소스 Vector의 요소가 RenderedImage의 인스턴스 인 경우 원본 ParameterBlock을 사용하여 CRIF.create () 메서드가 즉시 호출됩니다. 이것은 재귀의 기본 사례를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="65b15f4158c3ccc225eea910594e13a346b7fa3c" translate="yes" xml:space="preserve">
          <source>If the encoded byte output of the needed size can not be allocated, the encode methods of this class will cause an &lt;a href=&quot;../lang/outofmemoryerror&quot;&gt;&lt;code&gt;OutOfMemoryError&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">필요한 크기의 인코딩 된 바이트 출력을 할당 할 수없는 경우이 클래스의 인코딩 메서드로 인해 &lt;a href=&quot;../lang/outofmemoryerror&quot;&gt; &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="166569c27e8b2a7656f585d48975b7df17589d30" translate="yes" xml:space="preserve">
          <source>If the encoding has an historical name then that name is returned; otherwise the encoding's canonical name is returned.</source>
          <target state="translated">인코딩에 히스토리 이름이 있으면 해당 이름이 리턴됩니다. 그렇지 않으면 인코딩의 정식 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3837fdfef6f0110640afb54a092f9fb29173f9df" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, a &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">모든 비트를 읽기 전에 스트림의 끝이 발견되면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48c3f477e37a6d7f2bde864091bbef88c4c21567" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">모든 비트를 읽기 전에 스트림의 끝에 도달하면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2217350c5c68b3e5ab4a98715b4b5c48f6366d39" translate="yes" xml:space="preserve">
          <source>If the entire string has been read or skipped, then this method has no effect and always returns 0.</source>
          <target state="translated">전체 문자열을 읽거나 건너 뛴 경우이 메서드는 적용되지 않으며 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ece76de2aa9cb829e9b2c9714827801ca68dc1f" translate="yes" xml:space="preserve">
          <source>If the entry being considered was created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the given certificate is compared to the first element of that entry's certificate chain.</source>
          <target state="translated">항목이 호출에 의해 생성 된 것으로 간주되는 경우 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 다음 지정된 인증서는 그 엔트리의 인증서 체인의 첫 번째 요소로 비교된다.</target>
        </trans-unit>
        <trans-unit id="901709c9c92242d1f05529c7ed99092d836cea48" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. If the date-time set is out of the range of the standard &lt;code&gt;
 MS-DOS date and time format&lt;/code&gt;, the time will also be stored into zip file entry's extended timestamp fields in &lt;code&gt;optional
 extra data&lt;/code&gt; in UTC time. The &lt;a href=&quot;../../time/zoneid#systemDefault()&quot;&gt;&lt;code&gt;system default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the local date-time to UTC time.</source>
          <target state="translated">항목이 ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력되는 경우이 방법으로 설정된 마지막 수정 시간 은 zip 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되고 표준 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 인코딩 됩니다 . 날짜-시간 세트가 표준 &lt;code&gt; MS-DOS date and time format&lt;/code&gt; 의 범위를 벗어난 경우 시간은 UTC 시간의 &lt;code&gt;optional extra data&lt;/code&gt; 에 있는 zip 파일 항목의 확장 된 타임 스탬프 필드에도 저장됩니다 . &lt;a href=&quot;../../time/zoneid#systemDefault()&quot;&gt; &lt;code&gt;system default TimeZone&lt;/code&gt; &lt;/a&gt; UTC 시간 로컬 날짜 - 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b500fa31b73e631f7dcb75621d0a2f6abc54a397" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">항목이 ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력되는 경우이 방법으로 설정된 마지막 수정 시간 은 zip 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되고 표준 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 인코딩 됩니다 . &lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 는 MS-DOS 데이터와 시간에 신기원 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a00a113b23cd107c1f980e1846beabb40469342" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">항목이 ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력되는 경우이 방법으로 설정된 마지막 수정 시간 은 zip 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되고 표준 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 인코딩 됩니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 는 MS-DOS 데이터와 시간에 신기원 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85a5272c1bab15e68743538f438b05df60195e22" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;
 date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우 이는 zip 파일 항목 의 &lt;code&gt; date and time fields&lt;/code&gt; 에서 마지막으로 수정 한 시간입니다 . &lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 신기원 시간에 표준 MS-DOS 형식의 날짜와 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ccafee62ee3362796ffa2f54139e7599780958" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우, 이것은 ZIP 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간입니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 신기원 시간에 표준 MS-DOS 형식의 날짜와 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab32364343d6a000b40b013685c0fce3d0cb517" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽은 경우 확장 된 타임 스탬프 필드가있는 경우 zip 파일 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 에서 마지막으로 수정 한 시간입니다 . 그렇지 않으면 항목의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간을 읽습니다 . &lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 을 사용하여 표준 MS-DOS 형식의 날짜 및 시간을 기점 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b289b42cb002e533856d62e0fbbde21b7d11a5b" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우 확장 된 시간 소인 필드가있는 경우 ZIP 파일 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 에서 마지막 수정 시간입니다 . 그렇지 않으면 항목의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간을 읽습니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 은 표준 MS-DOS 형식의 날짜 및 시간을 에포크 시간으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="05d613b0e17c16e0c66c734b0a98a9ba4f184306" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise, the last modification time is read from entry's standard MS-DOS formatted &lt;code&gt;date and time fields&lt;/code&gt;.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽은 경우 확장 된 타임 스탬프 필드가있는 경우 zip 파일 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 에서 마지막으로 수정 한 시간입니다 . 그렇지 않으면 항목의 표준 MS-DOS 형식 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="797642f2d5761f48870b5a97a0e9081a36bc1501" translate="yes" xml:space="preserve">
          <source>If the event class associated with this event factory is already registered, the call to this method is ignored.</source>
          <target state="translated">이 이벤트 팩토리와 관련된 이벤트 클래스가 이미 등록 된 경우이 메서드에 대한 호출이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="659072435671da166f323fd01cd2350cabee3286" translate="yes" xml:space="preserve">
          <source>If the event class associated with this event factory is not already registered, the call to this method is ignored.</source>
          <target state="translated">이 이벤트 팩토리와 관련된 이벤트 클래스가 아직 등록되지 않은 경우이 메서드에 대한 호출이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1131461e543048c9f3d0dad87b28281f4c97ad31" translate="yes" xml:space="preserve">
          <source>If the event class is already registered, then the invocation of this method is ignored.</source>
          <target state="translated">이벤트 클래스가 이미 등록 된 경우이 메서드의 호출이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="63079cda2661b4d19d530c94c9bca72825955418" translate="yes" xml:space="preserve">
          <source>If the event class is not registered, then the invocation of this method is ignored.</source>
          <target state="translated">이벤트 클래스가 등록되지 않은 경우이 메소드의 호출이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e02b2a061b3320b01237249ddfaa9eb0520ac284" translate="yes" xml:space="preserve">
          <source>If the event doesn't get filtered, it will try to insert content into the text editor. The content is fetched from the command string of the ActionEvent. The text entry is done through the &lt;code&gt;replaceSelection&lt;/code&gt; method on the target text component. This is the action that will be fired for most text entry tasks.</source>
          <target state="translated">이벤트가 필터링되지 않으면 텍스트 편집기에 콘텐츠 삽입을 시도합니다. 컨텐츠는 ActionEvent의 명령 문자열에서 가져옵니다. 텍스트 입력은 &lt;code&gt;replaceSelection&lt;/code&gt; 을 통해 수행됩니다. 대상 텍스트 구성 요소 메서드를 . 이것은 대부분의 텍스트 입력 작업에 대해 실행되는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="44db14d1e9cdb3209ffe191f5a2a3430583832df" translate="yes" xml:space="preserve">
          <source>If the event involved an exception, this will be the exception object. Otherwise null.</source>
          <target state="translated">이벤트에 예외가 포함 된 경우 예외 개체가됩니다. 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="8e47a9d7666abe192af5ff31d67d31063f85d1ad" translate="yes" xml:space="preserve">
          <source>If the event is an instant event, then the start time and end time are the same.</source>
          <target state="translated">이벤트가 인스턴트 이벤트 인 경우 시작 시간과 종료 시간이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="636af865dd5520f93c482ef1d513964eb35efb7f" translate="yes" xml:space="preserve">
          <source>If the event parameter is &lt;code&gt;null&lt;/code&gt; the behavior is unspecified and may result in an exception.</source>
          <target state="translated">이벤트 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 동작이 지정되지 않고 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86bcde70649fd800362c8d848bf84e937894cfad" translate="yes" xml:space="preserve">
          <source>If the event starts with an invocation of the &lt;code&gt;begin&lt;/code&gt; method, but does not end with an explicit invocation of the &lt;code&gt;end&lt;/code&gt; method, then the event ends when the &lt;code&gt;commit&lt;/code&gt; method is invoked.</source>
          <target state="translated">이벤트가 &lt;code&gt;begin&lt;/code&gt; 메서드 의 호출로 시작 하지만 &lt;code&gt;end&lt;/code&gt; 메서드 의 명시 적 호출로 끝나지 않는 경우 &lt;code&gt;commit&lt;/code&gt; 메서드가 호출 될 때 이벤트가 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="af1991d1905a17c3a61e8189297ee3cdafb502d7" translate="yes" xml:space="preserve">
          <source>If the event type is not one of the above, nothing happens.</source>
          <target state="translated">이벤트 유형이 위 중 하나가 아니면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04ee175a91380bcfff6774332dbdc8f91673dbd2" translate="yes" xml:space="preserve">
          <source>If the exact product of the first two arguments is infinite (in other words, at least one of the arguments is infinite and the other is neither zero nor NaN) and the third argument is an infinity of the opposite sign, the result is NaN.</source>
          <target state="translated">처음 두 인수의 정확한 곱이 무한대 (즉, 인수 중 하나 이상이 무한이고 다른 인수가 0도 NaN도 아님)이고 세 번째 인수가 반대 부호의 무한대이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="2ad6e084350af847bf5f8d8cac23d0487a14cc12" translate="yes" xml:space="preserve">
          <source>If the exception was created with the return value from the agent &lt;code&gt;Agent_OnAttach&lt;/code&gt; function then this returns that value, otherwise returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">에이전트 &lt;code&gt;Agent_OnAttach&lt;/code&gt; 함수 의 반환 값으로 예외가 생성 된 경우 해당 값을 반환하고 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="89efede28f8340ed4b4384494bc673df18dd7978" translate="yes" xml:space="preserve">
          <source>If the expression cannot be converted to return the specified type.</source>
          <target state="translated">지정된 유형을 리턴하도록 표현식을 변환 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="e95e52b95a3d17be2a361085bc902faa16c60d26" translate="yes" xml:space="preserve">
          <source>If the expression contains a function reference, the function will be found through the &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt; set with &lt;a href=&quot;#setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver)&quot;&gt;&lt;code&gt;setXPathFunctionResolver(XPathFunctionResolver resolver)&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the function resolver is undefined or the function resolver returns &lt;code&gt;null&lt;/code&gt; for the function.</source>
          <target state="translated">표현식에 함수 참조가 포함 된 경우 &lt;a href=&quot;#setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver)&quot;&gt; &lt;code&gt;setXPathFunctionResolver(XPathFunctionResolver resolver)&lt;/code&gt; &lt;/a&gt; 설정된 &lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; 를&lt;/a&gt; 통해 함수 를 찾습니다 . &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 함수 해결이 정의되지 않은 경우 발생하거나 기능 확인자 반환 &lt;code&gt;null&lt;/code&gt; 기능을 위해.</target>
        </trans-unit>
        <trans-unit id="43696688f3c4489c7b41ec9b95dff40a7fa60072" translate="yes" xml:space="preserve">
          <source>If the expression contains a function reference, the function will be found through the &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the function resolver is undefined or the function resolver returns &lt;code&gt;null&lt;/code&gt; for the function.</source>
          <target state="translated">표현식에 함수 참조가 포함되어 있으면 &lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; 를&lt;/a&gt; 통해 함수를 찾습니다 . &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 함수 해결이 정의되지 않은 경우 발생하거나 기능 확인자 반환 &lt;code&gt;null&lt;/code&gt; 기능을 위해.</target>
        </trans-unit>
        <trans-unit id="8ec91836ab8810be357b49e4f3c052ec4bf73ac1" translate="yes" xml:space="preserve">
          <source>If the expression contains a variable reference, its value will be found through the &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt; set with &lt;a href=&quot;#setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver)&quot;&gt;&lt;code&gt;setXPathVariableResolver(XPathVariableResolver resolver)&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the variable resolver is undefined or the resolver returns &lt;code&gt;null&lt;/code&gt; for the variable. The value of a variable must be immutable through the course of any single evaluation.</source>
          <target state="translated">표현식에 변수 참조가 포함 된 경우 해당 값은 &lt;a href=&quot;#setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver)&quot;&gt; &lt;code&gt;setXPathVariableResolver(XPathVariableResolver resolver)&lt;/code&gt; &lt;/a&gt; 설정된 &lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; 를&lt;/a&gt; 통해 검색 됩니다. &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 변수 리졸버가 정의되어있는 경우 발생하거나 해결 반환 &lt;code&gt;null&lt;/code&gt; 변수에 대한. 변수의 값은 단일 평가 과정에서 불변이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ac27a65340aff2ce4aa55c84684d42f7fc9702ed" translate="yes" xml:space="preserve">
          <source>If the expression contains a variable reference, its value will be found through the &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the variable resolver is undefined or the resolver returns &lt;code&gt;null&lt;/code&gt; for the variable. The value of a variable must be immutable through the course of any single evaluation.</source>
          <target state="translated">표현식에 변수 참조가 포함 된 경우 해당 값은 &lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; 를&lt;/a&gt; 통해 찾습니다 . &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 변수 리졸버가 정의되어있는 경우 제기하거나 해결 반환되는 &lt;code&gt;null&lt;/code&gt; 변수에 대한. 변수 값은 단일 평가 과정에서 변경 불가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="e47c3d09f4791484483e78797bfa839979548f7c" translate="yes" xml:space="preserve">
          <source>If the expression has a syntax error or otherwise is not a legal expression according to the rules of the specific &lt;code&gt;XPathEvaluator&lt;/code&gt; or contains specialized extension functions or variables not supported by this implementation.</source>
          <target state="translated">식에 구문 오류가 있거나 그렇지 않으면 특정 &lt;code&gt;XPathEvaluator&lt;/code&gt; 의 규칙에 따라 올바른식이 아니 거나이 구현에서 지원하지 않는 특수 확장 함수 또는 변수가 포함 된 경우.</target>
        </trans-unit>
        <trans-unit id="e0292adc0114844d25fb79e16b7258d6d3885abd" translate="yes" xml:space="preserve">
          <source>If the extension class loader cannot be found then the system class loader is used; if there is no system class loader then the bootstrap class loader is used.</source>
          <target state="translated">확장 클래스 로더를 찾을 수 없으면 시스템 클래스 로더가 사용됩니다. 시스템 클래스 로더가없는 경우 부트 스트랩 클래스 로더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="173d1b8bf14c80f810bc6e9721b807d2048ebbcd" translate="yes" xml:space="preserve">
          <source>If the field has the &lt;code&gt;@Unsigned&lt;/code&gt; annotation and is of a narrower type than &lt;code&gt;int&lt;/code&gt;, then the value will be returned as an unsigned.</source>
          <target state="translated">필드에 &lt;code&gt;@Unsigned&lt;/code&gt; 어노테이션이 있고 &lt;code&gt;int&lt;/code&gt; 보다 좁은 유형 인 경우 값은 unsigned로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b39d0fb537a08b776be7ac77a06fcd2b3da27f28" translate="yes" xml:space="preserve">
          <source>If the field has the &lt;code&gt;@Unsigned&lt;/code&gt; annotation and is of a narrower type than &lt;code&gt;long&lt;/code&gt;, then the value will be returned as an unsigned.</source>
          <target state="translated">필드에 &lt;code&gt;@Unsigned&lt;/code&gt; 주석이 있고 &lt;code&gt;long&lt;/code&gt; 보다 좁은 유형 인 경우 값은 unsigned로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2ed1f18b615e007d2288b83889463bb892c443f1" translate="yes" xml:space="preserve">
          <source>If the field has the &lt;code&gt;@Unsigned&lt;/code&gt; annotation and is of a narrower type than &lt;code&gt;short&lt;/code&gt;, then the value is returned as an unsigned.</source>
          <target state="translated">필드에 &lt;code&gt;@Unsigned&lt;/code&gt; 어노테이션이 있고 &lt;code&gt;short&lt;/code&gt; 보다 좁은 유형 인 경우 값은 unsigned로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6968b385e002c9508a424a478292c0f3a7af81" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the range of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 이면 1에서 7까지의 요일 범위가 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5c19fc73e0fc2d097b24a11cffd6f4ae4696359b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the value of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 이면 1에서 7까지의 요일 값이 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="30d9439a6bb009c979b0800716929ef61f2bbd69" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; 인&lt;/a&gt; 경우이 메소드는 true를 리턴합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="326c5765ea79518cbefcc0303c7d41108e792d2b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the range of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면 1에서 12까지의 월 범위가 반환됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="af240bad736f05e53adae955dd58de67cb50462f" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the value of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면 1에서 12까지의 월 값이 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4fe971066ffd7c4b8626dd60c34bb8f8261cfed9" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면이 메소드는 true를 리턴합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7faeadf7c05f00989d9bc2390cd06288a8ff039" translate="yes" xml:space="preserve">
          <source>If the field is &lt;code&gt;final&lt;/code&gt;, write access will not be allowed and access checking will fail, except under certain narrow circumstances documented for &lt;a href=&quot;../reflect/field#set(java.lang.Object,java.lang.Object)&quot;&gt;&lt;code&gt;Field.set&lt;/code&gt;&lt;/a&gt;. A method handle is returned only if a corresponding call to the &lt;code&gt;Field&lt;/code&gt; object's &lt;code&gt;set&lt;/code&gt; method could return normally. In particular, fields which are both &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; may never be set.</source>
          <target state="translated">필드가 &lt;code&gt;final&lt;/code&gt; 이면 &lt;a href=&quot;../reflect/field#set(java.lang.Object,java.lang.Object)&quot;&gt; &lt;code&gt;Field.set&lt;/code&gt; 에&lt;/a&gt; 대해 문서화 된 특정 좁은 상황을 제외하고 쓰기 액세스가 허용되지 않고 액세스 검사가 실패 합니다. 메서드 핸들은 &lt;code&gt;Field&lt;/code&gt; 개체의 &lt;code&gt;set&lt;/code&gt; 메서드에 대한 해당 호출이 정상적으로 반환 될 수 있는 경우에만 반환됩니다. 특히, &lt;code&gt;static&lt;/code&gt; 적이고 &lt;code&gt;final&lt;/code&gt; 필드 는 절대 설정되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38484743a496914be1e808c10f80951caa603c0e" translate="yes" xml:space="preserve">
          <source>If the field is &lt;code&gt;static&lt;/code&gt;, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">필드가 &lt;code&gt;static&lt;/code&gt; 이고 반환 된 메서드 핸들이 호출 된 경우 필드의 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="3cbe7e72fb8b0010865d68d0c08c6481722f84e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the range. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 필드의 범위를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="184058e0a14902aa21c927d78bf2821afd7ffb8f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the value of the era. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 의 필드는 시대의 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1953db0f99dd40e5aaa224b3ed2d92f821f4fad2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 의 필드는 true를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5df5ba306c3a00473938e546303760434732261a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. 지원되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddb65541050763763b556e80a29c16db72c7248" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="871d99f928633d452b234c707859c60ee439a250" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 조정이 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 에 일치하는 방법에 따라 작동합니다 &lt;a href=&quot;localdate#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt; . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="cc3692f941d5abe057e214a3bd9f234905a09651" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 에 일치하는 방법에 따라 작동합니다 &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt; . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1d4babbf0823e08d2dba83490653149a8a5cf2ed" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The supported fields behave as follows:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다. 지원되는 필드는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="654ffbe0ee041234f33cf275c87fc4c9fc7c6dd4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="073a987d8c755e83cfc6ffb42e22775ce7412bb2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 날짜를 기준으로 유효 값을 반환합니다 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="393ab92db0d7f28b2848265a88f15c6d53af21b2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 발생 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="7152b3b52d7c7f0f4904764283f2e7cc4e36acbd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="67d10135df9a9ec6dcec81f7c4eba9e088b27dc9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="241448bc71c4585fd6b57179f68b0b3ae2b77f80" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4394383d7f696594ca101d030728c860c4bd2767" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 날짜를 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="55f31e63ce0b6d34f732d6c74159b03dff5fbefe" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 달 일을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3d5a1d9d7bbcd893d7dda7838ecb8f4a2331eaea" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="54d4291388dc2b83820f747cb1f95091292f696d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e757166ab7f790e16750f19e7591a3771d8323b1" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 올해 개월을 기준으로 유효한 값을 반환합니다 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="07988f9ebdc9aba8f17f1634be192d7cbfc13f5d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해 개월을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="24967a514d85ca0fb445207b1151d9d0b3e22369" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해에 따라 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b3a122466042d935dfadf2919be12e5c6bf577cb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b2fae4d33d968604493905d86ff128c82e5db2f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 발생 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="552594823755dd323e34fbb36aa82bd02dc7ccec" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="64682870ad58c05c116e810cd345d87fe71b6bca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e53df72b9538f5704d56c85109a2837d5a0400cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 날짜를 기준으로 유효 값을 반환합니다 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="32c54db3dedc37f0421eb1580db3b740ec121cad" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 날짜를 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="11ea794a31defe3e3eefa9ea5db21eca50570400" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a90c6eb29cbac028e8449f9cf54d00261c219feb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5b5f3e15dbf7f02cadaff2b1f715b8a83fed50ca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2d7280f2ef05621f8965764c134012686323f8c9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a08bb7dfd7f2733af861740d800b7ce9f70eb5cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f2ea46b126ff3b5bdbf666ca3c46b71e50576dc7" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3f81a778997a088523214d2edc7a7aab7a300ca4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ce1690eace7e2c6d89cc928ca7a7a051f9a8d0f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 달 일을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="54c277810f3ed7c547f4b1ad6fd3fb8f9a746292" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="20e764af5b165d57d63cb3a6753fd7d4d9d38420" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bbfa08249a8a681a77ac31ded9b0970961cb7e45" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="216d1b40d29dcd13ae455e39ff25a34173b680bc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="89af7f61649fef38a7f170c1bd0ab908cfde7464" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f135da292374c58a63e9a7dd6bf4f22cdbf128fc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="66a31e186370c87394aabeac098a9be857ade9fd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1a78917caede284548be462696171d8a8df88818" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해에 따라 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="638fba149e2f9605d4c8dd06cfefd8163837f176" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bc96611b6dd2d22d3132d6d3df53e51b38124d7a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 올해 개월을 기준으로 유효한 값을 반환합니다 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5f2e16d3207b8a1b377b13995b5829979baa3c06" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해 개월을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5fda7020a7bae43a5df2b5286206bb91d72d039d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="88d03525f1042dd0011a22419c6df4c5121eba14" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a0124fd3059f644ca04188c31653732caf32a08f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="0337a2eda7a472dc0aa83a7e1eef644d5a370e32" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4046ccaca6ad2d1bf0b7e5c2e124396f1812f96d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns the value of the offset. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 의 필드 오프셋의 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="09800c7a5d51ab3ac1ecbfa59a39761992b8d783" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 의 필드는 true를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bcdaaec98194652eaec2e755f354592d8a5f1fa2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt;여기에서 쿼리가 구현됩니다. 지원되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26f815de83bf9d85fe8094749e5ea200739939d5" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localdatetime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d8816d4bddc205a3c0266b4706842519edca858" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30e6967c28e9ee1cc43dcf0ccc34a23008296abc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다 . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a927c94cc558aa44e673d3c09b5dede6b4bbec9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edd9f66100a0f8ebdeaf7afd13edd4d404894480" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;#plusDays(long)&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 날짜 단위는 &lt;a href=&quot;localdate#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가됩니다 . 시간 단위는 &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 에 따라 추가되며 &lt;a href=&quot;#plusDays(long)&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일하게 추가 된 일 단위의 오버플로가 있습니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="f5cba436d7af3b0ad553fc0358e491b4ffeb23a3" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 날짜 단위는 &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가됩니다 . 시간 단위는 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가되며 , 일 수의 오버플로는 &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt; 사용과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="87edabfd23bcd4b5580257d424970351a200d0e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The supported fields behave as follows:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 지원되는 필드는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7d28f15788411edaf2c4769963134a70f9a51014" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The zone is not part of the calculation and will be unchanged in the result. The calculation for date and time units differ.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 영역은 계산의 일부가 아니며 결과에서 변경되지 않습니다. 날짜 및 시간 단위에 대한 계산이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="472a2bad58441686158034a719ecf7233180fcd9" translate="yes" xml:space="preserve">
          <source>If the field is declared &lt;code&gt;volatile&lt;/code&gt; then the returned VarHandle will override access to the field (effectively ignore the &lt;code&gt;volatile&lt;/code&gt; declaration) in accordance to its specified access modes.</source>
          <target state="translated">필드가 &lt;code&gt;volatile&lt;/code&gt; 로 선언 되면 반환 된 VarHandle이 필드에 대한 액세스를 재정의합니다 (효과적으로 &lt;code&gt;volatile&lt;/code&gt; 지정된 액세스 모드에 따라 선언을 ).</target>
        </trans-unit>
        <trans-unit id="df5997d9cb9eb98daf0677e44c78da78084843dc" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is obtained according to the preceding rules.</source>
          <target state="translated">필드가 다음 유형으로 숨겨진 경우 &lt;code&gt;obj&lt;/code&gt; 지면 필드 값은 이전 규칙에 따라 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3cd0fa2a6c549544bf0fa17d3fe9a0bbdad3a534" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is set according to the preceding rules.</source>
          <target state="translated">필드가 &lt;code&gt;obj&lt;/code&gt; 유형에 숨겨져있는 경우 값은 이전 규칙에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c8f06458338d0982fde844f74e3eac7907ffd72d" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the field determines whether and how to adjust the instant.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로 . 이 경우 필드는 순간을 조정할지 여부와 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="bc13b792f3c5838d3770d636dc87567d506bc218" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 첫번째 인자로.</target>
        </trans-unit>
        <trans-unit id="593408760a93df2aae450a2a246b1f8f655869de" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="84111e9c7052aea445fc84ff88640c7d9d47a3e1" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 값을 얻을 수 있는지 여부와 값이 나타내는 것은 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0976d6ec775eae314c44e1cc501085eba97650" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="8bfc158b937ea3897727206425819d75e46f302c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the field is supported is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 필드가 지원되는지 여부는 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="63182facd2f63b4b7afccc2a4e59688c8ba979ee" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="7688528113c7572e4ebfde7d3d5c748187dbd155" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the range can be obtained is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 범위를 얻을 수 있는지 여부는 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="9dc945edaeb99a9dd905b6958af0da2b698eb2ff" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="1bc2facd61e2bb2d253a7e2d751714a8d91fd304" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the unit determines whether and how to perform the addition.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoUnit&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 이 경우 장치는 추가 수행 여부와 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3745b108d29fe526d4efe7b06863f59e4b41c30c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoUnit&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="7c31bf8c81eb5e3fa5966507ecfeb7eeb414a7a3" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned VarHandle is operated on, the field's declaring class will be initialized, if it has not already been initialized.</source>
          <target state="translated">필드가 정적이고 반환 된 VarHandle이 작동되는 경우 필드의 선언 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="73f48c353a2b4ef722c15d4cc5583b25df30a788" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">필드가 정적이고 리턴 된 메소드 핸들이 호출되면 필드의 클래스가 초기화되지 않은 경우 필드 클래스가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f75aa0d9bdab9beccdb246276fa853bdf88f9fa1" translate="yes" xml:space="preserve">
          <source>If the field type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then numeric and atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">필드 유형이 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 이면 숫자 및 원자 업데이트 액세스 모드는 비트 표현을 사용하여 값을 비교합니다 &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt; 각각 &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt; 및 Double.doubleToRawLongBits (double) 참조 ).</target>
        </trans-unit>
        <trans-unit id="9a766268cd602d31dba43c646e17e366517c908b" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0.</source>
          <target state="translated">파일이 이미 존재하고 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열리면 길이가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="929d4fca608fb0e25c4e8a63977f3cccb4c4213a" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">파일이 이미 존재하고 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열리면 길이가 0으로 잘립니다. 파일이 &lt;a href=&quot;#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 용으로 만 열린 경우이 옵션은 무시됩니다. 액세스 .</target>
        </trans-unit>
        <trans-unit id="99de1988747f1a4d19117e077c897d899a759367" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">파일이 이미 존재하고 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열린 경우에는 길이가 0으로 잘립니다.이 옵션은 파일이 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 액세스 용으로 만 열린 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="717bfba6c0a90a03523ab0b13a3750e80f9e6288" translate="yes" xml:space="preserve">
          <source>If the file does not reside on a local device then no such guarantee is made.</source>
          <target state="translated">파일이 로컬 장치에 없으면 그러한 보증이 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c9b9ed3b31f95435fd26b9b50e781fb7b10f8ba" translate="yes" xml:space="preserve">
          <source>If the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">파일이 존재하지만 일반 파일이 아닌 디렉토리 인 경우 존재하지 않지만 작성할 수 없거나 다른 이유로 열 수없는 경우 &lt;code&gt;FileNotFoundException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f72ad9bda52a7b14dd7371372743b4037fafc486" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist.</source>
          <target state="translated">파일이 디렉토리이면 디렉토리가 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리 작성시 작성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 특수 항목 만 존재할 경우 디렉토리는 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d8fa9367e398fcca0e927495045f7052187e809e" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;#walkFileTree(java.nio.file.Path,java.util.Set,int,java.nio.file.FileVisitor)&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">파일이 디렉토리이면 디렉토리가 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리가 생성 될 때 생성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 디렉토리는 특수 항목 만 존재할 때 비어있는 것으로 간주됩니다. 이 메소드는 &lt;a href=&quot;#walkFileTree(java.nio.file.Path,java.util.Set,int,java.nio.file.FileVisitor)&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용 하여 디렉토리 및 디렉토리의 모든 항목 또는 전체 항목을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c1117a6df1c8b656d3b8ee4f35129ed11c6504" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">파일이 디렉토리 인 경우 디렉토리는 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리 작성시 작성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 특수 항목 만 존재할 경우 디렉토리는 비어있는 것으로 간주됩니다. 이 메소드를 &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용 하여 디렉토리 및 디렉토리의 모든 항목 또는 전체를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d651a40c8a6027fa645d02154642d3d0cbb9614" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">파일이 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열리면 바이트는 시작이 아닌 파일 끝에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7dbd0c6e9ab04a8789ef0e83e00003ffa2ee9662" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">파일이 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열린 경우 바이트는 시작이 아닌 파일의 끝에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d2a8154b6e04db066d371ce68d85675117b48d" translate="yes" xml:space="preserve">
          <source>If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.</source>
          <target state="translated">다른 프로그램이 쓰기 액세스를 위해 파일을 연 경우 파일 끝에 쓰는 것이 원자적인 경우 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="363aa2bf9bc4403e90b3304537b4850955de2d6f" translate="yes" xml:space="preserve">
          <source>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.</source>
          <target state="translated">이 버퍼에 맵핑 된 파일이 로컬 저장 장치에 상주하는 경우이 메소드가 리턴 할 때 버퍼가 작성된 이후 또는이 메소드가 마지막으로 호출 된 이후에 버퍼에 대한 모든 변경 사항이 해당 디바이스에 기록되었음을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="26650d7e2c0ee9c777086da59ae41956022f191f" translate="yes" xml:space="preserve">
          <source>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the selected region buffer since it was created, or since this method was last invoked, will have been written to that device. The force operation is free to write bytes that lie outside the specified region, for example to ensure that data blocks of some device-specific granularity are transferred in their entirety.</source>
          <target state="translated">이 버퍼에 매핑 된 파일이 로컬 저장 장치에 상주하는 경우이 메서드가 반환 될 때 생성 된 이후 또는이 메서드가 마지막으로 호출 된 이후 선택한 영역 버퍼에 대한 모든 변경 사항이 해당 장치에 기록되었음을 보장합니다. . 강제 작업은 지정된 영역 외부에있는 바이트를 자유롭게 쓸 수 있습니다. 예를 들어 일부 장치 별 세분성의 데이터 블록이 전체적으로 전송되도록합니다.</target>
        </trans-unit>
        <trans-unit id="5c66fa0bc0370be55e7f6902e9819c235f1ae2c1" translate="yes" xml:space="preserve">
          <source>If the file mapped into this segment resides on a local storage device then when this method returns it is guaranteed that all changes made to the segment since it was created, or since this method was last invoked, will have been written to that device.</source>
          <target state="translated">이 세그먼트에 매핑 된 파일이 로컬 저장 장치에있는 경우이 메서드가 반환 될 때 세그먼트가 생성 된 이후 또는이 메서드가 마지막으로 호출 된 이후에 적용된 모든 변경 사항이 해당 장치에 기록되었음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="5d3f80a7c47e0dee8ff25771e1984095801d55de" translate="yes" xml:space="preserve">
          <source>If the file system and files remain static, then this method implements an equivalence relation for non-null &lt;code&gt;Paths&lt;/code&gt;.</source>
          <target state="translated">파일 시스템과 파일이 정적으로 유지되면이 메소드는 널이 아닌 &lt;code&gt;Paths&lt;/code&gt; 대한 등가 관계를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="bf2540a956606dd24c05d911dfb014b7471baead" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;#lastModifiedTime()&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 액세스 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메서드는 구현 특정 기본값 (일반적으로 &lt;a href=&quot;#lastModifiedTime()&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;FileTime&lt;/code&gt; )을 반환합니다. epoch를 나타내는 (1970-01-01T00 : 00 : 00Z).</target>
        </trans-unit>
        <trans-unit id="1cc09fc7cf4f903c9ad57909dbe23e700dcd6cfb" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 액세스 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값, 일반적으로 &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 신기원을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; (1970-01-01T00 : 00)을 리턴합니다 . 00Z).</target>
        </trans-unit>
        <trans-unit id="fa544bd520d9dcec26b2ece7f7dc9e779d24b413" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last modification then this method returns an implementation specific default value, typically a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 수정 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값 (일반적으로 신기원 (1970-01-01T00 : 00 : 00Z)을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; )을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="02f361be725f40f9d2cf1b1f7f87f23ccb88afbd" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;#lastModifiedTime()&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 파일이 생성 된 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메서드는 구현 특정 기본값 (일반적으로 &lt;a href=&quot;#lastModifiedTime()&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 epoch를 나타내는 &lt;code&gt;FileTime&lt;/code&gt; (1970-01-01T00 : 00 : 00Z).</target>
        </trans-unit>
        <trans-unit id="823bb3918b8c7dfd2716375b3397ec3520a2d6b4" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현에서 파일이 생성 된 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값, 일반적으로 &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 신기원 (1970-01-01T00)을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; 을 리턴합니다 . 00 : 00Z).</target>
        </trans-unit>
        <trans-unit id="cbaa60988de0c25a04ce29dd95934e886dae24fd" translate="yes" xml:space="preserve">
          <source>If the file system object identified by this object is currently registered with the watch service then the watch key, representing that registration, is returned after changing the event set or modifiers to those specified by the &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;modifiers&lt;/code&gt; parameters. Changing the event set does not cause pending events for the object to be discarded. Objects are automatically registered for the &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt;&lt;code&gt;OVERFLOW&lt;/code&gt;&lt;/a&gt; event. This event is not required to be present in the array of events.</source>
          <target state="translated">이 오브젝트에 의해 식별 된 파일 시스템 오브젝트가 현재 감시 서비스에 등록 된 경우, 이벤트 세트 또는 수정자를 &lt;code&gt;events&lt;/code&gt; 및 &lt;code&gt;modifiers&lt;/code&gt; 매개 변수에 의해 지정된 것으로 변경 한 후 해당 등록을 나타내는 감시 키가 리턴 됩니다. 이벤트 세트를 변경해도 오브젝트의 보류중인 이벤트가 삭제되지 않습니다. &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt; &lt;code&gt;OVERFLOW&lt;/code&gt; &lt;/a&gt; 이벤트에 객체가 자동으로 등록됩니다 . 이 이벤트는 이벤트 배열에 존재할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="459754495e8f2fc830a24baaf3d7fd1c98e3b5d4" translate="yes" xml:space="preserve">
          <source>If the file system supports &lt;a href=&quot;package-summary#links&quot;&gt;symbolic links&lt;/a&gt; then this method is used to read the target of the link, failing if the file is not a symbolic link. The target of the link need not exist. The returned &lt;code&gt;Path&lt;/code&gt; object will be associated with the same file system as &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">파일 시스템이 &lt;a href=&quot;package-summary#links&quot;&gt;기호 링크&lt;/a&gt; 를 지원하는 경우이 방법은 링크 대상을 읽는 데 사용되며 파일이 기호 링크가 아닌 경우 실패합니다. 링크의 대상이 없어도됩니다. 리턴 된 &lt;code&gt;Path&lt;/code&gt; 오브젝트는 &lt;code&gt;link&lt;/code&gt; 와 동일한 파일 시스템과 연관 됩니다.</target>
        </trans-unit>
        <trans-unit id="fb0c8d3a8a398a77e00455877d296ebfc50c2a10" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions()&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">파일 시스템이 다른 보안 관련 파일 속성 (예 : 파일 &lt;a href=&quot;posixfileattributes#permissions()&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt; 을 지원하는 경우 액세스 제어 목록을 업데이트하면 이러한 보안 관련 속성도 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7347290370c35baf47e41039a48176f518ba6b9" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">파일 시스템이 다른 보안 관련 파일 속성 (예 : 파일 &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt; 등)을 지원 하는 경우 액세스 제어 목록을 업데이트하면 이러한 보안 관련 속성도 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67de7dc4816dc3dd80c82da2f81ec2067ab1b35e" translate="yes" xml:space="preserve">
          <source>If the filter returns &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt;&lt;code&gt;Status.REJECTED&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;null&lt;/code&gt; or throws a &lt;a href=&quot;../lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;, the active &lt;code&gt;readObject&lt;/code&gt; or &lt;code&gt;readUnshared&lt;/code&gt; throws &lt;a href=&quot;invalidclassexception&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;, otherwise deserialization continues uninterrupted.</source>
          <target state="translated">필터가 &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt; &lt;code&gt;Status.REJECTED&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;null&lt;/code&gt; 을 반환 하거나 &lt;a href=&quot;../lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; 을&lt;/a&gt; throw 하면 활성 &lt;code&gt;readObject&lt;/code&gt; 또는 &lt;code&gt;readUnshared&lt;/code&gt; 가 &lt;a href=&quot;invalidclassexception&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; 을&lt;/a&gt; throw 하고 그렇지 않으면 deserialization이 중단없이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9f05868501904493829d0907142a7754fe1122ce" translate="yes" xml:space="preserve">
          <source>If the filter returns a value, the target must accept that value as its argument in position &lt;code&gt;pos&lt;/code&gt;, preceded and/or followed by any arguments not passed to the filter. If the filter returns void, the target must accept all arguments not passed to the filter. No arguments are reordered, and a result returned from the filter replaces (in order) the whole subsequence of arguments originally passed to the adapter.</source>
          <target state="translated">필터가 값을 반환하는 경우 대상은 해당 값을 위치 &lt;code&gt;pos&lt;/code&gt; 의 인수로, 필터에 전달되지 않은 인수 앞에 와야합니다. 필터가 void를 반환하면 대상은 필터에 전달되지 않은 모든 인수를 허용해야합니다. 다시 정렬 된 인수는 없으며 필터에서 리턴 된 결과는 원래 어댑터로 전달 된 인수의 전체 서브 시퀀스를 (순서대로) 대체합니다.</target>
        </trans-unit>
        <trans-unit id="4842b7ba908041edda9019cd8af48573f8706e76" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of bytes actually read.</source>
          <target state="translated">기본 스트림 의 첫 번째 &lt;code&gt;read&lt;/code&gt; 에서 파일 끝을 나타 내기 위해 &lt;code&gt;-1&lt;/code&gt; 을 반환 하면 이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 그렇지 않으면이 메소드는 실제로 읽은 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="33b359247ef4ee2d114342c7c506f4ed4d411b51" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of characters actually read.</source>
          <target state="translated">기본 스트림 의 첫 번째 &lt;code&gt;read&lt;/code&gt; 에서 파일 끝을 나타 내기 위해 &lt;code&gt;-1&lt;/code&gt; 을 반환 하면 이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 그렇지 않으면이 메소드는 실제로 읽은 문자 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ce60218f2510c7e7fddf8a7ccb70e4c23d7ed409" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN and the second argument is nonzero, then the result is NaN.</source>
          <target state="translated">첫 번째 인수가 NaN이고 두 번째 인수가 0이 아닌 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="8870d606c771442922f1503139366f1c5f6ffb42" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN, NaN is returned.</source>
          <target state="translated">첫 번째 인수가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9089269bb48d32b9328e7c9f2b5e776cab13b138" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and less than zero</source>
          <target state="translated">첫 번째 인수가 유한하고 0보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="40390f7aa327fdf0e7159e3c2ee52c76dda4cc5d" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and the second argument is infinite, then the result is the same as the first argument.</source>
          <target state="translated">첫 번째 인수가 유한하고 두 번째 인수가 무한하면 결과는 첫 번째 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="c79e66b15f81ddc9a951871c47a016d3318d1439" translate="yes" xml:space="preserve">
          <source>If the first argument is infinite, then an infinity of the same sign is returned.</source>
          <target state="translated">첫 번째 인수가 무한대이면 동일한 부호의 무한대가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7d4927f7484d5a09a609cfa4c9572e1d2c7f45" translate="yes" xml:space="preserve">
          <source>If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음수이고 두 번째 인수가 양수 0 또는 음수 0이거나 첫 번째 인수가 음의 무한대이고 두 번째 인수가 유한이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="c8e4a59b27a1fe3d520aae3637f149a7db9573ea" translate="yes" xml:space="preserve">
          <source>If the first argument is negative infinity and the second argument is positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음의 무한대이고 두 번째 인수가 양의 무한대이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="82b10d31a7012b44b539ae72f08e4e4c13a206b9" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음수이고 두 번째 인수가 음수이거나 첫 번째 인수가 음수이고 유한하며 두 번째 인수가 음수 무한대이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="8e475337333e7011c577f6dfd579b80f0f2ae245" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero.</source>
          <target state="translated">첫 번째 인수가 음수 0이고 두 번째 인수가 양수이거나 첫 번째 인수가 음수이고 유한하며 두 번째 인수가 양수 무한대이면 결과는 음의 0입니다.</target>
        </trans-unit>
        <trans-unit id="e71c64d3bcd633902a2d641246fcfc98d2800c74" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus character &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002D'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">첫 번째 인수가 음수이면 결과의 첫 번째 요소는 ASCII 빼기 문자 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002D'&lt;/code&gt; )입니다. 첫 번째 인수가 음수가 아닌 경우 결과에 부호 문자가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f757bab2a5b1e8678119d7c70a633d7f48cfbb1b" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus sign &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">첫 번째 인수가 음수이면 결과의 첫 번째 요소는 ASCII 빼기 기호 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002d'&lt;/code&gt; )입니다. 첫 번째 인수가 음수가 아닌 경우 결과에 부호 문자가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be73a6c34da2b109aed6beaf3902ff7b8fa1d76b" translate="yes" xml:space="preserve">
          <source>If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">첫 번째 인수가 양수이고 두 번째 인수가 양수 0 또는 음수 0이거나 첫 번째 인수가 양의 무한대이고 두 번째 인수가 유한이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="ebb6e09520d0766b54210b09e064a33ea2e4b570" translate="yes" xml:space="preserve">
          <source>If the first argument is positive infinity and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to 3*</source>
          <target state="translated">첫 번째 인수가 양의 무한대이고 두 번째 인수가 음의 무한대이면 결과는 3 *에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="a545d4a869ce0070ee3a2c5a7bd5c19feeb5e959" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">첫 번째 인수가 양수 0이고 두 번째 인수가 음수이거나 첫 번째 인수가 양수이고 유한하며 두 번째 인수가 음수 무한대이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="2b99cd366559b0aa882f76d5433c550ae23a29d2" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero.</source>
          <target state="translated">첫 번째 인수가 양수 0이고 두 번째 인수가 양수이거나 첫 번째 인수가 양수이고 유한하며 두 번째 인수가 양수 무한대이면 결과는 양수 0입니다.</target>
        </trans-unit>
        <trans-unit id="90dbabf1b114fed471b1a3cd65fc77c1740f1756" translate="yes" xml:space="preserve">
          <source>If the first argument is zero, then a zero of the same sign is returned.</source>
          <target state="translated">첫 번째 인수가 0이면 동일한 부호의 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a1663731875dc28dccca70ad4bb3ad9c2ee28bff" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;0xxxxxxx&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; means &quot;may be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;&quot;), then the group consists of just that byte. The byte is zero-extended to form a character.</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;0xxxxxxx&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; 는 &quot; &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 일 수 있음&quot;을 의미 함) 와 일치하면 그룹은 해당 바이트 로만 구성됩니다. 바이트는 0 확장되어 문자를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="43977f5f9b49b5f068ba277caf7c1c9b82cc82fa" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;110xxxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and a second byte &lt;code&gt;b&lt;/code&gt;. If there is no byte &lt;code&gt;b&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was the last of the bytes to be read), or if byte &lt;code&gt;b&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;110xxxxx&lt;/code&gt; 와 일치 하면 그룹은 해당 바이트 &lt;code&gt;a&lt;/code&gt; 와 두 번째 바이트 &lt;code&gt;b&lt;/code&gt; 로 구성 됩니다. 더 바이트가없는 경우 &lt;code&gt;b&lt;/code&gt; 를 (바이트 때문에 &lt;code&gt;a&lt;/code&gt; 읽을 수 바이트의 마지막), 또는 바이트의 경우 &lt;code&gt;b&lt;/code&gt; 는 비트 패턴과 일치하지 않는 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 , 다음 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생합니다. 그렇지 않으면 그룹이 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e5e1a187c24e47368e1814e48c4f2e5999e848" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;1110xxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and two more bytes &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. If there is no byte &lt;code&gt;c&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was one of the last two of the bytes to be read), or either byte &lt;code&gt;b&lt;/code&gt; or byte &lt;code&gt;c&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;1110xxxx&lt;/code&gt; 와 일치하면 그룹은 해당 바이트 &lt;code&gt;a&lt;/code&gt; 와 2 개 이상의 바이트 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 로 구성 됩니다. 아무 바이트 없으면 &lt;code&gt;c&lt;/code&gt; (바이트 때문에 &lt;code&gt;a&lt;/code&gt; 판독 될 바이트의 마지막 2 중 하나), 또는 두 바이트 &lt;code&gt;b&lt;/code&gt; 또는 바이트 &lt;code&gt;c&lt;/code&gt; 비트 패턴에 일치하지 않는 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 당시로서는, &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생합니다. 그렇지 않으면 그룹이 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b4205a0b70ecc18a1f7d17bb4cefe1ef7847e2c" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the pattern &lt;code&gt;1111xxxx&lt;/code&gt; or the pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown.</source>
          <target state="translated">그룹의 선두 바이트는 패턴과 일치하는 경우 &lt;code&gt;1111xxxx&lt;/code&gt; 또는 패턴 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 당시로서는, &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="de12fa584ec591ad89fe529ab99890cef05ff7df" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 첫 번째 문자 가 &lt;code&gt;'/'&lt;/code&gt; (절대 경로 이름을 나타냄) 인 경우이 기본 설정 노드의 잠금은 &lt;code&gt;path&lt;/code&gt; 를 토큰으로 나누기 전에 삭제 되며이 메서드는 루트에서 시작하는 경로를 반복적으로 탐색합니다 (이 노드에서 시작하지 않음). 그렇지 않으면 순회는 상대 경로 이름에 대해 설명 된 것과 동일합니다. &lt;a href=&quot;#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt; 따라 교착 상태의 가능성을 방지하려면 루트 노드에서 순회를 시작하기 전에이 노드에서 잠금을 삭제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fe4bd2bc924f289ce5e3e243830c506290c8bfa3" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;abstractpreferences#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 첫 번째 문자 가 &lt;code&gt;'/'&lt;/code&gt; (절대 경로 이름을 나타냄) 인 경우 &lt;code&gt;path&lt;/code&gt; 를 토큰으로 나누기 전에이 환경 설정 노드의 잠금이 삭제 되고이 메소드는 루트에서 시작하여 (이 노드에서 시작하지 않고) 경로를 재귀 적으로 탐색합니다. 통과는 상대 경로 이름에 대해 설명한 것과 동일합니다. 루트 노드에서 순회를 시작하기 전에이 노드에서 잠금을 삭제하는 것은 &lt;a href=&quot;abstractpreferences#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt; 따라 교착 상태의 가능성을 피하기 위해 필수적입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="de6a756f5a999d243dc3d549609d91cce131f2d6" translate="yes" xml:space="preserve">
          <source>If the first letter of the property defined by a getter is a capital, then this handler will look first for an item in the &lt;code&gt;CompositeData&lt;/code&gt; beginning with a capital, then, if that is not found, for an item beginning with the corresponding lowercase letter or code point. For a getter called &lt;code&gt;getNumber()&lt;/code&gt;, the handler will first look for an item called &lt;code&gt;Number&lt;/code&gt;, then for &lt;code&gt;number&lt;/code&gt;. If the getter is called &lt;code&gt;getnumber()&lt;/code&gt;, then the item must be called &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">getter에 의해 정의 된 속성의 첫 글자가 대문자 인 경우,이 핸들러는 먼저 &lt;code&gt;CompositeData&lt;/code&gt; 에서 대문자로 시작하는 항목을 찾은 다음 찾지 못하면 해당 소문자로 시작하는 항목 또는 코드 포인트. &lt;code&gt;getNumber()&lt;/code&gt; 라는 getter의 경우 핸들러는 먼저 &lt;code&gt;Number&lt;/code&gt; 라는 항목을 찾은 다음 &lt;code&gt;number&lt;/code&gt; 를 찾습니다 . getter가 &lt;code&gt;getnumber()&lt;/code&gt; 이면 항목을 &lt;code&gt;number&lt;/code&gt; 라고해야합니다. .</target>
        </trans-unit>
        <trans-unit id="c5b9fdddf990174b0c1bb31fd056338ffdb9f842" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C++-style comments are not treated specially.</source>
          <target state="translated">플래그 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 C ++ 스타일 주석은 특별히 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b755352a37aefb0ddd22fcf4ddac56889ee380f" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C-style comments are not treated specially.</source>
          <target state="translated">플래그 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 C 스타일 주석은 특별히 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed5b11ba23b450c90177463610accda7b5ef8311" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then the &lt;code&gt;sval&lt;/code&gt; field is not modified.</source>
          <target state="translated">flag 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우, &lt;code&gt;sval&lt;/code&gt; 필드는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a51b936e9c60259867a0c6a0a1415a7006e73bc6" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;false&lt;/code&gt;, delimiter characters serve to separate tokens. A token is a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">플래그가 &lt;code&gt;false&lt;/code&gt; 인 경우 구분 문자는 토큰을 분리하는 데 사용됩니다. 토큰은 분리 문자가 아닌 최대 연속 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="243de70bc00db3702139f3dd218555f6b229e223" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;true&lt;/code&gt;, delimiter characters are themselves considered to be tokens. A token is thus either one delimiter character, or a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">플래그가 &lt;code&gt;true&lt;/code&gt; 인 경우 구분 문자 자체는 토큰으로 간주됩니다. 따라서 토큰은 하나의 분리 문자이거나 분리 문자가 아닌 연속 된 최대 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="b5b0bc25b0d262fecfa18b60166faf5e2347e80f" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;true&lt;/code&gt;, this text component becomes user editable. If the flag is set to &lt;code&gt;false&lt;/code&gt;, the user cannot change the text of this text component. By default, non-editable text components have a background color of SystemColor.control. This default can be overridden by calling setBackground.</source>
          <target state="translated">플래그가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우이 텍스트 구성 요소는 사용자가 편집 할 수 있습니다. 플래그가 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 사용자는이 텍스트 구성 요소의 텍스트를 변경할 수 없습니다. 기본적으로 편집 할 수없는 텍스트 구성 요소의 배경색은 SystemColor.control입니다. 이 기본값은 setBackground를 호출하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57f350c5b50d157976b5f5f9a315e16106f5450" translate="yes" xml:space="preserve">
          <source>If the focused Window is a Frame or a Dialog it is also the active Window. Otherwise, the active Window is the first Frame or Dialog that is an owner of the focused Window.</source>
          <target state="translated">초점이 맞춰진 창이 프레임 또는 대화 상자이면 활성 창이기도합니다. 그렇지 않으면 활성 창은 포커스가있는 창의 소유자 인 첫 번째 프레임 또는 대화 상자입니다.</target>
        </trans-unit>
        <trans-unit id="56c6279667d7868f05ad4fddd3dde243109f6834" translate="yes" xml:space="preserve">
          <source>If the font is &lt;code&gt;null&lt;/code&gt; or a &lt;code&gt;UIResource&lt;/code&gt;, the defaults table is queried with the key &lt;code&gt;fontKey&lt;/code&gt;. All of &lt;code&gt;UIDefault's&lt;/code&gt; get methods throw a &lt;code&gt;
 NullPointerException&lt;/code&gt; if passed in &lt;code&gt;null&lt;/code&gt;. As such, unless otherwise noted each of the various install methods of &lt;code&gt;
 LookAndFeel&lt;/code&gt; throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the current value is &lt;code&gt;null&lt;/code&gt; or a &lt;code&gt;UIResource&lt;/code&gt; and the supplied defaults key is &lt;code&gt;null&lt;/code&gt;. In addition, unless otherwise specified all of the &lt;code&gt;install&lt;/code&gt; methods throw a &lt;code&gt;NullPointerException&lt;/code&gt; if a &lt;code&gt;null&lt;/code&gt; component is passed in.</source>
          <target state="translated">글꼴이 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;UIResource&lt;/code&gt; 인 경우 defaults 테이블은 &lt;code&gt;fontKey&lt;/code&gt; 키로 쿼리됩니다 . &lt;code&gt;UIDefault's&lt;/code&gt; 모든 get 메소드 는 &lt;code&gt;null&lt;/code&gt; 로 전달되면 &lt;code&gt; NullPointerException&lt;/code&gt; 을 발생 시킵니다. 따라서, 그렇지 않으면 여러 각각 언급하지 않는 방법 설치 &lt;code&gt; LookAndFeel&lt;/code&gt; 던져 &lt;code&gt;NullPointerException&lt;/code&gt; 이 전류 값 인 경우에는 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;UIResource&lt;/code&gt; 인터페이스 및 제공된 디폴트 키는 &lt;code&gt;null&lt;/code&gt; . 또한 별도로 지정하지 않는 한 모든 &lt;code&gt;install&lt;/code&gt; 메서드 는 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;NullPointerException&lt;/code&gt; 을 throw합니다. 구성 요소가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f77a5cbbfc5e7d2a5c0ad6a18e49115f1c49efaa" translate="yes" xml:space="preserve">
          <source>If the format of an argument loses information, such as with a choice format where a large number formats to &quot;many&quot;.</source>
          <target state="translated">인수 형식이 정보를 잃는 경우 (예 : 다수가 &quot;많은&quot;형식 인 선택 형식).</target>
        </trans-unit>
        <trans-unit id="0dcd3261c6e6bc40c628cfcd3ed02c38b9a8ba09" translate="yes" xml:space="preserve">
          <source>If the format specifier contains a width or precision with an invalid value or which is otherwise unsupported, then a &lt;a href=&quot;illegalformatwidthexception&quot;&gt;&lt;code&gt;IllegalFormatWidthException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; respectively will be thrown.</source>
          <target state="translated">형식 지정자가 유효하지 않은 값을 가진 너비 또는 정밀도를 포함하거나 지원되지 않는 경우 &lt;a href=&quot;illegalformatwidthexception&quot;&gt; &lt;code&gt;IllegalFormatWidthException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 각각 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="23d86bd64d57a83827a905eb3f62752e01b0a38e" translate="yes" xml:space="preserve">
          <source>If the formatter parses the same field more than once with different values, the result will be an error.</source>
          <target state="translated">포맷터가 다른 값으로 동일한 필드를 두 번 이상 구문 분석하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db3731fc2aa4a3e087228df78b6ed03888b9aa5c" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하면 매핑이 기록되지 않습니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 매핑이 기록되지 않습니다. 가장 일반적인 사용법은 다음과 같이 초기 매핑 값 또는 메모 결과로 제공되는 새 객체를 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="144af7e618eb46c9529d1d33c26d53810f2167da" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하는 경우 하면 매핑이 제거됩니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26f473bb6caf3da04b1285866c6a28b1b984ef5f" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 매핑이 제거됩니다 (또는 처음에없는 경우 부재 상태로 유지됨). 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91e50d7000baf56cbe84741a636dedc280c25287" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 매핑이 제거됩니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="926782c512e4f063b419e0421193c8c7a7433138" translate="yes" xml:space="preserve">
          <source>If the function succeeds, instrument &lt;code&gt;from&lt;/code&gt; is unloaded.</source>
          <target state="translated">기능이 성공하면 계측기 &lt;code&gt;from&lt;/code&gt; 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="253e6025d142f63cd0c731b35e5e54635921bd1e" translate="yes" xml:space="preserve">
          <source>If the function to map a module name to class loader throws an error or runtime exception then it is propagated to the caller of this method.</source>
          <target state="translated">모듈 이름을 클래스 로더에 매핑하는 함수가 오류 또는 런타임 예외를 throw하면이 메서드의 호출자에게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="32a91e07ee88bec0b9954a59c4de099b9aa8f328" translate="yes" xml:space="preserve">
          <source>If the garbage collector determines at a certain point in time that the referent of a phantom reference is &lt;a href=&quot;package-summary#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that time or at some later time it will enqueue the reference.</source>
          <target state="translated">가비지 콜렉터가 특정 시점에서 팬텀 참조의 참조가 &lt;a href=&quot;package-summary#reachability&quot;&gt;팬텀에 도달 할 수&lt;/a&gt; 있다고 판단하는 경우 해당 시간 또는 나중에 나중에 참조를 큐에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="53adf0e26e84566de9caa7cabb62afdabd38f865" translate="yes" xml:space="preserve">
          <source>If the gauge difference mode is used, the value of the derived gauge is calculated as the difference between the observed gauge values for two successive observations.</source>
          <target state="translated">게이지 차이 모드를 사용하는 경우 파생 게이지 값은 두 개의 연속 관측치에 대한 관측 게이지 값의 차이로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f36edc06d9e8ab3918e6499129015f8c141e7e54" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, an unchecked exception is thrown from &lt;code&gt;parallelSetAll&lt;/code&gt; and the array is left in an indeterminate state.</source>
          <target state="translated">생성기 함수에서 예외가 발생하면 &lt;code&gt;parallelSetAll&lt;/code&gt; 에서 검사되지 않은 예외가 발생 하고 배열이 미확인 상태로 남습니다.</target>
        </trans-unit>
        <trans-unit id="9d8173ed15e9b7709fd7094f05762f38b139637d" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</source>
          <target state="translated">생성기 함수에서 예외가 발생하면 호출자에게 릴레이되고 배열은 알 수없는 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="76782efd69d7292ec1741cf01ee5b2215277c044" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, This attribute will be set to &lt;a href=&quot;../../../../java.base/java/lang/thread#NORM_PRIORITY&quot;&gt;&lt;code&gt;Thread.NORM_PRIORITY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 에이 속성이 포함되지 않은 경우이 속성은 &lt;a href=&quot;../../../../java.base/java/lang/thread#NORM_PRIORITY&quot;&gt; &lt;code&gt;Thread.NORM_PRIORITY&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a37afbef057d6ba837b305b1cd9bad125d8e146" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, the &lt;code&gt;LockInfo&lt;/code&gt; object will be constructed from the value of the &lt;code&gt;lockName&lt;/code&gt; attribute.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 가이 속성을 포함하지 않는 경우, &lt;code&gt;LockInfo&lt;/code&gt; 오브젝트는 &lt;code&gt;lockName&lt;/code&gt; 속성 의 값에서 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e232e6d08b2921ecd51a0928548c7d20fb389fec" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, this attribute will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 에이 속성이 포함되지 않은 경우이 속성은 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1400b3eda5d304390a2540e7c1391b9930fe93a9" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, this attribute will be set to an empty array.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 에이 속성이 포함되지 않은 경우이 속성은 빈 배열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0db7828d6899e244beb39f64663230573a2ea5f3" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;ProtectionDomain&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a default protection domain will be assigned to the class as specified in the documentation for &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int)&lt;/code&gt;&lt;/a&gt;. Before the class can be used it must be resolved.</source>
          <target state="translated">지정된 &lt;code&gt;ProtectionDomain&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이면&lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int)&lt;/code&gt; &lt;/a&gt; 문서에 지정된대로 기본 보호 도메인이 클래스에 할당됩니다 . 클래스를 사용하려면 먼저 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f34fbb4cfa40d33b09699390aae3ac53e8ab2c4" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;instant&lt;/code&gt; represents a point on the time-line too far in the future or past to fit in a &lt;code&gt;long&lt;/code&gt; milliseconds and nanoseconds adjustment, then an &lt;code&gt;ArithmeticException&lt;/code&gt; will be thrown.</source>
          <target state="translated">주어진 &lt;code&gt;instant&lt;/code&gt; 이 &lt;code&gt;long&lt;/code&gt; 밀리 초 및 나노초 조정 에 맞기에는 너무 먼 미래 또는 과거의 타임 라인 지점을 나타내는 경우 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15c5a383f51c24f8825b786eaae7ec8e4fc3e1be" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;module&lt;/code&gt; is an unnamed module, then this method is equivalent to calling &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;getBundle(baseName, targetLocale, module.getClassLoader()&lt;/code&gt;&lt;/a&gt; to load resource bundles that are visible to the class loader of the given unnamed module. Custom &lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt;&lt;code&gt;ResourceBundleControlProvider&lt;/code&gt;&lt;/a&gt; implementations, if present, will only be invoked if the specified module is an unnamed module.</source>
          <target state="translated">지정된 &lt;code&gt;module&lt;/code&gt; 이 이름이 지정되지 않은 모듈 인 경우이 메서드는 &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;getBundle(baseName, targetLocale, module.getClassLoader()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 지정된 이름이 지정되지 않은 모듈의 클래스 로더에 표시되는 리소스 번들을로드 하는 것과 동일 합니다. 사용자 지정 &lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt; &lt;code&gt;ResourceBundleControlProvider&lt;/code&gt; &lt;/a&gt; 구현 (있는 경우) , 지정된 모듈이 이름이없는 모듈 인 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0e16e73e1c388c5bcfaf11ed9189d8791a0ccfd7" translate="yes" xml:space="preserve">
          <source>If the given &lt;var&gt;inModelMBeanInfo&lt;/var&gt; does not contain any &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;GENERIC&lt;/code&gt; or &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; notifications, then the RequiredModelMBean will supply its own default &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt;s for those missing notifications.</source>
          <target state="translated">주어진 &lt;var&gt;inModelMBeanInfo&lt;/var&gt; 에 &lt;code&gt;GENERIC&lt;/code&gt; 또는 &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; 알림에 대한 &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; &lt;/a&gt; 가 포함되어 있지 않은 경우 RequiredModelMBean은 자체 기본 &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; 를 제공합니다.&lt;/a&gt; 누락 된 알림에 대해 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf86ec019e6dc9802020d9a480bb2d423505a7f3" translate="yes" xml:space="preserve">
          <source>If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">주어진 Collection이 &lt;a href=&quot;#unmodifiable&quot;&gt;수정 불가능한 List 인&lt;/a&gt; 경우 copyOf를 호출하면 일반적으로 복사본이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f10d628399ffa67f965f7a348c67ac7f2b5b2030" translate="yes" xml:space="preserve">
          <source>If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable Set&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">주어진 Collection이 &lt;a href=&quot;#unmodifiable&quot;&gt;수정 불가능한 Set 인&lt;/a&gt; 경우 copyOf를 호출하면 일반적으로 복사본이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d42f41fcf7ca04751155bf461b15402f39209e6a" translate="yes" xml:space="preserve">
          <source>If the given Map is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable Map&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">지정된 Map이 &lt;a href=&quot;#unmodifiable&quot;&gt;수정할 수없는 Map 인&lt;/a&gt; 경우 copyOf를 호출하면 일반적으로 복사본이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="871cb4309703aec2bc0023c758d9cf428cebc74f" translate="yes" xml:space="preserve">
          <source>If the given URI has an authority component then the new URI's authority and path are taken from the given URI.</source>
          <target state="translated">제공된 URI에 권한 구성 요소가 있으면 새 URI의 권한 및 경로가 지정된 URI에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e06d94bd934ab4eadeb7ce0dca1e7e7222d58665" translate="yes" xml:space="preserve">
          <source>If the given URI is already absolute, or if this URI is opaque, then the given URI is returned.</source>
          <target state="translated">제공된 URI가 이미 절대적이거나이 URI가 불투명 한 경우 지정된 URI가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2430c525f00d8a5ecee224a7a5b81e9aae39e412" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">지정된 URI의 조각 구성 요소가 정의되고 해당 경로 구성 요소가 비어 있고 해당 구성표, 권한 및 쿼리 구성 요소가 정의되지 않은 경우 지정된 조각이 있지만 다른 모든 구성 요소가이 URI의 구성 요소와 동일한 URI가 반환됩니다. 이를 통해 &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt; 와 같은 독립형 조각 참조를 나타내는 URI를 기본 URI에 대해 유용하게 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="409ab55de149be7ee7466f039641cd5cdd79e97a" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">주어진 URI의 조각 구성 요소가 정의되고 경로 구성 요소가 비어 있고 스키마, 권한 및 쿼리 구성 요소가 정의되지 않은 경우 주어진 조각이 있지만 다른 모든 구성 요소가이 URI의 구성 요소와 동일한 URI가 반환됩니다. 이렇게하면 &lt;code&gt;&quot;#foo&quot;&lt;/code&gt; 와 같은 독립형 조각 참조를 나타내는 URI가 기본 URI에 대해 유용하게 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c849fb5cce341a58fea462c01a105441e0cc9602" translate="yes" xml:space="preserve">
          <source>If the given URI's path is absolute then the new URI's path is taken from the given URI.</source>
          <target state="translated">주어진 URI의 경로가 절대적이면 새로운 URI의 경로는 주어진 URI에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="14f7899ffb21b582de61406576d434576cfac581" translate="yes" xml:space="preserve">
          <source>If the given address includes a JNDI directory URL as specified in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;, then this &lt;code&gt;RMIConnectorServer&lt;/code&gt; will bootstrap by binding the &lt;code&gt;RMIServerImpl&lt;/code&gt; to the given address.</source>
          <target state="translated">지정된 주소에 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt; 패키지 문서에 지정된 JNDI 디렉토리 URL이 포함되어있는 경우, 이 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 는 &lt;code&gt;RMIServerImpl&lt;/code&gt; 을 지정된 주소 에 바인딩하여 부트 스트랩 합니다.</target>
        </trans-unit>
        <trans-unit id="ca814afbdb188e0d8eb604c68dacd59c7bf69539" translate="yes" xml:space="preserve">
          <source>If the given alias already exists, the keystore information associated with it is overridden by the given key (and possibly certificate chain).</source>
          <target state="translated">지정된 별명이 이미 존재하면, 해당 별명과 연관된 키 저장소 정보는 제공된 키 (및 인증서 체인)에 의해 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3a595a56aadbb88b4114693edc5c1ee01ec9f96d" translate="yes" xml:space="preserve">
          <source>If the given alias identifies an existing entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, the trusted certificate in the existing entry is overridden by the given certificate.</source>
          <target state="translated">지정된 별명 식별 기존를 호출 해 작성된 엔트리 경우 &lt;code&gt;setCertificateEntry&lt;/code&gt; 의 호출에 의해, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A를 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 를 기존 항목에서 신뢰할 수있는 인증서는 지정된 증명서에 의해 오버라이드 (override)됩니다.</target>
        </trans-unit>
        <trans-unit id="5db25da879a6c8a2469a9ffa221b439cce428d7c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, then the trusted certificate contained in that entry is returned.</source>
          <target state="translated">지정된 별명 이름을 식별하는를 호출 해 작성된 엔트리 경우 &lt;code&gt;setCertificateEntry&lt;/code&gt; 의 호출에 의해, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A를 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 를이 다음 신뢰할 수있는 인증서가 해당 항목에 포함 된 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d4d7d88c3b4df9575339dccffaf79058f1c8930" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry (if a chain exists) is returned.</source>
          <target state="translated">경우 지정된 별명 식별하는 호출에 의해 생성 된 입력 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 , 그 엔트리의 인증서 체인의 다음의 첫 번째 요소는 (a 체인이 존재하는 경우)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="c2ed3e7db9906e449ddb9d356b3252474de4e64c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry is returned.</source>
          <target state="translated">주어진 별명 식별하는 호출에 의해 생성 된 진입하면 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 , 그 항목의 인증서 체인의 첫 번째 요소가 반환된다.</target>
        </trans-unit>
        <trans-unit id="80577b628d04d07146a4c8598f72bfad40ed28b3" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;#implConfigureBlocking(boolean)&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">주어진 차단 모드가 현재 차단 모드와 다른 &lt;a href=&quot;#implConfigureBlocking(boolean)&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt; 메서드는 모드를 변경하기 위해 적절한 잠금을 유지하면서 implConfigureBlocking 메서드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a7044af5535fc0b80bc9e6eb2af416837a93528e" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">주어진 차단 모드가 현재 차단 모드와 다른 &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt; 메소드는 모드를 변경하기 위해 적절한 잠금을 유지하면서 implConfigureBlocking 메소드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="099ac9d14ce6f3a8c241c4173bc2f3c060d37fae" translate="yes" xml:space="preserve">
          <source>If the given index is outside the list's range of cells, this method results in nothing.</source>
          <target state="translated">주어진 인덱스가 목록의 셀 범위를 벗어나면이 메서드는 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef47fccc5a72a56e061d58ffbc98135bb15f0e3b" translate="yes" xml:space="preserve">
          <source>If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">제공된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd6f94d655e9cba018e02791b4d2bafeaf0cd16b" translate="yes" xml:space="preserve">
          <source>If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only the base bundle as the resulting resource bundle.</source>
          <target state="translated">지정된 로케일이 동일한 경우 &lt;code&gt;Locale.ROOT&lt;/code&gt; (루트 로케일)하는 &lt;code&gt;List&lt;/code&gt; 만을 루트 포함 된 &lt;code&gt;Locale&lt;/code&gt; 반환해야합니다. 이 경우 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 팩토리 메소드는 기본 번들 만 결과 자원 번들로로드합니다.</target>
        </trans-unit>
        <trans-unit id="d78ff521c3166afea2224a7e827c542012a19f6e" translate="yes" xml:space="preserve">
          <source>If the given location is either a module oriented location, or an output location containing multiple modules, and no explicit modules prefix is given, a suitable module is inferred. If a suitable module cannot be inferred &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference.</source>
          <target state="translated">주어진 위치가 모듈 지향 위치이거나 여러 모듈을 포함하는 출력 위치이고 명시적인 모듈 접두사가 제공되지 않으면 적절한 모듈이 유추됩니다. 적합한 모듈을 유추 할 수없는 경우 &lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 구현은 추론의 일부로 주석 처리 도구의 구성에 대한 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd86b458fa6c5cb798c0359d6978ebb6799d62aa" translate="yes" xml:space="preserve">
          <source>If the given location is neither a &lt;a href=&quot;../../tools/javafilemanager.location#isModuleOrientedLocation()&quot;&gt;module oriented location&lt;/a&gt;, nor an &lt;a href=&quot;../../tools/javafilemanager.location#isOutputLocation()&quot;&gt;output location containing multiple modules&lt;/a&gt;, and the explicit module prefix is given, &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">지정된 위치가 &lt;a href=&quot;../../tools/javafilemanager.location#isModuleOrientedLocation()&quot;&gt;모듈 지향 위치&lt;/a&gt; 도 아니고 &lt;a href=&quot;../../tools/javafilemanager.location#isOutputLocation()&quot;&gt;여러 모듈을 포함&lt;/a&gt; 하는 출력 위치 도 아니고 명시 적 모듈 접두사가 제공되면 &lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a722054d6a8a85985b6af9a7f074ff6c9d6c5114" translate="yes" xml:space="preserve">
          <source>If the given method to be invoked, together with the provided signature, matches one of RequiredModelMbean accessible methods, this one will be call. Otherwise the call to the given method will be tried on the managed resource.</source>
          <target state="translated">제공된 서명과 함께 제공된 메소드가 RequiredModelMbean 액세스 가능 메소드 중 하나와 일치하면이 메소드가 호출됩니다. 그렇지 않으면 지정된 메소드에 대한 호출이 관리 자원에서 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="5903b5c68713e17c01106dc0242d392ba3fd13a3" translate="yes" xml:space="preserve">
          <source>If the given modality type is not supported, &lt;code&gt;MODELESS&lt;/code&gt; is used. You may want to call &lt;code&gt;getModalityType()&lt;/code&gt; after calling this method to ensure that the modality type has been set.</source>
          <target state="translated">주어진 모달 유형이 지원되지 않으면 &lt;code&gt;MODELESS&lt;/code&gt; 가 사용됩니다. 당신은 전화를 할 수 있습니다 &lt;code&gt;getModalityType()&lt;/code&gt; 모달 형식이 설정되어 있는지 확인하기 위해이 방법을 호출 한 후.</target>
        </trans-unit>
        <trans-unit id="7cf0a900811cd6f2b34fd3e614d21d91355d860b" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;ModuleDescriptor&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module descriptors are equal if each of their corresponding components is equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;ModuleDescriptor&lt;/code&gt; 가 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 각 해당 구성 요소가 같으면 두 모듈 설명자가 같습니다.</target>
        </trans-unit>
        <trans-unit id="265ee67148fb3d461cae1321c492c06ad8be4305" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Provides&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;Provides&lt;/code&gt; objects are equal if the service type is equal and the list of providers is equal.</source>
          <target state="translated">제공된 객체가 &lt;code&gt;Provides&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 서비스 유형이 같고 공급자 목록이 같으면 두 개의 &lt;code&gt;Provides&lt;/code&gt; 개체가 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9dc4b5ba6652e7ccce8cb26463d690c4e101f15" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Requires&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module dependence objects are equal if the module names are equal, set of modifiers are equal, and the compiled version of both modules is equal or not recorded for both modules.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Requires&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 모듈 이름이 같고 수정 자 집합이 같고 두 모듈의 컴파일 된 버전이 두 모듈에 대해 같거나 기록되지 않은 경우 두 모듈 종속성 개체는 같습니다.</target>
        </trans-unit>
        <trans-unit id="087eec123268666bb5ff587f9f3824a68696a44d" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;ResolvedModule&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;ResolvedModule&lt;/code&gt; objects are equal if they are in the same configuration and have equal references to the module content.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;ResolvedModule&lt;/code&gt; 이 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 &lt;code&gt;ResolvedModule&lt;/code&gt; 개체가 동일한 구성에 있고 모듈 콘텐츠에 대한 동일한 참조가 있으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cfd682a1d142327e25c86e6fd36c7f41a2a41ad9" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Version&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module version are equal if their corresponding components are equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Version&lt;/code&gt; 이 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 해당 구성 요소가 같으면 두 모듈 버전이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a79eac791e4b86cfc10aabf01a42570af6907767" translate="yes" xml:space="preserve">
          <source>If the given object is not a Path, or is a Path associated with a different &lt;code&gt;FileSystem&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 Path가 아니거나 다른 &lt;code&gt;FileSystem&lt;/code&gt; 에 관련한 Path 인 경우 ,이 메소드는 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="ab44b435bce5e6d0dd0d4400904c04dd1b50093c" translate="yes" xml:space="preserve">
          <source>If the given object is not a URI then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 URI가 아닌 경우,이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="dab849a2dfb627f012f49b202b71d39af39c2224" translate="yes" xml:space="preserve">
          <source>If the given object is not a URL then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 URL이 아닌 경우,이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="01a564c21ef594219aeafdbf8732e9a0030e72be" translate="yes" xml:space="preserve">
          <source>If the given object is not a VirtualMachine then this method returns &lt;code&gt;false&lt;/code&gt;. For two VirtualMachines to be considered equal requires that they both reference the same provider, and their &lt;a href=&quot;virtualmachinedescriptor#id()&quot;&gt;&lt;code&gt;identifiers&lt;/code&gt;&lt;/a&gt; are equal.</source>
          <target state="translated">주어진 객체가 VirtualMachine이 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 VirtualMachine이 동일한 것으로 간주 되려면 둘 다 동일한 공급자를 참조하고 &lt;a href=&quot;virtualmachinedescriptor#id()&quot;&gt; &lt;code&gt;identifiers&lt;/code&gt; &lt;/a&gt; 가 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b305239f4bf84e68ec183969e76e319dbf5445c9" translate="yes" xml:space="preserve">
          <source>If the given object is not a VirtualMachineDescriptor then this method returns &lt;code&gt;false&lt;/code&gt;. For two VirtualMachineDescriptors to be considered equal requires that they both reference the same provider, and their &lt;a href=&quot;#id()&quot;&gt;&lt;code&gt;identifiers&lt;/code&gt;&lt;/a&gt; are equal.</source>
          <target state="translated">주어진 객체가 VirtualMachineDescriptor가 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 VirtualMachineDescriptor가 동일한 것으로 간주 되려면 둘 다 동일한 공급자를 참조하고 해당 &lt;a href=&quot;#id()&quot;&gt; &lt;code&gt;identifiers&lt;/code&gt; &lt;/a&gt; 가 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="51317f50e868ccac84e6251d8aade86da12219ac" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;AclEntry&lt;/code&gt; then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 &lt;code&gt;AclEntry&lt;/code&gt; 가 아닌 경우, 이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="deee112803ae8aa28ebe1e7b06cce4d2e7efea17" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;Exports&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module exports objects are equal if their set of modifiers is equal, the package names are equal and the set of target module names is equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Exports&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 모듈 내보내기 객체는 수정 자 집합이 같고 패키지 이름이 같고 대상 모듈 이름 집합이 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ff01ba4aa3f9066a3a4d258504eb98e093cb3dd4" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;HttpHeaders&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two HTTP headers are equal if each of their corresponding &lt;a href=&quot;#map()&quot;&gt;maps&lt;/a&gt; are equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;HttpHeaders&lt;/code&gt; 가 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 각각의 해당 &lt;a href=&quot;#map()&quot;&gt;맵&lt;/a&gt; 이 동일 하면 두 개의 HTTP 헤더가 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2dc78364f9dc2b13b28a620cc038ded7d1559bd8" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;HttpRequest&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two HTTP requests are equal if their URI, method, and headers fields are all equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;HttpRequest&lt;/code&gt; 가 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 HTTP 요청은 URI, 메소드 및 헤더 필드가 모두 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a08bc86883e9dc33f9a3477bb9b5d3ab9ca49cb6" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;Opens&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;Opens&lt;/code&gt; objects are equal if their set of modifiers is equal, the package names are equal and the set of target module names is equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Opens&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 개의 &lt;code&gt;Opens&lt;/code&gt; 오브젝트는 수정 자 세트가 같고 패키지 이름이 같고 대상 모듈 이름 세트가 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5067d1933a7fb6de041c489427ed9f038cbf2e5d" translate="yes" xml:space="preserve">
          <source>If the given path has &lt;em&gt;N&lt;/em&gt; elements, and no root component, and this path has &lt;em&gt;N&lt;/em&gt; or more elements, then this path ends with the given path if the last &lt;em&gt;N&lt;/em&gt; elements of each path, starting at the element farthest from the root, are equal.</source>
          <target state="translated">주어진 경로에 &lt;em&gt;N 개의&lt;/em&gt; 요소가 있고 루트 구성 요소가 &lt;em&gt;없고이&lt;/em&gt; 경로에 &lt;em&gt;N&lt;/em&gt; 개 이상의 요소가있는 경우 루트에서 가장 먼 요소에서 시작하여 각 경로 의 마지막 &lt;em&gt;N 개&lt;/em&gt; 요소가 동일한 경우이 경로는 제공된 경로로 끝납니다. .</target>
        </trans-unit>
        <trans-unit id="fe7eaf75c5ca09e9dc37afa7038d8c228c398461" translate="yes" xml:space="preserve">
          <source>If the given path has a root component then this path ends with the given path if the root component of this path &lt;em&gt;ends with&lt;/em&gt; the root component of the given path, and the corresponding elements of both paths are equal. Whether or not the root component of this path ends with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not end with the given path.</source>
          <target state="translated">지정된 경로에 루트 구성 요소가있는 경우이 경로의 루트 구성 요소가 지정된 경로의 루트 구성 요소로 &lt;em&gt;끝나고&lt;/em&gt; 두 경로의 해당 요소가 동일한 경우이 경로 &lt;em&gt;는&lt;/em&gt; 지정된 경로 로 &lt;em&gt;끝납니다&lt;/em&gt; . 이 경로의 루트 구성 요소가 주어진 경로의 루트 구성 요소로 끝나는 지 여부는 파일 시스템에 따라 다릅니다. 이 경로에 루트 구성 요소가없고 지정된 경로에 루트 구성 요소가 있으면이 경로는 지정된 경로로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fdc1f0bd8bdd66110dc3f031d4817dcf3caed63" translate="yes" xml:space="preserve">
          <source>If the given path is associated with a different &lt;code&gt;FileSystem&lt;/code&gt; to this path then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">주어진 경로 가이 경로 와 다른 &lt;code&gt;FileSystem&lt;/code&gt; 과 연관되어 있으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4b2bf60e5452de4ddf9870cafed442c49431cf97" translate="yes" xml:space="preserve">
          <source>If the given provider is installed at the requested position, the provider that used to be at that position, and all providers with a position greater than &lt;code&gt;position&lt;/code&gt;, are shifted up one position (towards the end of the list of installed providers).</source>
          <target state="translated">지정된 프로 바이더가 요구 된 위치에 설치되어있는 경우, 그 위치에 있던 프로 바이더와보다 위치보다 모든 업체 &lt;code&gt;position&lt;/code&gt; , (인스톨되고있는 프로 바이더의리스트의 끝으로) 한 위치를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="0348730345bae0d2545ea8b21da48cf025a26fbe" translate="yes" xml:space="preserve">
          <source>If the given row number is negative, the cursor moves to an absolute row position with respect to the end of the result set. For example, calling the method &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row; calling the method &lt;code&gt;absolute(-2)&lt;/code&gt; moves the cursor to the next-to-last row, and so on.</source>
          <target state="translated">주어진 행 번호가 음수이면 커서는 결과 세트의 끝을 기준으로 절대 행 위치로 이동합니다. 예를 들어 &lt;code&gt;absolute(-1)&lt;/code&gt; 메서드를 호출 하면 커서가 마지막 행에 배치됩니다. &lt;code&gt;absolute(-2)&lt;/code&gt; 메서드를 호출하면 커서가 마지막 행으로 이동하는 식입니다.</target>
        </trans-unit>
        <trans-unit id="ebbca2e71ca391fdcf53f907a578f53411598fa7" translate="yes" xml:space="preserve">
          <source>If the given runnable attempts to make any mutations in this implementation, a deadlock will occur. There is no tracking of individual rendering threads to enable detecting this situation, but a subclass could incur the overhead of tracking them and throwing an error.</source>
          <target state="translated">주어진 runnable이이 구현에서 변형을 시도하면 교착 상태가 발생합니다. 이 상황을 감지 할 수 있도록 개별 렌더링 스레드를 추적하지는 않지만 하위 클래스는이를 추적하고 오류를 발생시키는 오버 헤드를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be7b3561a355e78f18cdeae419abf0ee5e2ea933" translate="yes" xml:space="preserve">
          <source>If the given size is less than the current size then the entity is truncated, discarding any bytes beyond the new end. If the given size is greater than or equal to the current size then the entity is not modified. In either case, if the current position is greater than the given size then it is set to that size.</source>
          <target state="translated">주어진 크기가 현재 크기보다 작 으면 엔터티가 잘리고 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 현재 크기보다 크거나 같으면 엔티티가 수정되지 않습니다. 두 경우 모두 현재 위치가 지정된 크기보다 큰 경우 해당 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aaefbc3d9c612129c52e3733260c322198b61ac6" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified.</source>
          <target state="translated">지정된 크기가 파일의 현재 크기보다 작 으면 파일이 잘리고 파일의 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 파일의 현재 크기보다 크거나 같으면 파일이 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87ded65bf156680a79571d8a9d909a68f908630c" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified. In either case, if this channel's file position is greater than the given size then it is set to that size.</source>
          <target state="translated">주어진 크기가 파일의 현재 크기보다 작 으면 파일이 잘리고 파일의 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 파일의 현재 크기보다 크거나 같으면 파일이 수정되지 않습니다. 두 경우 모두이 채널의 파일 위치가 지정된 크기보다 큰 경우 해당 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7dd1419e3ad877e5832a2e55c7efd5daa5e8f3e6" translate="yes" xml:space="preserve">
          <source>If the given type is not supported, &lt;code&gt;NO_EXCLUDE&lt;/code&gt; is used.</source>
          <target state="translated">지정된 유형이 지원되지 않으면 &lt;code&gt;NO_EXCLUDE&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee541dacfad38286ca16f7b64502c1de0394dbf6" translate="yes" xml:space="preserve">
          <source>If the gradient and graphics rendering transforms are uniformly scaled and the user sets the focus so that it coincides with the center of the circle, the gradient color proportions are equal for any line drawn from the center. The following figure shows the distances AB, BC, AD, and DE. They are all equal.</source>
          <target state="translated">그라디언트 및 그래픽 렌더링 변환이 균일하게 조정되고 사용자가 초점을 원의 중심과 일치하도록 설정하면 중심에서 그린 모든 선에 대해 그라디언트 색상 비율이 동일합니다. 다음 그림은 거리 AB, BC, AD 및 DE를 보여줍니다. 그들은 모두 동등합니다.</target>
        </trans-unit>
        <trans-unit id="0dd273a96dc30568917e48986c0b9215f521962c" translate="yes" xml:space="preserve">
          <source>If the gradient is acyclic then points on the P1 side of the segment have the constant &lt;code&gt;Color&lt;/code&gt; C1 while points on the P2 side have the constant &lt;code&gt;Color&lt;/code&gt; C2.</source>
          <target state="translated">그래디언트가 비순환이면 세그먼트의 P1 측에있는 점 은 일정한 &lt;code&gt;Color&lt;/code&gt; C1을 가지며 P2 측에있는 점은 일정한 &lt;code&gt;Color&lt;/code&gt; C2를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="896c9bfd563344965e7bce74bae30d109938cbeb" translate="yes" xml:space="preserve">
          <source>If the gradient is cyclic then the points on the extended P1, P2 connecting line cycle back and forth between the colors C1 and C2.</source>
          <target state="translated">그래디언트가 순환 적이면 확장 된 P1, P2 연결 선의 점이 색상 C1과 C2 사이를 앞뒤로 순환합니다.</target>
        </trans-unit>
        <trans-unit id="677a4e88376df9d9470bda35c5236fc7e5c9051a" translate="yes" xml:space="preserve">
          <source>If the group class name specified in the &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method will behave as if the group descriptor contained the name of the default activation group implementation class.</source>
          <target state="translated">&lt;code&gt;ActivationGroupDesc&lt;/code&gt; 에 지정된 그룹 클래스 이름 이 &lt;code&gt;null&lt;/code&gt; 이면이 메소드는 그룹 디스크립터에 기본 활성 그룹 구현 클래스의 이름이 포함 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f0b0bf2a45ec36e583f47ca33513286c575ec604" translate="yes" xml:space="preserve">
          <source>If the handler is not null and there is a security manager, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; permission. This may result in a SecurityException. No validation of the inputs is performed by this constructor.</source>
          <target state="translated">핸들러가 널이 아니고 보안 관리자가있는 &lt;code&gt;checkPermission&lt;/code&gt; , 보안 관리자의 checkPermission 메소드는 &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 SecurityException이 발생할 수 있습니다. 이 생성자는 입력의 유효성 검증을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd5ef3ee310fe9a2a0784c9212a810e58ed3a94b" translate="yes" xml:space="preserve">
          <source>If the history buffer is then rolled back (i.e. the last UndoableEdit undone), a DocumentEvent is sent to both views, causing both of them to reflect the undone mutation to the document (that is, the removal of the right component's mutation). If the history buffer again rolls back another change, another DocumentEvent is sent to both views, causing them to reflect the undone mutation to the document -- that is, the removal of the left component's mutation.</source>
          <target state="translated">그런 다음 히스토리 버퍼가 롤백되면 (즉, 마지막 UndoableEdit 실행 취소) DocumentEvent가 두보기 모두에 전송되어 두보기 모두 문서에 실행 취소 된 변형 (즉, 오른쪽 구성 요소의 변형 제거)이 반영됩니다. 히스토리 버퍼가 다른 변경 사항을 다시 롤백하면 다른 DocumentEvent가 두 뷰 모두에 전송되어 문서에 대한 실행 취소 된 변형, 즉 왼쪽 구성 요소의 변형이 제거 된 것을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="a7b208411b1f838553bd26f17a98bd6ecf12f387" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length()&lt;/code&gt; is equal to zero, then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">호스트가 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;host.length()&lt;/code&gt; 가 0이면 루프백 인터페이스의 주소를 나타내는 &lt;code&gt;InetAddress&lt;/code&gt; 가 반환됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; 섹션 2 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; 섹션 2.5.3을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17f223f38d5244a08362b498762d26000fb8d528" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length()&lt;/code&gt; is equal to zero, then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;https://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;https://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">호스트가 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;host.length()&lt;/code&gt; 가 0이면 루프백 인터페이스의 주소를 나타내는 &lt;code&gt;InetAddress&lt;/code&gt; 가 반환됩니다. &lt;a href=&quot;https://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; 섹션 2 및 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; 섹션 2.5.3을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82294cea404b457d7895b5f7849b8f8cdabef00b" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">호스트 인 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt;InetAddress&lt;/code&gt; 루프백 인터페이스의 주소를 나타내는가 반환됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; 섹션 2 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; 섹션 2.5.3을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13f82f51386e3d3d93037591572aea8cb88f6868" translate="yes" xml:space="preserve">
          <source>If the icon doesn't load, the border area is painted gray.</source>
          <target state="translated">아이콘이로드되지 않으면 테두리 영역이 회색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c743eca5b6b4b9d617040308e1ee27a4b7c6393" translate="yes" xml:space="preserve">
          <source>If the identity is marked as &quot;trusted&quot;, this allows an attacker to introduce a different public key (e.g., its own) that is not trusted by the system's identity scope, thereby granting applet or application code signed with that public key privileges that would have been denied otherwise.</source>
          <target state="translated">ID가 &quot;신뢰 됨&quot;으로 표시되면 공격자는 시스템의 ID 범위에서 신뢰하지 않는 다른 공개 키 (예 : 자체)를 도입하여 해당 공개 키 권한으로 서명 된 애플릿 또는 응용 프로그램 코드를 부여 할 수 있습니다. 그렇지 않으면 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="75b8821b16ad8c4bce7f71ae9f2499e34e968953" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default height.</source>
          <target state="translated">이미지를 사용자 지정 크기로 렌더링 할 수 있으면이 메서드는 기본 높이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4a58cc703a9db33b11b3faf9dca4d8e83b20a1f" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default width.</source>
          <target state="translated">이미지를 사용자 지정 크기로 렌더링 할 수 있으면이 메서드는 기본 너비를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="38702f2cc1d6bfec3cbebca538696adacba267f7" translate="yes" xml:space="preserve">
          <source>If the image has completely loaded and its pixels are no longer being changed, then &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and as more of the image becomes available or it is time to draw another frame of animation, the process that loads the image notifies the specified image observer.</source>
          <target state="translated">이미지가 완전히로드되고 픽셀이 더 이상 변경되지 않으면 &lt;code&gt;drawImage&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;drawImage&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 더 많은 이미지를 사용할 수있게되거나 다른 애니메이션 프레임을 그릴 때가되면 이미지를로드하는 프로세스가 지정된 이미지 관찰자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="a0b05514b8f5d731608326b087f332a040bf4271" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values.</source>
          <target state="translated">이미지를 임의의 크기로 렌더링 할 수있는 경우 소스 너비와 높이를 제공된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1e4e52ec311e9e75dd4cc081567f1eae9e6bf20f" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values. Note that the values returned from the &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; methods on &lt;code&gt;ImageReader&lt;/code&gt; are not affected by this method; they will continue to return the default size for the image. Similarly, if the image is also tiled the tile width and height are given in terms of the default size.</source>
          <target state="translated">이미지를 임의의 크기로 렌더링 할 수 있으면 소스 너비와 높이를 제공된 값으로 설정하십시오. &lt;code&gt;ImageReader&lt;/code&gt; 의 &lt;code&gt;getWidth&lt;/code&gt; 및 &lt;code&gt;getHeight&lt;/code&gt; 메소드에서 리턴 된 값 은이 메소드의 영향을받지 않습니다. 이미지의 기본 크기를 계속 반환합니다. 마찬가지로 이미지가 타일링 된 경우 타일 너비와 높이는 기본 크기와 관련하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3b13126a7b6fc1071a110411ef949559c81f856f" translate="yes" xml:space="preserve">
          <source>If the image represents an animated image, it will be animated automatically.</source>
          <target state="translated">이미지가 애니메이션 이미지를 나타내는 경우 자동으로 애니메이션됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a7ef1905b7717e6534c8262beb9af466dbbe75" translate="yes" xml:space="preserve">
          <source>If the image type is TYPE_BYTE_BINARY, the number of entries in the color model is used to determine whether the image should have 1, 2, or 4 bits per pixel. If the color model has 1 or 2 entries, the image will have 1 bit per pixel. If it has 3 or 4 entries, the image with have 2 bits per pixel. If it has between 5 and 16 entries, the image will have 4 bits per pixel. Otherwise, an IllegalArgumentException will be thrown.</source>
          <target state="translated">이미지 유형이 TYPE_BYTE_BINARY 인 경우 색상 모델의 항목 수를 사용하여 이미지에 픽셀 당 1, 2 또는 4 비트가 있어야하는지 여부를 결정합니다. 색상 모델에 1 개 또는 2 개의 항목이있는 경우 이미지에는 픽셀 당 1 비트가 있습니다. 항목이 3 개 또는 4 개인 경우 이미지는 픽셀 당 2 비트입니다. 항목이 5 개에서 16 개 사이 인 경우 이미지는 픽셀 당 4 비트를 갖습니다. 그렇지 않으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d7ce886e7cf517b9dd1b8e4bf3972fb87acfaf11" translate="yes" xml:space="preserve">
          <source>If the implementation can supply a value for one of the queries listed in the if statement of the default implementation, then it must do so. For example, an application-defined &lt;code&gt;HourMin&lt;/code&gt; class storing the hour and minute must override this method as follows:</source>
          <target state="translated">구현이 기본 구현의 if 문에 나열된 쿼리 중 하나에 대한 값을 제공 할 수 있으면 그렇게해야합니다. 예를 들어, 시간과 분을 저장 하는 응용 프로그램 정의 &lt;code&gt;HourMin&lt;/code&gt; 클래스는 다음과 같이이 메서드를 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">구현이 요청 된 유형의 객체 또는 작업을 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="8ab19508e52ba992a5a553d39a65472031820996" translate="yes" xml:space="preserve">
          <source>If the implementation of this class does not support persistence, an &lt;a href=&quot;../mbeanexception&quot;&gt;&lt;code&gt;MBeanException&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;../servicenotfoundexception&quot;&gt;&lt;code&gt;ServiceNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 클래스의 구현이 지속성을 지원하지 않는 경우 &lt;a href=&quot;../mbeanexception&quot;&gt; &lt;code&gt;MBeanException&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../servicenotfoundexception&quot;&gt; &lt;code&gt;ServiceNotFoundException&lt;/code&gt; 를&lt;/a&gt; 랩핑 MBeanException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="05e9c8575bf962e5c616ffc00d01915b9381d7c7" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시키면 MBean 서버는 각각 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부에서이를 다시 발생 시킵니다. 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외가 발생 하더라도 MBean의 상태는 변경되지 않습니다. MBean은 이미 성공적으로 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b030ce654ec4888a547056d4d3abf6da997ebc0c" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시키면 MBean 서버는 각각 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부에서이를 다시 발생 시킵니다. 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외를 던지면 MBean의 상태가 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="61497ea0a67eb203673d203a0f2b5369b019bf33" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 &lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;각각 RuntimeErrorException. 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외를 던져도MBean의 상태가 변경되지는 않습니다. MBean이 이미 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b96b5c5ec491812d30a354e2cb6f11721b2e2b1d" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 각각 &lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부의 것을 Throw합니다 . 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외가 발생합니다. MBean의 상태는 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4535342913d52819782cb269ae901b36379460f0" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 각각 . 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외를 던져도 MBean의 상태가 변경되지는 않습니다. MBean이 이미 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="76763841aca1fa1b12ea5b878cc85e9f7cde9edb" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 각각 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부의 것을 Throw합니다 . 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외를 던져도 MBean의 상태는 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1a75de9cc725b96c1261a9ca528b8f0bb1b31691" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the &lt;code&gt;PROCESSING&lt;/code&gt; or &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the &lt;code&gt;PROCESSING&lt;/code&gt; or &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the &lt;code&gt;CANCELED&lt;/code&gt; or &lt;code&gt;ABORTED&lt;/code&gt; job states.</source>
          <target state="translated">구현시 &lt;code&gt;PROCESSING&lt;/code&gt; 또는 &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; 작업 상태 에서 작업을 취소하는 데 측정 가능한 시간이 필요한 경우 프린터는이 이유를 사용하여 작업이 &lt;code&gt;PROCESSING&lt;/code&gt; 또는 &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; 상태 에있는 동안 프린터가 여전히 작업에 대해 일부 작업을 수행하고 있음을 나타내야합니다 . 모든 작업의 ​​작업 설명 속성이 증가를 중지하면 프린터는 작업을 PROCESSING 상태에서 &lt;code&gt;CANCELED&lt;/code&gt; 또는 &lt;code&gt;ABORTED&lt;/code&gt; 작업 상태로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e5a527012aa1181404e26ff9eba79c5215c6617c" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the PROCESSING or PROCESSING_STOPPED job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the PROCESSING or PROCESSING_STOPPED state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the CANCELED or ABORTED job states.</source>
          <target state="translated">구현이 PROCESSING 또는 PROCESSING_STOPPED 작업 상태에서 작업을 취소하는 데 측정 가능한 시간이 필요한 경우, 프린터는이 이유를 사용하여 작업이 PROCESSING 또는 PROCESSING_STOPPED 상태에있는 동안 프린터가 여전히 작업에 대해 일부 조치를 수행하고 있음을 표시해야합니다. 모든 작업의 ​​작업 설명 속성 증가가 중지 된 후 프린터는 작업을 처리 중 상태에서 취소 또는 중단 된 작업 상태로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="21a96789298a278046ce067991e2d31d04c7cbd4" translate="yes" xml:space="preserve">
          <source>If the implementation supports</source>
          <target state="translated">구현이 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="9c61e0dd2f97968224ba5bded184eb2a44d95c79" translate="yes" xml:space="preserve">
          <source>If the implementation supports a history mechanism, a reference to an Edit implementation will be returned, otherwise null.</source>
          <target state="translated">구현이 히스토리 메커니즘을 지원하는 경우 편집 구현에 대한 참조가 반환되고 그렇지 않으면 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="35f873dd7c2035b38202cda19f7fef9dd8dbdb3b" translate="yes" xml:space="preserve">
          <source>If the implementing method determines that no transformations are needed, it should return &lt;code&gt;null&lt;/code&gt;. Otherwise, it should create a new &lt;code&gt;byte[]&lt;/code&gt; array, copy the input &lt;code&gt;classfileBuffer&lt;/code&gt; into it, along with all desired transformations, and return the new array. The input &lt;code&gt;classfileBuffer&lt;/code&gt; must not be modified.</source>
          <target state="translated">구현 방법이 변환이 필요하지 않다고 판단하면 &lt;code&gt;null&lt;/code&gt; 을 반환해야합니다 . 그렇지 않으면, 새로운 &lt;code&gt;byte[]&lt;/code&gt; 배열을 생성하고 , 원하는 모든 변환과 함께 입력 &lt;code&gt;classfileBuffer&lt;/code&gt; 를 복사 하고 새로운 배열을 반환해야합니다. 입력 &lt;code&gt;classfileBuffer&lt;/code&gt; 를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="81ca206f6782401fcc1f26d127affa8acd0e136d" translate="yes" xml:space="preserve">
          <source>If the implementing object is an instance of java.beans.beancontext.BeanContext, or a subinterface thereof, then that BeanContext should fire a PropertyChangeEvent, to its registered BeanContextMembershipListeners, with parameters:</source>
          <target state="translated">구현 객체가 java.beans.beancontext.BeanContext의 인스턴스 또는 그 하위 인터페이스 인 경우 해당 BeanContext는 매개 변수를 사용하여 등록 된 BeanContextMembershipListeners에 PropertyChangeEvent를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="36b6757dd0b7b9698143f2e5d681dfa198ff7d6d" translate="yes" xml:space="preserve">
          <source>If the incoming object does not implement any additional interfaces known to the writer, the writer has no choice but to access it via the standard &lt;code&gt;IIOMetadata&lt;/code&gt; interfaces such as the tree view provided by &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt;. In this case, there is likely to be significant loss of information.</source>
          <target state="translated">수신 객체가 작가로 알려진 추가 인터페이스를 구현하지 않는 경우, 작가는 선택의 여지가 있지만, 표준 통한 액세스를로 &lt;code&gt;IIOMetadata&lt;/code&gt; 에서 제공하는 트리보기와 같은 인터페이스 &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt; . 이 경우 정보가 크게 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e436d84bd4232b4579b6124cd808ff4918e211d5" translate="yes" xml:space="preserve">
          <source>If the inherited channel is a datagram-oriented socket then a &lt;a href=&quot;../datagramchannel&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt; is returned. The datagram channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">상속 된 채널이 데이터 그램 지향 소켓이면 &lt;a href=&quot;../datagramchannel&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 데이터 그램 채널은 적어도 초기에 차단 모드에 있으며 소켓 주소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3073a336a578c76af3c2fae533b0dcd45d01e490" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented connected socket then a &lt;a href=&quot;../socketchannel&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The socket channel is, at least initially, in blocking mode, bound to a socket address, and connected to a peer.</source>
          <target state="translated">상속 된 채널이 스트림 지향 연결 소켓을 나타내는 경우 &lt;a href=&quot;../socketchannel&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 소켓 채널은 적어도 초기에 블로킹 모드에 있으며 소켓 주소에 바인딩되어 있고 피어에 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="875d948792bb0df4386ddee7ed26751e7f15e361" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented listening socket then a &lt;a href=&quot;../serversocketchannel&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The server-socket channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">상속 된 채널이 스트림 지향 청취 소켓을 나타내는 경우 &lt;a href=&quot;../serversocketchannel&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다. 서버 소켓 채널은 적어도 초기에는 차단 모드에 있으며 소켓 주소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="046cd8116ea31a7deaa92b344ddffcaddc10e57f" translate="yes" xml:space="preserve">
          <source>If the input byte array is not in valid Base64 encoding scheme then some bytes may have been written to the output byte array before IllegalargumentException is thrown.</source>
          <target state="translated">입력 바이트 배열이 유효한 Base64 인코딩 체계가 아닌 경우 IllegalargumentException이 발생하기 전에 일부 바이트가 출력 바이트 배열에 기록되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91347d5773aae8847de673eedfeeb7e761115795" translate="yes" xml:space="preserve">
          <source>If the input is not a valid Snippet, this will not be a valid class/import definition.</source>
          <target state="translated">입력이 유효한 스 니펫이 아니면 유효한 클래스 / 가져 오기 정의가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7b8c0e64cbb7daebfbf49419512f53ea309aa91a" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; system property. For more information, see the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos Requirements&lt;/a&gt;.</source>
          <target state="translated">입력 이름에 영역이 포함되지 않은 경우 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; 시스템 속성을 통해 지정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos 요구 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bd58891e2c653b5383c76eb69e062e344690968" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm-1&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; system property. For more information, see the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos Requirements&lt;/a&gt;.</source>
          <target state="translated">입력 이름에 영역이 포함되지 않은 경우 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm-1&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; 시스템 속성을 통해 지정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos 요구 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44c010f5bf051b0a98a728de40056665c0f4201b" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information,  Kerberos Requirements</source>
          <target state="translated">입력 이름에 영역이 없으면 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 특성을 통해 지정할 수 있습니다. 자세한 내용은 Kerberos 요구 사항</target>
        </trans-unit>
        <trans-unit id="e2258789d44cebf2e677dac1a6ecd85ab5667fdc" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see  Kerberos Requirements.</source>
          <target state="translated">입력 이름에 영역이 없으면 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 특성을 통해 지정할 수 있습니다. 자세한 내용은 Kerberos 요구 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a73e715c93a5e0127bac80ed71051dc7af6a5b8" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos Requirements&lt;/a&gt;. Additionally, if a security manager is installed, a &lt;a href=&quot;servicepermission&quot;&gt;&lt;code&gt;ServicePermission&lt;/code&gt;&lt;/a&gt; must be granted and the service principal of the permission must minimally be inside the &lt;code&gt;KerberosPrincipal&lt;/code&gt;'s realm. For example, if the result of &lt;code&gt;new KerberosPrincipal(&quot;user&quot;)&lt;/code&gt; is &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt;, then a &lt;code&gt;ServicePermission&lt;/code&gt; with service principal &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (and any action) must be granted.</source>
          <target state="translated">입력 이름에 영역이 포함되지 않은 경우 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 속성을 통해 지정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos 요구 사항을&lt;/a&gt; 참조하십시오 . 또한 보안 관리자가 설치된 경우 &lt;a href=&quot;servicepermission&quot;&gt; &lt;code&gt;ServicePermission&lt;/code&gt; &lt;/a&gt; 을 부여해야하며 권한의 서비스 주체는 최소한 &lt;code&gt;KerberosPrincipal&lt;/code&gt; 영역 내에 있어야합니다 . 예를 들어 &lt;code&gt;new KerberosPrincipal(&quot;user&quot;)&lt;/code&gt; 의 결과 가 &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt; 이면 서비스 주체가 &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (및 모든 작업) 인 &lt;code&gt;ServicePermission&lt;/code&gt; 을 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="72db9a55602aeaacd8d06804f6747b4e1ec98ac6" translate="yes" xml:space="preserve">
          <source>If the input sequence is mutable, it must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">입력 시퀀스가 ​​변경 가능한 경우 터미널 스트림 작업을 실행하는 동안 입력 시퀀스가 ​​일정하게 유지되어야합니다. 그렇지 않으면 터미널 스트림 작업의 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc4fd432cad2c0de1cfdac5a329f31d55c9e12d" translate="yes" xml:space="preserve">
          <source>If the inserted character is '-', it is accepted.</source>
          <target state="translated">삽입 된 문자가 '-'이면 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d3dcf4d36e88edd9ce623dd444c8f85abfe0b1" translate="yes" xml:space="preserve">
          <source>If the inserted character matches the mask for the next non-literal character, it is accepted at the new location.</source>
          <target state="translated">삽입 된 문자가 리터럴이 아닌 다음 문자의 마스크와 일치하면 새 위치에서 승인됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcd5cc0d6714ef6dfe7ad5151f92554586e46cb" translate="yes" xml:space="preserve">
          <source>If the intended destination of this stream is an abstraction provided by the underlying operating system, for example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed to the operating system for writing; it does not guarantee that they are actually written to a physical device such as a disk drive.</source>
          <target state="translated">이 스트림의 의도 된 목적지가 기본 운영 체제 (예 : 파일)에 의해 제공되는 추상화 인 경우, 스트림을 비우면 이전에 스트림에 기록 된 바이트 만 운영 체제로 전달되어 기록됩니다. 디스크 드라이브와 같은 실제 장치에 실제로 기록되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6dbed2351bbf5adacbd2e790b9255ca10dfcf5cc" translate="yes" xml:space="preserve">
          <source>If the internal frame is already closed, this method does nothing and returns immediately. Otherwise, this method begins by firing an &lt;code&gt;INTERNAL_FRAME_CLOSING&lt;/code&gt; event. Then this method sets the &lt;code&gt;closed&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; unless a listener vetoes the property change. This method finishes by making the internal frame invisible and unselected, and then firing an &lt;code&gt;INTERNAL_FRAME_CLOSED&lt;/code&gt; event.</source>
          <target state="translated">내부 프레임이 이미 닫힌 경우이 메서드는 아무 작업도 수행하지 않고 즉시 반환합니다. 그렇지 않으면이 메서드는 &lt;code&gt;INTERNAL_FRAME_CLOSING&lt;/code&gt; 이벤트 를 발생시켜 시작됩니다 . 그런 다음이 메서드는 리스너가 속성 변경을 거부하지 않는 한 &lt;code&gt;closed&lt;/code&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정합니다 . 이 메서드는 내부 프레임을 표시하지 않고 선택 취소 한 다음 &lt;code&gt;INTERNAL_FRAME_CLOSED&lt;/code&gt; 이벤트 를 발생시켜 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="81483551df6d9559fcbeffe5f6509d97a94497cc" translate="yes" xml:space="preserve">
          <source>If the internal frame is not visible, brings the internal frame to the front, makes it visible, and attempts to select it.</source>
          <target state="translated">내부 프레임이 보이지 않으면 내부 프레임을 앞으로 가져 와서 표시 한 다음 선택을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5939dca1837b7f5c342938c51c20c51e55fd3d33" translate="yes" xml:space="preserve">
          <source>If the internal frame is not visible, brings the internal frame to the front, makes it visible, and attempts to select it. The first time the internal frame is made visible, this method also fires an &lt;code&gt;INTERNAL_FRAME_OPENED&lt;/code&gt; event. This method does nothing if the internal frame is already visible. Invoking this method has the same result as invoking &lt;code&gt;setVisible(true)&lt;/code&gt;.</source>
          <target state="translated">내부 프레임이 보이지 않으면 내부 프레임을 앞으로 가져 와서 표시 한 다음 선택을 시도합니다. 내부 프레임이 처음 표시 될 때이 메서드는 &lt;code&gt;INTERNAL_FRAME_OPENED&lt;/code&gt; 이벤트 도 발생합니다 . 이 메서드는 내부 프레임이 이미 표시되어 있으면 아무 작업도 수행하지 않습니다. 이 메서드를 호출하는 것은 &lt;code&gt;setVisible(true)&lt;/code&gt; 를 호출하는 것과 동일한 결과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="881b9ec107691ccb0574603b5fa37effa233e5be" translate="yes" xml:space="preserve">
          <source>If the invoked method completes normally, the value it returns is copied in the &lt;code&gt;value&lt;/code&gt; property. Note that the &lt;code&gt;value&lt;/code&gt; property is set to &lt;code&gt;null&lt;/code&gt;, if the return type of the underlying method is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">호출 된 메소드가 정상적으로 완료되면 리턴 된 &lt;code&gt;value&lt;/code&gt; 이 value 특성에 복사됩니다 . 점을 유의 &lt;code&gt;value&lt;/code&gt; 속성으로 설정된 &lt;code&gt;null&lt;/code&gt; 기본 메소드의 리턴 타입 인 경우, &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55fa409a4b17ed3350505c8e7edb658e38fe64b1" translate="yes" xml:space="preserve">
          <source>If the invoking thread is interrupted while waiting to acquire the lock then its interrupt status will be set and a &lt;a href=&quot;filelockinterruptionexception&quot;&gt;&lt;code&gt;FileLockInterruptionException&lt;/code&gt;&lt;/a&gt; will be thrown. If the invoker's interrupt status is set when this method is invoked then that exception will be thrown immediately; the thread's interrupt status will not be changed.</source>
          <target state="translated">잠금 획득을 기다리는 동안 호출 스레드가 인터럽트되면 해당 인터럽트 상태가 설정되고 &lt;a href=&quot;filelockinterruptionexception&quot;&gt; &lt;code&gt;FileLockInterruptionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 이 메소드를 호출 할 때 호출자의 인터럽트 상태가 설정되면 해당 예외가 즉시 발생합니다. 스레드의 인터럽트 상태는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c99f7a43566c3e0f406a92c738f397ca332a50c" translate="yes" xml:space="preserve">
          <source>If the invoking thread is interrupted while waiting, then it will return immediately with the interrupt status set. If the interrupted status is already set, this method returns immediately with the interrupt status set.</source>
          <target state="translated">호출 스레드가 대기하는 동안 중단되면 인터럽트 상태가 설정된 상태로 즉시 반환됩니다. 인터럽트 상태가 이미 설정된 경우이 메서드는 인터럽트 상태가 설정된 상태로 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b769fc50fe26f32efef5297788dde55385ed9b56" translate="yes" xml:space="preserve">
          <source>If the item at the specified index is not selected, then the operation is ignored.</source>
          <target state="translated">지정된 인덱스의 항목을 선택하지 않으면 작업이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="609b6cb5da70d41c83a3aac10202e485bae19735" translate="yes" xml:space="preserve">
          <source>If the item is the first one being added to the choice, then the item becomes selected. Otherwise, if the selected item was one of the items shifted, the first item in the choice becomes the selected item. If the selected item was no among those shifted, it remains the selected item.</source>
          <target state="translated">항목이 선택 항목에 추가되는 첫 번째 항목이면 항목이 선택됩니다. 그렇지 않고 선택한 항목이 이동 된 항목 중 하나 인 경우 선택 항목의 첫 번째 항목이 선택한 항목이됩니다. 이동 한 항목 중 선택한 항목이 없으면 선택한 항목이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2c303e208ec2fac91ffa790d4de069ee4e7cc5" translate="yes" xml:space="preserve">
          <source>If the iteration variable type &lt;code&gt;V&lt;/code&gt; is dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">반복 변수 유형 &lt;code&gt;V&lt;/code&gt; 가 내부 매개 변수 목록에서 삭제되면 결과로 생성되는 더 짧은 목록 &lt;code&gt;(A...)&lt;/code&gt; &lt;em&gt;외부 매개 변수 목록&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="677df4c5c3a72284b193dc3046a802a47d947204" translate="yes" xml:space="preserve">
          <source>If the iteration variable types &lt;code&gt;(V I)&lt;/code&gt; are dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">반복 변수 유형 &lt;code&gt;(V I)&lt;/code&gt; 이 내부 매개 변수 목록에서 삭제되면 결과로 생성되는 더 짧은 목록 &lt;code&gt;(A...)&lt;/code&gt; &lt;em&gt;외부 매개 변수 목록&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="3b2f8ee14f1a5134aa879886d0c902676ccbfafd" translate="yes" xml:space="preserve">
          <source>If the iteration variable types &lt;code&gt;(V T)&lt;/code&gt; are dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">반복 변수 유형 &lt;code&gt;(V T)&lt;/code&gt; 이 내부 매개 변수 목록에서 삭제되면 결과로 생성되는 더 짧은 목록 &lt;code&gt;(A...)&lt;/code&gt; &lt;em&gt;외부 매개 변수 목록&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="ace7c9d0c03c5a8591ce4f875b6cfb21a9fe43d8" translate="yes" xml:space="preserve">
          <source>If the jar file is on the class path, VendorJavaCompiler can be located using code like this:</source>
          <target state="translated">jar 파일이 클래스 경로에있는 경우 VendorJavaCompiler는 다음과 같은 코드를 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05798c7b9d831dc45d92f33b15f7f3c7a9524b15" translate="yes" xml:space="preserve">
          <source>If the key agreement algorithm requires random bytes, it gets them from the given source of randomness, &lt;code&gt;random&lt;/code&gt;. However, if the underlying algorithm implementation does not require any random bytes, &lt;code&gt;random&lt;/code&gt; is ignored.</source>
          <target state="translated">키 합의 알고리즘에 임의의 바이트가 필요한 경우, 임의의 지정된 &lt;code&gt;random&lt;/code&gt; 소스 random로부터 가져옵니다 . 그러나 기본 알고리즘 구현에 임의 바이트가 필요하지 않은 경우 &lt;code&gt;random&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ba2d545a01554992fedf0cb983cad56e6a2aca" translate="yes" xml:space="preserve">
          <source>If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.</source>
          <target state="translated">키가 하드웨어 장치에 저장된 경우 해당 사양에는 장치의 키를 식별하는 데 도움이되는 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9af549a3a519458df47c4c31dbda4adcd0e3257" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, This method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어에 다른 형식의 서식과 독립 실행 형 사용이 필요한 경우이 메서드는 짧은 달 이름을 서식 형식으로 반환합니다. 예를 들어, 1 월 카탈로니아 어로 선호되는 약어는 &lt;em&gt;degen입니다. &lt;/em&gt;&lt;em&gt;gen&lt;/em&gt; 형식 인 동안 서식 형식으로 독립형으로. 이 메소드는 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 리턴합니다 . 이 경우 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;LDML (Unicode Locale Data Markup Language) 사양&lt;/a&gt; 의 달력 요소 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93f027224547b6049ea9e0bfa7e65c576dd00372" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns month names in the formatting form. For example, the preferred month name for January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어에 다른 형식의 서식과 독립 실행 형 사용이 필요한 경우이 메서드는 서식 형식으로 월 이름을 반환합니다. 예를 들어, 체코 어로 1 월에 선호하는 월 이름 은 형식화 형식으로 &lt;em&gt;ledna&lt;/em&gt; 이고 독립형 형식으로 &lt;em&gt;leden&lt;/em&gt; 입니다. 이 경우이 메소드는 &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; 를 리턴합니다 . 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;LDML (Unicode Locale Data Markup Language) 사양&lt;/a&gt; 의 달력 요소 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec115a41fa789db2802143bd704e450eb4e10a17" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns month names in the formatting form. For example, the preferred month name for January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어에 서식 지정 및 독립 실행 형 사용을 위해 다른 형식이 필요한 경우이 메서드는 형식 지정 형식으로 월 이름을 반환합니다. 예를 들어, 체코 어로 1 월의 선호 월 이름 은 형식화 양식의 &lt;em&gt;ledna&lt;/em&gt; 이고 독립형 양식의 &lt;em&gt;leden&lt;/em&gt; 입니다. 이 경우이 메서드는 &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; 를 반환합니다 . 자세한 내용은 &lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;유니 코드 LDML (Locale Data Markup Language) 사양&lt;/a&gt; 의 캘린더 요소 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="4df908f1fac23c580aff4bb5a5d73c49f92ce060" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어가 형식화 및 독립 실행 형 사용을 위해 다른 형식을 요구하는 경우이 메서드는 형식화 형식에 짧은 월 이름을 반환합니다. 예를 들어, 카탈루냐어에서 1 월에 선호되는 약어는 &lt;em&gt;de gen입니다. &lt;/em&gt;형식화 형식이지만 &lt;em&gt;gen입니다. &lt;/em&gt;독립형 형태로. 이 메서드는 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 반환합니다 . 이 경우. 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode Locale Data Markup Language (LDML) 사양&lt;/a&gt; 의 캘린더 요소 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="9a36eee403712a7e42f21c34d895460cc4cd080c" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어가 형식화 및 독립 실행 형 사용을 위해 다른 형식을 요구하는 경우이 메서드는 형식화 형식에 짧은 월 이름을 반환합니다. 예를 들어, 카탈루냐어에서 1 월에 선호되는 약어는 &lt;em&gt;de gen입니다.&lt;/em&gt; 형식화 형식이지만 &lt;em&gt;gen입니다.&lt;/em&gt; 독립형 형태로. 이 메서드는 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 반환합니다 . 이 경우. 자세한 내용은 &lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;유니 코드 LDML (Locale Data Markup Language) 사양&lt;/a&gt; 의 캘린더 요소 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="f1bf4283a4aed636a8a304bb68dccc18d01e161c" translate="yes" xml:space="preserve">
          <source>If the layout manager uses a per-component string, adds the component &lt;code&gt;comp&lt;/code&gt; to the layout, associating it with the string specified by &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">레이아웃 관리자가 컴포넌트 별 문자열을 사용하는 경우 컴포넌트 &lt;code&gt;comp&lt;/code&gt; 를 레이아웃에 추가하여 &lt;code&gt;name&lt;/code&gt; 으로 지정된 문자열과 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="721e40fbee0b627fcc6ccf4dd39ef80c9c24cc65" translate="yes" xml:space="preserve">
          <source>If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 의 길이 가 0이면 바이트를 읽지 않고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 적어도 1 바이트를 읽으려고합니다. 스트림이 파일의 끝에 있기 때문에 사용 가능한 바이트가 없으면 값 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 적어도 하나의 바이트를 읽고 &lt;code&gt;b&lt;/code&gt; 에 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="945b37877bd5c51ba536e667136d3b4286b64c37" translate="yes" xml:space="preserve">
          <source>If the length of the argument string is &lt;code&gt;0&lt;/code&gt;, then this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence that is the concatenation of the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object and the character sequence represented by the argument string.</source>
          <target state="translated">인수 문자열의 길이가 &lt;code&gt;0&lt;/code&gt; 이면이 &lt;code&gt;String&lt;/code&gt; 객체가 반환됩니다. 그렇지 않으면, &lt;code&gt;String&lt;/code&gt; 객체는 문자 시퀀스의 연결이로 표시되는 문자 순서 나타내 반환되는 &lt;code&gt;String&lt;/code&gt; 오브젝트 인수의 캐릭터 라인이 나타내는 문자 순서를.</target>
        </trans-unit>
        <trans-unit id="0940fb46aa425a706a545b01258cef980fd6db8a" translate="yes" xml:space="preserve">
          <source>If the length of the specified &lt;code&gt;CharSequence&lt;/code&gt; is less than or equal to zero, then an empty buffer of capacity &lt;code&gt;16&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 &lt;code&gt;CharSequence&lt;/code&gt; 의 길이 가 0보다 작거나 같은 경우 용량 &lt;code&gt;16&lt;/code&gt; 의 빈 버퍼 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="383b812813a9ca054e67e8d7ed50b33281ee93ba" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open(javax.sound.sampled.AudioFormat)&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">행이 열려 있지 않고 열지 않은 경우 기본 형식을 반환합니다. 기본 형식은 구현 특정 오디오 형식이거나, 이 &lt;code&gt;DataLine&lt;/code&gt; 을 검색하는 데 사용 된 &lt;code&gt;DataLine.Info&lt;/code&gt; 개체가 하나 이상의 정규화 된 오디오 형식을 지정하는 경우 마지막 형식이 기본 형식으로 사용됩니다. 특정 오디오 형식 (예 : &lt;a href=&quot;sourcedataline#open(javax.sound.sampled.AudioFormat)&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt; ) 으로 라인을 열면 기본 형식이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="009a7b082a7f277c626ca216eb6dd0590efc9900" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">줄이 열려 있지 않고 열리지 않은 경우 기본 형식을 반환합니다. 기본 형식은 구현 별 오디오 형식이거나, 이 &lt;code&gt;DataLine&lt;/code&gt; 을 검색하는 데 사용 된 &lt;code&gt;DataLine.Info&lt;/code&gt; 객체가 하나 이상의 정규화 된 오디오 형식을 지정하는 경우 마지막 형식이 기본 형식으로 사용됩니다. 특정 오디오 형식으로 라인을 열면 (예 : &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt; ) 기본 형식을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="7863f26128f8bba0e665024d8f8516c082ac4867" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">목록이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에 목록보다 많은 요소가있는 경우) 컬렉션의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다. . (이것은 목록의 길이를 결정하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="9d2a9e6acfe01f48880cc127c76590e8af39df2a" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">목록이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에 목록보다 많은 요소가있는 경우) 목록의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . (이것은 목록의 길이를 결정하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="e2a6a2c57017a029e9ebb7681d955085f7ded61a" translate="yes" xml:space="preserve">
          <source>If the list is an instance of &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; then the default implementation creates a spliterator that traverses elements by invoking the method &lt;a href=&quot;#get(int)&quot;&gt;&lt;code&gt;get(int)&lt;/code&gt;&lt;/a&gt;. If such invocation results or would result in an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; then the spliterator will &lt;em&gt;fail-fast&lt;/em&gt; and throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. If the list is also an instance of &lt;a href=&quot;abstractlist&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt; then the spliterator will use the list's &lt;a href=&quot;abstractlist#modCount&quot;&gt;&lt;code&gt;modCount&lt;/code&gt;&lt;/a&gt; field to provide additional &lt;em&gt;fail-fast&lt;/em&gt; behavior.</source>
          <target state="translated">목록이 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 의 인스턴스 인 경우 기본 구현은 &lt;a href=&quot;#get(int)&quot;&gt; &lt;code&gt;get(int)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 요소를 순회하는 분할자를 만듭니다 . 이러한 호출이 발생하거나 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 이 &lt;em&gt;발생&lt;/em&gt; 하는 경우 분할자는 &lt;em&gt;실패 속도를&lt;/em&gt; 내고 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 를 . 목록이 &lt;a href=&quot;abstractlist&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt; 의 인스턴스이기도 한 경우 스플리터는 목록의 &lt;a href=&quot;abstractlist#modCount&quot;&gt; &lt;code&gt;modCount&lt;/code&gt; &lt;/a&gt; 필드를 사용하여 추가 &lt;em&gt;페일&lt;/em&gt; 패스 동작 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1b902068f08330a0362c3c251027edac230d4119" translate="yes" xml:space="preserve">
          <source>If the list of assistive technology providers as provided through system property &quot;&lt;code&gt;&lt;span id=&quot;javax.accessibility.assistive_technologies&quot;&gt;javax.accessibility.assistive_technologies&lt;/span&gt;&lt;/code&gt;&quot; is the empty string or contains only &lt;a href=&quot;../../../java.base/java/lang/character#isWhitespace(int)&quot;&gt;white space&lt;/a&gt; characters it is ignored. All other errors are handled via an AWTError exception.</source>
          <target state="translated">시스템 특성 &quot; &lt;code&gt;&lt;span id=&quot;javax.accessibility.assistive_technologies&quot;&gt;javax.accessibility.assistive_technologies&lt;/span&gt;&lt;/code&gt; &quot;를 통해 제공된 보조 기술 제공자 목록이 빈 문자열이거나 &lt;a href=&quot;../../../java.base/java/lang/character#isWhitespace(int)&quot;&gt;공백&lt;/a&gt; 문자 만 포함하는 경우 무시됩니다. 다른 모든 오류는 AWTError 예외를 통해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1566f18ef0180d3aac88323daa9341914ba885e6" translate="yes" xml:space="preserve">
          <source>If the list's list-iterator does not support the &lt;code&gt;set&lt;/code&gt; operation then an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown when replacing the first element.</source>
          <target state="translated">리스트의리스트 반복자가 &lt;code&gt;set&lt;/code&gt; 조작을 지원하지 않는 경우는 최초의 요소를 교체 할 때 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae175c3216a75f24ee407fdf582572db3c498ef" translate="yes" xml:space="preserve">
          <source>If the listener is registered more than once, perhaps with different filters or callbacks, this method will remove all those registrations.</source>
          <target state="translated">리스너가 다른 필터 또는 콜백으로 두 번 이상 등록 된 경우이 메소드는 모든 등록을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="54b665bbf8eb506dbbe12fdda9847f03e69a163c" translate="yes" xml:space="preserve">
          <source>If the literal is empty, nothing is added to the formatter.</source>
          <target state="translated">리터럴이 비어 있으면 포맷터에 아무것도 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5586e5fb737ecf0129eedcffc9670c2876a5d020" translate="yes" xml:space="preserve">
          <source>If the load average is not available, a negative value is returned.</source>
          <target state="translated">로드 평균을 사용할 수 없으면 음수 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c80e112fdf053b8009f76cd046e1d1d1382fcec5" translate="yes" xml:space="preserve">
          <source>If the loaded KeyStore's provider extends &lt;code&gt;java.security.AuthProvider&lt;/code&gt;, then the provider's &lt;code&gt;logout&lt;/code&gt; method is invoked.</source>
          <target state="translated">로드 된 KeyStore의 공급자가 &lt;code&gt;java.security.AuthProvider&lt;/code&gt; 를 확장 하면 공급자의 &lt;code&gt;logout&lt;/code&gt; 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="612e3af41a7467295225df330e80d3aa55f31393" translate="yes" xml:space="preserve">
          <source>If the loading of the content handler class would be performed by a classloader that is outside of the delegation chain of the caller, the JVM will need the RuntimePermission &quot;getClassLoader&quot;.</source>
          <target state="translated">컨텐츠 핸들러 클래스의로드가 호출자의 위임 체인 외부에있는 클래스 로더에 의해 수행되는 경우 JVM에는 RuntimePermission &quot;getClassLoader&quot;가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1001411e7601e30ddd0e0c79cdc5159c320dbf60" translate="yes" xml:space="preserve">
          <source>If the local part is &lt;code&gt;null&lt;/code&gt; an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. A local part of &quot;&quot; is allowed to preserve compatible behavior with QName 1.0.</source>
          <target state="translated">로컬 부분 인 경우 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다. &quot;&quot;의 로컬 부분은 QName 1.0과 호환되는 동작을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a740773690bece4f01892057f26d0f5a3505d90" translate="yes" xml:space="preserve">
          <source>If the locale contains &quot;nu&quot; (numbers) and/or &quot;rg&quot; (region override) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the decimal digits, and/or the country used for formatting are overridden. If both &quot;nu&quot; and &quot;rg&quot; are specified, the decimal digits from the &quot;nu&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">로케일에 &quot;nu&quot;(숫자) 및 / 또는 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우 10 진수 및 / 또는 서식 지정에 사용 된 국가가 재정의됩니다. &quot;nu&quot;와 &quot;rg&quot;가 모두 지정되면 &quot;nu&quot;확장의 10 진수가 &quot;rg&quot;확장의 암시 적 숫자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="cfd944ef78cfcaae58d9f89252c3afdb5b581936" translate="yes" xml:space="preserve">
          <source>If the locale contains &quot;rg&quot; (region override) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbols are overridden for the designated region.</source>
          <target state="translated">로케일에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우 기호는 지정된 지역에 대해 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd82e30f2bfd2487deb48a3cd1ca525cc48b4ce" translate="yes" xml:space="preserve">
          <source>If the locale contains the &quot;rg&quot; (region override) &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the formatting pattern is overridden with the one appropriate for the region.</source>
          <target state="translated">로케일에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;유니 코드 확장이&lt;/a&gt; 포함되어 있으면 해당 지역에 적합한 형식으로 서식 지정 패턴이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5d4e75ab16c0169470cb2e36bf63130f893a3f1a" translate="yes" xml:space="preserve">
          <source>If the locale contains the time zone with &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, and time zone hasn't been given explicitly, time zone in the locale is used.</source>
          <target state="translated">로케일에 &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장자&lt;/a&gt; 가있는 시간대가 포함되어 있고 시간대가 명시 적으로 지정되지 않은 경우 로케일의 시간대가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13aecb53d0af72473665627440df7f59b9fad86f" translate="yes" xml:space="preserve">
          <source>If the locale contains the time zone with &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, that time zone is used instead.</source>
          <target state="translated">로케일에 &quot;tz&quot;가있는 시간대가 포함 된 경우 &lt;a href=&quot;locale#def_locale_extension&quot;&gt; 유니 코드 확장자&lt;/a&gt; 시간대가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb7426e4160f2b1fe5d7220ffa07b99d6ba7024b" translate="yes" xml:space="preserve">
          <source>If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is followed.</source>
          <target state="translated">로케일이 정확히 &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; 인 경우 먼저 &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; 로 변환됩니다. 다음 위의 절차를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c64c3966e3d4abb3a14f499628ce198c1164f906" translate="yes" xml:space="preserve">
          <source>If the lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">현재 스레드에서 잠금을 획득하면 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="822233d82712d166731e9dcca011715ab8bbe1d8" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the lock hold count is set to one.</source>
          <target state="translated">잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴되고 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="243ddf2fd70f54733945fc92a2c6210895bc2219" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e267ec383786f22b490efc4cbeb5a239987b49eb" translate="yes" xml:space="preserve">
          <source>If the lock is available this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">잠금이 사용 가능한 경우이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
