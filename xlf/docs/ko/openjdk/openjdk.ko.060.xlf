<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="97d46862568414c0b9e367d4cdf281bea3e7e493" translate="yes" xml:space="preserve">
          <source>Appends the localized zone offset, such as 'GMT+01:00', to the formatter.</source>
          <target state="translated">포맷터에 현지화 된 영역 오프셋 (예 : 'GMT + 01 : 00')을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fd286ce1d15d7645892b282499aa1ecce4aa925e" translate="yes" xml:space="preserve">
          <source>Appends the reduced value of a date-time field to the formatter.</source>
          <target state="translated">날짜-시간 필드의 감소 된 값을 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d23820a391259610c6b7bb21a498a57e376f2b05" translate="yes" xml:space="preserve">
          <source>Appends the specified &lt;code&gt;CharSequence&lt;/code&gt; to this sequence.</source>
          <target state="translated">지정된 &lt;code&gt;CharSequence&lt;/code&gt; 를이 순서에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="403adf760efb7fe7cb1aa666063d328faf97f09e" translate="yes" xml:space="preserve">
          <source>Appends the specified &lt;code&gt;StringBuffer&lt;/code&gt; to this sequence.</source>
          <target state="translated">지정된 &lt;code&gt;StringBuffer&lt;/code&gt; 를이 순서에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="5892314ebff890abad54a7a7be692ff3ea762427" translate="yes" xml:space="preserve">
          <source>Appends the specified URL to the list of URLs to search for classes and resources.</source>
          <target state="translated">지정된 URL을 URL 목록에 추가하여 클래스 및 리소스를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="73915bea68ba19ae72f33dc4bfdcc44636bc7108" translate="yes" xml:space="preserve">
          <source>Appends the specified char to this buffer</source>
          <target state="translated">이 버퍼에 지정된 문자를 추가</target>
        </trans-unit>
        <trans-unit id="f10b41fc51842242ba117d2c4f767a409a2c964a" translate="yes" xml:space="preserve">
          <source>Appends the specified character sequence to this &lt;code&gt;Appendable&lt;/code&gt;.</source>
          <target state="translated">지정된 문자 순서를이 &lt;code&gt;Appendable&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="3075ba4f49ae6a67e39b472af9bf812da0b2253e" translate="yes" xml:space="preserve">
          <source>Appends the specified character sequence to this buffer</source>
          <target state="translated">지정된 문자 순서를이 버퍼에 추가합니다</target>
        </trans-unit>
        <trans-unit id="e9b0b9ea35093bbab5cb3a27f2b9ffa8024c499c" translate="yes" xml:space="preserve">
          <source>Appends the specified character sequence to this output stream.</source>
          <target state="translated">지정된 문자 순서를이 출력 스트림에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="887bf872fc6b7ed418b5e718d6b3a0388c2bead1" translate="yes" xml:space="preserve">
          <source>Appends the specified character sequence to this writer.</source>
          <target state="translated">이 라이터에 지정된 문자 순서를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ef647ab518b3e2a40fedf796692416afcaca78e0" translate="yes" xml:space="preserve">
          <source>Appends the specified character to this &lt;code&gt;Appendable&lt;/code&gt;.</source>
          <target state="translated">지정된 문자를이 &lt;code&gt;Appendable&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1ea8d81001eaf82780b763ae2e6dacaefa1698ce" translate="yes" xml:space="preserve">
          <source>Appends the specified character to this output stream.</source>
          <target state="translated">지정된 문자를이 출력 스트림에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3d1e8b2d88ae00633bf4795273c255496c85aafe" translate="yes" xml:space="preserve">
          <source>Appends the specified character to this writer.</source>
          <target state="translated">이 라이터에 지정된 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4093a0c9df3c2371bdf1c791854d0fce03c9d058" translate="yes" xml:space="preserve">
          <source>Appends the specified component to the end of this container.</source>
          <target state="translated">이 컨테이너의 끝에 지정된 구성 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="877038f4a6f17ee2b8a7500f552ddacacbc994a8" translate="yes" xml:space="preserve">
          <source>Appends the specified component to the end of this container. This is a convenience method for &lt;a href=&quot;#addImpl(java.awt.Component,java.lang.Object,int)&quot;&gt;&lt;code&gt;addImpl(java.awt.Component, java.lang.Object, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 컨테이너의 끝에 지정된 구성 요소를 추가합니다. 이것은 &lt;a href=&quot;#addImpl(java.awt.Component,java.lang.Object,int)&quot;&gt; &lt;code&gt;addImpl(java.awt.Component, java.lang.Object, int)&lt;/code&gt; &lt;/a&gt; 대한 편리한 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="c67c0539bfb73ed763f5009a1fa3babf42790093" translate="yes" xml:space="preserve">
          <source>Appends the specified coordinates to this &lt;code&gt;Polygon&lt;/code&gt;.</source>
          <target state="translated">지정된 좌표를이 &lt;code&gt;Polygon&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="6d6377ba64cf7e458515159c18b80a0099538be1" translate="yes" xml:space="preserve">
          <source>Appends the specified element to the end of this Vector.</source>
          <target state="translated">지정된 요소를이 Vector의 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c349afe5e41baabf619d250f973de2631a819363" translate="yes" xml:space="preserve">
          <source>Appends the specified element to the end of this list (optional operation).</source>
          <target state="translated">지정된 요소를이 목록의 끝에 추가합니다 (선택적 조작).</target>
        </trans-unit>
        <trans-unit id="e786e7cc0f0900809cfabc8dff37ab88f2b0c507" translate="yes" xml:space="preserve">
          <source>Appends the specified element to the end of this list.</source>
          <target state="translated">지정된 요소를이 목록의 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="79a02db15553112578bc583213992e5af537660d" translate="yes" xml:space="preserve">
          <source>Appends the specified exception to the exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">이 예외를 전달하기 위해 억제 된 예외에 지정된 예외를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="89e15512a891a8fbf4db2f5714182d60f58c57f4" translate="yes" xml:space="preserve">
          <source>Appends the specified exception to the exceptions that were suppressed in order to deliver this exception. This method is thread-safe and typically called (automatically and implicitly) by the &lt;code&gt;try&lt;/code&gt;-with-resources statement.</source>
          <target state="translated">이 예외를 전달하기 위해 억제 된 예외에 지정된 예외를 추가합니다. 이 메소드는 스레드로부터 안전하며 일반적으로 &lt;code&gt;try&lt;/code&gt; -with-resources 문에 의해 (자동 및 암시 적으로) 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9b937fc9361f9718ac900d4b93f787db5572ad7" translate="yes" xml:space="preserve">
          <source>Appends the specified menu item to the end of this menu.</source>
          <target state="translated">이 메뉴의 끝에 지정된 메뉴 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c6c97272e1c7e1340478d0cd77ecaa2732904de7" translate="yes" xml:space="preserve">
          <source>Appends the specified menu to the end of the menu bar.</source>
          <target state="translated">메뉴 모음 끝에 지정된 메뉴를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="088a1f0d499d8b31f5099362a31c3a6d9606e250" translate="yes" xml:space="preserve">
          <source>Appends the specified string to this character sequence.</source>
          <target state="translated">지정된 문자열을이 문자 순서에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2f191e8e601e6a0d6d9bd5bf4260185658ef46f9" translate="yes" xml:space="preserve">
          <source>Appends the string representation of a subarray of the &lt;code&gt;char&lt;/code&gt; array argument to this sequence.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 배열 인수 의 서브 어레이의 문자열 표현 을이 순서에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="db66fd97a079558f509cf7046555fa67ead53369" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;Object&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 인수 의 문자열 표현을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="fdcfe0a57ccfd59aff3e13b380b34851f14bb38c" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;boolean&lt;/code&gt; argument to the sequence.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 인수 의 문자열 표현을 시퀀스에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b024e4927c67af8f6fae9e55ee4a8f6dae7b79" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;char&lt;/code&gt; argument to this sequence.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 인수 의 캐릭터 라인 표현 을이 순서에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="74119a37c1afbfc043dc9e471cf7fb1a05613fd6" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;char&lt;/code&gt; array argument to this sequence.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 배열 인수 의 문자열 표현 을이 순서에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="01ef91fecec989cf22290887f3826204d3d68916" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;codePoint&lt;/code&gt; argument to this sequence.</source>
          <target state="translated">&lt;code&gt;codePoint&lt;/code&gt; 인수 의 문자열 표현 을이 순서에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="163ff8bd37d249d282af7c101be46c5e84506eaa" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;double&lt;/code&gt; argument to this sequence.</source>
          <target state="translated">이 인수에 &lt;code&gt;double&lt;/code&gt; 인수 의 캐릭터 라인 표현을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="2ea5a8324ac302b185027ecfd9539501689e5aca" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;float&lt;/code&gt; argument to this sequence.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 인수 의 캐릭터 라인 표현 을이 순서에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f57211745a2b4498fd6b12988fc604c40d01fadb" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;int&lt;/code&gt; argument to this sequence.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 인수 의 문자열 표현 을이 순서에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8841ab004de348406bc2339572b5dacb3dfabf83" translate="yes" xml:space="preserve">
          <source>Appends the string representation of the &lt;code&gt;long&lt;/code&gt; argument to this sequence.</source>
          <target state="translated">이 인수에 &lt;code&gt;long&lt;/code&gt; 인수 의 캐릭터 라인 표현을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b76372942da5bbdb7456c730eef6450037742063" translate="yes" xml:space="preserve">
          <source>Appends the text of a date-time field to the formatter using the full text style.</source>
          <target state="translated">전체 텍스트 스타일을 사용하여 날짜-시간 필드의 텍스트를 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6de64cb1814bcaa101564c20928a648a625492b9" translate="yes" xml:space="preserve">
          <source>Appends the text of a date-time field to the formatter using the specified map to supply the text.</source>
          <target state="translated">지정된 맵을 사용하여 날짜-시간 필드의 텍스트를 포맷터에 추가하여 텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="47624b2d52e60838e636d54e86d8d936e7a86c02" translate="yes" xml:space="preserve">
          <source>Appends the text of a date-time field to the formatter.</source>
          <target state="translated">날짜-시간 필드의 텍스트를 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e144089807b8aec12ca52afc817e29d9c32a1ef6" translate="yes" xml:space="preserve">
          <source>Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter, using the best available zone ID.</source>
          <target state="translated">사용 가능한 최상의 영역 ID를 사용하여 '유럽 / 파리'또는 '+02 : 00'과 같은 시간대 ID를 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c62c30d255541630177a168af30674da0f2bf39a" translate="yes" xml:space="preserve">
          <source>Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.</source>
          <target state="translated">'유럽 / 파리'또는 '+02 : 00'과 같은 시간대 ID를 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ebec0377fec25d4e0ded182c38d98da4043d0b5a" translate="yes" xml:space="preserve">
          <source>Appends the time-zone name, such as 'British Summer Time', to the formatter.</source>
          <target state="translated">'British Summer Time'과 같은 시간대 이름을 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fce4d833a5294e5be507295337076318cc55f391" translate="yes" xml:space="preserve">
          <source>Appends the time-zone region ID, such as 'Europe/Paris', to the formatter, rejecting the zone ID if it is a &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">'유럽 / 파리'와 같은 시간대 영역 ID를 포맷터에 추가하여 &lt;code&gt;ZoneOffset&lt;/code&gt; 인 경우 영역 ID를 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="46b5c41f6878511d79dc2357225f0f3c59199147" translate="yes" xml:space="preserve">
          <source>Appends the value of a date-time field to the formatter providing full control over formatting.</source>
          <target state="translated">날짜-시간 필드의 값을 포맷터에 추가하여 포맷팅을 완전히 제어합니다.</target>
        </trans-unit>
        <trans-unit id="4c16af480b92b45ba43b0fc2b238944f9add2fe0" translate="yes" xml:space="preserve">
          <source>Appends the value of a date-time field to the formatter using a fixed width, zero-padded approach.</source>
          <target state="translated">고정 너비의 0으로 채워진 접근 방식을 사용하여 날짜-시간 필드의 값을 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="186f7ffe827c5f1a49eb2f747df751f27687bbe4" translate="yes" xml:space="preserve">
          <source>Appends the value of a date-time field to the formatter using a normal output style.</source>
          <target state="translated">일반 출력 스타일을 사용하여 날짜-시간 필드의 값을 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="db208587cb329f41f68ab69d38d81b63d7b0e039" translate="yes" xml:space="preserve">
          <source>Appends the zone offset, such as '+01:00', to the formatter.</source>
          <target state="translated">'+01 : 00'과 같은 영역 오프셋을 포맷터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="18b2b60a1a07cab1060e2d47172cbe32a0b7f89d" translate="yes" xml:space="preserve">
          <source>Applet</source>
          <target state="translated">Applet</target>
        </trans-unit>
        <trans-unit id="3aa2e09a94b226303351ddc50dae9e64eadf1838" translate="yes" xml:space="preserve">
          <source>Applet.AccessibleApplet</source>
          <target state="translated">Applet.AccessibleApplet</target>
        </trans-unit>
        <trans-unit id="4fc1edd5ee53c250311ccc5208b107f025a4b8b7" translate="yes" xml:space="preserve">
          <source>AppletContext</source>
          <target state="translated">AppletContext</target>
        </trans-unit>
        <trans-unit id="488b0304818d795d79ef00b876ed6c33abb17a19" translate="yes" xml:space="preserve">
          <source>AppletInitializer</source>
          <target state="translated">AppletInitializer</target>
        </trans-unit>
        <trans-unit id="a0e9a59fc6a8081eea334fc91e80fc293bfdb9d3" translate="yes" xml:space="preserve">
          <source>AppletInitializer.activate()</source>
          <target state="translated">AppletInitializer.activate()</target>
        </trans-unit>
        <trans-unit id="00640ab6965f79d693f1a39c2c2b63fe4721b903" translate="yes" xml:space="preserve">
          <source>AppletInitializer.initialize()</source>
          <target state="translated">AppletInitializer.initialize()</target>
        </trans-unit>
        <trans-unit id="f5415147ecdcf531d4510ec0ec67e6b5a749dcf6" translate="yes" xml:space="preserve">
          <source>AppletStub</source>
          <target state="translated">AppletStub</target>
        </trans-unit>
        <trans-unit id="1dff35ce41c1c847b6d220332d1bd7905bee5db1" translate="yes" xml:space="preserve">
          <source>Applets typically run in a container that already has a security manager, so there is generally no need for applets to set a security manager. If you have a standalone application, you might need to set a &lt;code&gt;SecurityManager&lt;/code&gt; in order to enable class downloading. This can be done by adding the following to your code. (It needs to be executed before RMI can download code from remote hosts, so it most likely needs to appear in the &lt;code&gt;main&lt;/code&gt; method of your application.)</source>
          <target state="translated">애플릿은 일반적으로 이미 보안 관리자가있는 컨테이너에서 실행되므로 일반적으로 애플릿에서 보안 관리자를 설정할 필요가 없습니다. 독립 실행 형 애플리케이션이있는 경우 클래스 다운로드를 사용하려면 &lt;code&gt;SecurityManager&lt;/code&gt; 를 설정해야 할 수 있습니다 . 코드에 다음을 추가하면됩니다. (RMI가 원격 호스트에서 코드를 다운로드하기 전에 실행해야하므로 애플리케이션 의 &lt;code&gt;main&lt;/code&gt; 메소드에 표시되어야 할 가능성이 높습니다 .)</target>
        </trans-unit>
        <trans-unit id="1e49f01f985d37daacd5c2ac45cd785f57acc910" translate="yes" xml:space="preserve">
          <source>Application Data - Once the communication parameters have been established and the handshake is complete, application data may flow through the &lt;code&gt;SSLEngine&lt;/code&gt;. Outbound application messages are encrypted and integrity protected, and inbound messages reverse the process.</source>
          <target state="translated">애플리케이션 데이터-통신 매개 변수가 설정되고 핸드 셰이크가 완료되면 애플리케이션 데이터가 &lt;code&gt;SSLEngine&lt;/code&gt; 을 통해 흐를 수 있습니다 . 아웃 바운드 애플리케이션 메시지는 암호화되고 무결성이 보호되며 인바운드 메시지는 프로세스를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="1c01bfbc616afd5a098ddde578a275ebbbf2b372" translate="yes" xml:space="preserve">
          <source>Application Resource Files</source>
          <target state="translated">응용 프로그램 리소스 파일</target>
        </trans-unit>
        <trans-unit id="3c888e08801297fc7c9a8c9e3373ba0d954cc1a4" translate="yes" xml:space="preserve">
          <source>Application code can also create a new MBean Server, or access already-created MBean Servers, using the &lt;a href=&quot;mbeanserverfactory&quot;&gt;&lt;code&gt;MBeanServerFactory&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">응용 프로그램 코드는 &lt;a href=&quot;mbeanserverfactory&quot;&gt; &lt;code&gt;MBeanServerFactory&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 새 MBean 서버를 작성하거나 이미 작성된 MBean 서버에 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0ddafcb009f60a8abcaf2a35a101c3eda97ef79" translate="yes" xml:space="preserve">
          <source>Application code can directly subclass Configuration to provide a custom implementation. In addition, an instance of a Configuration object can be constructed by invoking one of the &lt;code&gt;getInstance&lt;/code&gt; factory methods with a standard type. The default policy type is &quot;JavaLoginConfig&quot;. See the Configuration section in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#configuration-types&quot;&gt; Java Security Standard Algorithm Names Specification&lt;/a&gt; for a list of standard Configuration types.</source>
          <target state="translated">애플리케이션 코드는 사용자 정의 구현을 제공하기 위해 구성을 직접 하위 클래스화할 수 있습니다. 또한 표준 유형으로 &lt;code&gt;getInstance&lt;/code&gt; 팩토리 메소드 중 하나를 호출하여 Configuration 객체의 인스턴스를 생성 할 수 있습니다 . 기본 정책 유형은 &quot;JavaLoginConfig&quot;입니다. 표준 구성 유형 목록은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#configuration-types&quot;&gt;Java 보안 표준 알고리즘 이름 사양&lt;/a&gt; 의 구성 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecf48d008bc04c9fba8077398c4acbc137fa56a1" translate="yes" xml:space="preserve">
          <source>Application code can directly subclass Configuration to provide a custom implementation. In addition, an instance of a Configuration object can be constructed by invoking one of the &lt;code&gt;getInstance&lt;/code&gt; factory methods with a standard type. The default policy type is &quot;JavaLoginConfig&quot;. See the Configuration section in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Configuration&quot;&gt; Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt; for a list of standard Configuration types.</source>
          <target state="translated">응용 프로그램 코드는 구성을 직접 서브 클래 싱하여 사용자 정의 구현을 제공 할 수 있습니다. 또한 표준 유형으로 &lt;code&gt;getInstance&lt;/code&gt; 팩토리 메소드 중 하나를 호출하여 구성 오브젝트의 인스턴스를 구성 할 수 있습니다 . 기본 정책 유형은 &quot;JavaLoginConfig&quot;입니다. 표준 구성 유형 목록은 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Configuration&quot;&gt;Java 암호화 아키텍처 표준 알고리즘 이름 설명서&lt;/a&gt; 의 구성 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d2e568ff7065c4954d0ca7cf3c6b38197e77f6e" translate="yes" xml:space="preserve">
          <source>Application code can directly subclass Policy to provide a custom implementation. In addition, an instance of a Policy object can be constructed by invoking one of the &lt;code&gt;getInstance&lt;/code&gt; factory methods with a standard type. The default policy type is &quot;JavaPolicy&quot;.</source>
          <target state="translated">응용 프로그램 코드는 정책을 직접 서브 클래 싱하여 사용자 지정 구현을 제공 할 수 있습니다. 또한 정책 개체 중 하나를 호출하여 정책 개체의 인스턴스를 구성 할 수 있습니다. &lt;code&gt;getInstance&lt;/code&gt; 표준 유형 getInstance 팩토리 메소드 . 기본 정책 유형은 &quot;JavaPolicy&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e2e089e05cf66fff329ca5e8678168e19dc8bf7f" translate="yes" xml:space="preserve">
          <source>Application code will not use these methods explicitly, they are used internally by &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">애플리케이션 코드는 이러한 메소드를 명시 적으로 사용하지 않으며 &lt;code&gt;JTable&lt;/code&gt; 에서 내부적으로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="e4f463c504e79280da5308b67af94a7fd194d269" translate="yes" xml:space="preserve">
          <source>Application code will not use these methods explicitly, they are used internally by JTable.</source>
          <target state="translated">애플리케이션 코드는 이러한 메소드를 명시 적으로 사용하지 않으며 JTable에서 내부적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f3a6e6614cf26b872cd28ba7e7296063689eae53" translate="yes" xml:space="preserve">
          <source>Application code will not use this method explicitly, it is used internally by the column dragging mechanism.</source>
          <target state="translated">응용 프로그램 코드는이 메서드를 명시 적으로 사용하지 않으며 열 끌기 메커니즘에서 내부적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1b79f5649db950b57931a71da3a2d588807ae702" translate="yes" xml:space="preserve">
          <source>Application code will not use this method explicitly, it is used internally by the column sizing mechanism.</source>
          <target state="translated">응용 프로그램 코드는이 메서드를 명시 적으로 사용하지 않으며 열 크기 조정 메커니즘에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="771f3f889ff6ba3070f745a76dc87772ecf1dd69" translate="yes" xml:space="preserve">
          <source>Application data (also known as plaintext or cleartext) is data which is produced or consumed by an application. Its counterpart is network data, which consists of either handshaking and/or ciphertext (encrypted) data, and destined to be transported via an I/O mechanism. Inbound data is data which has been received from the peer, and outbound data is destined for the peer.</source>
          <target state="translated">응용 프로그램 데이터 (일반 텍스트 또는 일반 텍스트라고도 함)는 응용 프로그램에서 생성하거나 사용하는 데이터입니다. 그것의 대응은 네트워크 데이터이며, 이는 핸드 쉐이킹 및 / 또는 암호문 (암호화 된) 데이터로 구성되며 I / O 메커니즘을 통해 전송 될 예정이다. 인바운드 데이터는 피어에서 수신 한 데이터이며, 아웃 바운드 데이터는 피어를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="ecafbb5ea26d556e3932ebfbf003adb3f9f935d5" translate="yes" xml:space="preserve">
          <source>Application developers should refer to their provider's documentation to find out which key specifications are supported by the &lt;a href=&quot;#generateSecret(java.security.spec.KeySpec)&quot;&gt;&lt;code&gt;generateSecret&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getKeySpec(javax.crypto.SecretKey,java.lang.Class)&quot;&gt;&lt;code&gt;getKeySpec&lt;/code&gt;&lt;/a&gt; methods. For example, the DES secret-key factory supplied by the &quot;SunJCE&quot; provider supports &lt;code&gt;DESKeySpec&lt;/code&gt; as a transparent representation of DES keys, and that provider's secret-key factory for Triple DES keys supports &lt;code&gt;DESedeKeySpec&lt;/code&gt; as a transparent representation of Triple DES keys.</source>
          <target state="translated">응용 프로그램 개발자는 &lt;a href=&quot;#generateSecret(java.security.spec.KeySpec)&quot;&gt; &lt;code&gt;generateSecret&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#getKeySpec(javax.crypto.SecretKey,java.lang.Class)&quot;&gt; &lt;code&gt;getKeySpec&lt;/code&gt; &lt;/a&gt; 메서드 에서 지원하는 키 사양을 확인하려면 해당 공급자의 설명서를 참조해야 합니다. 예를 들어, &quot;SunJCE&quot;공급자가 제공하는 DES 비밀 키 팩토리 는 DES 키의 투명한 표현으로 &lt;code&gt;DESKeySpec&lt;/code&gt; 을 지원 하고 해당 공급자의 Triple DES 키에 대한 비밀 키 팩토리는 트리플 DES 키 의 투명한 표현으로 &lt;code&gt;DESedeKeySpec&lt;/code&gt; 을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="e4731649856f6c1954ff4144c23e30b90b9f5f89" translate="yes" xml:space="preserve">
          <source>Application developers should refer to their provider's documentation to find out which key specifications are supported by the &lt;a href=&quot;secretkeyfactory#generateSecret-java.security.spec.KeySpec-&quot;&gt;&lt;code&gt;generateSecret&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;secretkeyfactory#getKeySpec-javax.crypto.SecretKey-java.lang.Class-&quot;&gt;&lt;code&gt;getKeySpec&lt;/code&gt;&lt;/a&gt; methods. For example, the DES secret-key factory supplied by the &quot;SunJCE&quot; provider supports &lt;code&gt;DESKeySpec&lt;/code&gt; as a transparent representation of DES keys, and that provider's secret-key factory for Triple DES keys supports &lt;code&gt;DESedeKeySpec&lt;/code&gt; as a transparent representation of Triple DES keys.</source>
          <target state="translated">응용 프로그램 개발자는 제공자의 문서를 참조하여 &lt;a href=&quot;secretkeyfactory#generateSecret-java.security.spec.KeySpec-&quot;&gt; &lt;code&gt;generateSecret&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;secretkeyfactory#getKeySpec-javax.crypto.SecretKey-java.lang.Class-&quot;&gt; &lt;code&gt;getKeySpec&lt;/code&gt; &lt;/a&gt; 메소드 가 지원하는 주요 스펙을 찾으십시오 . 예를 들어, &quot;SunJCE&quot;공급자가 제공 한 DES 비밀 키 팩토리 는 DES 키의 투명한 표현으로 &lt;code&gt;DESKeySpec&lt;/code&gt; 을 지원 하고 트리플 DES 키를위한 해당 제공자의 비밀 키 팩토리는 &lt;code&gt;DESedeKeySpec&lt;/code&gt; 의 투명한 표현으로 DESedeKeySpec 을 합니다.</target>
        </trans-unit>
        <trans-unit id="05a10d262c8adc401cafe34e37c1a23c2b26d366" translate="yes" xml:space="preserve">
          <source>Application servers are not required to support any particular form or type of mapped name, nor the ability to use mapped names. The mapped name is product-dependent and often installation-dependent. No use of a mapped name is portable.</source>
          <target state="translated">응용 프로그램 서버는 특정 형식이나 유형의 매핑 된 이름 또는 매핑 된 이름을 사용할 수있는 기능을 지원하지 않아도됩니다. 맵핑 된 이름은 제품에 따라 다르며 종종 설치에 따라 다릅니다. 매핑 된 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7334dcab4d38450f3344a48c3f61759e7e00a671" translate="yes" xml:space="preserve">
          <source>Application writers can extend this class when they need to implement only part of an interface; parser writers can instantiate this class to provide default handlers when the application has not supplied its own.</source>
          <target state="translated">응용 프로그램 작성자는 인터페이스의 일부만 구현해야 할 때이 클래스를 확장 할 수 있습니다. 파서 작성자는 응용 프로그램이 자체적으로 제공하지 않은 경우 기본 처리기를 제공하기 위해이 클래스를 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b47220c84b69e328fec122d9b191c8ae39356d29" translate="yes" xml:space="preserve">
          <source>Application writers can use this method to redirect external system identifiers to secure and/or local URI, to look up public identifiers in a catalogue, or to read an entity from a database or other input source (including, for example, a dialog box).</source>
          <target state="translated">애플리케이션 작성자는이 방법을 사용하여 외부 시스템 식별자를 보안 및 / 또는 로컬 URI로 리디렉션하거나, 카탈로그에서 공용 식별자를 조회하거나, 데이터베이스 또는 기타 입력 소스 (예 : 대화 상자 포함)에서 엔터티를 읽을 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="ad99f1ff92befdc42409538a4a9dd6dcb1ee33e7" translate="yes" xml:space="preserve">
          <source>Application writers can use this method to redirect external system identifiers to secure and/or local URIs, to look up public identifiers in a catalogue, or to read an entity from a database or other input source (including, for example, a dialog box). Neither XML nor SAX specifies a preferred policy for using public or system IDs to resolve resources. However, SAX specifies how to interpret any InputSource returned by this method, and that if none is returned, then the system ID will be dereferenced as a URL.</source>
          <target state="translated">애플리케이션 작성자는이 방법을 사용하여 외부 시스템 식별자를 보안 및 / 또는 로컬 URI로 리디렉션하거나, 카탈로그에서 공용 식별자를 조회하거나, 데이터베이스 또는 기타 입력 소스 (예 : 대화 상자 포함)에서 엔터티를 읽을 수 있습니다. . XML과 SAX 모두 리소스를 확인하기 위해 공용 또는 시스템 ID를 사용하기위한 기본 정책을 지정하지 않습니다. 그러나 SAX는이 메서드에 의해 반환 된 InputSource를 해석하는 방법을 지정하며, 반환되는 것이 없으면 시스템 ID가 URL로 역 참조되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6981b8a3830b95086056c91236e685d7623bc901" translate="yes" xml:space="preserve">
          <source>Application writers should use setSystemId() to provide a base for resolving relative URIs, and may use setPublicId to include a public identifier.</source>
          <target state="translated">애플리케이션 작성자는 setSystemId ()를 사용하여 상대 URI를 확인하기위한 기반을 제공해야하며 setPublicId를 사용하여 공용 식별자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e4c4088ad948a1e43bb6e90ccf8258db578ba3" translate="yes" xml:space="preserve">
          <source>Application writers should use setSystemId() to provide a base for resolving relative URIs, may use setPublicId to include a public identifier, and may use setEncoding to specify the object's character encoding.</source>
          <target state="translated">애플리케이션 작성자는 setSystemId ()를 사용하여 상대 URI를 확인하기위한 기반을 제공하고 setPublicId를 사용하여 공용 식별자를 포함 할 수 있으며 setEncoding을 사용하여 개체의 문자 인코딩을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a62ecdac430fdfde2451dea4ff330e4cd5656ec5" translate="yes" xml:space="preserve">
          <source>Application writers who do not want to implement the entire interface can derive a class from HandlerBase, which implements the default functionality; parser writers can instantiate HandlerBase to obtain a default handler. The application can find the location of any document event using the Locator interface supplied by the Parser through the setDocumentLocator method.</source>
          <target state="translated">전체 인터페이스를 구현하지 않으려는 응용 프로그램 작성자는 기본 기능을 구현하는 HandlerBase에서 클래스를 파생시킬 수 있습니다. 파서 작성자는 HandlerBase를 인스턴스화하여 기본 처리기를 얻을 수 있습니다. 애플리케이션은 setDocumentLocator 메소드를 통해 Parser가 제공하는 로케이터 인터페이스를 사용하여 문서 이벤트의 위치를 ​​찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b6e2473f35ddd610a148601726bc65198ce010" translate="yes" xml:space="preserve">
          <source>Application-specified source of randomness.</source>
          <target state="translated">응용 프로그램이 지정한 임의성 소스.</target>
        </trans-unit>
        <trans-unit id="aa746d6603ea64f1223d3ba28adfac00d22e42b8" translate="yes" xml:space="preserve">
          <source>ApplicationName - The name of the application currently utilizing the connection</source>
          <target state="translated">ApplicationName-현재 연결을 사용하는 애플리케이션의 이름</target>
        </trans-unit>
        <trans-unit id="132e90c01e41cbf711e24fb6067cf1406ce4cfbe" translate="yes" xml:space="preserve">
          <source>Applications are discouraged from calling this method since this operation may not be supported by all policy implementations. Applications should rely on the &lt;code&gt;implies&lt;/code&gt; method to perform policy checks.</source>
          <target state="translated">이 정책은 모든 정책 구현에서 지원되지 않을 수 있으므로 응용 프로그램에서이 메서드를 호출하지 않는 것이 좋습니다. 응용 프로그램은 &lt;code&gt;implies&lt;/code&gt; 방법을 사용하여 정책 검사를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e723e9edd551fe7209bf1873036ec2ae65fd9842" translate="yes" xml:space="preserve">
          <source>Applications are discouraged from calling this method since this operation may not be supported by all policy implementations. Applications should solely rely on the &lt;code&gt;implies&lt;/code&gt; method to perform policy checks. If an application absolutely must call a getPermissions method, it should call &lt;code&gt;getPermissions(ProtectionDomain)&lt;/code&gt;.</source>
          <target state="translated">이 정책은 모든 정책 구현에서 지원되지 않을 수 있으므로 응용 프로그램에서이 메서드를 호출하지 않는 것이 좋습니다. 응용 프로그램은 정책 검사를 수행하기 위해 &lt;code&gt;implies&lt;/code&gt; 방법 에만 의존해야 합니다. 애플리케이션이 절대적으로 getPermissions 메소드를 호출해야하는 경우 &lt;code&gt;getPermissions(ProtectionDomain)&lt;/code&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="57a30a3fedb6b3250c115b3fe69d364bce20f841" translate="yes" xml:space="preserve">
          <source>Applications are not expected to use this class directly. A remote object exported to use a dynamic proxy with &lt;a href=&quot;unicastremoteobject&quot;&gt;&lt;code&gt;UnicastRemoteObject&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../activation/activatable&quot;&gt;&lt;code&gt;Activatable&lt;/code&gt;&lt;/a&gt; has an instance of this class as that proxy's invocation handler.</source>
          <target state="translated">응용 프로그램은이 클래스를 직접 사용하지 않습니다. &lt;a href=&quot;unicastremoteobject&quot;&gt; &lt;code&gt;UnicastRemoteObject&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../activation/activatable&quot;&gt; &lt;code&gt;Activatable&lt;/code&gt; &lt;/a&gt; 과 함께 동적 프록시를 사용하기 위해 내 보낸 원격 개체 에는 해당 프록시의 호출 처리기로이 클래스의 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc38f60d3ad17a4c6657603cf5a58c9520bb195b" translate="yes" xml:space="preserve">
          <source>Applications can apply a degree of filtering to determine the level of synchronization that a &lt;code&gt;SyncProvider&lt;/code&gt; implementation offers. The following criteria determine whether a provider is made available to a &lt;code&gt;RowSet&lt;/code&gt; object:</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;SyncProvider&lt;/code&gt; 구현이 제공 하는 동기화 수준을 결정하기 위해 일정 수준의 필터링을 적용 할 수 있습니다 . 다음 기준은 공급자를 &lt;code&gt;RowSet&lt;/code&gt; 개체에 사용할 수 있는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="44e4145573d0b541941799c9f70c0f0bcbcebc91" translate="yes" xml:space="preserve">
          <source>Applications can call this method even during a &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; is being parsed.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; 가 구문 분석되는 동안에도이 메서드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="153f84eb324e14ccfa14a7560ce2acdf23ea121b" translate="yes" xml:space="preserve">
          <source>Applications can determine if an object supports the &lt;code&gt;AccessibleExtendedText&lt;/code&gt; interface by first obtaining its &lt;code&gt;AccessibleContext&lt;/code&gt; (see &lt;a href=&quot;accessible&quot;&gt;&lt;code&gt;Accessible&lt;/code&gt;&lt;/a&gt;) and then calling the &lt;a href=&quot;accessiblecontext#getAccessibleText()&quot;&gt;&lt;code&gt;AccessibleContext.getAccessibleText()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;AccessibleContext&lt;/code&gt;. If the return value is an instance of &lt;code&gt;AccessibleExtendedText&lt;/code&gt;, the object supports this interface.</source>
          <target state="translated">물체가 지원하는지 여부를 판정 할 수 &lt;code&gt;AccessibleExtendedText&lt;/code&gt; 먼저 획득함으로써 인터페이스 &lt;code&gt;AccessibleContext&lt;/code&gt; (참조 &lt;a href=&quot;accessible&quot;&gt; &lt;code&gt;Accessible&lt;/code&gt; &lt;/a&gt; 호출 한 후) 및 &lt;a href=&quot;accessiblecontext#getAccessibleText()&quot;&gt; &lt;code&gt;AccessibleContext.getAccessibleText()&lt;/code&gt; &lt;/a&gt; 방법 &lt;code&gt;AccessibleContext&lt;/code&gt; . 반환 값이 &lt;code&gt;AccessibleExtendedText&lt;/code&gt; 의 인스턴스 이면 객체는이 인터페이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c6a911fb9ffbfbfbcf5b7408fbd2cb67176b9e9b" translate="yes" xml:space="preserve">
          <source>Applications can determine if an object supports the AccessibleAction interface by first obtaining its &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt; (see &lt;a href=&quot;#Accessible&quot;&gt;Accessible&lt;/a&gt;) and then calling the &lt;code&gt;getAccessibleAction&lt;/code&gt; method of &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt;. If the return value is not &lt;code&gt;null&lt;/code&gt;, the object supports this interface.</source>
          <target state="translated">객체가 먼저 획득함으로써 AccessibleAction가 인터페이스를 지원하는지 여부를 판정 할 수 &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext를&lt;/a&gt; (참조 &lt;a href=&quot;#Accessible&quot;&gt;가능&lt;/a&gt; ) 후 호출 &lt;code&gt;getAccessibleAction&lt;/code&gt; 의 방법 &lt;a href=&quot;#AccessibleContext&quot;&gt;의 AccessibleContext&lt;/a&gt; . 반환 값이 &lt;code&gt;null&lt;/code&gt; 이 아니면 객체는이 인터페이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4176bff2e5f1378ad37d1b8d07311f3665e58076" translate="yes" xml:space="preserve">
          <source>Applications can determine if an object supports the AccessibleComponent interface by first obtaining its &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt; (see &lt;a href=&quot;#Accessible&quot;&gt;Accessible&lt;/a&gt;) and then calling the &lt;code&gt;getAccessibleComponent&lt;/code&gt; method of &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt;. If the return value is not &lt;code&gt;null&lt;/code&gt;, the object supports this interface.</source>
          <target state="translated">객체의 제 1 취득 AccessibleComponent 인터페이스를 지원하는 경우를 판정 할 수 &lt;a href=&quot;#AccessibleContext&quot;&gt;있었던 AccessibleContext&lt;/a&gt; (참조 &lt;a href=&quot;#Accessible&quot;&gt;가능&lt;/a&gt; ) 후 호출 &lt;code&gt;getAccessibleComponent&lt;/code&gt; 의 방법 &lt;a href=&quot;#AccessibleContext&quot;&gt;의 AccessibleContext&lt;/a&gt; . 반환 값이 &lt;code&gt;null&lt;/code&gt; 이 아니면 객체는이 인터페이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="805f6e698e4e5a778689babdaaef18b2c9a9a771" translate="yes" xml:space="preserve">
          <source>Applications can determine if an object supports the AccessibleSelection interface by first obtaining its &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt; (see &lt;a href=&quot;#Accessible&quot;&gt;Accessible&lt;/a&gt;) and then calling the &lt;code&gt;getAccessibleSelection&lt;/code&gt; method of &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt;. If the return value is not &lt;code&gt;null&lt;/code&gt;, the object supports this interface.</source>
          <target state="translated">객체가 먼저 획득함으로써 AccessibleSelection가 인터페이스를 지원하는 경우를 판정 할 수 &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext를&lt;/a&gt; (참조 &lt;a href=&quot;#Accessible&quot;&gt;가능&lt;/a&gt; ) 후 호출 &lt;code&gt;getAccessibleSelection&lt;/code&gt; 의 방법 &lt;a href=&quot;#AccessibleContext&quot;&gt;의 AccessibleContext&lt;/a&gt; . 반환 값이 &lt;code&gt;null&lt;/code&gt; 이 아니면 객체는이 인터페이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d9bef358388a33dfb6045c18f6c5fcfcb395e149" translate="yes" xml:space="preserve">
          <source>Applications can determine if an object supports the AccessibleText interface by first obtaining its &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt; (see &lt;a href=&quot;#Accessible&quot;&gt;Accessible&lt;/a&gt;) and then calling the &lt;code&gt;getAccessibleText&lt;/code&gt; method of &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt;. If the return value is not &lt;code&gt;null&lt;/code&gt;, the object supports this interface.</source>
          <target state="translated">객체가 먼저 획득함으로써 AccessibleText가 인터페이스를 지원하는지 여부를 판정 할 수 &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext를&lt;/a&gt; (참조 &lt;a href=&quot;#Accessible&quot;&gt;편의&lt;/a&gt; 호출 한 후) 및 &lt;code&gt;getAccessibleText&lt;/code&gt; 의 방법 &lt;a href=&quot;#AccessibleContext&quot;&gt;의 AccessibleContext&lt;/a&gt; . 반환 값이 &lt;code&gt;null&lt;/code&gt; 이 아니면 객체는이 인터페이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cb769fe735c3907709ceb6b86e554b1edfc1f302" translate="yes" xml:space="preserve">
          <source>Applications can determine if an object supports the AccessibleValue interface by first obtaining its &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt; (see &lt;a href=&quot;#Accessible&quot;&gt;Accessible&lt;/a&gt;) and then calling the &lt;code&gt;getAccessibleValue&lt;/code&gt; method of &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext&lt;/a&gt;. If the return value is not &lt;code&gt;null&lt;/code&gt;, the object supports this interface.</source>
          <target state="translated">객체가 먼저 획득함으로써 AccessibleValue가 인터페이스를 지원하는지 여부를 판정 할 수 &lt;a href=&quot;#AccessibleContext&quot;&gt;AccessibleContext를&lt;/a&gt; (참조 &lt;a href=&quot;#Accessible&quot;&gt;편의&lt;/a&gt; 호출 한 후) 및 &lt;code&gt;getAccessibleValue&lt;/code&gt; 의 방법 &lt;a href=&quot;#AccessibleContext&quot;&gt;의 AccessibleContext&lt;/a&gt; . 반환 값이 &lt;code&gt;null&lt;/code&gt; 이 아니면 객체는이 인터페이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6c566cba08b160bf81fb42960c8496da9c9443bf" translate="yes" xml:space="preserve">
          <source>Applications can form a &lt;code&gt;WebRowSet&lt;/code&gt; object from the &lt;code&gt;CachedRowSet&lt;/code&gt; object returned by this method in order to export the &lt;code&gt;RowSet&lt;/code&gt; schema definition to XML for future use.</source>
          <target state="translated">응용 프로그램은 나중에 사용 하기 위해 &lt;code&gt;RowSet&lt;/code&gt; 스키마 정의를 XML 로 내보내기 위해이 메서드에서 반환 된 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체에서 &lt;code&gt;WebRowSet&lt;/code&gt; 개체를 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="848d5fe4fb8d8437ee08a3a497b4e4987d7d51dd" translate="yes" xml:space="preserve">
          <source>Applications can obtain instances of this class by calling &lt;a href=&quot;terminalfactory#terminals()&quot;&gt;TerminalFactory.terminals()&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;terminalfactory#terminals()&quot;&gt;TerminalFactory.terminals ()&lt;/a&gt; 를 호출하여이 클래스의 인스턴스를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99ab44a57e9dc2d6d20f4b64c0c5db1c3f3f24ee" translate="yes" xml:space="preserve">
          <source>Applications can override this method in subclasses of &lt;code&gt;ThreadGroup&lt;/code&gt; to provide alternative handling of uncaught exceptions.</source>
          <target state="translated">응용 프로그램 은 잡히지 않은 예외에 대한 대체 처리를 제공하기 위해 &lt;code&gt;ThreadGroup&lt;/code&gt; 의 서브 클래스에서이 메소드를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ed1edc0226a5b9fdb98ea718f5c59aef398e3b0" translate="yes" xml:space="preserve">
          <source>Applications can specify &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances returned by the &lt;code&gt;getControl&lt;/code&gt; factory methods or created from a subclass of &lt;code&gt;ResourceBundle.Control&lt;/code&gt; to customize the bundle loading process. The following are examples of changing the default bundle loading process.</source>
          <target state="translated">애플리케이션은 &lt;code&gt;getControl&lt;/code&gt; 팩토리 메소드가 리턴 하거나 &lt;code&gt;ResourceBundle.Control&lt;/code&gt; 의 서브 클래스에서 작성된 &lt;code&gt;ResourceBundle.Control&lt;/code&gt; 인스턴스 를 지정하여 번들로드 프로세스를 사용자 정의 할 수 있습니다. 다음은 기본 번들로드 프로세스를 변경하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="c0f4b582b88b3d6f1c2968f7d0f433534f21b7f4" translate="yes" xml:space="preserve">
          <source>Applications can subclass this class to indicate similar exceptions.</source>
          <target state="translated">응용 프로그램은이 예외를 나타 내기 위해이 클래스를 서브 클래 싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5639adf96080f7fa0d069edeab3220011ef933f" translate="yes" xml:space="preserve">
          <source>Applications can use a &lt;code&gt;StreamPrintService&lt;/code&gt; obtained from a factory in place of a &lt;code&gt;PrintService&lt;/code&gt; which represents a physical printer device.</source>
          <target state="translated">응용 프로그램은 실제 프린터 장치를 나타내는 &lt;code&gt;PrintService&lt;/code&gt; 대신 공장에서 얻은 &lt;code&gt;StreamPrintService&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a0deb30755c5eafb7d8d8ce8df9ecc03af2ede9" translate="yes" xml:space="preserve">
          <source>Applications have to ensure that exclusive access is correctly released. This can be achieved by executing the &lt;code&gt;beginExclusive()&lt;/code&gt; and &lt;code&gt;endExclusive&lt;/code&gt; calls in a &lt;code&gt;try ... finally&lt;/code&gt; block.</source>
          <target state="translated">응용 프로그램은 독점 액세스가 올바르게 해제되었는지 확인해야합니다. &lt;code&gt;try ... finally&lt;/code&gt; 블록 에서 &lt;code&gt;beginExclusive()&lt;/code&gt; 및 &lt;code&gt;endExclusive&lt;/code&gt; 호출 을 실행하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="3963cd69ff2fadde570d87ead539525be2c79bb1" translate="yes" xml:space="preserve">
          <source>Applications implement subclasses of &lt;code&gt;ClassLoader&lt;/code&gt; in order to extend the manner in which the Java virtual machine dynamically loads classes.</source>
          <target state="translated">애플리케이션 은 Java 가상 머신이 동적으로 클래스를로드하는 방식을 확장하기 위해 &lt;code&gt;ClassLoader&lt;/code&gt; 의 서브 클래스를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="be8a4811cc1fccfd081cd55755b371f53d7a6c32" translate="yes" xml:space="preserve">
          <source>Applications locate instances of this class by calling the &lt;a href=&quot;#lookupStreamPrintServiceFactories(javax.print.DocFlavor,java.lang.String)&quot;&gt;&lt;code&gt;lookupStreamPrintServiceFactories(DocFlavor, String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;#lookupStreamPrintServiceFactories(javax.print.DocFlavor,java.lang.String)&quot;&gt; &lt;code&gt;lookupStreamPrintServiceFactories(DocFlavor, String)&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여이 클래스의 인스턴스를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4bc5621eb479f9d5877f4770a5ce46653ea10b" translate="yes" xml:space="preserve">
          <source>Applications locate instances of this class by calling the &lt;a href=&quot;streamprintservicefactory#lookupStreamPrintServiceFactories-javax.print.DocFlavor-java.lang.String-&quot;&gt;&lt;code&gt;lookupStreamPrintServiceFactories(DocFlavor, String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;streamprintservicefactory#lookupStreamPrintServiceFactories-javax.print.DocFlavor-java.lang.String-&quot;&gt; &lt;code&gt;lookupStreamPrintServiceFactories(DocFlavor, String)&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여이 클래스의 인스턴스를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="493c346b5bac7af3f7bdee8467d56ce170c93671" translate="yes" xml:space="preserve">
          <source>Applications may not invoke this method while a parse is in progress (they should create a new Parser instead for each additional XML document). Once a parse is complete, an application may reuse the same Parser object, possibly with a different input source.</source>
          <target state="translated">응용 프로그램은 구문 분석이 진행되는 동안이 메서드를 호출 할 수 없습니다 (각 추가 XML 문서에 대해 대신 새 구문 분석기를 만들어야 함). 구문 분석이 완료되면 응용 프로그램은 동일한 Parser 개체를 다른 입력 소스와 함께 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d09f696befdb9d57275ea4e57836585e74b89fd" translate="yes" xml:space="preserve">
          <source>Applications may not invoke this method while a parse is in progress (they should create a new XMLReader instead for each nested XML document). Once a parse is complete, an application may reuse the same XMLReader object, possibly with a different input source. Configuration of the XMLReader object (such as handler bindings and values established for feature flags and properties) is unchanged by completion of a parse, unless the definition of that aspect of the configuration explicitly specifies other behavior. (For example, feature flags or properties exposing characteristics of the document being parsed.)</source>
          <target state="translated">응용 프로그램은 구문 분석이 진행되는 동안이 메서드를 호출 할 수 없습니다 (중첩 된 각 XML 문서에 대해 대신 새 XMLReader를 만들어야 함). 구문 분석이 완료되면 응용 프로그램은 동일한 XMLReader 객체를 다른 입력 소스와 함께 재사용 할 수 있습니다. XMLReader 개체의 구성 (예 : 기능 플래그 및 속성에 대해 설정된 처리기 바인딩 및 값)은 구성의 해당 측면에 대한 정의가 명시 적으로 다른 동작을 지정하지 않는 한 구문 분석이 완료 되어도 변경되지 않습니다. (예를 들어, 구문 분석중인 문서의 특성을 노출하는 기능 플래그 또는 속성)</target>
        </trans-unit>
        <trans-unit id="e78e65ff374391f1ab4f62a14ea9dc6e2e303832" translate="yes" xml:space="preserve">
          <source>Applications may override any default GUIs and provide their own controllers embedded in their own framework. All that is required is that the &lt;code&gt;activate&lt;/code&gt; method behave modally (not returning until either cancelled or committed), though it need not put up an explicitly modal dialog. Such a non-modal GUI component would be coded roughly as follows:</source>
          <target state="translated">애플리케이션은 기본 GUI를 재정의하고 자체 프레임 워크에 포함 된 자체 컨트롤러를 제공 할 수 있습니다. 필요한 것은 &lt;code&gt;activate&lt;/code&gt; 메서드가 모달 방식으로 동작하는 것뿐입니다 (취소되거나 커밋 될 때까지 반환되지 않음). 명시 적으로 모달 대화 상자를 표시 할 필요는 없습니다. 이러한 비 모달 GUI 구성 요소는 대략 다음과 같이 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="4b587573b858a58a96fa5abac5ee6d8933768d15" translate="yes" xml:space="preserve">
          <source>Applications may override any default GUIs and provide their own controllers embedded in their own framework. All that is required is that the&lt;code&gt;activate&lt;/code&gt; method behave modally (not returning until either cancelled or committed), though it need not put up an explicitly modal dialog. Such a non-modal GUI component would be coded roughly as follows:</source>
          <target state="translated">응용 프로그램은 기본 GUI를 무시하고 자체 프레임 워크에 내장 된 자체 컨트롤러를 제공 할 수 있습니다. 필요한 것은 &lt;code&gt;activate&lt;/code&gt; 메소드가 명시 적으로 모달 대화 상자를 표시 할 필요는 없지만 모달로 (취소하거나 커미트 될 때까지 리턴하지 않음) 작동하는 것입니다. 이러한 비 모달 GUI 구성 요소는 대략 다음과 같이 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="12e0a28eb3da6b82bdbca83b99663ba8b878dc31" translate="yes" xml:space="preserve">
          <source>Applications may register a new or different entity resolver in the middle of a parse, and the SAX parser must begin using the new resolver immediately.</source>
          <target state="translated">응용 프로그램은 구문 분석 중에 새롭거나 다른 엔티티 확인자를 등록 할 수 있으며 SAX 구문 분석기는 즉시 새 확인자를 사용하기 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb83f4c4e3f9ac4e3ace42a53002fec40835c90b" translate="yes" xml:space="preserve">
          <source>Applications may register a new or different handler in the middle of a parse, and the SAX parser must begin using the new handler immediately.</source>
          <target state="translated">응용 프로그램은 구문 분석 중에 새 처리기 또는 다른 처리기를 등록 할 수 있으며 SAX 파서는 즉시 새 처리기를 사용하기 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="d5ea9e7d4716fdd3b357b22b1ab31a181081d121" translate="yes" xml:space="preserve">
          <source>Applications may register a new or different resolver in the middle of a parse, and the SAX parser must begin using the new resolver immediately.</source>
          <target state="translated">응용 프로그램은 구문 분석 중에 새 또는 다른 해결 프로그램을 등록 할 수 있으며 SAX 구문 분석기는 즉시 새 해결 프로그램 사용을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="8479d65a0cb75ab17ac2952d57865056d13ec785" translate="yes" xml:space="preserve">
          <source>Applications may use setPublicId to include a public identifier as well, or setEncoding to specify the character encoding, if known.</source>
          <target state="translated">응용 프로그램은 setPublicId를 사용하여 공용 식별자도 포함하거나 setEncoding을 사용하여 알려진 경우 문자 인코딩을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ab22008fe450339467853779a771cc39c1b147" translate="yes" xml:space="preserve">
          <source>Applications may use the &lt;code&gt;DatabaseMetaData.getClientInfoProperties&lt;/code&gt; method to determine the client info properties supported by the driver and the maximum length that may be specified for each property.</source>
          <target state="translated">애플리케이션은 &lt;code&gt;DatabaseMetaData.getClientInfoProperties&lt;/code&gt; 메소드를 사용하여 드라이버가 지원하는 클라이언트 정보 속성과 각 속성에 대해 지정할 수있는 최대 길이를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86abca252c8dc1fc986531ce260cb232f29e5150" translate="yes" xml:space="preserve">
          <source>Applications may use the &lt;code&gt;DatabaseMetaData.getClientInfoProperties&lt;/code&gt; method to determine the client info properties supported by the driver.</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;DatabaseMetaData.getClientInfoProperties&lt;/code&gt; 메서드를 사용 하여 드라이버에서 지원하는 클라이언트 정보 속성을 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8c1f1a0575644de66b4266591eea42ecef57ba2" translate="yes" xml:space="preserve">
          <source>Applications might choose to process delegated tasks in different threads. When an &lt;code&gt;SSLEngine&lt;/code&gt; is created, the current &lt;a href=&quot;../../../java/security/accesscontrolcontext&quot;&gt;&lt;code&gt;AccessControlContext&lt;/code&gt;&lt;/a&gt; is saved. All future delegated tasks will be processed using this context: that is, all access control decisions will be made using the context captured at engine creation.</source>
          <target state="translated">응용 프로그램은 다른 스레드에서 위임 된 작업을 처리하도록 선택할 수 있습니다. 때 &lt;code&gt;SSLEngine&lt;/code&gt; 생성되고, 현재 &lt;a href=&quot;../../../java/security/accesscontrolcontext&quot;&gt; &lt;code&gt;AccessControlContext&lt;/code&gt; &lt;/a&gt; 저장됩니다. 향후 모든 위임 된 작업은이 컨텍스트를 사용하여 처리됩니다. 즉, 모든 액세스 제어 결정은 엔진 생성시 캡처 된 컨텍스트를 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2c21b853c91398004c3c0d3991f71ec0b5c8541a" translate="yes" xml:space="preserve">
          <source>Applications must ensure that &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;../../../org/xml/sax/contenthandler#startPrefixMapping(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;ContentHandler.startPrefixMapping(String,String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../org/xml/sax/contenthandler#endPrefixMapping(java.lang.String)&quot;&gt;&lt;code&gt;ContentHandler.endPrefixMapping(String)&lt;/code&gt;&lt;/a&gt; are invoked properly. Similarly, the user-specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; will receive startPrefixMapping/endPrefixMapping events. If the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; introduces additional namespace bindings, the user-specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; will receive additional startPrefixMapping/endPrefixMapping events.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../../org/xml/sax/contenthandler#startPrefixMapping(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;ContentHandler.startPrefixMapping(String,String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../org/xml/sax/contenthandler#endPrefixMapping(java.lang.String)&quot;&gt; &lt;code&gt;ContentHandler.endPrefixMapping(String)&lt;/code&gt; &lt;/a&gt; 이 올바르게 호출되었는지 확인해야합니다. 마찬가지로 사용자 지정 &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 는 startPrefixMapping / endPrefixMapping 이벤트를 수신합니다. &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; 가 추가 네임 스페이스 바인딩을 도입 하는 경우 사용자 지정 &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 는 추가 startPrefixMapping / endPrefixMapping 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a4f08185d62df49415723581536be4829452fc6a" translate="yes" xml:space="preserve">
          <source>Applications needing to implement custom handling for external resources can implement this interface and register their implementation by setting the &quot;resource-resolver&quot; parameter of &lt;code&gt;DOMConfiguration&lt;/code&gt; objects attached to &lt;code&gt;LSParser&lt;/code&gt; and &lt;code&gt;LSSerializer&lt;/code&gt;. It can also be register on &lt;code&gt;DOMConfiguration&lt;/code&gt; objects attached to &lt;code&gt;Document&lt;/code&gt; if the &quot;LS&quot; feature is supported.</source>
          <target state="translated">외부 리소스에 대한 사용자 지정 처리를 구현해야하는 응용 프로그램 은 &lt;code&gt;LSParser&lt;/code&gt; 및 &lt;code&gt;LSSerializer&lt;/code&gt; 에 연결된 &lt;code&gt;DOMConfiguration&lt;/code&gt; 개체 의 &quot;resource-resolver&quot;매개 변수를 설정하여이 인터페이스를 구현하고 구현을 등록 할 수 있습니다 . &quot;LS&quot;기능이 지원되는 경우 &lt;code&gt;Document&lt;/code&gt; 에 첨부 된 &lt;code&gt;DOMConfiguration&lt;/code&gt; 객체에 등록 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4272d2b9f815f524c6f692c44d6448c0e43bc509" translate="yes" xml:space="preserve">
          <source>Applications or applets that use an exemption mechanism may be granted stronger encryption capabilities than those which don't.</source>
          <target state="translated">예외 메커니즘을 사용하는 응용 프로그램 또는 애플릿에는 그렇지 않은 응용 프로그램보다 강력한 암호화 기능이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34e45e56b7625b178f394ccedba2bf275358f9a" translate="yes" xml:space="preserve">
          <source>Applications should normally obtain an instance from &lt;a href=&quot;zonerules&quot;&gt;&lt;code&gt;ZoneRules&lt;/code&gt;&lt;/a&gt;. This factory is only intended for use when creating &lt;a href=&quot;zonerules&quot;&gt;&lt;code&gt;ZoneRules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 일반적으로 &lt;a href=&quot;zonerules&quot;&gt; &lt;code&gt;ZoneRules&lt;/code&gt; &lt;/a&gt; 에서 인스턴스를 가져와야 합니다. 이 팩토리는 &lt;a href=&quot;zonerules&quot;&gt; &lt;code&gt;ZoneRules&lt;/code&gt; 를&lt;/a&gt; 만들 때만 사용하도록되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="856e62d7222e9db0956537129ad5bbf3467b3d25" translate="yes" xml:space="preserve">
          <source>Applications should not add children directly to the scrollpane.</source>
          <target state="translated">응용 프로그램은 스크롤 창에 직접 자식을 추가해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="962732fa9130bc39a7c591ac82bbfe99253b366a" translate="yes" xml:space="preserve">
          <source>Applications should not create their own file descriptors.</source>
          <target state="translated">응용 프로그램은 자체 파일 설명자를 만들면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="011adffeaaf1e10d2cacbfcf3b993f3a66b5e494" translate="yes" xml:space="preserve">
          <source>Applications should not normally invoke this method directly.</source>
          <target state="translated">애플리케이션은 일반적으로이 메소드를 직접 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bff34b849d467e1176772314869bdf7c54563ef2" translate="yes" xml:space="preserve">
          <source>Applications should throw instances of this class to indicate other illegal uses of the &lt;code&gt;null&lt;/code&gt; object. &lt;code&gt;NullPointerException&lt;/code&gt; objects may be constructed by the virtual machine as if &lt;a href=&quot;throwable#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;suppression were disabled and/or the stack trace was not writable&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은이 클래스의 인스턴스를 throw하여 &lt;code&gt;null&lt;/code&gt; 개체 의 다른 불법 사용을 나타내야 합니다. &lt;code&gt;NullPointerException&lt;/code&gt; 개체는 &lt;a href=&quot;throwable#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;억제가 비활성화되었거나 스택 추적이 쓰기 불가능한&lt;/a&gt; 것처럼 가상 머신에 의해 생성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c6a7fe42dc9ff4200bf574b34466584498c0fd3" translate="yes" xml:space="preserve">
          <source>Applications should throw instances of this class to indicate other illegal uses of the &lt;code&gt;null&lt;/code&gt; object. &lt;code&gt;NullPointerException&lt;/code&gt; objects may be constructed by the virtual machine as if &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;suppression were disabled and/or the stack trace was not writable&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;null&lt;/code&gt; 객체 의 다른 불법적 인 사용을 나타 내기 위해이 클래스의 인스턴스를 던져야 합니다. &lt;code&gt;NullPointerException&lt;/code&gt; 개체는 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;억제가 비활성화되거나 스택 추적이 쓰기 가능하지 않은&lt;/a&gt; 것처럼 가상 컴퓨터에 의해 생성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe25f35fb35beeb62ad61ab8f11a46b5fdc2ce40" translate="yes" xml:space="preserve">
          <source>Applications that need to define a subclass of &lt;code&gt;InputStream&lt;/code&gt; must always provide a method that returns the next byte of input.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 의 서브 클래스를 정의해야하는 응용 프로그램 은 항상 다음 바이트 입력을 리턴하는 메소드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="31880f2fe972133fb48d5fdc09b7d923da0cb8a5" translate="yes" xml:space="preserve">
          <source>Applications that need to define a subclass of &lt;code&gt;OutputStream&lt;/code&gt; must always provide at least a method that writes one byte of output.</source>
          <target state="translated">&lt;code&gt;OutputStream&lt;/code&gt; 의 서브 클래스를 정의해야하는 응용 프로그램 은 항상 1 바이트의 출력을 작성하는 메소드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8847b03a0b6b50f755539e3509745b4d6d7a081" translate="yes" xml:space="preserve">
          <source>Applications that override the &lt;code&gt;clone&lt;/code&gt; method can also throw this exception to indicate that an object could not or should not be cloned.</source>
          <target state="translated">&lt;code&gt;clone&lt;/code&gt; 메서드 를 재정의하는 응용 프로그램은 이 예외를 발생시켜 개체를 복제 할 수 없거나 복제 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0130a94bc9bd195ae61ee9f02357e4650f694ab4" translate="yes" xml:space="preserve">
          <source>Applications that use Robot for purposes other than self-testing should handle these error conditions gracefully.</source>
          <target state="translated">자체 테스트 이외의 목적으로 Robot을 사용하는 애플리케이션은 이러한 오류 조건을 적절하게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdfc5456438722c57e4af0077c329cc9dc195e2e" translate="yes" xml:space="preserve">
          <source>Applications that want a stricter policy should override this method. If this method is overridden, the method that overrides it should additionally check to see if the calling thread has the &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission, and if so, return silently. This is to ensure that code granted that permission (such as the JDK itself) is allowed to manipulate any thread.</source>
          <target state="translated">보다 엄격한 정책을 원하는 응용 프로그램은이 방법을 재정의해야합니다. 이 메서드를 재정의하는 경우, 메서드를 재정의하는 메서드는 호출 스레드에 &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; 권한 이 있는지 확인하여 추가로 확인해야합니다 . 이는 JDK 자체와 같은 해당 권한이 부여 된 코드가 스레드를 조작 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="34e2d7454bea95269be25ddc380b555451ae0748" translate="yes" xml:space="preserve">
          <source>Applications that want a stricter policy should override this method. If this method is overridden, the method that overrides it should additionally check to see if the calling thread has the &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission, and if so, return silently. This is to ensure that code granted that permission (such as the JDK itself) is allowed to manipulate any thread.</source>
          <target state="translated">보다 엄격한 정책을 원하는 응용 프로그램은이 방법을 재정의해야합니다. 이 메서드를 재정의하는 경우 메서드를 재정의하는 메서드는 호출 스레드에 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 권한 이 있는지 확인하여 추가로 확인해야합니다 . 이는 JDK 자체와 같은 해당 권한이 부여 된 코드가 스레드를 조작 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5fcbc2973f8b1d1a961945bac1ca8ebc1df910f" translate="yes" xml:space="preserve">
          <source>Applications use only the static methods of this abstract class. The instance methods are implemented by a service provider in a subclass and the unification of the results from all installed lookup classes are reported by the static methods of this class when called by the application.</source>
          <target state="translated">어플리케이션은이 추상 클래스의 정적 메소드 만 사용합니다. 인스턴스 메소드는 서브 클래스에서 서비스 제공자에 의해 구현되며, 설치된 모든 검색 클래스의 결과 통일은 애플리케이션에 의해 호출 될 때이 클래스의 정적 메소드에 의해보고됩니다.</target>
        </trans-unit>
        <trans-unit id="71f0645594ce5b298e9e02a37a9af1da7ec30fa8" translate="yes" xml:space="preserve">
          <source>Applications use the &lt;code&gt;DataSource&lt;/code&gt; and &lt;code&gt;RowSet&lt;/code&gt; APIs directly, but the connection pooling and distributed transaction APIs are used internally by the middle-tier infrastructure.</source>
          <target state="translated">애플리케이션은 &lt;code&gt;DataSource&lt;/code&gt; 및 &lt;code&gt;RowSet&lt;/code&gt; API를 직접 사용하지만 연결 풀링 및 분산 트랜잭션 API는 중간 계층 인프라에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b3abfab5d4a29aa5145237a84cef9c01d1b2a62" translate="yes" xml:space="preserve">
          <source>Applications use this class by overriding &lt;a href=&quot;#getPasswordAuthentication()&quot;&gt;&lt;code&gt;getPasswordAuthentication()&lt;/code&gt;&lt;/a&gt; in a sub-class. This method will typically use the various getXXX() accessor methods to get information about the entity requesting authentication. It must then acquire a username and password either by interacting with the user or through some other non-interactive means. The credentials are then returned as a &lt;a href=&quot;passwordauthentication&quot;&gt;&lt;code&gt;PasswordAuthentication&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="translated">애플리케이션 은 하위 클래스에서 &lt;a href=&quot;#getPasswordAuthentication()&quot;&gt; &lt;code&gt;getPasswordAuthentication()&lt;/code&gt; &lt;/a&gt; 을 재정 의하여이 클래스를 사용합니다 . 이 메소드는 일반적으로 인증을 요청하는 엔티티에 대한 정보를 얻기 위해 다양한 getXXX () 접근 자 메소드를 사용합니다. 그런 다음 사용자와 상호 작용하거나 다른 비대화 형 수단을 통해 사용자 이름과 암호를 획득해야합니다. 그런 다음 자격 증명은 &lt;a href=&quot;passwordauthentication&quot;&gt; &lt;code&gt;PasswordAuthentication&lt;/code&gt; &lt;/a&gt; 반환 값 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8085b2ec40f77a6963a9d772f8821a4a760738cb" translate="yes" xml:space="preserve">
          <source>Applications use this class by overriding &lt;a href=&quot;authenticator#getPasswordAuthentication--&quot;&gt;&lt;code&gt;getPasswordAuthentication()&lt;/code&gt;&lt;/a&gt; in a sub-class. This method will typically use the various getXXX() accessor methods to get information about the entity requesting authentication. It must then acquire a username and password either by interacting with the user or through some other non-interactive means. The credentials are then returned as a &lt;a href=&quot;passwordauthentication&quot;&gt;&lt;code&gt;PasswordAuthentication&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="translated">응용 프로그램 은 하위 클래스에서 &lt;a href=&quot;authenticator#getPasswordAuthentication--&quot;&gt; &lt;code&gt;getPasswordAuthentication()&lt;/code&gt; &lt;/a&gt; 을 재정 의하여이 클래스를 사용합니다 . 이 메소드는 일반적으로 다양한 getXXX () 접근 자 메소드를 사용하여 인증을 요청하는 엔티티에 대한 정보를 가져옵니다. 그런 다음 사용자와 상호 작용하거나 다른 비 대화식 수단을 통해 사용자 이름과 비밀번호를 얻어야합니다. 그런 다음 신임 정보는 &lt;a href=&quot;passwordauthentication&quot;&gt; &lt;code&gt;PasswordAuthentication&lt;/code&gt; &lt;/a&gt; 리턴 값 으로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9af378508928918978a91b776f2d39c8dbd80a3" translate="yes" xml:space="preserve">
          <source>Applications using this factory method are providing hints for an internal session reuse strategy.</source>
          <target state="translated">이 팩토리 방법을 사용하는 애플리케이션은 내부 세션 재사용 전략에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a41b269f9b80c25739f1b1837b9eea19b5c0ff21" translate="yes" xml:space="preserve">
          <source>Applications using this factory method are providing no hints for an internal session reuse strategy. If hints are desired, &lt;a href=&quot;#createSSLEngine(java.lang.String,int)&quot;&gt;&lt;code&gt;createSSLEngine(String, int)&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">이 팩토리 방법을 사용하는 애플리케이션은 내부 세션 재사용 전략에 대한 힌트를 제공하지 않습니다. 힌트가 필요한 경우 대신 &lt;a href=&quot;#createSSLEngine(java.lang.String,int)&quot;&gt; &lt;code&gt;createSSLEngine(String, int)&lt;/code&gt; &lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2e3472131ccf5e729e75486c663694dc0281794" translate="yes" xml:space="preserve">
          <source>Applications using this factory method are providing no hints for an internal session reuse strategy. If hints are desired, &lt;a href=&quot;#engineCreateSSLEngine(java.lang.String,int)&quot;&gt;&lt;code&gt;engineCreateSSLEngine(String, int)&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">이 팩토리 방법을 사용하는 애플리케이션은 내부 세션 재사용 전략에 대한 힌트를 제공하지 않습니다. 힌트가 필요한 경우 &lt;a href=&quot;#engineCreateSSLEngine(java.lang.String,int)&quot;&gt; &lt;code&gt;engineCreateSSLEngine(String, int)&lt;/code&gt; &lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed7bfe89dc2287b744eafdd591732d2e9fb94e52" translate="yes" xml:space="preserve">
          <source>Applications using this factory method are providing no hints for an internal session reuse strategy. If hints are desired, &lt;a href=&quot;sslcontext#createSSLEngine-java.lang.String-int-&quot;&gt;&lt;code&gt;createSSLEngine(String, int)&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">이 팩토리 방법을 사용하는 애플리케이션은 내부 세션 재사용 전략에 대한 힌트를 제공하지 않습니다. 힌트가 필요한 경우, &lt;a href=&quot;sslcontext#createSSLEngine-java.lang.String-int-&quot;&gt; &lt;code&gt;createSSLEngine(String, int)&lt;/code&gt; &lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6739fbed1280ca989694c5498cfd3c0394faccc4" translate="yes" xml:space="preserve">
          <source>Applications using this factory method are providing no hints for an internal session reuse strategy. If hints are desired, &lt;a href=&quot;sslcontextspi#engineCreateSSLEngine-java.lang.String-int-&quot;&gt;&lt;code&gt;engineCreateSSLEngine(String, int)&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">이 팩토리 방법을 사용하는 애플리케이션은 내부 세션 재사용 전략에 대한 힌트를 제공하지 않습니다. 힌트가 필요한 경우 대신 &lt;a href=&quot;sslcontextspi#engineCreateSSLEngine-java.lang.String-int-&quot;&gt; &lt;code&gt;engineCreateSSLEngine(String, int)&lt;/code&gt; &lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="174371772db23b6e9faea3024b79602067942aaa" translate="yes" xml:space="preserve">
          <source>Applications will create a credential object passing the desired parameters. The application can then use the query methods to obtain specific information about the instantiated credential object. When the credential is no longer needed, the application should call the &lt;a href=&quot;#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method to release any resources held by the credential object and to destroy any cryptographically sensitive information.</source>
          <target state="translated">응용 프로그램은 원하는 매개 변수를 전달하는 자격 증명 개체를 만듭니다. 그런 다음 응용 프로그램은 쿼리 메서드를 사용하여 인스턴스화 된 자격 증명 개체에 대한 특정 정보를 얻을 수 있습니다. 자격 증명이 더 이상 필요하지 않은 경우 응용 프로그램은 &lt;a href=&quot;#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하여 자격 증명 개체가 보유한 모든 리소스를 해제하고 암호 적으로 민감한 정보를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="7887c222c6fe399a39e8e8a65758153aeb03db5e" translate="yes" xml:space="preserve">
          <source>Applies SSLParameters to newly accepted connections.</source>
          <target state="translated">SSLParameters를 새로 허용 된 연결에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="79ba78d7bcdd2ef1aa6315a8bc3d5a4431396b29" translate="yes" xml:space="preserve">
          <source>Applies SSLParameters to this engine.</source>
          <target state="translated">이 엔진에 SSLParameters를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="e85201a8248d6af8e821fba56acc7387166ad503" translate="yes" xml:space="preserve">
          <source>Applies SSLParameters to this socket.</source>
          <target state="translated">이 소켓에 SSLParameters를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0b85f712b61c24db5923e83d81bcc03c037eb36a" translate="yes" xml:space="preserve">
          <source>Applies a visitor to this directive.</source>
          <target state="translated">이 지시문에 방문자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f70e5aa14b98d061b144c57c1d08e4e87dea1418" translate="yes" xml:space="preserve">
          <source>Applies a visitor to this element.</source>
          <target state="translated">이 요소에 방문자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="69489835c4b5d6eb7e6d279c3ea83008ccf5e5c3" translate="yes" xml:space="preserve">
          <source>Applies a visitor to this type.</source>
          <target state="translated">이 유형에 방문자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="1411b1eda0cd57f82271f22c2d75ff3043a054c4" translate="yes" xml:space="preserve">
          <source>Applies a visitor to this value.</source>
          <target state="translated">이 값에 방문자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="e8e3598101e8440656d941dd38f4235e12b1316f" translate="yes" xml:space="preserve">
          <source>Applies capture conversion to a type.</source>
          <target state="translated">캡처 변환을 유형으로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="5cf560b44948d66af3e69c3ef06fa9ba31c7cb6c" translate="yes" xml:space="preserve">
          <source>Applies per-message security services over the established security context using streams. The method will return a token with the application supplied data and a cryptographic MIC over it. The data may be encrypted if confidentiality (privacy) was requested. This method is equivalent to the byte array based &lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스트림을 사용하여 설정된 보안 컨텍스트에 메시지 별 보안 서비스를 적용합니다. 이 메서드는 애플리케이션에서 제공 한 데이터와 그 위에 암호화 MIC가있는 토큰을 반환합니다. 기밀성 (개인 정보 보호)이 요청 된 경우 데이터가 암호화 될 수 있습니다. 이 메서드는 바이트 배열 기반 &lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap&lt;/code&gt; &lt;/a&gt; 메서드 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d50cd1691b9234a78c92d28bb0b2c107c36c943c" translate="yes" xml:space="preserve">
          <source>Applies per-message security services over the established security context.</source>
          <target state="translated">설정된 보안 컨텍스트를 통해 메시지 별 보안 서비스를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="9b0ac9b16527196413ad532b5060c5eb8219b1e0" translate="yes" xml:space="preserve">
          <source>Applies per-message security services over the established security context. The method will return a token with the application supplied data and a cryptographic MIC over it. The data may be encrypted if confidentiality (privacy) was requested.</source>
          <target state="translated">설정된 보안 컨텍스트를 통해 메시지 별 보안 서비스를 적용합니다. 이 메서드는 애플리케이션에서 제공 한 데이터와 그 위에 암호화 MIC가있는 토큰을 반환합니다. 기밀성 (개인 정보 보호)이 요청 된 경우 데이터가 암호화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3d959679821060b0a8dda5f78ba65f52b2da2c7" translate="yes" xml:space="preserve">
          <source>Applies the &lt;code&gt;AttributeValueExp&lt;/code&gt; on an MBean.</source>
          <target state="translated">MBean에 &lt;code&gt;AttributeValueExp&lt;/code&gt; 를 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="22c9e18e5a5fe0b138e9c7059d5c927f19cffe9b" translate="yes" xml:space="preserve">
          <source>Applies the &lt;code&gt;AttributeValueExp&lt;/code&gt; on an MBean. This method calls &lt;a href=&quot;#getAttribute(javax.management.ObjectName)&quot;&gt;&lt;code&gt;getAttribute(name)&lt;/code&gt;&lt;/a&gt; and wraps the result as a &lt;code&gt;ValueExp&lt;/code&gt;. The value returned by &lt;code&gt;getAttribute&lt;/code&gt; must be a &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, or &lt;code&gt;Boolean&lt;/code&gt;; otherwise this method throws a &lt;code&gt;BadAttributeValueExpException&lt;/code&gt;, which will cause the containing query to be false for this &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">MBean에 &lt;code&gt;AttributeValueExp&lt;/code&gt; 를 적용합니다 . 이 메서드는 &lt;a href=&quot;#getAttribute(javax.management.ObjectName)&quot;&gt; &lt;code&gt;getAttribute(name)&lt;/code&gt; &lt;/a&gt; 호출 하고 결과를 &lt;code&gt;ValueExp&lt;/code&gt; 로 래핑합니다 . &lt;code&gt;getAttribute&lt;/code&gt; 에 의해 반환되는 값 은 &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;Boolean&lt;/code&gt; 이어야합니다 . 그렇지 않으면이 메서드는 &lt;code&gt;BadAttributeValueExpException&lt;/code&gt; 을 발생시켜 포함하는 쿼리가이 &lt;code&gt;name&lt;/code&gt; 대해 거짓이되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="90ba83081f32c8fadaa4c2055d819807f1fe71e0" translate="yes" xml:space="preserve">
          <source>Applies the &lt;code&gt;AttributeValueExp&lt;/code&gt; on an MBean. This method calls &lt;a href=&quot;attributevalueexp#getAttribute-javax.management.ObjectName-&quot;&gt;&lt;code&gt;getAttribute(name)&lt;/code&gt;&lt;/a&gt; and wraps the result as a &lt;code&gt;ValueExp&lt;/code&gt;. The value returned by &lt;code&gt;getAttribute&lt;/code&gt; must be a &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, or &lt;code&gt;Boolean&lt;/code&gt;; otherwise this method throws a &lt;code&gt;BadAttributeValueExpException&lt;/code&gt;, which will cause the containing query to be false for this &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">MBean에 &lt;code&gt;AttributeValueExp&lt;/code&gt; 를 적용합니다 . 이 메소드는 &lt;a href=&quot;attributevalueexp#getAttribute-javax.management.ObjectName-&quot;&gt; &lt;code&gt;getAttribute(name)&lt;/code&gt; &lt;/a&gt; 호출 하고 결과를 &lt;code&gt;ValueExp&lt;/code&gt; 로 랩핑합니다 . &lt;code&gt;getAttribute&lt;/code&gt; 에 의해 반환되는 값 은 &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;Boolean&lt;/code&gt; 이어야합니다 . 그렇지 않으면이 메소드는 &lt;code&gt;BadAttributeValueExpException&lt;/code&gt; 을 발생 시켜이 &lt;code&gt;name&lt;/code&gt; 대해 포함 쿼리가 false가 됩니다.</target>
        </trans-unit>
        <trans-unit id="3f54a850faf032d7ed918850b33bbeda8b2dd173" translate="yes" xml:space="preserve">
          <source>Applies the QueryExp on an MBean.</source>
          <target state="translated">MBean에 QueryExp를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a94f537ce9ac93295258fdd4457c71a11f2f575a" translate="yes" xml:space="preserve">
          <source>Applies the ValueExp on a MBean.</source>
          <target state="translated">MBean에 ValueExp를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="56486964cd814481b6bf81aa7aec5bbd43188a97" translate="yes" xml:space="preserve">
          <source>Applies the given &lt;code&gt;Predicate&lt;/code&gt; object to this &lt;code&gt;FilteredRowSet&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;Predicate&lt;/code&gt; 오브젝트를이 &lt;code&gt;FilteredRowSet&lt;/code&gt; 오브젝트에 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="733b5fca05a0efaf1bbfcaf0a96624fd1615014c" translate="yes" xml:space="preserve">
          <source>Applies the given &lt;code&gt;Predicate&lt;/code&gt; object to this &lt;code&gt;FilteredRowSet&lt;/code&gt; object. The filter applies controls both to inbound and outbound views, constraining which rows are visible and which rows can be manipulated.</source>
          <target state="translated">지정된 &lt;code&gt;Predicate&lt;/code&gt; 오브젝트를이 &lt;code&gt;FilteredRowSet&lt;/code&gt; 오브젝트에 적용 합니다. 필터는 인바운드 및 아웃 바운드보기 모두에 제어를 적용하여 표시되는 행과 조작 할 수있는 행을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="435f7d09af7ca8afbabdf439428f18a6d6f1b3ad" translate="yes" xml:space="preserve">
          <source>Applies the given attributes to character content.</source>
          <target state="translated">캐릭터 콘텐츠에 주어진 속성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="6eadd3e7034c7bed306e72eb53d5a4cbc1d23dbd" translate="yes" xml:space="preserve">
          <source>Applies the given attributes to character content. If there is a selection, the attributes are applied to the selection range. If there is no selection, the attributes are applied to the input attribute set which defines the attributes for any new text that gets inserted.</source>
          <target state="translated">캐릭터 콘텐츠에 주어진 속성을 적용합니다. 선택 항목이 있으면 속성이 선택 범위에 적용됩니다. 선택 사항이 없으면 삽입되는 새 텍스트에 대한 속성을 정의하는 입력 속성 세트에 속성이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c5a7a8b1e5c1f8a6e8e37e307f22a11ca31c0f" translate="yes" xml:space="preserve">
          <source>Applies the given attributes to paragraphs.</source>
          <target state="translated">주어진 속성을 단락에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="2f8651bf3405a1d9ccef675a7c94e72753149f9e" translate="yes" xml:space="preserve">
          <source>Applies the given attributes to paragraphs. If there is a selection, the attributes are applied to the paragraphs that intersect the selection. If there is no selection, the attributes are applied to the paragraph at the current caret position.</source>
          <target state="translated">주어진 속성을 단락에 적용합니다. 선택 항목이있는 경우 선택 항목과 교차하는 단락에 속성이 적용됩니다. 선택 항목이 없으면 현재 캐럿 위치의 단락에 속성이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fce093abc16868f06fa6d0cf14fcf88a3bd80de1" translate="yes" xml:space="preserve">
          <source>Applies the given attributes to paragraphs. If there is a selection, the attributes are applied to the paragraphs that intersect the selection. if there is no selection, the attributes are applied to the paragraph at the current caret position.</source>
          <target state="translated">주어진 속성을 단락에 적용합니다. 선택 항목이있는 경우 선택 항목과 교차하는 단락에 속성이 적용됩니다. 선택 항목이 없으면 현재 캐럿 위치의 단락에 속성이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5431418c913d0cd8d58500882e9a196a6df9ac82" translate="yes" xml:space="preserve">
          <source>Applies the given function to the stream of &lt;code&gt;StackFrame&lt;/code&gt;s for the current thread, traversing from the top frame of the stack, which is the method calling this &lt;code&gt;walk&lt;/code&gt; method.</source>
          <target state="translated">이 &lt;code&gt;walk&lt;/code&gt; 메서드를 호출하는 메서드 인 스택의 맨 위 프레임에서 순회하면서 현재 스레드에 대한 &lt;code&gt;StackFrame&lt;/code&gt; 의 스트림에 지정된 함수를 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="68ea95622c17c3501a71d389933a811f354722ff" translate="yes" xml:space="preserve">
          <source>Applies the given localized pattern string to this date format.</source>
          <target state="translated">지정된 현지화 된 패턴 문자열을이 날짜 형식에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="97ba7da6b18d975571d7145878622f49090f5a6c" translate="yes" xml:space="preserve">
          <source>Applies the given pattern string to this date format.</source>
          <target state="translated">주어진 패턴 문자열을이 날짜 형식에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="092f9872dea41f81d6bea1b5c9bf378fd0d9503d" translate="yes" xml:space="preserve">
          <source>Applies this function to the given argument.</source>
          <target state="translated">이 함수를 주어진 인수에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="465e66a74ccd22473b9e814ef500f5fd24a7056c" translate="yes" xml:space="preserve">
          <source>Applies this function to the given arguments.</source>
          <target state="translated">이 함수를 주어진 인수에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="1c1cc9ca4c4938bb046e1f73de81d33c228fa5b1" translate="yes" xml:space="preserve">
          <source>Applies this operator to the given operand.</source>
          <target state="translated">이 연산자를 지정된 피연산자에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="09e5471b52d0066b4fed63fbe930ae9e7f66a7de" translate="yes" xml:space="preserve">
          <source>Applies this operator to the given operands.</source>
          <target state="translated">이 연산자를 주어진 피연산자에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="dd284bad21c47b1ab995e58d8cf866b44c9948b5" translate="yes" xml:space="preserve">
          <source>Apply the colors to the destination drawing surface using the current &lt;a href=&quot;composite&quot;&gt;&lt;code&gt;Composite&lt;/code&gt;&lt;/a&gt; attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;Graphics2D&lt;/code&gt; 컨텍스트 에서 현재 &lt;a href=&quot;composite&quot;&gt; &lt;code&gt;Composite&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 대상 그리기 표면에 색상을 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="7ebe72edbd46e861f2348adfa7a6d4c1ff878e69" translate="yes" xml:space="preserve">
          <source>Apply the given pattern to this Format object.</source>
          <target state="translated">이 Format 객체에 주어진 패턴을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="40ea6f9cf1dd9e76881f086c503ed2233392c4f8" translate="yes" xml:space="preserve">
          <source>Apply the given pattern to this Format object. A pattern is a short-hand specification for the various formatting properties. These properties can also be changed individually through the various setter methods.</source>
          <target state="translated">지정된 패턴을이 Format 객체에 적용합니다. 패턴은 다양한 서식 속성에 대한 속기 사양입니다. 이러한 속성은 다양한 설정 방법을 통해 개별적으로 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3394fe6ba8781f349e9d2e8a1f85bedbb590239" translate="yes" xml:space="preserve">
          <source>Apply the given pattern to this Format object. The pattern is assumed to be in a localized notation. A pattern is a short-hand specification for the various formatting properties. These properties can also be changed individually through the various setter methods.</source>
          <target state="translated">지정된 패턴을이 Format 객체에 적용합니다. 패턴은 현지화 된 표기법으로 가정합니다. 패턴은 다양한 서식 속성에 대한 속기 사양입니다. 이러한 속성은 다양한 설정 방법을 통해 개별적으로 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="922f6429d4f7117b2c682bfb171c71edd287e775" translate="yes" xml:space="preserve">
          <source>Apply the supplied configuration argument to this provider instance and return the configured provider.</source>
          <target state="translated">제공된 구성 인수를이 공급자 인스턴스에 적용하고 구성된 공급자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="64987bb6636dbcd6239708a68cc6f3df34a0054e" translate="yes" xml:space="preserve">
          <source>Apply the supplied configuration argument to this provider instance and return the configured provider. Note that if this provider cannot be configured in-place, a new provider will be created and returned. Therefore, callers should always use the returned provider.</source>
          <target state="translated">제공된 구성 인수를이 공급자 인스턴스에 적용하고 구성된 공급자를 반환합니다. 이 공급자를 제자리에서 구성 할 수없는 경우 새 공급자가 생성되고 반환됩니다. 따라서 호출자는 항상 반환 된 공급자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a46eaa3873ca34a730dd7803b181407b1e7e2807" translate="yes" xml:space="preserve">
          <source>Applying the Blending Equation</source>
          <target state="translated">혼합 방정식 적용</target>
        </trans-unit>
        <trans-unit id="473fe811ab475410322782e93567dece51e0b8ff" translate="yes" xml:space="preserve">
          <source>Applying the method &lt;a href=&quot;character#toLowerCase-char-&quot;&gt;&lt;code&gt;Character.toLowerCase(char)&lt;/code&gt;&lt;/a&gt; to each character produces the same result</source>
          <target state="translated">&lt;a href=&quot;character#toLowerCase-char-&quot;&gt; &lt;code&gt;Character.toLowerCase(char)&lt;/code&gt; &lt;/a&gt; 메소드 를 각 문자에 적용하면 동일한 결과가 생성됩니다</target>
        </trans-unit>
        <trans-unit id="c0925034ed84c1ba3f4ae2dd1afbf8cc66850ac7" translate="yes" xml:space="preserve">
          <source>Applying the method &lt;a href=&quot;character#toUpperCase-char-&quot;&gt;&lt;code&gt;Character.toUpperCase(char)&lt;/code&gt;&lt;/a&gt; to each character produces the same result</source>
          <target state="translated">&lt;a href=&quot;character#toUpperCase-char-&quot;&gt; &lt;code&gt;Character.toUpperCase(char)&lt;/code&gt; &lt;/a&gt; 메소드 를 각 문자에 적용하면 동일한 결과가 생성됩니다</target>
        </trans-unit>
        <trans-unit id="327ed8d0a0963022714273723ba29db94c41fa04" translate="yes" xml:space="preserve">
          <source>ApproveSelectionAction</source>
          <target state="translated">ApproveSelectionAction</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="7a64dc99a10d9b589bd9de24024a282c12818436" translate="yes" xml:space="preserve">
          <source>Arbitrary transformations of the contained value are provided both by low-level read-modify-write operations such as &lt;code&gt;compareAndSet&lt;/code&gt; and by higher-level methods such as &lt;code&gt;getAndUpdate&lt;/code&gt;.</source>
          <target state="translated">포함 된 값의 임의 변환은 &lt;code&gt;compareAndSet&lt;/code&gt; 과 같은 저수준 읽기-수정-쓰기 작업과 &lt;code&gt;getAndUpdate&lt;/code&gt; 와 같은 상위 수준 메서드에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d94e713358cbb21a94171519afdcff3ba1724459" translate="yes" xml:space="preserve">
          <source>Arc2D</source>
          <target state="translated">Arc2D</target>
        </trans-unit>
        <trans-unit id="24a0cfb01e2d18f1c87ef242b3756832c5c434f8" translate="yes" xml:space="preserve">
          <source>Arc2D.Double</source>
          <target state="translated">Arc2D.Double</target>
        </trans-unit>
        <trans-unit id="219b544d41c812c11908bc255bebcda2fd70e19c" translate="yes" xml:space="preserve">
          <source>Arc2D.Float</source>
          <target state="translated">Arc2D.Float</target>
        </trans-unit>
        <trans-unit id="81774a3777584c094447787ba12a1651af131e47" translate="yes" xml:space="preserve">
          <source>Architectural issues to consider</source>
          <target state="translated">고려해야 할 건축 문제</target>
        </trans-unit>
        <trans-unit id="d2c998f8c52ee46eb198cc61d9a35814cb097ee3" translate="yes" xml:space="preserve">
          <source>Are lines horizontal?</source>
          <target state="translated">선이 수평입니까?</target>
        </trans-unit>
        <trans-unit id="2cf778fed5e58155d336586ba78713d083e28830" translate="yes" xml:space="preserve">
          <source>Are lines horizontal? This will return true for horizontal, left-to-right writing systems such as Roman.</source>
          <target state="translated">선이 수평입니까? 이것은 Roman과 같은 수평, 왼쪽에서 오른쪽 쓰기 시스템에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="440a4ad2c19eec40d8595d1f1bf68e3a2ba95e5d" translate="yes" xml:space="preserve">
          <source>Are the allocations for the children still valid?</source>
          <target state="translated">자녀에 대한 할당이 여전히 유효합니까?</target>
        </trans-unit>
        <trans-unit id="2745debaa64a20eedb49d9f14a0b807c87aa2d2a" translate="yes" xml:space="preserve">
          <source>Area</source>
          <target state="translated">Area</target>
        </trans-unit>
        <trans-unit id="6f52d283c8455ded1590131b78149b805d2402ff" translate="yes" xml:space="preserve">
          <source>AreaAction</source>
          <target state="translated">AreaAction</target>
        </trans-unit>
        <trans-unit id="e81d51c0e9c58d1f20dd4217287950af66b03f67" translate="yes" xml:space="preserve">
          <source>AreaAveragingScaleFilter</source>
          <target state="translated">AreaAveragingScaleFilter</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="6dee7863f0914f6588e2684aa82d8c428b414ed9" translate="yes" xml:space="preserve">
          <source>Argument Category</source>
          <target state="translated">인수 범주</target>
        </trans-unit>
        <trans-unit id="c572b8e5f06f5529375df62562cb7b867061a307" translate="yes" xml:space="preserve">
          <source>Argument Index</source>
          <target state="translated">인수 인덱스</target>
        </trans-unit>
        <trans-unit id="3b22ce472a26848501b86f89d1acecdd7ba7743e" translate="yes" xml:space="preserve">
          <source>Argument lists are padded out by &lt;a href=&quot;#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)&quot;&gt;dropping unused trailing arguments&lt;/a&gt;.</source>
          <target state="translated">인수 목록은 &lt;a href=&quot;#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)&quot;&gt;사용하지 않는 후행 인수&lt;/a&gt; 를 삭제하여 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="1cf417639cd88dca5ed348977db444c372780174" translate="yes" xml:space="preserve">
          <source>ArgumentIndex</source>
          <target state="translated">ArgumentIndex</target>
        </trans-unit>
        <trans-unit id="1a4ae3fef371487f78d2f69c8740337873fcf7e7" translate="yes" xml:space="preserve">
          <source>Arguments that appear in the argument list for &lt;a href=&quot;#metafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)&lt;/code&gt;&lt;/a&gt; have the same specification as in that method. The additional arguments are interpreted as follows:</source>
          <target state="translated">&lt;a href=&quot;#metafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)&lt;/code&gt; &lt;/a&gt; 의 인수 목록에 나타나는 인수 는 해당 메서드와 동일한 사양을 갖습니다. 추가 인수는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="2e5bfc7efad8b45cdc934f7fa43f90adf2a2ea6e" translate="yes" xml:space="preserve">
          <source>Arguments that appear in the argument list for &lt;a href=&quot;lambdametafactory#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)&lt;/code&gt;&lt;/a&gt; have the same specification as in that method. The additional arguments are interpreted as follows:</source>
          <target state="translated">&lt;a href=&quot;lambdametafactory#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)&lt;/code&gt; &lt;/a&gt; 의 인수 목록에 나타나는 인수 는 해당 메소드와 동일한 스펙을 갖습니다. 추가 인수는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="acf9d5ef3ca8bfb95db6ab809773c5a98582c787" translate="yes" xml:space="preserve">
          <source>Arguments used to pass a completion result (that is, for parameters of type &lt;code&gt;T&lt;/code&gt;) for methods accepting them may be null, but passing a null value for any other parameter will result in a &lt;a href=&quot;../../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">이를 수락하는 메서드에 대한 완료 결과 (즉, &lt;code&gt;T&lt;/code&gt; 형식의 매개 변수에 대한)를 전달하는 데 사용되는 인수는 null 일 수 있지만 다른 매개 변수에 대해 null 값을 전달하면 &lt;a href=&quot;../../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; 이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="2259330fb77de2bd8dc1911ad15baf0ac1663381" translate="yes" xml:space="preserve">
          <source>ArithmeticException</source>
          <target state="translated">ArithmeticException</target>
        </trans-unit>
        <trans-unit id="6705be38307e0ff0e31175e8f380d6014e23948e" translate="yes" xml:space="preserve">
          <source>Arity limits</source>
          <target state="translated">희귀 한도</target>
        </trans-unit>
        <trans-unit id="02e3b97ab015096a3b53dd7591b690f3d33f15d5" translate="yes" xml:space="preserve">
          <source>Arrange async execution</source>
          <target state="translated">비동기 실행 정렬</target>
        </trans-unit>
        <trans-unit id="3d56281f7929720ab8951cd1b5aa1de1a5698b01" translate="yes" xml:space="preserve">
          <source>Arrange exec and obtain Future</source>
          <target state="translated">임원을 준비하고 미래를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="ddaa41333e9d65ededfb5ce00db0f24147833e1c" translate="yes" xml:space="preserve">
          <source>ArrangeGrid</source>
          <target state="translated">ArrangeGrid</target>
        </trans-unit>
        <trans-unit id="e6033304ba65c2bf03ba37405ffb4242d91c1c5f" translate="yes" xml:space="preserve">
          <source>Arranges for (asynchronous) execution of the given task.</source>
          <target state="translated">주어진 작업의 (비동기) 실행을 준비합니다.</target>
        </trans-unit>
        <trans-unit id="ef4aaa5d407375c225b8697d59217a548d1bc776" translate="yes" xml:space="preserve">
          <source>Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the &lt;a href=&quot;forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;&lt;/a&gt; if not &lt;a href=&quot;#inForkJoinPool()&quot;&gt;&lt;code&gt;inForkJoinPool()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 작업이 실행중인 풀 (해당하는 경우)에서이 작업을 비동기 적으로 실행하거나 &lt;a href=&quot;#inForkJoinPool()&quot;&gt; &lt;code&gt;inForkJoinPool()&lt;/code&gt; &lt;/a&gt; 아닌 경우 &lt;a href=&quot;forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; &lt;/a&gt; 사용하도록 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="2491dfc5f0c04c431d7776873e47d40497b07f23" translate="yes" xml:space="preserve">
          <source>Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the &lt;a href=&quot;forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;&lt;/a&gt; if not &lt;a href=&quot;#inForkJoinPool()&quot;&gt;&lt;code&gt;inForkJoinPool()&lt;/code&gt;&lt;/a&gt;. While it is not necessarily enforced, it is a usage error to fork a task more than once unless it has completed and been reinitialized. Subsequent modifications to the state of this task or any data it operates on are not necessarily consistently observable by any thread other than the one executing it unless preceded by a call to &lt;a href=&quot;#join()&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; or related methods, or a call to &lt;a href=&quot;future#isDone()&quot;&gt;&lt;code&gt;Future.isDone()&lt;/code&gt;&lt;/a&gt; returning &lt;code&gt;
 true&lt;/code&gt;.</source>
          <target state="translated">현재 작업이 실행중인 풀 (해당하는 경우)에서이 작업을 비동기 적으로 실행하거나 &lt;a href=&quot;#inForkJoinPool()&quot;&gt; &lt;code&gt;inForkJoinPool()&lt;/code&gt; &lt;/a&gt; 아닌 경우 &lt;a href=&quot;forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; &lt;/a&gt; 사용하도록 정렬 합니다. 반드시 적용되는 것은 아니지만 작업이 완료되고 다시 초기화되지 않는 한 작업을 두 번 이상 포크하는 것은 사용 오류입니다. 이 작업의 상태 또는 작업이 수행되는 모든 데이터에 대한 후속 수정은 &lt;a href=&quot;#join()&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 또는 관련 메서드에 대한 호출 또는 &lt;a href=&quot;future#isDone()&quot;&gt; &lt;code&gt;Future.isDone()&lt;/code&gt; &lt;/a&gt; 에 대한 호출이 선행되지 않는 한이를 실행하는 스레드 이외의 다른 스레드에서 반드시 일관되게 관찰 할 수있는 것은 아닙니다. &lt;code&gt; true&lt;/code&gt; 반환 .</target>
        </trans-unit>
        <trans-unit id="71cba7686e4af3c9e7770e896be81d3174386480" translate="yes" xml:space="preserve">
          <source>Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;&lt;/a&gt; if not &lt;a href=&quot;forkjointask#inForkJoinPool--&quot;&gt;&lt;code&gt;inForkJoinPool()&lt;/code&gt;&lt;/a&gt;. While it is not necessarily enforced, it is a usage error to fork a task more than once unless it has completed and been reinitialized. Subsequent modifications to the state of this task or any data it operates on are not necessarily consistently observable by any thread other than the one executing it unless preceded by a call to &lt;a href=&quot;forkjointask#join--&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; or related methods, or a call to &lt;a href=&quot;forkjointask#isDone--&quot;&gt;&lt;code&gt;isDone()&lt;/code&gt;&lt;/a&gt; returning &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">현재 작업이 실행중인 풀 (해당되는 경우)에서 풀에서이 작업을 비동기식으로 실행하거나 &lt;a href=&quot;forkjointask#inForkJoinPool--&quot;&gt; &lt;code&gt;inForkJoinPool()&lt;/code&gt; &lt;/a&gt; 아닌 경우 &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 합니다. 반드시 적용되는 것은 아니지만 작업을 완료하고 다시 초기화하지 않으면 작업을 두 번 이상 포크하는 것은 사용 오류입니다. 이 작업의 상태 또는 작동하는 데이터에 대한 후속 수정은 &lt;a href=&quot;forkjointask#join--&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 또는 관련 메서드에 대한 호출 또는 &lt;a href=&quot;forkjointask#isDone--&quot;&gt; &lt;code&gt;isDone()&lt;/code&gt; &lt;/a&gt; 대한 호출이 &lt;code&gt;true&lt;/code&gt; 를 반환 하지 않는 한 실행 스레드 이외의 스레드에서 반드시 일관되게 관찰 할 수있는 것은 아닙니다. .</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="7747b10dd8edbc36723d3bda1e4fc1f9d0dce370" translate="yes" xml:space="preserve">
          <source>Array of Actions to install on JFormattedTextField</source>
          <target state="translated">JFormattedTextField에 설치할 액션 배열</target>
        </trans-unit>
        <trans-unit id="f8525f3f00f2bbff94d01f29f59dbcc41a51d329" translate="yes" xml:space="preserve">
          <source>Array of TableColumn objects in this model</source>
          <target state="translated">이 모델의 TableColumn 개체 배열</target>
        </trans-unit>
        <trans-unit id="bb7ef34866c1c3791e0e32c3560fdda96203d676" translate="yes" xml:space="preserve">
          <source>Array of class constants or enum constants</source>
          <target state="translated">클래스 상수 또는 열거 형 상수의 배열</target>
        </trans-unit>
        <trans-unit id="6c0eeedee20201092df554dd207d8eac0d32e06b" translate="yes" xml:space="preserve">
          <source>Array of extra objects to be included in the cache key</source>
          <target state="translated">캐시 키에 포함될 추가 개체의 배열</target>
        </trans-unit>
        <trans-unit id="569807c2a3ec4f7f160eb054479694d8449216d8" translate="yes" xml:space="preserve">
          <source>Array of printing attribute categories that the client can specify as a doc-level or job-level attribute in a Print Request. Each element in the array is a &lt;a href=&quot;../../java/lang/class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; that implements interface &lt;a href=&quot;attribute/attribute&quot;&gt;&lt;code&gt;Attribute&lt;/code&gt;&lt;/a&gt;. The array is empty if no categories are supported.</source>
          <target state="translated">클라이언트가 인쇄 요청에서 문서 레벨 또는 작업 레벨 속성으로 지정할 수있는 인쇄 속성 범주의 배열. 배열의 각 요소는 인터페이스 &lt;a href=&quot;attribute/attribute&quot;&gt; &lt;code&gt;Attribute&lt;/code&gt; &lt;/a&gt; 를 구현 하는 &lt;a href=&quot;../../java/lang/class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 입니다 . 지원되는 카테고리가 없으면 배열이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acea35f9cae772bd6729ea0a91ba2e0d2e049d3b" translate="yes" xml:space="preserve">
          <source>Array of supported doc flavors, should have at least one element.</source>
          <target state="translated">지원되는 문서 맛의 배열에는 하나 이상의 요소가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b6dc0470fc51b523a7e090cb616eed491033a26" translate="yes" xml:space="preserve">
          <source>Array of values the user can choose from.</source>
          <target state="translated">사용자가 선택할 수있는 값의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="db7de6653d382624f40994ff09165d3589b89b86" translate="yes" xml:space="preserve">
          <source>Array of values the user can choose from. Look and feel will provide the UI component to choose this from.</source>
          <target state="translated">사용자가 선택할 수있는 값의 배열입니다. 룩앤필은이를 선택할 수있는 UI 구성 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67254b0229a4173b61140618f8507f28706cc74c" translate="yes" xml:space="preserve">
          <source>Array used for multiple resource declarations.</source>
          <target state="translated">여러 리소스 선언에 사용되는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="4658726120ea2a76ab5f9db00569884eaf5c32c1" translate="yes" xml:space="preserve">
          <source>Array.get()</source>
          <target state="translated">Array.get()</target>
        </trans-unit>
        <trans-unit id="1169b0baca08e75ccd9d1d7d32fc92353347736e" translate="yes" xml:space="preserve">
          <source>Array.getBoolean()</source>
          <target state="translated">Array.getBoolean()</target>
        </trans-unit>
        <trans-unit id="45e230ecb81ecd9ebe58640f54af87cee473a1c7" translate="yes" xml:space="preserve">
          <source>Array.getByte()</source>
          <target state="translated">Array.getByte()</target>
        </trans-unit>
        <trans-unit id="9b247c6af24e2cac173bff15ce5dd20e7554ca39" translate="yes" xml:space="preserve">
          <source>Array.getChar()</source>
          <target state="translated">Array.getChar()</target>
        </trans-unit>
        <trans-unit id="8e241acaa4e7de56f4f6b06a9a2b69c8b3934a9c" translate="yes" xml:space="preserve">
          <source>Array.getDouble()</source>
          <target state="translated">Array.getDouble()</target>
        </trans-unit>
        <trans-unit id="d72cad2b167d638887c65cb8102a0842bdeef724" translate="yes" xml:space="preserve">
          <source>Array.getFloat()</source>
          <target state="translated">Array.getFloat()</target>
        </trans-unit>
        <trans-unit id="4a5e0617636097c95ddd3b26825b9fa630129bd0" translate="yes" xml:space="preserve">
          <source>Array.getInt()</source>
          <target state="translated">Array.getInt()</target>
        </trans-unit>
        <trans-unit id="b1ea126ae4a5892b65c8761706ebf577fa0b8447" translate="yes" xml:space="preserve">
          <source>Array.getLength()</source>
          <target state="translated">Array.getLength()</target>
        </trans-unit>
        <trans-unit id="b4e13c666fbd535053c99dc297ab35fb4f028144" translate="yes" xml:space="preserve">
          <source>Array.getLong()</source>
          <target state="translated">Array.getLong()</target>
        </trans-unit>
        <trans-unit id="5d172f7ac795870d2f898d4e0b36bea81b013a3f" translate="yes" xml:space="preserve">
          <source>Array.getShort()</source>
          <target state="translated">Array.getShort()</target>
        </trans-unit>
        <trans-unit id="e88fedaeae84f4fd50173a5bdd67c92f374f0d63" translate="yes" xml:space="preserve">
          <source>Array.newInstance()</source>
          <target state="translated">Array.newInstance()</target>
        </trans-unit>
        <trans-unit id="f6af3462971f6d30e9ec2c85b6f112b33661a48c" translate="yes" xml:space="preserve">
          <source>Array.set()</source>
          <target state="translated">Array.set()</target>
        </trans-unit>
        <trans-unit id="f91f1f89eedde88ec92a16f2690640ccc75db314" translate="yes" xml:space="preserve">
          <source>Array.setBoolean()</source>
          <target state="translated">Array.setBoolean()</target>
        </trans-unit>
        <trans-unit id="9a2dc485cb875a98afdbe9f1fc0af3ae91bc7d22" translate="yes" xml:space="preserve">
          <source>Array.setByte()</source>
          <target state="translated">Array.setByte()</target>
        </trans-unit>
        <trans-unit id="3bc6ded8b8303eae5d660be744937261f4fb655b" translate="yes" xml:space="preserve">
          <source>Array.setChar()</source>
          <target state="translated">Array.setChar()</target>
        </trans-unit>
        <trans-unit id="062ef285c7735737b8feec3b6018d5913746147a" translate="yes" xml:space="preserve">
          <source>Array.setDouble()</source>
          <target state="translated">Array.setDouble()</target>
        </trans-unit>
        <trans-unit id="b284650cdb4942518c61c9fb415d0f3273563e0b" translate="yes" xml:space="preserve">
          <source>Array.setFloat()</source>
          <target state="translated">Array.setFloat()</target>
        </trans-unit>
        <trans-unit id="eb2dd2165c3cdf2c0752876ae095f28dd88b60dc" translate="yes" xml:space="preserve">
          <source>Array.setInt()</source>
          <target state="translated">Array.setInt()</target>
        </trans-unit>
        <trans-unit id="da531263561c3c737792c93701185e9465b36a9c" translate="yes" xml:space="preserve">
          <source>Array.setLong()</source>
          <target state="translated">Array.setLong()</target>
        </trans-unit>
        <trans-unit id="0773afd66a6be3901682429b86107e92c0137d0b" translate="yes" xml:space="preserve">
          <source>Array.setShort()</source>
          <target state="translated">Array.setShort()</target>
        </trans-unit>
        <trans-unit id="1a283a038a4dcdb2e50b5ad5b7b9ab73e8033daf" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue</source>
          <target state="translated">ArrayBlockingQueue</target>
        </trans-unit>
        <trans-unit id="3d96acc37cd4954c931fa29a5de4124c31c1d3e9" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.add()</source>
          <target state="translated">ArrayBlockingQueue.add()</target>
        </trans-unit>
        <trans-unit id="3dbd1eb6fdbac03d7ef6563da0eb3a8180e79e61" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.clear()</source>
          <target state="translated">ArrayBlockingQueue.clear()</target>
        </trans-unit>
        <trans-unit id="d2b8c263fb51c1d3665002060e6cacb05b477a5f" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.contains()</source>
          <target state="translated">ArrayBlockingQueue.contains()</target>
        </trans-unit>
        <trans-unit id="56496c2e552af45b7fe3d89c4a6e038dd024ffe1" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.drainTo()</source>
          <target state="translated">ArrayBlockingQueue.drainTo()</target>
        </trans-unit>
        <trans-unit id="bb6a69f32e54e7f6e94d4b4a1f2502f19ab5e73c" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.iterator()</source>
          <target state="translated">ArrayBlockingQueue.iterator()</target>
        </trans-unit>
        <trans-unit id="ae8981ef0588c86f5c55f27f5891a2639e002e80" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.offer()</source>
          <target state="translated">ArrayBlockingQueue.offer()</target>
        </trans-unit>
        <trans-unit id="b2f039549dcdcef93e747e665aa28a510a467c06" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.peek()</source>
          <target state="translated">ArrayBlockingQueue.peek()</target>
        </trans-unit>
        <trans-unit id="6713c2584369c8ae5280831ce58bedae449bc270" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.poll()</source>
          <target state="translated">ArrayBlockingQueue.poll()</target>
        </trans-unit>
        <trans-unit id="0ea6f79daf5205a896305d995a997675b14b3d2b" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.put()</source>
          <target state="translated">ArrayBlockingQueue.put()</target>
        </trans-unit>
        <trans-unit id="e75f62a1986ae83f920bebf8c1ac2bf450672d87" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.remainingCapacity()</source>
          <target state="translated">ArrayBlockingQueue.remainingCapacity()</target>
        </trans-unit>
        <trans-unit id="baffefbb01fe5b64bee2c1206365c66a2329aa74" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.remove()</source>
          <target state="translated">ArrayBlockingQueue.remove()</target>
        </trans-unit>
        <trans-unit id="01039bfc283527758908b9a5697520991aa6a923" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.size()</source>
          <target state="translated">ArrayBlockingQueue.size()</target>
        </trans-unit>
        <trans-unit id="8f1266bf6b909b6efa0985bdf17784f5de67fbd2" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.spliterator()</source>
          <target state="translated">ArrayBlockingQueue.spliterator()</target>
        </trans-unit>
        <trans-unit id="babefc9596faf932dfa911f390aff3a971b2ccff" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.take()</source>
          <target state="translated">ArrayBlockingQueue.take()</target>
        </trans-unit>
        <trans-unit id="ecd956bb79ba9d156919269a43e7111bb0457368" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.toArray()</source>
          <target state="translated">ArrayBlockingQueue.toArray()</target>
        </trans-unit>
        <trans-unit id="ac7393cded22c6ae03dbbf5d496efe87f9cd2b60" translate="yes" xml:space="preserve">
          <source>ArrayBlockingQueue.toString()</source>
          <target state="translated">ArrayBlockingQueue.toString()</target>
        </trans-unit>
        <trans-unit id="a1d9626b2a8faf29b6417286fb8a6b3e1f9be338" translate="yes" xml:space="preserve">
          <source>ArrayDeque</source>
          <target state="translated">ArrayDeque</target>
        </trans-unit>
        <trans-unit id="bed2df06b552cca23f4d8af39984e1178eeb27a4" translate="yes" xml:space="preserve">
          <source>ArrayDeque.add()</source>
          <target state="translated">ArrayDeque.add()</target>
        </trans-unit>
        <trans-unit id="d2701c9e24b7f41499b59cd658e03461d594b48d" translate="yes" xml:space="preserve">
          <source>ArrayDeque.addFirst()</source>
          <target state="translated">ArrayDeque.addFirst()</target>
        </trans-unit>
        <trans-unit id="e437dd06b166eda7b7de7a8002cf304b9b770bf4" translate="yes" xml:space="preserve">
          <source>ArrayDeque.addLast()</source>
          <target state="translated">ArrayDeque.addLast()</target>
        </trans-unit>
        <trans-unit id="a352cf50a3d9d333f0cb4a879b607e249c258494" translate="yes" xml:space="preserve">
          <source>ArrayDeque.clear()</source>
          <target state="translated">ArrayDeque.clear()</target>
        </trans-unit>
        <trans-unit id="9e84be1b39b7efeaa4ccb90aca05601634b0ddd9" translate="yes" xml:space="preserve">
          <source>ArrayDeque.clone()</source>
          <target state="translated">ArrayDeque.clone()</target>
        </trans-unit>
        <trans-unit id="7982354300300d171b3016130244329713b149cd" translate="yes" xml:space="preserve">
          <source>ArrayDeque.contains()</source>
          <target state="translated">ArrayDeque.contains()</target>
        </trans-unit>
        <trans-unit id="75b05cd9e1f69bc6dac6a81afad1a495b214d20e" translate="yes" xml:space="preserve">
          <source>ArrayDeque.descendingIterator()</source>
          <target state="translated">ArrayDeque.descendingIterator()</target>
        </trans-unit>
        <trans-unit id="e0a60bac2ddad41306d36b5b43bc5f77e1dc4781" translate="yes" xml:space="preserve">
          <source>ArrayDeque.element()</source>
          <target state="translated">ArrayDeque.element()</target>
        </trans-unit>
        <trans-unit id="a420aa718866ddb4a3a295fa14df62837dca90e0" translate="yes" xml:space="preserve">
          <source>ArrayDeque.getFirst()</source>
          <target state="translated">ArrayDeque.getFirst()</target>
        </trans-unit>
        <trans-unit id="7dc95f4a9183134e5a977034584c9c29c0da84d0" translate="yes" xml:space="preserve">
          <source>ArrayDeque.getLast()</source>
          <target state="translated">ArrayDeque.getLast()</target>
        </trans-unit>
        <trans-unit id="ea86c6721057aa21b774837669c804b2ae5ff14b" translate="yes" xml:space="preserve">
          <source>ArrayDeque.isEmpty()</source>
          <target state="translated">ArrayDeque.isEmpty()</target>
        </trans-unit>
        <trans-unit id="2778cf97463835ee87fdf389f420513adc88da5e" translate="yes" xml:space="preserve">
          <source>ArrayDeque.iterator()</source>
          <target state="translated">ArrayDeque.iterator()</target>
        </trans-unit>
        <trans-unit id="9a23b8f00c880c251e597a2828b54b13cf11591e" translate="yes" xml:space="preserve">
          <source>ArrayDeque.offer()</source>
          <target state="translated">ArrayDeque.offer()</target>
        </trans-unit>
        <trans-unit id="956983a0c043c9c5a1f7d323c7d758837dde02ba" translate="yes" xml:space="preserve">
          <source>ArrayDeque.offerFirst()</source>
          <target state="translated">ArrayDeque.offerFirst()</target>
        </trans-unit>
        <trans-unit id="4bb9d892b664791a921a331d941810f8b80c900b" translate="yes" xml:space="preserve">
          <source>ArrayDeque.offerLast()</source>
          <target state="translated">ArrayDeque.offerLast()</target>
        </trans-unit>
        <trans-unit id="f33bac0a172c3990700e65739fa16ef9abf2961f" translate="yes" xml:space="preserve">
          <source>ArrayDeque.peek()</source>
          <target state="translated">ArrayDeque.peek()</target>
        </trans-unit>
        <trans-unit id="314c49c13bf4a77b621e7be5815bcd236146d330" translate="yes" xml:space="preserve">
          <source>ArrayDeque.peekFirst()</source>
          <target state="translated">ArrayDeque.peekFirst()</target>
        </trans-unit>
        <trans-unit id="0f0b523e109dd965b5e3fd8f054173fa9acf9395" translate="yes" xml:space="preserve">
          <source>ArrayDeque.peekLast()</source>
          <target state="translated">ArrayDeque.peekLast()</target>
        </trans-unit>
        <trans-unit id="b7d97e0cac420b8b46914f7eb4b9ff69a56f47f1" translate="yes" xml:space="preserve">
          <source>ArrayDeque.poll()</source>
          <target state="translated">ArrayDeque.poll()</target>
        </trans-unit>
        <trans-unit id="ec16ee31c4dc2bcd8f0f02b45cc335c86eb9fe4d" translate="yes" xml:space="preserve">
          <source>ArrayDeque.pollFirst()</source>
          <target state="translated">ArrayDeque.pollFirst()</target>
        </trans-unit>
        <trans-unit id="8d134b459fc996a5e431c9e7ae608aeea0923492" translate="yes" xml:space="preserve">
          <source>ArrayDeque.pollLast()</source>
          <target state="translated">ArrayDeque.pollLast()</target>
        </trans-unit>
        <trans-unit id="770e2003af764711664240954edb26b3268a95d5" translate="yes" xml:space="preserve">
          <source>ArrayDeque.pop()</source>
          <target state="translated">ArrayDeque.pop()</target>
        </trans-unit>
        <trans-unit id="60fc19ac26e8d552fa9d36569e69afe123439d32" translate="yes" xml:space="preserve">
          <source>ArrayDeque.push()</source>
          <target state="translated">ArrayDeque.push()</target>
        </trans-unit>
        <trans-unit id="ca1078f7c4af77c9358b816a58b5ae37310f9fd6" translate="yes" xml:space="preserve">
          <source>ArrayDeque.remove()</source>
          <target state="translated">ArrayDeque.remove()</target>
        </trans-unit>
        <trans-unit id="16a4d68564ea8bca4be4f1174ceca9d5f7110b20" translate="yes" xml:space="preserve">
          <source>ArrayDeque.removeFirst()</source>
          <target state="translated">ArrayDeque.removeFirst()</target>
        </trans-unit>
        <trans-unit id="0ef19d078a9315e6fb282cd424c2059db93eaec0" translate="yes" xml:space="preserve">
          <source>ArrayDeque.removeFirstOccurrence()</source>
          <target state="translated">ArrayDeque.removeFirstOccurrence()</target>
        </trans-unit>
        <trans-unit id="2ef2e331f8c0a6398215f9094fcd408191cde0d2" translate="yes" xml:space="preserve">
          <source>ArrayDeque.removeLast()</source>
          <target state="translated">ArrayDeque.removeLast()</target>
        </trans-unit>
        <trans-unit id="7c8b7e728f64463eb5ff97018c0f09518af8af5e" translate="yes" xml:space="preserve">
          <source>ArrayDeque.removeLastOccurrence()</source>
          <target state="translated">ArrayDeque.removeLastOccurrence()</target>
        </trans-unit>
        <trans-unit id="a54b8c10adeb716e784d2ad7c4305438595619f7" translate="yes" xml:space="preserve">
          <source>ArrayDeque.size()</source>
          <target state="translated">ArrayDeque.size()</target>
        </trans-unit>
        <trans-unit id="50926f012e8f6d6654906ecf9aeced2678ec6965" translate="yes" xml:space="preserve">
          <source>ArrayDeque.spliterator()</source>
          <target state="translated">ArrayDeque.spliterator()</target>
        </trans-unit>
        <trans-unit id="4983ebbc8740047ee462627b80722151818752f9" translate="yes" xml:space="preserve">
          <source>ArrayDeque.toArray()</source>
          <target state="translated">ArrayDeque.toArray()</target>
        </trans-unit>
        <trans-unit id="21484b74aa640458082fe4bb49601200afedc0f0" translate="yes" xml:space="preserve">
          <source>ArrayIndexOutOfBoundsException</source>
          <target state="translated">ArrayIndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="f5baaa4ad5d36710b8fed9d2bc4a53a86da5b55a" translate="yes" xml:space="preserve">
          <source>ArrayList</source>
          <target state="translated">ArrayList</target>
        </trans-unit>
        <trans-unit id="d1b38d91a4da43ea7d424a38ce96c626a121696b" translate="yes" xml:space="preserve">
          <source>ArrayList of ObjectName objects for referenced MBeans.</source>
          <target state="translated">참조 된 MBean에 대한 ObjectName 객체의 ArrayList입니다.</target>
        </trans-unit>
        <trans-unit id="a1d711fdf8512dbf9ae876dfaad2ed359350d906" translate="yes" xml:space="preserve">
          <source>ArrayList of RoleInfo.</source>
          <target state="translated">RoleInfo의 ArrayList.</target>
        </trans-unit>
        <trans-unit id="79f1f5f289d4a364472fcb60a9d57fe0207ae8ac" translate="yes" xml:space="preserve">
          <source>ArrayList of String</source>
          <target state="translated">문자열의 ArrayList</target>
        </trans-unit>
        <trans-unit id="f072bf434a8e4e92915b83b944e15e391db88282" translate="yes" xml:space="preserve">
          <source>ArrayList of relation type names (Strings)</source>
          <target state="translated">관계 유형 이름 (문자열)의 ArrayList</target>
        </trans-unit>
        <trans-unit id="0f47b6ff5f2eca03244dbd321baeb58760b3cf91" translate="yes" xml:space="preserve">
          <source>ArrayList.add()</source>
          <target state="translated">ArrayList.add()</target>
        </trans-unit>
        <trans-unit id="507a2eea358226004f14b71091689e5b0b3de625" translate="yes" xml:space="preserve">
          <source>ArrayList.addAll()</source>
          <target state="translated">ArrayList.addAll()</target>
        </trans-unit>
        <trans-unit id="082bae60cab9869e2405f845a57761031488cc85" translate="yes" xml:space="preserve">
          <source>ArrayList.clear()</source>
          <target state="translated">ArrayList.clear()</target>
        </trans-unit>
        <trans-unit id="088b969c19105c440fdadb5c6c028c09751f4524" translate="yes" xml:space="preserve">
          <source>ArrayList.clone()</source>
          <target state="translated">ArrayList.clone()</target>
        </trans-unit>
        <trans-unit id="8772045082c4ae7aa5b0cc2513d87c1dd3f0519c" translate="yes" xml:space="preserve">
          <source>ArrayList.contains()</source>
          <target state="translated">ArrayList.contains()</target>
        </trans-unit>
        <trans-unit id="696a156109972f7f27cb904a75eea4be0ca4edb5" translate="yes" xml:space="preserve">
          <source>ArrayList.ensureCapacity()</source>
          <target state="translated">ArrayList.ensureCapacity()</target>
        </trans-unit>
        <trans-unit id="a65347c40f0e485b54559608a032f6fcd888d79a" translate="yes" xml:space="preserve">
          <source>ArrayList.forEach()</source>
          <target state="translated">ArrayList.forEach()</target>
        </trans-unit>
        <trans-unit id="c6d0a301f9d31161a1449a9f575abf47243c5209" translate="yes" xml:space="preserve">
          <source>ArrayList.get()</source>
          <target state="translated">ArrayList.get()</target>
        </trans-unit>
        <trans-unit id="f494893c35f2e63cdd96ebe689dc06117c3036b3" translate="yes" xml:space="preserve">
          <source>ArrayList.indexOf()</source>
          <target state="translated">ArrayList.indexOf()</target>
        </trans-unit>
        <trans-unit id="68caef6bb721f87b173f7baf484b770b7fbf672e" translate="yes" xml:space="preserve">
          <source>ArrayList.isEmpty()</source>
          <target state="translated">ArrayList.isEmpty()</target>
        </trans-unit>
        <trans-unit id="6794ed7d20aaefcda7a3eaf86ab23508164d2d72" translate="yes" xml:space="preserve">
          <source>ArrayList.iterator()</source>
          <target state="translated">ArrayList.iterator()</target>
        </trans-unit>
        <trans-unit id="205270f883fc49ffa068c9a3dbe66852020bf3a2" translate="yes" xml:space="preserve">
          <source>ArrayList.lastIndexOf()</source>
          <target state="translated">ArrayList.lastIndexOf()</target>
        </trans-unit>
        <trans-unit id="aa3f5f8a7bf8faa3ea051729f325aa4505c1a5f7" translate="yes" xml:space="preserve">
          <source>ArrayList.listIterator()</source>
          <target state="translated">ArrayList.listIterator()</target>
        </trans-unit>
        <trans-unit id="4acdb817b23096f50c66aac9c5e120b25d50ad5e" translate="yes" xml:space="preserve">
          <source>ArrayList.remove()</source>
          <target state="translated">ArrayList.remove()</target>
        </trans-unit>
        <trans-unit id="d3667e4b10100a95482cdb56bc6e0e42b4ec20f5" translate="yes" xml:space="preserve">
          <source>ArrayList.removeAll()</source>
          <target state="translated">ArrayList.removeAll()</target>
        </trans-unit>
        <trans-unit id="ab982c1457071db3d759d9fc8bb07db0f0568b23" translate="yes" xml:space="preserve">
          <source>ArrayList.removeIf()</source>
          <target state="translated">ArrayList.removeIf()</target>
        </trans-unit>
        <trans-unit id="566e74e2242ca7c9df417b51e91dabe7c34c143c" translate="yes" xml:space="preserve">
          <source>ArrayList.removeRange()</source>
          <target state="translated">ArrayList.removeRange()</target>
        </trans-unit>
        <trans-unit id="36bab2da55c0e9dc6a1f7f936fa8697fbbd75548" translate="yes" xml:space="preserve">
          <source>ArrayList.replaceAll()</source>
          <target state="translated">ArrayList.replaceAll()</target>
        </trans-unit>
        <trans-unit id="532a41b9f0e66f2a34cf7991c625b88a72eb406d" translate="yes" xml:space="preserve">
          <source>ArrayList.retainAll()</source>
          <target state="translated">ArrayList.retainAll()</target>
        </trans-unit>
        <trans-unit id="32fc31340174e6ddb82791777b34fbb197c55b26" translate="yes" xml:space="preserve">
          <source>ArrayList.set()</source>
          <target state="translated">ArrayList.set()</target>
        </trans-unit>
        <trans-unit id="f16daa8e32cf5bf5607ac82deb5cfb60765a4a90" translate="yes" xml:space="preserve">
          <source>ArrayList.size()</source>
          <target state="translated">ArrayList.size()</target>
        </trans-unit>
        <trans-unit id="fac2a946b847ab427216c071e3f0b3af92c4a36f" translate="yes" xml:space="preserve">
          <source>ArrayList.sort()</source>
          <target state="translated">ArrayList.sort()</target>
        </trans-unit>
        <trans-unit id="d148a99b7cd7829c476159cb3b6c744b0c5ee770" translate="yes" xml:space="preserve">
          <source>ArrayList.spliterator()</source>
          <target state="translated">ArrayList.spliterator()</target>
        </trans-unit>
        <trans-unit id="e0385a55c46be6d850fd057ec9a0d3a4cedea4c3" translate="yes" xml:space="preserve">
          <source>ArrayList.subList()</source>
          <target state="translated">ArrayList.subList()</target>
        </trans-unit>
        <trans-unit id="1fd2236a7851d3a0612dc24e53d2ac3991b3c237" translate="yes" xml:space="preserve">
          <source>ArrayList.toArray()</source>
          <target state="translated">ArrayList.toArray()</target>
        </trans-unit>
        <trans-unit id="1ff7df7831f0c607f6db81ba9f79b3b9239ceef3" translate="yes" xml:space="preserve">
          <source>ArrayList.trimToSize()</source>
          <target state="translated">ArrayList.trimToSize()</target>
        </trans-unit>
        <trans-unit id="70ce27f43d491914a500ad71f5cd62e7c63052b6" translate="yes" xml:space="preserve">
          <source>ArrayStoreException</source>
          <target state="translated">ArrayStoreException</target>
        </trans-unit>
        <trans-unit id="77e0a11af696ddb246c753fbf92cf343a2992b51" translate="yes" xml:space="preserve">
          <source>ArrayType</source>
          <target state="translated">ArrayType</target>
        </trans-unit>
        <trans-unit id="0ad6cfa3795c8768a161ec4d9565a1cb78765d05" translate="yes" xml:space="preserve">
          <source>ArrayType.equals()</source>
          <target state="translated">ArrayType.equals()</target>
        </trans-unit>
        <trans-unit id="b6cf1edc1e95c031c5a6ec52f87a88a439d88d8c" translate="yes" xml:space="preserve">
          <source>ArrayType.getArrayType()</source>
          <target state="translated">ArrayType.getArrayType()</target>
        </trans-unit>
        <trans-unit id="2d529dd9d80021b7d146f1cf42e0717a7cf4216a" translate="yes" xml:space="preserve">
          <source>ArrayType.getComponentType()</source>
          <target state="translated">ArrayType.getComponentType()</target>
        </trans-unit>
        <trans-unit id="03b3b6b244b2153b6b58e79a75359d327e3244e5" translate="yes" xml:space="preserve">
          <source>ArrayType.getDimension()</source>
          <target state="translated">ArrayType.getDimension()</target>
        </trans-unit>
        <trans-unit id="59d72720bddbebb8c69f72937b6908a569a0696a" translate="yes" xml:space="preserve">
          <source>ArrayType.getElementOpenType()</source>
          <target state="translated">ArrayType.getElementOpenType()</target>
        </trans-unit>
        <trans-unit id="229162e2aee70affd2dbe41528f566b00858fd60" translate="yes" xml:space="preserve">
          <source>ArrayType.getPrimitiveArrayType()</source>
          <target state="translated">ArrayType.getPrimitiveArrayType()</target>
        </trans-unit>
        <trans-unit id="3146cb41e5856b3709df762521839f1a446b3dcc" translate="yes" xml:space="preserve">
          <source>ArrayType.hashCode()</source>
          <target state="translated">ArrayType.hashCode()</target>
        </trans-unit>
        <trans-unit id="93d36cfaf61145695e080e5e742a56ce0312a81b" translate="yes" xml:space="preserve">
          <source>ArrayType.isPrimitiveArray()</source>
          <target state="translated">ArrayType.isPrimitiveArray()</target>
        </trans-unit>
        <trans-unit id="98cc545995e3dd73b4112c4ef40a1f05d7eaa3c0" translate="yes" xml:space="preserve">
          <source>ArrayType.isValue()</source>
          <target state="translated">ArrayType.isValue()</target>
        </trans-unit>
        <trans-unit id="f227b51b3a472ea46fad9e1babf056963137e266" translate="yes" xml:space="preserve">
          <source>ArrayType.toString()</source>
          <target state="translated">ArrayType.toString()</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="785112061d071a3b0f54a08c6eb7aef42d45601d" translate="yes" xml:space="preserve">
          <source>Arrays.asList()</source>
          <target state="translated">Arrays.asList()</target>
        </trans-unit>
        <trans-unit id="f3d9ec164d4d8a6008befbecb43760ebc32085f2" translate="yes" xml:space="preserve">
          <source>Arrays.binarySearch()</source>
          <target state="translated">Arrays.binarySearch()</target>
        </trans-unit>
        <trans-unit id="12502654ba05a3e6d53da76af059402cbb12044a" translate="yes" xml:space="preserve">
          <source>Arrays.copyOf()</source>
          <target state="translated">Arrays.copyOf()</target>
        </trans-unit>
        <trans-unit id="dbc9f4a9ab427ca23d1513d26347763e5b9209db" translate="yes" xml:space="preserve">
          <source>Arrays.copyOfRange()</source>
          <target state="translated">Arrays.copyOfRange()</target>
        </trans-unit>
        <trans-unit id="0e5aa98d7dcf419ac91cb5a6dd4cf0faff77b0f9" translate="yes" xml:space="preserve">
          <source>Arrays.deepEquals()</source>
          <target state="translated">Arrays.deepEquals()</target>
        </trans-unit>
        <trans-unit id="b8790dc370ceaac6a247f001d220325b8a9840f1" translate="yes" xml:space="preserve">
          <source>Arrays.deepHashCode()</source>
          <target state="translated">Arrays.deepHashCode()</target>
        </trans-unit>
        <trans-unit id="c14ee3f183bc78fa73dda4bc29af17be0e9d4c84" translate="yes" xml:space="preserve">
          <source>Arrays.deepToString()</source>
          <target state="translated">Arrays.deepToString()</target>
        </trans-unit>
        <trans-unit id="15a2250d58064792e0aa4c812b2fcd12bbf2cba8" translate="yes" xml:space="preserve">
          <source>Arrays.equals()</source>
          <target state="translated">Arrays.equals()</target>
        </trans-unit>
        <trans-unit id="7065cdf47ae5fa24a1bc1786252642b6ffc02e75" translate="yes" xml:space="preserve">
          <source>Arrays.fill()</source>
          <target state="translated">Arrays.fill()</target>
        </trans-unit>
        <trans-unit id="b7f4f05ac6079c2f39826d73fa974a667c2af896" translate="yes" xml:space="preserve">
          <source>Arrays.hashCode()</source>
          <target state="translated">Arrays.hashCode()</target>
        </trans-unit>
        <trans-unit id="1c84a0a521a0f88270229b96bf0c0c7052d3e797" translate="yes" xml:space="preserve">
          <source>Arrays.parallelPrefix()</source>
          <target state="translated">Arrays.parallelPrefix()</target>
        </trans-unit>
        <trans-unit id="6158fac122308b4615eef303cf6d18c4b6c598db" translate="yes" xml:space="preserve">
          <source>Arrays.parallelSetAll()</source>
          <target state="translated">Arrays.parallelSetAll()</target>
        </trans-unit>
        <trans-unit id="80c65cbf63256455d9f0156c52fe85f7774ffe3b" translate="yes" xml:space="preserve">
          <source>Arrays.parallelSort()</source>
          <target state="translated">Arrays.parallelSort()</target>
        </trans-unit>
        <trans-unit id="be3d1ea55339b035c7d4c55fc7102d227e5eb8ac" translate="yes" xml:space="preserve">
          <source>Arrays.setAll()</source>
          <target state="translated">Arrays.setAll()</target>
        </trans-unit>
        <trans-unit id="6eb3c3ed8dad53c9c7b43fe48c62d680b9b601f2" translate="yes" xml:space="preserve">
          <source>Arrays.sort()</source>
          <target state="translated">Arrays.sort()</target>
        </trans-unit>
        <trans-unit id="db8256238c2e9e487d4c3cd55dcc7735a411e0ad" translate="yes" xml:space="preserve">
          <source>Arrays.spliterator()</source>
          <target state="translated">Arrays.spliterator()</target>
        </trans-unit>
        <trans-unit id="3f01157894c7fb06cfd674ea96da3e264a32b485" translate="yes" xml:space="preserve">
          <source>Arrays.stream()</source>
          <target state="translated">Arrays.stream()</target>
        </trans-unit>
        <trans-unit id="9169ccbfd1326cb33090f82ec8fbe3c7ab8af645" translate="yes" xml:space="preserve">
          <source>Arrays.toString()</source>
          <target state="translated">Arrays.toString()</target>
        </trans-unit>
        <trans-unit id="0593ec9ff63572472f50caf84da2753c8e528390" translate="yes" xml:space="preserve">
          <source>Arrives at this phaser and awaits others.</source>
          <target state="translated">이 페이저에 도착하여 다른 사람들을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d1539b18fd678578b164311c3d48f4d617b373cc" translate="yes" xml:space="preserve">
          <source>Arrives at this phaser and awaits others. Equivalent in effect to &lt;code&gt;awaitAdvance(arrive())&lt;/code&gt;. If you need to await with interruption or timeout, you can arrange this with an analogous construction using one of the other forms of the &lt;code&gt;
 awaitAdvance&lt;/code&gt; method. If instead you need to deregister upon arrival, use &lt;code&gt;awaitAdvance(arriveAndDeregister())&lt;/code&gt;.</source>
          <target state="translated">이 페이저에 도착하여 다른 사람들을 기다립니다. 사실상 &lt;code&gt;awaitAdvance(arrive())&lt;/code&gt; 합니다. 중단 또는 시간 초과로 기다려야하는 경우 &lt;code&gt; awaitAdvance&lt;/code&gt; 메서드 의 다른 형식 중 하나를 사용하여 유사한 구성으로이를 정렬 할 수 있습니다 . 대신 도착시 등록을 취소해야하는 경우 &lt;code&gt;awaitAdvance(arriveAndDeregister())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b298b30836ac59332910f7b9733054fb1ef7ff82" translate="yes" xml:space="preserve">
          <source>Arrives at this phaser and awaits others. Equivalent in effect to &lt;code&gt;awaitAdvance(arrive())&lt;/code&gt;. If you need to await with interruption or timeout, you can arrange this with an analogous construction using one of the other forms of the &lt;code&gt;awaitAdvance&lt;/code&gt; method. If instead you need to deregister upon arrival, use &lt;code&gt;awaitAdvance(arriveAndDeregister())&lt;/code&gt;.</source>
          <target state="translated">이 페이저에 도착하고 다른 사람들을 기다립니다. 효력 등가 &lt;code&gt;awaitAdvance(arrive())&lt;/code&gt; . 중단 또는 시간 종료로 대기해야하는 경우 다른 형식의 &lt;code&gt;awaitAdvance&lt;/code&gt; 메소드 중 하나를 사용하여 유사한 구성으로이를 배열 할 수 있습니다 . 도착시 등록을 취소해야하는 경우 &lt;code&gt;awaitAdvance(arriveAndDeregister())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ea548ad2eef87c5d8b67034a1e4844e0af0439d" translate="yes" xml:space="preserve">
          <source>Arrives at this phaser and deregisters from it without waiting for others to arrive.</source>
          <target state="translated">이 페이저에 도착하여 다른 사람들이 도착할 때까지 기다리지 않고 페이저에서 등록을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="331a996402bfe9c73489f9b59ef23c5414ff2f59" translate="yes" xml:space="preserve">
          <source>Arrives at this phaser and deregisters from it without waiting for others to arrive. Deregistration reduces the number of parties required to advance in future phases. If this phaser has a parent, and deregistration causes this phaser to have zero parties, this phaser is also deregistered from its parent.</source>
          <target state="translated">이 페이저에 도착하여 다른 사람이 도착하기를 기다리지 않고 등록을 취소합니다. 등록 취소는 향후 단계에서 진행하는 데 필요한 당사자 수를 줄입니다. 이 페이저에 상위가 있고 등록 취소로 인해이 페이저에 파티가없는 경우이 페이저도 상위에서 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="d77bf15c90eea56d5b8772727b356cf4aaf22515" translate="yes" xml:space="preserve">
          <source>Arrives at this phaser, without waiting for others to arrive.</source>
          <target state="translated">다른 사람이 도착하기를 기다리지 않고이 페이저에 도착합니다.</target>
        </trans-unit>
        <trans-unit id="0b0acd2f28a72c90a83e78811a10a96eb0dbb71a" translate="yes" xml:space="preserve">
          <source>ArrowButton's are special types of buttons that also render a directional indicator, typically an arrow.</source>
          <target state="translated">ArrowButton은 방향 표시기 (일반적으로 화살표)도 렌더링하는 특수한 유형의 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="5c6cd0f44fc52608739cfb8e05a5e7345de993e6" translate="yes" xml:space="preserve">
          <source>ArrowButton's are special types of buttons that also render a directional indicator, typically an arrow. ArrowButtons are used by composite components, for example ScrollBar's contain ArrowButtons. To bind a style to this &lt;code&gt;Region&lt;/code&gt; use the name &lt;code&gt;ArrowButton&lt;/code&gt;.</source>
          <target state="translated">ArrowButton은 방향 표시기 (일반적으로 화살표)도 렌더링하는 특수한 유형의 버튼입니다. ArrowButtons는 복합 구성 요소에서 사용됩니다. 예를 들어 ScrollBar에는 ArrowButton이 포함되어 있습니다. 이 &lt;code&gt;Region&lt;/code&gt; 스타일을 바인딩하려면 이름 &lt;code&gt;ArrowButton&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cc73ee5807d168a1d8aacc166c82c2ee7c47082" translate="yes" xml:space="preserve">
          <source>ArrowButtonListener</source>
          <target state="translated">ArrowButtonListener</target>
        </trans-unit>
        <trans-unit id="85039c6640a4167808be49d7f6bbb5c37d904454" translate="yes" xml:space="preserve">
          <source>Artificial unit that represents the concept of forever.</source>
          <target state="translated">영원히의 개념을 나타내는 인공 유닛.</target>
        </trans-unit>
        <trans-unit id="09a0f3f10a2375351ccbcd46c508e740e33c0052" translate="yes" xml:space="preserve">
          <source>Artificial unit that represents the concept of forever. This is primarily used with &lt;a href=&quot;temporalfield&quot;&gt;&lt;code&gt;TemporalField&lt;/code&gt;&lt;/a&gt; to represent unbounded fields such as the year or era. The estimated duration of the era is artificially defined as the largest duration supported by &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">영원히의 개념을 나타내는 인공적인 단위. 이것은 주로 &lt;a href=&quot;temporalfield&quot;&gt; &lt;code&gt;TemporalField&lt;/code&gt; &lt;/a&gt; 와 함께 사용되어 연도 또는 연대와 같은 무한한 필드를 나타냅니다. 최대 지속 시간에 의해 지원되는 시대의 예상 기간은 인위적으로 정의 된 &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28878bd911a6e2161201f12a752b16a0e3a64e59" translate="yes" xml:space="preserve">
          <source>Artificial unit that represents the concept of forever. This is primarily used with &lt;a href=&quot;temporalfield&quot;&gt;&lt;code&gt;TemporalField&lt;/code&gt;&lt;/a&gt; to represent unbounded fields such as the year or era. The estimated duration of this unit is artificially defined as the largest duration supported by &lt;a href=&quot;../duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">영원히의 개념을 나타내는 인공 유닛. 이것은 주로 &lt;a href=&quot;temporalfield&quot;&gt; &lt;code&gt;TemporalField&lt;/code&gt; &lt;/a&gt; 와 함께 사용되어 연도 또는 연대와 같은 무제한 필드를 나타냅니다. 이 단위의 예상 기간은 &lt;a href=&quot;../duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; 에서&lt;/a&gt; 지원하는 최대 기간으로 인위적으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="51055c590ce92112eede9c3d7b64cc8efee1e10c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;ArrayType&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;ArrayType&lt;/code&gt; 의 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="8a06eee7db8e8e0c95360d596e24304443d3c08a" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;ArrayType&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">으로 &lt;code&gt;ArrayType&lt;/code&gt; 의 인스턴스는 불변,이 인스턴스의 캐릭터 라인 표현은, 최초의 호출시에 1 회 계산 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4f31c066c80c5ecc56fb18455cfb5f55e8d1452b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;CompositeType&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;CompositeType&lt;/code&gt; 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="14e5a49915ee48848aa83aac1c10d5aa4e7f1ccb" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;CompositeType&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">으로 &lt;code&gt;CompositeType&lt;/code&gt; 인스턴스는 불변,이 인스턴스의 캐릭터 라인 표현은, 최초의 호출시에 1 회 계산 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f39844cef3aced03bf7c027927a3077ca0c207aa" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;EventHandler&lt;/code&gt; ultimately relies on reflection to invoke a method we recommend against targeting an overloaded method. For example, if the target is an instance of the class &lt;code&gt;MyTarget&lt;/code&gt; which is defined as:</source>
          <target state="translated">로 &lt;code&gt;EventHandler&lt;/code&gt; 궁극적으로 메소드를 호출하는 반사에 의존하는 우리는 오버로드 된 메서드를 대상에 좋습니다. 예를 들어, 대상이 &lt;code&gt;MyTarget&lt;/code&gt; 클래스의 인스턴스 인 경우 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee103e1a122355fcb9e79b4fe3fc234251537c4" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">같이 &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="946d6e26cfa18c5dae68a73cdfafd66ae3e8c5fc" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 인스턴스는 불변,이 인스턴스의 캐릭터 라인 표현은, 최초의 호출시에 1 회 계산 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9bfab5877cfd4aadd260affbf021286f773564b5" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanConstructorInfoSupport&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">으로 &lt;code&gt;OpenMBeanConstructorInfoSupport&lt;/code&gt; 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="7ac07f54833c9ed8e5c753676bb8a2eddf1a57aa" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanConstructorInfoSupport&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">으로 &lt;code&gt;OpenMBeanConstructorInfoSupport&lt;/code&gt; 인스턴스는 불변,이 인스턴스의 캐릭터 라인 표현은, 최초의 호출시에 1 회 계산 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf0445af58e188e046e7e859bff2655bb05cf95" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanInfoSupport&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;OpenMBeanInfoSupport&lt;/code&gt; 의 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출되고 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="428c0b090909064feea96c5ea3e0851adaf9590a" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanInfoSupport&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;OpenMBeanInfoSupport&lt;/code&gt; 의 인스턴스는 불변이고, 이것은 예를 들면 문자열 표현은 처음 호출에 1 회만 산출되고 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b3c738e291bc0c1040cfbeb66d921626f9eb1fdc" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; 의 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출되고 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="227aadac004a08ea1ee54c3a5b5ecd8b3b17e38b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">으로 &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; 의 인스턴스는 불변,이 인스턴스의 캐릭터 라인 표현은, 최초의 호출시에 1 회 만 계산됩니다 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c6930e46117c4bb5747552c4bb0b1e5ed8204dae" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 의 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="c28102d97791fec60864d02ec9584b7d0725f6f7" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">마찬가지로 &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 의 인스턴스는 불변이고, 이것은 예를 들면 문자열 표현은 처음 호출에 1 회만 산출되고 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f4aa7fa6a849490533c1d02585baa36a48ace15e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;SimpleType&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">같이 &lt;code&gt;SimpleType&lt;/code&gt; 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="ab6cadd5d40419488fed610574bff741e74a9113" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;SimpleType&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">으로 &lt;code&gt;SimpleType&lt;/code&gt; 인스턴스는 불변,이 인스턴스의 캐릭터 라인 표현은, 최초의 호출시에 1 회 만 계산됩니다 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="93bc4d923197d0977c93323bf2dfa7f5a46914ed" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;TabularType&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once, on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">대로 &lt;code&gt;TabularType&lt;/code&gt; 인스턴스는 불변이 인스턴스 해시 코드의 최초의 호출시에 1 회만 산출 &lt;code&gt;hashCode&lt;/code&gt; 및 그 후의 호출에는 같은 값이 반환된다.</target>
        </trans-unit>
        <trans-unit id="047b3ab07b8a9ec14650cf8b2c56435c20d42ea5" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;TabularType&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once, on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.</source>
          <target state="translated">으로 &lt;code&gt;TabularType&lt;/code&gt; 인스턴스는 불변,이 인스턴스의 캐릭터 라인 표현은, 최초의 호출시에 1 회 만 계산됩니다 &lt;code&gt;toString&lt;/code&gt; , 그리고 그 후의 호출에는 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="396ab8afee4eb44f6c8771bdd963d301172563d2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;c1&lt;/code&gt; is the largest of the three components, the parallel group is sized to &lt;code&gt;c1&lt;/code&gt;. As &lt;code&gt;c2&lt;/code&gt; and &lt;code&gt;c3&lt;/code&gt; are smaller than &lt;code&gt;c1&lt;/code&gt; they are aligned based on the alignment specified for the component (if specified) or the default alignment of the parallel group. In the diagram &lt;code&gt;c2&lt;/code&gt; and &lt;code&gt;c3&lt;/code&gt; were created with an alignment of &lt;code&gt;LEADING&lt;/code&gt;. If the component orientation were right-to-left then &lt;code&gt;c2&lt;/code&gt; and &lt;code&gt;c3&lt;/code&gt; would be positioned on the opposite side.</source>
          <target state="translated">마찬가지로 &lt;code&gt;c1&lt;/code&gt; 세 성분의 가장 큰 병렬 그룹 크기로되어있다 &lt;code&gt;c1&lt;/code&gt; . 마찬가지로 &lt;code&gt;c2&lt;/code&gt; 및 &lt;code&gt;c3&lt;/code&gt; 보다 작은 &lt;code&gt;c1&lt;/code&gt; 들은 (지정된 경우) 컴포넌트에 지정된 정렬 또는 병렬 기의 기본 정렬에 기초하여 정렬된다. 다이어그램에서 &lt;code&gt;c2&lt;/code&gt; 와 &lt;code&gt;c3&lt;/code&gt; 은 &lt;code&gt;LEADING&lt;/code&gt; 정렬로 생성되었습니다 . 구성 요소 방향이 오른쪽에서 왼쪽이면 &lt;code&gt;c2&lt;/code&gt; 및 &lt;code&gt;c3&lt;/code&gt; 은 반대쪽에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="28a1d751cfb71b7fcb97fc65216d17c414cf67ab" translate="yes" xml:space="preserve">
          <source>As RFC 1122 section 4.2.4.2 indicates, a compliant TCP implementation should, but is not required to, let application change the TOS field during the lifetime of a connection. So whether the type-of-service field can be changed after the TCP connection has been established depends on the implementation in the underlying platform. Applications should not assume that they can change the TOS field after the connection.</source>
          <target state="translated">RFC 1122 섹션 4.2.4.2에서 알 수 있듯이, 호환되는 TCP 구현은 연결 수명 동안 애플리케이션이 TOS 필드를 변경하도록해야하지만 필수는 아닙니다. 따라서 TCP 연결이 설정된 후 서비스 유형 필드를 변경할 수 있는지 여부는 기본 플랫폼의 구현에 따라 다릅니다. 응용 프로그램은 연결 후 TOS 필드를 변경할 수 있다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e1f390e0b93e35b816181456c6d7c90804944390" translate="yes" xml:space="preserve">
          <source>As SO_SNDBUF is a hint, applications that want to verify what size the buffer is should call &lt;a href=&quot;#getSendBufferSize()&quot;&gt;&lt;code&gt;getSendBufferSize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SO_SNDBUF가 힌트이므로 버퍼 크기를 확인하려는 응용 프로그램은 &lt;a href=&quot;#getSendBufferSize()&quot;&gt; &lt;code&gt;getSendBufferSize()&lt;/code&gt; &lt;/a&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="63933179360786262318bf144605f9c23c651e60" translate="yes" xml:space="preserve">
          <source>As SO_SNDBUF is a hint, applications that want to verify what size the buffer is should call &lt;a href=&quot;datagramsocket#getSendBufferSize--&quot;&gt;&lt;code&gt;getSendBufferSize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SO_SNDBUF는 힌트이므로 버퍼 크기를 확인하려는 응용 프로그램은 &lt;a href=&quot;datagramsocket#getSendBufferSize--&quot;&gt; &lt;code&gt;getSendBufferSize()&lt;/code&gt; &lt;/a&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c126704b5a3fcc95e4f56fd04a4805113d3d177" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;code&gt;BorderLayout&lt;/code&gt; interprets the absence of a string specification the same as the constant &lt;code&gt;CENTER&lt;/code&gt;:</source>
          <target state="translated">As a convenience, &lt;code&gt;BorderLayout&lt;/code&gt; interprets the absence of a string specification the same as the constant &lt;code&gt;CENTER&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="623216a332823a9b42526097333c8db524b41960" translate="yes" xml:space="preserve">
          <source>As a convenience, the standard classes that implement this interface (such as &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, &lt;code&gt;JWindow&lt;/code&gt;, &lt;code&gt;JApplet&lt;/code&gt;, and &lt;code&gt;JInternalFrame&lt;/code&gt;) have their &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;setLayout&lt;/code&gt; methods overridden, so that they delegate calls to the corresponding methods of the &lt;code&gt;ContentPane&lt;/code&gt;. For example, you can add a child component to a frame as follows:</source>
          <target state="translated">As a convenience, the standard classes that implement this interface (such as &lt;code&gt;JFrame&lt;/code&gt; , &lt;code&gt;JDialog&lt;/code&gt; , &lt;code&gt;JWindow&lt;/code&gt; , &lt;code&gt;JApplet&lt;/code&gt; , and &lt;code&gt;JInternalFrame&lt;/code&gt; ) have their &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , and &lt;code&gt;setLayout&lt;/code&gt; methods overridden, so that they delegate calls to the corresponding methods of the &lt;code&gt;ContentPane&lt;/code&gt; . For example, you can add a child component to a frame as follows:</target>
        </trans-unit>
        <trans-unit id="1384114084e4b557636b3a669133612afbae554c" translate="yes" xml:space="preserve">
          <source>As a corner case, an uncasted &lt;code&gt;null&lt;/code&gt; argument is given a symbolic type descriptor of &lt;code&gt;java.lang.Void&lt;/code&gt;. The ambiguity with the type &lt;code&gt;Void&lt;/code&gt; is harmless, since there are no references of type &lt;code&gt;Void&lt;/code&gt; except the null reference.</source>
          <target state="translated">모퉁이의 경우, 캐스트되지 않은 &lt;code&gt;null&lt;/code&gt; 인수에는 &lt;code&gt;java.lang.Void&lt;/code&gt; 의 기호 유형 설명자가 제공 됩니다. &lt;code&gt;Void&lt;/code&gt; 유형에 대한 모호성 은 널 참조를 제외하고 &lt;code&gt;Void&lt;/code&gt; 유형에 대한 참조가 없기 때문에 무해 합니다.</target>
        </trans-unit>
        <trans-unit id="4dd15ca7767698ca99948d2fe7faf753510dcb36" translate="yes" xml:space="preserve">
          <source>As a corollary of this, access to protected members is restricted to receivers only of the accessing class, or one of its subclasses, and the accessing class must in turn be a subclass (or package sibling) of the protected member's defining class. If a method reference refers to a protected non-static method or field of a class outside the current package, the receiver argument will be narrowed to the type of the accessing class.</source>
          <target state="translated">이를 위해 보호 된 멤버에 대한 액세스는 액세스하는 클래스 또는 해당 서브 클래스 중 하나의 수신자로만 제한되며, 액세스하는 클래스는 보호 된 멤버 정의 클래스의 서브 클래스 (또는 패키지 형제) 여야합니다. 메소드 참조가 현재 패키지 외부의 클래스의 보호 된 비 정적 메소드 또는 필드를 참조하는 경우 수신자 인수는 액세스 클래스의 유형으로 좁 힙니다.</target>
        </trans-unit>
        <trans-unit id="b5e2fbf4bf3c3874328b22e88bce1d044494b951" translate="yes" xml:space="preserve">
          <source>As a corollary, two threads must not attempt to call the same method (either &lt;code&gt;wrap()&lt;/code&gt; or &lt;code&gt;unwrap()&lt;/code&gt;) concurrently, because there is no way to guarantee the eventual packet ordering.</source>
          <target state="translated">결과적으로 두 개의 스레드는 최종 패킷 순서를 보장 할 방법이 없으므로 동일한 메소드 ( &lt;code&gt;wrap()&lt;/code&gt; 또는 &lt;code&gt;unwrap()&lt;/code&gt; )를 동시에 호출하려고 시도해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="294df90d4fa2b7808301cd9a5c8eb1990b072037" translate="yes" xml:space="preserve">
          <source>As a delegate of Views, this object is responsible for the insets of a View and making sure the background is maintained according to the CSS attributes.</source>
          <target state="translated">As a delegate of Views, this object is responsible for the insets of a View and making sure the background is maintained according to the CSS attributes.</target>
        </trans-unit>
        <trans-unit id="580e11f8bfcdf88928df2e045bb0ed702f504ca2" translate="yes" xml:space="preserve">
          <source>As a further improvement, notice that the left task need not even exist. Instead of creating a new one, we can iterate using the original task, and add a pending count for each fork. Additionally, because no task in this tree implements an &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;tryComplete()&lt;/code&gt; can be replaced with &lt;a href=&quot;countedcompleter#propagateCompletion--&quot;&gt;&lt;code&gt;propagateCompletion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추가 개선으로, 왼쪽 작업이 존재하지 않아도됩니다. 새 작업을 만드는 대신 원래 작업을 사용하여 반복하고 각 포크에 대해 보류 카운트를 추가 할 수 있습니다. 또한이 트리의 어떤 작업도 &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; 메서드를 구현하지 않으므로 &lt;code&gt;tryComplete()&lt;/code&gt; 을 &lt;a href=&quot;countedcompleter#propagateCompletion--&quot;&gt; &lt;code&gt;propagateCompletion()&lt;/code&gt; &lt;/a&gt; 로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bad71a3fb8ccd4692da1314d34451b8a2867d03" translate="yes" xml:space="preserve">
          <source>As a further optimization, notice that the left task need not even exist. Instead of creating a new one, we can continue using the original task, and add a pending count for each fork. Additionally, because no task in this tree implements an &lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;tryComplete&lt;/code&gt; can be replaced with &lt;a href=&quot;#propagateCompletion()&quot;&gt;&lt;code&gt;propagateCompletion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">As a further optimization, notice that the left task need not even exist. Instead of creating a new one, we can continue using the original task, and add a pending count for each fork. Additionally, because no task in this tree implements an &lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; method, &lt;code&gt;tryComplete&lt;/code&gt; can be replaced with &lt;a href=&quot;#propagateCompletion()&quot;&gt; &lt;code&gt;propagateCompletion()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b8b19025d85d644eb22f97cbd0fa732dcda56af0" translate="yes" xml:space="preserve">
          <source>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the &lt;code&gt;HashMap&lt;/code&gt; class, including &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</source>
          <target state="translated">일반적으로 기본로드 팩터 (.75)는 시간과 공간 비용간에 좋은 균형을 제공합니다. 값이 클수록 공간 오버 헤드는 줄어들지 만 조회 비용은 증가합니다 ( &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; 을 포함한 대부분의 &lt;code&gt;HashMap&lt;/code&gt; 클래스 작업에 반영됨 ). 초기 용량을 설정할 때 재해시 작업의 수를 최소화하기 위해 맵의 예상 항목 수와로드 계수를 고려해야합니다. 초기 용량이 최대 항목 수를로드 계수로 나눈 값보다 큰 경우 재해시 작업이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f05ad47986d3ce6ff04a4c600cb7bc75a4a5dad" translate="yes" xml:space="preserve">
          <source>As a guide to naming &lt;code&gt;SyncProvider&lt;/code&gt; implementations, the following should be noted:</source>
          <target state="translated">As a guide to naming &lt;code&gt;SyncProvider&lt;/code&gt; implementations, the following should be noted:</target>
        </trans-unit>
        <trans-unit id="e854b3bf3147e12e70b3724dc0c7a2eaff478c26" translate="yes" xml:space="preserve">
          <source>As a matter of pure convention, the &lt;a href=&quot;methodhandles.lookup#lookupClass&quot;&gt;lookup class&lt;/a&gt; of this lookup object will be &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">순수한 규칙에 따라이 조회 객체 의 &lt;a href=&quot;methodhandles.lookup#lookupClass&quot;&gt;조회 클래스&lt;/a&gt; 는 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d14768545d05835f3609fcc1faf367631d891a6e" translate="yes" xml:space="preserve">
          <source>As a matter of pure convention, the &lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;lookup class&lt;/a&gt; of this lookup object will be &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">As a matter of pure convention, the &lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;lookup class&lt;/a&gt; of this lookup object will be &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7b19e5b4703495ec90563138008d666eca821389" translate="yes" xml:space="preserve">
          <source>As a matter of style, programmers should always use this annotation on the most deeply nested element where it is effective. If you want to suppress a warning in a particular method, you should annotate that method rather than its class.</source>
          <target state="translated">스타일의 문제로 프로그래머는 항상 가장 깊은 중첩 요소에이 주석을 사용해야합니다. 특정 메소드에서 경고를 표시하지 않으려면 해당 클래스가 아닌 해당 메소드에 주석을 달아야합니다.</target>
        </trans-unit>
        <trans-unit id="4b54334dbad11746d8242cb8b52d1a32929adbea" translate="yes" xml:space="preserve">
          <source>As a numeric identifier.</source>
          <target state="translated">숫자 식별자로.</target>
        </trans-unit>
        <trans-unit id="10ae13ed4ff91de1ecaf9c67004a39286fa17f1e" translate="yes" xml:space="preserve">
          <source>As a particular instance of the &lt;a href=&quot;package-summary&quot;&gt;general accuracy requirements&lt;/a&gt; and the ordering behavior required of this interface, the list of enclosed elements will be returned in the natural order for the originating source of information about the type. For example, if the information about the type is originating from a source file, the elements will be returned in source code order. (However, in that case the the ordering of &lt;a href=&quot;../util/elements.origin#MANDATED&quot;&gt;implicitly declared&lt;/a&gt; elements, such as default constructors, is not specified.)</source>
          <target state="translated">As a particular instance of the &lt;a href=&quot;package-summary&quot;&gt;general accuracy requirements&lt;/a&gt; and the ordering behavior required of this interface, the list of enclosed elements will be returned in the natural order for the originating source of information about the type. For example, if the information about the type is originating from a source file, the elements will be returned in source code order. (However, in that case the the ordering of &lt;a href=&quot;../util/elements.origin#MANDATED&quot;&gt;implicitly declared&lt;/a&gt; elements, such as default constructors, is not specified.)</target>
        </trans-unit>
        <trans-unit id="4ea0debaf0c58be87193507940bb32b65aead044" translate="yes" xml:space="preserve">
          <source>As a rule, the &lt;code&gt;equals&lt;/code&gt; method should be used by implementations of this class to decide if two keys are the same.</source>
          <target state="translated">일반적 으로이 클래스의 구현 에서는 &lt;code&gt;equals&lt;/code&gt; 메서드를 사용하여 두 개의 키가 같은지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc11a3f7d42b1ac540afd0c6c3ee9d0bfe836f85" translate="yes" xml:space="preserve">
          <source>As a special case, a value of -1 will produce a single large segment with all input files, while a value of 0 will produce one segment for each class. Larger archive segments result in less fragmentation and better compression, but processing them requires more memory.</source>
          <target state="translated">특별한 경우, 값이 -1이면 모든 입력 파일이있는 하나의 큰 세그먼트가 생성되고 값이 0이면 각 클래스에 대해 하나의 세그먼트가 생성됩니다. 아카이브 세그먼트가 클수록 조각화가 적고 압축률이 높아지지만 처리시 더 많은 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6ffc2cd29b50910748b3dfc8aac2d22991c2da03" translate="yes" xml:space="preserve">
          <source>As a special case, if the body contributes only &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; types, with no additional &lt;code&gt;A&lt;/code&gt; types, then the internal parameter list is extended by the argument types &lt;code&gt;A...&lt;/code&gt; of the &lt;code&gt;end&lt;/code&gt; handle.</source>
          <target state="translated">As a special case, if the body contributes only &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; types, with no additional &lt;code&gt;A&lt;/code&gt; types, then the internal parameter list is extended by the argument types &lt;code&gt;A...&lt;/code&gt; of the &lt;code&gt;end&lt;/code&gt; handle.</target>
        </trans-unit>
        <trans-unit id="0543fa2121ace689795a5b36a10d99cf789f79b8" translate="yes" xml:space="preserve">
          <source>As a special case, if the body contributes only &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; types, with no additional &lt;code&gt;A&lt;/code&gt; types, then the internal parameter list is extended by the argument types &lt;code&gt;A...&lt;/code&gt; of the &lt;code&gt;iterations&lt;/code&gt; handle.</source>
          <target state="translated">As a special case, if the body contributes only &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; types, with no additional &lt;code&gt;A&lt;/code&gt; types, then the internal parameter list is extended by the argument types &lt;code&gt;A...&lt;/code&gt; of the &lt;code&gt;iterations&lt;/code&gt; handle.</target>
        </trans-unit>
        <trans-unit id="c77f144e7f31f7133a206cb54181a33e19ca97bd" translate="yes" xml:space="preserve">
          <source>As a special case, if the body contributes only &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; types, with no additional &lt;code&gt;A&lt;/code&gt; types, then the internal parameter list is extended by the argument types &lt;code&gt;A...&lt;/code&gt; of the &lt;code&gt;iterator&lt;/code&gt; handle; if it is &lt;code&gt;null&lt;/code&gt; the single type &lt;code&gt;Iterable&lt;/code&gt; is added and constitutes the &lt;code&gt;A...&lt;/code&gt; list.</source>
          <target state="translated">As a special case, if the body contributes only &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; types, with no additional &lt;code&gt;A&lt;/code&gt; types, then the internal parameter list is extended by the argument types &lt;code&gt;A...&lt;/code&gt; of the &lt;code&gt;iterator&lt;/code&gt; handle; if it is &lt;code&gt;null&lt;/code&gt; the single type &lt;code&gt;Iterable&lt;/code&gt; is added and constitutes the &lt;code&gt;A...&lt;/code&gt; list.</target>
        </trans-unit>
        <trans-unit id="08b0d14a79938767ce36fbb2707705d3d9cc39a1" translate="yes" xml:space="preserve">
          <source>As a special case, urls of the form, &quot;scheme:*&quot; are accepted to mean any url of the given scheme.</source>
          <target state="translated">특별한 경우, &quot;scheme : *&quot;형식의 URL은 주어진 체계의 모든 URL을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="84f7d6bfe0569d881c0e177f460ee852887b2dff" translate="yes" xml:space="preserve">
          <source>As a special case, when the Core Reflection API is used to view the signature polymorphic access mode methods in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by &lt;a href=&quot;../class#getDeclaredMethod(java.lang.String,java.lang.Class...)&quot;&gt;&lt;code&gt;Class.getDeclaredMethod&lt;/code&gt;&lt;/a&gt;, is unaffected by their special status in this API. For example, &lt;a href=&quot;../reflect/executable#getModifiers()&quot;&gt;&lt;code&gt;Method.getModifiers&lt;/code&gt;&lt;/a&gt; will report exactly those modifier bits required for any similarly declared method, including in this case &lt;code&gt;native&lt;/code&gt; and &lt;code&gt;varargs&lt;/code&gt; bits.</source>
          <target state="translated">As a special case, when the Core Reflection API is used to view the signature polymorphic access mode methods in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by &lt;a href=&quot;../class#getDeclaredMethod(java.lang.String,java.lang.Class...)&quot;&gt; &lt;code&gt;Class.getDeclaredMethod&lt;/code&gt; &lt;/a&gt;, is unaffected by their special status in this API. For example, &lt;a href=&quot;../reflect/executable#getModifiers()&quot;&gt; &lt;code&gt;Method.getModifiers&lt;/code&gt; &lt;/a&gt; will report exactly those modifier bits required for any similarly declared method, including in this case &lt;code&gt;native&lt;/code&gt; and &lt;code&gt;varargs&lt;/code&gt; bits.</target>
        </trans-unit>
        <trans-unit id="461db1b17375856f1f73326f8f768f30bff7ae49" translate="yes" xml:space="preserve">
          <source>As a special case, when the Core Reflection API is used to view the signature polymorphic methods &lt;code&gt;invokeExact&lt;/code&gt; or plain &lt;code&gt;invoke&lt;/code&gt; in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by &lt;a href=&quot;../class#getDeclaredMethod(java.lang.String,java.lang.Class...)&quot;&gt;&lt;code&gt;Class.getDeclaredMethod&lt;/code&gt;&lt;/a&gt;, is unaffected by their special status in this API. For example, &lt;a href=&quot;../reflect/executable#getModifiers()&quot;&gt;&lt;code&gt;Method.getModifiers&lt;/code&gt;&lt;/a&gt; will report exactly those modifier bits required for any similarly declared method, including in this case &lt;code&gt;native&lt;/code&gt; and &lt;code&gt;varargs&lt;/code&gt; bits.</source>
          <target state="translated">As a special case, when the Core Reflection API is used to view the signature polymorphic methods &lt;code&gt;invokeExact&lt;/code&gt; or plain &lt;code&gt;invoke&lt;/code&gt; in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by &lt;a href=&quot;../class#getDeclaredMethod(java.lang.String,java.lang.Class...)&quot;&gt; &lt;code&gt;Class.getDeclaredMethod&lt;/code&gt; &lt;/a&gt;, is unaffected by their special status in this API. For example, &lt;a href=&quot;../reflect/executable#getModifiers()&quot;&gt; &lt;code&gt;Method.getModifiers&lt;/code&gt; &lt;/a&gt; will report exactly those modifier bits required for any similarly declared method, including in this case &lt;code&gt;native&lt;/code&gt; and &lt;code&gt;varargs&lt;/code&gt; bits.</target>
        </trans-unit>
        <trans-unit id="216f9961d4139cec8f0bddd8265f28e7c9a615bb" translate="yes" xml:space="preserve">
          <source>As a special case, when the Core Reflection API is used to view the signature polymorphic methods &lt;code&gt;invokeExact&lt;/code&gt; or plain &lt;code&gt;invoke&lt;/code&gt; in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by &lt;a href=&quot;../class#getDeclaredMethod-java.lang.String-java.lang.Class...-&quot;&gt;&lt;code&gt;Class.getDeclaredMethod&lt;/code&gt;&lt;/a&gt;, is unaffected by their special status in this API. For example, &lt;a href=&quot;../reflect/method#getModifiers--&quot;&gt;&lt;code&gt;Method.getModifiers&lt;/code&gt;&lt;/a&gt; will report exactly those modifier bits required for any similarly declared method, including in this case &lt;code&gt;native&lt;/code&gt; and &lt;code&gt;varargs&lt;/code&gt; bits.</source>
          <target state="translated">특별한 경우, Core Reflection API를 사용 하여이 클래스에서 &lt;code&gt;invokeExact&lt;/code&gt; 또는 일반 &lt;code&gt;invoke&lt;/code&gt; 시그니처 다형성 메소드를 볼 때 일반적인 비다 형성 메소드 로 나타납니다. &lt;a href=&quot;../class#getDeclaredMethod-java.lang.String-java.lang.Class...-&quot;&gt; &lt;code&gt;Class.getDeclaredMethod&lt;/code&gt; &lt;/a&gt; 에서 볼 때 반사 모양 은이 API의 특수 상태에 영향을받지 않습니다. 예를 들어, &lt;a href=&quot;../reflect/method#getModifiers--&quot;&gt; &lt;code&gt;Method.getModifiers&lt;/code&gt; &lt;/a&gt; 는이 경우 &lt;code&gt;native&lt;/code&gt; 및 &lt;code&gt;varargs&lt;/code&gt; 비트를 포함하여 유사하게 선언 된 메소드에 필요한 수정 자 비트를 정확하게보고합니다 .</target>
        </trans-unit>
        <trans-unit id="f3508d6b0f8d38b0a073fe61a77c17290460cd9c" translate="yes" xml:space="preserve">
          <source>As a string.</source>
          <target state="translated">문자열로.</target>
        </trans-unit>
        <trans-unit id="02c0e99193c309cd55617591b9c9cc47876658f4" translate="yes" xml:space="preserve">
          <source>As a third example, the line:</source>
          <target state="translated">세 번째 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3cd84df848618f3e33e617ab7faae9f566cbead" translate="yes" xml:space="preserve">
          <source>As all events are delivered on the event dispatching thread, care must be taken in event processing. In particular, a long running task, such as network io or computational intensive processing, executed on the event dispatching thread blocks the event dispatching thread from dispatching any other events. While the event dispatching thread is blocked the application is completely unresponsive to user input. Refer to &lt;a href=&quot;swingworker&quot;&gt;&lt;code&gt;SwingWorker&lt;/code&gt;&lt;/a&gt; for the preferred way to do such processing when working with Swing.</source>
          <target state="translated">As all events are delivered on the event dispatching thread, care must be taken in event processing. In particular, a long running task, such as network io or computational intensive processing, executed on the event dispatching thread blocks the event dispatching thread from dispatching any other events. While the event dispatching thread is blocked the application is completely unresponsive to user input. Refer to &lt;a href=&quot;swingworker&quot;&gt; &lt;code&gt;SwingWorker&lt;/code&gt; &lt;/a&gt; for the preferred way to do such processing when working with Swing.</target>
        </trans-unit>
        <trans-unit id="5a2d3b42ea5a2a4845e3f6b24418f4af05907a8c" translate="yes" xml:space="preserve">
          <source>As already mentioned this supports CSS. We don't support the full CSS spec. Refer to the javadoc of the CSS class to see what properties we support. The two major CSS parsing related concepts we do not currently support are pseudo selectors, such as &lt;code&gt;A:link { color: red }&lt;/code&gt;, and the &lt;code&gt;important&lt;/code&gt; modifier.</source>
          <target state="translated">As already mentioned this supports CSS. We don't support the full CSS spec. Refer to the javadoc of the CSS class to see what properties we support. The two major CSS parsing related concepts we do not currently support are pseudo selectors, such as &lt;code&gt;A:link { color: red }&lt;/code&gt; , and the &lt;code&gt;important&lt;/code&gt; modifier.</target>
        </trans-unit>
        <trans-unit id="fcf3b06fd523e2b92dcafbaa3dc3070a140b52b4" translate="yes" xml:space="preserve">
          <source>As always, GSS-API implementations must impose a local access-control policy on callers to prevent unauthorized callers from acquiring credentials to which they are not entitled. Non-default values for initLifetime and acceptLifetime cannot always be honored by the underlying mechanisms, thus callers should be prepared to call &lt;a href=&quot;#getRemainingInitLifetime(org.ietf.jgss.Oid)&quot;&gt;&lt;code&gt;getRemainingInitLifetime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getRemainingAcceptLifetime(org.ietf.jgss.Oid)&quot;&gt;&lt;code&gt;getRemainingAcceptLifetime&lt;/code&gt;&lt;/a&gt; on the credential.</source>
          <target state="translated">As always, GSS-API implementations must impose a local access-control policy on callers to prevent unauthorized callers from acquiring credentials to which they are not entitled. Non-default values for initLifetime and acceptLifetime cannot always be honored by the underlying mechanisms, thus callers should be prepared to call &lt;a href=&quot;#getRemainingInitLifetime(org.ietf.jgss.Oid)&quot;&gt; &lt;code&gt;getRemainingInitLifetime&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#getRemainingAcceptLifetime(org.ietf.jgss.Oid)&quot;&gt; &lt;code&gt;getRemainingAcceptLifetime&lt;/code&gt; &lt;/a&gt; on the credential.</target>
        </trans-unit>
        <trans-unit id="d20a6ada10d0115ed4b136d5f68578e23b849406" translate="yes" xml:space="preserve">
          <source>As an aid to agents that deploy supporting classes on the search path of the bootstrap class loader, or the search path of the class loader that loads the main agent class, the Java virtual machine arranges for the module of transformed classes to read the unnamed module of both class loaders.</source>
          <target state="translated">As an aid to agents that deploy supporting classes on the search path of the bootstrap class loader, or the search path of the class loader that loads the main agent class, the Java virtual machine arranges for the module of transformed classes to read the unnamed module of both class loaders.</target>
        </trans-unit>
        <trans-unit id="2c8eb36876577789fcdb3c4850fa5c24c780ff9a" translate="yes" xml:space="preserve">
          <source>As an alternative to the generated addresses just described, the &lt;code&gt;serviceURL&lt;/code&gt; address supplied when creating a connector server can specify a &lt;em&gt;directory address&lt;/em&gt; in which to store the provided or generated &lt;code&gt;RMIServer&lt;/code&gt; stub. This directory address is then used by both client and server.</source>
          <target state="translated">방금 설명한 생성 된 주소에 대한 대안으로, 커넥터 서버를 작성할 때 제공되는 &lt;code&gt;serviceURL&lt;/code&gt; 주소 는 제공되거나 생성 된 &lt;code&gt;RMIServer&lt;/code&gt; 스텁 을 저장할 &lt;em&gt;디렉토리 주소&lt;/em&gt; 를 지정할 수 있습니다 . 그런 다음이 디렉토리 주소는 클라이언트와 서버 모두에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d264f31c9b2c8f4622e4e0337771b3dbb526bb93" translate="yes" xml:space="preserve">
          <source>As an alternative, the application can request the value or type of specific attributes:</source>
          <target state="translated">As an alternative, the application can request the value or type of specific attributes:</target>
        </trans-unit>
        <trans-unit id="c1f18943e71618cbbb7bdca802691957dfdda635" translate="yes" xml:space="preserve">
          <source>As an example consider a method in a class that spins in a loop until some flag is set outside of that method. A call to the &lt;code&gt;onSpinWait&lt;/code&gt; method should be placed inside the spin loop.</source>
          <target state="translated">As an example consider a method in a class that spins in a loop until some flag is set outside of that method. A call to the &lt;code&gt;onSpinWait&lt;/code&gt; method should be placed inside the spin loop.</target>
        </trans-unit>
        <trans-unit id="ce78af05eb9f6f37051b98f08c5f9b210775e147" translate="yes" xml:space="preserve">
          <source>As an example consider an Exif image. The &lt;code&gt;TIFFDirectory&lt;/code&gt; instance corresponding to the Exif IFD in the Exif stream would have parent tag &lt;a href=&quot;exifparenttifftagset#TAG_EXIF_IFD_POINTER&quot;&gt;&lt;code&gt;TAG_EXIF_IFD_POINTER&lt;/code&gt;&lt;/a&gt; and would include &lt;a href=&quot;exiftifftagset&quot;&gt;&lt;code&gt;ExifTIFFTagSet&lt;/code&gt;&lt;/a&gt; in its group of known tag sets. The &lt;code&gt;TIFFDirectory&lt;/code&gt; corresponding to this Exif IFD will be contained in the data field of a &lt;code&gt;TIFFField&lt;/code&gt; which will in turn be contained in the &lt;code&gt;TIFFDirectory&lt;/code&gt; corresponding to the primary IFD of the Exif image which will itself have a &lt;code&gt;null&lt;/code&gt;-valued parent tag.</source>
          <target state="translated">As an example consider an Exif image. The &lt;code&gt;TIFFDirectory&lt;/code&gt; instance corresponding to the Exif IFD in the Exif stream would have parent tag &lt;a href=&quot;exifparenttifftagset#TAG_EXIF_IFD_POINTER&quot;&gt; &lt;code&gt;TAG_EXIF_IFD_POINTER&lt;/code&gt; &lt;/a&gt; and would include &lt;a href=&quot;exiftifftagset&quot;&gt; &lt;code&gt;ExifTIFFTagSet&lt;/code&gt; &lt;/a&gt; in its group of known tag sets. The &lt;code&gt;TIFFDirectory&lt;/code&gt; corresponding to this Exif IFD will be contained in the data field of a &lt;code&gt;TIFFField&lt;/code&gt; which will in turn be contained in the &lt;code&gt;TIFFDirectory&lt;/code&gt; corresponding to the primary IFD of the Exif image which will itself have a &lt;code&gt;null&lt;/code&gt; -valued parent tag.</target>
        </trans-unit>
        <trans-unit id="519670b8abe414575f9887bc856f1caca855376c" translate="yes" xml:space="preserve">
          <source>As an example how a parallel computation framework, such as the &lt;code&gt;java.util.stream&lt;/code&gt; package, would use Spliterator in a parallel computation, here is one way to implement an associated parallel forEach, that illustrates the primary usage idiom of splitting off subtasks until the estimated amount of work is small enough to perform sequentially. Here we assume that the order of processing across subtasks doesn't matter; different (forked) tasks may further split and process elements concurrently in undetermined order. This example uses a &lt;a href=&quot;concurrent/countedcompleter&quot;&gt;&lt;code&gt;CountedCompleter&lt;/code&gt;&lt;/a&gt;; similar usages apply to other parallel task constructions.</source>
          <target state="translated">예를 들어 &lt;code&gt;java.util.stream&lt;/code&gt; 패키지 와 같은 병렬 계산 프레임 워크가 병렬 계산 에서 Spliterator를 사용하는 방법은 다음과 같습니다. 예상 작업량은 순차적으로 수행하기에 충분히 작습니다. 여기서 우리는 서브 태스크에서 처리 순서가 중요하지 않다고 가정합니다. 상이한 (포크 된) 태스크는 결정되지 않은 순서로 요소를 동시에 분할 및 처리 할 수있다. 이 예제는 &lt;a href=&quot;concurrent/countedcompleter&quot;&gt; &lt;code&gt;CountedCompleter&lt;/code&gt; &lt;/a&gt; 를 사용합니다 . 다른 병렬 작업 구성에도 유사한 사용법이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8d0ae0a0b146fb1c4a7ccc7080745fe849c0f316" translate="yes" xml:space="preserve">
          <source>As an example of how to transform a stream pipeline that inappropriately uses side-effects to one that does not, the following code searches a stream of strings for those matching a given regular expression, and puts the matches in a list.</source>
          <target state="translated">부작용을 부적절하게 사용하는 스트림 파이프 라인을 그렇지 않은 스트림 파이프 라인으로 변환하는 방법의 예로서, 다음 코드는 주어진 정규 표현식과 일치하는 문자열 스트림을 검색하여 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="be0b4cb6953281dedf890ce02d6399e01e8e281d" translate="yes" xml:space="preserve">
          <source>As an example of the creation and meaning of SocketPermissions, note that if the following permission:</source>
          <target state="translated">SocketPermissions의 작성 및 의미의 예로서 다음과 같은 권한이있는 경우에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="af9f7dce64decac25923a7b89727f0ff8e9ce855" translate="yes" xml:space="preserve">
          <source>As an example, a JAR file named &quot;&lt;code&gt;foo-bar.jar&lt;/code&gt;&quot; will derive a module name &quot;&lt;code&gt;foo.bar&lt;/code&gt;&quot; and no version. A JAR file named &quot;&lt;code&gt;foo-bar-1.2.3-SNAPSHOT.jar&lt;/code&gt;&quot; will derive a module name &quot;&lt;code&gt;foo.bar&lt;/code&gt;&quot; and &quot;&lt;code&gt;1.2.3-SNAPSHOT&lt;/code&gt;&quot; as the version.</source>
          <target state="translated">As an example, a JAR file named &quot; &lt;code&gt;foo-bar.jar&lt;/code&gt; &quot; will derive a module name &quot; &lt;code&gt;foo.bar&lt;/code&gt; &quot; and no version. A JAR file named &quot; &lt;code&gt;foo-bar-1.2.3-SNAPSHOT.jar&lt;/code&gt; &quot; will derive a module name &quot; &lt;code&gt;foo.bar&lt;/code&gt; &quot; and &quot; &lt;code&gt;1.2.3-SNAPSHOT&lt;/code&gt; &quot; as the version.</target>
        </trans-unit>
        <trans-unit id="97b387abc8b857d9304279d1b14c91f4f3312903" translate="yes" xml:space="preserve">
          <source>As an example, a connection ID can look something like this:</source>
          <target state="translated">예를 들어 연결 ID는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f24b1ec4f0deb26b67d4a967e2d2944546f1544" translate="yes" xml:space="preserve">
          <source>As an example, each of the following three lines specifies the key &lt;code&gt;&quot;Truth&quot;&lt;/code&gt; and the associated element value &lt;code&gt;&quot;Beauty&quot;&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 다음 세 줄은 각각 &lt;code&gt;&quot;Truth&quot;&lt;/code&gt; 키 와 관련 요소 값 &lt;code&gt;&quot;Beauty&quot;&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f3eb8046c9fa22260a1f4ffbf4ea69bccaf666b0" translate="yes" xml:space="preserve">
          <source>As an example, suppose a module specifies the following directives:</source>
          <target state="translated">As an example, suppose a module specifies the following directives:</target>
        </trans-unit>
        <trans-unit id="a9d7c71d033ba15d3b2c3f4170e79efd63f690d4" translate="yes" xml:space="preserve">
          <source>As an example, suppose the service is &lt;code&gt;com.example.CodecFactory&lt;/code&gt;, an interface that defines methods for producing encoders and decoders:</source>
          <target state="translated">As an example, suppose the service is &lt;code&gt;com.example.CodecFactory&lt;/code&gt; , an interface that defines methods for producing encoders and decoders:</target>
        </trans-unit>
        <trans-unit id="5287559ce076aa6993abddd37b36a81602b2644f" translate="yes" xml:space="preserve">
          <source>As an example, suppose we have a bounded buffer which supports &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt; methods. If a &lt;code&gt;take&lt;/code&gt; is attempted on an empty buffer, then the thread will block until an item becomes available; if a &lt;code&gt;put&lt;/code&gt; is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting &lt;code&gt;put&lt;/code&gt; threads and &lt;code&gt;take&lt;/code&gt; threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">예를 들어, &lt;code&gt;put&lt;/code&gt; 및 &lt;code&gt;take&lt;/code&gt; 메소드 를 지원하는 경계 버퍼가 있다고 가정하십시오 . 경우 &lt;code&gt;take&lt;/code&gt; 비어있는 버퍼에 시도 항목을 사용할 수있을 때까지, 다음 스레드가 차단됩니다; 경우 &lt;code&gt;put&lt;/code&gt; 전체 버퍼에 시도하는 공간이 될 때까지, 다음 스레드가 차단됩니다. 우리는 기다리게하고 싶은 &lt;code&gt;put&lt;/code&gt; 스레드와 &lt;code&gt;take&lt;/code&gt; 우리가 항목 만 나 공백이 버퍼에 사용할 수있게 한 번에 하나의 스레드를 통지의 최적화를 사용할 수 있도록 별도의 대기 세트에 스레드. 이것은 두 가지 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 사용하여 달성 할 수 있습니다 인스턴스를 .</target>
        </trans-unit>
        <trans-unit id="25026a033fa89a756fd3fbc1cc4ef7249b229f4d" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to find all MBeans where the &lt;code&gt;
 Enabled&lt;/code&gt; attribute is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;Owner&lt;/code&gt; attribute is &lt;code&gt;
 &quot;Duke&quot;&lt;/code&gt;. Here is how you could construct the appropriate &lt;code&gt;QueryExp&lt;/code&gt; by chaining together method calls:</source>
          <target state="translated">As an example, suppose you wanted to find all MBeans where the &lt;code&gt; Enabled&lt;/code&gt; attribute is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;Owner&lt;/code&gt; attribute is &lt;code&gt; &quot;Duke&quot;&lt;/code&gt; . Here is how you could construct the appropriate &lt;code&gt;QueryExp&lt;/code&gt; by chaining together method calls:</target>
        </trans-unit>
        <trans-unit id="fe3bc312e29b02ca913f13cc16a375dece93eb7a" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to find all MBeans where the &lt;code&gt;Enabled&lt;/code&gt; attribute is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;Owner&lt;/code&gt; attribute is &lt;code&gt;&quot;Duke&quot;&lt;/code&gt;. Here is how you could construct the appropriate &lt;code&gt;QueryExp&lt;/code&gt; by chaining together method calls:</source>
          <target state="translated">예를 들어, &lt;code&gt;Enabled&lt;/code&gt; 속성이 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;Owner&lt;/code&gt; 속성이 &lt;code&gt;&quot;Duke&quot;&lt;/code&gt; 인 모든 MBean을 찾고 싶다고 가정하십시오 . 적절한 &lt;code&gt;QueryExp&lt;/code&gt; 를 구성하는 방법은 다음과 같습니다.메소드 호출을 함께 연결 를 .</target>
        </trans-unit>
        <trans-unit id="20743818463fcdeb7f18917626acb2165d277608" translate="yes" xml:space="preserve">
          <source>As an example, the following piece of code:</source>
          <target state="translated">예를 들어 다음 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98bfa17581a2aa8712de27e7e305b34e05a857cb" translate="yes" xml:space="preserve">
          <source>As an example, the strings &quot;Good&quot;, &quot;Better&quot;, and &quot;Best&quot; could be associated with the ranges &lt;code&gt;[0, .33)&lt;/code&gt;, &lt;code&gt;[.33, .66)&lt;/code&gt;, and &lt;code&gt;[.66, 1.0]&lt;/code&gt;. In this case, &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; would return &lt;code&gt;{ &quot;Good&quot;, &quot;Better&quot;, &quot;Best&quot; }&lt;/code&gt; and &lt;code&gt;getCompressionQualityValues&lt;/code&gt; would return &lt;code&gt;{ 0.0F, .33F, .66F, 1.0F }&lt;/code&gt;.</source>
          <target state="translated">예를 들어 문자열 &quot;Good&quot;, &quot;Better&quot;및 &quot;Best&quot;는 &lt;code&gt;[0, .33)&lt;/code&gt; , &lt;code&gt;[.33, .66)&lt;/code&gt; 및 &lt;code&gt;[.66, 1.0]&lt;/code&gt; 범위와 연관 될 수 있습니다 . 이 경우 &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; 는 &lt;code&gt;{ &quot;Good&quot;, &quot;Better&quot;, &quot;Best&quot; }&lt;/code&gt; 를 리턴 하고 &lt;code&gt;getCompressionQualityValues&lt;/code&gt; 는 &lt;code&gt;{ 0.0F, .33F, .66F, 1.0F }&lt;/code&gt; 리턴합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="7c84b909cb394014f6e9e28fcceef3cdf0b27e39" translate="yes" xml:space="preserve">
          <source>As an example, think of two Language Priority Lists each of which includes only one language range and a set of following language tags:</source>
          <target state="translated">예를 들어, 각각 하나의 언어 범위와 다음 언어 태그 세트를 포함하는 두 개의 언어 우선 순위 목록을 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="b74235f16bc65bf0ded8643900f93d34fe2af4db" translate="yes" xml:space="preserve">
          <source>As another example, if the &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">다른 예로서, &lt;code&gt;JMXServiceURL&lt;/code&gt; 이 다음 과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="d3aa2758b9604888fefa6adbf8630b3457e22630" translate="yes" xml:space="preserve">
          <source>As another example, the following three lines specify a single property:</source>
          <target state="translated">다른 예로, 다음 세 줄은 단일 속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cf8bb67abb028308da14d13bd3f1168caca43131" translate="yes" xml:space="preserve">
          <source>As another example, this code allows &lt;code&gt;long&lt;/code&gt; types to be assigned from entries in a file &lt;code&gt;myNumbers&lt;/code&gt;:</source>
          <target state="translated">다른 예로,이 코드를 사용하면 &lt;code&gt;myNumbers&lt;/code&gt; 파일의 항목에서 &lt;code&gt;long&lt;/code&gt; 유형을 지정할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="aa967af9ff93d303ea894c49b3d794790a1fff12" translate="yes" xml:space="preserve">
          <source>As appropriate, the tool calls the &lt;a href=&quot;#process(java.util.Set,javax.annotation.processing.RoundEnvironment)&quot;&gt;&lt;code&gt;process&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;Processor&lt;/code&gt; object; a new &lt;code&gt;Processor&lt;/code&gt; object is &lt;em&gt;not&lt;/em&gt; created for each round.</source>
          <target state="translated">As appropriate, the tool calls the &lt;a href=&quot;#process(java.util.Set,javax.annotation.processing.RoundEnvironment)&quot;&gt; &lt;code&gt;process&lt;/code&gt; &lt;/a&gt; method on the &lt;code&gt;Processor&lt;/code&gt; object; a new &lt;code&gt;Processor&lt;/code&gt; object is &lt;em&gt;not&lt;/em&gt; created for each round.</target>
        </trans-unit>
        <trans-unit id="5298b9629494ed8424507f9377213cba4fd0e6bf" translate="yes" xml:space="preserve">
          <source>As appropriate, the tool calls the &lt;a href=&quot;processor#process-java.util.Set-javax.annotation.processing.RoundEnvironment-&quot;&gt;&lt;code&gt;process&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;Processor&lt;/code&gt; object; a new &lt;code&gt;Processor&lt;/code&gt; object is &lt;em&gt;not&lt;/em&gt; created for each round.</source>
          <target state="translated">적절한 경우이 도구 는 &lt;code&gt;Processor&lt;/code&gt; 개체 에서 &lt;a href=&quot;processor#process-java.util.Set-javax.annotation.processing.RoundEnvironment-&quot;&gt; &lt;code&gt;process&lt;/code&gt; &lt;/a&gt; 메서드를 호출 합니다. 각 라운드마다 새로운 &lt;code&gt;Processor&lt;/code&gt; 객체가 생성 &lt;em&gt;되지 않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b6301b17b79ed3b3340c90417e936d981fab12b" translate="yes" xml:space="preserve">
          <source>As described in section 3, &quot;Server Name Indication&quot;, of &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC 6066)&lt;/a&gt;, &quot;HostName&quot; contains the fully qualified DNS hostname of the server, as understood by the client. The encoded server name value of a hostname is represented as a byte string using ASCII encoding without a trailing dot. This allows the support of Internationalized Domain Names (IDN) through the use of A-labels (the ASCII-Compatible Encoding (ACE) form of a valid string of Internationalized Domain Names for Applications (IDNA)) defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc5890.txt&quot;&gt;RFC 5890&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS 확장 (RFC 6066)의&lt;/a&gt; 섹션 3, &quot;서버 이름 표시&quot;에 설명 된대로 &quot;HostName&quot;에는 클라이언트가 이해하는 서버의 정규화 된 DNS 호스트 이름이 포함됩니다. 호스트 이름의 인코딩 된 서버 이름 값은 후행 점없이 ASCII 인코딩을 사용하여 바이트 문자열로 표시됩니다. 이를 통해 &lt;a href=&quot;http://www.ietf.org/rfc/rfc5890.txt&quot;&gt;RFC 5890에&lt;/a&gt; 정의 된 유효한 국제화 된 도메인 이름 응용 프로그램 (IDNA) 문자열의 ASCII 레이블 (ACE) 형식 인 A- 라벨을 사용하여 국제화 된 도메인 이름 (IDN)을 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3bce682edc8c24d9e7ae232cf93cc47f151c707" translate="yes" xml:space="preserve">
          <source>As described in the Java Virtual Machine Specification, certain types in this package are given special treatment by the virtual machine:</source>
          <target state="translated">As described in the Java Virtual Machine Specification, certain types in this package are given special treatment by the virtual machine:</target>
        </trans-unit>
        <trans-unit id="6b4f306157d9d4daaf890904a7cf403b8f976740" translate="yes" xml:space="preserve">
          <source>As described in the Java Virtual Machine Specification, certain types in this package have special relations to dynamic language support in the virtual machine:</source>
          <target state="translated">Java Virtual Machine Specification에 설명 된대로이 패키지의 특정 유형은 가상 시스템의 동적 언어 지원과 특별한 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e701ee63c9d6aac4889cb8fb04b11a80bd1ad2" translate="yes" xml:space="preserve">
          <source>As dictated by the Standard MIDI Files specification, two status byte values are legal for a &lt;code&gt;SysexMessage&lt;/code&gt; read from a MIDI file:</source>
          <target state="translated">표준 MIDI 파일 사양에 따라 두 가지 상태 바이트 값은 MIDI 파일에서 읽은 &lt;code&gt;SysexMessage&lt;/code&gt; 에 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="823211c0e6e5c6f3a690856e6dbbe71cc75eed60" translate="yes" xml:space="preserve">
          <source>As discussed above, performing calculations on a date where the rules of the calendar system are pluggable requires skill and is not recommended. Fortunately, the need to perform calculations on a date in an arbitrary calendar system is extremely rare. For example, it is highly unlikely that the business rules of a library book rental scheme will allow rentals to be for one month, where meaning of the month is dependent on the user's preferred calendar system.</source>
          <target state="translated">위에서 설명한 바와 같이, 달력 시스템의 규칙을 플러그 할 수있는 날짜에 계산을 수행하려면 기술이 필요하므로 권장하지 않습니다. 다행스럽게도 임의의 달력 시스템에서 날짜에 대한 계산을 수행 할 필요는 거의 없습니다. 예를 들어, 도서관 도서 대여 체계의 비즈니스 규칙에 따라 1 개월 동안 임대가 가능할 가능성은 거의 없습니다. 여기서 해당 월의 의미는 사용자가 선호하는 달력 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="36314eb89ebb3a2d4ef9809875cad02204176e33" translate="yes" xml:space="preserve">
          <source>As documented in the JVM specification, all failures arising from the linkage of a dynamic call site are reported by a &lt;a href=&quot;../bootstrapmethoderror&quot;&gt;&lt;code&gt;BootstrapMethodError&lt;/code&gt;&lt;/a&gt;, which is thrown as the abnormal termination of the dynamic call site execution. If this happens, the same error will the thrown for all subsequent attempts to execute the dynamic call site.</source>
          <target state="translated">JVM 스펙에 설명 된대로 동적 호출 사이트의 링크에서 발생하는 모든 실패 는 동적 호출 사이트 실행이 비정상적으로 종료 될 때 발생 하는 &lt;a href=&quot;../bootstrapmethoderror&quot;&gt; &lt;code&gt;BootstrapMethodError&lt;/code&gt; 에&lt;/a&gt; 의해보고됩니다 . 이 경우 동적 호출 사이트를 실행하려는 모든 후속 시도에 대해 동일한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf9e2b2d25d40b2e40f4396be9bb0dd7402e5fb1" translate="yes" xml:space="preserve">
          <source>As empty branch elements are not allowed in the document, if the element is the sole child, its parent element is removed as well, recursively. This means that when replacing all the children of a particular element, new children should be added &lt;em&gt;before&lt;/em&gt; removing old children.</source>
          <target state="translated">As empty branch elements are not allowed in the document, if the element is the sole child, its parent element is removed as well, recursively. This means that when replacing all the children of a particular element, new children should be added &lt;em&gt;before&lt;/em&gt; removing old children.</target>
        </trans-unit>
        <trans-unit id="a10251bdf20853933c47ec19a245569632c05790" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;code&gt;DOMString&lt;/code&gt; interface, text strings in the DOM are represented in UTF-16, i.e. as a sequence of 16-bit units. In the following, the term 16-bit units is used whenever necessary to indicate that indexing on CharacterData is done in 16-bit units.</source>
          <target state="translated">As explained in the &lt;code&gt;DOMString&lt;/code&gt; interface, text strings in the DOM are represented in UTF-16, i.e. as a sequence of 16-bit units. In the following, the term 16-bit units is used whenever necessary to indicate that indexing on CharacterData is done in 16-bit units.</target>
        </trans-unit>
        <trans-unit id="1c5f4783a2e6c5d9961ec49ed626628e6b18d177" translate="yes" xml:space="preserve">
          <source>As far as customizing how the table looks in the printed result, &lt;code&gt;JTable&lt;/code&gt; itself will take care of hiding the selection and focus during printing. For additional customizations, your renderers or painting code can customize the look based on the value of &lt;a href=&quot;jcomponent#isPaintingForPrint()&quot;&gt;&lt;code&gt;JComponent.isPaintingForPrint()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">As far as customizing how the table looks in the printed result, &lt;code&gt;JTable&lt;/code&gt; itself will take care of hiding the selection and focus during printing. For additional customizations, your renderers or painting code can customize the look based on the value of &lt;a href=&quot;jcomponent#isPaintingForPrint()&quot;&gt; &lt;code&gt;JComponent.isPaintingForPrint()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bf1bd957df6b1e6645097076c35d04db35960a2" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;Entity&lt;/code&gt; nodes, &lt;code&gt;EntityReference&lt;/code&gt; nodes and all their descendants are readonly.</source>
          <target state="translated">As for &lt;code&gt;Entity&lt;/code&gt; nodes, &lt;code&gt;EntityReference&lt;/code&gt; nodes and all their descendants are readonly.</target>
        </trans-unit>
        <trans-unit id="4fd4c6616b03047a5039b07c21afb5e7a0ec9d44" translate="yes" xml:space="preserve">
          <source>As for all &lt;code&gt;JComponent&lt;/code&gt; classes, you can use &lt;a href=&quot;inputmap&quot;&gt;&lt;code&gt;InputMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;actionmap&quot;&gt;&lt;code&gt;ActionMap&lt;/code&gt;&lt;/a&gt; to associate an &lt;a href=&quot;action&quot;&gt;&lt;code&gt;Action&lt;/code&gt;&lt;/a&gt; object with a &lt;a href=&quot;keystroke&quot;&gt;&lt;code&gt;KeyStroke&lt;/code&gt;&lt;/a&gt; and execute the action under specified conditions.</source>
          <target state="translated">As for all &lt;code&gt;JComponent&lt;/code&gt; classes, you can use &lt;a href=&quot;inputmap&quot;&gt; &lt;code&gt;InputMap&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;actionmap&quot;&gt; &lt;code&gt;ActionMap&lt;/code&gt; &lt;/a&gt; to associate an &lt;a href=&quot;action&quot;&gt; &lt;code&gt;Action&lt;/code&gt; &lt;/a&gt; object with a &lt;a href=&quot;keystroke&quot;&gt; &lt;code&gt;KeyStroke&lt;/code&gt; &lt;/a&gt; and execute the action under specified conditions.</target>
        </trans-unit>
        <trans-unit id="b894f63cb8c564155a5703563abd39ad622c4ab3" translate="yes" xml:space="preserve">
          <source>As guaranteed by the WebSocket Protocol, the message consists of not more than &lt;code&gt;125&lt;/code&gt; bytes. These bytes are located from the buffer's position to its limit.</source>
          <target state="translated">As guaranteed by the WebSocket Protocol, the message consists of not more than &lt;code&gt;125&lt;/code&gt; bytes. These bytes are located from the buffer's position to its limit.</target>
        </trans-unit>
        <trans-unit id="d08bfa569d3c6b52674c19efff0534f7b7a13392" translate="yes" xml:space="preserve">
          <source>As html skips whitespace the position for text will be the position of the first valid character, eg in the string '\n\n\nblah' the text 'blah' will have a position of 3, the newlines are skipped.</source>
          <target state="translated">As html skips whitespace the position for text will be the position of the first valid character, eg in the string '\n\n\nblah' the text 'blah' will have a position of 3, the newlines are skipped.</target>
        </trans-unit>
        <trans-unit id="c223f6bbf9967816d62342a4c9f6c1437115f662" translate="yes" xml:space="preserve">
          <source>As implied by the above, one valid implementation of this method is given by the expression below which computes a &lt;code&gt;double&lt;/code&gt; with the same exponent and significand as the argument but with a guaranteed zero sign bit indicating a positive value:</source>
          <target state="translated">As implied by the above, one valid implementation of this method is given by the expression below which computes a &lt;code&gt;double&lt;/code&gt; with the same exponent and significand as the argument but with a guaranteed zero sign bit indicating a positive value:</target>
        </trans-unit>
        <trans-unit id="70ed0065184e03471d3e9ef112b8a79b054572ba" translate="yes" xml:space="preserve">
          <source>As implied by the above, one valid implementation of this method is given by the expression below which computes a &lt;code&gt;float&lt;/code&gt; with the same exponent and significand as the argument but with a guaranteed zero sign bit indicating a positive value:</source>
          <target state="translated">As implied by the above, one valid implementation of this method is given by the expression below which computes a &lt;code&gt;float&lt;/code&gt; with the same exponent and significand as the argument but with a guaranteed zero sign bit indicating a positive value:</target>
        </trans-unit>
        <trans-unit id="7620dc9eaffdd8d3c92f18aa3797c61e64859c95" translate="yes" xml:space="preserve">
          <source>As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:</source>
          <target state="translated">하나의 인수 버전에서와 같이 인터럽트 및 스퓨리어스 웨이크 업이 가능하며이 방법은 항상 루프에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6a12f2a545ba53922d480b551f75008baa4d398" translate="yes" xml:space="preserve">
          <source>As inconsistent with &lt;code&gt;hashCode()&lt;/code&gt; contract, use &lt;a href=&quot;#isMimeTypeEqual(java.lang.String)&quot;&gt;&lt;code&gt;isMimeTypeEqual(String)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">As inconsistent with &lt;code&gt;hashCode()&lt;/code&gt; contract, use &lt;a href=&quot;#isMimeTypeEqual(java.lang.String)&quot;&gt; &lt;code&gt;isMimeTypeEqual(String)&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="3de0ea91bebc6cff04f6c4a0b27942aa56579aef" translate="yes" xml:space="preserve">
          <source>As indicated above, there are many issues to consider when try to use and manipulate a date in an arbitrary calendar system. These are some of the key issues.</source>
          <target state="translated">위에 표시된 것처럼 임의의 달력 시스템에서 날짜를 사용하고 조작하려고 할 때 고려해야 할 많은 문제가 있습니다. 이것들은 몇 가지 주요 문제입니다.</target>
        </trans-unit>
        <trans-unit id="5642f21bd06f9e0469d94ef1ca5f2237ede6c426" translate="yes" xml:space="preserve">
          <source>As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action may have unblocked the thread. An implementation should document this behavior.</source>
          <target state="translated">인터럽트는 일반적으로 취소를 의미하고, 인터럽트 검사는 종종 드물기 때문에 구현은 일반적인 메소드 리턴에 대한 인터럽트에 대한 응답을 선호 할 수 있습니다. 다른 조치로 스레드 차단을 해제 한 후 인터럽트가 발생했음을 알 수있는 경우에도 마찬가지입니다. 구현시이 동작을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="682a7908747b239c3cd1be0e6e2d9d7739d4d462" translate="yes" xml:space="preserve">
          <source>As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action that may have unblocked the thread. An implementation should document this behavior.</source>
          <target state="translated">인터럽트는 일반적으로 취소를 의미하고, 인터럽트 검사는 종종 드물기 때문에 구현은 일반적인 메소드 리턴에 대한 인터럽트에 대한 응답을 선호 할 수 있습니다. 스레드를 차단 해제 한 다른 조치 후에 인터럽트가 발생했음을 알 수있는 경우에도 마찬가지입니다. 구현시이 동작을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="deca80918e6f723d8b3411fc4be463146d7fb9d5" translate="yes" xml:space="preserve">
          <source>As is normal with thread-local ordering of write events, every action already performed by the current thread is taken to happen before the volatile write to &lt;code&gt;V&lt;/code&gt;. (In some implementations, this means that the current thread performs a global release operation.)</source>
          <target state="translated">쓰레드-로컬 쓰기 이벤트 순서와 마찬가지로, 현재 쓰레드에 의해 이미 수행 된 모든 액션은 &lt;code&gt;V&lt;/code&gt; 에 휘발성 쓰기 전에 발생합니다 . (일부 구현에서 이것은 현재 스레드가 전역 릴리스 작업을 수행함을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="280fd0ecc7b23215e80f5701196ff52f63873f1c" translate="yes" xml:space="preserve">
          <source>As is the case with other ExecutorServices, there are three main task execution methods summarized in the following table. These are designed to be used primarily by clients not already engaged in fork/join computations in the current pool. The main forms of these methods accept instances of &lt;code&gt;ForkJoinTask&lt;/code&gt;, but overloaded forms also allow mixed execution of plain &lt;code&gt;
 Runnable&lt;/code&gt;- or &lt;code&gt;Callable&lt;/code&gt;- based activities as well. However, tasks that are already executing in a pool should normally instead use the within-computation forms listed in the table unless using async event-style tasks that are not usually joined, in which case there is little difference among choice of methods.</source>
          <target state="translated">As is the case with other ExecutorServices, there are three main task execution methods summarized in the following table. These are designed to be used primarily by clients not already engaged in fork/join computations in the current pool. The main forms of these methods accept instances of &lt;code&gt;ForkJoinTask&lt;/code&gt; , but overloaded forms also allow mixed execution of plain &lt;code&gt; Runnable&lt;/code&gt; - or &lt;code&gt;Callable&lt;/code&gt; - based activities as well. However, tasks that are already executing in a pool should normally instead use the within-computation forms listed in the table unless using async event-style tasks that are not usually joined, in which case there is little difference among choice of methods.</target>
        </trans-unit>
        <trans-unit id="c2b850de7e5f6fae367a3847e0ff710535eb37d2" translate="yes" xml:space="preserve">
          <source>As is the case with other ExecutorServices, there are three main task execution methods summarized in the following table. These are designed to be used primarily by clients not already engaged in fork/join computations in the current pool. The main forms of these methods accept instances of &lt;code&gt;ForkJoinTask&lt;/code&gt;, but overloaded forms also allow mixed execution of plain &lt;code&gt;Runnable&lt;/code&gt;- or &lt;code&gt;Callable&lt;/code&gt;- based activities as well. However, tasks that are already executing in a pool should normally instead use the within-computation forms listed in the table unless using async event-style tasks that are not usually joined, in which case there is little difference among choice of methods.</source>
          <target state="translated">다른 ExecutorService의 경우와 마찬가지로 다음 표에 세 가지 주요 작업 실행 방법이 요약되어 있습니다. 이들은 현재 풀에서 포크 / 조인 계산에 아직 참여하지 않은 클라이언트가 주로 사용하도록 설계되었습니다. 이러한 메소드의 주요 형식은 &lt;code&gt;ForkJoinTask&lt;/code&gt; 인스턴스를 허용하지만 오버로드 된 형식은 일반 &lt;code&gt;Runnable&lt;/code&gt; 또는 &lt;code&gt;Callable&lt;/code&gt; 기반 활동 의 혼합 실행도 허용 합니다. 그러나 풀에서 이미 실행중인 작업은 일반적으로 조인되지 않은 비동기 이벤트 스타일 작업을 사용하지 않는 한 일반적으로 표에 나열된 계산 내 양식을 사용해야합니다.이 경우 메서드 선택에 차이가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="35255f3b8879a5b2a391888c7bcc4428c54ff06c" translate="yes" xml:space="preserve">
          <source>As is usual with virtual methods, source-level calls to &lt;code&gt;invokeExact&lt;/code&gt; and &lt;code&gt;invoke&lt;/code&gt; compile to an &lt;code&gt;invokevirtual&lt;/code&gt; instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must generate instructions that push them on the stack according to their own unconverted types. The method handle object itself is pushed on the stack before the arguments. The compiler then generates an &lt;code&gt;invokevirtual&lt;/code&gt; instruction that invokes the method handle with a symbolic type descriptor which describes the argument and return types.</source>
          <target state="translated">As is usual with virtual methods, source-level calls to &lt;code&gt;invokeExact&lt;/code&gt; and &lt;code&gt;invoke&lt;/code&gt; compile to an &lt;code&gt;invokevirtual&lt;/code&gt; instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must generate instructions that push them on the stack according to their own unconverted types. The method handle object itself is pushed on the stack before the arguments. The compiler then generates an &lt;code&gt;invokevirtual&lt;/code&gt; instruction that invokes the method handle with a symbolic type descriptor which describes the argument and return types.</target>
        </trans-unit>
        <trans-unit id="f4d082e3a7819c6c85102d27161b03668225f32f" translate="yes" xml:space="preserve">
          <source>As is usual with virtual methods, source-level calls to &lt;code&gt;invokeExact&lt;/code&gt; and &lt;code&gt;invoke&lt;/code&gt; compile to an &lt;code&gt;invokevirtual&lt;/code&gt; instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must push them on the stack according to their own unconverted types. The method handle object itself is pushed on the stack before the arguments. The compiler then calls the method handle with a symbolic type descriptor which describes the argument and return types.</source>
          <target state="translated">로 가상 방법에 소스 수준의 통화와 평소 &lt;code&gt;invokeExact&lt;/code&gt; 및 &lt;code&gt;invoke&lt;/code&gt; 에 컴파일 &lt;code&gt;invokevirtual&lt;/code&gt; 명령. 더 일반적으로 컴파일러는 실제 인수 유형을 기록해야하며 인수에 대해 메소드 호출 변환을 수행하지 않을 수 있습니다. 대신 자체 변환되지 않은 유형에 따라 스택에 밀어 넣어야합니다. 메소드 핸들 오브젝트 자체는 인수보다 먼저 스택에서 푸시됩니다. 그런 다음 컴파일러는 인수 및 반환 형식을 설명하는 기호 형식 설명자와 함께 메서드 핸들을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="103795efb378ee6530e68440f6b7990618ac2966" translate="yes" xml:space="preserve">
          <source>As is usual with virtual methods, source-level calls to access mode methods compile to an &lt;code&gt;invokevirtual&lt;/code&gt; instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must generate instructions to push them on the stack according to their own unconverted types. The VarHandle object itself will be pushed on the stack before the arguments. The compiler then generates an &lt;code&gt;invokevirtual&lt;/code&gt; instruction that invokes the access mode method with a symbolic type descriptor which describes the argument and return types.</source>
          <target state="translated">As is usual with virtual methods, source-level calls to access mode methods compile to an &lt;code&gt;invokevirtual&lt;/code&gt; instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must generate instructions to push them on the stack according to their own unconverted types. The VarHandle object itself will be pushed on the stack before the arguments. The compiler then generates an &lt;code&gt;invokevirtual&lt;/code&gt; instruction that invokes the access mode method with a symbolic type descriptor which describes the argument and return types.</target>
        </trans-unit>
        <trans-unit id="74a104890384d5eb34e0f6435f39fc9894819a17" translate="yes" xml:space="preserve">
          <source>As it is typically impractical to obtain the &lt;code&gt;TreeUI&lt;/code&gt; from the &lt;code&gt;JTree&lt;/code&gt; and cast to an instance of &lt;code&gt;MetalTreeUI&lt;/code&gt; you enable this property via the client property &lt;code&gt;JTree.lineStyle&lt;/code&gt;. For example, to switch to &lt;code&gt;Horizontal&lt;/code&gt; style you would do: &lt;code&gt;tree.putClientProperty(&quot;JTree.lineStyle&quot;, &quot;Horizontal&quot;);&lt;/code&gt;</source>
          <target state="translated">As it is typically impractical to obtain the &lt;code&gt;TreeUI&lt;/code&gt; from the &lt;code&gt;JTree&lt;/code&gt; and cast to an instance of &lt;code&gt;MetalTreeUI&lt;/code&gt; you enable this property via the client property &lt;code&gt;JTree.lineStyle&lt;/code&gt; . For example, to switch to &lt;code&gt;Horizontal&lt;/code&gt; style you would do: &lt;code&gt;tree.putClientProperty(&quot;JTree.lineStyle&quot;, &quot;Horizontal&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd413f3a79e5b5d005a16c39828bd3b915ac3102" translate="yes" xml:space="preserve">
          <source>As long as each bootstrap method can be correctly invoked by &lt;code&gt;MethodHandle.invoke&lt;/code&gt;, its detailed type is arbitrary. For example, the first argument could be &lt;code&gt;Object&lt;/code&gt; instead of &lt;code&gt;MethodHandles.Lookup&lt;/code&gt;, and the return type could also be &lt;code&gt;Object&lt;/code&gt; instead of &lt;code&gt;CallSite&lt;/code&gt;. (Note that the types and number of the stacked arguments limit the legal kinds of bootstrap methods to appropriately typed static methods and constructors of &lt;code&gt;CallSite&lt;/code&gt; subclasses.)</source>
          <target state="translated">&lt;code&gt;MethodHandle.invoke&lt;/code&gt; 가 각 부트 스트랩 메소드를 올바르게 호출 할 수있는 한 , 세부 유형은 임의적입니다. 예를 들어, 첫 번째 인수 는 &lt;code&gt;MethodHandles.Lookup&lt;/code&gt; 대신 &lt;code&gt;Object&lt;/code&gt; 일 수 있으며 반환 유형 은 &lt;code&gt;CallSite&lt;/code&gt; 대신 &lt;code&gt;Object&lt;/code&gt; 일 수도 있습니다 . 스택 형 인수의 유형과 수는 유효한 유형의 부트 스트랩 메소드를 적절하게 유형이 지정된 정적 메소드 및 &lt;code&gt;CallSite&lt;/code&gt; 서브 클래스 생성자로 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="e0466654ef45ec448d8ee41f8acfd12ca31c99c4" translate="yes" xml:space="preserve">
          <source>As long as the constraints of the Java Memory Model are obeyed, implementations may delay the completion of a &lt;code&gt;syncAll&lt;/code&gt; operation while other threads (&lt;code&gt;T&lt;/code&gt; above) continue to use previous values of &lt;code&gt;S&lt;/code&gt;'s target. However, implementations are (as always) encouraged to avoid livelock, and to eventually require all threads to take account of the updated target.</source>
          <target state="translated">Java 메모리 모델의 제약 조건을 준수 하는 한 다른 스레드 ( 위의 &lt;code&gt;T&lt;/code&gt; )가 &lt;code&gt;S&lt;/code&gt; 의 대상 의 이전 값을 계속 사용 하는 동안 구현에서 &lt;code&gt;syncAll&lt;/code&gt; 작업 의 완료를 지연시킬 수 있습니다 . 그러나 구현은 라이브 록을 피하고 결국 모든 스레드가 업데이트 된 대상을 고려하도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="930ba2ce92706ad2996098d82d35de349c3e2a75" translate="yes" xml:space="preserve">
          <source>As mentioned in the package description of &lt;code&gt;javax.print&lt;/code&gt;, a &lt;code&gt;null&lt;/code&gt; reference parameter to methods is incorrect unless explicitly documented on the method as having a meaningful interpretation. Usage to the contrary is incorrect coding and may result in a run time exception either immediately or at some later time. &lt;code&gt;IllegalArgumentException&lt;/code&gt; and &lt;code&gt;NullPointerException&lt;/code&gt; are examples of typical and acceptable run time exceptions for such cases.</source>
          <target state="translated">As mentioned in the package description of &lt;code&gt;javax.print&lt;/code&gt; , a &lt;code&gt;null&lt;/code&gt; reference parameter to methods is incorrect unless explicitly documented on the method as having a meaningful interpretation. Usage to the contrary is incorrect coding and may result in a run time exception either immediately or at some later time. &lt;code&gt;IllegalArgumentException&lt;/code&gt; and &lt;code&gt;NullPointerException&lt;/code&gt; are examples of typical and acceptable run time exceptions for such cases.</target>
        </trans-unit>
        <trans-unit id="ef47518c57367cc39530570a388c653f9133e814" translate="yes" xml:space="preserve">
          <source>As mentioned in the package description of javax.print, a null reference parameter to methods is incorrect unless explicitly documented on the method as having a meaningful interpretation. Usage to the contrary is incorrect coding and may result in a run time exception either immediately or at some later time. IllegalArgumentException and NullPointerException are examples of typical and acceptable run time exceptions for such cases.</source>
          <target state="translated">javax.print의 패키지 설명에서 언급했듯이, 메소드에 대한 널 참조 매개 변수는 의미있는 해석을 갖는 것으로 메소드에 명시 적으로 문서화되어 있지 않으면 올바르지 않습니다. 반대로 사용하는 것은 잘못된 코딩이며 즉시 또는 나중에 런타임 예외가 발생할 수 있습니다. IllegalArgumentException 및 NullPointerException은 이러한 경우에 일반적이고 수용 가능한 런타임 예외의 예입니다.</target>
        </trans-unit>
        <trans-unit id="658b60b45ae1f084a108c71ff05f1cfdd970d71f" translate="yes" xml:space="preserve">
          <source>As mentioned, &lt;code&gt;flavor1&lt;/code&gt; and &lt;code&gt;flavor2&lt;/code&gt; are considered identical. As such, asking a &lt;code&gt;Transferable&lt;/code&gt; for either &lt;code&gt;DataFlavor&lt;/code&gt; returns the same results.</source>
          <target state="translated">As mentioned, &lt;code&gt;flavor1&lt;/code&gt; and &lt;code&gt;flavor2&lt;/code&gt; are considered identical. As such, asking a &lt;code&gt;Transferable&lt;/code&gt; for either &lt;code&gt;DataFlavor&lt;/code&gt; returns the same results.</target>
        </trans-unit>
        <trans-unit id="cf0c458e0a3f734bebd8ffc23b81ee99b33a763f" translate="yes" xml:space="preserve">
          <source>As mentioned, URL and URLConnection rely on protocol handlers which must be present, otherwise an Exception is thrown. This is the major difference with URIs which only identify resources, and therefore don't need to have access to the protocol handler. So, while it is possible to create an URI with any kind of protocol scheme (e.g. &lt;code&gt;myproto://myhost.mydomain/resource/&lt;/code&gt;), a similar URL will try to instantiate the handler for the specified protocol; if it doesn't exist an exception will be thrown.</source>
          <target state="translated">언급 한 바와 같이, URL 및 URLConnection은 반드시 존재해야하는 프로토콜 핸들러에 의존합니다. 그렇지 않으면 예외가 발생합니다. 이는 리소스 만 식별하므로 프로토콜 처리기에 액세스 할 필요가없는 URI와의 주요 차이점입니다. 따라서 모든 종류의 프로토콜 체계 (예 : &lt;code&gt;myproto://myhost.mydomain/resource/&lt;/code&gt; ) 를 사용하여 URI를 작성할 수 있지만 유사한 URL은 지정된 프로토콜에 대한 핸들러를 인스턴스화하려고 시도합니다. 존재하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c439206e7a2da26a2faa9d4b4b049cd5b4436121" translate="yes" xml:space="preserve">
          <source>As much as is reasonably practical, the hashCode method defined by class &lt;code&gt;Object&lt;/code&gt; does return distinct integers for distinct objects. (The hashCode may or may not be implemented as some function of an object's memory address at some point in time.)</source>
          <target state="translated">As much as is reasonably practical, the hashCode method defined by class &lt;code&gt;Object&lt;/code&gt; does return distinct integers for distinct objects. (The hashCode may or may not be implemented as some function of an object's memory address at some point in time.)</target>
        </trans-unit>
        <trans-unit id="e74b35b186283378f9b0106c790dba3e1f4abdfd" translate="yes" xml:space="preserve">
          <source>As much as is reasonably practical, the hashCode method defined by class &lt;code&gt;Object&lt;/code&gt; does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java&amp;trade; programming language.)</source>
          <target state="translated">합리적으로 실용적이기는하지만 &lt;code&gt;Object&lt;/code&gt; 클래스에 의해 정의 된 hashCode 메소드 는 개별 오브젝트에 대해 고유 한 정수를 리턴합니다. (일반적으로 이는 오브젝트의 내부 주소를 정수로 변환하여 구현되지만이 구현 기술은 Java &amp;trade; 프로그래밍 언어에 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="896cf238ecb885632ecc94b86442bd80a47d1959" translate="yes" xml:space="preserve">
          <source>As noted above, the actual method type of the bootstrap method can vary. For example, the fourth argument could be &lt;code&gt;MethodHandle&lt;/code&gt;, if that is the type of the corresponding constant in the &lt;code&gt;CONSTANT_InvokeDynamic&lt;/code&gt; entry. In that case, the &lt;code&gt;MethodHandle.invoke&lt;/code&gt; call will pass the extra method handle constant as an &lt;code&gt;Object&lt;/code&gt;, but the type matching machinery of &lt;code&gt;MethodHandle.invoke&lt;/code&gt; will cast the reference back to &lt;code&gt;MethodHandle&lt;/code&gt; before invoking the bootstrap method. (If a string constant were passed instead, by badly generated code, that cast would then fail, resulting in a &lt;code&gt;BootstrapMethodError&lt;/code&gt;.)</source>
          <target state="translated">전술 한 바와 같이, 부트 스트랩 방법의 실제 방법 유형은 다양 할 수있다. 예를 들어, &lt;code&gt;CONSTANT_InvokeDynamic&lt;/code&gt; 항목 의 해당 상수 유형 인 경우 네 번째 인수는 &lt;code&gt;MethodHandle&lt;/code&gt; 일 수 있습니다 . 이 경우 &lt;code&gt;MethodHandle.invoke&lt;/code&gt; 호출은 추가 메소드 핸들 상수를 &lt;code&gt;Object&lt;/code&gt; 로 전달하지만 &lt;code&gt;MethodHandle.invoke&lt;/code&gt; 의 유형 일치 메커니즘 은 부트 스트랩 메소드를 호출하기 전에 참조를 &lt;code&gt;MethodHandle&lt;/code&gt; 로 다시 캐스트합니다 . (잘못 생성 된 코드에 의해 문자열 상수가 대신 전달되면 해당 캐스트가 실패하여 &lt;code&gt;BootstrapMethodError&lt;/code&gt; 가 발생 합니다.)</target>
        </trans-unit>
        <trans-unit id="86d58fb2698a77126c6a3f5dcde06c1be10241ab" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;../lang/autocloseable#close()&quot;&gt;&lt;code&gt;AutoCloseable.close()&lt;/code&gt;&lt;/a&gt;, cases where the close may fail require careful attention. It is strongly advised to relinquish the underlying resources and to internally &lt;em&gt;mark&lt;/em&gt; the &lt;code&gt;Closeable&lt;/code&gt; as closed, prior to throwing the &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">As noted in &lt;a href=&quot;../lang/autocloseable#close()&quot;&gt; &lt;code&gt;AutoCloseable.close()&lt;/code&gt; &lt;/a&gt;, cases where the close may fail require careful attention. It is strongly advised to relinquish the underlying resources and to internally &lt;em&gt;mark&lt;/em&gt; the &lt;code&gt;Closeable&lt;/code&gt; as closed, prior to throwing the &lt;code&gt;IOException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32a33e4d3cced7ddc9346d0339be98de3caa49df" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;../lang/autocloseable#close--&quot;&gt;&lt;code&gt;AutoCloseable.close()&lt;/code&gt;&lt;/a&gt;, cases where the close may fail require careful attention. It is strongly advised to relinquish the underlying resources and to internally &lt;em&gt;mark&lt;/em&gt; the &lt;code&gt;Closeable&lt;/code&gt; as closed, prior to throwing the &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang/autocloseable#close--&quot;&gt; &lt;code&gt;AutoCloseable.close()&lt;/code&gt; &lt;/a&gt; 에서 언급했듯이 닫기가 실패 할 경우주의를 기울여야합니다. &lt;code&gt;IOException&lt;/code&gt; 을 발생 시키기 전에 기본 리소스를 포기하고 내부적 으로 &lt;code&gt;Closeable&lt;/code&gt; 을 닫힌 것으로 &lt;em&gt;표시&lt;/em&gt; 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4566f9c885e3ad9e992d254b2442aca7ca24b212" translate="yes" xml:space="preserve">
          <source>As noted in &lt;code&gt;UIManager&lt;/code&gt; each &lt;code&gt;LookAndFeel&lt;/code&gt; has the opportunity to provide a set of defaults that are layered in with developer and system defaults. Some of Swing's components require the look and feel to provide a specific set of defaults. These are documented in the classes that require the specific default.</source>
          <target state="translated">As noted in &lt;code&gt;UIManager&lt;/code&gt; each &lt;code&gt;LookAndFeel&lt;/code&gt; has the opportunity to provide a set of defaults that are layered in with developer and system defaults. Some of Swing's components require the look and feel to provide a specific set of defaults. These are documented in the classes that require the specific default.</target>
        </trans-unit>
        <trans-unit id="7247086c7fab6f3282000b3391fad996e6a81579" translate="yes" xml:space="preserve">
          <source>As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.invokeAndWait()&lt;/code&gt;.</source>
          <target state="translated">As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.invokeAndWait()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ee2019d0c4c5a944a512798b441f4eaab8677d" translate="yes" xml:space="preserve">
          <source>As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.invokeLater()&lt;/code&gt;.</source>
          <target state="translated">As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.invokeLater()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="612b8dd6969171d982d326b92ecc73e6c5219294" translate="yes" xml:space="preserve">
          <source>As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.isDispatchThread()&lt;/code&gt;.</source>
          <target state="translated">As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.isDispatchThread()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fd2681408ced2b6910a4b6a9a0001c61709b5dd" translate="yes" xml:space="preserve">
          <source>As of 1.3, value comes from UIManager UIManager property FormView.resetButtonText</source>
          <target state="translated">As of 1.3, value comes from UIManager UIManager property FormView.resetButtonText</target>
        </trans-unit>
        <trans-unit id="95dded3f869f45308da343a4de1eb830ea2391ed" translate="yes" xml:space="preserve">
          <source>As of 1.3, value now comes from UIManager property FormView.submitButtonText</source>
          <target state="translated">As of 1.3, value now comes from UIManager property FormView.submitButtonText</target>
        </trans-unit>
        <trans-unit id="0cf651a3c482c18eb34caa55ea8d1cfd6481649d" translate="yes" xml:space="preserve">
          <source>As of 1.3.</source>
          <target state="translated">As of 1.3.</target>
        </trans-unit>
        <trans-unit id="b21093cf4f2a87ae11817ac47d99d87e559e7bf8" translate="yes" xml:space="preserve">
          <source>As of 1.4 a BlockAction</source>
          <target state="translated">As of 1.4 a BlockAction</target>
        </trans-unit>
        <trans-unit id="d4f5b6b2f6806457767b882b8e9b302d549c5ef3" translate="yes" xml:space="preserve">
          <source>As of 1.4 this field is final.</source>
          <target state="translated">As of 1.4 this field is final.</target>
        </trans-unit>
        <trans-unit id="6f6943ece34c654e379de3a2d956d7e1c8bd3ee4" translate="yes" xml:space="preserve">
          <source>As of 1.4, replaced by &lt;code&gt;Component.setFocusTraversalKeys(int, Set)&lt;/code&gt; and &lt;code&gt;Container.setFocusCycleRoot(boolean)&lt;/code&gt;.</source>
          <target state="translated">As of 1.4, replaced by &lt;code&gt;Component.setFocusTraversalKeys(int, Set)&lt;/code&gt; and &lt;code&gt;Container.setFocusCycleRoot(boolean)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0bd2f061f6181f8089c4f9b308a1a4c55a0f76" translate="yes" xml:space="preserve">
          <source>As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy.getDefaultComponent(Container).requestFocus()&lt;/code&gt;</source>
          <target state="translated">As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy.getDefaultComponent(Container).requestFocus()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69030aae104775e6725721ca29b89a51c373039a" translate="yes" xml:space="preserve">
          <source>As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;</source>
          <target state="translated">As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc714aff4cc9fa3e05658c6ce1e5c7f442977cc6" translate="yes" xml:space="preserve">
          <source>As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;.</source>
          <target state="translated">As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f35a386c5a558df6ce157d5a621ed2c29d873c2" translate="yes" xml:space="preserve">
          <source>As of 1.4, replaced by &lt;code&gt;KeyboardFocusManager.getDefaultFocusTraversalPolicy()&lt;/code&gt;</source>
          <target state="translated">As of 1.4, replaced by &lt;code&gt;KeyboardFocusManager.getDefaultFocusTraversalPolicy()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f7b9d687bb739fbb439d6adf05bcea717a8e920" translate="yes" xml:space="preserve">
          <source>As of 1.4, replaced by &lt;code&gt;KeyboardFocusManager.getFocusOwner()&lt;/code&gt;.</source>
          <target state="translated">As of 1.4, replaced by &lt;code&gt;KeyboardFocusManager.getFocusOwner()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4120adbf871102091499306963573310bfdeaf5b" translate="yes" xml:space="preserve">
          <source>As of 1.4, replaced by &lt;code&gt;isFocusable()&lt;/code&gt;.</source>
          <target state="translated">As of 1.4, replaced by &lt;code&gt;isFocusable()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4078cfe3937faabfba671d2a570abce668bef825" translate="yes" xml:space="preserve">
          <source>As of 1.4, this class is now obsolete, doesn't do anything, and is only included for backwards API compatibility.</source>
          <target state="translated">As of 1.4, this class is now obsolete, doesn't do anything, and is only included for backwards API compatibility.</target>
        </trans-unit>
        <trans-unit id="2a3a2b8654a18a3407672451588d551b97d0f64c" translate="yes" xml:space="preserve">
          <source>As of 1.4, this class is now obsolete, doesn't do anything, and is only included for backwards API compatibility. Do not call or override.</source>
          <target state="translated">As of 1.4, this class is now obsolete, doesn't do anything, and is only included for backwards API compatibility. Do not call or override.</target>
        </trans-unit>
        <trans-unit id="c548dda8d18587686eae830cf20254e14261a65f" translate="yes" xml:space="preserve">
          <source>As of 1.5, &lt;a href=&quot;processbuilder#start()&quot;&gt;&lt;code&gt;ProcessBuilder.start()&lt;/code&gt;&lt;/a&gt; is the preferred way to create a &lt;code&gt;Process&lt;/code&gt;.</source>
          <target state="translated">As of 1.5, &lt;a href=&quot;processbuilder#start()&quot;&gt; &lt;code&gt;ProcessBuilder.start()&lt;/code&gt; &lt;/a&gt; is the preferred way to create a &lt;code&gt;Process&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f841b77c906be2ef00ecd3023912695621031d6" translate="yes" xml:space="preserve">
          <source>As of 1.5, &lt;a href=&quot;processbuilder#start--&quot;&gt;&lt;code&gt;ProcessBuilder.start()&lt;/code&gt;&lt;/a&gt; is the preferred way to create a &lt;code&gt;Process&lt;/code&gt;.</source>
          <target state="translated">1.5 &lt;a href=&quot;processbuilder#start--&quot;&gt; &lt;code&gt;ProcessBuilder.start()&lt;/code&gt; &lt;/a&gt; 가 선호하는 &lt;code&gt;Process&lt;/code&gt; 작성 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="00c8381a41f0a615d501dbd28d8ab8c081b28992" translate="yes" xml:space="preserve">
          <source>As of 1.6 &lt;code&gt;RepaintManager&lt;/code&gt; handles repaint requests for Swing's top level components (&lt;code&gt;JApplet&lt;/code&gt;, &lt;code&gt;JWindow&lt;/code&gt;, &lt;code&gt;JFrame&lt;/code&gt; and &lt;code&gt;JDialog&lt;/code&gt;). Any calls to &lt;code&gt;repaint&lt;/code&gt; on one of these will call into the appropriate &lt;code&gt;addDirtyRegion&lt;/code&gt; method.</source>
          <target state="translated">As of 1.6 &lt;code&gt;RepaintManager&lt;/code&gt; handles repaint requests for Swing's top level components ( &lt;code&gt;JApplet&lt;/code&gt; , &lt;code&gt;JWindow&lt;/code&gt; , &lt;code&gt;JFrame&lt;/code&gt; and &lt;code&gt;JDialog&lt;/code&gt; ). Any calls to &lt;code&gt;repaint&lt;/code&gt; on one of these will call into the appropriate &lt;code&gt;addDirtyRegion&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="b70359d515a6b5eb5eda8309bf3124e5aff82b14" translate="yes" xml:space="preserve">
          <source>As of J2SE 1.4, &lt;code&gt;KeyEvent&lt;/code&gt;s are redirected to the focus owner. Please see the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt; for further information.</source>
          <target state="translated">As of J2SE 1.4, &lt;code&gt;KeyEvent&lt;/code&gt; s are redirected to the focus owner. Please see the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt; for further information.</target>
        </trans-unit>
        <trans-unit id="4275c974aeb2f997c66cdc7d8c8ff0ffbec458a7" translate="yes" xml:space="preserve">
          <source>As of J2SE 1.4, replaced by &lt;a href=&quot;component#applyComponentOrientation(java.awt.ComponentOrientation)&quot;&gt;&lt;code&gt;Component.applyComponentOrientation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">As of J2SE 1.4, replaced by &lt;a href=&quot;component#applyComponentOrientation(java.awt.ComponentOrientation)&quot;&gt; &lt;code&gt;Component.applyComponentOrientation&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0eda1248633dc5aece6898581820dfebc3c783ec" translate="yes" xml:space="preserve">
          <source>As of J2SE 1.4, use &lt;a href=&quot;#getOrientation(java.util.Locale)&quot;&gt;&lt;code&gt;getOrientation(java.util.Locale)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">As of J2SE 1.4, use &lt;a href=&quot;#getOrientation(java.util.Locale)&quot;&gt; &lt;code&gt;getOrientation(java.util.Locale)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="205ae4b1491f3a618d959d167e04a4d3b103f459" translate="yes" xml:space="preserve">
          <source>As of JDK 1.7, replaced by &lt;a href=&quot;#getSelectedValuesList()&quot;&gt;&lt;code&gt;getSelectedValuesList()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">As of JDK 1.7, replaced by &lt;a href=&quot;#getSelectedValuesList()&quot;&gt; &lt;code&gt;getSelectedValuesList()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e842eed2965fc75d946a8906f628936c18cde45" translate="yes" xml:space="preserve">
          <source>As of JDK 5, replaced by &lt;code&gt;Component.setBounds(int, int, int, int)&lt;/code&gt;.</source>
          <target state="translated">As of JDK 5, replaced by &lt;code&gt;Component.setBounds(int, int, int, int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd4e566da2cb13190000c450e8dba393e17b625" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1 replaced by &lt;code&gt;dispatchEvent(AWTEvent)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1 replaced by &lt;code&gt;dispatchEvent(AWTEvent)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="933caf0d6e1f93a0a4a41c7920755cf96d7fcca5" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1 replaced by dispatchEvent(AWTEvent).</source>
          <target state="translated">As of JDK version 1.1 replaced by dispatchEvent(AWTEvent).</target>
        </trans-unit>
        <trans-unit id="d023ffdceb027daf6e1645589f6f01345f660293" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1 replaced by processEvent(AWTEvent).</source>
          <target state="translated">As of JDK version 1.1 replaced by processEvent(AWTEvent).</target>
        </trans-unit>
        <trans-unit id="f5506c931d4308a73c43a4b0aed9aac92da7fffa" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, Not for public use in the future.</source>
          <target state="translated">As of JDK version 1.1, Not for public use in the future.</target>
        </trans-unit>
        <trans-unit id="383310e7457b9a270c48f692aa77c3d80368eea8" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, Not for public use in the future. This method is expected to be retained only as a package private method.</source>
          <target state="translated">As of JDK version 1.1, Not for public use in the future. This method is expected to be retained only as a package private method.</target>
        </trans-unit>
        <trans-unit id="79b83cc8bacd199f934d7e3b4d0ae7eedf242a68" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;a href=&quot;#dispatchEvent(java.awt.AWTEvent)&quot;&gt;&lt;code&gt;dispatchEvent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;a href=&quot;#dispatchEvent(java.awt.AWTEvent)&quot;&gt; &lt;code&gt;dispatchEvent&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="af60a9781d9ce5eb2a82b45c437f9542d56e3f37" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;-(Calendar.get(Calendar.ZONE_OFFSET) +
 Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;-(Calendar.get(Calendar.ZONE_OFFSET) + Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="862bd45c2ef1e44ce848071b4788359d8277f4ab" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.DAY_OF_MONTH)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.DAY_OF_MONTH)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f77530d3f27a7d829604a7dfcf2443e8640f1315" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.DAY_OF_WEEK)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.DAY_OF_WEEK)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fa2c35b30828245dba843b62b84c2249bc60ffe" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.HOUR_OF_DAY)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.HOUR_OF_DAY)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76901278b1bea81bc056c34aa73a7dc92c277542" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.MINUTE)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.MINUTE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64c2aca2cded1a2d366ab88c3c53fe3e22dbbdcf" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.MONTH)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.MONTH)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f97b319aad1e2d079bd36791f5a4fc7391730c" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.SECOND)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.SECOND)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba32aceba1ab42323593d862f67eee864216d3c7" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.YEAR) - 1900&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.get(Calendar.YEAR) - 1900&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25a012c9eef0640445a12ec17019b2083cf12462" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.DAY_OF_MONTH, int date)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.DAY_OF_MONTH, int date)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f148f66bfe6bff3da40dd58e6742c4477c689036" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.HOUR_OF_DAY, int hours)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.HOUR_OF_DAY, int hours)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e92f33fb489c41272e8a35d8da75143d876b94c6" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.MINUTE, int minutes)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.MINUTE, int minutes)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5700613dcca99459a38ef951b5fc66b2495f8c" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.MONTH, int month)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.MONTH, int month)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fec704ae4485de8f51ab6dc8a1acdc3dc8843b2c" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.SECOND, int seconds)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.SECOND, int seconds)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0bd61a1eebf74ddf12d1100ec312b654fadfa5" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.YEAR, year + 1900)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(Calendar.YEAR, year + 1900)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2555cbf7a2b1fdc30ed0a5234b9a4f5f8e9a188d" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b90c24efb44a8f8df38f0931579aeb41b7eaa4e" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date, hrs, min)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date, hrs, min)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date, hrs, min)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date, hrs, min)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab19d298f07791ed92fb53f3475d34ce269d6a14" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date, hrs, min, sec)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date, hrs, min, sec)&lt;/code&gt;, using a UTC &lt;code&gt;TimeZone&lt;/code&gt;, followed by &lt;code&gt;Calendar.getTime().getTime()&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date, hrs, min, sec)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date, hrs, min, sec)&lt;/code&gt; , using a UTC &lt;code&gt;TimeZone&lt;/code&gt; , followed by &lt;code&gt;Calendar.getTime().getTime()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b39359e34b54f9d5132599171d24e3534ff1a5eb" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date, hrs, min, sec)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date, hrs, min, sec)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Calendar.set(year + 1900, month, date, hrs, min, sec)&lt;/code&gt; or &lt;code&gt;GregorianCalendar(year + 1900, month, date, hrs, min, sec)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27c94ee3a6e159ccffd23a93408b4d84b718e276" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Component.getCursor()&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Component.getCursor()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b413ea2cf5a9b9857fb3d0731b9cc31851d148aa" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;Component.setCursor(Cursor)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;Component.setCursor(Cursor)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7818380166a2993dea6908fe34d6c7b14a2cfd12" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;DateFormat.format(Date date)&lt;/code&gt;, using a GMT &lt;code&gt;TimeZone&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;DateFormat.format(Date date)&lt;/code&gt; , using a GMT &lt;code&gt;TimeZone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80190dc24da84550676cd77af807c7907322298" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;DateFormat.format(Date date)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;DateFormat.format(Date date)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41d46e3cf866a5960cb1d14dab6cc7525ca389d3" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;DateFormat.parse(String s)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;DateFormat.parse(String s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c74e6e0e10e4d69bff73fb7a727da09c0c8907dd" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;append(String)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;append(String)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="657891bd09f91e429f8533f511660f33600bce9a" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;contains(int, int)&lt;/code&gt;.</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;contains(int, int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b97640725738db5f9bd11b511d28d622c8a2c391" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;</source>
          <target state="translated">As of JDK version 1.1, replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe070ff5657a4e5c75e2d3b0ac91cb8b180eea97" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3b24763a2b2a2110003710ce430ffc3a3b68b3a8" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;doLayout()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;doLayout()&lt;/code&gt; 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="927e992a14753040b5c901dd380578abac0bb8a4" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getBlockIncrement()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getBlockIncrement()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a48e4e4732eb319195c2db693217512d73ab9055" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getBounds()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getBounds()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b21c9550deb44f8b3b09d90a88a81625d5d8976c" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getClipBounds()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getClipBounds()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ba045eb54b12bb9963e2c66fabce79acb03077a6" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getComponentAt(int, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getComponentAt(int, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2bfd4b14d9d5d2fc4dd3cdeb015d263da6e02d0d" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getInsets()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getInsets()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0bca5dd0571901ee1a3343f2cbb0ddbad44789f2" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getItemCount()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getItemCount()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2eaee3fba9e8543d95c339d91d6b711ddf6eb16f" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getLocation()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getLocation()&lt;/code&gt; 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d11a13f7bb070af99b802ae1b324cced5a67e328" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getMenuCount()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getMenuCount()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1f7f931c662c8de397e070c94b5f073d72f6f6bc" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getMinimumSize()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getMinimumSize()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fbc616ed74380ee00fdde02e90274c20861d2f27" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getMinimumSize(int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getMinimumSize(int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fa6c9349fb90ccfeae499d2ff856aa26d1aeaee0" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getMinimumSize(int, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getMinimumSize(int, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="21751df976183702afbfd140f2295ccb88b4fcb8" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getPreferredSize()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getPreferredSize()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ebf651b2bb74515fafd10b012fd2a39fce205b61" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getPreferredSize(int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getPreferredSize(int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="90907f6546dc5338883128c0af942a00500f8bb1" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getPreferredSize(int, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getPreferredSize(int, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7b4df14bb49fd244d657e17d89b6c3f076b892f0" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getSelectedCheckbox()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getSelectedCheckbox()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b2520dc893e84fa8387a81ff0f495e6b15dd4a6c" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getSize()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getSize()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fb43948465bf5eb1f1979cd38822c8ba4ff15d71" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getUnitIncrement()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;getUnitIncrement()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="12cdad42e834c649a36a414828bfe4f95425f57e" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;getVisibleAmount()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;getVisibleAmount()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5d16764d83319a4f9587185e3916038fa9d88e8a" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;insert(String, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;insert(String, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="673c1de9b17342bad3424a81feecbdfdeb7d4ad6" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;isIndexSelected(int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;isIndexSelected(int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3ad11af3f5ff474472b1039de69914f69e17f144" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;isMultipleMode()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;isMultipleMode()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4345c9146d6a9ac127c8c2bf0107d79c56ca2677" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1 &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d8ea04455e4cdd5949ec1c9cfdc8c18026d2d2ec" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;removeAll()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;removeAll()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9034774553d5e34369fcf8de7ef8556ed4d2b736" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;replaceRange(String, int, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;replaceRange(String, int, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bccee485a05fee207bf917d918e5490556581ff4" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setBlockIncrement()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;setBlockIncrement()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="024e3f53a8d2c13d2ff73864add76e7ed32e61a5" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setBounds(int, int, int, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;setBounds(int, int, int, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="403f81d2f0a18b069b5416204d0ef57c18ae1ebe" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setEchoChar(char)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;setEchoChar(char)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="525c54ff72b2ae6925c37d4378eb28a609acc5f3" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setEnabled(boolean)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;setEnabled(boolean)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f4264f084d028c2121e4d38235e0ca59f3145a" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setLocation(int, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;setLocation(int, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="32f65d8a4aceaf20e3d983ec9ecf18122b892612" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setMultipleMode(boolean)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;setMultipleMode(boolean)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7e9a1d5dcf94d1a7bc8b63b3963b22cdf393fa97" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setSelectedCheckbox(Checkbox)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;setSelectedCheckbox(Checkbox)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="db0f410a21c048b898cb95e2ff573087366ecc04" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setSize(Dimension)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;setSize(Dimension)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c1147a00de342aa069ad5ce26b6d743e46861796" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setSize(int, int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1에서 &lt;code&gt;setSize(int, int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2fedf9e12e1bf7ccffae809ee90869da88e3a281" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setUnitIncrement(int)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;setUnitIncrement(int)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ba5f045eb3f75c2edcbe2a4aeff0770a4ae1eb35" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by &lt;code&gt;setVisible(boolean)&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1부터 &lt;code&gt;setVisible(boolean)&lt;/code&gt; 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4ff86ca4140514fddbb088afabc0c9c17c4ef4b7" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by contains(int, int).</source>
          <target state="translated">JDK 버전 1.1부터 contains (int, int)로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="7590d75c26466d5985cd6ff99541f0009b265fbd" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by dispatchEvent(AWTEvent).</source>
          <target state="translated">JDK 버전 1.1부터 dispatchEvent (AWTEvent)로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="7fb3455469a33d6333f8421e7e86f1a8638acd70" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by getComponentAt(int, int).</source>
          <target state="translated">JDK 버전 1.1부터 getComponentAt (int, int)로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="901f30185afca84105291a66fd4e84eb5675e977" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by getComponentCount().</source>
          <target state="translated">JDK 버전 1.1에서 getComponentCount ()로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="6754f1789b8bab7a83a073ddb6c104c444850f81" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by processFocusEvent(FocusEvent).</source>
          <target state="translated">JDK 버전 1.1부터 processFocusEvent (FocusEvent)로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="807f7111e175b46b30e39cceb63deda16fce0f9f" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by processKeyEvent(KeyEvent).</source>
          <target state="translated">JDK 버전 1.1부터 processKeyEvent (KeyEvent)로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="e12fded5aa0b6f176810c710258960a88a34f217" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by processMouseEvent(MouseEvent).</source>
          <target state="translated">JDK 버전 1.1부터 processMouseEvent (MouseEvent)로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="7e6c33261c4a17d6999ccfb56c6afa56f389c738" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by processMouseMotionEvent(MouseEvent).</source>
          <target state="translated">JDK 버전 1.1부터 processMouseMotionEvent (MouseEvent)로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="e036f729a9b3d31c464e6723e4ff14b8d9652079" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, replaced by transferFocus().</source>
          <target state="translated">JDK 버전 1.1부터 transferFocus ()로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a9ad99eef6bb9748574f02170c39a89ef7bd855" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, should register this component as ActionListener on component which fires action events.</source>
          <target state="translated">JDK 버전 1.1부터는 액션 이벤트를 발생시키는 컴포넌트에서이 컴포넌트를 ActionListener로 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="11a5b9ef252127ad7d297a29fdebeb61ee5c7177" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1, the preferred way to tokenize an input stream is to convert it into a character stream, for example:</source>
          <target state="translated">JDK 버전 1.1에서 입력 스트림을 토큰 화하는 선호되는 방법은 입력 스트림을 문자 스트림으로 변환하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc97ce694acf92463aadec8ee94b80b73ba5209d" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.1.1, replaced by &lt;code&gt;getMaxDescent()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.1.1부터 &lt;code&gt;getMaxDescent()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="37e75136f4be5cfe9e299e469461138dd57b14bf" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.2, replaced by the &lt;code&gt;Font&lt;/code&gt; method &lt;code&gt;getLineMetrics&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 1.2 &lt;code&gt;getLineMetrics&lt;/code&gt; &lt;code&gt;Font&lt;/code&gt; 메소드 getLineMetrics 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="dbccb3d5c45a75a068a9ad2412360ac6f9829588" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.5, replaced by &lt;a href=&quot;#setVisible(boolean)&quot;&gt;&lt;code&gt;setVisible(boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 버전 1.5에서 &lt;a href=&quot;#setVisible(boolean)&quot;&gt; &lt;code&gt;setVisible(boolean)&lt;/code&gt; &lt;/a&gt; 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5f13b7e8edde06ba8737796722eb7d20c6cf6f54" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.7</source>
          <target state="translated">JDK 버전 1.7 기준</target>
        </trans-unit>
        <trans-unit id="17744b50c6835b55040bfc8e1e6945364190877f" translate="yes" xml:space="preserve">
          <source>As of JDK version 1.7, the &lt;a href=&quot;#getPredefinedCursor(int)&quot;&gt;&lt;code&gt;getPredefinedCursor(int)&lt;/code&gt;&lt;/a&gt; method should be used instead.</source>
          <target state="translated">JDK 버전 1.7 &lt;a href=&quot;#getPredefinedCursor(int)&quot;&gt; &lt;code&gt;getPredefinedCursor(int)&lt;/code&gt; &lt;/a&gt; 메서드를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="82d2ded73e384823b93b5c0213b63e1c31f05843" translate="yes" xml:space="preserve">
          <source>As of JDK version 9.</source>
          <target state="translated">JDK 버전 9 기준.</target>
        </trans-unit>
        <trans-unit id="4f108a70b45d438d2a8820ad3d0f05adb841b518" translate="yes" xml:space="preserve">
          <source>As of JDK version 9. Obsolete class.</source>
          <target state="translated">JDK 버전 9부터 사용되지 않는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0e79b12ef3cc60e10f55387f928279dc1bd198cf" translate="yes" xml:space="preserve">
          <source>As of JDK version Swing1.1 replaced by &lt;code&gt;JScrollPane.getViewportBorderBounds()&lt;/code&gt;.</source>
          <target state="translated">JDK 버전 Swing1.1에서 &lt;code&gt;JScrollPane.getViewportBorderBounds()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="09df6f63e1723dcdd01e59e900fdea2698d4efb9" translate="yes" xml:space="preserve">
          <source>As of JMX 1.2, replaced by &lt;a href=&quot;#addObservedObject(javax.management.ObjectName)&quot;&gt;&lt;code&gt;addObservedObject(javax.management.ObjectName)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">JMX 1.2부터 &lt;a href=&quot;#addObservedObject(javax.management.ObjectName)&quot;&gt; &lt;code&gt;addObservedObject(javax.management.ObjectName)&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9a6d2717f2ae36e1f0190b1f0ad86c532fe5fc6e" translate="yes" xml:space="preserve">
          <source>As of JMX 1.2, replaced by &lt;a href=&quot;#getDerivedGauge(javax.management.ObjectName)&quot;&gt;&lt;code&gt;getDerivedGauge(ObjectName)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">JMX 1.2부터 &lt;a href=&quot;#getDerivedGauge(javax.management.ObjectName)&quot;&gt; &lt;code&gt;getDerivedGauge(ObjectName)&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="14b4288a4bd81842562762a5b8926301081ae225" translate="yes" xml:space="preserve">
          <source>As of JMX 1.2, replaced by &lt;a href=&quot;#getDerivedGaugeTimeStamp(javax.management.ObjectName)&quot;&gt;&lt;code&gt;getDerivedGaugeTimeStamp(ObjectName)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">JMX 1.2부터 &lt;a href=&quot;#getDerivedGaugeTimeStamp(javax.management.ObjectName)&quot;&gt; &lt;code&gt;getDerivedGaugeTimeStamp(ObjectName)&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="38cdf5a93feda1b157951c8636c2c27196af26ba" translate="yes" xml:space="preserve">
          <source>As of JMX 1.2, replaced by &lt;a href=&quot;#getObservedObjects()&quot;&gt;&lt;code&gt;getObservedObjects()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">JMX 1.2부터 &lt;a href=&quot;#getObservedObjects()&quot;&gt; &lt;code&gt;getObservedObjects()&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f8713edd2fcb8c7b603a4a2d2b8598a9ebbf586" translate="yes" xml:space="preserve">
          <source>As of JMX 1.2, replaced by &lt;a href=&quot;#getThreshold(javax.management.ObjectName)&quot;&gt;&lt;code&gt;getThreshold(ObjectName)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">JMX 1.2부터 &lt;a href=&quot;#getThreshold(javax.management.ObjectName)&quot;&gt; &lt;code&gt;getThreshold(ObjectName)&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="74ede142d761c569f6cdfe31ce4b923db880135e" translate="yes" xml:space="preserve">
          <source>As of JMX 1.2, replaced by &lt;a href=&quot;#setInitThreshold(java.lang.Number)&quot;&gt;&lt;code&gt;setInitThreshold(java.lang.Number)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">JMX 1.2부터 &lt;a href=&quot;#setInitThreshold(java.lang.Number)&quot;&gt; &lt;code&gt;setInitThreshold(java.lang.Number)&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d6a2c0383ddcb7e62fc33647247dd7f714d05a6" translate="yes" xml:space="preserve">
          <source>As of Java 2 SDK v1.2, the default implementation of each of the other &lt;code&gt;check&lt;/code&gt; methods in &lt;code&gt;SecurityManager&lt;/code&gt; is to call the &lt;code&gt;SecurityManager checkPermission&lt;/code&gt; method to determine if the calling thread has permission to perform the requested operation.</source>
          <target state="translated">자바 2 SDK 1.2 이후의 다른 각각의 기본 구현 &lt;code&gt;check&lt;/code&gt; 의 방법 &lt;code&gt;SecurityManager&lt;/code&gt; 부르는 것입니다 &lt;code&gt;SecurityManager checkPermission&lt;/code&gt; 호출 스레드가 요청 된 작업을 수행 할 수있는 권한이 있는지 확인하는 방법을.</target>
        </trans-unit>
        <trans-unit id="aaf8bab14e9352eee7e1a1c6a7e3e34a670bddbc" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform 1.4, this previously undocumented class is now obsolete.</source>
          <target state="translated">Java 2 플랫폼 1.4부터 이전에 문서화되지 않은이 클래스는 이제 폐기되었습니다.</target>
        </trans-unit>
        <trans-unit id="ddddc033b7a47cfce94f414d2d69291f3335ad15" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform 1.4, this previously undocumented class is now obsolete. KeyBindings are now managed by the popup menu.</source>
          <target state="translated">Java 2 플랫폼 1.4부터 이전에 문서화되지 않은이 클래스는 이제 폐기되었습니다. KeyBindings는 이제 팝업 메뉴에서 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="9361fd538103c7bda01829e0d20f4d0a0d0eb8c4" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v 1.4, this class is now obsolete and is only included for backwards API compatibility.</source>
          <target state="translated">Java 2 플랫폼 v 1.4부터이 클래스는 더 이상 사용되지 않으며 하위 API 호환성을 위해서만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="de3225be5bcdd924660d18dde9f99c4c4647b288" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v 1.4, this class is now obsolete and is only included for backwards API compatibility. Do not instantiate or subclass.</source>
          <target state="translated">Java 2 플랫폼 v 1.4부터이 클래스는 더 이상 사용되지 않으며 하위 API 호환성을 위해서만 포함됩니다. 인스턴스화하거나 하위 클래스를 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3f2400239d38085729b3b575d33ec752d5e6e3a0" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v 1.4, this class is now obsolete, doesn't do anything, and is only included for backwards API compatibility.</source>
          <target state="translated">Java 2 플랫폼 v 1.4부터이 클래스는 이제 더 이상 사용되지 않으며 아무 작업도 수행하지 않으며 하위 API 호환성을 위해서만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ffd09d50f061770ff5622decf87b9f56216b34f1" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v 1.4, this class is now obsolete, doesn't do anything, and is only included for backwards API compatibility. Do not call or override.</source>
          <target state="translated">Java 2 플랫폼 v 1.4부터이 클래스는 이제 더 이상 사용되지 않으며 아무 작업도 수행하지 않으며 하위 API 호환성을 위해서만 포함됩니다. 전화하거나 무시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="46bcc2c3854382aa9226a4f7f987b9ad05a7bb5c" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.2, replaced by &lt;code&gt;getPassword&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.2부터 &lt;code&gt;getPassword&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a199d02e08db7672b80c1f6718d12e790f3289a6" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3</source>
          <target state="translated">Java 2 플랫폼 v1.3 기준</target>
        </trans-unit>
        <trans-unit id="be583631d8560d6e5df31a06fb4e9b13793fad67" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3 this class is no longer used. Instead &lt;code&gt;JTable&lt;/code&gt; overrides &lt;code&gt;processKeyBinding&lt;/code&gt; to dispatch the event to the current &lt;code&gt;TableCellEditor&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터이 클래스는 더 이상 사용되지 않습니다. 대신 &lt;code&gt;JTable&lt;/code&gt; 은 &lt;code&gt;processKeyBinding&lt;/code&gt; 을 재정 의하여 현재 &lt;code&gt;TableCellEditor&lt;/code&gt; 에 이벤트를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="82cb662072105780e7d62f8b9453055d5c5f8799" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3 this method is no longer used. Instead you should set the border on the divider.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터이 방법은 더 이상 사용되지 않습니다. 대신 구분선에 테두리를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdeec53fa418324c652e89f54ba7148c204bc608" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3 this method is no longer used. Subclassers previously using this method should instead create an &lt;code&gt;Action&lt;/code&gt; wrapping the &lt;code&gt;ActionListener&lt;/code&gt;, and register that &lt;code&gt;Action&lt;/code&gt; by overriding &lt;code&gt;installKeyboardActions&lt;/code&gt; and placing the &lt;code&gt;Action&lt;/code&gt; in the &lt;code&gt;SplitPane's ActionMap&lt;/code&gt;. Please refer to the key bindings specification for further details.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터이 방법은 더 이상 사용되지 않습니다. 이전에이 메소드를 사용했던 서브 클래 셔는 대신 &lt;code&gt;ActionListener&lt;/code&gt; 를 래핑 하는 &lt;code&gt;Action&lt;/code&gt; 을 만들고 &lt;code&gt;installKeyboardActions&lt;/code&gt; 를 재정의 하고 &lt;code&gt;Action&lt;/code&gt; 을 &lt;code&gt;SplitPane's ActionMap&lt;/code&gt; 에 배치하여 해당 &lt;code&gt;Action&lt;/code&gt; 을 등록해야 합니다 . 자세한 내용은 키 바인딩 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e534ea9fb51de547ac607efe3fc3a6f126317505" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3 this previously undocumented field is no longer used. Key bindings are now defined by the LookAndFeel, please refer to the key bindings specification for further details.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터 ​​이전에 문서화되지 않은이 필드는 더 이상 사용되지 않습니다. 키 바인딩은 이제 LookAndFeel에 의해 정의됩니다. 자세한 내용은 키 바인딩 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="723772ab0c0ff5e6610a59b285c8adb7d82fa261" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3 this undocumented class is no longer used.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터이 문서화되지 않은 클래스는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ce068ca5276f94983f51f8d0d9a69153ee8e731" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3 this undocumented class is no longer used. The recommended approach to creating bindings is to use a combination of an &lt;code&gt;ActionMap&lt;/code&gt;, to contain the action, and an &lt;code&gt;InputMap&lt;/code&gt; to contain the mapping from KeyStroke to action description. The InputMap is usually described in the LookAndFeel tables.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터이 문서화되지 않은 클래스는 더 이상 사용되지 않습니다. 바인딩 작성에 권장되는 접근 방식은 &lt;code&gt;ActionMap&lt;/code&gt; 조합을 사용 하여 작업 을 포함하고 &lt;code&gt;InputMap&lt;/code&gt; 을 사용하여 KeyStroke에서 작업 설명으로의 매핑을 포함하는 것입니다. InputMap은 일반적으로 LookAndFeel 테이블에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="423ae3fefce4ad8339fd1ed6d5d57e63e8e34a36" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3, instead set the border on the divider.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터는 대신 구분선에 테두리를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="50486120b71f93b80ae8fca229cba995ebbf6943" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3, replaced by &lt;code&gt;getScrollMode()&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터 &lt;code&gt;getScrollMode()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ffec56faa6959762f309a23d80f883c476242195" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3, replaced by &lt;code&gt;setScrollMode()&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.3 &lt;code&gt;setScrollMode()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a03b05174075ed272ad545267503fb0e541f998f" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3, this method is not called by the &lt;code&gt;TableColumn&lt;/code&gt; constructor.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터이 메서드는 &lt;code&gt;TableColumn&lt;/code&gt; 생성자에 의해 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="22f8243765077d0567287e5b0d79261e5dfabd7a" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3, this method is not called by the &lt;code&gt;TableColumn&lt;/code&gt; constructor. Previously this method was used by the &lt;code&gt;TableColumn&lt;/code&gt; to create a default header renderer. As of Java 2 platform v1.3, the default header renderer is &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;JTableHeader&lt;/code&gt; now provides its own shared default renderer, just as the &lt;code&gt;JTable&lt;/code&gt; does for its cell renderers.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터이 메서드는 &lt;code&gt;TableColumn&lt;/code&gt; 생성자에 의해 호출되지 않습니다 . 이전에이 메서드는 &lt;code&gt;TableColumn&lt;/code&gt; 에서 기본 헤더 렌더러를 만드는 데 사용되었습니다 . Java 2 플랫폼 v1.3부터 ​​기본 헤더 렌더러는 &lt;code&gt;null&lt;/code&gt; 입니다. &lt;code&gt;JTableHeader&lt;/code&gt; 는 이제 &lt;code&gt;JTable&lt;/code&gt; 이 셀 렌더러에 대해 수행하는 것처럼 자체 공유 기본 렌더러를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="b2c309c6a1cc9124e74b7a70b0db4bd233c4084f" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3, use insertAtBoundary</source>
          <target state="translated">Java 2 플랫폼 v1.3부터 ​​insertAtBoundary 사용</target>
        </trans-unit>
        <trans-unit id="f558fb4e4dcb44f1b81651ab72371a94b8765aa2" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.3.</source>
          <target state="translated">Java 2 플랫폼 v1.3부터.</target>
        </trans-unit>
        <trans-unit id="735a6ad54461a9f02de15d5117ca1eb4075969c7" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.4 this field should no longer be used.</source>
          <target state="translated">Java 2 플랫폼 v1.4부터이 필드는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d815d3e90ca1134ef75abb4709d250a96d17e2bd" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.4 this field should no longer be used. If you wish to provide similar behavior you should directly override &lt;code&gt;isCellEditable&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.4부터이 필드는 더 이상 사용되지 않습니다. 유사한 동작을 제공하려면 &lt;code&gt;isCellEditable&lt;/code&gt; 을 직접 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="49027db9f5967ad1562bb9a36b6814d52ef1117b" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.4 this method is no longer used.</source>
          <target state="translated">Java 2 플랫폼 v1.4부터이 방법은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f93f409ef33fdf20da65d3cb02bc77de2cee7312" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.4 this method is no longer used. Do not call or override. All the functionality of this method is in the MetalPropertyChangeListener.</source>
          <target state="translated">Java 2 플랫폼 v1.4부터이 방법은 더 이상 사용되지 않습니다. 전화하거나 무시하지 마십시오. 이 메서드의 모든 기능은 MetalPropertyChangeListener에 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b8a54b505f53e840a5851311f9de529716d5fd" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.4 this previously undocumented field is no longer used.</source>
          <target state="translated">Java 2 플랫폼 v1.4부터 이전에 문서화되지 않은이 필드는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe120a3e2fd7c53de2769a4a97b57f050d3c5e44" translate="yes" xml:space="preserve">
          <source>As of Java 2 platform v1.4.</source>
          <target state="translated">Java 2 플랫폼 v1.4부터.</target>
        </trans-unit>
        <trans-unit id="870a114d631932f5053bcd585f88c526fe19c48d" translate="yes" xml:space="preserve">
          <source>As of Java SE 10, the first element of a version number is not the major-release number but the feature-release counter, incremented for every time-based release.</source>
          <target state="translated">Java SE 10부터 버전 번호의 첫 번째 요소는 주 릴리스 번호가 아니라 모든 시간 기반 릴리스에 대해 증가하는 기능 릴리스 카운터입니다.</target>
        </trans-unit>
        <trans-unit id="874abecafeb22a591175e878cc75476187c2f796" translate="yes" xml:space="preserve">
          <source>As of Java SE 10, the first element of a version number is not the major-release number but the feature-release counter, incremented for every time-based release. Use the &lt;a href=&quot;#feature()&quot;&gt;&lt;code&gt;feature()&lt;/code&gt;&lt;/a&gt; method in preference to this method. For compatibility, this method returns the value of the &lt;a href=&quot;#FEATURE&quot;&gt;feature&lt;/a&gt; element.</source>
          <target state="translated">Java SE 10부터 버전 번호의 첫 번째 요소는 주 릴리스 번호가 아니라 모든 시간 기반 릴리스에 대해 증가하는 기능 릴리스 카운터입니다. 이 메서드보다 우선적으로 &lt;a href=&quot;#feature()&quot;&gt; &lt;code&gt;feature()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 . 호환성을 위해이 메서드는 &lt;a href=&quot;#FEATURE&quot;&gt;기능&lt;/a&gt; 요소 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="47f76336237e73dac48d90e785a1aab35096db06" translate="yes" xml:space="preserve">
          <source>As of Java SE 10, the second element of a version number is not the minor-release number but the interim-release counter, incremented for every interim release.</source>
          <target state="translated">Java SE 10에서 버전 번호의 두 번째 요소는 부 릴리스 번호가 아니라 임시 릴리스 카운터이며 모든 중간 릴리스에 대해 증가합니다.</target>
        </trans-unit>
        <trans-unit id="176fdd148cb9e2b9277b063452610ddcedd572c9" translate="yes" xml:space="preserve">
          <source>As of Java SE 10, the second element of a version number is not the minor-release number but the interim-release counter, incremented for every interim release. Use the &lt;a href=&quot;#interim()&quot;&gt;&lt;code&gt;interim()&lt;/code&gt;&lt;/a&gt; method in preference to this method. For compatibility, this method returns the value of the &lt;a href=&quot;#INTERIM&quot;&gt;interim&lt;/a&gt; element, or zero if it is absent.</source>
          <target state="translated">Java SE 10에서 버전 번호의 두 번째 요소는 부 릴리스 번호가 아니라 임시 릴리스 카운터이며 모든 중간 릴리스에 대해 증가합니다. 이 메소드보다 우선적으로 &lt;a href=&quot;#interim()&quot;&gt; &lt;code&gt;interim()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . 호환성을 위해이 메서드는 &lt;a href=&quot;#INTERIM&quot;&gt;중간&lt;/a&gt; 요소 의 값을 반환 하거나없는 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b3cacc889816b258b9dcc03d911f2c4c6bbde75" translate="yes" xml:space="preserve">
          <source>As of Java SE 10, the third element of a version number is not the security level but the update-release counter, incremented for every update release.</source>
          <target state="translated">Java SE 10부터 버전 번호의 세 번째 요소는 보안 수준이 아니라 모든 업데이트 릴리스에 대해 증가하는 업데이트 릴리스 카운터입니다.</target>
        </trans-unit>
        <trans-unit id="d1f1ee60f2179dbf4962eac5d9c2e50440806861" translate="yes" xml:space="preserve">
          <source>As of Java SE 10, the third element of a version number is not the security level but the update-release counter, incremented for every update release. Use the &lt;a href=&quot;#update()&quot;&gt;&lt;code&gt;update()&lt;/code&gt;&lt;/a&gt; method in preference to this method. For compatibility, this method returns the value of the &lt;a href=&quot;#UPDATE&quot;&gt;update&lt;/a&gt; element, or zero if it is absent.</source>
          <target state="translated">Java SE 10부터 버전 번호의 세 번째 요소는 보안 수준이 아니라 모든 업데이트 릴리스에 대해 증가하는 업데이트 릴리스 카운터입니다. 이 메서드보다 우선적으로 &lt;a href=&quot;#update()&quot;&gt; &lt;code&gt;update()&lt;/code&gt; &lt;/a&gt; 메서드를 사용합니다 . 호환성을 위해이 메서드는 &lt;a href=&quot;#UPDATE&quot;&gt;업데이트&lt;/a&gt; 요소 의 값을 반환 하거나없는 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac1cb05e209367a48dc3ac3c99c7cd48c59a1cd6" translate="yes" xml:space="preserve">
          <source>As of Swing version 1.0.2, replaced by &lt;code&gt;new JScrollPane(aTable)&lt;/code&gt;.</source>
          <target state="translated">Swing 버전 1.0.2부터 &lt;code&gt;new JScrollPane(aTable)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="82f1434454dc1cb820590dfba19b66529399bc23" translate="yes" xml:space="preserve">
          <source>As of Swing version 1.0.3 replaced by &lt;code&gt;getJMenuBar()&lt;/code&gt;.</source>
          <target state="translated">Swing 버전 1.0.3에서 &lt;code&gt;getJMenuBar()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4be97f451fe3d46789afa2901709b6807a24ca92" translate="yes" xml:space="preserve">
          <source>As of Swing version 1.0.3 replaced by &lt;code&gt;setJMenuBar(JMenuBar m)&lt;/code&gt;.</source>
          <target state="translated">Swing 버전 1.0.3에서 &lt;code&gt;setJMenuBar(JMenuBar m)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c8b21dac3ca5bd856005d0c63195cfaaf65226e2" translate="yes" xml:space="preserve">
          <source>As of Swing version 1.0.3 replaced by &lt;code&gt;setJMenuBar(JMenuBar menu)&lt;/code&gt;.</source>
          <target state="translated">Swing 버전 1.0.3에서 &lt;code&gt;setJMenuBar(JMenuBar menu)&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="87c6f4504cb250fc2c92ec36cede0d01750fa2c2" translate="yes" xml:space="preserve">
          <source>As of Swing version 1.0.3, replaced by &lt;code&gt;doLayout()&lt;/code&gt;.</source>
          <target state="translated">Swing 버전 1.0.3부터 &lt;code&gt;doLayout()&lt;/code&gt; 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4bd402d4b47296fb14a4c642d98724984636191e" translate="yes" xml:space="preserve">
          <source>As of Swing version 1.0.3, replaced by &lt;code&gt;getJMenuBar()&lt;/code&gt;.</source>
          <target state="translated">Swing 버전 1.0.3부터 &lt;code&gt;getJMenuBar()&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e08c1998b3504c141072c04254f8fadb0f566316" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;&lt;code&gt;IOException&lt;/code&gt; that terminated the print job&quot; that is provided at construction time and accessed via the &lt;a href=&quot;#getIOException()&quot;&gt;&lt;code&gt;getIOException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 은 &quot; &lt;code&gt;IOException&lt;/code&gt; 이 비아 건설시에 제공하고 액세스 할 인쇄 작업 종료&quot; &lt;a href=&quot;#getIOException()&quot;&gt; &lt;code&gt;getIOException()&lt;/code&gt; &lt;/a&gt; 현재로 알려져 방법</target>
        </trans-unit>
        <trans-unit id="3537b28ccb55746c134247c452faa27ade7075c7" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;detail exception&quot; that may be provided at construction time and accessed via the public &lt;a href=&quot;#detail&quot;&gt;&lt;code&gt;detail&lt;/code&gt;&lt;/a&gt; field is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 건설시 제공되고 공개 &lt;a href=&quot;#detail&quot;&gt; &lt;code&gt;detail&lt;/code&gt; &lt;/a&gt; 필드 를 통해 액세스 할 수있는 &quot;세부 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="38a41bfa4140a87f71793039399828eac684be96" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;exception causing the abort&quot; that is provided at construction time and accessed via the public &lt;a href=&quot;#detail&quot;&gt;&lt;code&gt;detail&lt;/code&gt;&lt;/a&gt; field is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 건설시 제공되고 공개 &lt;a href=&quot;#detail&quot;&gt; &lt;code&gt;detail&lt;/code&gt; &lt;/a&gt; 필드 를 통해 액세스되는 &quot;중단을 유발하는 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="155920b436a733307bf2f132ae7bdebc97ee45ce" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;exception causing the abort&quot; that is provided at construction time and accessed via the public &lt;a href=&quot;writeabortedexception#detail&quot;&gt;&lt;code&gt;detail&lt;/code&gt;&lt;/a&gt; field is now known as the</source>
          <target state="translated">릴리스 1.4부터이 예외는 범용 예외 체인 메커니즘을 준수하도록 개선되었습니다. 시공 시점에 제공되고 공개 &lt;a href=&quot;writeabortedexception#detail&quot;&gt; &lt;code&gt;detail&lt;/code&gt; &lt;/a&gt; 필드 를 통해 액세스되는 &quot;중단을 일으키는 예외&quot; 는 현재</target>
        </trans-unit>
        <trans-unit id="05c4806cbf6997bf4a2b024b7563e447c395b349" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;exception thrown by the privileged computation&quot; that is provided at construction time and accessed via the &lt;a href=&quot;#getException()&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 생성시 제공되고 &lt;a href=&quot;#getException()&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 액세스되는 &quot;특권 계산에 의해 throw되는 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="8495fe7de406e54be9a9a6704464127b904b17f9" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;exception thrown by the privileged computation&quot; that is provided at construction time and accessed via the &lt;a href=&quot;privilegedactionexception#getException--&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4부터이 예외는 범용 예외 체인 메커니즘을 준수하도록 개선되었습니다. 생성시에 제공되어 &lt;a href=&quot;privilegedactionexception#getException--&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 메소드 를 사용해 액세스되는 「권한 계산에 의한 예외」를 이제는</target>
        </trans-unit>
        <trans-unit id="9eb20d677973b4d444992bcfeb741c46213ad5b8" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;nested exception&quot; that may be provided at construction time and accessed via the public &lt;a href=&quot;#detail&quot;&gt;&lt;code&gt;detail&lt;/code&gt;&lt;/a&gt; field is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 건설시 제공되고 공개 &lt;a href=&quot;#detail&quot;&gt; &lt;code&gt;detail&lt;/code&gt; &lt;/a&gt; 필드 를 통해 액세스 할 수있는 &quot;중첩 된 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="5fb3da4dd2c838061870fbe2ad2012fc8cfe2ab8" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;optional exception that was raised while loading the class&quot; that may be provided at construction time and accessed via the &lt;a href=&quot;#getException()&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 생성시 제공되고 &lt;a href=&quot;#getException()&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 액세스 할 수있는 &quot;클래스를로드하는 동안 발생한 선택적 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="0e80c8416bb52dec10dec7b4bec14bd1c9044e25" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;optional exception that was raised while loading the class&quot; that may be provided at construction time and accessed via the &lt;a href=&quot;classnotfoundexception#getException--&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4부터이 예외는 범용 예외 체인 메커니즘을 준수하도록 개선되었습니다. 생성시에 제공되고 &lt;a href=&quot;classnotfoundexception#getException--&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 액세스 할 수있는 &quot;클래스를로드하는 동안 발생 된 선택적 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="98b22717e520f503eeca57b7a0cdf6582e3d5b21" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;saved throwable object&quot; that may be provided at construction time and accessed via the &lt;a href=&quot;#getException()&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 생성시 제공되고 &lt;a href=&quot;#getException()&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 액세스 할 수있는 &quot;저장된 throwable 객체&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="a03b661cd4f78001e9078093a2c0b7edd9e59ee0" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;saved throwable object&quot; that may be provided at construction time and accessed via the &lt;a href=&quot;exceptionininitializererror#getException--&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4부터이 예외는 범용 예외 체인 메커니즘을 준수하도록 개선되었습니다. 생성시에 제공되어 &lt;a href=&quot;exceptionininitializererror#getException--&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 메소드 를 사용해 액세스 가능한 「저장된 Throwable 객체」를 이제는</target>
        </trans-unit>
        <trans-unit id="5c00973f94dd87b5972e337104c8c200c571c568" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;target exception&quot; that is provided at construction time and accessed via the &lt;a href=&quot;#getTargetException()&quot;&gt;&lt;code&gt;getTargetException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 생성시 제공되고 &lt;a href=&quot;#getTargetException()&quot;&gt; &lt;code&gt;getTargetException()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 액세스되는 &quot;대상 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="a5f4d3eca6416349f41ab5a1a6b1e77c4d437ad4" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;target exception&quot; that is provided at construction time and accessed via the &lt;a href=&quot;invocationtargetexception#getTargetException--&quot;&gt;&lt;code&gt;getTargetException()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4부터이 예외는 범용 예외 체인 메커니즘을 준수하도록 개선되었습니다. 생성시에 제공되고 &lt;a href=&quot;invocationtargetexception#getTargetException--&quot;&gt; &lt;code&gt;getTargetException()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 액세스되는 &quot;대상 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="80eb32895fea620be0b2747213fc17d59e21b26b" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;undeclared checked exception that was thrown by the invocation handler&quot; that may be provided at construction time and accessed via the &lt;a href=&quot;#getUndeclaredThrowable()&quot;&gt;&lt;code&gt;getUndeclaredThrowable()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 생성시 제공되고 &lt;a href=&quot;#getUndeclaredThrowable()&quot;&gt; &lt;code&gt;getUndeclaredThrowable()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 액세스 될 수있는 &quot;호출 처리기에 의해 throw 된 선언되지 않은 확인 된 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="745046a23cf80e295270cdcaa70c0f899787c482" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;undeclared checked exception that was thrown by the invocation handler&quot; that may be provided at construction time and accessed via the &lt;a href=&quot;undeclaredthrowableexception#getUndeclaredThrowable--&quot;&gt;&lt;code&gt;getUndeclaredThrowable()&lt;/code&gt;&lt;/a&gt; method is now known as the</source>
          <target state="translated">릴리스 1.4부터이 예외는 범용 예외 체인 메커니즘을 준수하도록 개선되었습니다. 구성 시간에 제공되어 &lt;a href=&quot;undeclaredthrowableexception#getUndeclaredThrowable--&quot;&gt; &lt;code&gt;getUndeclaredThrowable()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 액세스 할 수있는 &quot;호출 핸들러에서 발생 된 선언되지 않은 검사 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="ec9f2b3eb7bda6088852bcb9696d1f7b65bc5186" translate="yes" xml:space="preserve">
          <source>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism. The &quot;wrapped remote exception&quot; that may be provided at construction time and accessed via the public &lt;a href=&quot;#detail&quot;&gt;&lt;code&gt;detail&lt;/code&gt;&lt;/a&gt; field is now known as the</source>
          <target state="translated">릴리스 1.4에서이 예외는 범용 예외 체인 메커니즘을 준수하도록 개조되었습니다. 건설시 제공되고 공개 &lt;a href=&quot;#detail&quot;&gt; &lt;code&gt;detail&lt;/code&gt; &lt;/a&gt; 필드 를 통해 액세스 할 수있는 &quot;래핑 된 원격 예외&quot; 는 이제</target>
        </trans-unit>
        <trans-unit id="08abfb7f42903e6ce5dc42817d72e81a7e3128b7" translate="yes" xml:space="preserve">
          <source>As of release 7, the platform supports the notion of</source>
          <target state="translated">릴리스 7부터 플랫폼은</target>
        </trans-unit>
        <trans-unit id="d199937d4d0e643598ee602346c6a171ef560fe1" translate="yes" xml:space="preserve">
          <source>As of release JDK 5, this class has been supplemented with an equivalent class designed for use by a single thread, &lt;a href=&quot;stringbuilder&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;StringBuilder&lt;/code&gt; class should generally be used in preference to this one, as it supports all of the same operations but it is faster, as it performs no synchronization.</source>
          <target state="translated">릴리스 JDK 5부터이 클래스에는 단일 스레드 &lt;a href=&quot;stringbuilder&quot;&gt; &lt;code&gt;StringBuilder&lt;/code&gt; &lt;/a&gt; 에서 사용하도록 설계된 동등한 클래스가 추가되었습니다 . &lt;code&gt;StringBuilder&lt;/code&gt; 는 동일한 동작을 모두 지원하지만 아무런 동기화를 수행하지 않기 때문에 그것이 빠르기 때문 클래스는 일반적으로,이 우선적으로 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="2e6bcd78086d103a664fb31d032ae03a98131ac5" translate="yes" xml:space="preserve">
          <source>As of the Java 2 platform v1.2, this class was retrofitted to implement the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface, making it a member of the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt; Java Collections Framework&lt;/a&gt;. Unlike the new collection implementations, &lt;code&gt;Vector&lt;/code&gt; is synchronized. If a thread-safe implementation is not needed, it is recommended to use &lt;a href=&quot;arraylist&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;Vector&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.2부터이 클래스는 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하도록 개량되어 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; 의 멤버가되었습니다 . 새로운 컬렉션 구현과 달리 &lt;code&gt;Vector&lt;/code&gt; 는 동기화됩니다. 스레드 안전 구현이 필요하지 않은 경우 &lt;code&gt;Vector&lt;/code&gt; 대신 &lt;a href=&quot;arraylist&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f9bbe3fdbcf9e9f98b620f55c3ee04603691aa08" translate="yes" xml:space="preserve">
          <source>As of the Java 2 platform v1.2, this class was retrofitted to implement the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface, making it a member of the &lt;a href=&quot;package-summary#CollectionsFramework&quot;&gt; Java Collections Framework&lt;/a&gt;. Unlike the new collection implementations, &lt;code&gt;Vector&lt;/code&gt; is synchronized. If a thread-safe implementation is not needed, it is recommended to use &lt;a href=&quot;arraylist&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;Vector&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.2부터이 클래스는 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하도록 개조되어 &lt;a href=&quot;package-summary#CollectionsFramework&quot;&gt;Java Collections Framework&lt;/a&gt; 의 구성원이되었습니다 . 새로운 컬렉션 구현과 달리 &lt;code&gt;Vector&lt;/code&gt; 는 동기화됩니다. 스레드로부터 안전한 구현이 필요하지 않은 경우 &lt;code&gt;Vector&lt;/code&gt; 대신 &lt;a href=&quot;arraylist&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fca7f268bf7fdde33cb8e4ec038344234d57ae07" translate="yes" xml:space="preserve">
          <source>As of the Java 2 platform v1.2, this class was retrofitted to implement the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; interface, making it a member of the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt; Java Collections Framework&lt;/a&gt;. Unlike the new collection implementations, &lt;code&gt;Hashtable&lt;/code&gt; is synchronized. If a thread-safe implementation is not needed, it is recommended to use &lt;a href=&quot;hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt;. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use &lt;a href=&quot;concurrent/concurrenthashmap&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.2부터이 클래스는 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하도록 개량되어 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; 의 멤버가되었습니다 . 새로운 컬렉션 구현과 달리 &lt;code&gt;Hashtable&lt;/code&gt; 은 동기화됩니다. 스레드 안전 구현이 필요하지 않은 경우 &lt;code&gt;Hashtable&lt;/code&gt; 대신 &lt;a href=&quot;hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 . 스레드 안전성이 높은 동시 구현이 필요한 경우 &lt;code&gt;Hashtable&lt;/code&gt; 대신 &lt;a href=&quot;concurrent/concurrenthashmap&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fa0e1843fcf3cfc5e3b98851e0ca2ee8a7a7beac" translate="yes" xml:space="preserve">
          <source>As of the Java 2 platform v1.2, this class was retrofitted to implement the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; interface, making it a member of the &lt;a href=&quot;package-summary#CollectionsFramework&quot;&gt; Java Collections Framework&lt;/a&gt;. Unlike the new collection implementations, &lt;code&gt;Hashtable&lt;/code&gt; is synchronized. If a thread-safe implementation is not needed, it is recommended to use &lt;a href=&quot;hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt;. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use &lt;a href=&quot;concurrent/concurrenthashmap&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼 v1.2부터이 클래스는 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하도록 개조되어 &lt;a href=&quot;package-summary#CollectionsFramework&quot;&gt;Java Collections Framework&lt;/a&gt; 의 구성원이되었습니다 . 새로운 컬렉션 구현과 달리 &lt;code&gt;Hashtable&lt;/code&gt; 은 동기화됩니다. 스레드로부터 안전한 구현이 필요하지 않은 경우 &lt;code&gt;Hashtable&lt;/code&gt; 대신 &lt;a href=&quot;hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 . 스레드로부터 안전한 고도로 동시 구현이 필요한 경우 &lt;code&gt;Hashtable&lt;/code&gt; 대신 &lt;a href=&quot;concurrent/concurrenthashmap&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8c1dadb9a609742bac134bce7543bdcb4233e40d" translate="yes" xml:space="preserve">
          <source>As of v1.4, the &lt;code&gt;java.beans&lt;/code&gt; package provides support for &lt;em&gt;long-term persistence&lt;/em&gt; -- reading and writing a bean as a textual representation of its property values. The property values are treated as beans, and are recursively read or written to capture their publicly available state. This approach is suitable for long-term storage because it relies only on public API, rather than the likely-to-change private implementation.</source>
          <target state="translated">v1.4부터 &lt;code&gt;java.beans&lt;/code&gt; 패키지는 &lt;em&gt;장기 지속성을&lt;/em&gt; 지원합니다 . Bean을 특성 값의 텍스트 표현으로 읽고 쓰기합니다. 특성 값은 Bean으로 처리되며 공개적으로 사용 가능한 상태를 캡처하기 위해 재귀 적으로 읽거나 씁니다. 이 방법은 변경 가능성이 높은 개인 구현이 아닌 공개 API에만 의존하기 때문에 장기 저장소에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="2fe88917a8774511a1f31627d32350cf0b1a85da" translate="yes" xml:space="preserve">
          <source>As part of its initialization, the &lt;code&gt;DriverManager&lt;/code&gt; class will attempt to load available JDBC drivers by using:</source>
          <target state="translated">초기화의 일부로 &lt;code&gt;DriverManager&lt;/code&gt; 클래스는 다음을 사용하여 사용 가능한 JDBC 드라이버를로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="eeb69f99ce768e2368d58f91be9d9b4d2ac4e667" translate="yes" xml:space="preserve">
          <source>As part of its internal notification process, a &lt;code&gt;RowSet&lt;/code&gt; object creates an instance of &lt;code&gt;RowSetEvent&lt;/code&gt; and passes it to the listener. The listener can use this &lt;code&gt;RowSetEvent&lt;/code&gt; object to find out which rowset had the event.</source>
          <target state="translated">내부 알림 프로세스의 일부로 &lt;code&gt;RowSet&lt;/code&gt; 객체는 &lt;code&gt;RowSetEvent&lt;/code&gt; 의 인스턴스를 만들고 이를 리스너에 전달합니다. 리스너는이 &lt;code&gt;RowSetEvent&lt;/code&gt; 객체를 사용 하여 이벤트가있는 행 집합을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cb3da4b4ff931e292c1804ac98488778ba3257c" translate="yes" xml:space="preserve">
          <source>As per the contract of the base &lt;code&gt;Image#getGraphics()&lt;/code&gt; method, this implementation will always throw &lt;code&gt;UnsupportedOperationException&lt;/code&gt; since only off-screen images can return a &lt;code&gt;Graphics&lt;/code&gt; object.</source>
          <target state="translated">기본 &lt;code&gt;Image#getGraphics()&lt;/code&gt; 메서드 의 계약에 따라 오프 스크린 이미지 만 &lt;code&gt;Graphics&lt;/code&gt; 객체를 반환 할 수 있으므로이 구현은 항상 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="3934207a533e24592d8c4d7a9d31ad79632324aa" translate="yes" xml:space="preserve">
          <source>As previously stated, this invokes &lt;code&gt;loadSystemColors&lt;/code&gt; with the supplied &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;name-color&lt;/code&gt; pair array. The last argument to &lt;code&gt;loadSystemColors&lt;/code&gt; indicates whether the value of the field in &lt;code&gt;SystemColor&lt;/code&gt; should be used. This method passes the value of &lt;code&gt;
 isNativeLookAndFeel()&lt;/code&gt; as the last argument to &lt;code&gt;loadSystemColors&lt;/code&gt;.</source>
          <target state="translated">앞서 언급했듯이 이것은 제공된 &lt;code&gt;table&lt;/code&gt; 과 &lt;code&gt;name-color&lt;/code&gt; 쌍 배열을 사용하여 &lt;code&gt;loadSystemColors&lt;/code&gt; 를 호출합니다 . &lt;code&gt;loadSystemColors&lt;/code&gt; 의 마지막 인수 는 &lt;code&gt;SystemColor&lt;/code&gt; 의 필드 값을 사용해야하는지 여부 를 나타 냅니다 . 이 메서드는 &lt;code&gt; isNativeLookAndFeel()&lt;/code&gt; 값 을 &lt;code&gt;loadSystemColors&lt;/code&gt; 에 대한 마지막 인수로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="f37d49d91e67aab15a9f7a227fc3a78be4eb9abd" translate="yes" xml:space="preserve">
          <source>As service binding involves resolution then it may fail with &lt;code&gt;
 FindException&lt;/code&gt; or &lt;code&gt;ResolutionException&lt;/code&gt; for exactly the same reasons specified in &lt;code&gt;resolve&lt;/code&gt;.</source>
          <target state="translated">서비스 바인딩이 해결을 포함하므로 &lt;code&gt;resolve&lt;/code&gt; 에 지정된 것과 정확히 동일한 이유로 &lt;code&gt; FindException&lt;/code&gt; 또는 &lt;code&gt;ResolutionException&lt;/code&gt; 으로 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aafc293e257030347fd4b78d6be1bc7cd7cacca" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;#figure1&quot;&gt;figure 1&lt;/a&gt;, if &lt;b&gt;D&lt;/b&gt; was just added, the index of the next edit will be 4. Invoking &lt;code&gt;undo&lt;/code&gt; results in invoking &lt;code&gt;undo&lt;/code&gt; on &lt;b&gt;D&lt;/b&gt; and setting the index of the next edit to 3 (edit</source>
          <target state="translated">도시 된 바와 같이 &lt;a href=&quot;#figure1&quot;&gt;도 1의&lt;/a&gt; 경우, &lt;b&gt;D는&lt;/b&gt; 단지 첨가하고, 다음의 편집의 인덱스 4. 호출하기 것이다 &lt;code&gt;undo&lt;/code&gt; 호출 결과를 &lt;code&gt;undo&lt;/code&gt; 에 &lt;b&gt;D&lt;/b&gt; (편집 및도 3을 다음의 편집의 인덱스를 설정</target>
        </trans-unit>
        <trans-unit id="74de9815fea9b7360931636613219dd6f8de6ac1" translate="yes" xml:space="preserve">
          <source>As shown, although the date objects are in different calendar systems, represented by different &lt;code&gt;Chronology&lt;/code&gt; instances, both can be queried using the same constant on &lt;code&gt;ChronoField&lt;/code&gt;. For a full discussion of the implications of this, see &lt;a href=&quot;chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt;. In general, the advice is to use the known ISO-based &lt;code&gt;LocalDate&lt;/code&gt;, rather than &lt;code&gt;ChronoLocalDate&lt;/code&gt;.</source>
          <target state="translated">도시 된 바와 같이, 날짜 객체들이 상이한 &lt;code&gt;Chronology&lt;/code&gt; 인스턴스들로 표현되는 상이한 캘린더 시스템에 있지만 , 둘 다 &lt;code&gt;ChronoField&lt;/code&gt; 에서 동일한 상수를 사용하여 질의 될 수있다 . 이것의 의미에 대한 자세한 내용은 &lt;a href=&quot;chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 일반적으로 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 대신 알려진 ISO 기반 &lt;code&gt;LocalDate&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="18d7e1176138c02170e7e0f9731e4b0101ef7e9d" translate="yes" xml:space="preserve">
          <source>As shown, there can be two different sets of request controls associated with a context: connection request controls and context request controls. This is required for those applications needing to send critical controls that might not be applicable to both the context operation and any implicit LDAP &quot;bind&quot; operation. A typical user program would do the following:</source>
          <target state="translated">도시 된 바와 같이, 컨텍스트와 관련된 2 개의 상이한 요청 제어 세트가있을 수있다 : 연결 요청 제어 및 컨텍스트 요청 제어. 컨텍스트 조작 및 내재 된 LDAP &quot;바인드&quot;조작 모두에 적용 할 수없는 중요 제어를 보내야하는 응용 프로그램에 필요합니다. 일반적인 사용자 프로그램은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2144436e183058db41c722ad6e7b3a6a91de6eae" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt; key events are dispatched to the focus owner by default.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html&quot;&gt;포커스 사양에&lt;/a&gt; 지정된대로 키 이벤트는 기본적으로 포커스 소유자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1b352dd5bd27a81759ee7172972f80beb9d86cf6" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html#s.res.fail&quot;&gt; XML Catalogs, OASIS Standard V1.1&lt;/a&gt;, if a catalog entry is invalid, it is ignored. In case all entries are invalid, the resulting Catalog object will contain no Catalog elements. Any matching operation using the Catalog will return null.</source>
          <target state="translated">&lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html#s.res.fail&quot;&gt;XML 카탈로그, OASIS Standard V1.1에&lt;/a&gt; 지정된대로 카탈로그 항목이 유효하지 않으면 무시됩니다. 모든 항목이 유효하지 않은 경우 결과 카탈로그 개체에는 카탈로그 요소가 포함되지 않습니다. 카탈로그를 사용하는 모든 일치 작업은 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="038e4c2fbfc0101cd213203d9902254e7adab9f7" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html#s.res.fail&quot;&gt; XML Catalogs, OASIS Standard V1.1&lt;/a&gt;, if a catalog entry is invalid, it is ignored. In case all entries are invalid, the resulting CatalogResolver object will contain no valid catalog. Any resolution operation using the resolver therefore will return as no mapping is found. See &lt;a href=&quot;catalogresolver&quot;&gt;&lt;code&gt;CatalogResolver&lt;/code&gt;&lt;/a&gt; for the behavior when no mapping is found.</source>
          <target state="translated">&lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html#s.res.fail&quot;&gt;XML 카탈로그, OASIS Standard V1.1에&lt;/a&gt; 지정된대로 카탈로그 항목이 유효하지 않으면 무시됩니다. 모든 항목이 유효하지 않은 경우 결과 CatalogResolver 개체에 유효한 카탈로그가 포함되지 않습니다. 따라서 리졸버를 사용하는 모든 해결 작업은 매핑을 찾을 수 없으므로 반환됩니다. 매핑이 없을 때의 동작 은 &lt;a href=&quot;catalogresolver&quot;&gt; &lt;code&gt;CatalogResolver&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85eeef57e9253e237d872efe82c0b85684896fb6" translate="yes" xml:space="preserve">
          <source>As specified in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt;] , when a document is first made available via the LSParser:</source>
          <target state="translated">[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt; ]에 지정된대로 LSParser를 통해 문서를 처음 사용할 수있는 경우 :</target>
        </trans-unit>
        <trans-unit id="09a387e17a0102b28fda4804fcb6ca57e3626e02" translate="yes" xml:space="preserve">
          <source>As specified in section 5.4.3 of the</source>
          <target state="translated">섹션 5.4.3에 명시된대로</target>
        </trans-unit>
        <trans-unit id="8a81f332a784752a04d5a460f5f8755e0973c1c2" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;WatchService&lt;/code&gt; is intended to map directly on to the native file event notification facility (where available) then many of details on how registered objects are watched is highly implementation specific. When watching a directory for changes for example, and the directory is moved or renamed in the file system, there is no guarantee that the watch key will be cancelled and so the object returned by this method may no longer be a valid path to the directory.</source>
          <target state="translated">는 AS &lt;code&gt;WatchService&lt;/code&gt; 이 지켜된다 (사용 가능한) 방법 등록 된 객체에 대한 세부 사항을 다음 많은 기본 파일 이벤트 통지 기능을 직접지도하기위한 것입니다 매우 구현 고유의 것입니다. 예를 들어 디렉토리에서 변경 사항을 감시하고 디렉토리가 파일 시스템에서 이동되거나 이름이 바뀔 때 감시 키가 취소된다는 보장이 없으므로이 메소드가 리턴 한 오브젝트가 더 이상 디렉토리의 올바른 경로가 아닐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12aa136826b865e2ff157db15e4d08b9665bb439" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;nodeName&lt;/code&gt; attribute is used to derive the name which the node must be stored under, multiple nodes of certain types (those that have a &quot;special&quot; string value) cannot be stored as the names would clash. This is seen as preferable to allowing nodes to be aliased.</source>
          <target state="translated">는 AS &lt;code&gt;nodeName&lt;/code&gt; 속성이 노드에 저장해야 이름을 도출하는 데 사용되는 이름으로 저장 될 수없는 특정 유형의 여러 노드 ( &quot;특별한&quot;문자열 값을 가지고 그 사람들은) 충돌합니다. 이것은 노드의 별칭을 허용하는 것보다 선호되는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="aa6c49cf03238266cf1714236a6543613f54d3f0" translate="yes" xml:space="preserve">
          <source>As the content is parsed by the underlying parser, methods of the given &lt;a href=&quot;../../../org/xml/sax/handlerbase&quot;&gt;&lt;code&gt;HandlerBase&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;../../../org/xml/sax/helpers/defaulthandler&quot;&gt;&lt;code&gt;DefaultHandler&lt;/code&gt;&lt;/a&gt; are called.</source>
          <target state="translated">콘텐츠가 기본 파서에 의해 구문 분석되므로 지정된 &lt;a href=&quot;../../../org/xml/sax/handlerbase&quot;&gt; &lt;code&gt;HandlerBase&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../org/xml/sax/helpers/defaulthandler&quot;&gt; &lt;code&gt;DefaultHandler&lt;/code&gt; 의&lt;/a&gt; 메서드 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2cdb2d73ddfa0ff1f2ef686f5ebf6bdbffa6affd" translate="yes" xml:space="preserve">
          <source>As the image is scaled up, it will look correspondingly blocky. As the image is scaled down, the colors for source pixels will be either used unmodified, or skipped entirely in the output representation.</source>
          <target state="translated">이미지가 확대되면 그에 따라 고르지 않게 보일 것입니다. 이미지가 축소되면 소스 픽셀의 색상이 수정되지 않은 상태로 사용되거나 출력 표현에서 완전히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a702f8af3fa364bc3c009cfa9afe487d6f1c3e40" translate="yes" xml:space="preserve">
          <source>As the image is scaled up, there are no blocky edges and the interpolation should appear smoother and with better depictions of any edges in the original image than with &lt;code&gt;BILINEAR&lt;/code&gt;. As the image is scaled down, even more of the original color samples from the original image will have their color information carried through and represented.</source>
          <target state="translated">이미지가 확대됨에 따라 고르지 않은 가장자리가 없으며 보간이 &lt;code&gt;BILINEAR&lt;/code&gt; 보다 원본 이미지의 가장자리를 더 잘 묘사하면서 더 매끄럽게 나타나야 합니다. 이미지가 축소됨에 따라 원본 이미지의 원래 색상 샘플 중 더 많은 색상 정보가 전달되고 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="91d1aab307d7ddc986f82f00f0b850043842f4ea" translate="yes" xml:space="preserve">
          <source>As the image is scaled up, there are no blocky edges between the colors in the image as there are with &lt;a href=&quot;#VALUE_INTERPOLATION_NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;, but the blending may show some subtle discontinuities along the horizontal and vertical edges that line up with the samples caused by a sudden change in the slope of the interpolation from one side of a sample to the other. As the image is scaled down, more image pixels have their color samples represented in the resulting output since each output pixel receives color information from up to 4 image pixels.</source>
          <target state="translated">이미지가 확대됨에 따라 &lt;a href=&quot;#VALUE_INTERPOLATION_NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;NEAREST_NEIGHBOR&lt;/code&gt; &lt;/a&gt; 와 같이 이미지의 색상 사이에 고르지 않은 가장자리가 없지만 블렌딩은 갑작스러운 변화로 인해 샘플과 정렬되는 수평 및 수직 가장자리를 따라 약간의 불연속성을 보일 수 있습니다. 샘플의 한면에서 다른면으로의 보간 기울기. 이미지가 축소됨에 따라 각 출력 픽셀이 최대 4 개의 이미지 픽셀에서 색상 정보를 수신하므로 더 많은 이미지 픽셀이 결과 출력에 색상 샘플을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="61317a2ac613441bcf5d5afe40ea81f32fa6489b" translate="yes" xml:space="preserve">
          <source>As the inheritance hierarchy implies, a &lt;code&gt;PopupMenu&lt;/code&gt; can be used anywhere a &lt;code&gt;Menu&lt;/code&gt; can be used. However, if you use a &lt;code&gt;PopupMenu&lt;/code&gt; like a &lt;code&gt;Menu&lt;/code&gt; (e.g., you add it to a &lt;code&gt;MenuBar&lt;/code&gt;), then you &lt;b&gt;cannot&lt;/b&gt; call &lt;code&gt;show&lt;/code&gt; on that &lt;code&gt;PopupMenu&lt;/code&gt;.</source>
          <target state="translated">상속 계층 구조에서 알 수 있듯이 &lt;code&gt;PopupMenu&lt;/code&gt; 는 &lt;code&gt;Menu&lt;/code&gt; 사용할 수있는 모든 곳에서 사용할 수 있습니다. 그러나 &lt;code&gt;Menu&lt;/code&gt; 와 같은 &lt;code&gt;PopupMenu&lt;/code&gt; 를 사용하는 경우 (예 : &lt;code&gt;MenuBar&lt;/code&gt; 에 추가 ) 해당 &lt;code&gt;PopupMenu&lt;/code&gt; 에서 &lt;code&gt;show&lt;/code&gt; 를 호출 할 &lt;b&gt;수 없습니다&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a4403430e032de99eacb96bb465f8eff3f54dd0" translate="yes" xml:space="preserve">
          <source>As the largest &lt;code&gt;double&lt;/code&gt; value less than &lt;code&gt;1.0&lt;/code&gt; is &lt;code&gt;Math.nextDown(1.0)&lt;/code&gt;, a value &lt;code&gt;x&lt;/code&gt; in the closed range &lt;code&gt;[x1,x2]&lt;/code&gt; where &lt;code&gt;x1&amp;lt;=x2&lt;/code&gt; may be defined by the statements</source>
          <target state="translated">&lt;code&gt;1.0&lt;/code&gt; 보다 작은 가장 큰 &lt;code&gt;double&lt;/code&gt; 값 은 &lt;code&gt;Math.nextDown(1.0)&lt;/code&gt; 이므로 닫힌 범위 &lt;code&gt;[x1,x2]&lt;/code&gt; 의 값 &lt;code&gt;x&lt;/code&gt; 는 명령문으로 정의 할 수 있습니다 . &lt;code&gt;x1&amp;lt;=x2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10db4757a6b843534723bc0bbcb82eb46a835d72" translate="yes" xml:space="preserve">
          <source>As the monitor attributes may change at runtime, a check is performed before each observation. If a monitor attribute has become invalid, a monitor setting exception is thrown.</source>
          <target state="translated">모니터 속성은 런타임에 변경 될 수 있으므로, 각 관찰 전에 점검이 수행됩니다. 모니터 속성이 유효하지 않은 경우 모니터 설정 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ac8e4fde6dec6335496b355fcdd102b05472c6c" translate="yes" xml:space="preserve">
          <source>As the new data is inserted into the document, at least one mutation event is fired per new immediate child or sibling of the context node.</source>
          <target state="translated">새 데이터가 문서에 삽입되면 컨텍스트 노드의 새 직계 자식 또는 형제마다 하나 이상의 변형 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0b8b1e8829293993b0747795d1bed596ed71cd8" translate="yes" xml:space="preserve">
          <source>As the return value is an &lt;code&gt;int&lt;/code&gt;, an incorrect value will be returned for &lt;code&gt;Duration&lt;/code&gt;s with years that go beyond the range of an &lt;code&gt;int&lt;/code&gt;. Use &lt;a href=&quot;#getField(javax.xml.datatype.DatatypeConstants.Field)&quot;&gt;&lt;code&gt;getField(DatatypeConstants.YEARS)&lt;/code&gt;&lt;/a&gt; to avoid possible loss of precision.</source>
          <target state="translated">반환 값은이므로 &lt;code&gt;int&lt;/code&gt; , 잘못된 값이 반환됩니다 &lt;code&gt;Duration&lt;/code&gt; 의 범위를 넘어 년의 &lt;code&gt;int&lt;/code&gt; . 정밀도 손실을 방지 하려면 &lt;a href=&quot;#getField(javax.xml.datatype.DatatypeConstants.Field)&quot;&gt; &lt;code&gt;getField(DatatypeConstants.YEARS)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c93f4f4fbd468b9aefc52826d44fc46124020f4" translate="yes" xml:space="preserve">
          <source>As the semantics of how a tree or subtree may be merged with another tree are completely format-specific, plug-in authors may implement this method in whatever manner is most appropriate for the format, including simply replacing all existing state with the contents of the given tree.</source>
          <target state="translated">트리 또는 하위 트리를 다른 트리와 병합하는 방법에 대한 의미는 형식에 따라 다르므로 플러그인 작성자는 기존의 모든 상태를 기존의 내용으로 간단히 바꾸는 등 형식에 가장 적합한 방식으로이 방법을 구현할 수 있습니다. 주어진 나무.</target>
        </trans-unit>
        <trans-unit id="0aae174adf4969941ef7ca9af30375166a193cba" translate="yes" xml:space="preserve">
          <source>As the underlying network implementation may ignore the traffic class or type-of-service set using &lt;a href=&quot;#setTrafficClass(int)&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; this method may return a different value than was previously set using the &lt;a href=&quot;#setTrafficClass(int)&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; method on this DatagramSocket.</source>
          <target state="translated">기본 네트워크 구현은 &lt;a href=&quot;#setTrafficClass(int)&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 사용하여 트래픽 클래스 또는 서비스 유형 집합을 무시할 수 &lt;a href=&quot;#setTrafficClass(int)&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 메서드는이 DatagramSocket 에서 setTrafficClass (int) 메서드를 사용하여 이전에 설정된 것과 다른 값을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13250d2ca51c1336598dc788a65b3c27315c3b2f" translate="yes" xml:space="preserve">
          <source>As the underlying network implementation may ignore the traffic class or type-of-service set using &lt;a href=&quot;#setTrafficClass(int)&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; this method may return a different value than was previously set using the &lt;a href=&quot;#setTrafficClass(int)&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; method on this Socket.</source>
          <target state="translated">기본 네트워크 구현은 &lt;a href=&quot;#setTrafficClass(int)&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 사용하여 트래픽 클래스 또는 서비스 유형 집합을 무시할 수 &lt;a href=&quot;#setTrafficClass(int)&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 메서드는이 소켓 에서 setTrafficClass (int) 메서드를 사용하여 이전에 설정 한 것과 다른 값을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e3b663db14ddbd84bf650414e653cfed7b4d3bf" translate="yes" xml:space="preserve">
          <source>As the underlying network implementation may ignore the traffic class or type-of-service set using &lt;a href=&quot;datagramsocket#setTrafficClass-int-&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; this method may return a different value than was previously set using the &lt;a href=&quot;datagramsocket#setTrafficClass-int-&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; method on this DatagramSocket.</source>
          <target state="translated">기본 네트워크 구현이 &lt;a href=&quot;datagramsocket#setTrafficClass-int-&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 사용하여 트래픽 클래스 또는 서비스 유형 세트를 무시할 수 &lt;a href=&quot;datagramsocket#setTrafficClass-int-&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 메소드는이 DatagramSocket 에서 setTrafficClass (int) 메소드를 사용하여 이전에 설정 한 것과 다른 값을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd3dcaa75bfca85fdab534c16fe7b401186b0b4f" translate="yes" xml:space="preserve">
          <source>As the underlying network implementation may ignore the traffic class or type-of-service set using &lt;a href=&quot;socket#setTrafficClass-int-&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; this method may return a different value than was previously set using the &lt;a href=&quot;socket#setTrafficClass-int-&quot;&gt;&lt;code&gt;setTrafficClass(int)&lt;/code&gt;&lt;/a&gt; method on this Socket.</source>
          <target state="translated">기본 네트워크 구현이 &lt;a href=&quot;socket#setTrafficClass-int-&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 사용하여 트래픽 클래스 또는 서비스 유형 세트를 무시할 수 &lt;a href=&quot;socket#setTrafficClass-int-&quot;&gt; &lt;code&gt;setTrafficClass(int)&lt;/code&gt; &lt;/a&gt; 메소드는이 소켓 에서 setTrafficClass (int) 메소드를 사용하여 이전에 설정 한 것과 다른 값을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30c1a54150bebd25d644937ac69968a8cf3ce67a" translate="yes" xml:space="preserve">
          <source>As the user gestures navigate over &lt;code&gt;Component&lt;/code&gt;(s) in the GUI with associated &lt;code&gt;DropTarget&lt;/code&gt;(s), the &lt;code&gt;DragSource&lt;/code&gt; receives notifications in order to provide &quot;Drag Over&quot; feedback effects, and the &lt;code&gt;DropTarget&lt;/code&gt;(s) receive notifications in order to provide &quot;Drag Under&quot; feedback effects based upon the operation(s) supported and the data type(s) involved.</source>
          <target state="translated">사용자 제스처 가 연결된 &lt;code&gt;DropTarget&lt;/code&gt; (s) 과 함께 GUI의 &lt;code&gt;Component&lt;/code&gt; 탐색 할 때 &lt;code&gt;DragSource&lt;/code&gt; 는 &quot;Drag Over&quot;피드백 효과 를 제공하기 위해 알림을 수신 하고 &lt;code&gt;DropTarget&lt;/code&gt; (s)은 &quot;Drag Under&quot;를 제공하기 위해 알림을받습니다. &quot;지원되는 작업 및 관련 데이터 유형에 따른 피드백 효과.</target>
        </trans-unit>
        <trans-unit id="a018fd4869a6ee0a6d1fa92b59dcb90f4eaffe64" translate="yes" xml:space="preserve">
          <source>As the user scrolls to a new print service selection, the values copied are based on the settings for the previous service, together with any user changes. The values are not based on the original settings supplied by the client.</source>
          <target state="translated">사용자가 새 인쇄 서비스 선택으로 스크롤하면 복사 된 값은 사용자 변경 사항과 함께 이전 서비스의 설정을 기반으로합니다. 값은 클라이언트에서 제공 한 원래 설정을 기반으로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c24ced3aee59d1f2dd37a59962b90aa7b6659d75" translate="yes" xml:space="preserve">
          <source>As this formatter has an optional element, it may be necessary to parse using &lt;a href=&quot;#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)&quot;&gt;&lt;code&gt;parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&amp;lt;?&amp;gt;...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 포맷터에는 선택적 요소가 있으므로 &lt;a href=&quot;#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)&quot;&gt; &lt;code&gt;parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&amp;lt;?&amp;gt;...)&lt;/code&gt; &lt;/a&gt; 사용하여 구문 분석해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63b2cbf6bbb7a70620dccb2c42662a47a39ad720" translate="yes" xml:space="preserve">
          <source>As this formatter has an optional element, it may be necessary to parse using &lt;a href=&quot;datetimeformatter#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-&quot;&gt;&lt;code&gt;parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&amp;lt;?&amp;gt;...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 포맷터에는 선택적 요소가 있으므로 &lt;a href=&quot;datetimeformatter#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-&quot;&gt; &lt;code&gt;parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&amp;lt;?&amp;gt;...)&lt;/code&gt; &lt;/a&gt; 사용하여 구문 분석해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a90cb6e4f589014bf7857aa07948c0333ab20879" translate="yes" xml:space="preserve">
          <source>As usual, the &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;:&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; can be omitted.</source>
          <target state="translated">평소와 같이 &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; 및 &lt;code&gt;:&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; 는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7535c46dcf2769b40f61ad05b1ea40757f5b181c" translate="yes" xml:space="preserve">
          <source>As when creating a &lt;code&gt;Configuration&lt;/code&gt;, &lt;a href=&quot;module/moduledescriptor#isAutomatic()&quot;&gt;&lt;code&gt;automatic&lt;/code&gt;&lt;/a&gt; modules receive special treatment when creating a layer. An automatic module is created in the Java virtual machine as a &lt;code&gt;Module&lt;/code&gt; that reads every unnamed &lt;code&gt;
 Module&lt;/code&gt; in the Java virtual machine.</source>
          <target state="translated">만들 때으로 &lt;code&gt;Configuration&lt;/code&gt; , &lt;a href=&quot;module/moduledescriptor#isAutomatic()&quot;&gt; &lt;code&gt;automatic&lt;/code&gt; &lt;/a&gt; 레이어를 만들 때 모듈은 특별 대우를받을 수 있습니다. 자동 모듈은 Java 가상 머신 에서 이름이 지정되지 않은 모든 &lt;code&gt;Module&lt;/code&gt; 을 읽는 &lt;code&gt; Module&lt;/code&gt; 로 Java 가상 머신에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d986f1c6b5fc10c93dce9af4e60795f3b2310ad7" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt;, the view of a file provided by an instance of this class is guaranteed to be consistent with other views of the same file provided by other instances in the same program. The view provided by an instance of this class may or may not, however, be consistent with the views seen by other concurrently-running programs due to caching performed by the underlying operating system and delays induced by network-filesystem protocols. This is true regardless of the language in which these other programs are written, and whether they are running on the same machine or on some other machine. The exact nature of any such inconsistencies are system-dependent and are therefore unspecified.</source>
          <target state="translated">&lt;a href=&quot;filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt; 과 마찬가지로이 클래스의 인스턴스가 제공 한 파일의보기는 동일한 프로그램의 다른 인스턴스가 제공 한 동일한 파일의 다른보기와 일치하도록 보장됩니다. 그러나이 클래스의 인스턴스가 제공하는보기는 기본 운영 체제에서 수행하는 캐싱 및 네트워크 파일 시스템 프로토콜에 의해 유발 된 지연으로 인해 동시에 실행중인 다른 프로그램에서 보는보기와 일치 할 수도 있고 일치하지 않을 수도 있습니다. 이는 다른 프로그램이 작성되는 언어 및 동일한 시스템에서 실행되는지 또는 다른 시스템에서 실행되는지에 관계없이 적용됩니다. 이러한 불일치의 정확한 특성은 시스템에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7321b4553d4be1009088b0499507fe54640c853f" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;jobkoctets&quot;&gt;&lt;code&gt;JobKOctets&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;JobImpressions&lt;/code&gt; value must also not include the multiplicative factor due to a copies instruction embedded in the document data. If the document data actually includes replications of the document data, this value will include such replication. In other words, this value is always the number of impressions in the source document data, rather than a measure of the number of impressions to be produced by the job.</source>
          <target state="translated">처럼 &lt;a href=&quot;jobkoctets&quot;&gt; &lt;code&gt;JobKOctets&lt;/code&gt; &lt;/a&gt; 상기 &lt;code&gt;JobImpressions&lt;/code&gt; 의 값은 문서 데이터에 포함 된 복사 명령에 곱셈 계수를 포함 할 수 없습니다. 문서 데이터에 실제로 문서 데이터의 복제가 포함 된 경우이 값에는 이러한 복제가 포함됩니다. 즉,이 값은 작업에 의해 생성되는 노출 수 측정 값이 아니라 항상 소스 문서 데이터의 노출 수입니다.</target>
        </trans-unit>
        <trans-unit id="0dd8db7d1efbbb6b79d2c73ecc53bb267bfa661c" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;jobkoctets&quot;&gt;&lt;code&gt;JobKOctets&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;JobImpressions&lt;/code&gt; value must not include the multiplicative factors contributed by the number of copies specified by the &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute, independent of whether the device can process multiple copies without making multiple passes over the job or document data and independent of whether the output is collated or not. Thus the value is independent of the implementation and reflects the size of the document(s) measured in impressions independent of the number of copies.</source>
          <target state="translated">처럼 &lt;a href=&quot;jobkoctets&quot;&gt; &lt;code&gt;JobKOctets&lt;/code&gt; &lt;/a&gt; 상기 &lt;code&gt;JobImpressions&lt;/code&gt; 의 값에 의해 지정된 매수 기부 곱셈 인자 포함하지 않아야 &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 장치가 작업 또는 문서 데이터에 다중 패스 않고 여러 복사본을 처리 할 수 있는지 여부와 무관 여부 출력 무관 한 특성, 대조 여부입니다. 따라서이 값은 구현과 무관하며 사본 수에 관계없이 임프레션으로 측정 된 문서의 크기를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="d0a1adff4be253570aae7c70e7723a214fe98ebb" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;jobkoctets&quot;&gt;&lt;code&gt;JobKOctets&lt;/code&gt;&lt;/a&gt;, the JobImpressions value must also not include the multiplicative factor due to a copies instruction embedded in the document data. If the document data actually includes replications of the document data, this value will include such replication. In other words, this value is always the number of impressions in the source document data, rather than a measure of the number of impressions to be produced by the job.</source>
          <target state="translated">처럼 &lt;a href=&quot;jobkoctets&quot;&gt; &lt;code&gt;JobKOctets&lt;/code&gt; &lt;/a&gt; 상기 JobImpressions 값은 문서 데이터에 포함 된 복사 명령에 곱셈 계수를 포함 할 수 없습니다. 문서 데이터에 실제로 문서 데이터의 복제가 포함 된 경우이 값에는 해당 복제가 포함됩니다. 즉,이 값은 작업에서 생성 된 노출 수를 측정하는 것이 아니라 항상 소스 문서 데이터의 노출 수입니다.</target>
        </trans-unit>
        <trans-unit id="f5f9f9939fad21a9bd4b811bb57e093c751929f2" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;jobkoctets&quot;&gt;&lt;code&gt;JobKOctets&lt;/code&gt;&lt;/a&gt;, the JobImpressions value must not include the multiplicative factors contributed by the number of copies specified by the &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute, independent of whether the device can process multiple copies without making multiple passes over the job or document data and independent of whether the output is collated or not. Thus the value is independent of the implementation and reflects the size of the document(s) measured in impressions independent of the number of copies.</source>
          <target state="translated">처럼 &lt;a href=&quot;jobkoctets&quot;&gt; &lt;code&gt;JobKOctets&lt;/code&gt; &lt;/a&gt; 상기 JobImpressions 값에 의해 지정된 매수 기부 곱셈 인자 포함하지 않아야 &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 장치가 작업 또는 문서 데이터에 다중 패스 않고 여러 복사본을 처리 할 수 있는지 여부와 무관 여부 출력 무관 한 특성, 데이터 정렬 여부입니다. 따라서이 값은 구현과 무관하며 사본 수와 무관하게 노출로 측정 된 문서의 크기를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="a2723d228f118c016a25042ee3a660575455f1bc" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;ActionMap&lt;/code&gt; if you create a cycle, eg:</source>
          <target state="translated">사이클을 생성하는 경우 &lt;code&gt;ActionMap&lt;/code&gt; 과 마찬가지로 :</target>
        </trans-unit>
        <trans-unit id="f6b36971863105d539cbb564dc7a3ad1e3ebc632" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;InputMap&lt;/code&gt; if you create a cycle, eg:</source>
          <target state="translated">사이클을 생성하는 경우 &lt;code&gt;InputMap&lt;/code&gt; 과 마찬가지로 , 예 :</target>
        </trans-unit>
        <trans-unit id="6fc6e5c3cc00733d1ff1b8546cc74f47994bb5e7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;Object.equals()&lt;/code&gt;, the notion of ordering for names depends on the class that implements this interface. For example, the ordering may be based on lexicographical ordering of the name components. Specific attributes of the name, such as how it treats case, may affect the ordering. In general, two names of different classes may not be compared.</source>
          <target state="translated">&lt;code&gt;Object.equals()&lt;/code&gt; 와 마찬가지로 이름 순서 개념은이 인터페이스를 구현하는 클래스에 따라 다릅니다. 예를 들어, 순서는 이름 구성 요소의 사전 순서에 기초 할 수있다. 대소 문자를 처리하는 방법과 같은 이름의 특정 속성이 순서에 영향을 줄 수 있습니다. 일반적으로 다른 클래스의 두 이름은 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6a98742073e2df8125e467c41af37aa99b7823a" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;, if not otherwise specified, this class uses &lt;a href=&quot;executors#defaultThreadFactory()&quot;&gt;&lt;code&gt;Executors.defaultThreadFactory()&lt;/code&gt;&lt;/a&gt; as the default thread factory, and &lt;a href=&quot;threadpoolexecutor.abortpolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt;&lt;/a&gt; as the default rejected execution handler.</source>
          <target state="translated">&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 와 마찬가지로 , 별도로 지정하지 않으면이 클래스는 &lt;a href=&quot;executors#defaultThreadFactory()&quot;&gt; &lt;code&gt;Executors.defaultThreadFactory()&lt;/code&gt; &lt;/a&gt; 를 기본 스레드 팩토리로 사용하고 &lt;a href=&quot;threadpoolexecutor.abortpolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt; &lt;/a&gt; 를 기본 거부 된 실행 처리기로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b749bece098f77ecadbb1923dbff8752bd9d9094" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;java.awt.datatransfer.StringSelection&lt;/code&gt;, if the requested flavor is &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;, or an equivalent flavor, a Reader is returned. &lt;b&gt;Note:&lt;/b&gt; The behavior of the system Clipboard's &lt;code&gt;getTransferData()&lt;/code&gt; method for &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;, and equivalent DataFlavors, is inconsistent with the definition of &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;. Because of this, support for &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;, and equivalent flavors, is &lt;b&gt;deprecated&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;java.awt.datatransfer.StringSelection&lt;/code&gt; 과 마찬가지로 요청 된 플레이버가 &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt; 또는 동등한 플레이버이면 Reader가 반환됩니다. &lt;b&gt;참고 :&lt;/b&gt; 시스템 클립 보드의의 동작 &lt;code&gt;getTransferData()&lt;/code&gt; 를위한 방법 &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt; 및 동등의 DataFlavor는의 정의와 일관성 &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt; . 이 때문에 &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt; 및 이에 상응하는 특징에 대한 지원 이 &lt;b&gt;더 이상 사용되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="262554f67a3eea86592c01186bc8f29566223708" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;reduce()&lt;/code&gt;, a benefit of expressing &lt;code&gt;collect&lt;/code&gt; in this abstract way is that it is directly amenable to parallelization: we can accumulate partial results in parallel and then combine them, so long as the accumulation and combining functions satisfy the appropriate requirements. For example, to collect the String representations of the elements in a stream into an &lt;code&gt;ArrayList&lt;/code&gt;, we could write the obvious sequential for-each form:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 와 마찬가지로 , 표현의 이익을 &lt;code&gt;collect&lt;/code&gt; 이 추상적 인 방법으로는 병렬 직접 의무가 있다는 것입니다 : 우리는 축적으로 너무 오래, 그들을 결합 및 결합 기능은 적절한 요구 사항을 만족 병렬로 부분적인 결과를 축적 할 수 있습니다. 예를 들어, 스트림에있는 요소의 문자열 표현을 &lt;code&gt;ArrayList&lt;/code&gt; 에 수집하기 위해 각 순차 형식을 명확하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede03b687b41f48e7233661bb939683685897780" translate="yes" xml:space="preserve">
          <source>As with any reflected method, these methods (when reflected) may be invoked directly via &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt;&lt;code&gt;Lookup.unreflect&lt;/code&gt;&lt;/a&gt;. However, such reflective calls do not result in access mode method invocations. Such a call, if passed the required argument (a single one, of type &lt;code&gt;Object[]&lt;/code&gt;), will ignore the argument and will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">모든 반영된 메서드와 마찬가지로 이러한 메서드 (반영시)는 &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt; 를 통해 직접 , JNI를 통해 또는 &lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt; &lt;code&gt;Lookup.unreflect&lt;/code&gt; &lt;/a&gt; 를 통해 간접적으로 호출 될 수 있습니다 . 그러나 이러한 반사 호출은 액세스 모드 메소드 호출로 이어지지 않습니다. 이러한 호출은 필수 인수 ( &lt;code&gt;Object[]&lt;/code&gt; 유형의 단일 인수)를 전달하면 인수 를 무시하고 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="6333d66ae19067718314b731c9a438823931dc0f" translate="yes" xml:space="preserve">
          <source>As with any reflected method, these methods (when reflected) may be invoked via &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;. However, such reflective calls do not result in method handle invocations. Such a call, if passed the required argument (a single one, of type &lt;code&gt;Object[]&lt;/code&gt;), will ignore the argument and will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">모든 반영된 메소드와 마찬가지로 이러한 메소드 (반영시)는 &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt; 를 통해 호출 될 수 있습니다 . 그러나 이러한 반사 호출은 메서드 핸들 호출로 이어지지 않습니다. 이러한 호출은 필수 인수 ( &lt;code&gt;Object[]&lt;/code&gt; 유형의 단일 인수)를 전달하면 인수 를 무시하고 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="896d64f648c747af5597747b989014908d267502" translate="yes" xml:space="preserve">
          <source>As with any reflected method, these methods (when reflected) may be invoked via &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;. However, such reflective calls do not result in method handle invocations. Such a call, if passed the required argument (a single one, of type &lt;code&gt;Object[]&lt;/code&gt;), will ignore the argument and will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">반영된 메소드와 마찬가지로이 메소드 (반사 된 경우)는 &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt; 를 통해 호출 할 수 있습니다 . 그러나 이러한 반사 호출은 메소드 핸들 호출을 초래하지 않습니다. 필수 인수 (단일 유형)를 전달한 경우 이러한 호출 &lt;code&gt;Object[]&lt;/code&gt; 를 무시하고 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="6b9b6e0ef7ecc1f48f3ff6c34453251a64104c1e" translate="yes" xml:space="preserve">
          <source>As with automatic modules, the contents of a packaged or exploded module may need to be &lt;em&gt;scanned&lt;/em&gt; in order to determine the packages in the module. Whether &lt;a href=&quot;../../nio/file/files#isHidden(java.nio.file.Path)&quot;&gt;hidden files&lt;/a&gt; are ignored or not is implementation specific and therefore not specified. If a &lt;code&gt;.class&lt;/code&gt; file (other than &lt;code&gt;
 module-info.class&lt;/code&gt;) is found in the top-level directory then it is assumed to be a class in the unnamed package and so &lt;code&gt;FindException&lt;/code&gt; is thrown.</source>
          <target state="translated">자동 모듈과 마찬가지로 모듈 의 패키지를 확인하기 위해 패키지 또는 분해 된 모듈의 내용을 &lt;em&gt;스캔&lt;/em&gt; 해야 할 수 있습니다 . &lt;a href=&quot;../../nio/file/files#isHidden(java.nio.file.Path)&quot;&gt;숨겨진 파일&lt;/a&gt; 이 무시 되는지 여부 는 구현에 따라 다르므로 지정되지 않습니다. 경우 &lt;code&gt;.class&lt;/code&gt; 파일 (이외의 &lt;code&gt; module-info.class&lt;/code&gt; ) 다음은 이름이없는 패키지의 클래스로 간주됩니다 최상위 디렉토리에와 있으므로 발견 &lt;code&gt;FindException&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b9011646c18b6a1b541565467e477948b20784f1" translate="yes" xml:space="preserve">
          <source>As with other &lt;a href=&quot;../../../java.base/java/security/permission&quot;&gt;&lt;code&gt;Permission&lt;/code&gt;&lt;/a&gt; objects, an MBeanPermission can represent either a permission that you &lt;em&gt;have&lt;/em&gt; or a permission that you &lt;em&gt;need&lt;/em&gt;. When a sensitive operation is being checked for permission, an MBeanPermission is constructed representing the permission you need. The operation is only allowed if the permissions you have &lt;a href=&quot;#implies(java.security.Permission)&quot;&gt;imply&lt;/a&gt; the permission you need.</source>
          <target state="translated">다른 경우와 마찬가지로 &lt;a href=&quot;../../../java.base/java/security/permission&quot;&gt; &lt;code&gt;Permission&lt;/code&gt; &lt;/a&gt; 객체, MBeanPermission는 것을 권한 중 하나를 나타낼 수 &lt;em&gt;있다&lt;/em&gt; 거나하는 권한이 &lt;em&gt;필요&lt;/em&gt; . 민감한 작업이 권한을 확인하는 경우 필요한 권한을 나타내는 MBeanPermission이 구성됩니다. 권한이 필요한 권한을 &lt;a href=&quot;#implies(java.security.Permission)&quot;&gt;암시&lt;/a&gt; 하는 경우에만 작업이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cba2c61f7f99bc01a53a595cc3d12bcd79fb3392" translate="yes" xml:space="preserve">
          <source>As with other &lt;a href=&quot;../../java/security/permission&quot;&gt;&lt;code&gt;Permission&lt;/code&gt;&lt;/a&gt; objects, an MBeanPermission can represent either a permission that you &lt;em&gt;have&lt;/em&gt; or a permission that you &lt;em&gt;need&lt;/em&gt;. When a sensitive operation is being checked for permission, an MBeanPermission is constructed representing the permission you need. The operation is only allowed if the permissions you have &lt;a href=&quot;mbeanpermission#implies-java.security.Permission-&quot;&gt;imply&lt;/a&gt; the permission you need.</source>
          <target state="translated">다른 경우와 마찬가지로 &lt;a href=&quot;../../java/security/permission&quot;&gt; &lt;code&gt;Permission&lt;/code&gt; &lt;/a&gt; 객체, MBeanPermission는 것을 권한 중 하나를 나타낼 수 &lt;em&gt;있다&lt;/em&gt; 거나하는 권한 &lt;em&gt;필요&lt;/em&gt; . 민감한 조작이 권한을 점검 할 때, 필요한 권한을 나타내는 MBeanPermission이 구성됩니다. 권한이 필요한 권한을 &lt;a href=&quot;mbeanpermission#implies-java.security.Permission-&quot;&gt;암시&lt;/a&gt; 하는 경우에만 작업이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e99dc2c6441f0c0cb81841bcf0e2788829832e10" translate="yes" xml:space="preserve">
          <source>As with other &lt;code&gt;&lt;a href=&quot;control&quot;&gt;&lt;code&gt;Control&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; subclasses, a method is provided that returns string labels for the values, suitable for display in the user interface.</source>
          <target state="translated">다른 &lt;code&gt;&lt;a href=&quot;control&quot;&gt;&lt;code&gt;Control&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 서브 클래스 , 사용자 인터페이스에 표시하기에 적합한 값의 문자열 레이블을 리턴하는 메소드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="65f9ecf9281d455ff39c6145c2b79da2e1fe863c" translate="yes" xml:space="preserve">
          <source>As with other &lt;code&gt;Control&lt;/code&gt; subclasses, a method is provided that returns string labels for the values, suitable for display in the user interface.</source>
          <target state="translated">다른 &lt;code&gt;Control&lt;/code&gt; 하위 클래스 와 마찬가지로 사용자 인터페이스에 표시하기에 적합한 값에 대한 문자열 레이블을 반환하는 메서드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1246ab44696837b0652fc305b2d39edc07ce22ac" translate="yes" xml:space="preserve">
          <source>As with pooled connections, connections made via a &lt;code&gt;DataSource&lt;/code&gt; object that is implemented to work with the middle tier infrastructure may participate in distributed transactions. This gives an application the ability to involve data sources on multiple servers in a single transaction.</source>
          <target state="translated">풀링 된 연결 과 마찬가지로 중간 계층 인프라에서 작동하도록 구현 된 &lt;code&gt;DataSource&lt;/code&gt; 개체를 통해 이루어진 연결은 분산 트랜잭션에 참여할 수 있습니다. 이를 통해 애플리케이션은 단일 트랜잭션에서 여러 서버의 데이터 소스를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="615d032dca7df7a5c842602da0a20b505578a94e" translate="yes" xml:space="preserve">
          <source>As with selectors, the implementation of asynchronous channels can be replaced by &quot;plugging in&quot; an alternative definition or instance of the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; class defined in the &lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.nio.channels.spi&lt;/code&gt;&lt;/a&gt; package. It is not expected that many developers will actually make use of this facility; it is provided primarily so that sophisticated users can take advantage of operating-system-specific asynchronous I/O mechanisms when very high performance is required.</source>
          <target state="translated">선택기와 마찬가지로 비동기 채널의 구현은 &lt;a href=&quot;spi/package-summary&quot;&gt; &lt;code&gt;java.nio.channels.spi&lt;/code&gt; &lt;/a&gt; 패키지에 정의 된 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 클래스 의 대체 정의 또는 인스턴스를 &quot;플러그인&quot;하여 대체 할 수 있습니다 . 많은 개발자가 실제로이 기능을 사용할 것으로 예상되지는 않습니다. 고급 사용자가 매우 높은 성능이 필요할 때 운영 체제 별 비동기 I / O 메커니즘을 활용할 수 있도록 기본적으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a81f92999bbe8bb40deddaac7c56d7ffe984df" translate="yes" xml:space="preserve">
          <source>As with selectors, the implementation of asynchronous channels can be replaced by &quot;plugging in&quot; an alternative definition or instance of the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; class defined in the &lt;code&gt;&lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.nio.channels.spi&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; package. It is not expected that many developers will actually make use of this facility; it is provided primarily so that sophisticated users can take advantage of operating-system-specific asynchronous I/O mechanisms when very high performance is required.</source>
          <target state="translated">선택기와 마찬가지로, 비동기 채널의 구현은 &lt;code&gt;&lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.nio.channels.spi&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 에 정의 된 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 클래스 의 대체 정의 또는 인스턴스를 &quot;플러그인&quot;하여 대체 할 수 있습니다. 패키지에 . 많은 개발자들이 실제로이 기능을 사용할 것으로 예상되지는 않습니다. 기본적으로 고급 사용자가 매우 높은 성능이 필요할 때 운영 체제 별 비동기 I / O 메커니즘을 활용할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a83689cc07dbd288340afb585c2ad8fe118e29" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;#delete(java.nio.file.Path)&quot;&gt;&lt;code&gt;delete(Path)&lt;/code&gt;&lt;/a&gt; method, an implementation may need to examine the file to determine if the file is a directory. Consequently this method may not be atomic with respect to other file system operations. If the file is a symbolic link, then the symbolic link itself, not the final target of the link, is deleted.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#delete(java.nio.file.Path)&quot;&gt; &lt;code&gt;delete(Path)&lt;/code&gt; &lt;/a&gt; 방법, 구현 파일이 디렉토리인지 여부를 확인하기 위해 파일을 검토해야 할 수 있습니다. 따라서이 방법은 다른 파일 시스템 작업과 관련하여 원 자성이 아닐 수 있습니다. 파일이 심볼릭 링크 인 경우 링크의 최종 대상이 아닌 심볼릭 링크 자체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="58c9e0627883470188162f1617620dbcb74e8a35" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;#findWithinHorizon(java.lang.String,int)&quot;&gt;&lt;code&gt;findWithinHorizon()&lt;/code&gt;&lt;/a&gt; methods, this method might block waiting for additional input, and it might buffer an unbounded amount of input searching for a match.</source>
          <target state="translated">&lt;a href=&quot;#findWithinHorizon(java.lang.String,int)&quot;&gt; &lt;code&gt;findWithinHorizon()&lt;/code&gt; &lt;/a&gt; 메서드 와 마찬가지로이 메서드는 추가 입력 대기를 차단할 수 있으며 일치 항목을 검색하는 무제한 입력을 버퍼링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8da4a35fbeea42792bb871fcaaaff80c1a8f2297" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;files#delete-java.nio.file.Path-&quot;&gt;&lt;code&gt;delete(Path)&lt;/code&gt;&lt;/a&gt; method, an implementation may need to examine the file to determine if the file is a directory. Consequently this method may not be atomic with respect to other file system operations. If the file is a symbolic link, then the symbolic link itself, not the final target of the link, is deleted.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;files#delete-java.nio.file.Path-&quot;&gt; &lt;code&gt;delete(Path)&lt;/code&gt; &lt;/a&gt; 방법, 구현 파일이 디렉토리인지 여부를 확인하기 위해 파일을 검토해야 할 수 있습니다. 결과적으로이 방법은 다른 파일 시스템 작업과 관련하여 원 자성이 아닐 수 있습니다. 파일이 심볼릭 링크 인 경우 링크의 최종 대상이 아닌 심볼릭 링크 자체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="892068b5185e5337e67f6c48a31993f2577028e8" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;File.createTempFile&lt;/code&gt; methods, this method is only part of a temporary-file facility. Where used as a &lt;em&gt;work files&lt;/em&gt;, the resulting file may be opened using the &lt;a href=&quot;standardopenoption#DELETE_ON_CLOSE&quot;&gt;&lt;code&gt;DELETE_ON_CLOSE&lt;/code&gt;&lt;/a&gt; option so that the file is deleted when the appropriate &lt;code&gt;close&lt;/code&gt; method is invoked. Alternatively, a &lt;a href=&quot;../../lang/runtime#addShutdownHook(java.lang.Thread)&quot;&gt;&lt;code&gt;shutdown-hook&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../io/file#deleteOnExit()&quot;&gt;&lt;code&gt;File.deleteOnExit()&lt;/code&gt;&lt;/a&gt; mechanism may be used to delete the file automatically.</source>
          <target state="translated">&lt;code&gt;File.createTempFile&lt;/code&gt; 메소드 와 마찬가지로이 메소드는 임시 파일 기능의 일부일뿐입니다. A와 사용하는 경우 &lt;em&gt;작업 파일&lt;/em&gt; , 결과 파일은 사용하여 열 수 있습니다 &lt;a href=&quot;standardopenoption#DELETE_ON_CLOSE&quot;&gt; &lt;code&gt;DELETE_ON_CLOSE&lt;/code&gt; 의&lt;/a&gt; 적절한 때 파일이 삭제되도록 옵션을 &lt;code&gt;close&lt;/code&gt; 메소드가 호출됩니다. 또는 &lt;a href=&quot;../../lang/runtime#addShutdownHook(java.lang.Thread)&quot;&gt; &lt;code&gt;shutdown-hook&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/file#deleteOnExit()&quot;&gt; &lt;code&gt;File.deleteOnExit()&lt;/code&gt; &lt;/a&gt; 메커니즘을 사용하여 파일을 자동으로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a261b6a09fb814b4bbbcd5aab921703e3b7193" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;File.createTempFile&lt;/code&gt; methods, this method is only part of a temporary-file facility. Where used as a &lt;em&gt;work files&lt;/em&gt;, the resulting file may be opened using the &lt;a href=&quot;standardopenoption#DELETE_ON_CLOSE&quot;&gt;&lt;code&gt;DELETE_ON_CLOSE&lt;/code&gt;&lt;/a&gt; option so that the file is deleted when the appropriate &lt;code&gt;close&lt;/code&gt; method is invoked. Alternatively, a &lt;a href=&quot;../../lang/runtime#addShutdownHook-java.lang.Thread-&quot;&gt;&lt;code&gt;shutdown-hook&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../io/file#deleteOnExit--&quot;&gt;&lt;code&gt;File.deleteOnExit()&lt;/code&gt;&lt;/a&gt; mechanism may be used to delete the file automatically.</source>
          <target state="translated">&lt;code&gt;File.createTempFile&lt;/code&gt; 메소드 와 마찬가지로이 메소드는 임시 파일 기능의 일부일뿐입니다. &lt;em&gt;작업 파일&lt;/em&gt; 로 사용되는 경우 적절한 &lt;code&gt;close&lt;/code&gt; 메소드가 호출 될 때 파일이 삭제되도록 &lt;a href=&quot;standardopenoption#DELETE_ON_CLOSE&quot;&gt; &lt;code&gt;DELETE_ON_CLOSE&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 결과 파일을 열 수 있습니다 . 또는 &lt;a href=&quot;../../lang/runtime#addShutdownHook-java.lang.Thread-&quot;&gt; &lt;code&gt;shutdown-hook&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/file#deleteOnExit--&quot;&gt; &lt;code&gt;File.deleteOnExit()&lt;/code&gt; &lt;/a&gt; 메커니즘을 사용하여 파일을 자동으로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7317926a77bc48bf845c713c6d355a6885acef73" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;createTempFile&lt;/code&gt; methods, this method is only part of a temporary-file facility. A &lt;a href=&quot;../../lang/runtime#addShutdownHook(java.lang.Thread)&quot;&gt;&lt;code&gt;shutdown-hook&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../io/file#deleteOnExit()&quot;&gt;&lt;code&gt;File.deleteOnExit()&lt;/code&gt;&lt;/a&gt; mechanism may be used to delete the directory automatically.</source>
          <target state="translated">&lt;code&gt;createTempFile&lt;/code&gt; 메소드 와 마찬가지로이 메소드는 임시 파일 기능의 일부일뿐입니다. &lt;a href=&quot;../../lang/runtime#addShutdownHook(java.lang.Thread)&quot;&gt; &lt;code&gt;shutdown-hook&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/file#deleteOnExit()&quot;&gt; &lt;code&gt;File.deleteOnExit()&lt;/code&gt; &lt;/a&gt; 메커니즘은 자동으로 디렉토리를 삭제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="326ad63f1918b9c85c6453ad60621a5368927b46" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;createTempFile&lt;/code&gt; methods, this method is only part of a temporary-file facility. A &lt;a href=&quot;../../lang/runtime#addShutdownHook-java.lang.Thread-&quot;&gt;&lt;code&gt;shutdown-hook&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../io/file#deleteOnExit--&quot;&gt;&lt;code&gt;File.deleteOnExit()&lt;/code&gt;&lt;/a&gt; mechanism may be used to delete the directory automatically.</source>
          <target state="translated">&lt;code&gt;createTempFile&lt;/code&gt; 메소드 와 마찬가지로이 메소드는 임시 파일 기능의 일부일뿐입니다. &lt;a href=&quot;../../lang/runtime#addShutdownHook-java.lang.Thread-&quot;&gt; &lt;code&gt;shutdown-hook&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/file#deleteOnExit--&quot;&gt; &lt;code&gt;File.deleteOnExit()&lt;/code&gt; &lt;/a&gt; 메커니즘은 자동으로 디렉토리를 삭제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e3b8ba36cadd3e6df85e320488c95b68d911b8" translate="yes" xml:space="preserve">
          <source>As with the regular reduction operation, &lt;code&gt;collect()&lt;/code&gt; operations can only be parallelized if appropriate conditions are met. For any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result &lt;code&gt;p&lt;/code&gt; that is the result of any series of accumulator and combiner invocations, &lt;code&gt;p&lt;/code&gt; must be equivalent to &lt;code&gt;combiner.apply(p, supplier.get())&lt;/code&gt;.</source>
          <target state="translated">일반 축소 작업과 마찬가지로 &lt;code&gt;collect()&lt;/code&gt; 작업은 적절한 조건이 충족되는 경우에만 병렬화 할 수 있습니다. 부분적으로 누적 된 결과의 경우 빈 결과 컨테이너와 결합하면 동등한 결과가 생성되어야합니다. 즉, 일련의 누산기 및 결합기 호출의 결과 인 부분적으로 누적 된 결과 &lt;code&gt;p&lt;/code&gt; 의 경우 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;combiner.apply(p, supplier.get())&lt;/code&gt; 과 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bcb00a9519c459ce65b7b2341192b1e789fc3248" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;JButton.States&lt;/code&gt; entry lists the states that the JButton style will support. You then specify the settings for each state. If you do not specify the &lt;code&gt;JButton.States&lt;/code&gt; entry, then the standard Synth states will be assumed. If you specify the entry but the list of states is empty or null, then the standard synth states will be assumed.</source>
          <target state="translated">보시다시피 &lt;code&gt;JButton.States&lt;/code&gt; 항목은 JButton 스타일이 지원할 상태를 나열합니다. 그런 다음 각 상태에 대한 설정을 지정합니다. &lt;code&gt;JButton.States&lt;/code&gt; 항목을 지정하지 않으면 표준 Synth 상태로 간주됩니다. 항목을 지정했지만 상태 목록이 비어 있거나 null 인 경우 표준 신디사이저 상태로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ce160b9c85add9848ba5fabe3a06f93d6b3242c4" translate="yes" xml:space="preserve">
          <source>As you can see, the definitions are very similar. The only difference is that the convention for naming the interface is to use &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MXBean&lt;/code&gt; for MXBeans, rather than &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MBean&lt;/code&gt; for Standard MBeans.</source>
          <target state="translated">보다시피, 정의는 매우 유사합니다. 유일한 차이점은 인터페이스 이름 지정 규칙 이 표준 &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MBean&lt;/code&gt; 용 &lt;em&gt;Something&lt;/em&gt; MBean 대신 &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MXBean&lt;/code&gt; 용 &lt;em&gt;Something&lt;/em&gt; MXBean 을 사용 한다는 것 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="221179f56564f16c3bf0ead01596d6864af0443e" translate="yes" xml:space="preserve">
          <source>Ascending key ordered views and their iterators are faster than descending ones.</source>
          <target state="translated">오름차순 키 정렬 뷰 및 반복자는 내림차순보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="680836461076e4d9fd895662b650ecbef5e28569" translate="yes" xml:space="preserve">
          <source>Ascending ordered views and their iterators are faster than descending ones.</source>
          <target state="translated">오름차순으로 정렬 된 뷰와 반복자는 내림차순보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="fe7333ede146ba59ba3843df3e7ebb063f3db329" translate="yes" xml:space="preserve">
          <source>Ascertains whether escape processing is enabled for this &lt;code&gt;RowSet&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;RowSet&lt;/code&gt; 객체에 대해 이스케이프 처리를 사용할 수 있는지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="758aa47daf61431b726197da8c21e06dda3dc2f0" translate="yes" xml:space="preserve">
          <source>Ascertains whether the last value read from this &lt;code&gt;SQLInputImpl&lt;/code&gt; object was &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;SQLInputImpl&lt;/code&gt; 객체 에서 읽은 마지막 값 이 &lt;code&gt;null&lt;/code&gt; 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="15d9bda45e150bb1a9913fe8f8dfb05cb4ff7c64" translate="yes" xml:space="preserve">
          <source>Aside from some minor deviations noted below, an instance of this class represents a URI reference as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described &lt;a href=&quot;inet6address#scoped&quot;&gt;here&lt;/a&gt;. This class provides constructors for creating URI instances from their components or by parsing their string forms, methods for accessing the various components of an instance, and methods for normalizing, resolving, and relativizing URI instances. Instances of this class are immutable.</source>
          <target state="translated">아래에 언급 된 약간의 편차 외에,이 클래스의 인스턴스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396에&lt;/i&gt;&lt;/a&gt; 정의 된 URI 참조를 나타냅니다. URI &lt;i&gt;(Uniform Resource Identifiers) : 일반 구문&lt;/i&gt; , &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732에&lt;/i&gt;&lt;/a&gt; 의해 수정 됨 &lt;i&gt;: URL의 리터럴 IPv6 주소 형식&lt;/i&gt; . 리터럴 IPv6 주소 형식은 scope_id도 지원합니다. scope_ids의 구문과 사용법은 &lt;a href=&quot;inet6address#scoped&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 . 이 클래스는 컴포넌트에서 URI 인스턴스를 작성하거나 문자열 양식을 구문 분석하여 인스턴스의 다양한 컴포넌트에 액세스하는 메소드 및 URI 인스턴스를 정규화, 해결 및 재배치하는 메소드를 제공합니다. 이 클래스의 인스턴스는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b53f94e0b88a8376cd30e61475e0381084d5b75d" translate="yes" xml:space="preserve">
          <source>Ask the authenticator that has been registered with the system for a password.</source>
          <target state="translated">시스템에 등록 된 인증 자에게 비밀번호를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="37ce9a9c92de1ff89be39c1eee7738ad15cf079f" translate="yes" xml:space="preserve">
          <source>Ask the authenticator that has been registered with the system for a password. This is the preferred method for requesting a password because the hostname can be provided in cases where the InetAddress is not available.</source>
          <target state="translated">시스템에 등록 된 인증 자에게 비밀번호를 요청하십시오. InetAddress를 사용할 수없는 경우 호스트 이름을 제공 할 수 있으므로 암호를 요청하는 데 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="dfa2042d74fe5d4408b1711c40259c2e739bf893" translate="yes" xml:space="preserve">
          <source>Ask the editor to start editing and to select everything</source>
          <target state="translated">편집자에게 편집을 시작하고 모든 것을 선택하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="c0b0a70195dc1449b91b352575bd84b45a3dc2a0" translate="yes" xml:space="preserve">
          <source>Ask the given &lt;code&gt;authenticator&lt;/code&gt; for a password.</source>
          <target state="translated">주어진 &lt;code&gt;authenticator&lt;/code&gt; 에게 암호를 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="70685b4b5e5251b8ac4e294cf0f9329f70870415" translate="yes" xml:space="preserve">
          <source>Ask the given &lt;code&gt;authenticator&lt;/code&gt; for a password. If the given &lt;code&gt;authenticator&lt;/code&gt; is null, the authenticator, if any, that has been registered with the system using &lt;a href=&quot;#setDefault(java.net.Authenticator)&quot;&gt;&lt;code&gt;setDefault&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">주어진 &lt;code&gt;authenticator&lt;/code&gt; 에게 암호를 요청하십시오 . 지정된 &lt;code&gt;authenticator&lt;/code&gt; null이면 &lt;a href=&quot;#setDefault(java.net.Authenticator)&quot;&gt; &lt;code&gt;setDefault&lt;/code&gt; &lt;/a&gt; 를 사용 하여 시스템에 등록 된 인증자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b96067459f9364e53d745b6285496bafb7d8dbc" translate="yes" xml:space="preserve">
          <source>Ask the resource manager to prepare for a transaction commit of the transaction specified in xid.</source>
          <target state="translated">자원 관리자에게 xid에 지정된 트랜잭션의 트랜잭션 커밋을 준비하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="2e6bb01b3d9978b9222f3cfc88666046c17032cf" translate="yes" xml:space="preserve">
          <source>Ask this authenticator for a password.</source>
          <target state="translated">이 인증 자에게 암호를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="54a223f32c33573a38b8d6ba7d39910720e9071e" translate="yes" xml:space="preserve">
          <source>Asks a confirming question, like yes/no/cancel.</source>
          <target state="translated">예 / 아니요 / 취소와 같은 확인 질문을합니다.</target>
        </trans-unit>
        <trans-unit id="e2f0096d1367ce69aa70ecb7503d8a10498a0c06" translate="yes" xml:space="preserve">
          <source>Asks the current input method to reconvert text from the current client component.</source>
          <target state="translated">현재 입력 방법에 현재 클라이언트 구성 요소의 텍스트를 다시 변환하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="8cbd44a99e0624127211f52983fe7b7a658e42ca" translate="yes" xml:space="preserve">
          <source>Asks the current input method to reconvert text from the current client component. The input method obtains the text to be reconverted from the client component using the &lt;a href=&quot;inputmethodrequests#getSelectedText(java.text.AttributedCharacterIterator.Attribute%5B%5D)&quot;&gt;&lt;code&gt;InputMethodRequests.getSelectedText&lt;/code&gt;&lt;/a&gt; method. The other &lt;code&gt;InputMethodRequests&lt;/code&gt; methods must be prepared to deal with further information requests by the input method. The composed and/or committed text will be sent to the client component as a sequence of &lt;code&gt;InputMethodEvent&lt;/code&gt;s. If the input method cannot reconvert the given text, the text is returned as committed text in an &lt;code&gt;InputMethodEvent&lt;/code&gt;.</source>
          <target state="translated">현재 입력 방법에 현재 클라이언트 구성 요소의 텍스트를 다시 변환하도록 요청합니다. 입력 메서드는 &lt;a href=&quot;inputmethodrequests#getSelectedText(java.text.AttributedCharacterIterator.Attribute%5B%5D)&quot;&gt; &lt;code&gt;InputMethodRequests.getSelectedText&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 클라이언트 구성 요소에서 다시 변환 할 텍스트를 가져옵니다 . 다른 &lt;code&gt;InputMethodRequests&lt;/code&gt; 메서드는 입력 메서드의 추가 정보 요청을 처리 할 준비가되어 있어야합니다. 작성 및 / 또는 커밋 된 텍스트는 &lt;code&gt;InputMethodEvent&lt;/code&gt; 시퀀스로 클라이언트 구성 요소에 전송됩니다 . 입력 방법이 주어진 텍스트를 다시 변환 할 수없는 경우 해당 텍스트는 &lt;code&gt;InputMethodEvent&lt;/code&gt; 에 커밋 된 텍스트로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac710040d9edd7f70003a1f51cda6c7e543a3c41" translate="yes" xml:space="preserve">
          <source>Asks the editor if it can start editing using &lt;code&gt;anEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;anEvent&lt;/code&gt; 를 사용하여 편집을 시작할 수 있는지 편집자에게 묻습니다 .</target>
        </trans-unit>
        <trans-unit id="0fdb7a9cc29fde0e52139a9e114e5c4daef86b3c" translate="yes" xml:space="preserve">
          <source>Asks the editor if it can start editing using &lt;code&gt;anEvent&lt;/code&gt;. &lt;code&gt;anEvent&lt;/code&gt; is in the invoking component coordinate system. The editor can not assume the Component returned by &lt;code&gt;getCellEditorComponent&lt;/code&gt; is installed. This method is intended for the use of client to avoid the cost of setting up and installing the editor component if editing is not possible. If editing can be started this method returns true.</source>
          <target state="translated">&lt;code&gt;anEvent&lt;/code&gt; 를 사용하여 편집을 시작할 수 있는지 편집자에게 묻습니다 . &lt;code&gt;anEvent&lt;/code&gt; 는 호출하는 컴포넌트 좌표계에 있습니다. 편집기는 &lt;code&gt;getCellEditorComponent&lt;/code&gt; 에서 반환 된 구성 요소 가 설치되어 있다고 가정 할 수 없습니다 . 이 방법은 편집이 불가능한 경우 편집기 구성 요소를 설정하고 설치하는 비용을 피하기 위해 클라이언트를 사용하기위한 것입니다. 편집을 시작할 수있는 경우이 메서드는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45efd8625e80e75e71f5326b2062c4dfbfa9b66b" translate="yes" xml:space="preserve">
          <source>Assembles system menu.</source>
          <target state="translated">시스템 메뉴를 조립합니다.</target>
        </trans-unit>
        <trans-unit id="e3292c12a856a02722a46d87471ff4e6faefa104" translate="yes" xml:space="preserve">
          <source>AssertionError</source>
          <target state="translated">AssertionError</target>
        </trans-unit>
        <trans-unit id="72a049221815f87248586556441a46a16237d8e4" translate="yes" xml:space="preserve">
          <source>Assign a value to the &quot;declared&quot; flag of a specific attribute.</source>
          <target state="translated">특정 속성의 &quot;선언 된&quot;플래그에 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="3179effeb5d69717e2bad863525aafb9facaa135" translate="yes" xml:space="preserve">
          <source>Assign a value to the &quot;declared&quot; flag of a specific attribute. This is normally needed only for attributes of type CDATA, including attributes whose type is changed to or from CDATA.</source>
          <target state="translated">특정 속성의 &quot;선언 된&quot;플래그에 값을 할당합니다. 이는 일반적으로 유형이 CDATA로 또는 CDATA에서 변경되는 속성을 포함하여 CDATA 유형의 속성에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3956cdf51fca4fb0472c212d072a3c40a049bc65" translate="yes" xml:space="preserve">
          <source>Assign a value to the &quot;specified&quot; flag of a specific attribute.</source>
          <target state="translated">특정 속성의 &quot;지정된&quot;플래그에 값을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1e54db72810ff4a9f71ddd57a69c6af046c56877" translate="yes" xml:space="preserve">
          <source>Assign a value to the &quot;specified&quot; flag of a specific attribute. This is the only way this flag can be cleared, except clearing by initialization with the copy constructor.</source>
          <target state="translated">특정 속성의 &quot;지정된&quot;플래그에 값을 지정하십시오. 이것이 복사 생성자로 초기화하여 지우는 것을 제외하고는이 플래그를 지울 수있는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e24e824b68118fff14de0778b82b4c9dbfb94b46" translate="yes" xml:space="preserve">
          <source>Assigned</source>
          <target state="translated">Assigned</target>
        </trans-unit>
        <trans-unit id="7bba905b55142579de2a66f6b683b423c3b0fe2f" translate="yes" xml:space="preserve">
          <source>Assigning the value different from listed above will cause an unspecified behavior.</source>
          <target state="translated">위에 나열된 것과 다른 값을 지정하면 지정되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aba7f8ea24d1d89adf7ccf6191e29dc4d229e16e" translate="yes" xml:space="preserve">
          <source>Assigning the value different from listed above will cause unspecified behavior.</source>
          <target state="translated">위에 나열된 것과 다른 값을 지정하면 지정되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="852dbb53c173a49101772c0f25442c6ccfb20602" translate="yes" xml:space="preserve">
          <source>Assigns a new value to a cookie after the cookie is created.</source>
          <target state="translated">쿠키가 생성 된 후 쿠키에 새 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b52d10a10654b41ea61d70d7f65aa92071dd4dd3" translate="yes" xml:space="preserve">
          <source>Assigns a new value to a cookie after the cookie is created. If you use a binary value, you may want to use BASE64 encoding.</source>
          <target state="translated">쿠키가 생성 된 후 쿠키에 새로운 값을 할당합니다. 이진 값을 사용하는 경우 BASE64 인코딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6ec57416daeb7e1bf901725b6c77e9ee388e56" translate="yes" xml:space="preserve">
          <source>Assigns default positions to each glyph in this &lt;code&gt;GlyphVector&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;GlyphVector&lt;/code&gt; 의 각 글리프에 기본 위치를 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="a3a33595b5d4599556bcefe95e14bfa5c59089f3" translate="yes" xml:space="preserve">
          <source>Assigns default positions to each glyph in this &lt;code&gt;GlyphVector&lt;/code&gt;. This can destroy information generated during initial layout of this &lt;code&gt;GlyphVector&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;GlyphVector&lt;/code&gt; 의 각 글리프에 기본 위치를 할당 합니다 . 이 &lt;code&gt;GlyphVector&lt;/code&gt; 의 초기 레이아웃 중에 생성 된 정보를 파괴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c53a3314f445e4a9a4018a59d0a067e552ecb6d" translate="yes" xml:space="preserve">
          <source>Assigns the current value of the encoding property.</source>
          <target state="translated">인코딩 속성의 현재 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="940caf1a2a99903001af7a3a14c58ce863f86e5c" translate="yes" xml:space="preserve">
          <source>Assigns the current value of the version property.</source>
          <target state="translated">버전 속성의 현재 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="14131902f49a325ec31a2d035fe77e792ea1898a" translate="yes" xml:space="preserve">
          <source>Assigns the given certificate to the given alias.</source>
          <target state="translated">지정된 인증서를 지정된 별명에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="dd54242e3214e9a11b71c1f7bbbd2c0d26edd181" translate="yes" xml:space="preserve">
          <source>Assigns the given key (that has already been protected) to the given alias.</source>
          <target state="translated">지정된 키 (이미 보호 된)를 지정된 별명에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="190310fc8afce66d231a98403c36c4c9c03fcbe3" translate="yes" xml:space="preserve">
          <source>Assigns the given key to the given alias, protecting it with the given password.</source>
          <target state="translated">지정된 키로 지정된 별명을 지정하고 지정된 비밀번호로 보호합니다.</target>
        </trans-unit>
        <trans-unit id="fa0f1bbf5f4d07b8de90733569bccd093335123e" translate="yes" xml:space="preserve">
          <source>Assigns the given trusted certificate to the given alias.</source>
          <target state="translated">제공된 신뢰할 수있는 인증서를 지정된 별명에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="41bb3dd961b066e09527355b3f6b2f0decad0e47" translate="yes" xml:space="preserve">
          <source>Assigns the specified Object reference to each element of the specified array of Objects.</source>
          <target state="translated">지정된 Object 배열의 각 요소에 지정된 Object 참조를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="cc29f457a43c6edbf792bb3025852f00001f92b0" translate="yes" xml:space="preserve">
          <source>Assigns the specified Object reference to each element of the specified range of the specified array of Objects.</source>
          <target state="translated">지정된 Object 배열의 지정된 범위에있는 각 요소에 지정된 Object 참조를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="9e6567cd1d0e6b379d3edb1755530e088fdcca25" translate="yes" xml:space="preserve">
          <source>Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 Object 배열의 지정된 범위의 각 요소에 지정된 Object 참조를 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. ( &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 경우 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="aa97362d123bf088ceb72ad6ec4beca483f4bbd7" translate="yes" xml:space="preserve">
          <source>Assigns the specified boolean value to each element of the specified array of booleans.</source>
          <target state="translated">지정된 부울 값을 지정된 부울 배열의 각 요소에 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a9fb44ef9537d0bed01355fa19c92227ce44a2bd" translate="yes" xml:space="preserve">
          <source>Assigns the specified boolean value to each element of the specified range of the specified array of booleans.</source>
          <target state="translated">지정된 부울 배열의 지정된 범위에있는 각 요소에 지정된 부울 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="19c114567eeb53351e27e40c31941a7cad152ac2" translate="yes" xml:space="preserve">
          <source>Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 부울 값을 지정된 부울 배열의 지정된 범위에있는 각 요소에 지정합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. ( &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 경우 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b71da5862ab3bca6cd964d71a1c4b63d88307544" translate="yes" xml:space="preserve">
          <source>Assigns the specified byte value to each element of the specified array of bytes.</source>
          <target state="translated">지정된 바이트 배열의 각 요소에 지정된 바이트 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="066d0c8db44b64c11d31eaf82ed6f233a443883d" translate="yes" xml:space="preserve">
          <source>Assigns the specified byte value to each element of the specified range of the specified array of bytes.</source>
          <target state="translated">지정된 바이트 배열의 지정된 범위에있는 각 요소에 지정된 바이트 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="aabf230d433b804d69bfbdde2d2bbe871d5db946" translate="yes" xml:space="preserve">
          <source>Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 바이트 배열의 지정된 범위의 각 요소에 지정된 바이트 값을 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. ( &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 경우 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a61cd2fecf8872fd26aa3b2bc9d7203ef55288db" translate="yes" xml:space="preserve">
          <source>Assigns the specified char value to each element of the specified array of chars.</source>
          <target state="translated">지정된 문자 값을 지정된 문자 배열의 각 요소에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="9b9d986a8a5b5cfc53fe22c191d9f02b111d7c7b" translate="yes" xml:space="preserve">
          <source>Assigns the specified char value to each element of the specified range of the specified array of chars.</source>
          <target state="translated">지정된 char 배열의 지정된 범위에있는 각 요소에 지정된 char 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="bfc01c4cd64169604e3669500d07ccedad5fa31b" translate="yes" xml:space="preserve">
          <source>Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 문자 값을 지정된 문자 배열의 지정된 범위의 각 요소에 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. ( &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 경우 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="aa2949a21b0bda3197dc597b50e2edbadd924d2d" translate="yes" xml:space="preserve">
          <source>Assigns the specified double value to each element of the specified array of doubles.</source>
          <target state="translated">지정된 double 값을 지정된 double 배열의 각 요소에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d747a12501c41aa9ea13554b2c57fec5aa48a4ae" translate="yes" xml:space="preserve">
          <source>Assigns the specified double value to each element of the specified range of the specified array of doubles.</source>
          <target state="translated">지정된 double 배열의 지정된 범위에있는 각 요소에 지정된 double 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="c2cccf0fbbdc4c631f0191e8949b6b9e251d2e05" translate="yes" xml:space="preserve">
          <source>Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 double 배열의 지정된 범위의 각 요소에 지정된 double 값을 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. (만약 &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="548f8d9d8d90319449cd7c1e43c0ddb3165d7cba" translate="yes" xml:space="preserve">
          <source>Assigns the specified float value to each element of the specified array of floats.</source>
          <target state="translated">지정된 float 값을 지정된 float 배열의 각 요소에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="2544a9ca144b11339a617b3d5c9d97a0d4d7169a" translate="yes" xml:space="preserve">
          <source>Assigns the specified float value to each element of the specified range of the specified array of floats.</source>
          <target state="translated">지정된 float 배열의 지정된 범위에있는 각 요소에 지정된 float 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="87f83cba2e8ee29319591b81320b49a9a38a3f77" translate="yes" xml:space="preserve">
          <source>Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 float 값을 지정된 float 배열의 지정된 범위에있는 각 요소에 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. ( &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 경우 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8ab05d5d5c34361f40aec66e70227fcc60b823b6" translate="yes" xml:space="preserve">
          <source>Assigns the specified int value to each element of the specified array of ints.</source>
          <target state="translated">지정된 int 값을 지정된 int 배열의 각 요소에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="15dcd4995be25075436a346bb2447364772538da" translate="yes" xml:space="preserve">
          <source>Assigns the specified int value to each element of the specified range of the specified array of ints.</source>
          <target state="translated">지정된 int 배열의 지정된 범위에있는 각 요소에 지정된 int 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8ab20ceeff85d29f36f3312d2b8c7695c820d435" translate="yes" xml:space="preserve">
          <source>Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 int 값을 지정된 int 배열의 지정된 범위에있는 각 요소에 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. ( &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 경우 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8e7cfdfe806edcc64f438c51c5879abbcede733e" translate="yes" xml:space="preserve">
          <source>Assigns the specified long value to each element of the specified array of longs.</source>
          <target state="translated">지정된 long 값을 지정된 long 배열의 각 요소에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="f4cf28244917fe9de5a11c62f7d5f82f3bded36a" translate="yes" xml:space="preserve">
          <source>Assigns the specified long value to each element of the specified range of the specified array of longs.</source>
          <target state="translated">지정된 long 배열의 지정된 범위에있는 각 요소에 지정된 long 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="7c12a444178cac052d8254551cf806e6c839cad0" translate="yes" xml:space="preserve">
          <source>Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 long 배열의 지정된 범위의 각 요소에 지정된 long 값을 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. ( &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 경우 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b0362a5fb07ffcc97a8d631afd78d1343ee6009e" translate="yes" xml:space="preserve">
          <source>Assigns the specified short value to each element of the specified array of shorts.</source>
          <target state="translated">지정된 short 배열의 각 요소에 지정된 short 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b908fdb8daae43487c0422a708e8dfeb85f68cfb" translate="yes" xml:space="preserve">
          <source>Assigns the specified short value to each element of the specified range of the specified array of shorts.</source>
          <target state="translated">지정된 short 배열의 지정된 범위에있는 각 요소에 지정된 short 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="bb589c326208de9d7da93d57ef3ba32112689328" translate="yes" xml:space="preserve">
          <source>Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, to index &lt;code&gt;toIndex&lt;/code&gt;, exclusive. (If &lt;code&gt;fromIndex==toIndex&lt;/code&gt;, the range to be filled is empty.)</source>
          <target state="translated">지정된 short 배열의 지정된 범위의 각 요소에 지정된 short 값을 할당합니다. 채워질 범위는 index &lt;code&gt;fromIndex&lt;/code&gt; 를 포함하여 index &lt;code&gt;toIndex&lt;/code&gt; 까지 포함 됩니다. (만약 &lt;code&gt;fromIndex==toIndex&lt;/code&gt; 인 채울 범위는 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a39e950342c74cb6be62ea68712b0794ec71defa" translate="yes" xml:space="preserve">
          <source>Associate a &lt;code&gt;DropTarget&lt;/code&gt; with this component.</source>
          <target state="translated">이 구성 요소에 &lt;code&gt;DropTarget&lt;/code&gt; 을 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="3d5ab5a5222dcc5ea4afd28ee96ca88a58abfa6d" translate="yes" xml:space="preserve">
          <source>Associate a &lt;code&gt;DropTarget&lt;/code&gt; with this component. The &lt;code&gt;Component&lt;/code&gt; will receive drops only if it is enabled.</source>
          <target state="translated">이 구성 요소에 &lt;code&gt;DropTarget&lt;/code&gt; 을 연결합니다 . &lt;code&gt;Component&lt;/code&gt; 가 활성화 된 경우에만 드롭을받습니다.</target>
        </trans-unit>
        <trans-unit id="afda1354a3a51a2a4ece66c971df42f00468cfd9" translate="yes" xml:space="preserve">
          <source>Associate a named attribute with this feature.</source>
          <target state="translated">명명 된 속성을이 기능과 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="55a8164c7b8d7289d071313db70a61de250d6bb6" translate="yes" xml:space="preserve">
          <source>Associate an object to a key on this node.</source>
          <target state="translated">이 노드의 키에 개체를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="7f664988fe3783f9a217e070c6a53a17cd55f4d9" translate="yes" xml:space="preserve">
          <source>Associate an object to a key on this node. The object can later be retrieved from this node by calling &lt;code&gt;getUserData&lt;/code&gt; with the same key.</source>
          <target state="translated">이 노드의 키에 개체를 연결합니다. 객체는 나중에 동일한 키로 &lt;code&gt;getUserData&lt;/code&gt; 를 호출하여이 노드에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fed07227fb7016097478db12f2ca5f4e93599583" translate="yes" xml:space="preserve">
          <source>Associate the newly instantiated Applet with the appropriate AppletContext.</source>
          <target state="translated">새로 인스턴스화 된 애플릿을 적절한 AppletContext와 연관 시키십시오.</target>
        </trans-unit>
        <trans-unit id="5ea80ee780b44807cfe90a72a283ba223f4cc7d4" translate="yes" xml:space="preserve">
          <source>Associate the provided &lt;code&gt;Subject&lt;/code&gt; with this &lt;code&gt;SubjectDomainCombiner&lt;/code&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;Subject&lt;/code&gt; 를이 &lt;code&gt;SubjectDomainCombiner&lt;/code&gt; 와 연관 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="96a7869a23b73f3451a0232cf15bec5ea0c63c5f" translate="yes" xml:space="preserve">
          <source>Associate this PrinterJob with a new PrintService.</source>
          <target state="translated">이 PrinterJob을 새 PrintService와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="fe1cb668107f9f3d7fd39778f9092c90c15f0854" translate="yes" xml:space="preserve">
          <source>Associate this PrinterJob with a new PrintService. This method is overridden by subclasses which support specifying a Print Service. Throws &lt;code&gt;PrinterException&lt;/code&gt; if the specified service cannot support the &lt;code&gt;Pageable&lt;/code&gt; and &lt;code&gt;Printable&lt;/code&gt; interfaces necessary to support 2D printing.</source>
          <target state="translated">이 PrinterJob을 새 PrintService와 연결합니다. 이 메서드는 인쇄 서비스 지정을 지원하는 하위 클래스에 의해 재정의됩니다. 지정된 서비스가 2D 인쇄를 지원하는 데 필요한 &lt;code&gt;Pageable&lt;/code&gt; 및 &lt;code&gt;Printable&lt;/code&gt; 인터페이스를 지원할 수없는 경우 &lt;code&gt;PrinterException&lt;/code&gt; 을 throw 합니다 .</target>
        </trans-unit>
        <trans-unit id="e29d38541cd869d3405412eed5b1633671996421" translate="yes" xml:space="preserve">
          <source>Associated</source>
          <target state="translated">Associated</target>
        </trans-unit>
        <trans-unit id="c56252f4b250dc006a0320b3dbe2ee3bd8d9e4bb" translate="yes" xml:space="preserve">
          <source>Associates a &lt;code&gt;Bindings&lt;/code&gt; instance with a particular scope in this &lt;code&gt;ScriptContext&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Bindings&lt;/code&gt; 인스턴스를이 &lt;code&gt;ScriptContext&lt;/code&gt; 의 특정 범위와 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="5b775edadbddda2d7d7523bed597c7f2ffebaac1" translate="yes" xml:space="preserve">
          <source>Associates a &lt;code&gt;Bindings&lt;/code&gt; instance with a particular scope in this &lt;code&gt;ScriptContext&lt;/code&gt;. Calls to the &lt;code&gt;getAttribute&lt;/code&gt; and &lt;code&gt;setAttribute&lt;/code&gt; methods must map to the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; methods of the &lt;code&gt;Bindings&lt;/code&gt; for the specified scope.</source>
          <target state="translated">이 &lt;code&gt;ScriptContext&lt;/code&gt; 의 &lt;code&gt;Bindings&lt;/code&gt; 인스턴스를 특정 범위와 연결합니다 . &lt;code&gt;getAttribute&lt;/code&gt; 및 &lt;code&gt;setAttribute&lt;/code&gt; 메소드 에 대한 호출 은 지정된 범위 에 대한 &lt;code&gt;Bindings&lt;/code&gt; 의 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; 메소드에 맵핑되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="429c2cbe243b64b1cc542b6771ea7e607e72de21" translate="yes" xml:space="preserve">
          <source>Associates a property with the document.</source>
          <target state="translated">속성을 문서와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="561f0cb319ee05eb8f7dd277fd39cbc5f41079e6" translate="yes" xml:space="preserve">
          <source>Associates a property with the document. Two standard property keys provided are: &lt;a href=&quot;#StreamDescriptionProperty&quot;&gt; &lt;code&gt;StreamDescriptionProperty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#TitleProperty&quot;&gt;&lt;code&gt;TitleProperty&lt;/code&gt;&lt;/a&gt;. Other properties, such as author, may also be defined.</source>
          <target state="translated">속성을 문서와 연결합니다. 제공되는 두 가지 표준 속성 키는 &lt;a href=&quot;#StreamDescriptionProperty&quot;&gt; &lt;code&gt;StreamDescriptionProperty&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#TitleProperty&quot;&gt; &lt;code&gt;TitleProperty&lt;/code&gt; &lt;/a&gt; 입니다. 작성자와 같은 다른 속성도 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d77c9190951a1c06534733f64b9cfbabd320492c" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified boolean value with the specified key in this preference node.</source>
          <target state="translated">지정된 부울 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="3fad436712ad26a7310dfd53775ac46a6cb4631a" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified boolean value with the specified key in this preference node. The associated string is &lt;code&gt;&quot;true&quot;&lt;/code&gt; if the value is true, and &lt;code&gt;&quot;false&quot;&lt;/code&gt; if it is false. This method is intended for use in conjunction with &lt;a href=&quot;#getBoolean(java.lang.String,boolean)&quot;&gt;&lt;code&gt;getBoolean(java.lang.String, boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 부울 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다. 값이 true &lt;code&gt;&quot;true&quot;&lt;/code&gt; 연관된 문자열은 &quot;true&quot; 이고 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 이면 &quot;false&quot; 입니다. 이 메소드는 &lt;a href=&quot;#getBoolean(java.lang.String,boolean)&quot;&gt; &lt;code&gt;getBoolean(java.lang.String, boolean)&lt;/code&gt; &lt;/a&gt; 과 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="cb1e81826acc11cdd4fd8787f2f261093651dd07" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified boolean value with the specified key in this preference node. The associated string is &lt;code&gt;&quot;true&quot;&lt;/code&gt; if the value is true, and &lt;code&gt;&quot;false&quot;&lt;/code&gt; if it is false. This method is intended for use in conjunction with &lt;a href=&quot;preferences#getBoolean-java.lang.String-boolean-&quot;&gt;&lt;code&gt;getBoolean(java.lang.String, boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 부울 값을 나타내는 문자열을이 환경 설정 노드의 지정된 키와 연관시킵니다. 값이 true &lt;code&gt;&quot;true&quot;&lt;/code&gt; 연관된 문자열은 &quot;true&quot; 이고, &lt;code&gt;&quot;false&quot;&lt;/code&gt; 이면 &quot;false&quot; 입니다. 이 메소드는 &lt;a href=&quot;preferences#getBoolean-java.lang.String-boolean-&quot;&gt; &lt;code&gt;getBoolean(java.lang.String, boolean)&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="62ce37159c6c7c1e8fac38ab3d53b3e0b0cbbe84" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified byte array with the specified key in this preference node.</source>
          <target state="translated">지정된 바이트 배열을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="2833c20c864a4a65f2407bd5a5f7c09afc6d20e5" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified byte array with the specified key in this preference node. The associated string is the</source>
          <target state="translated">지정된 바이트 배열을 나타내는 캐릭터 라인을이 설정 노드의 지정된 키에 관련 짓습니다. 연관된 문자열은</target>
        </trans-unit>
        <trans-unit id="b986481f8eebbd1cfc5e920b04128b1fbbff926d" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified double value with the specified key in this preference node.</source>
          <target state="translated">지정된 double 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="59b1f3e3783dcc197f8456f3d721d926d9807199" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified double value with the specified key in this preference node. The associated string is the one that would be returned if the double value were passed to &lt;a href=&quot;../../../../java.base/java/lang/double#toString(double)&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;#getDouble(java.lang.String,double)&quot;&gt;&lt;code&gt;getDouble(java.lang.String, double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 double 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다. 연관된 문자열은 double 값이 &lt;a href=&quot;../../../../java.base/java/lang/double#toString(double)&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 반환되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;#getDouble(java.lang.String,double)&quot;&gt; &lt;code&gt;getDouble(java.lang.String, double)&lt;/code&gt; &lt;/a&gt; 과 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="405e98c0ec2e33a2102051245efeb3354d88d37a" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified double value with the specified key in this preference node. The associated string is the one that would be returned if the double value were passed to &lt;a href=&quot;../../lang/double#toString-double-&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;preferences#getDouble-java.lang.String-double-&quot;&gt;&lt;code&gt;getDouble(java.lang.String, double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 double 값을 나타내는 문자열을이 환경 설정 노드의 지정된 키와 연관시킵니다. 연관된 문자열은 double 값이 &lt;a href=&quot;../../lang/double#toString-double-&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 리턴되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;preferences#getDouble-java.lang.String-double-&quot;&gt; &lt;code&gt;getDouble(java.lang.String, double)&lt;/code&gt; &lt;/a&gt; 과 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="811d93a2d81ac217e884d98ea40501bed7e07b28" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified float value with the specified key in this preference node.</source>
          <target state="translated">지정된 float 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="265b6ab460e863a9f81e12fae614898938027fb4" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified float value with the specified key in this preference node. The associated string is the one that would be returned if the float value were passed to &lt;a href=&quot;../../../../java.base/java/lang/float#toString(float)&quot;&gt;&lt;code&gt;Float.toString(float)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;#getFloat(java.lang.String,float)&quot;&gt;&lt;code&gt;getFloat(java.lang.String, float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 float 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다. 연관된 문자열은 float 값이 &lt;a href=&quot;../../../../java.base/java/lang/float#toString(float)&quot;&gt; &lt;code&gt;Float.toString(float)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 반환되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;#getFloat(java.lang.String,float)&quot;&gt; &lt;code&gt;getFloat(java.lang.String, float)&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e1a97e7672e7f164eb7d746fc62a23c0bfd82b25" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified float value with the specified key in this preference node. The associated string is the one that would be returned if the float value were passed to &lt;a href=&quot;../../lang/float#toString-float-&quot;&gt;&lt;code&gt;Float.toString(float)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;preferences#getFloat-java.lang.String-float-&quot;&gt;&lt;code&gt;getFloat(java.lang.String, float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 float 값을 나타내는 문자열을이 환경 설정 노드의 지정된 키와 연관시킵니다. 연관된 문자열은 float 값이 &lt;a href=&quot;../../lang/float#toString-float-&quot;&gt; &lt;code&gt;Float.toString(float)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 반환되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;preferences#getFloat-java.lang.String-float-&quot;&gt; &lt;code&gt;getFloat(java.lang.String, float)&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3f126d853d1c8c1081d99f7088f1bc511ff589e3" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified int value with the specified key in this preference node.</source>
          <target state="translated">지정된 int 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="9d82ccd21c0b6c1717de6a0d084f3786544f8d0c" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified int value with the specified key in this preference node. The associated string is the one that would be returned if the int value were passed to &lt;a href=&quot;../../../../java.base/java/lang/integer#toString(int)&quot;&gt;&lt;code&gt;Integer.toString(int)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;#getInt(java.lang.String,int)&quot;&gt;&lt;code&gt;getInt(java.lang.String, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 int 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다. 연관된 문자열은 int 값이 &lt;a href=&quot;../../../../java.base/java/lang/integer#toString(int)&quot;&gt; &lt;code&gt;Integer.toString(int)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 반환되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;#getInt(java.lang.String,int)&quot;&gt; &lt;code&gt;getInt(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="402eba66a399cc572ffcc2bcf5d31eaf5d6758a9" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified int value with the specified key in this preference node. The associated string is the one that would be returned if the int value were passed to &lt;a href=&quot;../../lang/integer#toString-int-&quot;&gt;&lt;code&gt;Integer.toString(int)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;preferences#getInt-java.lang.String-int-&quot;&gt;&lt;code&gt;getInt(java.lang.String, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 int 값을 나타내는 문자열을이 환경 설정 노드의 지정된 키와 연관시킵니다. 관련 문자열은 int 값이 &lt;a href=&quot;../../lang/integer#toString-int-&quot;&gt; &lt;code&gt;Integer.toString(int)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 반환되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;preferences#getInt-java.lang.String-int-&quot;&gt; &lt;code&gt;getInt(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="59874ea1a953f3203589d3f0a64f675b70a05d8e" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified long value with the specified key in this preference node.</source>
          <target state="translated">지정된 long 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f50f4e9f4152a2c76a5b968e9850a70d4c665bec" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified long value with the specified key in this preference node. The associated string is the one that would be returned if the long value were passed to &lt;a href=&quot;../../../../java.base/java/lang/long#toString(long)&quot;&gt;&lt;code&gt;Long.toString(long)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;#getLong(java.lang.String,long)&quot;&gt;&lt;code&gt;getLong(java.lang.String, long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 long 값을 나타내는 문자열을이 기본 설정 노드의 지정된 키와 연결합니다. 연관된 문자열은 long 값이 &lt;a href=&quot;../../../../java.base/java/lang/long#toString(long)&quot;&gt; &lt;code&gt;Long.toString(long)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 반환되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;#getLong(java.lang.String,long)&quot;&gt; &lt;code&gt;getLong(java.lang.String, long)&lt;/code&gt; &lt;/a&gt; 과 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="72969c845bbda1489fd6757f2f1f88ef6d5c3422" translate="yes" xml:space="preserve">
          <source>Associates a string representing the specified long value with the specified key in this preference node. The associated string is the one that would be returned if the long value were passed to &lt;a href=&quot;../../lang/long#toString-long-&quot;&gt;&lt;code&gt;Long.toString(long)&lt;/code&gt;&lt;/a&gt;. This method is intended for use in conjunction with &lt;a href=&quot;preferences#getLong-java.lang.String-long-&quot;&gt;&lt;code&gt;getLong(java.lang.String, long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 long 값을 나타내는 문자열을이 환경 설정 노드의 지정된 키와 연관시킵니다. 연관된 문자열은 long 값이 &lt;a href=&quot;../../lang/long#toString-long-&quot;&gt; &lt;code&gt;Long.toString(long)&lt;/code&gt; &lt;/a&gt; 전달 된 경우 리턴되는 문자열입니다 . 이 메소드는 &lt;a href=&quot;preferences#getLong-java.lang.String-long-&quot;&gt; &lt;code&gt;getLong(java.lang.String, long)&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9dd3f787ca15bb5eefd28f5c6d487adefe12ce1b" translate="yes" xml:space="preserve">
          <source>Associates the editor with a text document.</source>
          <target state="translated">편집기를 텍스트 문서와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="9d10851be40e90636ddb547482ce215bee2592b6" translate="yes" xml:space="preserve">
          <source>Associates the editor with a text document. The currently registered factory is used to build a view for the document, which gets displayed by the editor after revalidation. A PropertyChange event (&quot;document&quot;) is propagated to each listener.</source>
          <target state="translated">편집기를 텍스트 문서와 연결합니다. 현재 등록 된 팩토리는 재 검증 후 편집기에 표시되는 문서에 대한보기를 작성하는 데 사용됩니다. PropertyChange 이벤트 ( &quot;문서&quot;)가 각 리스너로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="aec8b78153861e86f1b3f29002affd38e8f3e461" translate="yes" xml:space="preserve">
          <source>Associates the editor with a text document. The currently registered factory is used to build a view for the document, which gets displayed by the editor.</source>
          <target state="translated">편집기를 텍스트 문서와 연결합니다. 현재 등록 된 팩토리는 편집기에 표시되는 문서에 대한보기를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="daa90549130d536371136182f14279e9eded26b2" translate="yes" xml:space="preserve">
          <source>Associates the editor with a text document. This must be a &lt;code&gt;StyledDocument&lt;/code&gt;.</source>
          <target state="translated">편집기를 텍스트 문서와 연결합니다. &lt;code&gt;StyledDocument&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d8b941f2598d7e75a59544d73f6b3752776225a" translate="yes" xml:space="preserve">
          <source>Associates the given path with the given location. Any previous value will be discarded.</source>
          <target state="translated">주어진 경로를 주어진 위치와 연관시킵니다. 이전 값은 버려집니다.</target>
        </trans-unit>
        <trans-unit id="cab030f323008760ae72759c2b396fb5e21f4675" translate="yes" xml:space="preserve">
          <source>Associates the given search path with the given location.</source>
          <target state="translated">지정된 검색 경로를 지정된 위치와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="4616321ebaa03fd4913b0e71d734f5f832ab37fc" translate="yes" xml:space="preserve">
          <source>Associates the given search path with the given location. Any previous value will be discarded. If the location is a module-oriented or output location, any module-specific associations set up by &lt;a href=&quot;#setLocationForModule(javax.tools.JavaFileManager.Location,java.lang.String,java.util.Collection)&quot;&gt;setLocationForModule&lt;/a&gt; will be cancelled.</source>
          <target state="translated">지정된 검색 경로를 지정된 위치와 연결합니다. 이전 값은 모두 삭제됩니다. 위치가 모듈 지향 또는 출력 위치 인 경우 &lt;a href=&quot;#setLocationForModule(javax.tools.JavaFileManager.Location,java.lang.String,java.util.Collection)&quot;&gt;setLocationForModule에&lt;/a&gt; 의해 설정된 모든 모듈 관련 연결 이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="3c5152450c078fcd1b5d69f65f5f1638bb1ed70a" translate="yes" xml:space="preserve">
          <source>Associates the given search path with the given module and location, which must be a module-oriented or output location.</source>
          <target state="translated">지정된 검색 경로를 지정된 모듈 및 위치와 연결합니다. 모듈 지향 또는 출력 위치 여야합니다.</target>
        </trans-unit>
        <trans-unit id="824f932d85d61d2fb036c594a862d6fed5463dc4" translate="yes" xml:space="preserve">
          <source>Associates the given search path with the given module and location, which must be a module-oriented or output location. Any previous value will be discarded. This overrides any default association derived from the search path associated with the location itself. All such module-specific associations will be cancelled if a new search path is associated with the location by calling &lt;a href=&quot;#setLocation(javax.tools.JavaFileManager.Location,java.lang.Iterable)&quot;&gt;setLocation &lt;/a&gt; or &lt;a href=&quot;#setLocationFromPaths(javax.tools.JavaFileManager.Location,java.util.Collection)&quot;&gt;setLocationFromPaths&lt;/a&gt;.</source>
          <target state="translated">지정된 검색 경로를 지정된 모듈 및 위치와 연결합니다. 모듈 지향 또는 출력 위치 여야합니다. 이전 값은 모두 삭제됩니다. 이는 위치 자체와 연관된 검색 경로에서 파생 된 모든 기본 연관을 대체합니다. 새 검색 경로가 &lt;a href=&quot;#setLocation(javax.tools.JavaFileManager.Location,java.lang.Iterable)&quot;&gt;setLocation&lt;/a&gt; 또는 &lt;a href=&quot;#setLocationFromPaths(javax.tools.JavaFileManager.Location,java.util.Collection)&quot;&gt;setLocationFromPaths&lt;/a&gt; 를 호출하여 위치와 연결되면 이러한 모든 모듈 관련 연결이 취소됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce44901b8fe7b1e5a344bf936e73410fd825cae2" translate="yes" xml:space="preserve">
          <source>Associates the specified message digest with this stream.</source>
          <target state="translated">지정된 메시지 요약을이 스트림과 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="4aedc217436104862899bfd917f42c6876d02da2" translate="yes" xml:space="preserve">
          <source>Associates the specified persistence delegate with the given type.</source>
          <target state="translated">지정된 지속성 대리자를 지정된 형식과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="c207a1526d3e87d682d33956745f8f28964f5056" translate="yes" xml:space="preserve">
          <source>Associates the specified stream with the specified key in this applet context.</source>
          <target state="translated">지정된 스트림을이 애플릿 컨텍스트의 지정된 키와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="120587f0aaf1be398039e94df3a080b55cdf7bbb" translate="yes" xml:space="preserve">
          <source>Associates the specified stream with the specified key in this applet context. If the applet context previously contained a mapping for this key, the old value is replaced.</source>
          <target state="translated">지정된 스트림을이 애플릿 컨텍스트의 지정된 키와 연관시킵니다. 애플릿 컨텍스트에 이전에이 키에 대한 매핑이 포함 된 경우 이전 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="46394ec7a101b03340a6587004a576409057f8b3" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified attribute name (key) in this Map.</source>
          <target state="translated">지정된 값을이 맵의 지정된 속성 이름 (키)과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="e2d6673941ced8f85bc7d2d31f579905b7989d0a" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified attribute name (key) in this Map. If the Map previously contained a mapping for the attribute name, the old value is replaced.</source>
          <target state="translated">지정된 값을이 맵의 지정된 속성 이름 (키)과 연관시킵니다. 맵에 이전에 속성 이름에 대한 맵핑이 포함 된 경우 이전 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="39ad33a5d746b83560d42a35681a1da81c0d0770" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified attribute name, specified as a String.</source>
          <target state="translated">지정된 값을 문자열로 지정된 지정된 속성 이름과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="75f2bdf25f7f51dda93e424528bcb2ebe5312dfe" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified attribute name, specified as a String. The attributes name is case-insensitive. If the Map previously contained a mapping for the attribute name, the old value is replaced.</source>
          <target state="translated">지정된 값을 지정된 속성 이름 (String으로 지정된)과 연관시킵니다. 속성 이름은 대소 문자를 구분하지 않습니다. 맵에 이전에 속성 이름에 대한 맵핑이 포함 된 경우 이전 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="2fffb6afdcfe9099ae096bc7c0c1aef032d241d5" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this context.</source>
          <target state="translated">이 컨텍스트에서 지정된 값을 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="c73ac59fc30103d3b70a666642f64b986553ac7d" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this context. If the context previously contained a mapping for this key, the old value is replaced by the specified value.</source>
          <target state="translated">이 컨텍스트에서 지정된 값을 지정된 키와 연결합니다. 컨텍스트에 이전에이 키에 대한 매핑이 포함 된 경우 이전 값이 지정된 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="5af9913790bece6eeec4b6b22d0ac1fc117f1210" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this identity hash map.</source>
          <target state="translated">지정된 값을이 ID 해시 맵의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="0741057f3a2bf120ef2d33699a0aa9512f6a283e" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this identity hash map. If the map previously contained a mapping for the key, the old value is replaced.</source>
          <target state="translated">지정된 값을이 아이덴티티 해시 맵의 지정된 키에 관련 짓습니다. 맵에 이전에 키에 대한 맵핑이 포함 된 경우 이전 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6970d32733ee777a7badb6404c1939ad0c423fd8" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this map (optional operation).</source>
          <target state="translated">지정된 값을이 맵의 지정된 키와 연결합니다 (선택적 작업).</target>
        </trans-unit>
        <trans-unit id="27b34f9e23c6cfe9e869dd5dc7451d2d5df38b1d" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map &lt;code&gt;m&lt;/code&gt; is said to contain a mapping for a key &lt;code&gt;k&lt;/code&gt; if and only if &lt;a href=&quot;#containsKey(java.lang.Object)&quot;&gt;&lt;code&gt;m.containsKey(k)&lt;/code&gt;&lt;/a&gt; would return &lt;code&gt;true&lt;/code&gt;.)</source>
          <target state="translated">지정된 값을이 맵의 지정된 키와 연결합니다 (선택적 작업). 맵에 이전에 키에 대한 매핑이 포함 된 경우 이전 값이 지정된 값으로 대체됩니다. (맵 &lt;code&gt;m&lt;/code&gt; 은 &lt;a href=&quot;#containsKey(java.lang.Object)&quot;&gt; &lt;code&gt;m.containsKey(k)&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우에만 키 &lt;code&gt;k&lt;/code&gt; 에 대한 매핑을 포함한다고 합니다 .)</target>
        </trans-unit>
        <trans-unit id="3b2417d854b3d413b72fb5e3655a2c211c281d9d" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map &lt;code&gt;m&lt;/code&gt; is said to contain a mapping for a key &lt;code&gt;k&lt;/code&gt; if and only if &lt;a href=&quot;map#containsKey(java.lang.Object)&quot;&gt;&lt;code&gt;m.containsKey(k)&lt;/code&gt;&lt;/a&gt; would return &lt;code&gt;true&lt;/code&gt;.)</source>
          <target state="translated">지정된 값을이 맵의 지정된 키와 연결합니다 (선택적 작업). 맵에 이전에 키에 대한 매핑이 포함 된 경우 이전 값이 지정된 값으로 대체됩니다. (맵 &lt;code&gt;m&lt;/code&gt; 은 &lt;a href=&quot;map#containsKey(java.lang.Object)&quot;&gt; &lt;code&gt;m.containsKey(k)&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우에만 키 &lt;code&gt;k&lt;/code&gt; 에 대한 매핑을 포함한다고 합니다 .)</target>
        </trans-unit>
        <trans-unit id="ccb82428d35baee9740c6ecdf19fc281e23f9c3d" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map &lt;code&gt;m&lt;/code&gt; is said to contain a mapping for a key &lt;code&gt;k&lt;/code&gt; if and only if &lt;a href=&quot;map#containsKey-java.lang.Object-&quot;&gt;&lt;code&gt;m.containsKey(k)&lt;/code&gt;&lt;/a&gt; would return &lt;code&gt;true&lt;/code&gt;.)</source>
          <target state="translated">지정된 값을이 맵의 지정된 키와 연관시킵니다 (선택적 조작). 맵에 이전에 키에 대한 맵핑이 포함 된 경우 이전 값이 지정된 값으로 대체됩니다. ( &lt;code&gt;m&lt;/code&gt; 맵 이 &lt;a href=&quot;map#containsKey-java.lang.Object-&quot;&gt; &lt;code&gt;m.containsKey(k)&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 돌려 주는 경우에만 키 &lt;code&gt;k&lt;/code&gt; 에 대한 매핑을 포함한다고 합니다 .)</target>
        </trans-unit>
        <trans-unit id="36e0d856a6c0dcfe83c15e40aab96415213aa2f9" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this map.</source>
          <target state="translated">지정된 값을이 맵의 지정된 키와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="adb578d547a699ec9eca9741fe72aa2e0bdc6674" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.</source>
          <target state="translated">지정된 값을이 맵의 지정된 키와 연관시킵니다. 맵에 이전에 키에 대한 맵핑이 포함 된 경우 이전 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="551bc84ca615d2fafe109a62876f4e8d0a4502a6" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this map. If the map previously contained a mapping for this key, the old value is replaced.</source>
          <target state="translated">지정된 값을이 맵의 지정된 키와 연관시킵니다. 맵에 이전에이 키에 대한 맵핑이 포함 된 경우 이전 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0bc237fc2b57374ff6a182e558a47d47e8763f0a" translate="yes" xml:space="preserve">
          <source>Associates the specified value with the specified key in this preference node.</source>
          <target state="translated">지정된 값을이 환경 설정 노드의 지정된 키와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="7834ca4a8fca23930775c7ff74cdae02e831d307" translate="yes" xml:space="preserve">
          <source>Associating Style Sheets with XML documents Version 1.0</source>
          <target state="translated">스타일 시트를 XML 문서 버전 1.0과 연관</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="01c87cbcfcb3a4c3c670dfd17de13f85145d0637" translate="yes" xml:space="preserve">
          <source>Assume the linkage arguments are as follows:</source>
          <target state="translated">연결 인수가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2dc2100f672c34160990cbf608240b0f61030c73" translate="yes" xml:space="preserve">
          <source>Assuming</source>
          <target state="translated">Assuming</target>
        </trans-unit>
        <trans-unit id="26b8d1cd93b0a70aa708d7ef3eaaabd54c871558" translate="yes" xml:space="preserve">
          <source>Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is</source>
          <target state="translated">동적 유형 안전 뷰가 생성되기 전에 맵에 잘못 입력 된 키 또는 값이없고 맵에 대한 모든 후속 액세스가 뷰 (또는 해당 콜렉션 뷰 중 하나)를 통해 발생한다고 가정하면,</target>
        </trans-unit>
        <trans-unit id="9ea0a7be7566f90ae54ba0c383e2ca9e62b14ca1" translate="yes" xml:space="preserve">
          <source>Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is &lt;em&gt;guaranteed&lt;/em&gt; that the map cannot contain an incorrectly typed key or value.</source>
          <target state="translated">동적 유형 안전 뷰가 생성되기 전에 맵에 잘못 입력 된 키나 값이없고 맵에 대한 모든 후속 액세스가 뷰 (또는 컬렉션 뷰 중 하나)를 통해 발생 &lt;em&gt;한다고&lt;/em&gt; 가정하면 맵이 잘못 입력 된 키 또는 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2684e9da2f1f66e957040b3dfd882412818330a2" translate="yes" xml:space="preserve">
          <source>Assuming that there is a security manager, or that the implementation chooses to make checks anyway, the checks are made as detailed below. In what follows, and unless otherwise specified, &lt;code&gt;className&lt;/code&gt; is the string returned by &lt;a href=&quot;mbeaninfo#getClassName()&quot;&gt;&lt;code&gt;MBeanInfo.getClassName()&lt;/code&gt;&lt;/a&gt; for the target MBean.</source>
          <target state="translated">보안 관리자가 있거나 구현에서 확인을 선택한다고 가정하면 아래에 설명 된대로 확인이 이루어집니다. 다음에서 그리고 달리 지정되지 않는 한 &lt;code&gt;className&lt;/code&gt; 은 대상 MBean에 대해 &lt;a href=&quot;mbeaninfo#getClassName()&quot;&gt; &lt;code&gt;MBeanInfo.getClassName()&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="5e277e047ec1bb884239c12a127e28b4227b5181" translate="yes" xml:space="preserve">
          <source>Assuming that there is a security manager, or that the implementation chooses to make checks anyway, the checks are made as detailed below. In what follows, and unless otherwise specified, &lt;code&gt;className&lt;/code&gt; is the string returned by &lt;a href=&quot;mbeaninfo#getClassName--&quot;&gt;&lt;code&gt;MBeanInfo.getClassName()&lt;/code&gt;&lt;/a&gt; for the target MBean.</source>
          <target state="translated">보안 관리자가 있거나 구현에서 검사를 선택한다고 가정하면 검사는 아래에 자세히 설명 된대로 수행됩니다. 다음에서, 달리 지정되지 않는 한, &lt;code&gt;className&lt;/code&gt; 은 대상 MBean에 대해 &lt;a href=&quot;mbeaninfo#getClassName--&quot;&gt; &lt;code&gt;MBeanInfo.getClassName()&lt;/code&gt; &lt;/a&gt; 에 의해 리턴 된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="22283d771439aa7823d5c15a58186011af184d67" translate="yes" xml:space="preserve">
          <source>Assuming there are no other scaling transforms added to the &lt;code&gt;Graphics2D&lt;/code&gt; object, the resulting line will be approximately 15 pixels wide. As the example code demonstrates, a floating-point line offers better precision, especially when large transforms are used with a &lt;code&gt;Graphics2D&lt;/code&gt; object. When a line is diagonal, the exact width depends on how the rendering pipeline chooses which pixels to fill as it traces the theoretical widened outline. The choice of which pixels to turn on is affected by the antialiasing attribute because the antialiasing rendering pipeline can choose to color partially-covered pixels.</source>
          <target state="translated">&lt;code&gt;Graphics2D&lt;/code&gt; 개체에 추가 된 다른 크기 조정 변환이 없다고 가정하면 결과 선의 너비는 약 15 픽셀이됩니다. 예제 코드에서 알 수 있듯이 부동 소수점 줄은 특히 &lt;code&gt;Graphics2D&lt;/code&gt; 개체 와 함께 큰 변환을 사용할 때 더 나은 정밀도를 제공 합니다. 선이 대각선 일 때 정확한 너비는 렌더링 파이프 라인이 이론적으로 넓어진 윤곽선을 추적 할 때 채울 픽셀을 선택하는 방법에 따라 다릅니다. 안티 앨리어싱 렌더링 파이프 라인이 부분적으로 덮인 픽셀의 색상을 선택할 수 있기 때문에 켤 픽셀의 선택은 안티 앨리어싱 속성의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="e864db538fc4d63a8155b6107c72a215e133afc3" translate="yes" xml:space="preserve">
          <source>Assure the rectangles are created.</source>
          <target state="translated">직사각형이 생성되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="54da51c6e514c6c934fbde58897984f378972c6c" translate="yes" xml:space="preserve">
          <source>Astronomical and Scientific Notes</source>
          <target state="translated">천문 및 과학 노트</target>
        </trans-unit>
        <trans-unit id="580edc5fb3b7034f1b915922663d854b824bc61b" translate="yes" xml:space="preserve">
          <source>Asymmetric primitive: key agreement and key distribution</source>
          <target state="translated">비대칭 기본 요소 : 키 계약 및 키 분배</target>
        </trans-unit>
        <trans-unit id="2980e582cf65c953331bea13f7e0d66a66676398" translate="yes" xml:space="preserve">
          <source>Asymmetric primitive: key encapsulation mechanism</source>
          <target state="translated">비대칭 프리미티브 : 키 캡슐화 메커니즘</target>
        </trans-unit>
        <trans-unit id="0d2796c4c5fa505c038af711127a4b8a98410166" translate="yes" xml:space="preserve">
          <source>Asymmetric primitive: public key encryption</source>
          <target state="translated">비대칭 기본 요소 : 공개 키 암호화</target>
        </trans-unit>
        <trans-unit id="b8470d41ba31d8d653235530d47cdc9f886b039c" translate="yes" xml:space="preserve">
          <source>Asymmetric primitive: signature scheme</source>
          <target state="translated">비대칭 프리미티브 : 서명 체계</target>
        </trans-unit>
        <trans-unit id="ee354e8540e9b98480026a8b0146863a1ca05cff" translate="yes" xml:space="preserve">
          <source>AsyncBoxView</source>
          <target state="translated">AsyncBoxView</target>
        </trans-unit>
        <trans-unit id="848467ea04c9f7448c5b0f1fbaa31f843c7d7ac4" translate="yes" xml:space="preserve">
          <source>AsyncBoxView.ChildLocator</source>
          <target state="translated">AsyncBoxView.ChildLocator</target>
        </trans-unit>
        <trans-unit id="93b416ebd87bfed062f5a7578286b1ba8a59456e" translate="yes" xml:space="preserve">
          <source>AsyncBoxView.ChildState</source>
          <target state="translated">AsyncBoxView.ChildState</target>
        </trans-unit>
        <trans-unit id="d36830bb1cdc9797d519a38f83f8c2a95a23787f" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;LSParser&lt;/code&gt; objects are expected to also implement the &lt;code&gt;events::EventTarget&lt;/code&gt; interface so that event listeners can be registered on asynchronous &lt;code&gt;LSParser&lt;/code&gt; objects.</source>
          <target state="translated">비동기 &lt;code&gt;LSParser&lt;/code&gt; 객체는 이벤트 리스너가 비동기 &lt;code&gt;LSParser&lt;/code&gt; 객체 에 등록 될 수 있도록 &lt;code&gt;events::EventTarget&lt;/code&gt; 인터페이스 도 구현해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7011bcb2a149d047c8ec7153896517a23adc9f65" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O</source>
          <target state="translated">비동기식 I / O</target>
        </trans-unit>
        <trans-unit id="8a319250e7a62a6449653025f2ab2f88895ac77d" translate="yes" xml:space="preserve">
          <source>Asynchronous Loading</source>
          <target state="translated">비동기식 로딩</target>
        </trans-unit>
        <trans-unit id="3beeb5d6437684f9d37c4cc7339c30f7ce34c987" translate="yes" xml:space="preserve">
          <source>Asynchronous channels are bound to an asynchronous channel group for the purpose of resource sharing. A group has an associated &lt;a href=&quot;../../util/concurrent/executorservice&quot;&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; to which tasks are submitted to handle I/O events and dispatch to completion handlers that consume the result of asynchronous operations performed on channels in the group. The group can optionally be specified when creating the channel or the channel can be bound to a &lt;em&gt;default group&lt;/em&gt;. Sophisticated users may wish to create their own asynchronous channel groups or configure the &lt;code&gt;ExecutorService&lt;/code&gt; that will be used for the default group.</source>
          <target state="translated">비동기 채널은 리소스 공유를 위해 비동기 채널 그룹에 바인딩됩니다. 그룹에는 I / O 이벤트를 처리하고 그룹의 채널에서 수행 된 비동기 작업의 결과를 사용하는 완료 핸들러로 디스패치하기 위해 태스크가 제출되는 연관된 &lt;a href=&quot;../../util/concurrent/executorservice&quot;&gt; &lt;code&gt;ExecutorService&lt;/code&gt; &lt;/a&gt; 가 있습니다. 채널을 만들 때 그룹을 선택적으로 지정하거나 채널을 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩 할 수 있습니다 . 정교한 사용자는 자체 비동기 채널 그룹을 만들거나 기본 그룹에 사용될 &lt;code&gt;ExecutorService&lt;/code&gt; 를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10310ac79f4a508680b2efe15ed75869c6a0dde6" translate="yes" xml:space="preserve">
          <source>Asynchronous channels are safe for use by multiple concurrent threads. Some channel implementations may support concurrent reading and writing, but may not allow more than one read and one write operation to be outstanding at any given time.</source>
          <target state="translated">비동기 채널은 여러 개의 동시 스레드에서 안전하게 사용할 수 있습니다. 일부 채널 구현은 동시 읽기 및 쓰기를 지원할 수 있지만 주어진 시간에 하나 이상의 읽기 및 쓰기 작업이 수행되도록 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dba4ef655eef73aea32f4791092fafa5f8e4f5ec" translate="yes" xml:space="preserve">
          <source>Asynchronous socket channels are created in one of two ways. A newly-created &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; is created by invoking one of the &lt;a href=&quot;#open(java.nio.channels.AsynchronousChannelGroup)&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; methods defined by this class. A newly-created channel is open but not yet connected. A connected &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; is created when a connection is made to the socket of an &lt;a href=&quot;asynchronousserversocketchannel&quot;&gt;&lt;code&gt;AsynchronousServerSocketChannel&lt;/code&gt;&lt;/a&gt;. It is not possible to create an asynchronous socket channel for an arbitrary, pre-existing &lt;a href=&quot;../../net/socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비동기 소켓 채널은 두 가지 방법 중 하나로 생성됩니다. 새로 생성 된 &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; 은이 클래스에서 정의한 &lt;a href=&quot;#open(java.nio.channels.AsynchronousChannelGroup)&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 메서드 중 하나를 호출하여 생성됩니다 . 새로 생성 된 채널이 열려 있지만 아직 연결되지 않았습니다. A는 접속 &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; 가 연결가 소켓에의했을 때에 생성 &lt;a href=&quot;asynchronousserversocketchannel&quot;&gt; &lt;code&gt;AsynchronousServerSocketChannel&lt;/code&gt; &lt;/a&gt; . 임의의 기존 &lt;a href=&quot;../../net/socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 대한 비동기 소켓 채널을 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="457ba8593230a1f46060a7b261e3c57edf4f55f3" translate="yes" xml:space="preserve">
          <source>Asynchronous socket channels are created in one of two ways. A newly-created &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; is created by invoking one of the &lt;a href=&quot;asynchronoussocketchannel#open-java.nio.channels.AsynchronousChannelGroup-&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; methods defined by this class. A newly-created channel is open but not yet connected. A connected &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; is created when a connection is made to the socket of an &lt;a href=&quot;asynchronousserversocketchannel&quot;&gt;&lt;code&gt;AsynchronousServerSocketChannel&lt;/code&gt;&lt;/a&gt;. It is not possible to create an asynchronous socket channel for an arbitrary, pre-existing &lt;a href=&quot;../../net/socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비동기 소켓 채널은 두 가지 방법 중 하나로 생성됩니다. 새로 작성된 &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; 은이 클래스에 의해 정의 된 &lt;a href=&quot;asynchronoussocketchannel#open-java.nio.channels.AsynchronousChannelGroup-&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 호출하여 작성됩니다 . 새로 만든 채널이 열려 있지만 아직 연결되지 않았습니다. A는 접속 &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; 가 연결가 소켓에의했을 때에 생성 &lt;a href=&quot;asynchronousserversocketchannel&quot;&gt; &lt;code&gt;AsynchronousServerSocketChannel&lt;/code&gt; &lt;/a&gt; . 임의의 기존 &lt;a href=&quot;../../net/socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 대한 비동기 소켓 채널을 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="22d1e165da18a2de45d488ef5c26e97f609c9064" translate="yes" xml:space="preserve">
          <source>AsynchronousByteChannel</source>
          <target state="translated">AsynchronousByteChannel</target>
        </trans-unit>
        <trans-unit id="38c2395242933dc76544daf5402d38cadc614d41" translate="yes" xml:space="preserve">
          <source>AsynchronousByteChannel.read()</source>
          <target state="translated">AsynchronousByteChannel.read()</target>
        </trans-unit>
        <trans-unit id="b148fb2a4231546109f0b653e76c4eeb809c429d" translate="yes" xml:space="preserve">
          <source>AsynchronousByteChannel.write()</source>
          <target state="translated">AsynchronousByteChannel.write()</target>
        </trans-unit>
        <trans-unit id="1bd5d4e7a7b5727a599dc116eaef1a6e3cf085b8" translate="yes" xml:space="preserve">
          <source>AsynchronousChannel</source>
          <target state="translated">AsynchronousChannel</target>
        </trans-unit>
        <trans-unit id="e6375b79b014e9e2bcc2fba4a81fc8429f4d2aad" translate="yes" xml:space="preserve">
          <source>AsynchronousChannel.close()</source>
          <target state="translated">AsynchronousChannel.close()</target>
        </trans-unit>
        <trans-unit id="084d7863268b49ee5d503756306daef2b2bb8d92" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup</source>
          <target state="translated">AsynchronousChannelGroup</target>
        </trans-unit>
        <trans-unit id="231457371c8ee568e4c4e461d506ae5ab111f8f0" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.awaitTermination()</source>
          <target state="translated">AsynchronousChannelGroup.awaitTermination()</target>
        </trans-unit>
        <trans-unit id="a77c1a9ec94c64cbd1f0942cd08b9ef2e90cc331" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.isShutdown()</source>
          <target state="translated">AsynchronousChannelGroup.isShutdown()</target>
        </trans-unit>
        <trans-unit id="05cddf221adabd93fd23ab51dcdafb5c40632f65" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.isTerminated()</source>
          <target state="translated">AsynchronousChannelGroup.isTerminated()</target>
        </trans-unit>
        <trans-unit id="365dd258e4339ad5b62ae65934f91d75a70b2530" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.provider()</source>
          <target state="translated">AsynchronousChannelGroup.provider()</target>
        </trans-unit>
        <trans-unit id="0d4cd7dcfebb616b24af5609c185d78b8cef5cca" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.shutdown()</source>
          <target state="translated">AsynchronousChannelGroup.shutdown()</target>
        </trans-unit>
        <trans-unit id="b9b902a93fc9e218993b0bd1abff5f1e60bd542f" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.shutdownNow()</source>
          <target state="translated">AsynchronousChannelGroup.shutdownNow()</target>
        </trans-unit>
        <trans-unit id="805a9f69a66b72c7f2d89bcfd6fed3d149c4eb92" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.withCachedThreadPool()</source>
          <target state="translated">AsynchronousChannelGroup.withCachedThreadPool()</target>
        </trans-unit>
        <trans-unit id="f0a8f823754034c375b249ef64e58c70a6eff6ab" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.withFixedThreadPool()</source>
          <target state="translated">AsynchronousChannelGroup.withFixedThreadPool()</target>
        </trans-unit>
        <trans-unit id="d4a60b6c164c7058c4effeebfdab80a84863dfa9" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelGroup.withThreadPool()</source>
          <target state="translated">AsynchronousChannelGroup.withThreadPool()</target>
        </trans-unit>
        <trans-unit id="e9306537f6a48ba0687fbac1e30e1b8afbf86a80" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelProvider</source>
          <target state="translated">AsynchronousChannelProvider</target>
        </trans-unit>
        <trans-unit id="dd41bacfc4bd784351a40b5fb3ec70794f07f505" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelProvider.openAsynchronousChannelGroup()</source>
          <target state="translated">AsynchronousChannelProvider.openAsynchronousChannelGroup()</target>
        </trans-unit>
        <trans-unit id="a3721826030acbac1d2b5ee44f47c017f8701c4d" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelProvider.openAsynchronousServerSocketChannel()</source>
          <target state="translated">AsynchronousChannelProvider.openAsynchronousServerSocketChannel()</target>
        </trans-unit>
        <trans-unit id="715363556807fd9142f1ffb683d6e4e6ca9a4a9d" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelProvider.openAsynchronousSocketChannel()</source>
          <target state="translated">AsynchronousChannelProvider.openAsynchronousSocketChannel()</target>
        </trans-unit>
        <trans-unit id="cb5ad6a32bf86cd395602adfe70345f6309e11e6" translate="yes" xml:space="preserve">
          <source>AsynchronousChannelProvider.provider()</source>
          <target state="translated">AsynchronousChannelProvider.provider()</target>
        </trans-unit>
        <trans-unit id="3f3c71d4577b9db0b73c9695596807edfccdf151" translate="yes" xml:space="preserve">
          <source>AsynchronousCloseException</source>
          <target state="translated">AsynchronousCloseException</target>
        </trans-unit>
        <trans-unit id="e6d7c57566eea09f975ec578b281effa9e828e0b" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel</source>
          <target state="translated">AsynchronousFileChannel</target>
        </trans-unit>
        <trans-unit id="b636326faba51f4d5aa1ff77b840a325b24577f7" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.force()</source>
          <target state="translated">AsynchronousFileChannel.force()</target>
        </trans-unit>
        <trans-unit id="79d01c62175cf4d3400781f64a6280ad3320b764" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.lock()</source>
          <target state="translated">AsynchronousFileChannel.lock()</target>
        </trans-unit>
        <trans-unit id="dc4185f231833e1f9286a64cd8bac776ab0bd0b2" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.open()</source>
          <target state="translated">AsynchronousFileChannel.open()</target>
        </trans-unit>
        <trans-unit id="95f0a39c98fe341f738d5e97a2d24efde3c09a7f" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.read()</source>
          <target state="translated">AsynchronousFileChannel.read()</target>
        </trans-unit>
        <trans-unit id="342cf21e6b57aba468c4406bdbc68d5ae84456a9" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.size()</source>
          <target state="translated">AsynchronousFileChannel.size()</target>
        </trans-unit>
        <trans-unit id="f2a0e94a307aed84704ca7719e2217d35094b899" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.truncate()</source>
          <target state="translated">AsynchronousFileChannel.truncate()</target>
        </trans-unit>
        <trans-unit id="0461b432fcad0bfcbfbede6659d4cac01aeff352" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.tryLock()</source>
          <target state="translated">AsynchronousFileChannel.tryLock()</target>
        </trans-unit>
        <trans-unit id="0d9d3c124561902d2ed067194dcabc13bef9e32f" translate="yes" xml:space="preserve">
          <source>AsynchronousFileChannel.write()</source>
          <target state="translated">AsynchronousFileChannel.write()</target>
        </trans-unit>
        <trans-unit id="9820a668ac36c047c8fc3c88beddfe1c6e4de467" translate="yes" xml:space="preserve">
          <source>AsynchronousServerSocketChannel</source>
          <target state="translated">AsynchronousServerSocketChannel</target>
        </trans-unit>
        <trans-unit id="0ed948c40f5ab1a65902b9c351b7d64330a6d683" translate="yes" xml:space="preserve">
          <source>AsynchronousServerSocketChannel.accept()</source>
          <target state="translated">AsynchronousServerSocketChannel.accept()</target>
        </trans-unit>
        <trans-unit id="67dd37dc020e003689e2634e4b72160bbf95ced1" translate="yes" xml:space="preserve">
          <source>AsynchronousServerSocketChannel.bind()</source>
          <target state="translated">AsynchronousServerSocketChannel.bind()</target>
        </trans-unit>
        <trans-unit id="68004c87af8f2afaf52e389020a56f05a52ebf70" translate="yes" xml:space="preserve">
          <source>AsynchronousServerSocketChannel.getLocalAddress()</source>
          <target state="translated">AsynchronousServerSocketChannel.getLocalAddress()</target>
        </trans-unit>
        <trans-unit id="3b3385acd971fa6f7af8b73432f320981e5e284f" translate="yes" xml:space="preserve">
          <source>AsynchronousServerSocketChannel.open()</source>
          <target state="translated">AsynchronousServerSocketChannel.open()</target>
        </trans-unit>
        <trans-unit id="af0a97236c952e07d89e6b35f23772e47e78d3d1" translate="yes" xml:space="preserve">
          <source>AsynchronousServerSocketChannel.provider()</source>
          <target state="translated">AsynchronousServerSocketChannel.provider()</target>
        </trans-unit>
        <trans-unit id="dc5b9061787eed9e8b249943e56933361c70b652" translate="yes" xml:space="preserve">
          <source>AsynchronousServerSocketChannel.setOption()</source>
          <target state="translated">AsynchronousServerSocketChannel.setOption()</target>
        </trans-unit>
        <trans-unit id="19b0bc9ffd74de23112a7825d4a92c38f4496b27" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel</source>
          <target state="translated">AsynchronousSocketChannel</target>
        </trans-unit>
        <trans-unit id="3c556485faa9f0b602270568e0e88aca6b61adc9" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.bind()</source>
          <target state="translated">AsynchronousSocketChannel.bind()</target>
        </trans-unit>
        <trans-unit id="5f04352e3263607eddb106f05894f657afad77c0" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.connect()</source>
          <target state="translated">AsynchronousSocketChannel.connect()</target>
        </trans-unit>
        <trans-unit id="eb17533b1c6dd367f748fd2a1f7831055f30fe4a" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.getLocalAddress()</source>
          <target state="translated">AsynchronousSocketChannel.getLocalAddress()</target>
        </trans-unit>
        <trans-unit id="e8e962516d0a1cf476846ed81f049bb0c89c3b65" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.getRemoteAddress()</source>
          <target state="translated">AsynchronousSocketChannel.getRemoteAddress()</target>
        </trans-unit>
        <trans-unit id="97fc71267041d6d1805e0d4c5a6e7cf1ffec2be7" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.open()</source>
          <target state="translated">AsynchronousSocketChannel.open()</target>
        </trans-unit>
        <trans-unit id="61198a34e6791c0c83be05300c899f29bf7941d8" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.provider()</source>
          <target state="translated">AsynchronousSocketChannel.provider()</target>
        </trans-unit>
        <trans-unit id="91fbfaae6f623af2474b8fd90cdd598c1ec2b519" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.read()</source>
          <target state="translated">AsynchronousSocketChannel.read()</target>
        </trans-unit>
        <trans-unit id="77daa2795de913d31bfa2670f9bfbcffcdee30dd" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.setOption()</source>
          <target state="translated">AsynchronousSocketChannel.setOption()</target>
        </trans-unit>
        <trans-unit id="6b53b99270afbb64ff8312cbace8118ec6baf2e7" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.shutdownInput()</source>
          <target state="translated">AsynchronousSocketChannel.shutdownInput()</target>
        </trans-unit>
        <trans-unit id="f9f90e06b9d36df23262bd662f1af5fdcac6386c" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.shutdownOutput()</source>
          <target state="translated">AsynchronousSocketChannel.shutdownOutput()</target>
        </trans-unit>
        <trans-unit id="82429badd61ae52d398401a5ecf2597dfa6ab69b" translate="yes" xml:space="preserve">
          <source>AsynchronousSocketChannel.write()</source>
          <target state="translated">AsynchronousSocketChannel.write()</target>
        </trans-unit>
        <trans-unit id="465f4db403e45e6fb27fbb5afc0eff730f096b16" translate="yes" xml:space="preserve">
          <source>At a high level, the &lt;code&gt;SSLEngine&lt;/code&gt; appears thus:</source>
          <target state="translated">높은 수준에서 &lt;code&gt;SSLEngine&lt;/code&gt; 은 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="794013949b2e9be3a6704050c29247d164b4c468" translate="yes" xml:space="preserve">
          <source>At a minimum, a &lt;code&gt;CertPathBuilderResult&lt;/code&gt; contains the &lt;code&gt;CertPath&lt;/code&gt; built by the &lt;code&gt;CertPathBuilder&lt;/code&gt; instance. Implementations of this interface may add methods to return implementation or algorithm specific information, such as debugging information or certification path validation results.</source>
          <target state="translated">최소한 &lt;code&gt;CertPathBuilderResult&lt;/code&gt; 에는 &lt;code&gt;CertPathBuilder&lt;/code&gt; 인스턴스에 의해 &lt;code&gt;CertPath&lt;/code&gt; CertPath 가 포함 됩니다. 이 인터페이스의 구현은 디버깅 정보 또는 인증 경로 유효성 검사 결과와 같은 구현 또는 알고리즘 특정 정보를 반환하는 메소드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c14d1fb0dfd837b3606459f2cdf9e075d76d515f" translate="yes" xml:space="preserve">
          <source>At a minimum, a &lt;code&gt;KeySelectorResult&lt;/code&gt; contains the &lt;code&gt;Key&lt;/code&gt; selected by the &lt;code&gt;KeySelector&lt;/code&gt;. Implementations of this interface may add methods to return implementation or algorithm specific information, such as a chain of certificates or debugging information.</source>
          <target state="translated">최소에서, &lt;code&gt;KeySelectorResult&lt;/code&gt; 는 포함 &lt;code&gt;Key&lt;/code&gt; 에 의해 선택 &lt;code&gt;KeySelector&lt;/code&gt; 에를 . 이 인터페이스의 구현은 인증서 체인이나 디버깅 정보와 같은 구현 또는 알고리즘 특정 정보를 반환하는 메서드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eba00f0f49e209660b101ab4a8b4cde9d34f2d5b" translate="yes" xml:space="preserve">
          <source>At a minimum, an implementation must support the conversions defined in Appendix B, Table B-3 and conversion of appropriate user defined SQL types to a Java type which implements &lt;code&gt;SQLData&lt;/code&gt;, or &lt;code&gt;Struct&lt;/code&gt;. Additional conversions may be supported and are vendor defined.</source>
          <target state="translated">구현은 최소한 부록 B, 표 B-3에 정의 된 변환 및 적절한 사용자 정의 SQL 유형을 &lt;code&gt;SQLData&lt;/code&gt; 또는 &lt;code&gt;Struct&lt;/code&gt; 를 구현하는 Java 유형으로 변환을 지원해야합니다 . 추가 변환이 지원 될 수 있으며 공급 업체가 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4dfd6e82723313e84d6ed27df9dba368ec23871d" translate="yes" xml:space="preserve">
          <source>At a minimum, the packer must set progress to 0 at the beginning of a packing operation, and to 100 at the end.</source>
          <target state="translated">포장업자는 최소한 포장 작업을 시작할 때 진행률을 0으로 설정하고 마지막에 100으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2b58a91a0f68a04cd8a32264f3939092e0cae52" translate="yes" xml:space="preserve">
          <source>At a minimum, the reference synchronization provider allowing RowSet content data to be stored using a JDBC driver should be possible.</source>
          <target state="translated">최소한 JDBC 드라이버를 사용하여 RowSet 콘텐츠 데이터를 저장할 수있는 참조 동기화 공급자가 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="6127688af7da3c07200f3074a005cb92ef0e32b7" translate="yes" xml:space="preserve">
          <source>At a minimum, the unpacker must set progress to 0 at the beginning of a packing operation, and to 100 at the end.</source>
          <target state="translated">언 패커는 최소한 포장 작업을 시작할 때 진행 상태를 0으로, 끝을 100으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="645108c71f0b81d71ecd1afb1f6097888864cddc" translate="yes" xml:space="preserve">
          <source>At a minimum, the unpacker must set progress to 0 at the beginning of an unpacking operation, and to 100 at the end.</source>
          <target state="translated">최소한 언 패커는 언 패킹 작업을 시작할 때 진행률을 0으로 설정하고 마지막에 100으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="63be36e4ae951bd0802c80122e005323536e4bea" translate="yes" xml:space="preserve">
          <source>At compile time only, the compilation module path. This path contains module definitions in source form.</source>
          <target state="translated">컴파일 시간에만 컴파일 모듈 경로입니다. 이 경로에는 소스 형식의 모듈 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a771eb4fbd3c832a048e2ed055cc05054c41cd58" translate="yes" xml:space="preserve">
          <source>At construction time, a component's orientation is set to &lt;code&gt;ComponentOrientation.UNKNOWN&lt;/code&gt;, indicating that it has not been specified explicitly. The UNKNOWN orientation behaves the same as &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt;.</source>
          <target state="translated">구성시 구성 요소의 방향은 &lt;code&gt;ComponentOrientation.UNKNOWN&lt;/code&gt; 으로 설정 되어 명시 적으로 지정되지 않았 음을 나타냅니다. UNKNOWN 방향은 &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3ed0e1e331e4292339cbcbf2794ef1833d84c286" translate="yes" xml:space="preserve">
          <source>At higher levels of synchronization, referred to as pessimistic concurrency, the writer take steps to avoid conflicts by setting locks. Setting locks can vary from setting a lock on a single row to setting a lock on a table or the entire data source. The level of synchronization is therefore a tradeoff between the ability of users to access the data source concurrently and the ability of the writer to keep the data in the &lt;code&gt;RowSet&lt;/code&gt; object and its data source synchronized.</source>
          <target state="translated">비관적 동시성이라고하는 더 높은 수준의 동기화에서 작성자는 잠금을 설정하여 충돌을 방지하는 조치를 취합니다. 잠금 설정은 단일 행에 대한 잠금 설정에서 테이블 또는 전체 데이터 소스에 대한 잠금 설정까지 다양 할 수 있습니다. 따라서 동기화 수준은 사용자가 데이터 소스에 동시에 액세스 할 수있는 기능과 작성자가 &lt;code&gt;RowSet&lt;/code&gt; 개체 및 해당 데이터 소스의 데이터를 동기화 상태로 유지하는 기능 사이의 균형 입니다.</target>
        </trans-unit>
        <trans-unit id="30ae6f8341e10c25d9dd4bff94d65f2135d69854" translate="yes" xml:space="preserve">
          <source>At least one input tray is empty.</source>
          <target state="translated">하나 이상의 입력 용지함이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9afe38b66a597bfb1e738aa766522915020ff5" translate="yes" xml:space="preserve">
          <source>At least one input tray is low on media.</source>
          <target state="translated">하나 이상의 입력 용지함에 용지가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="c8a8538b2910f365fc7f32a8dd7479b3e52a8386" translate="yes" xml:space="preserve">
          <source>At least one of publicId and systemId must be non-null. If a system identifier is present, and it is a URL, the SAX parser must resolve it fully before passing it to the application through this event.</source>
          <target state="translated">publicId 및 systemId 중 하나 이상은 널이 아니어야합니다. 시스템 식별자가 있고 URL 인 경우 SAX 파서는이 이벤트를 통해 응용 프로그램에 전달하기 전에이를 완전히 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="b26835d9f8e8575c4f50c02cac9482274d53f272" translate="yes" xml:space="preserve">
          <source>At least one of the resources needed by the job, such as media, fonts, resource objects, etc., is not ready on any of the physical printers for which the job is a candidate.</source>
          <target state="translated">미디어, 글꼴, 리소스 개체 등과 같이 작업에 필요한 리소스 중 하나 이상이 작업이 후보 인 물리적 프린터에서 준비되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7cbc6cf1fc5c19a66339259df4a399d1bc7a2615" translate="yes" xml:space="preserve">
          <source>At least one of the resources needed by the job, such as media, fonts, resource objects, etc., is not ready on any of the physical printers for which the job is a candidate. This condition may be detected when the job is accepted, or subsequently while the job is pending or processing, depending on implementation. The job may remain in its current state or be moved to the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, depending on implementation and/or job scheduling policy.</source>
          <target state="translated">미디어, 글꼴, 리소스 개체 등과 같이 작업에 필요한 리소스 중 하나 이상이 작업이 후보 인 물리적 프린터에서 준비되지 않았습니다. 이 조건은 구현에 따라 작업이 수락 될 때 또는 작업이 보류 중이거나 처리 중일 때 감지 될 수 있습니다. 작업은 구현 및 / 또는 작업 예약 정책에 따라 현재 상태를 유지하거나 &lt;code&gt;PENDING_HELD&lt;/code&gt; 상태 로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c72aae14b0592984195a6d333c85aec5e1dad21" translate="yes" xml:space="preserve">
          <source>At least one of the resources needed by the job, such as media, fonts, resource objects, etc., is not ready on any of the physical printers for which the job is a candidate. This condition may be detected when the job is accepted, or subsequently while the job is pending or processing, depending on implementation. The job may remain in its current state or be moved to the PENDING_HELD state, depending on implementation and/or job scheduling policy.</source>
          <target state="translated">미디어, 글꼴, 리소스 개체 등과 같이 작업에 필요한 리소스 중 하나 이상이 작업이 후보 인 실제 프린터에서 준비되지 않았습니다. 이 조건은 작업이 승인 될 때 ​​또는 구현에 따라 작업이 보류 중이거나 처리중인 동안 감지 될 수 있습니다. 구현 및 / 또는 작업 예약 정책에 따라 작업이 현재 상태로 유지되거나 PENDING_HELD 상태로 이동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8be2c174b716c3f30c1cf6769ccf4211404f05c" translate="yes" xml:space="preserve">
          <source>At most one element of a key property list may be an asterisk. If the key property list contains an asterisk element, the ObjectName is a property list pattern.</source>
          <target state="translated">키 속성 목록의 최대 하나의 요소는 별표 일 수 있습니다. 키 특성 목록에 별표 요소가 포함 된 경우 ObjectName은 특성 목록 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="423d1c1a2e18be9db61446923b1d66e7729bc946" translate="yes" xml:space="preserve">
          <source>At most, one &lt;code&gt;ChangeEvent&lt;/code&gt; is generated.</source>
          <target state="translated">최대 하나의 &lt;code&gt;ChangeEvent&lt;/code&gt; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1fa0958a89112583d2766f438b0a0b5d86c398e4" translate="yes" xml:space="preserve">
          <source>At run-time, resolution is an additive process. The recursive enumeration at step 1 may be relative to previous resolutions so that a root module, or a module named in a 'requires' directive, is not enumerated when it was enumerated by a previous (or parent) resolution. The readability graph that is the result of resolution may therefore have a vertex for a module enumerated in step 1 but with an edge to represent that the module reads a module that was enumerated by previous (or parent) resolution.</source>
          <target state="translated">런타임에서 해결은 추가 프로세스입니다. 1 단계의 재귀 열거는 이전 해결 방법에 상대적 일 수 있으므로 루트 모듈 또는 'requires'지시문에 명명 된 모듈이 이전 (또는 부모) 해결에 의해 열거 될 때 열거되지 않습니다. 따라서 분해능의 결과 인 가독성 그래프에는 1 단계에서 열거 된 모듈에 대한 정점이있을 수 있지만 모듈이 이전 (또는 상위) 분해능에 의해 열거 된 모듈을 읽음을 나타내는 에지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd789fed137eead45a5ddb2c0e3ccd440ce67d7d" translate="yes" xml:space="preserve">
          <source>At runtime, the conversions applied to reference arguments or return values may require additional runtime checks which can fail. An unboxing operation may fail because the original reference is null, causing a &lt;a href=&quot;../nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;. An unboxing operation or a reference cast may also fail on a reference to an object of the wrong type, causing a &lt;a href=&quot;../classcastexception&quot;&gt;&lt;code&gt;ClassCastException&lt;/code&gt;&lt;/a&gt;. Although an unboxing operation may accept several kinds of wrappers, if none are available, a &lt;code&gt;ClassCastException&lt;/code&gt; will be thrown.</source>
          <target state="translated">런타임시 참조 인수 또는 반환 값에 적용되는 변환에는 실패 할 수있는 추가 런타임 검사가 필요할 수 있습니다. 원래 참조가 null이므로 unboxing 작업이 실패하여 &lt;a href=&quot;../nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다. unboxing 작업 또는 참조 캐스트가 잘못된 유형의 객체에 대한 참조에서 실패하여 &lt;a href=&quot;../classcastexception&quot;&gt; &lt;code&gt;ClassCastException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다. 언 박싱 조작이 여러 종류의 랩퍼를 허용 할 수 있지만, 사용 가능한 것이 없으면 &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7a449671467bacfacb5cfdc12566e9fd22b5292" translate="yes" xml:space="preserve">
          <source>At startup the LogManager class is located using the java.util.logging.manager system property.</source>
          <target state="translated">시작시 LogManager 클래스는 java.util.logging.manager 시스템 특성을 사용하여 찾습니다.</target>
        </trans-unit>
        <trans-unit id="fa55d3ccaf0916f3d61d036166352b2dc4d894ce" translate="yes" xml:space="preserve">
          <source>At the appropriate time, the &lt;code&gt;ComponentUI&lt;/code&gt; is responsible for obtaining an &lt;code&gt;Action&lt;/code&gt; out of the &lt;code&gt;ActionMap&lt;/code&gt; and passing it to &lt;code&gt;playSound&lt;/code&gt;.</source>
          <target state="translated">적절한 시간에 상기 &lt;code&gt;ComponentUI&lt;/code&gt; 하는 취득을 담당 &lt;code&gt;Action&lt;/code&gt; 의 밖으로 &lt;code&gt;ActionMap&lt;/code&gt; 및에 전달 &lt;code&gt;playSound&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b16b3bfb5eec392e43915c41e26621e482cfcb55" translate="yes" xml:space="preserve">
          <source>At the completion of a drop, an implementation of this method is required to signal the success/failure of the drop by passing an appropriate &lt;code&gt;boolean&lt;/code&gt; to the &lt;code&gt;DropTargetDropEvent&lt;/code&gt;'s dropComplete(boolean success) method.</source>
          <target state="translated">드롭이 완료되면 &lt;code&gt;DropTargetDropEvent&lt;/code&gt; 의 dropComplete (boolean success) 메서드에 적절한 &lt;code&gt;boolean&lt;/code&gt; 을 전달하여 드롭의 성공 / 실패를 알리기 위해이 메서드의 구현이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="42a58db636916fb28b556e9abf682674c0617349" translate="yes" xml:space="preserve">
          <source>At the discretion of the host system, any module whose name is given by a 'requires' directive without the 'transitive' modifier is not observable.</source>
          <target state="translated">호스트 시스템의 재량에 따라 'transitive'수정 자없이 'requires'지시문에 의해 이름이 지정된 모듈은 관찰 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="baddd2b1e84cbc7e6d86e3a6b6beaac2e18f08c9" translate="yes" xml:space="preserve">
          <source>At the end of a communication session, applications should properly close the SSL/TLS link. The SSL/TLS protocols have closure handshake messages, and these messages should be communicated to the peer before releasing the &lt;code&gt;SSLEngine&lt;/code&gt; and closing the underlying transport mechanism. A close can be initiated by one of: an SSLException, an inbound closure handshake message, or one of the close methods. In all cases, closure handshake messages are generated by the engine, and &lt;code&gt;wrap()&lt;/code&gt; should be repeatedly called until the resulting &lt;code&gt;SSLEngineResult&lt;/code&gt;'s status returns &quot;CLOSED&quot;, or &lt;a href=&quot;sslengine#isOutboundDone--&quot;&gt;&lt;code&gt;isOutboundDone()&lt;/code&gt;&lt;/a&gt; returns true. All data obtained from the &lt;code&gt;wrap()&lt;/code&gt; method should be sent to the peer.</source>
          <target state="translated">통신 세션이 끝나면 응용 프로그램이 SSL / TLS 링크를 올바르게 닫아야합니다. SSL / TLS 프로토콜에는 클로저 핸드 셰이크 메시지가 있으며 이러한 메시지는 &lt;code&gt;SSLEngine&lt;/code&gt; 을 해제 하고 기본 전송 메커니즘을 닫기 전에 피어와 통신해야합니다 . 닫기는 SSLException, 인바운드 클로저 핸드 셰이크 메시지 또는 닫기 메소드 중 하나에 의해 시작될 수 있습니다. 모든 경우에 엔진에서 클로저 핸드 셰이크 메시지가 생성되며 결과 &lt;code&gt;SSLEngineResult&lt;/code&gt; 상태가 &quot;CLOSED&quot;를 반환하거나 &lt;a href=&quot;sslengine#isOutboundDone--&quot;&gt; &lt;code&gt;isOutboundDone()&lt;/code&gt; &lt;/a&gt; 이 true를 반환 할 때까지 &lt;code&gt;wrap()&lt;/code&gt; 을 반복적으로 호출해야 합니다. &lt;code&gt;wrap()&lt;/code&gt; 메소드 에서 얻은 모든 데이터 는 피어로 전송되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c07378b79d0b225fa49e36f165164e1e059f1740" translate="yes" xml:space="preserve">
          <source>At the end of a communication session, applications should properly close the SSL/TLS/DTLS link. The SSL/TLS/DTLS protocols have closure handshake messages, and these messages should be communicated to the peer before releasing the &lt;code&gt;SSLEngine&lt;/code&gt; and closing the underlying transport mechanism. A close can be initiated by one of: an SSLException, an inbound closure handshake message, or one of the close methods. In all cases, closure handshake messages are generated by the engine, and &lt;code&gt;wrap()&lt;/code&gt; should be repeatedly called until the resulting &lt;code&gt;SSLEngineResult&lt;/code&gt;'s status returns &quot;CLOSED&quot;, or &lt;a href=&quot;#isOutboundDone()&quot;&gt;&lt;code&gt;isOutboundDone()&lt;/code&gt;&lt;/a&gt; returns true. All data obtained from the &lt;code&gt;wrap()&lt;/code&gt; method should be sent to the peer.</source>
          <target state="translated">통신 세션이 끝나면 응용 프로그램은 SSL / TLS / DTLS 링크를 올바르게 닫아야합니다. SSL / TLS / DTLS 프로토콜에는 클로저 핸드 셰이크 메시지가 있으며 이러한 메시지는 &lt;code&gt;SSLEngine&lt;/code&gt; 을 해제 하고 기본 전송 메커니즘을 닫기 전에 피어와 통신해야합니다 . 닫기는 SSLException, 인바운드 닫기 핸드 셰이크 메시지 또는 닫기 메소드 중 하나에 의해 시작될 수 있습니다. 모든 경우에 클로저 핸드 셰이크 메시지는 엔진에 의해 생성되며 결과 &lt;code&gt;SSLEngineResult&lt;/code&gt; 의 상태가 &quot;CLOSED&quot;를 반환하거나 &lt;a href=&quot;#isOutboundDone()&quot;&gt; &lt;code&gt;isOutboundDone()&lt;/code&gt; &lt;/a&gt; 이 true를 반환 할 때까지 &lt;code&gt;wrap()&lt;/code&gt; 을 반복적으로 호출해야 합니다. &lt;code&gt;wrap()&lt;/code&gt; 메서드 에서 얻은 모든 데이터 는 피어로 전송되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3600dcf739c85535bbcb604c9f198e1e39fbed63" translate="yes" xml:space="preserve">
          <source>At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string form has the syntax</source>
          <target state="translated">최상위 레벨에서 문자열 형식의 URI 참조 (이하 &quot;URI&quot;)는 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="28570dcb242153dba2d2536d7970503bd9dd5d4d" translate="yes" xml:space="preserve">
          <source>At the simplest level, text can be modeled as a linear sequence of characters. To support internationalization, the Swing text model uses &lt;a href=&quot;http://www.unicode.org/&quot;&gt;unicode&lt;/a&gt; characters. The sequence of characters displayed in a text component is generally referred to as the component's &lt;em&gt;content&lt;/em&gt;.</source>
          <target state="translated">가장 단순한 수준에서 텍스트는 문자의 선형 시퀀스로 모델링 할 수 있습니다. 국제화를 지원하기 위해 Swing 텍스트 모델은 &lt;a href=&quot;http://www.unicode.org/&quot;&gt;유니 코드&lt;/a&gt; 문자를 사용 합니다. 텍스트 구성 요소에 표시되는 문자 시퀀스를 일반적으로 구성 요소의 &lt;em&gt;내용&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="289f8b71d95a92b9ac8ae580447e077588d5231a" translate="yes" xml:space="preserve">
          <source>At the time any of the filter methods are called by the parser, the owner Document and DOMImplementation objects exist and are accessible. The document element is never passed to the &lt;code&gt;LSParserFilter&lt;/code&gt; methods, i.e. it is not possible to filter out the document element. &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentType&lt;/code&gt;, &lt;code&gt;Notation&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt;, and &lt;code&gt;Attr&lt;/code&gt; nodes are never passed to the &lt;code&gt;acceptNode&lt;/code&gt; method on the filter. The child nodes of an &lt;code&gt;EntityReference&lt;/code&gt; node are passed to the filter if the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;false&lt;/code&gt;. Note that, as described by the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot;, unexpanded entity reference nodes are never discarded and are always passed to the filter.</source>
          <target state="translated">파서가 필터 메서드를 호출 할 때 소유자 Document 및 DOMImplementation 개체가 존재하고 액세스 할 수 있습니다. 문서 요소는 &lt;code&gt;LSParserFilter&lt;/code&gt; 메소드로 전달 되지 않습니다. 즉, 문서 요소를 필터링 할 수 없습니다. &lt;code&gt;Document&lt;/code&gt; , &lt;code&gt;DocumentType&lt;/code&gt; , &lt;code&gt;Notation&lt;/code&gt; , &lt;code&gt;Entity&lt;/code&gt; 및 &lt;code&gt;Attr&lt;/code&gt; 노드는 필터 의 &lt;code&gt;acceptNode&lt;/code&gt; 메서드에 전달되지 않습니다 . 매개 변수 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt; &quot;가 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 &lt;code&gt;EntityReference&lt;/code&gt; 노드 의 하위 노드가 필터에 전달됩니다 . 매개 변수 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;엔티티에&lt;/a&gt; 설명 된대로&quot;, 확장되지 않은 엔티티 참조 노드는 삭제되지 않으며 항상 필터에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="732f992a8ac91e6d3c80ad202f2b11658aec5c35" translate="yes" xml:space="preserve">
          <source>At the time of reading or writing, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown by the reader or writer if a value larger than the largest destination band index has been specified, or if the number of source bands and destination bands to be used differ. The &lt;code&gt;ImageReader.checkReadParamBandSettings&lt;/code&gt; method may be used to automate this test.</source>
          <target state="translated">읽거나 쓸 때 가장 큰 대상 밴드 인덱스보다 큰 값이 지정되었거나 사용되는 소스 밴드 및 대상 밴드의 수가 다른 경우 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 판독기 또는 기록기에서 발생합니다. &lt;code&gt;ImageReader.checkReadParamBandSettings&lt;/code&gt; 의 방법은이 테스트를 자동화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c41012a0616676f7d23f9fe0674fd8b3a31f06d5" translate="yes" xml:space="preserve">
          <source>At the time of reading, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown by the reader or writer if a value larger than the largest available source band index has been specified or if the number of source bands and destination bands to be used differ. The &lt;code&gt;ImageReader.checkReadParamBandSettings&lt;/code&gt; method may be used to automate this test.</source>
          <target state="translated">읽을 때 사용 가능한 최대 소스 밴드 인덱스보다 큰 값이 지정되었거나 사용되는 소스 밴드 및 대상 밴드의 수가 다른 경우 리더 또는 기록기 에서 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. &lt;code&gt;ImageReader.checkReadParamBandSettings&lt;/code&gt; 의 방법은이 테스트를 자동화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff746f577b2ef009b70a0d8c13d2aaff8eebfb5" translate="yes" xml:space="preserve">
          <source>At the time of reading, the image is checked to verify that its &lt;code&gt;ColorModel&lt;/code&gt; and &lt;code&gt;SampleModel&lt;/code&gt; correspond to one of the &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;s returned from the &lt;code&gt;ImageReader&lt;/code&gt;'s &lt;code&gt;getImageTypes&lt;/code&gt; method. If it does not, the reader will throw an &lt;code&gt;IIOException&lt;/code&gt;.</source>
          <target state="translated">읽을 때 이미지의 &lt;code&gt;ColorModel&lt;/code&gt; 및 &lt;code&gt;SampleModel&lt;/code&gt; 이 &lt;code&gt;ImageReader&lt;/code&gt; 의 &lt;code&gt;getImageTypes&lt;/code&gt; 메소드 에서 리턴 된 &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; 중 하나에 해당 하는지 확인합니다 . 그렇지 않은 경우 리더는 &lt;code&gt;IIOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="521125ddadcb8ea8987ed2949417122d4a840175" translate="yes" xml:space="preserve">
          <source>At this point,</source>
          <target state="translated">이 지점에서,</target>
        </trans-unit>
        <trans-unit id="a692e529909dbde465dc00470bd9639e9737c2a7" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;getBundle&lt;/code&gt; finds &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;, which is put on hold because it's the base bundle. &lt;code&gt;getBundle&lt;/code&gt; calls &lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;&lt;code&gt;control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)&lt;/code&gt;&lt;/a&gt; which returns &lt;code&gt;Locale.FRENCH&lt;/code&gt;. Next, &lt;code&gt;getBundle&lt;/code&gt; tries loading a bundle in the following sequence.</source>
          <target state="translated">이 시점에서 &lt;code&gt;getBundle&lt;/code&gt; 은 기본 번들이기 때문에 보류 된 &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt; 를 찾습니다 . &lt;code&gt;getBundle&lt;/code&gt; 은 &lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)&lt;/code&gt; &lt;/a&gt; 를 반환 &lt;code&gt;Locale.FRENCH&lt;/code&gt; control.getFallbackLocale ( &quot;foo.bar.Messages&quot;, Locale.ITALY) 를 호출 합니다 . 다음으로 &lt;code&gt;getBundle&lt;/code&gt; 은 다음 순서로 번들로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="04572e2e3855dc7fbb76d1c15cf78b667eda066c" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;getBundle&lt;/code&gt; finds &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;, which is put on hold because it's the base bundle. &lt;code&gt;getBundle&lt;/code&gt; calls &lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)&lt;/code&gt;&lt;/a&gt; which returns &lt;code&gt;Locale.FRENCH&lt;/code&gt;. Next, &lt;code&gt;getBundle&lt;/code&gt; tries loading a bundle in the following sequence.</source>
          <target state="translated">이 시점에서 &lt;code&gt;getBundle&lt;/code&gt; 은 &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt; 를 찾으며 , 이는 기본 번들이므로 보류됩니다. &lt;code&gt;getBundle&lt;/code&gt; 는이 호출 &lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)&lt;/code&gt; &lt;/a&gt; 돌려 &lt;code&gt;Locale.FRENCH&lt;/code&gt; 을 . 다음으로 &lt;code&gt;getBundle&lt;/code&gt; 은 다음 순서로 번들로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4d6de1188ad0f86a8046d61a60a1b9e1df0cbd8b" translate="yes" xml:space="preserve">
          <source>At this point, every init function parameter list is effectively identical to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;, but some lists may be shorter. For every init function with a short parameter list, pad out the end of the list.</source>
          <target state="translated">이 시점에서 모든 초기화 함수 매개 변수 목록은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 과 사실상 동일 하지만 일부 목록은 더 짧을 수 있습니다. 짧은 매개 변수 목록이있는 모든 init 함수에 대해 목록의 끝을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="bfa760755353e81deeab9e166eddec0fc4b880af" translate="yes" xml:space="preserve">
          <source>At this point, every non-init function parameter list is effectively identical to the internal parameter list &lt;code&gt;(V... A...)&lt;/code&gt;, but some lists may be shorter. For every non-init function with a short parameter list, pad out the end of the list.</source>
          <target state="translated">이 시점에서 모든 비 초기화 함수 매개 변수 목록은 내부 매개 변수 목록 &lt;code&gt;(V... A...)&lt;/code&gt; 과 사실상 동일 하지만 일부 목록은 더 짧을 수 있습니다. 짧은 매개 변수 목록이있는 초기화가 아닌 모든 함수에 대해 목록 끝을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="c91c8ec3b3c881d1cf8653c91f7e50fa68768cbe" translate="yes" xml:space="preserve">
          <source>At this point, the command for &lt;code&gt;crs&lt;/code&gt; is the query &lt;code&gt;&quot;SELECT
 FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT &amp;gt; 5000
 AND REGION = &quot;West&quot;&lt;/code&gt;. After the &lt;code&gt;readData&lt;/code&gt; method executes this command with the following line of code, it will have the data from &lt;code&gt;rs&lt;/code&gt; with which to populate &lt;code&gt;crs&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 &lt;code&gt;crs&lt;/code&gt; 에 대한 명령은 &lt;code&gt;&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT &amp;gt; 5000 AND REGION = &quot;West&quot;&lt;/code&gt; 쿼리 입니다. &lt;code&gt;readData&lt;/code&gt; 메소드가 다음 코드 줄을 사용하여이 명령을 실행하면 데이터가 있습니다. &lt;code&gt;crs&lt;/code&gt; 를 채울 &lt;code&gt;rs&lt;/code&gt; 에서 .</target>
        </trans-unit>
        <trans-unit id="e410ecd471472d8a7aa5335a30bed37263709a93" translate="yes" xml:space="preserve">
          <source>At this point, we have found a resource bundle that's not the base bundle. If this bundle set its parent during its instantiation, it is returned to the caller. Otherwise, its &lt;a href=&quot;resourcebundle#parent_chain&quot;&gt;parent chain&lt;/a&gt; is instantiated based on the list of candidate locales from which it was found. Finally, the bundle is returned to the caller.</source>
          <target state="translated">이제 기본 번들이 아닌 리소스 번들을 찾았습니다. 이 번들이 인스턴스화 중에 상위를 설정하면 호출자에게 리턴됩니다. 그렇지 않으면, &lt;a href=&quot;resourcebundle#parent_chain&quot;&gt;상위 체인&lt;/a&gt; 은 발견 된 후보 로케일 목록을 기반으로 인스턴스화됩니다. 마지막으로 번들은 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a247514663abbd4eab3efc5a540d37f131b17503" translate="yes" xml:space="preserve">
          <source>At transaction commit time, the resource managers are informed by the transaction manager to prepare, commit, or rollback a transaction according to the two-phase commit protocol.</source>
          <target state="translated">트랜잭션 커밋시 리소스 관리자는 트랜잭션 관리자가 2 단계 커밋 프로토콜에 따라 트랜잭션을 준비, 커밋 또는 롤백하도록 알립니다.</target>
        </trans-unit>
        <trans-unit id="f3901a778297cd4e3095098dc0b02793244da9ca" translate="yes" xml:space="preserve">
          <source>At uninstallUI() time we reset the property to null if its value is an instance of UIResource:</source>
          <target state="translated">uninstallUI () 시간에 값이 UIResource의 인스턴스 인 경우 속성을 null로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="db46499b6071e169916a6d3ccbed296282f361c8" translate="yes" xml:space="preserve">
          <source>At various points this class specifies that an instance that is &quot;open for reading,&quot; &quot;open for writing,&quot; or &quot;open for reading and writing&quot; is required. A channel obtained via the &lt;a href=&quot;../../io/fileinputstream#getChannel()&quot;&gt;&lt;code&gt;getChannel&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;../../io/fileinputstream&quot;&gt;&lt;code&gt;FileInputStream&lt;/code&gt;&lt;/a&gt; instance will be open for reading. A channel obtained via the &lt;a href=&quot;../../io/fileoutputstream#getChannel()&quot;&gt;&lt;code&gt;getChannel&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;../../io/fileoutputstream&quot;&gt;&lt;code&gt;FileOutputStream&lt;/code&gt;&lt;/a&gt; instance will be open for writing. Finally, a channel obtained via the &lt;a href=&quot;../../io/randomaccessfile#getChannel()&quot;&gt;&lt;code&gt;getChannel&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;../../io/randomaccessfile&quot;&gt;&lt;code&gt;RandomAccessFile&lt;/code&gt;&lt;/a&gt; instance will be open for reading if the instance was created with mode &lt;code&gt;&quot;r&quot;&lt;/code&gt; and will be open for reading and writing if the instance was created with mode &lt;code&gt;&quot;rw&quot;&lt;/code&gt;.</source>
          <target state="translated">여러 지점에서이 클래스는 &quot;읽기 위해 열기&quot;, &quot;쓰기 위해 열기&quot;또는 &quot;읽기 및 쓰기 위해 열기&quot;인스턴스가 필요함을 지정합니다. &lt;a href=&quot;../../io/fileinputstream&quot;&gt; &lt;code&gt;FileInputStream&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;a href=&quot;../../io/fileinputstream#getChannel()&quot;&gt; &lt;code&gt;getChannel&lt;/code&gt; &lt;/a&gt; 메소드를 통해 얻은 채널 은 읽기 위해 열립니다. &lt;a href=&quot;../../io/fileoutputstream&quot;&gt; &lt;code&gt;FileOutputStream&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;a href=&quot;../../io/fileoutputstream#getChannel()&quot;&gt; &lt;code&gt;getChannel&lt;/code&gt; &lt;/a&gt; 메소드를 통해 얻은 채널 은 쓰기를 위해 열립니다. 마지막으로 &lt;a href=&quot;../../io/randomaccessfile&quot;&gt; &lt;code&gt;RandomAccessFile&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;a href=&quot;../../io/randomaccessfile#getChannel()&quot;&gt; &lt;code&gt;getChannel&lt;/code&gt; &lt;/a&gt; 메서드를 통해 얻은 채널 은 인스턴스가 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 모드로 생성 된 경우 읽기를 위해 열리고 인스턴스가 &lt;code&gt;&quot;rw&quot;&lt;/code&gt; 모드로 생성 된 경우 읽기 및 쓰기를 위해 열립니다 .</target>
        </trans-unit>
        <trans-unit id="af9dcb2d2164b28c11a33a8399737216abc72537" translate="yes" xml:space="preserve">
          <source>At various points this class specifies that an instance that is &quot;open for reading,&quot; &quot;open for writing,&quot; or &quot;open for reading and writing&quot; is required. A channel obtained via the &lt;a href=&quot;../../io/fileinputstream#getChannel--&quot;&gt;&lt;code&gt;getChannel&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;../../io/fileinputstream&quot;&gt;&lt;code&gt;FileInputStream&lt;/code&gt;&lt;/a&gt; instance will be open for reading. A channel obtained via the &lt;a href=&quot;../../io/fileoutputstream#getChannel--&quot;&gt;&lt;code&gt;getChannel&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;../../io/fileoutputstream&quot;&gt;&lt;code&gt;FileOutputStream&lt;/code&gt;&lt;/a&gt; instance will be open for writing. Finally, a channel obtained via the &lt;a href=&quot;../../io/randomaccessfile#getChannel--&quot;&gt;&lt;code&gt;getChannel&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;../../io/randomaccessfile&quot;&gt;&lt;code&gt;RandomAccessFile&lt;/code&gt;&lt;/a&gt; instance will be open for reading if the instance was created with mode &lt;code&gt;&quot;r&quot;&lt;/code&gt; and will be open for reading and writing if the instance was created with mode &lt;code&gt;&quot;rw&quot;&lt;/code&gt;.</source>
          <target state="translated">다양한 시점에서이 클래스는 &quot;읽기 위해 열기&quot;, &quot;쓰기 위해 열기&quot;또는 &quot;읽기 및 쓰기 위해 열기&quot;인 인스턴스가 필요함을 지정합니다. &lt;a href=&quot;../../io/fileinputstream&quot;&gt; &lt;code&gt;FileInputStream&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;a href=&quot;../../io/fileinputstream#getChannel--&quot;&gt; &lt;code&gt;getChannel&lt;/code&gt; &lt;/a&gt; 메소드를 통해 얻은 채널 은 읽기 위해 열립니다. &lt;a href=&quot;../../io/fileoutputstream&quot;&gt; &lt;code&gt;FileOutputStream&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;a href=&quot;../../io/fileoutputstream#getChannel--&quot;&gt; &lt;code&gt;getChannel&lt;/code&gt; &lt;/a&gt; 메소드를 통해 얻은 채널 은 쓰기 위해 열립니다. 마지막으로, &lt;a href=&quot;../../io/randomaccessfile&quot;&gt; &lt;code&gt;RandomAccessFile&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;a href=&quot;../../io/randomaccessfile#getChannel--&quot;&gt; &lt;code&gt;getChannel&lt;/code&gt; &lt;/a&gt; 메소드를 통해 얻은 채널 은 인스턴스가 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 모드로 작성된 경우 읽기 위해 열리고 인스턴스가 &lt;code&gt;&quot;rw&quot;&lt;/code&gt; 모드로 작성된 경우 읽기 및 쓰기를 위해 열립니다 .</target>
        </trans-unit>
        <trans-unit id="c3ba21965adef48b4fad4b03fdd1aa1a192eda15" translate="yes" xml:space="preserve">
          <source>Atomic classes are designed primarily as building blocks for implementing non-blocking data structures and related infrastructure classes. The &lt;code&gt;compareAndSet&lt;/code&gt; method is not a general replacement for locking. It applies only when critical updates for an object are confined to a &lt;em&gt;single&lt;/em&gt; variable.</source>
          <target state="translated">원자 클래스는 주로 비 차단 데이터 구조 및 관련 인프라 클래스를 구현하기위한 빌딩 블록으로 설계되었습니다. &lt;code&gt;compareAndSet&lt;/code&gt; 있어서 락의 대체가 아닙니다. 개체에 대한 중요 업데이트가 &lt;em&gt;단일&lt;/em&gt; 변수에 한정된 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2a65302a48d01169c145c0498c4a74f4c4a556c" translate="yes" xml:space="preserve">
          <source>Atomic classes are not general purpose replacements for &lt;code&gt;java.lang.Integer&lt;/code&gt; and related classes. They do &lt;em&gt;not&lt;/em&gt; define methods such as &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt;. (Because atomic variables are expected to be mutated, they are poor choices for hash table keys.) Additionally, classes are provided only for those types that are commonly useful in intended applications. For example, there is no atomic class for representing &lt;code&gt;byte&lt;/code&gt;. In those infrequent cases where you would like to do so, you can use an &lt;code&gt;AtomicInteger&lt;/code&gt; to hold &lt;code&gt;byte&lt;/code&gt; values, and cast appropriately. You can also hold floats using &lt;a href=&quot;../../../lang/float#floatToRawIntBits-float-&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../lang/float#intBitsToFloat-int-&quot;&gt;&lt;code&gt;Float.intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; conversions, and doubles using &lt;a href=&quot;../../../lang/double#doubleToRawLongBits-double-&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../lang/double#longBitsToDouble-long-&quot;&gt;&lt;code&gt;Double.longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; conversions.</source>
          <target state="translated">원자 클래스는 &lt;code&gt;java.lang.Integer&lt;/code&gt; 및 관련 클래스를 대체 할 목적이 아닙니다 . &lt;code&gt;equals&lt;/code&gt; , &lt;code&gt;hashCode&lt;/code&gt; 및 &lt;code&gt;compareTo&lt;/code&gt; 와 같은 메소드 는 정의 하지 &lt;em&gt;않습니다&lt;/em&gt; . 원자 변수는 변경 될 것으로 예상되므로 해시 테이블 키에는 적합하지 않습니다. 또한 클래스는 의도 된 응용 프로그램에 일반적으로 유용한 유형에 대해서만 제공됩니다. 예를 들어, &lt;code&gt;byte&lt;/code&gt; 를 나타내는 원자 클래스는 없습니다 . 자주 원하지 않는 경우 &lt;code&gt;AtomicInteger&lt;/code&gt; 를 사용하여 &lt;code&gt;byte&lt;/code&gt; 값 을 보유 하고 적절하게 캐스트 할 수 있습니다. &lt;a href=&quot;../../../lang/float#floatToRawIntBits-float-&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt; 사용하여 float를 유지할 수도 있습니다.및 &lt;a href=&quot;../../../lang/float#intBitsToFloat-int-&quot;&gt; &lt;code&gt;Float.intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt; 변환하고, 복식 사용하여 &lt;a href=&quot;../../../lang/double#doubleToRawLongBits-double-&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../../../lang/double#longBitsToDouble-long-&quot;&gt; &lt;code&gt;Double.longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt; 변환을.</target>
        </trans-unit>
        <trans-unit id="8ed33adfdb95cc7fd0d5b3fe6ea9bbb8c6df7c8b" translate="yes" xml:space="preserve">
          <source>AtomicBoolean</source>
          <target state="translated">AtomicBoolean</target>
        </trans-unit>
        <trans-unit id="e1a0712ffb4a50bd7ef8cf48cc018df683180a49" translate="yes" xml:space="preserve">
          <source>AtomicBoolean.compareAndSet()</source>
          <target state="translated">AtomicBoolean.compareAndSet()</target>
        </trans-unit>
        <trans-unit id="21054de6a44e6381682876a4063a9f8aca016d4b" translate="yes" xml:space="preserve">
          <source>AtomicBoolean.get()</source>
          <target state="translated">AtomicBoolean.get()</target>
        </trans-unit>
        <trans-unit id="232343d81c881d60cc5fa50b236596969d6732d3" translate="yes" xml:space="preserve">
          <source>AtomicBoolean.getAndSet()</source>
          <target state="translated">AtomicBoolean.getAndSet()</target>
        </trans-unit>
        <trans-unit id="c0fdd2ef1750c2490d128f44a0a50b3347a65f60" translate="yes" xml:space="preserve">
          <source>AtomicBoolean.lazySet()</source>
          <target state="translated">AtomicBoolean.lazySet()</target>
        </trans-unit>
        <trans-unit id="23dc3d9a1a1b2d49fef1a8182a62abce0bcdf52b" translate="yes" xml:space="preserve">
          <source>AtomicBoolean.set()</source>
          <target state="translated">AtomicBoolean.set()</target>
        </trans-unit>
        <trans-unit id="ac099f49dfe262eb4c378f3c7de061ead4f52869" translate="yes" xml:space="preserve">
          <source>AtomicBoolean.toString()</source>
          <target state="translated">AtomicBoolean.toString()</target>
        </trans-unit>
        <trans-unit id="c1a4be4d11a98201a57b910a8db823f16b43e18d" translate="yes" xml:space="preserve">
          <source>AtomicBoolean.weakCompareAndSet()</source>
          <target state="translated">AtomicBoolean.weakCompareAndSet()</target>
        </trans-unit>
        <trans-unit id="031c2d24a8a8b5aac829ffde38e403ce10db3dd2" translate="yes" xml:space="preserve">
          <source>AtomicInteger</source>
          <target state="translated">AtomicInteger</target>
        </trans-unit>
        <trans-unit id="33e44f3d88e36fc1bcab3da80f8c45ec89e4c338" translate="yes" xml:space="preserve">
          <source>AtomicInteger.accumulateAndGet()</source>
          <target state="translated">AtomicInteger.accumulateAndGet()</target>
        </trans-unit>
        <trans-unit id="850969b16dc996b5bc4a3d42cfa46901c88a0701" translate="yes" xml:space="preserve">
          <source>AtomicInteger.addAndGet()</source>
          <target state="translated">AtomicInteger.addAndGet()</target>
        </trans-unit>
        <trans-unit id="c5662727b197824e8d6859634f44401f594f31d9" translate="yes" xml:space="preserve">
          <source>AtomicInteger.compareAndSet()</source>
          <target state="translated">AtomicInteger.compareAndSet()</target>
        </trans-unit>
        <trans-unit id="ee0a3850d4e46b56ac9985e96683d74876d9fc4e" translate="yes" xml:space="preserve">
          <source>AtomicInteger.decrementAndGet()</source>
          <target state="translated">AtomicInteger.decrementAndGet()</target>
        </trans-unit>
        <trans-unit id="4f3cb05fce30ccee0967a8f5489eb8997821aa0a" translate="yes" xml:space="preserve">
          <source>AtomicInteger.doubleValue()</source>
          <target state="translated">AtomicInteger.doubleValue()</target>
        </trans-unit>
        <trans-unit id="fb31bfbcbeab4f91a91731ac9264587401bde17b" translate="yes" xml:space="preserve">
          <source>AtomicInteger.floatValue()</source>
          <target state="translated">AtomicInteger.floatValue()</target>
        </trans-unit>
        <trans-unit id="fabbe156dd02dd022d99dbbb4d4a7c691219ed57" translate="yes" xml:space="preserve">
          <source>AtomicInteger.get()</source>
          <target state="translated">AtomicInteger.get()</target>
        </trans-unit>
        <trans-unit id="5e3d573530ae582667f4fb6da85b0a8817d6d5a2" translate="yes" xml:space="preserve">
          <source>AtomicInteger.getAndAccumulate()</source>
          <target state="translated">AtomicInteger.getAndAccumulate()</target>
        </trans-unit>
        <trans-unit id="0101e2bd3b30d5ddb2a6d947fb230353cf69af95" translate="yes" xml:space="preserve">
          <source>AtomicInteger.getAndAdd()</source>
          <target state="translated">AtomicInteger.getAndAdd()</target>
        </trans-unit>
        <trans-unit id="2bcaa86c024cac33e85e2370f0c8f443398dfe26" translate="yes" xml:space="preserve">
          <source>AtomicInteger.getAndDecrement()</source>
          <target state="translated">AtomicInteger.getAndDecrement()</target>
        </trans-unit>
        <trans-unit id="fbe349bf35ee01659e23d28bc6f233ef335d5f26" translate="yes" xml:space="preserve">
          <source>AtomicInteger.getAndIncrement()</source>
          <target state="translated">AtomicInteger.getAndIncrement()</target>
        </trans-unit>
        <trans-unit id="780f9ea63336977d97ffb4970334e8a17b708430" translate="yes" xml:space="preserve">
          <source>AtomicInteger.getAndSet()</source>
          <target state="translated">AtomicInteger.getAndSet()</target>
        </trans-unit>
        <trans-unit id="2041373f7c0f68cbcd8b7ca5bc07c587e0232d30" translate="yes" xml:space="preserve">
          <source>AtomicInteger.getAndUpdate()</source>
          <target state="translated">AtomicInteger.getAndUpdate()</target>
        </trans-unit>
        <trans-unit id="c78df742cea261db3e4ff471ea30fedfab4a6aed" translate="yes" xml:space="preserve">
          <source>AtomicInteger.incrementAndGet()</source>
          <target state="translated">AtomicInteger.incrementAndGet()</target>
        </trans-unit>
        <trans-unit id="a35e1a5a8c9d1a30abd84fb2e7e662e2f71c0989" translate="yes" xml:space="preserve">
          <source>AtomicInteger.intValue()</source>
          <target state="translated">AtomicInteger.intValue()</target>
        </trans-unit>
        <trans-unit id="159b939ea29321726f3bedc8883099ec1beab90f" translate="yes" xml:space="preserve">
          <source>AtomicInteger.lazySet()</source>
          <target state="translated">AtomicInteger.lazySet()</target>
        </trans-unit>
        <trans-unit id="c52d3998931b661db45b1b329fa6b8463d57f738" translate="yes" xml:space="preserve">
          <source>AtomicInteger.longValue()</source>
          <target state="translated">AtomicInteger.longValue()</target>
        </trans-unit>
        <trans-unit id="32422db05e4fa5d4ab45173bb721a60958d05dcd" translate="yes" xml:space="preserve">
          <source>AtomicInteger.set()</source>
          <target state="translated">AtomicInteger.set()</target>
        </trans-unit>
        <trans-unit id="dda537410032ad73b22156f22a95e22d7e7c3d0d" translate="yes" xml:space="preserve">
          <source>AtomicInteger.toString()</source>
          <target state="translated">AtomicInteger.toString()</target>
        </trans-unit>
        <trans-unit id="a29bc6dceff9c2083e0ee3b52073dafe204517d2" translate="yes" xml:space="preserve">
          <source>AtomicInteger.updateAndGet()</source>
          <target state="translated">AtomicInteger.updateAndGet()</target>
        </trans-unit>
        <trans-unit id="88dfef7324c272c0bf93e5a9f6cead9afd0d9c9f" translate="yes" xml:space="preserve">
          <source>AtomicInteger.weakCompareAndSet()</source>
          <target state="translated">AtomicInteger.weakCompareAndSet()</target>
        </trans-unit>
        <trans-unit id="bfb54e429f35d898e4d023b0015555f1acd008fb" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray</source>
          <target state="translated">AtomicIntegerArray</target>
        </trans-unit>
        <trans-unit id="54afdb7f07145a2ef44f2a85b1e3d12388b6f14d" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray.accumulateAndGet()</source>
          <target state="translated">AtomicIntegerArray.accumulateAndGet()</target>
        </trans-unit>
        <trans-unit id="50f239109ed56572a062f156953619fae80133fb" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray.addAndGet()</source>
          <target state="translated">AtomicIntegerArray.addAndGet()</target>
        </trans-unit>
        <trans-unit id="e44ba65d1670aa1b97efdc19e7129d8e3fcbbb92" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray.compareAndSet()</source>
          <target state="translated">AtomicIntegerArray.compareAndSet()</target>
        </trans-unit>
        <trans-unit id="a9cc3f20875d81123af7548e1852346eacac4f0e" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray.decrementAndGet()</source>
          <target state="translated">AtomicIntegerArray.decrementAndGet()</target>
        </trans-unit>
        <trans-unit id="c93bb8d82dc097929cd60c3829e3ffa97da1b08f" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray.get()</source>
          <target state="translated">AtomicIntegerArray.get()</target>
        </trans-unit>
        <trans-unit id="812f9f7e956f67b47b0dd71b82b4bf8d221cb3ff" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray.getAndAccumulate()</source>
          <target state="translated">AtomicIntegerArray.getAndAccumulate()</target>
        </trans-unit>
        <trans-unit id="84da9a0d1d65a6705bb2c54b75c85cc08c6ddf00" translate="yes" xml:space="preserve">
          <source>AtomicIntegerArray.getAndAdd()</source>
          <target state="translated">AtomicIntegerArray.getAndAdd()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
