<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="9b7835d6c2897bc03547bef50d2e8ccef489fee5" translate="yes" xml:space="preserve">
          <source>The padding value.</source>
          <target state="translated">패딩 값입니다.</target>
        </trans-unit>
        <trans-unit id="5254cf384974df4bf22cb621e6eb98fe1516e0c5" translate="yes" xml:space="preserve">
          <source>The paged-results control's assigned object identifier is 1.2.840.113556.1.4.319.</source>
          <target state="translated">페이징 제어 - 결과의 할당 객체 식별자 1.2.840.113556.1.4.319이다.</target>
        </trans-unit>
        <trans-unit id="866b80818a098f96114ee08abb23a44885090886" translate="yes" xml:space="preserve">
          <source>The paged-results response control's assigned object identifier is 1.2.840.113556.1.4.319.</source>
          <target state="translated">페이징 된 결과 응답 컨트롤의 할당 된 개체 식별자는 1.2.840.113556.1.4.319입니다.</target>
        </trans-unit>
        <trans-unit id="b266460db97939c24d673ede02a200ebb6755934" translate="yes" xml:space="preserve">
          <source>The paint event type.</source>
          <target state="translated">페인트 이벤트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="67aa960c4b671a24ef5b1e0c2ea9ff270cfe200e" translate="yes" xml:space="preserve">
          <source>The painting architecture of Swing requires an opaque &lt;code&gt;JComponent&lt;/code&gt; to exist in the containment hierarchy above all other components. This is typically provided by way of the content pane. If you replace the content pane, it is recommended that you make the content pane opaque by way of &lt;code&gt;setOpaque(true)&lt;/code&gt;. Additionally, if the content pane overrides &lt;code&gt;paintComponent&lt;/code&gt;, it will need to completely fill in the background in an opaque color in &lt;code&gt;paintComponent&lt;/code&gt;.</source>
          <target state="translated">Swing의 페인팅 아키텍처는 다른 모든 구성 요소 위에 포함 계층 구조에 존재 하는 불투명 &lt;code&gt;JComponent&lt;/code&gt; 가 필요합니다 . 이는 일반적으로 콘텐츠 창을 통해 제공됩니다. 콘텐츠 창을 교체하는 경우 &lt;code&gt;setOpaque(true)&lt;/code&gt; 통해 콘텐츠 창을 불투명하게 만드는 것이 좋습니다 . 내용 창에 우선하는 경우 또한, &lt;code&gt;paintComponent&lt;/code&gt; 완전히에서 불투명 한 색으로 배경을 작성하기 위해서는 필요합니다 &lt;code&gt;paintComponent&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="49dbe49dc69592f6524d7ca2b444c01fc630b182" translate="yes" xml:space="preserve">
          <source>The palette close icon.</source>
          <target state="translated">팔레트 닫기 아이콘.</target>
        </trans-unit>
        <trans-unit id="1b15c609d33b642b1ba463e5d2a1471d0d9df721" translate="yes" xml:space="preserve">
          <source>The palette layer sits over the default layer. Useful for floating toolbars and palettes, so they can be positioned above other components.</source>
          <target state="translated">팔레트 레이어는 기본 레이어 위에 있습니다. 부동 도구 모음 및 팔레트에 유용하므로 다른 구성 요소 위에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a054a114f906605bc80876fd63d7712ff1b761b8" translate="yes" xml:space="preserve">
          <source>The paragraph attributes form the definition of a paragraph to be rendered. All sizes are specified in points (such as found in postscript), a device independent measure.</source>
          <target state="translated">단락 속성은 렌더링 할 단락의 정의를 형성합니다. 모든 크기는 장치 독립적 측정 인 포인트 (예 : 포스트 스크립트에 있음)로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4707bb85a1366f3abad509af71baadf574140ddd" translate="yes" xml:space="preserve">
          <source>The paragraph left indent action identifier</source>
          <target state="translated">단락 왼쪽 들여 쓰기 작업 식별자</target>
        </trans-unit>
        <trans-unit id="16cfceed724273e5b7e0f3fabbd803cacb348ced" translate="yes" xml:space="preserve">
          <source>The paragraph right indent action identifier</source>
          <target state="translated">단락 오른쪽 들여 쓰기 작업 식별자</target>
        </trans-unit>
        <trans-unit id="7b4511c60fee63fc5dd606de36079b10244d82e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;item&lt;/code&gt; represents the context the XPath expression will be operated on. The type of the context is implementation-dependent. If the value is &lt;code&gt;null&lt;/code&gt;, the operation must have no dependency on the context, otherwise an XPathExpressionException will be thrown.</source>
          <target state="translated">매개 변수 &lt;code&gt;item&lt;/code&gt; 은 XPath 표현식이 작동 할 컨텍스트를 나타냅니다. 컨텍스트 유형은 구현에 따라 다릅니다. 값이 &lt;code&gt;null&lt;/code&gt; 이면 작업에 컨텍스트에 대한 종속성이 없어야합니다. 그렇지 않으면 XPathExpressionException이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="50af5226ec29660988fc56fada491b71c9083bd4" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;n&lt;/code&gt; must be in the range 0 through 999999999, inclusive. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; returns &lt;a href=&quot;#ONE&quot;&gt;&lt;code&gt;ONE&lt;/code&gt;&lt;/a&gt;. Note that future releases may expand the allowable exponent range of this method.</source>
          <target state="translated">매개 변수 &lt;code&gt;n&lt;/code&gt; 은 0-999999999 범위에 있어야합니다. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; 은 &lt;a href=&quot;#ONE&quot;&gt; &lt;code&gt;ONE&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 향후 릴리스에서는이 방법의 허용 가능한 지수 범위가 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24552a8980b41276ccd5905a6aaeeb53f392d59d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;n&lt;/code&gt; must be in the range 0 through 999999999, inclusive. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; returns &lt;a href=&quot;bigdecimal#ONE&quot;&gt;&lt;code&gt;ONE&lt;/code&gt;&lt;/a&gt;. Note that future releases may expand the allowable exponent range of this method.</source>
          <target state="translated">매개 변수 &lt;code&gt;n&lt;/code&gt; 은 0-999999999 범위에 있어야합니다. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; 은 &lt;a href=&quot;bigdecimal#ONE&quot;&gt; &lt;code&gt;ONE&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 향후 릴리스에서는이 방법의 허용 가능한 지수 범위가 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="225f6eef89aa234e726279199c17142bb293790d" translate="yes" xml:space="preserve">
          <source>The parameter count in &lt;code&gt;concatType&lt;/code&gt; equals to number of \1 tags in &lt;code&gt;recipe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;concatType&lt;/code&gt; 의 매개 변수 개수 는 &lt;code&gt;recipe&lt;/code&gt; 의 \ 1 태그 수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5ec5b0fc9d2ee85f8e3be945c5875b1eb128c88" translate="yes" xml:space="preserve">
          <source>The parameter factoryId defined here is inconsistent with that of other JAXP factories where the first parameter is fully qualified factory class name that provides implementation of the factory.</source>
          <target state="translated">여기에 정의 된 매개 변수 factoryId는 첫 번째 매개 변수가 팩토리 구현을 제공하는 완전한 팩토리 클래스 이름 인 다른 JAXP 팩토리의 매개 변수와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06f41071ad9d7621be55ce2931fc7d18a329dcd8" translate="yes" xml:space="preserve">
          <source>The parameter list &lt;code&gt;(V A...)&lt;/code&gt; of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;. It will constrain the parameter lists of the other loop parts.</source>
          <target state="translated">본문 의 매개 변수 목록 &lt;code&gt;(V A...)&lt;/code&gt; 을 &lt;em&gt;내부 매개 변수 목록&lt;/em&gt; 이라고합니다 . 다른 루프 파트의 매개 변수 목록을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="7fd62c7a8f8c15bfb268fbf63a8a0194acc8a533" translate="yes" xml:space="preserve">
          <source>The parameter list &lt;code&gt;(V I A...)&lt;/code&gt; of the body contributes to a list of types called the &lt;em&gt;internal parameter list&lt;/em&gt;. It will constrain the parameter lists of the other loop parts.</source>
          <target state="translated">본문 의 매개 변수 목록 &lt;code&gt;(V I A...)&lt;/code&gt; 은 &lt;em&gt;내부 매개 변수 목록&lt;/em&gt; 이라는 유형 목록에 기여 &lt;em&gt;합니다&lt;/em&gt; . 다른 루프 파트의 매개 변수 목록을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="e58b0b6e022c4ee1aa6339bb336b514c909a5f9d" translate="yes" xml:space="preserve">
          <source>The parameter list &lt;code&gt;(V T A...)&lt;/code&gt; of the body contributes to a list of types called the &lt;em&gt;internal parameter list&lt;/em&gt;. It will constrain the parameter lists of the other loop parts.</source>
          <target state="translated">본문 의 매개 변수 목록 &lt;code&gt;(V T A...)&lt;/code&gt; 은 &lt;em&gt;내부 매개 변수 목록&lt;/em&gt; 이라는 유형 목록에 기여 &lt;em&gt;합니다&lt;/em&gt; . 다른 루프 파트의 매개 변수 목록을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="474a5af5a3f8d227ed70f57da563f8b86bc54e3c" translate="yes" xml:space="preserve">
          <source>The parameter list for every non-omitted, non-init (step, pred, and fini) function must be effectively identical to the internal parameter list &lt;code&gt;(V... A...)&lt;/code&gt;.</source>
          <target state="translated">모든 생략되지 않고 초기화되지 않은 (step, pred 및 fini) 함수에 대한 매개 변수 목록은 내부 매개 변수 목록 &lt;code&gt;(V... A...)&lt;/code&gt; 과 사실상 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="53432ad7282ec815dfa60a54e056f22aa428efcb" translate="yes" xml:space="preserve">
          <source>The parameter list for init functions will be adjusted to the external parameter list. (Note that their parameter lists are already effectively identical to this list.)</source>
          <target state="translated">초기화 기능에 대한 매개 변수 목록은 외부 매개 변수 목록에 맞게 조정됩니다. (매개 변수 목록은 이미이 목록과 사실상 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="8e16a7cb9882736edeb02f61ab4586e18b7cca61" translate="yes" xml:space="preserve">
          <source>The parameter list for the resulting loop handle will be the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">결과 루프 핸들의 매개 변수 목록은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b118da091f6db3ab3ac720df6e05ded63f2e75c7" translate="yes" xml:space="preserve">
          <source>The parameter list of &lt;code&gt;iterations&lt;/code&gt; (of some form &lt;code&gt;(A*)&lt;/code&gt;) must be effectively identical to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(A*)&lt;/code&gt; 형식 의 &lt;code&gt;iterations&lt;/code&gt; 매개 변수 목록은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 과 효과적으로 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="30a082bbd95089d21ab808594316f3f108f9a062" translate="yes" xml:space="preserve">
          <source>The parameter list of &lt;code&gt;start&lt;/code&gt; (of some form &lt;code&gt;(A*)&lt;/code&gt;) must be effectively identical to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 의 매개 변수 목록 (일부 형식 &lt;code&gt;(A*)&lt;/code&gt; )은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 과 사실상 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9d60d133de9d4d6e4fd09cf41a4b92be03c10f9" translate="yes" xml:space="preserve">
          <source>The parameter list of an &lt;code&gt;iterator&lt;/code&gt; that is non-&lt;code&gt;null&lt;/code&gt; (of some form &lt;code&gt;(A*)&lt;/code&gt;) must be effectively identical to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 아닌 (일부 형식 &lt;code&gt;(A*)&lt;/code&gt; ) &lt;code&gt;iterator&lt;/code&gt; 의 매개 변수 목록은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 과 효과적으로 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c4b12867b1f840ab46a64f2a284a7b84dba7590" translate="yes" xml:space="preserve">
          <source>The parameter names used by the &lt;code&gt;DOMConfiguration&lt;/code&gt; object are defined throughout the DOM Level 3 specifications. Names are case-insensitive. To avoid possible conflicts, as a convention, names referring to parameters defined outside the DOM specification should be made unique. Because parameters are exposed as properties in names are recommended to follow the section 5.16 Identifiers of [Unicode] with the addition of the character '-' (HYPHEN-MINUS) but it is not enforced by the DOM implementation. DOM Level 3 Core Implementations are required to recognize all parameters defined in this specification. Some parameter values may also be required to be supported by the implementation. Refer to the definition of the parameter to know if a value must be supported or not.</source>
          <target state="translated">&lt;code&gt;DOMConfiguration&lt;/code&gt; 객체에서 사용하는 매개 변수 이름 은 DOM 레벨 3 사양 전체에서 정의됩니다. 이름은 대소 문자를 구분하지 않습니다. 충돌 가능성을 피하기 위해 규칙으로 DOM 사양 외부에 정의 된 매개 변수를 참조하는 이름은 고유해야합니다. 매개 변수는 이름의 속성으로 노출되기 때문에 문자 '-'(HYPHEN-MINUS)를 추가하여 5.16 [Unicode] 식별자 섹션을 따르는 것이 좋지만 DOM 구현에 의해 강제되지는 않습니다. DOM 레벨 3 핵심 구현은이 사양에 정의 된 모든 매개 변수를 인식하는 데 필요합니다. 일부 매개 변수 값은 구현에서 지원해야 할 수도 있습니다. 값이 지원되어야하는지 여부를 알려면 매개 변수 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcdb80d85de039f3e18bb3b5fc1d902bb8edad88" translate="yes" xml:space="preserve">
          <source>The parameter of this method is the number of invocations being requested from this WebSocket to the associated listener, not the number of messages. Sometimes a message may be delivered to the listener in a single invocation, but not always. For example, Ping, Pong and Close messages are delivered in a single invocation of &lt;code&gt;onPing&lt;/code&gt;, &lt;code&gt;onPong&lt;/code&gt; and &lt;code&gt;onClose&lt;/code&gt; methods respectively. However, whether or not Text and Binary messages are delivered in a single invocation of &lt;code&gt;onText&lt;/code&gt; and &lt;code&gt;onBinary&lt;/code&gt; methods depends on the boolean argument (&lt;code&gt;last&lt;/code&gt;) of these methods. If &lt;code&gt;last&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then there is more to a message than has been delivered to the invocation.</source>
          <target state="translated">이 메소드의 매개 변수는 메시지 수가 아니라이 WebSocket에서 연관된 리스너로 요청되는 호출 수입니다. 때로는 메시지가 단일 호출로 리스너에게 전달 될 수 있지만 항상 그런 것은 아닙니다. 예를 들어, Ping, Pong 및 Close 메시지는 각각 &lt;code&gt;onPing&lt;/code&gt; , &lt;code&gt;onPong&lt;/code&gt; 및 &lt;code&gt;onClose&lt;/code&gt; 메소드 의 단일 호출로 전달 됩니다. 그러나 Text 및 Binary 메시지가 &lt;code&gt;onText&lt;/code&gt; 및 &lt;code&gt;onBinary&lt;/code&gt; 메서드 의 단일 호출로 전달되는지 여부 는 이러한 메서드 의 부울 인수 ( &lt;code&gt;last&lt;/code&gt; )에 따라 다릅니다 . &lt;code&gt;last&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 이면이면 호출에 전달 된 것보다 더 많은 메시지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="44e6fab6d9ac4719240ec0b3727c954e51d89ce9" translate="yes" xml:space="preserve">
          <source>The parameter types &lt;code&gt;Vn&lt;/code&gt; will be interpreted as loop-local state elements &lt;code&gt;(V...)&lt;/code&gt;.</source>
          <target state="translated">매개 변수 유형 &lt;code&gt;Vn&lt;/code&gt; 은 루프 로컬 상태 요소 &lt;code&gt;(V...)&lt;/code&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e373695ec6d41c303c83799483b80fd014fe746" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setUnicodeStream&lt;/code&gt; has been called will return an array containing the parameter values that have been set. In that array, the element that represents the values set with this method will itself be an array. The first element of that array is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The second element is the value set for</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;setUnicodeStream&lt;/code&gt; 이 호출 된 후 &lt;code&gt;getParams&lt;/code&gt; 메소드를 호출하면 설정된 매개 변수 값이 포함 된 배열이 리턴됩니다. 이 배열에서이 메서드로 설정된 값을 나타내는 요소 자체가 배열이됩니다. 그 배열의 첫 번째 요소는 주어진 &lt;code&gt;java.io.InputStream&lt;/code&gt; 객체입니다. 두 번째 요소는 다음에 대해 설정된 값입니다.</target>
        </trans-unit>
        <trans-unit id="5b1d686a30e89e20a67cce69f88fe14f6a1d46c4" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be provided in any class that extends this class and implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;execute&lt;/code&gt; 및 &lt;code&gt;populate&lt;/code&gt; 와 같은 메소드 는이 클래스를 확장하고 표준 JSR-114 &lt;code&gt;RowSet&lt;/code&gt; 인터페이스 중 하나 이상을 구현하는 모든 클래스에서 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfb052ee0c1e5966878d2245fe418bfa8a8bdef9" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be provided in any class that extends this class and implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces. NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method as it is undefined in this class.</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;execute&lt;/code&gt; 및 &lt;code&gt;populate&lt;/code&gt; 와 같은 메소드 는이 클래스를 확장하고 표준 JSR-114 &lt;code&gt;RowSet&lt;/code&gt; 인터페이스 중 하나 이상을 구현하는 모든 클래스에서 제공되어야합니다 . 참고 : &lt;code&gt;JdbcRowSet&lt;/code&gt; 은이 클래스에서 정의 되지 않았기 때문에 &lt;code&gt;populate&lt;/code&gt; 메서드가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="305a02d1aa1ebc36991c6f5311b0ec8b4872c30b" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Methods such as &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt; must be provided in any class that extends this class and implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;execute&lt;/code&gt; , &lt;code&gt;populate&lt;/code&gt; 와 같은 메소드 는이 클래스를 확장하고 표준 JSR-114 &lt;code&gt;RowSet&lt;/code&gt; 인터페이스 중 하나 이상을 구현하는 모든 클래스에서 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b8ef4f0e5646bef0741f18b4f02a8cea83921ea8" translate="yes" xml:space="preserve">
          <source>The parameter values retain their original case, except a charset parameter value for a text media type is converted to lowercase.</source>
          <target state="translated">텍스트 매체 유형의 문자 세트 매개 변수 값이 소문자로 변환되는 것을 제외하고 매개 변수 값은 원래 대소 문자를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bb39ffff0d8075952f90c8c237468e1f45f1c684" translate="yes" xml:space="preserve">
          <source>The parameters are arranged in ascending order of parameter name.</source>
          <target state="translated">매개 변수는 매개 변수 이름의 오름차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="11e0d4edf362f7c76332fc4450bc63049b256eb3" translate="yes" xml:space="preserve">
          <source>The parameters are not authenticated by the &lt;code&gt;SSLEngine&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &lt;code&gt;SSLEngine&lt;/code&gt; 에 의해 인증되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb65f692e7e1455e31c885605739ad78cecb430f" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 addSelectionInterval(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;addSelectionInterval(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; addSelectionInterval(x, y)&lt;/code&gt; 는 &lt;code&gt;addSelectionInterval(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1f7d66b2c4cec0965399997b2bce2a3097afb6c1" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 getPathBetweenRows(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;getPathBetweenRows(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; getPathBetweenRows(x, y)&lt;/code&gt; 는 &lt;code&gt;getPathBetweenRows(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="71fdccbc419bc28fc08830c8d380f76d2f332f40" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 removeSelectionInterval(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;removeSelectionInterval(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; removeSelectionInterval(x, y)&lt;/code&gt; 는 &lt;code&gt;removeSelectionInterval(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8392c9e26a22dc79ccde9fbc210a6e58f6f0e6de" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 setSelectionInterval(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;setSelectionInterval(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; setSelectionInterval(x, y)&lt;/code&gt; 는 &lt;code&gt;setSelectionInterval(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="aff2143fd57f0fff307229e418484b901b5de2b1" translate="yes" xml:space="preserve">
          <source>The parameters consist of a 12-byte nonce and an initial counter value expressed as a 32-bit integer.</source>
          <target state="translated">매개 변수는 12 바이트 nonce와 32 비트 정수로 표현되는 초기 카운터 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ae335f84321e13f212ee4b121568c174875cb3" translate="yes" xml:space="preserve">
          <source>The parameters consist of a version number, a rounds count, a word size, and optionally an initialization vector (IV) (only in feedback mode).</source>
          <target state="translated">매개 변수는 버전 번호, 반올림 횟수, 단어 크기 및 선택적으로 초기화 벡터 (IV) (피드백 모드에서만)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f8d6f3c8b03d8da1385862cfad5502762462d5" translate="yes" xml:space="preserve">
          <source>The parameters consist of an effective key size and optionally an 8-byte initialization vector (IV) (only in feedback mode).</source>
          <target state="translated">매개 변수는 유효 키 크기와 선택적으로 8 바이트 IV (IV)로 구성됩니다 (피드백 모드에서만).</target>
        </trans-unit>
        <trans-unit id="0b947091ed01239ac2c63710914b838d30a607d9" translate="yes" xml:space="preserve">
          <source>The parameters of the underlying executable do not necessarily have unique names, or names that are legal identifiers in the Java programming language (JLS 3.8).</source>
          <target state="translated">기본 실행 파일의 매개 변수에 고유 이름 또는 Java 프로그래밍 언어 (JLS 3.8)의 유효한 식별자 인 이름이 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76d53ff74b412d6d37047d16013d75e50df36de2" translate="yes" xml:space="preserve">
          <source>The parameters represent the two parts of a phrase like '6 Hours'. For example:</source>
          <target state="translated">매개 변수는 '6 Hours'와 같은 문구의 두 부분을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad7182414b3d2ec2fdd16dc0fcb2c6566049a62c" translate="yes" xml:space="preserve">
          <source>The parameters specified by an &lt;code&gt;ImageReadParam&lt;/code&gt; are applied to an image as follows. First, if a rendering size has been set by &lt;code&gt;setSourceRenderSize&lt;/code&gt;, the entire decoded image is rendered at the size given by &lt;code&gt;getSourceRenderSize&lt;/code&gt;. Otherwise, the image has its natural size given by &lt;code&gt;ImageReader.getWidth&lt;/code&gt; and &lt;code&gt;ImageReader.getHeight&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ImageReadParam&lt;/code&gt; 에 의해 지정된 매개 변수 는 다음과 같이 이미지에 적용됩니다. 먼저, 렌더링 크기가 &lt;code&gt;setSourceRenderSize&lt;/code&gt; 에 의해 설정된 경우 , 디코딩 된 전체 이미지는 &lt;code&gt;getSourceRenderSize&lt;/code&gt; 가 제공 한 크기로 렌더링됩니다 . 그렇지 않으면 이미지는 &lt;code&gt;ImageReader.getWidth&lt;/code&gt; 및 &lt;code&gt;ImageReader.getHeight&lt;/code&gt; 에 의해 주어진 자연 크기를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="71e0836126bfdf6c19dabd14a10861299a8d46d0" translate="yes" xml:space="preserve">
          <source>The parameters supplied to this constructor are subject to the constraints described in &lt;a href=&quot;#setValues(int,int,int,int)&quot;&gt;&lt;code&gt;setValues(int, int, int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 생성자에 제공된 매개 변수에는 &lt;a href=&quot;#setValues(int,int,int,int)&quot;&gt; &lt;code&gt;setValues(int, int, int, int)&lt;/code&gt; &lt;/a&gt; 설명 된 제약 조건이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0eb52dcb0a07ffe222d0a4187fb174042c35c23" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;Printable.print(..)&lt;/code&gt; include a &lt;code&gt;PageFormat&lt;/code&gt; which describes the printable area of the page, needed for calculating the contents that will fit the page, and the page index, which specifies the zero-based print stream index of the requested page.</source>
          <target state="translated">&lt;code&gt;Printable.print(..)&lt;/code&gt; 대한 매개 변수 에는 페이지에 맞는 내용을 계산하는 데 필요한 페이지의 인쇄 가능 영역을 설명 하는 &lt;code&gt;PageFormat&lt;/code&gt; 과 요청 된 항목의 0부터 시작하는 인쇄 스트림 인덱스를 지정하는 페이지 인덱스가 포함됩니다. 페이지.</target>
        </trans-unit>
        <trans-unit id="adce7a8e02b2dbab7543097404b50ae2e2f2c0d3" translate="yes" xml:space="preserve">
          <source>The parameters to these methods follow consistent patterns:</source>
          <target state="translated">이러한 메서드에 대한 매개 변수는 일관된 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="64f3c4e11f9c88a8f6edb02c85c8a7f5a133e45c" translate="yes" xml:space="preserve">
          <source>The parameters used to construct the common pool may be controlled by setting the following &lt;a href=&quot;../../lang/system#getProperty(java.lang.String)&quot;&gt;system properties&lt;/a&gt;:</source>
          <target state="translated">공통 풀을 구성하는 데 사용되는 매개 변수는 다음 &lt;a href=&quot;../../lang/system#getProperty(java.lang.String)&quot;&gt;시스템 속성&lt;/a&gt; 을 설정하여 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbf95408183e18e8026be8d135af97a9475df373" translate="yes" xml:space="preserve">
          <source>The parameters will always have the ciphersuite and protocols arrays set to non-null values.</source>
          <target state="translated">매개 변수는 항상 ciphersuite 및 protocols 배열이 널이 아닌 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b52384d72a0f4af8de4f042358cf9996bbe18cf1" translate="yes" xml:space="preserve">
          <source>The parameters will always have the ciphersuites and protocols arrays set to non-null values.</source>
          <target state="translated">매개 변수는 항상 암호 스위트 및 프로토콜 배열이 널이 아닌 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc871c3368e0f342532a2f5e48a852376491cab" translate="yes" xml:space="preserve">
          <source>The parent &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">부모 &lt;code&gt;ClassLoader&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0f70c146a15a9633f15da82c69e002a0f572e9c" translate="yes" xml:space="preserve">
          <source>The parent &lt;code&gt;TIFFTag&lt;/code&gt; of this &lt;code&gt;TIFFDiectory&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">부모 &lt;code&gt;TIFFTag&lt;/code&gt; 이의 &lt;code&gt;TIFFDiectory&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d74755cef612aee13f4b446f05e5c5a94e3a7a37" translate="yes" xml:space="preserve">
          <source>The parent Preferences node whose child was added or removed</source>
          <target state="translated">자식이 추가 또는 제거 된 부모 기본 설정 노드</target>
        </trans-unit>
        <trans-unit id="33ac4d46f58c647e6c28b3a88eaca5814b56ebef" translate="yes" xml:space="preserve">
          <source>The parent XML reader, or null if none is set.</source>
          <target state="translated">부모 XML 판독기 또는 설정되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="cd9fa36300939772a8d4ba38942d9a6d934d8ad7" translate="yes" xml:space="preserve">
          <source>The parent bundle of this bundle.</source>
          <target state="translated">이 번들의 상위 번들입니다.</target>
        </trans-unit>
        <trans-unit id="e7f2fe8682b735add36e45bdef4d5db06770add9" translate="yes" xml:space="preserve">
          <source>The parent bundle of this bundle. The parent bundle is searched by &lt;a href=&quot;#getObject(java.lang.String)&quot;&gt;&lt;code&gt;getObject&lt;/code&gt;&lt;/a&gt; when this bundle does not contain a particular resource.</source>
          <target state="translated">이 번들의 상위 번들입니다. 이 번들에 특정 자원이 포함되지 않은 경우 &lt;a href=&quot;#getObject(java.lang.String)&quot;&gt; &lt;code&gt;getObject&lt;/code&gt; &lt;/a&gt; 가 상위 번들을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="f994dff1510a6e8c2918e9b6d01ec794ebf2150e" translate="yes" xml:space="preserve">
          <source>The parent bundle of this bundle. The parent bundle is searched by &lt;a href=&quot;resourcebundle#getObject-java.lang.String-&quot;&gt;&lt;code&gt;getObject&lt;/code&gt;&lt;/a&gt; when this bundle does not contain a particular resource.</source>
          <target state="translated">이 번들의 상위 번들입니다. 이 번들에 특정 자원이없는 경우 &lt;a href=&quot;resourcebundle#getObject-java.lang.String-&quot;&gt; &lt;code&gt;getObject&lt;/code&gt; &lt;/a&gt; 가 상위 번들을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="1a8a8c799fe8db426e27940a42162ee878964a8c" translate="yes" xml:space="preserve">
          <source>The parent filter, or null if none has been set.</source>
          <target state="translated">상위 필터 또는 설정되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="2ad67599d600504152ce7c1281d25a4bda96e309" translate="yes" xml:space="preserve">
          <source>The parent of this Raster, or null.</source>
          <target state="translated">이 Raster의 부모 또는 null입니다.</target>
        </trans-unit>
        <trans-unit id="6ead187d94bbfc9668d1eb5e36e9dd0eef0b1804" translate="yes" xml:space="preserve">
          <source>The parent of this node.</source>
          <target state="translated">이 노드의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="cc6d14ed40ff1babb894dcdc578652bb681cdd1e" translate="yes" xml:space="preserve">
          <source>The parent of this node. All nodes, except &lt;code&gt;Attr&lt;/code&gt;, &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentFragment&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt;, and &lt;code&gt;Notation&lt;/code&gt; may have a parent. However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 노드의 부모입니다. &lt;code&gt;Attr&lt;/code&gt; , &lt;code&gt;Document&lt;/code&gt; , &lt;code&gt;DocumentFragment&lt;/code&gt; , &lt;code&gt;Entity&lt;/code&gt; 및 &lt;code&gt;Notation&lt;/code&gt; 을 제외한 모든 노드 에는 부모가있을 수 있습니다. 그러나 노드가 방금 생성되었고 아직 트리에 추가되지 않았거나 트리에서 제거 된 경우 이것은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33e9e67cecfddb7bcbfe15f096f52a88a0f4abac" translate="yes" xml:space="preserve">
          <source>The parent of this path object consists of this path's root component, if any, and each element in the path except for the &lt;em&gt;farthest&lt;/em&gt; from the root in the directory hierarchy. This method does not access the file system; the path or its parent may not exist. Furthermore, this method does not eliminate special names such as &quot;.&quot; and &quot;..&quot; that may be used in some implementations. On UNIX for example, the parent of &quot;&lt;code&gt;/a/b/c&lt;/code&gt;&quot; is &quot;&lt;code&gt;/a/b&lt;/code&gt;&quot;, and the parent of &lt;code&gt;&quot;x/y/.&lt;/code&gt;&quot; is &quot;&lt;code&gt;x/y&lt;/code&gt;&quot;. This method may be used with the &lt;a href=&quot;#normalize()&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; method, to eliminate redundant names, for cases where &lt;em&gt;shell-like&lt;/em&gt; navigation is required.</source>
          <target state="translated">이 경로 개체의 부모는이 경로의 루트 구성 요소 (있는 경우)와 디렉터리 계층 구조의 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 것을 제외하고 경로의 각 요소로 구성됩니다 . 이 방법은 파일 시스템에 액세스하지 않습니다. 경로 또는 부모가 존재하지 않을 수 있습니다. 또한이 방법은 &quot;.&quot;와 같은 특수 이름을 제거하지 않습니다. 일부 구현에서 사용될 수있는 &quot;..&quot; 예를 들어 UNIX에서 &quot; &lt;code&gt;/a/b/c&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;/a/b&lt;/code&gt; &quot;이고 &lt;code&gt;&quot;x/y/.&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;x/y&lt;/code&gt; &quot;입니다. 이 메서드는 &lt;a href=&quot;#normalize()&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 메서드 와 함께 사용하여 &lt;em&gt;셸과 같은&lt;/em&gt; 탐색이 필요한 경우 중복 된 이름을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ecda3b1f4f94be292091c923d129f7d53c68915" translate="yes" xml:space="preserve">
          <source>The parent of this path object consists of this path's root component, if any, and each element in the path except for the &lt;em&gt;farthest&lt;/em&gt; from the root in the directory hierarchy. This method does not access the file system; the path or its parent may not exist. Furthermore, this method does not eliminate special names such as &quot;.&quot; and &quot;..&quot; that may be used in some implementations. On UNIX for example, the parent of &quot;&lt;code&gt;/a/b/c&lt;/code&gt;&quot; is &quot;&lt;code&gt;/a/b&lt;/code&gt;&quot;, and the parent of &lt;code&gt;&quot;x/y/.&lt;/code&gt;&quot; is &quot;&lt;code&gt;x/y&lt;/code&gt;&quot;. This method may be used with the &lt;a href=&quot;path#normalize--&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; method, to eliminate redundant names, for cases where &lt;em&gt;shell-like&lt;/em&gt; navigation is required.</source>
          <target state="translated">이 경로 객체의 부모는이 경로의 루트 구성 요소 (있는 경우)와 디렉토리 계층의 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 것을 제외하고 경로의 각 요소로 구성됩니다 . 이 방법은 파일 시스템에 액세스하지 않습니다. 경로 나 그 부모가 존재하지 않을 수 있습니다. 또한이 방법은 &quot;.&quot;와 같은 특수 이름을 제거하지 않습니다. 및 일부 구현에 사용될 수있는 &quot;..&quot; 예를 들어 UNIX에서 &quot; &lt;code&gt;/a/b/c&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;/a/b&lt;/code&gt; &quot;이고 &lt;code&gt;&quot;x/y/.&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;x/y&lt;/code&gt; &quot;입니다. &lt;em&gt;쉘과 같은&lt;/em&gt; 탐색이 필요한 경우 중복 이름을 제거하기 &lt;a href=&quot;path#normalize--&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 방법을 normalize 방법 과 함께 사용할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8eec86ed61bb41b453fe46f696b36fc01364efd8" translate="yes" xml:space="preserve">
          <source>The parentX, parentY, width and height parameters form a Rectangle in this Raster's coordinate space, indicating the area of pixels to be shared. An error will be thrown if this Rectangle is not contained with the bounds of the current Raster.</source>
          <target state="translated">parentX, parentY, width 및 height 매개 변수는이 Raster의 좌표 공간에서 Rectangle을 형성하여 공유 할 픽셀 영역을 나타냅니다. 이 Rectangle이 현재 Raster의 경계에 포함되어 있지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a015d5afd091b8ea8039b136a7b37b297cf71397" translate="yes" xml:space="preserve">
          <source>The parentX, parentY, width and height parameters form a Rectangle in this WritableRaster's coordinate space, indicating the area of pixels to be shared. An error will be thrown if this Rectangle is not contained with the bounds of the current WritableRaster.</source>
          <target state="translated">parentX, parentY, width 및 height 매개 변수는이 WritableRaster의 좌표 공간에서 Rectangle을 형성하여 공유 할 픽셀 영역을 나타냅니다. 이 Rectangle이 현재 WritableRaster의 경계에 포함되어 있지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a34ccef159a0d71e1f63c70bb6fe8aedb77a7a54" translate="yes" xml:space="preserve">
          <source>The parsed value. Passing an integer that corresponds to a known name (e.g., 700) will return the associated name (e.g., &lt;code&gt;CONFIG&lt;/code&gt;). Passing an integer that does not (e.g., 1) will return a new level name initialized to that value.</source>
          <target state="translated">파싱 ​​된 값입니다. 알려진 이름 (예 : 700)에 해당하는 정수를 전달하면 관련 이름 (예 : &lt;code&gt;CONFIG&lt;/code&gt; ) 이 반환됩니다 . 그렇지 않은 정수 (예 : 1)를 전달하면 해당 값으로 초기화 된 새 수준 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c80c4671a6882e49c3c95f5d8d0a916dc52dfeed" translate="yes" xml:space="preserve">
          <source>The parser drives the ParserCallback, which is provided by HTMLDocument. To change the callback, subclass HTMLDocument and reimplement the createDefaultDocument method to return document that produces a different reader. The reader controls how the document is structured. Although the Document provides HTML support by default, there is nothing preventing support of non-HTML tags that result in alternative element structures.</source>
          <target state="translated">파서는 HTMLDocument에서 제공하는 ParserCallback을 구동합니다. 콜백을 변경하려면 HTMLDocument를 하위 클래스로 만들고 createDefaultDocument 메서드를 다시 구현하여 다른 판독기를 생성하는 문서를 반환합니다. 독자는 문서의 구조를 제어합니다. 문서는 기본적으로 HTML 지원을 제공하지만 대체 요소 구조를 생성하는 비 HTML 태그의 지원을 방해하는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="0958e538d194ee775ec5a4fae0f7ef159a0e04df" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 탐욕스럽게 작동하여 가능한 한 많은 숫자를받습니다. 이 동작은 '인접 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="21ff5f3cdc66539833c1fbafaf60db7a54685bb2" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 최대한 많은 자릿수를 허용하면서 탐욕스럽게 동작합니다. 이 동작은 '인접한 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c09eecf6e6b5152ce4eaa50a2e9cb6e5669cb3d" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, requiring one digit, but accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 탐욕스럽게 작동하여 한 자리가 필요하지만 가능한 한 많은 자리를 허용합니다. 이 동작은 '인접 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f6b73693478a0455ddabfd20c4e13a83419854e" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, requiring one digit, but accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 탐욕스럽게 동작하며 한 자리를 요구하지만 가능한 한 많은 자리를 받아들입니다. 이 동작은 '인접한 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b2566f1d573d8a0c323846050643ae43f48e34c" translate="yes" xml:space="preserve">
          <source>The parser is replaceable. The default parser is the Hot Java parser which is DTD based. A different DTD can be used, or an entirely different parser can be used. To change the parser, reimplement the getParser method. The default parser is dynamically loaded when first asked for, so the class files will never be loaded if an alternative parser is used. The default parser is in a separate package called parser below this package.</source>
          <target state="translated">파서는 교체 가능합니다. 기본 구문 분석기는 DTD 기반의 Hot Java 구문 분석기입니다. 다른 DTD를 사용하거나 완전히 다른 파서를 사용할 수 있습니다. 파서를 변경하려면 getParser 메서드를 다시 구현하십시오. 기본 구문 분석기는 처음 요청할 때 동적으로로드되므로 대체 구문 분석기가 사용되는 경우 클래스 파일이로드되지 않습니다. 기본 구문 분석기는이 패키지 아래의 구문 분석기라는 별도의 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db896e88ea1524b86eec66607087c03e131c1fe" translate="yes" xml:space="preserve">
          <source>The parser treats \r and \r\n as \n. Newlines after starttags and before end tags are ignored just as specified in the SGML/HTML specification.</source>
          <target state="translated">파서는 \ r 및 \ r \ n을 \ n으로 취급합니다. 시작 태그 뒤와 끝 태그 앞의 줄 바꿈은 SGML / HTML 사양에 지정된대로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f79566e8db3ace95b06a78c81cfb5c3a069df4ea" translate="yes" xml:space="preserve">
          <source>The parser will call this method after each &lt;code&gt;Element&lt;/code&gt; start tag has been scanned, but before the remainder of the &lt;code&gt;Element&lt;/code&gt; is processed.</source>
          <target state="translated">파서는 각 &lt;code&gt;Element&lt;/code&gt; 시작 태그를 스캔 한 후 나머지 &lt;code&gt;Element&lt;/code&gt; 가 처리 되기 전에이 메서드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="89bb0dda1c5e645ee858d42db8076dbafa59d5c5" translate="yes" xml:space="preserve">
          <source>The parser will call this method after each &lt;code&gt;Element&lt;/code&gt; start tag has been scanned, but before the remainder of the &lt;code&gt;Element&lt;/code&gt; is processed. The intent is to allow the element, including any children, to be efficiently skipped. Note that only element nodes are passed to the &lt;code&gt;startElement&lt;/code&gt; function.</source>
          <target state="translated">파서는 각 &lt;code&gt;Element&lt;/code&gt; 시작 태그를 스캔 한 후 나머지 &lt;code&gt;Element&lt;/code&gt; 가 처리 되기 전에이 메서드를 호출 합니다. 의도는 모든 자식을 포함하여 요소를 효율적으로 건너 뛸 수 있도록하는 것입니다. 요소 노드 만 &lt;code&gt;startElement&lt;/code&gt; 함수에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="25bb83472b4f57122efa4cb36da17a7150c525d7" translate="yes" xml:space="preserve">
          <source>The parser will call this method before opening any external entity except the top-level document entity. Such entities include the external DTD subset and external parameter entities referenced within the DTD (in either case, only if the parser reads external parameter entities), and external general entities referenced within the document element (if the parser reads external general entities). The application may request that the parser locate the entity itself, that it use an alternative URI, or that it use data provided by the application (as a character or byte input stream).</source>
          <target state="translated">파서는 최상위 문서 엔터티를 제외한 외부 엔터티를 열기 전에이 메서드를 호출합니다. 이러한 엔터티에는 DTD 내에서 참조되는 외부 DTD 하위 집합 및 외부 매개 변수 엔터티 (두 경우 모두 파서가 외부 매개 변수 엔터티를 읽는 경우에만 해당) 및 문서 요소 내에서 참조되는 외부 일반 엔터티 (파서가 외부 일반 엔터티를 읽는 경우)가 포함됩니다. 응용 프로그램은 파서가 엔티티 자체를 찾거나 대체 URI를 사용하거나 응용 프로그램에서 제공하는 데이터 (문자 또는 바이트 입력 스트림)를 사용하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ee7fce3ce38754400a5fb2ffa707a2159a2a86a" translate="yes" xml:space="preserve">
          <source>The parsing and conversion to a path object is inherently implementation dependent. In the simplest case, the path string is rejected, and &lt;a href=&quot;invalidpathexception&quot;&gt;&lt;code&gt;InvalidPathException&lt;/code&gt;&lt;/a&gt; thrown, if the path string contains characters that cannot be converted to characters that are &lt;em&gt;legal&lt;/em&gt; to the file store. For example, on UNIX systems, the NUL (\u0000) character is not allowed to be present in a path. An implementation may choose to reject path strings that contain names that are longer than those allowed by any file store, and where an implementation supports a complex path syntax, it may choose to reject path strings that are &lt;em&gt;badly formed&lt;/em&gt;.</source>
          <target state="translated">경로 객체에 대한 구문 분석 및 변환은 본질적으로 구현에 따라 다릅니다. 가장 간단한 경우, 경로 문자열 에 파일 저장소에 &lt;em&gt;적합한&lt;/em&gt; 문자로 변환 할 수없는 문자가 포함 된 경우 경로 문자열이 거부되고 &lt;a href=&quot;invalidpathexception&quot;&gt; &lt;code&gt;InvalidPathException&lt;/code&gt; 이&lt;/a&gt; 발생 합니다. 예를 들어, UNIX 시스템에서 NUL (\ u0000) 문자는 경로에 존재할 수 없습니다. 구현은 파일 저장소가 허용하는 것보다 긴 이름을 포함하는 경로 문자열을 거부하도록 선택할 수 있으며 구현이 복잡한 경로 구문을 지원하는 경우 &lt;em&gt;잘못 구성된&lt;/em&gt; 경로 문자열을 거부하도록 선택할 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58366cc3fc3392a36ac4de8d54ae2345f03badf0" translate="yes" xml:space="preserve">
          <source>The parsing is done field by field so that the following holds for any lexically correct String x:</source>
          <target state="translated">구문 분석은 필드별로 수행되므로 어휘 적으로 올바른 문자열 x에 대해 다음이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="70a1b9684ff0e071a82a4339efad58504e82add3" translate="yes" xml:space="preserve">
          <source>The part of the destination lying inside of the source is composited over the source and replaces the destination (Porter-Duff Destination Atop Source rule).</source>
          <target state="translated">소스 내부에있는 대상 부분은 소스 위에 합성되어 대상을 대체합니다 (Porter-Duff Destination Atop Source 규칙).</target>
        </trans-unit>
        <trans-unit id="1da589b57f7260e6e37c7640ceeaac089943225b" translate="yes" xml:space="preserve">
          <source>The part of the destination lying inside of the source replaces the destination (Porter-Duff Destination In Source rule).</source>
          <target state="translated">소스 내부에있는 대상 부분이 대상을 대체합니다 (소스의 Porter-Duff 대상 규칙).</target>
        </trans-unit>
        <trans-unit id="dcfe0a22ae97cb137aea5a3bbe6c1a59738245d0" translate="yes" xml:space="preserve">
          <source>The part of the destination lying outside of the source replaces the destination (Porter-Duff Destination Held Out By Source rule).</source>
          <target state="translated">소스 외부에있는 대상 부분이 대상을 대체합니다 (소스에 의해 보관 된 Porter-Duff 대상 규칙).</target>
        </trans-unit>
        <trans-unit id="0514c11ef515545f2db88b599f4ee46a343c496c" translate="yes" xml:space="preserve">
          <source>The part of the link name that has not been resolved. It is a composite name. It can be null, which means the link remaining name field has not been set.</source>
          <target state="translated">해결되지 않은 링크 이름 부분. 합성 이름입니다. 널 (null) 일 수 있으며, 이는 링크 나머지 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="47baf3ca1b3134d4434d6cb4c6eec321ec81a768" translate="yes" xml:space="preserve">
          <source>The part of the link name that was resolved successfully. It is a composite name. It can be null, which means the link resolved name field has not been set.</source>
          <target state="translated">성공적으로 해결 된 링크 이름 부분. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 링크 해석 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="32726d1c2037f095bb11ef491521f5e2b8d6ac95" translate="yes" xml:space="preserve">
          <source>The part of the name that has not been resolved. It is a composite name. It can be null, which means the remaining name field has not been set.</source>
          <target state="translated">확인되지 않은 이름의 일부입니다. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 나머지 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ec9433b1d02006377972147afe60dd9073ccb8e0" translate="yes" xml:space="preserve">
          <source>The part of the name that was resolved successfully. It is a composite name. It can be null, which means the resolved name field has not been set.</source>
          <target state="translated">성공적으로 해결 된 이름의 일부입니다. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 해석 된 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6d1c09fb04aadbb62a7a9fde5b33cff4c271e44c" translate="yes" xml:space="preserve">
          <source>The part of the source lying inside of the destination is composited onto the destination (Porter-Duff Source Atop Destination rule).</source>
          <target state="translated">목적지 내부에있는 소스의 일부는 목적지에 합성됩니다 (Porter-Duff Source Atop Destination 규칙).</target>
        </trans-unit>
        <trans-unit id="40baec417b1738d9f463750ccea01809d5a85bba" translate="yes" xml:space="preserve">
          <source>The part of the source lying inside of the destination replaces the destination (Porter-Duff Source In Destination rule).</source>
          <target state="translated">목적지 내부에있는 소스 부분이 목적지를 대체합니다 (Porter-Duff Source In Destination 규칙).</target>
        </trans-unit>
        <trans-unit id="0edd66952700232dfab5dd336b9d5a21df59003b" translate="yes" xml:space="preserve">
          <source>The part of the source lying outside of the destination replaces the destination (Porter-Duff Source Held Out By Destination rule).</source>
          <target state="translated">대상 외부에있는 원본 부분이 대상을 대체합니다 (대상에 의해 보관 된 Porter-Duff 원본 규칙).</target>
        </trans-unit>
        <trans-unit id="76bc3c459fb6e604ce60cb4e6b1d79dd10a65b80" translate="yes" xml:space="preserve">
          <source>The part of the source that lies outside of the destination is combined with the part of the destination that lies outside of the source (Porter-Duff Source Xor Destination rule).</source>
          <target state="translated">대상 외부에있는 원본 부분은 원본 외부에있는 대상 부분과 결합됩니다 (Porter-Duff Source Xor 대상 규칙).</target>
        </trans-unit>
        <trans-unit id="a0ccdd4edd6b9daa6601aef32f68b66801d49f2d" translate="yes" xml:space="preserve">
          <source>The particular &lt;code&gt;ImageReader&lt;/code&gt; implementation may choose how often to provide updates. Each update specifies that a given region of the image has been updated since the last update. A region is described by its spatial bounding box (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt;); X and Y subsampling factors (&lt;code&gt;periodX&lt;/code&gt; and &lt;code&gt;periodY&lt;/code&gt;); and a set of updated bands (&lt;code&gt;bands&lt;/code&gt;). For example, the update:</source>
          <target state="translated">특정 &lt;code&gt;ImageReader&lt;/code&gt; 구현은 업데이트를 제공하는 빈도를 선택할 수 있습니다. 각 업데이트는 마지막 업데이트 이후 이미지의 특정 영역이 업데이트되었음을 ​​지정합니다. 영역은 공간 경계 상자 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; )로 설명됩니다. X 및 Y 서브 샘플링 인자 ( &lt;code&gt;periodX&lt;/code&gt; 및 &lt;code&gt;periodY&lt;/code&gt; ); 및 업데이트 된 밴드 세트 ( &lt;code&gt;bands&lt;/code&gt; ). 예를 들어, 업데이트 :</target>
        </trans-unit>
        <trans-unit id="2d05bd905575708b902adb79797980be7e49876a" translate="yes" xml:space="preserve">
          <source>The particular compression scheme to be used can be specified by using the &lt;code&gt;setCompressionType()&lt;/code&gt; method with the appropriate type string. The compression scheme specified will be honored if and only if it is compatible with the type of image being written. If the specified compression scheme is not compatible with the type of image being written then the &lt;code&gt;IOException&lt;/code&gt; will be thrown by the BMP image writer. If the compression type is not set explicitly then &lt;code&gt;getCompressionType()&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;. In this case the BMP image writer will select a compression type that supports encoding of the given image without loss of the color resolution.</source>
          <target state="translated">사용되는 특정 압축 체계 는 적절한 유형 문자열과 함께 &lt;code&gt;setCompressionType()&lt;/code&gt; 메소드를 사용하여 지정할 수 있습니다 . 지정된 압축 방식은 작성중인 이미지 유형과 호환되는 경우에만 적용됩니다. 지정된 압축 방식이 기록중인 이미지 유형과 호환되지 않으면 BMP 이미지 기록기에 의해 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다. 압축 유형이 명시 적으로 설정되지 않은 경우 &lt;code&gt;getCompressionType()&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 이 경우 BMP 이미지 기록기는 색상 해상도 손실없이 지정된 이미지의 인코딩을 지원하는 압축 유형을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d678e3b47db28315a51c9392f3290d72efd52628" translate="yes" xml:space="preserve">
          <source>The passed in &lt;code&gt;Graphics&lt;/code&gt; object might have a transform other than the identify transform installed on it. In this case, you might get unexpected results if you cumulatively apply another transform.</source>
          <target state="translated">전달 된 &lt;code&gt;Graphics&lt;/code&gt; 객체에 식별 변환이 아닌 다른 변환이 설치되어있을 수 있습니다. 이 경우 다른 변환을 누적 적용하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8241d354a88f83dd6e313eef3dc68fb3e944175" translate="yes" xml:space="preserve">
          <source>The password can be viewed as some kind of raw key material, from which the encryption mechanism that uses it derives a cryptographic key.</source>
          <target state="translated">암호는 일종의 원시 키 자료로 볼 수 있으며,이를 사용하는 암호화 메커니즘은 암호 키를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="820e2577f359bf6935013e53ac3bf2a5b32541fa" translate="yes" xml:space="preserve">
          <source>The past notifications sending on/off flag value.</source>
          <target state="translated">과거 / 이전 알림 전송 / 해제 플래그 값.</target>
        </trans-unit>
        <trans-unit id="2dff58ea6e8968b95e225bc5373e375d5474c33c" translate="yes" xml:space="preserve">
          <source>The path</source>
          <target state="translated">경로</target>
        </trans-unit>
        <trans-unit id="34dc364ae2dbeed42a8b0e59b6b7f50e29642280" translate="yes" xml:space="preserve">
          <source>The path component of a URI, if defined, only contains the slash character (&lt;code&gt;'/'&lt;/code&gt;), the commercial-at character (&lt;code&gt;'@'&lt;/code&gt;), and characters in the</source>
          <target state="translated">URI의 경로 구성 요소에는 정의 된 경우 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; ), 상업 문자 ( &lt;code&gt;'@'&lt;/code&gt; ) 및</target>
        </trans-unit>
        <trans-unit id="ce374624d095692df597972be967a92da604ae1f" translate="yes" xml:space="preserve">
          <source>The path component of a hierarchical URI is itself said to be absolute if it begins with a slash character (&lt;code&gt;'/'&lt;/code&gt;); otherwise it is relative. The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.</source>
          <target state="translated">계층 적 URI의 경로 구성 요소는 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작하는 경우 절대적이라고합니다 . 그렇지 않으면 상대적입니다. 절대적이거나 권한을 지정하는 계층 적 URI의 경로는 항상 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="984a1006edcb13d7a44e0aa4a2152ea60b272a92" translate="yes" xml:space="preserve">
          <source>The path component of this URI, or &lt;code&gt;null&lt;/code&gt; if the path is undefined</source>
          <target state="translated">이 URI의 패스 컴퍼넌트 . 패스가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a70f79521a69bb3942223fa682e3262fee7ae26f" translate="yes" xml:space="preserve">
          <source>The path length constraint has been violated.</source>
          <target state="translated">경로 길이 제약 조건을 위반했습니다.</target>
        </trans-unit>
        <trans-unit id="5c2d067f7af76e2b06945d71f3ec990142c7f99d" translate="yes" xml:space="preserve">
          <source>The pathname string of the parent directory named by this abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent</source>
          <target state="translated">이 추상 패스 명이 가리키는 친 디렉토리의 패스 명 문자열.이 패스 명이 부모를 나타내지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36815dfa099a2085beea9c4219c1336efe128f00" translate="yes" xml:space="preserve">
          <source>The paths returned from &lt;code&gt;getSelectionPaths&lt;/code&gt; are in the same order as those supplied to this method.</source>
          <target state="translated">&lt;code&gt;getSelectionPaths&lt;/code&gt; 에서 반환 된 경로는 이 메서드에 제공된 경로 와 동일한 순서입니다.</target>
        </trans-unit>
        <trans-unit id="44bfbe0740e4812ab2ebef01403857fd4763cbc0" translate="yes" xml:space="preserve">
          <source>The pattern for which this matcher was created</source>
          <target state="translated">이 매 처가 작성된 패턴</target>
        </trans-unit>
        <trans-unit id="df695ca495032754cb1e1d72664b6f7e2ce057b1" translate="yes" xml:space="preserve">
          <source>The pen width, measured perpendicularly to the pen trajectory.</source>
          <target state="translated">펜 궤적에 수직으로 측정 된 펜 너비입니다.</target>
        </trans-unit>
        <trans-unit id="228163f26ece9e76769fe19d43640bb8467f3d60" translate="yes" xml:space="preserve">
          <source>The period added is a multiple of this unit. For example, this method could be used to add &quot;3 days&quot; to a date by calling this method on the instance representing &quot;days&quot;, passing the date and the period &quot;3&quot;. The period to be added may be negative, which is equivalent to subtraction.</source>
          <target state="translated">추가 된 기간은이 단위의 배수입니다. 예를 들어, &quot;days&quot;를 나타내는 인스턴스에서이 메소드를 호출하고 날짜와 기간을 &quot;3&quot;으로 전달하여이 메소드를 사용하여 날짜에 &quot;3 일&quot;을 추가 할 수 있습니다. 더해지는주기는 음수 일 수 있으며, 이는 빼기와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fdc88c8af0c7b558ba1c4c23f7e65140ebfa762" translate="yes" xml:space="preserve">
          <source>The period character &lt;code&gt;'.'&lt;/code&gt; (&lt;code&gt;'\u002e'&lt;/code&gt;, &lt;small&gt;FULL STOP&lt;/small&gt;),</source>
          <target state="translated">마침표 문자 &lt;code&gt;'.'&lt;/code&gt; ( &lt;code&gt;'\u002e'&lt;/code&gt; , 완전 &lt;small&gt;정지&lt;/small&gt; ),</target>
        </trans-unit>
        <trans-unit id="8a43a4749a0092ff01f681602eba4d1752639395" translate="yes" xml:space="preserve">
          <source>The period is defined by the chronology. It controls the supported units and restricts addition/subtraction to &lt;code&gt;ChronoLocalDate&lt;/code&gt; instances of the same chronology.</source>
          <target state="translated">기간은 연대기에 의해 정의됩니다. 지원되는 단위를 제어하고 같은 연대기의 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 인스턴스에 더하기 / 빼기를 ​​제한 합니다.</target>
        </trans-unit>
        <trans-unit id="1a70990b9e6545d7eddd1d2d67af5b8ba6080247" translate="yes" xml:space="preserve">
          <source>The period is modeled as a directed amount of time, meaning that individual parts of the period may be negative.</source>
          <target state="translated">기간은 지정된 시간으로 모델링되므로 기간의 개별 부분이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582b9e9609272bc13dc68aa8a72ae7a31ac8a03b" translate="yes" xml:space="preserve">
          <source>The permission for which the &lt;code&gt;SecurityManager&lt;/code&gt; will check when code that is running an application with a &lt;code&gt;SecurityManager&lt;/code&gt; enabled, calls the &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; (deprecated) method, &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; method, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; method, &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; method, or the &lt;code&gt;Connection.abort&lt;/code&gt; method.</source>
          <target state="translated">있는 권한 &lt;code&gt;SecurityManager&lt;/code&gt; A의 응용 프로그램 실행시 코드를 확인합니다 &lt;code&gt;SecurityManager&lt;/code&gt; 사용할 수는 호출 &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; 메소드 (추천되지 않는다), &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; 의 방법, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; 의 , 방법을 &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; 메서드 또는 &lt;code&gt;Connection.abort&lt;/code&gt; 메서드.</target>
        </trans-unit>
        <trans-unit id="7596472c88903a656ba2e77a47db428db58c9b86" translate="yes" xml:space="preserve">
          <source>The permission for which the &lt;code&gt;SecurityManager&lt;/code&gt; will check when code that is running an application with a &lt;code&gt;SecurityManager&lt;/code&gt; enabled, calls the &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; (deprecated) method, &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; method, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; method, &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; method, or the &lt;code&gt;Connection.abort&lt;/code&gt; method. If there is no &lt;code&gt;SQLPermission&lt;/code&gt; object, these methods throw a &lt;code&gt;java.lang.SecurityException&lt;/code&gt; as a runtime exception.</source>
          <target state="translated">있는 권한 &lt;code&gt;SecurityManager&lt;/code&gt; A의 응용 프로그램 실행시 코드를 확인합니다 &lt;code&gt;SecurityManager&lt;/code&gt; 사용할 수는 호출 &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; 메소드 (추천되지 않는다), &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; 의 방법, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; 의 , 방법을 &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; 메서드 또는 &lt;code&gt;Connection.abort&lt;/code&gt; 메서드. &lt;code&gt;SQLPermission&lt;/code&gt; 오브젝트 가없는 경우 이러한 메소드 는 런타임 예외로 &lt;code&gt;java.lang.SecurityException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="905e0e83c9c4d3f7868b0477d055820ab11f5e8d" translate="yes" xml:space="preserve">
          <source>The permission returned may dependent upon the state of the connection. For example, the permission before connecting may be different from that after connecting. For example, an HTTP sever, say foo.com, may redirect the connection to a different host, say bar.com. Before connecting the permission returned by the connection will represent the permission needed to connect to foo.com, while the permission returned after connecting will be to bar.com.</source>
          <target state="translated">반환 된 권한은 연결 상태에 따라 달라질 수 있습니다. 예를 들어 연결 전의 권한이 연결 후의 권한과 다를 수 있습니다. 예를 들어 foo.com과 같은 HTTP 서버는 다른 호스트 (예 : bar.com)로 연결을 리디렉션 할 수 있습니다. 연결 전에 반환 된 권한은 foo.com에 연결하는 데 필요한 권한을 나타내며 연결 후 반환 된 권한은 bar.com입니다.</target>
        </trans-unit>
        <trans-unit id="9aec82e1b8e6d992b0690a908ac3aedc9b31e177" translate="yes" xml:space="preserve">
          <source>The permission which the SecurityManager will check when code that is running with a SecurityManager calls methods defined in the management interface for the Java platform.</source>
          <target state="translated">SecurityManager로 실행되는 코드가 Java 플랫폼의 관리 인터페이스에 정의 된 메소드를 호출 할 때 SecurityManager가 확인하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="e5faa7a6949030f63d05138d5d40aa6ac04a730d" translate="yes" xml:space="preserve">
          <source>The permission which the SecurityManager will check when code that is running with a SecurityManager calls one of the logging control methods (such as Logger.setLevel).</source>
          <target state="translated">SecurityManager로 실행중인 코드가 로깅 제어 방법 중 하나 (예 : Logger.setLevel)를 호출 할 때 SecurityManager가 확인하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="67f61541f09f163aad875955ec40973cb856f479" translate="yes" xml:space="preserve">
          <source>The permissions granted to this domain are dynamic, i.e. invoking the &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt;&lt;code&gt;staticPermissionsOnly()&lt;/code&gt;&lt;/a&gt; method returns false. They include both the static permissions passed to this constructor, and any permissions granted to this domain by the current Policy at the time a permission is checked.</source>
          <target state="translated">이 도메인에 부여 된 권한은 동적입니다. 즉, &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt; &lt;code&gt;staticPermissionsOnly()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하면 false가 반환됩니다. 여기에는이 생성자에 전달 된 정적 권한과 권한을 확인할 때 현재 정책에서이 도메인에 부여한 모든 권한이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c63c09e1919a0b385305981a2835a097860b9eda" translate="yes" xml:space="preserve">
          <source>The permissions granted to this domain are static, i.e. invoking the &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt;&lt;code&gt;staticPermissionsOnly()&lt;/code&gt;&lt;/a&gt; method returns true. They contain only the ones passed to this constructor and the current Policy will not be consulted.</source>
          <target state="translated">이 도메인에 부여 된 권한은 정적입니다. 즉, &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt; &lt;code&gt;staticPermissionsOnly()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하면 true가 반환됩니다. 여기에는이 생성자에 전달 된 항목 만 포함되며 현재 정책은 참조되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89058a6566fae0c8d5c5fdda2b2372f796569fb3" translate="yes" xml:space="preserve">
          <source>The physical connection is not closed until the connection pool manager calls the &lt;code&gt;PooledConnection&lt;/code&gt; method &lt;code&gt;close&lt;/code&gt;. This method is generally called to have an orderly shutdown of the server or if a fatal error has made the connection unusable.</source>
          <target state="translated">연결 풀 관리자가 &lt;code&gt;PooledConnection&lt;/code&gt; 메소드 &lt;code&gt;close&lt;/code&gt; 를 호출 할 때까지 물리적 연결은 닫히지 않습니다 . 이 메서드는 일반적으로 서버를 순서대로 종료하거나 치명적인 오류로 인해 연결을 사용할 수 없게 된 경우 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63cef99a21c3ce784ef3880657559d49f21aea55" translate="yes" xml:space="preserve">
          <source>The pixel (0, 0) in the coordinate space of the graphics context corresponds to the origin of the splash screen native window bounds (see &lt;a href=&quot;#getBounds()&quot;&gt;&lt;code&gt;getBounds()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">그래픽 컨텍스트의 좌표 공간에있는 픽셀 (0, 0)은 스플래시 화면 기본 창 경계의 원점에 해당합니다 ( &lt;a href=&quot;#getBounds()&quot;&gt; &lt;code&gt;getBounds()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="500d2293e97237119e1983a5c3e9a605e180c0c9" translate="yes" xml:space="preserve">
          <source>The pixels of the image are delivered using one or more calls to the setPixels method.</source>
          <target state="translated">이미지의 픽셀은 setPixels 메소드에 대한 하나 이상의 호출을 사용하여 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b32a76182c825641c5cc61b6489eb4335615b5b4" translate="yes" xml:space="preserve">
          <source>The pixels of the image are delivered using one or more calls to the setPixels method. Each call specifies the location and size of the rectangle of source pixels that are contained in the array of pixels. The specified ColorModel object should be used to convert the pixels into their corresponding color and alpha components. Pixel (m,n) is stored in the pixels array at index (n * scansize + m + off). The pixels delivered using this method are all stored as ints. this method are all stored as ints.</source>
          <target state="translated">이미지의 픽셀은 setPixels 메소드에 대한 하나 이상의 호출을 사용하여 전달됩니다. 각 호출은 픽셀 배열에 포함 된 소스 픽셀 사각형의 위치와 크기를 지정합니다. 지정된 ColorModel 객체를 사용하여 픽셀을 해당 색상 및 알파 구성 요소로 변환해야합니다. 픽셀 (m, n)은 인덱스 (n * scansize + m + off)에서 픽셀 배열에 저장됩니다. 이 방법을 사용하여 전달 된 픽셀은 모두 int로 저장됩니다. 이 메서드는 모두 int로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f611275393252bc802d72fdd641a2615171a85f6" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in (multiples of) complete scanlines at a time.</source>
          <target state="translated">픽셀은 한 번에 (여러 개의) 완전한 스캔 라인으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2fece7997ef4b9cf1e323d0a1efd50cb013153b0" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a random order.</source>
          <target state="translated">The pixels will be delivered in a random order.</target>
        </trans-unit>
        <trans-unit id="cf16e6291c890f1d381931538f7295e2f5706d87" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a random order. This tells the ImageConsumer not to use any optimizations that depend on the order of pixel delivery, which should be the default assumption in the absence of any call to the setHints method.</source>
          <target state="translated">The pixels will be delivered in a random order. This tells the ImageConsumer not to use any optimizations that depend on the order of pixel delivery, which should be the default assumption in the absence of any call to the setHints method.</target>
        </trans-unit>
        <trans-unit id="9c2099a9c74f962fd6a4d8576f2e1d315893b01f" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a single pass.</source>
          <target state="translated">The pixels will be delivered in a single pass.</target>
        </trans-unit>
        <trans-unit id="92bb6ee63ae68c3bc426e959c05f0f0b4310d5a1" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a single pass. Each pixel will appear in only one call to any of the setPixels methods. An example of an image format which does not meet this criterion is a progressive JPEG image which defines pixels in multiple passes, each more refined than the previous.</source>
          <target state="translated">The pixels will be delivered in a single pass. Each pixel will appear in only one call to any of the setPixels methods. An example of an image format which does not meet this criterion is a progressive JPEG image which defines pixels in multiple passes, each more refined than the previous.</target>
        </trans-unit>
        <trans-unit id="6310f53f396133fc271c197615afe20c6a96988b" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in top-down, left-to-right order.</source>
          <target state="translated">The pixels will be delivered in top-down, left-to-right order.</target>
        </trans-unit>
        <trans-unit id="9d90b3b0c7f4fd76e2cdd5db2a7c785664e9f012" translate="yes" xml:space="preserve">
          <source>The placeholder parameters set with the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods are stored as objects in an internal &lt;code&gt;Hashtable&lt;/code&gt; object. Primitives are stored as their &lt;code&gt;Object&lt;/code&gt; type. For example, &lt;code&gt;byte&lt;/code&gt; is stored as &lt;code&gt;Byte&lt;/code&gt; object, and &lt;code&gt;int&lt;/code&gt; is stored as an &lt;code&gt;Integer&lt;/code&gt; object. When the method &lt;code&gt;execute&lt;/code&gt; is called, the values in the &lt;code&gt;Hashtable&lt;/code&gt; object are substituted for the appropriate placeholder parameters in the command.</source>
          <target state="translated">The placeholder parameters set with the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods are stored as objects in an internal &lt;code&gt;Hashtable&lt;/code&gt; object. Primitives are stored as their &lt;code&gt;Object&lt;/code&gt; type. For example, &lt;code&gt;byte&lt;/code&gt; is stored as &lt;code&gt;Byte&lt;/code&gt; object, and &lt;code&gt;int&lt;/code&gt; is stored as an &lt;code&gt;Integer&lt;/code&gt; object. When the method &lt;code&gt;execute&lt;/code&gt; is called, the values in the &lt;code&gt;Hashtable&lt;/code&gt; object are substituted for the appropriate placeholder parameters in the command.</target>
        </trans-unit>
        <trans-unit id="a342a1ca910ba03ac856dd3cb6b496330e72e4ed" translate="yes" xml:space="preserve">
          <source>The placement of the scrollbars is controlled by platform-specific properties set by the user outside of the program.</source>
          <target state="translated">The placement of the scrollbars is controlled by platform-specific properties set by the user outside of the program.</target>
        </trans-unit>
        <trans-unit id="75c5e59d7fc130499537b22ca3f6a19ddfdef68a" translate="yes" xml:space="preserve">
          <source>The plain style constant.</source>
          <target state="translated">The plain style constant.</target>
        </trans-unit>
        <trans-unit id="5a84f21cac12242c01031819d62ec386192e9637" translate="yes" xml:space="preserve">
          <source>The platform &lt;code&gt;ClassLoader&lt;/code&gt;.</source>
          <target state="translated">The platform &lt;code&gt;ClassLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d191e3661c045abc37d149ffba48109cff4ab5bb" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt; , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; , and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</target>
        </trans-unit>
        <trans-unit id="2ceb5ca739bd037a631c6a8df267fc3ed5ce1040" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation, overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt; , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; , and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation, overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</target>
        </trans-unit>
        <trans-unit id="3ddf2138bdbeea3a72c2017234d8cedbfdba2c4d" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment, decrement, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">이 플랫폼은 int 및 long 기본 유형의 부호있는 2의 보수 정수 산술을 사용합니다. 개발자는 산술 연산이 일관되게 올바른 결과를 생성 할 수 있도록 기본 유형을 선택해야합니다. 어떤 경우에는 연산이 계산의 값 범위를 오버플로하지 않습니다. 가장 좋은 방법은 오버플로를 피하기 위해 기본 유형과 알고리즘을 선택하는 것입니다. 크기가 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 이고 오버플로 오류를 감지 &lt;code&gt;addExact&lt;/code&gt; 경우 addExact , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; 및 &lt;code&gt;toIntExact&lt;/code&gt; 메소드 에서 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생합니다.결과가 오버플로 될 때 나누기, 절대 값, 증분, 감소 및 부정 오버플로와 같은 다른 산술 연산의 경우 특정 최소값 또는 최대 값으로 만 발생하며, 최소값 또는 최대 값에 대해 적절하게 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7521e50eec810dafda8ec390ca964f1fb534790" translate="yes" xml:space="preserve">
          <source>The plus character &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;, &lt;small&gt;PLUS SIGN&lt;/small&gt;),</source>
          <target state="translated">더하기 문자 &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;'\u002b'&lt;/code&gt; , &lt;small&gt;PLUS SIGN&lt;/small&gt; ),</target>
        </trans-unit>
        <trans-unit id="8de422a879c63cd1d08f600a6e2474b68479ffa1" translate="yes" xml:space="preserve">
          <source>The plus sign &quot;&lt;code&gt;+&lt;/code&gt;&quot; is converted into a space character &quot; &quot; .</source>
          <target state="translated">더하기 부호 &quot; &lt;code&gt;+&lt;/code&gt; &quot;는 공백 문자 &quot;&quot;로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e85f9897d05dda5c28cb4704b1031cfc583d8bdb" translate="yes" xml:space="preserve">
          <source>The point size of this &lt;code&gt;Font&lt;/code&gt; in &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">The point size of this &lt;code&gt;Font&lt;/code&gt; in &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e05bc968c4e3e94ec2209d4abaf443fe21787fa" translate="yes" xml:space="preserve">
          <source>The point size of this &lt;code&gt;Font&lt;/code&gt;, rounded to integer.</source>
          <target state="translated">The point size of this &lt;code&gt;Font&lt;/code&gt; , rounded to integer.</target>
        </trans-unit>
        <trans-unit id="770068703e30a0ae5899254519c58354757383e7" translate="yes" xml:space="preserve">
          <source>The policies can be certificate-based or may depend on other authentication schemes.</source>
          <target state="translated">정책은 인증서 기반이거나 다른 인증 체계에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9410b63b7333b991d16e974b0ea1ae55586212" translate="yes" xml:space="preserve">
          <source>The policy constraints have been violated.</source>
          <target state="translated">정책 제약 조건이 위반되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b63ad61faf90a50a857b840faad61a57d9a475d" translate="yes" xml:space="preserve">
          <source>The policy for a Java runtime (specifying which permissions are available for code from various principals) is represented by a Policy object. Whenever a Policy is initialized or refreshed, Permission objects of appropriate classes are created for all permissions allowed by the Policy.</source>
          <target state="translated">Java 런타임에 대한 정책 (다양한 주체의 코드에 사용 가능한 권한 지정)은 Policy 개체로 표시됩니다. 정책을 초기화하거나 새로 고칠 때마다 정책에서 허용하는 모든 권한에 대해 적절한 클래스의 권한 개체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="744c3ae06df1c4965a33f02db62c6df02c922313" translate="yes" xml:space="preserve">
          <source>The poolable value of a statement is applicable to both internal statement caches implemented by the driver and external statement caches implemented by application servers and other applications.</source>
          <target state="translated">The poolable value of a statement is applicable to both internal statement caches implemented by the driver and external statement caches implemented by application servers and other applications.</target>
        </trans-unit>
        <trans-unit id="82fae92e0d4dd371e91f2864a390bac7d0eb3216" translate="yes" xml:space="preserve">
          <source>The pooled connection closed by the application</source>
          <target state="translated">The pooled connection closed by the application</target>
        </trans-unit>
        <trans-unit id="dfaf71328abec9e71a671eccc845d3121c2b0845" translate="yes" xml:space="preserve">
          <source>The pooling manager does not need to call &lt;code&gt;beginRequest&lt;/code&gt; if:</source>
          <target state="translated">The pooling manager does not need to call &lt;code&gt;beginRequest&lt;/code&gt; if:</target>
        </trans-unit>
        <trans-unit id="92fa2d336d7c8160e103bf987c4391a790f21b4b" translate="yes" xml:space="preserve">
          <source>The pooling manager does not need to call &lt;code&gt;endRequest&lt;/code&gt; if:</source>
          <target state="translated">The pooling manager does not need to call &lt;code&gt;endRequest&lt;/code&gt; if:</target>
        </trans-unit>
        <trans-unit id="e90b45718cda98d6bea32baefe82cd6640d8dea0" translate="yes" xml:space="preserve">
          <source>The pooling manager should call &lt;code&gt;beginRequest&lt;/code&gt; on the underlying connection prior to returning a connection to the caller.</source>
          <target state="translated">The pooling manager should call &lt;code&gt;beginRequest&lt;/code&gt; on the underlying connection prior to returning a connection to the caller.</target>
        </trans-unit>
        <trans-unit id="167dc5ab45ec38b0cd73d7df03608399509bba35" translate="yes" xml:space="preserve">
          <source>The pooling manager should call &lt;code&gt;endRequest&lt;/code&gt; on the underlying connection when the applications returns the connection back to the connection pool.</source>
          <target state="translated">The pooling manager should call &lt;code&gt;endRequest&lt;/code&gt; on the underlying connection when the applications returns the connection back to the connection pool.</target>
        </trans-unit>
        <trans-unit id="6926313f48d16c7d56d1e2313f5a4569737b892b" translate="yes" xml:space="preserve">
          <source>The popup layer displays above dialogs. That way, the popup windows associated with combo boxes, tooltips, and other help text will appear above the component, palette, or dialog that generated them.</source>
          <target state="translated">The popup layer displays above dialogs. That way, the popup windows associated with combo boxes, tooltips, and other help text will appear above the component, palette, or dialog that generated them.</target>
        </trans-unit>
        <trans-unit id="2fdaf80d95e0f5e31151be71383e818b9ccadd36" translate="yes" xml:space="preserve">
          <source>The port component of a URI, if defined, is a non-negative integer.</source>
          <target state="translated">URI의 포트 구성 요소는 정의 된 경우 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="465e20b5e3d6b616ff936762b108d3831a17ee64" translate="yes" xml:space="preserve">
          <source>The port component of this URI, or &lt;code&gt;-1&lt;/code&gt; if the port is undefined</source>
          <target state="translated">이 URI의 포트 컴퍼넌트 . 포트가 정의되어 있지 않은 경우는 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2770c496726c2c6a1fb08bb232925adc856e5e7f" translate="yes" xml:space="preserve">
          <source>The port number on the remote host to which this socket is connected.</source>
          <target state="translated">이 소켓이 연결된 원격 호스트의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="771f8b79eb7ead72cd42f8874261ce51d5e9642c" translate="yes" xml:space="preserve">
          <source>The port of the Service URL.</source>
          <target state="translated">The port of the Service URL.</target>
        </trans-unit>
        <trans-unit id="17cb13d2105c7d415ffa295626d4a87fddb85329" translate="yes" xml:space="preserve">
          <source>The port of the Service URL. If no port was specified, the returned value is 0.</source>
          <target state="translated">서비스 URL의 포트입니다. 포트가 지정되지 않은 경우 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="356c1293f756ffbef5fc572bed0d988e81455650" translate="yes" xml:space="preserve">
          <source>The port or portrange is optional. A port specification of the form &quot;N-&quot;, where</source>
          <target state="translated">포트 또는 포트 범위는 선택 사항입니다. &quot;N-&quot;형식의 포트 사양. 여기서</target>
        </trans-unit>
        <trans-unit id="f7a3255c4428117efb808f78d07d1a509a065fee" translate="yes" xml:space="preserve">
          <source>The port to lookup the activation system.</source>
          <target state="translated">The port to lookup the activation system.</target>
        </trans-unit>
        <trans-unit id="a50d6c96a3e4d969a207bbe35ece3c77d64fdbff" translate="yes" xml:space="preserve">
          <source>The portion of a private use subtag prefixed by &quot;lvariant&quot;, if any, is removed and appended to the variant field in the result locale (without case normalization). If it is then empty, the private use subtag is discarded:</source>
          <target state="translated">접두사 &quot;lvariant&quot;가있는 개인용 사용 서브 태그의 부분 (있는 경우)이 제거되고 결과 로케일의 변형 필드에 추가됩니다 (사례 정규화없이). 비어있는 경우 개인용 하위 태그는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dade22179ed59dcfbad33f06553c3e366962e9c8" translate="yes" xml:space="preserve">
          <source>The position</source>
          <target state="translated">위치</target>
        </trans-unit>
        <trans-unit id="be4c1197eaffc124cfb0f83a9e8a33d8b6aa4a29" translate="yes" xml:space="preserve">
          <source>The position argument will indicate the start of the tag, comment or text. Similar to arrays, the first character in the stream has a position of 0. For tags that are implied the position will indicate the location of the next encountered tag. In the first example, the implied start body and html tags will have the same position as the p tag, and the implied end p, html and body tags will all have the same position.</source>
          <target state="translated">The position argument will indicate the start of the tag, comment or text. Similar to arrays, the first character in the stream has a position of 0. For tags that are implied the position will indicate the location of the next encountered tag. In the first example, the implied start body and html tags will have the same position as the p tag, and the implied end p, html and body tags will all have the same position.</target>
        </trans-unit>
        <trans-unit id="e928e79ce165a52965e64d8e1b2549cc6465990b" translate="yes" xml:space="preserve">
          <source>The position for the title.</source>
          <target state="translated">The position for the title.</target>
        </trans-unit>
        <trans-unit id="9d1f5a30624f167466c9de353c1c87fe46188eb5" translate="yes" xml:space="preserve">
          <source>The position of a component within a layer can also be specified directly. Valid positions range from 0 up to one less than the number of components in that layer. A value of -1 indicates the bottommost position. A value of 0 indicates the topmost position. Unlike layer numbers, higher position values are</source>
          <target state="translated">The position of a component within a layer can also be specified directly. Valid positions range from 0 up to one less than the number of components in that layer. A value of -1 indicates the bottommost position. A value of 0 indicates the topmost position. Unlike layer numbers, higher position values are</target>
        </trans-unit>
        <trans-unit id="9aa972c882e959af5cfa74686b743fa2cca90fbe" translate="yes" xml:space="preserve">
          <source>The position of mark in buffer.</source>
          <target state="translated">버퍼에서 마크의 위치.</target>
        </trans-unit>
        <trans-unit id="5a10a32b9ba1b850952eb01a2dac5b8e40ece025" translate="yes" xml:space="preserve">
          <source>The position of this buffer</source>
          <target state="translated">이 버퍼의 위치</target>
        </trans-unit>
        <trans-unit id="e14f14e3eeac65815857675924c0f85fa97086c5" translate="yes" xml:space="preserve">
          <source>The position prior to which data may be discarded.</source>
          <target state="translated">The position prior to which data may be discarded.</target>
        </trans-unit>
        <trans-unit id="c4ecb0a7945551375751ca2e25e871a33f35f2b7" translate="yes" xml:space="preserve">
          <source>The position prior to which data may be discarded. Seeking to a smaller position is not allowed. &lt;code&gt;flushedPos&lt;/code&gt; will always be &amp;gt;= 0.</source>
          <target state="translated">데이터를 버릴 수있는 위치입니다. 더 작은 위치를 찾는 것은 허용되지 않습니다. &lt;code&gt;flushedPos&lt;/code&gt; 는 항상&amp;gt; = 0입니다.</target>
        </trans-unit>
        <trans-unit id="b019f8134a25cd17d205f23f036ec08fa24eb150" translate="yes" xml:space="preserve">
          <source>The position within the pushback buffer from which the next byte will be read.</source>
          <target state="translated">The position within the pushback buffer from which the next byte will be read.</target>
        </trans-unit>
        <trans-unit id="ce0957d483aceb3b45553d641f8c629ba289ca24" translate="yes" xml:space="preserve">
          <source>The position within the pushback buffer from which the next byte will be read. When the buffer is empty, &lt;code&gt;pos&lt;/code&gt; is equal to &lt;code&gt;buf.length&lt;/code&gt;; when the buffer is full, &lt;code&gt;pos&lt;/code&gt; is equal to zero.</source>
          <target state="translated">다음 바이트를 읽을 푸시 백 버퍼 내의 위치입니다. 버퍼가 비어 있으면 &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;buf.length&lt;/code&gt; 와 같습니다 . 버퍼가 가득 차면 &lt;code&gt;pos&lt;/code&gt; 는 0과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2697068a8ce2370b45252b0381024224e1a033b6" translate="yes" xml:space="preserve">
          <source>The positions tracking change are also generally cheap to maintain. The Position implementations (marks) store the array index and can easily calculate the sequential position from the current gap location. Changes only require update to the the marks between the old and new gap boundaries when the gap is moved, so generally updating the marks is pretty cheap. The marks are stored sorted so they can be located quickly with a binary search. This increases the cost of adding a mark, and decreases the cost of keeping the mark updated.</source>
          <target state="translated">The positions tracking change are also generally cheap to maintain. The Position implementations (marks) store the array index and can easily calculate the sequential position from the current gap location. Changes only require update to the the marks between the old and new gap boundaries when the gap is moved, so generally updating the marks is pretty cheap. The marks are stored sorted so they can be located quickly with a binary search. This increases the cost of adding a mark, and decreases the cost of keeping the mark updated.</target>
        </trans-unit>
        <trans-unit id="7548ff65d5ee10f38621f470acbd0447c4140b54" translate="yes" xml:space="preserve">
          <source>The possible actions are these:</source>
          <target state="translated">가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30057bbd133f892768abece91c4328fc6c016d37" translate="yes" xml:space="preserve">
          <source>The possible actions are:</source>
          <target state="translated">가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07e57a756aabf195e2b55eca8c76dad211c93a86" translate="yes" xml:space="preserve">
          <source>The possible attribute values</source>
          <target state="translated">The possible attribute values</target>
        </trans-unit>
        <trans-unit id="cf6fa0c1ab6538a58254ad393e6c38d337097a65" translate="yes" xml:space="preserve">
          <source>The possible constraints objects (Strings) are:</source>
          <target state="translated">The possible constraints objects (Strings) are:</target>
        </trans-unit>
        <trans-unit id="35dfa121a2fd6c8bb8d45be45d834b7cd54ad632" translate="yes" xml:space="preserve">
          <source>The possible implementations and return values have been modified in the Java 2 SDK, Standard Edition, version 1.3 to accommodate the option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</source>
          <target state="translated">The possible implementations and return values have been modified in the Java 2 SDK, Standard Edition, version 1.3 to accommodate the option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</target>
        </trans-unit>
        <trans-unit id="b36238ad8a3ea91b1260f9601a23cb5d54279a3f" translate="yes" xml:space="preserve">
          <source>The possible return values for this method were modified for the Java 2 SDK, Standard Edition, version 1.3. This was done to accommodate the new option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</source>
          <target state="translated">The possible return values for this method were modified for the Java 2 SDK, Standard Edition, version 1.3. This was done to accommodate the new option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</target>
        </trans-unit>
        <trans-unit id="7b7bd960ee00d4b00678a55c5cbb406785c27c39" translate="yes" xml:space="preserve">
          <source>The possible target names for an Authentication Permission are:</source>
          <target state="translated">인증 권한의 가능한 대상 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a3e78cdd39c4f87760b3390e7efcd189cdc7308" translate="yes" xml:space="preserve">
          <source>The possible ways to connect to the host are</source>
          <target state="translated">호스트에 연결하는 가능한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="080f48b0aa6b32cedd5af01121bd7b1bfc958102" translate="yes" xml:space="preserve">
          <source>The possibly null ID of the bad attribute.</source>
          <target state="translated">잘못된 속성의 null ID 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b7991f6067c19c449119e08d159087dc4972217" translate="yes" xml:space="preserve">
          <source>The possibly null address contents.</source>
          <target state="translated">가능한 null 주소 내용.</target>
        </trans-unit>
        <trans-unit id="4ed5af77681adda9a6ccec629fa59a1a47e0566d" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index &lt;code&gt;ix&lt;/code&gt; that was removed; null if the attribute value is null.</source>
          <target state="translated">인덱스 &lt;code&gt;ix&lt;/code&gt; 에서 제거 되었을 가능성이있는 속성 값입니다 . 속성 값이 null의 경우는 null</target>
        </trans-unit>
        <trans-unit id="75e1e093b3b31beab3f725db1a7a97f735291ed2" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index &lt;code&gt;ix&lt;/code&gt;; null if the attribute value is null.</source>
          <target state="translated">인덱스 &lt;code&gt;ix&lt;/code&gt; 의 null 가능성이있는 속성치 . 속성 값이 null의 경우는 null</target>
        </trans-unit>
        <trans-unit id="01e53a4583b8b632e31e23e545835d7fb151953e" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index ix that was replaced. Null if the attribute value was null.</source>
          <target state="translated">대체 된 인덱스 ix의 null 속성 값입니다. 속성 값이 null 인 경우는 null</target>
        </trans-unit>
        <trans-unit id="77bb1fce5266fd4ed13f0e3a64b2e033cc88d05b" translate="yes" xml:space="preserve">
          <source>The possibly null attributes to be bound.</source>
          <target state="translated">바인딩 가능한 null 속성입니다.</target>
        </trans-unit>
        <trans-unit id="71f9a1ed0e575411b69d0a23112e14cf08307845" translate="yes" xml:space="preserve">
          <source>The possibly null binding of the object after the change.</source>
          <target state="translated">변경 후 객체의 null 바인딩 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="303282c69dc7d698ff760f2ed06dfbbad81206cb" translate="yes" xml:space="preserve">
          <source>The possibly null binding of the object before the change.</source>
          <target state="translated">변경 전 객체의 null 바인딩 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be200430acab3902acee3be25723c5883a236b4b" translate="yes" xml:space="preserve">
          <source>The possibly null challenge to send to the client. It is null if the authentication has succeeded and there is no more challenge data to be sent to the client.</source>
          <target state="translated">클라이언트에게 보낼 가능성이있는 챌린지. 인증에 성공하고 클라이언트에 전송할 챌린지 데이터가 더 이상 없으면 널입니다.</target>
        </trans-unit>
        <trans-unit id="288430f98d1d8dc902d6cd0f841e573864bef168" translate="yes" xml:space="preserve">
          <source>The possibly null change information of this event.</source>
          <target state="translated">이 이벤트의 null 가능성이있는 정보</target>
        </trans-unit>
        <trans-unit id="ef5328e9a2c12269fc3c9790ffb3bdf7b904c77d" translate="yes" xml:space="preserve">
          <source>The possibly null class name of object bound. It is null if the object bound is null.</source>
          <target state="translated">바인딩 된 개체의 null 클래스 이름입니다. 바인드 된 오브젝트가 널인 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="ffd8994818808e7044f5a7bd47401c36f2d57625" translate="yes" xml:space="preserve">
          <source>The possibly null detail string explaining more about the problem with resolving a link. If null, it means there is no link detail message for this exception.</source>
          <target state="translated">링크를 해결하는 데 대한 문제점에 대해 자세히 설명하는 가능한 상세 문자열입니다. null의 경우,이 예외에 대한 링크 상세 메세지가없는 것을 의미한다</target>
        </trans-unit>
        <trans-unit id="67a7663ef453f501bcf8141dc78d296c77c8d264" translate="yes" xml:space="preserve">
          <source>The possibly null detail string explaining more about this exception. If null, it means there is no detail message for this exception.</source>
          <target state="translated">이 예외에 대해 더 설명하는 null 가능성이있는 문자열입니다. null의 경우,이 예외에 관한 상세 메세지가없는 것을 의미한다</target>
        </trans-unit>
        <trans-unit id="2dbbcea44ff699506e27e77c0ad6dc0d7cd34a86" translate="yes" xml:space="preserve">
          <source>The possibly null element in the enumeration. null is only valid for enumerations that can return null (e.g. Attribute.getAll() returns an enumeration of attribute values, and an attribute value can be null).</source>
          <target state="translated">열거에서 가능한 null 요소입니다. null은 null을 반환 할 수있는 열거에만 유효합니다 (예 : Attribute.getAll ()은 속성 값의 열거를 반환하고 속성 값은 null 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="50e6ea1bbf4d3d242e0442515defbd02966a7734" translate="yes" xml:space="preserve">
          <source>The possibly null exception that caused this naming exception. If null, it means no root cause has been set for this naming exception.</source>
          <target state="translated">이 이름 지정 예외의 원인이 된 null 예외입니다. null의 경우,이 네이밍 예외에 근본 원인이 설정되어 있지 않은 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ce85339be4b00e60548e7a67ece14ecc99dfce86" translate="yes" xml:space="preserve">
          <source>The possibly null fully-qualified class name of the factory. (e.g. &quot;java.lang.String&quot;)</source>
          <target state="translated">팩토리의 null 정규화 클래스 명일 가능성이 있습니다. (예 : &quot;java.lang.String&quot;)</target>
        </trans-unit>
        <trans-unit id="53819d8f2ff0666381a9127d62f2914f015d222f" translate="yes" xml:space="preserve">
          <source>The possibly null matching rule ID. If null then the ordering matching rule defined for the sort key attribute is used.</source>
          <target state="translated">가능한 null 일치 규칙 ID입니다. null의 경우, 소트 키 속성으로 정의 된 순서 일치 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7693eebba3b1d8e8aed9065f755c90ca9438ca" translate="yes" xml:space="preserve">
          <source>The possibly null object that was resolved so far. If null, it means the link resolved object field has not been set.</source>
          <target state="translated">지금까지 해결 된 null 가능성이있는 개체입니다. 널인 경우, 링크 분석 오브젝트 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="97169d9b8c4d89f8a301ca6eb28fad9af6f33b5c" translate="yes" xml:space="preserve">
          <source>The possibly null object that was resolved so far. null means that the resolved object field has not been set.</source>
          <target state="translated">지금까지 해결 된 null 가능성이있는 개체입니다. null은 확인 된 개체 필드가 ​​설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2ce6afd310045ea10e313ef96d7542591a1cd218" translate="yes" xml:space="preserve">
          <source>The possibly null object to be bound.</source>
          <target state="translated">바인딩 가능한 null 개체입니다.</target>
        </trans-unit>
        <trans-unit id="644a895b0ec7420afe1f7206497a62be42cccfd6" translate="yes" xml:space="preserve">
          <source>The possibly null part of the new name that has not been resolved. It is a composite name. It can be null, which means the remaining new name field has not been set.</source>
          <target state="translated">해결되지 않은 새 이름의 null 부분 일 수 있습니다. 합성 이름입니다. 널일 수 있으며, 이는 나머지 새 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="227b72d26062a0a4a65406d6b2400d858977938f" translate="yes" xml:space="preserve">
          <source>The possibly null response of the operation. null means the operation did not generate any response.</source>
          <target state="translated">작업의 null 응답 일 수 있습니다. null은 작업이 응답을 생성하지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="95751c0e2100386276d5fbab10fec9eadc434b68" translate="yes" xml:space="preserve">
          <source>The possibly null response to send to the server. It is null if the challenge accompanied a &quot;SUCCESS&quot; status and the challenge only contains data for the client to update its state and no response needs to be sent to the server. The response is a zero-length byte array if the client is to send a response with no data.</source>
          <target state="translated">서버에 보낼 수있는 null 응답 일 수 있습니다. 챌린지에 &quot;SUCCESS&quot;상태가 수반되고 챌린지에 클라이언트가 상태를 업데이트 할 수있는 데이터 만 포함되어 있고 응답을 서버로 보낼 필요가없는 경우 null입니다. 클라이언트가 데이터없이 응답을 보내야하는 경우 응답은 길이가 0 인 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a9f4959d404525b8010782edbbb82d1a4a73f2c7" translate="yes" xml:space="preserve">
          <source>The possibly null string containing the location for loading in the factory's class.</source>
          <target state="translated">팩토리 클래스에서로드 할 위치가 포함 된 null 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="598464a1b17e0cdd4775fa1d87fe9e6f6f313e36" translate="yes" xml:space="preserve">
          <source>The possibly null unexecuted modification list.</source>
          <target state="translated">실행되지 않은 null 수정 목록입니다.</target>
        </trans-unit>
        <trans-unit id="594289587491331d8018893d276e66cdd5175334" translate="yes" xml:space="preserve">
          <source>The possibly-empty unmodifiable set of the services that this module provides</source>
          <target state="translated">The possibly-empty unmodifiable set of the services that this module provides</target>
        </trans-unit>
        <trans-unit id="701dd4005bf758fa7ad450f4118b0095191d7b33" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by &lt;code&gt;combiner&lt;/code&gt;, a second method handle. Of the arguments passed to the adapter, the first &lt;code&gt;N&lt;/code&gt; arguments are copied to the combiner, which is then called. (Here, &lt;code&gt;N&lt;/code&gt; is defined as the parameter count of the combiner.) After this, control passes to the target, with any result from the combiner inserted before the original &lt;code&gt;N&lt;/code&gt; incoming arguments.</source>
          <target state="translated">전처리 는 제 2 방법 핸들 인 &lt;code&gt;combiner&lt;/code&gt; 에 의해 수행된다 . 어댑터에 전달 된 인수 중 첫 번째 &lt;code&gt;N&lt;/code&gt; 인수가 결합기에 복사 된 후 호출됩니다. (여기서 &lt;code&gt;N&lt;/code&gt; 은 컴 바이 너의 매개 변수 수로 정의됩니다.)이 후 제어는 대상에 전달되고 컴 바이 너의 결과는 원래 &lt;code&gt;N&lt;/code&gt; 개의 수신 인수 앞에 삽입 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c240ae7a898a6847f515e8d7157c3336476bbff" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by one or more method handles, specified in the elements of the &lt;code&gt;filters&lt;/code&gt; array. The first element of the filter array corresponds to the &lt;code&gt;pos&lt;/code&gt; argument of the target, and so on in sequence.</source>
          <target state="translated">사전 처리는 &lt;code&gt;filters&lt;/code&gt; 배열 의 요소에 지정된 하나 이상의 메소드 핸들로 수행됩니다 . 필터 배열의 첫 번째 요소 는 대상 의 &lt;code&gt;pos&lt;/code&gt; 인수 등에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="0c8d7cd21b52b86ec589875400da932885d18951" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by one or more method handles, specified in the elements of the &lt;code&gt;filters&lt;/code&gt; array. The first element of the filter array corresponds to the &lt;code&gt;pos&lt;/code&gt; argument of the target, and so on in sequence. The filter functions are invoked in left to right order.</source>
          <target state="translated">The pre-processing is performed by one or more method handles, specified in the elements of the &lt;code&gt;filters&lt;/code&gt; array. The first element of the filter array corresponds to the &lt;code&gt;pos&lt;/code&gt; argument of the target, and so on in sequence. The filter functions are invoked in left to right order.</target>
        </trans-unit>
        <trans-unit id="54fba175e25513934ae6e0c928d834995d59017b" translate="yes" xml:space="preserve">
          <source>The precedence of character-class operators is as follows, from highest to lowest:</source>
          <target state="translated">문자 클래스 연산자의 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a932d6aca64396e330c14caa731cd2e97c2efee4" translate="yes" xml:space="preserve">
          <source>The preceding code fragments give an idea of what goes on behind the scenes; they would not appear in an application, which would not invoke methods like &lt;code&gt;readData&lt;/code&gt; and &lt;code&gt;decodeParams&lt;/code&gt;. In contrast, the following code fragment shows what an application might do. It sets the rowset's command, sets the command's parameters, and executes the command. Simply by calling the &lt;code&gt;execute&lt;/code&gt; method, &lt;code&gt;crs&lt;/code&gt; populates itself with the requested data from the table &lt;code&gt;CUSTOMERS&lt;/code&gt;.</source>
          <target state="translated">The preceding code fragments give an idea of what goes on behind the scenes; they would not appear in an application, which would not invoke methods like &lt;code&gt;readData&lt;/code&gt; and &lt;code&gt;decodeParams&lt;/code&gt; . In contrast, the following code fragment shows what an application might do. It sets the rowset's command, sets the command's parameters, and executes the command. Simply by calling the &lt;code&gt;execute&lt;/code&gt; method, &lt;code&gt;crs&lt;/code&gt; populates itself with the requested data from the table &lt;code&gt;CUSTOMERS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b22a75a19cc8184d8d42eb3e0cea459d833bd7" translate="yes" xml:space="preserve">
          <source>The preceding element or null if &lt;code&gt;value&lt;/code&gt; is the first element of the sequence.</source>
          <target state="translated">The preceding element or null if &lt;code&gt;value&lt;/code&gt; is the first element of the sequence.</target>
        </trans-unit>
        <trans-unit id="1662793d099b9cf5e31bcba731e92de7d3a9c837" translate="yes" xml:space="preserve">
          <source>The precise definition of &quot;equality&quot; used in comparing attribute values is defined by the underlying directory service. It might use the &lt;code&gt;Object.equals&lt;/code&gt; method, for example, or might use a schema to specify a different equality operation. For matching based on operations other than equality (such as substring comparison) use the version of the &lt;code&gt;search&lt;/code&gt; method that takes a filter argument.</source>
          <target state="translated">속성 값을 비교하는 데 사용되는 &quot;평등&quot;의 정확한 정의는 기본 디렉토리 서비스에 의해 정의됩니다. 그것은 사용할 수 있습니다 &lt;code&gt;Object.equals&lt;/code&gt; 예를 들어, 방법, 또는 다른 동등 조작을 지정하는 스키마를 사용할 수 있습니다. 등호 이외의 연산 (예 : 하위 문자열 비교)을 기준으로 일치 시키려면 필터 인수를 사용하는 &lt;code&gt;search&lt;/code&gt; 메소드 버전을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb4614fd577d896554af4208ae33226e3eddd8ad" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, a path that does not contain &lt;em&gt;redundant&lt;/em&gt; name elements. In many file systems, the &quot;&lt;code&gt;.&lt;/code&gt;&quot; and &quot;&lt;code&gt;..&lt;/code&gt;&quot; are special names used to indicate the current directory and parent directory. In such file systems all occurrences of &quot;&lt;code&gt;.&lt;/code&gt;&quot; are considered redundant. If a &quot;&lt;code&gt;..&lt;/code&gt;&quot; is preceded by a non-&quot;&lt;code&gt;..&lt;/code&gt;&quot; name then both names are considered redundant (the process to identify such names is repeated until it is no longer applicable).</source>
          <target state="translated">이 방법의 정확한 정의는 구현에 따라 다르지만 일반적으로 &lt;em&gt;중복&lt;/em&gt; 이름 요소를 포함하지 않는 경로 인이 경로에서 파생됩니다 . 많은 파일 시스템에서 &quot; &lt;code&gt;.&lt;/code&gt; &quot;및 &quot; &lt;code&gt;..&lt;/code&gt; &quot;은 현재 디렉토리 및 상위 디렉토리를 나타내는 데 사용되는 특수 이름입니다. 이러한 파일 시스템에서 &quot; &lt;code&gt;.&lt;/code&gt; &quot;은 모두 중복 된 것으로 간주됩니다. 는 &quot;경우 &lt;code&gt;..&lt;/code&gt; &quot;비 &quot;로 시작됩니다 &lt;code&gt;..&lt;/code&gt; &quot;이름을 다음 두 이름이 고려 중복 (더 이상 적용 할 때까지 같은 이름을 식별 할 수있는 프로세스가 반복되지 않는다).</target>
        </trans-unit>
        <trans-unit id="29fe6f024b67a56fd1534c416c02d84229593b97" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, an &lt;a href=&quot;#isAbsolute()&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path that locates the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed.</source>
          <target state="translated">The precise definition of this method is implementation dependent but in general it derives from this path, an &lt;a href=&quot;#isAbsolute()&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; path that locates the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed.</target>
        </trans-unit>
        <trans-unit id="f156f4742b28783fc176e2435a927cffa5913867" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path that locates the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed.</source>
          <target state="translated">이 메소드의 정확한 정의는 구현에 따라 다르지만 일반적으로이 경로 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; 파일 을 찾는 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로 인 이 경로에서 파생 되지만 디렉토리 및 파일의 실제 이름을 나타내는 이름 요소가 있습니다. 예를 들어, 파일 시스템에서 파일 이름 비교가 대소 문자를 구분하지 않는 경우 name 요소는 실제 대소 문자 이름을 나타냅니다. 또한 결과 경로에 중복 이름 요소가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="f29514735dff4eb9875c567e3c77c10d0798a36a" translate="yes" xml:space="preserve">
          <source>The precise meaning of &quot;copy&quot; may depend on the class of the &lt;code&gt;CertStoreParameters&lt;/code&gt; object. A typical implementation performs a &quot;deep copy&quot; of this object, but this is not an absolute requirement. Some implementations may perform a &quot;shallow copy&quot; of some or all of the fields of this object.</source>
          <target state="translated">&quot;복사&quot;의 정확한 의미는 &lt;code&gt;CertStoreParameters&lt;/code&gt; 객체 의 클래스에 따라 달라질 수 있습니다 . 일반적인 구현은이 객체의 &quot;딥 카피&quot;를 수행하지만 반드시 필요한 것은 아닙니다. 일부 구현은이 객체의 일부 또는 모든 필드의 &quot;얕은 복사&quot;를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a518f78db20ec1e8e63802d6b81b3e5afc2d6f" translate="yes" xml:space="preserve">
          <source>The precise string returned is unspecified, although the following example can be considered typical:</source>
          <target state="translated">다음 예제는 일반적인 것으로 간주 될 수 있지만 반환 된 정확한 문자열은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc7760cf2ead29811d5a4f7919c808536944042d" translate="yes" xml:space="preserve">
          <source>The precision</source>
          <target state="translated">정밀도</target>
        </trans-unit>
        <trans-unit id="7f3d6ffd25563b48e926ec811735bc2c49c338dd" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If precision is specified then an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b627f68a8d6aaaef844dc471dec6b871f7b4415" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If the precision is specified an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73c2e0008148d7f138652dae3090ecc94203eec5" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If the precision is specified then an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f948c10e382d2f7768291cb8552af2625096c3e" translate="yes" xml:space="preserve">
          <source>The precision is the maximum number of characters to be written to the output. The precision is applied before the width, thus the output will be truncated to &lt;code&gt;precision&lt;/code&gt; characters even if the width is greater than the precision. If the precision is not specified then there is no explicit limit on the number of characters.</source>
          <target state="translated">정밀도는 출력에 쓸 수있는 최대 문자 수입니다. 너비보다 정밀도가 적용되므로 너비가 정밀도보다 큰 경우에도 출력이 &lt;code&gt;precision&lt;/code&gt; 문자 로 잘립니다 . 정밀도를 지정하지 않으면 문자 수에 대한 명시적인 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b1e32fea1577f6299edbb4af566a671877a6a6c" translate="yes" xml:space="preserve">
          <source>The precision of a Timestamp object is calculated to be either:</source>
          <target state="translated">The precision of a Timestamp object is calculated to be either:</target>
        </trans-unit>
        <trans-unit id="011a0b906162939e49578d08e8c1662e56c9f51a" translate="yes" xml:space="preserve">
          <source>The precision of a zero value is 1.</source>
          <target state="translated">0 값의 정밀도는 1입니다.</target>
        </trans-unit>
        <trans-unit id="7e82e7810d2a873bd46b845642c3dcb0365960ec" translate="yes" xml:space="preserve">
          <source>The predicate set on a &lt;code&gt;FilteredRowSet&lt;/code&gt; object applies a criterion on all rows in a &lt;code&gt;RowSet&lt;/code&gt; object to manage a subset of rows in a &lt;code&gt;RowSet&lt;/code&gt; object. This criterion governs the subset of rows that are visible and also defines which rows can be modified, deleted or inserted.</source>
          <target state="translated">The predicate set on a &lt;code&gt;FilteredRowSet&lt;/code&gt; object applies a criterion on all rows in a &lt;code&gt;RowSet&lt;/code&gt; object to manage a subset of rows in a &lt;code&gt;RowSet&lt;/code&gt; object. This criterion governs the subset of rows that are visible and also defines which rows can be modified, deleted or inserted.</target>
        </trans-unit>
        <trans-unit id="fa7e902fc875b9d16b011208a78c742ef3d3df14" translate="yes" xml:space="preserve">
          <source>The predicate which can be used for finding a match on a subsequence of a string</source>
          <target state="translated">The predicate which can be used for finding a match on a subsequence of a string</target>
        </trans-unit>
        <trans-unit id="17aa8f7febdaa3dd39b9259abe1f54bf9f0bebab" translate="yes" xml:space="preserve">
          <source>The predicate which can be used for matching an input string against this pattern.</source>
          <target state="translated">The predicate which can be used for matching an input string against this pattern.</target>
        </trans-unit>
        <trans-unit id="4f4b2728c2d9fd894664edd48acbeb413a1af02a" translate="yes" xml:space="preserve">
          <source>The predicate which can be used for matching on a string</source>
          <target state="translated">문자열에서 일치시키는 데 사용할 수있는 술어</target>
        </trans-unit>
        <trans-unit id="93d5400fe79116558dbb225fbe571b21c4ae79c8" translate="yes" xml:space="preserve">
          <source>The preference node that emitted the event.</source>
          <target state="translated">이벤트를 생성 한 환경 설정 노드.</target>
        </trans-unit>
        <trans-unit id="01203bc40cdd0fc728a1cb94001dc99438b063b0" translate="yes" xml:space="preserve">
          <source>The preferred (natural) size.</source>
          <target state="translated">The preferred (natural) size.</target>
        </trans-unit>
        <trans-unit id="668f70b2a4daaa09d8171ffcd2d7649a4140024b" translate="yes" xml:space="preserve">
          <source>The preferred (natural) size. For a component &lt;code&gt;comp&lt;/code&gt;, this should be equal to either &lt;code&gt;comp.getPreferredSize().width&lt;/code&gt; or &lt;code&gt;comp.getPreferredSize().height&lt;/code&gt;.</source>
          <target state="translated">The preferred (natural) size. For a component &lt;code&gt;comp&lt;/code&gt; , this should be equal to either &lt;code&gt;comp.getPreferredSize().width&lt;/code&gt; or &lt;code&gt;comp.getPreferredSize().height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bee2604a2c9080ffc366e1be25ae9500c7ea3565" translate="yes" xml:space="preserve">
          <source>The preferred alternative to this method is &lt;a href=&quot;#orElseThrow()&quot;&gt;&lt;code&gt;orElseThrow()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The preferred alternative to this method is &lt;a href=&quot;#orElseThrow()&quot;&gt; &lt;code&gt;orElseThrow()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6e11d6aa454b661b4e798d0b01d95991a0663d3" translate="yes" xml:space="preserve">
          <source>The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding. A &lt;code&gt;CharSet&lt;/code&gt; which corresponds to this and is suitable for use in a mime-type for a &lt;code&gt;DocFlavor&lt;/code&gt; can be obtained from &lt;a href=&quot;#hostEncoding&quot;&gt;&lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt;&lt;/a&gt; This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST &lt;code&gt;DocFlavors&lt;/code&gt; may be used.</source>
          <target state="translated">The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding. A &lt;code&gt;CharSet&lt;/code&gt; which corresponds to this and is suitable for use in a mime-type for a &lt;code&gt;DocFlavor&lt;/code&gt; can be obtained from &lt;a href=&quot;#hostEncoding&quot;&gt; &lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt; &lt;/a&gt; This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST &lt;code&gt;DocFlavors&lt;/code&gt; may be used.</target>
        </trans-unit>
        <trans-unit id="795459da550b399518e8f16108cfa6f315f51f3c" translate="yes" xml:space="preserve">
          <source>The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding. A CharSet which corresponds to this and is suitable for use in a mime-type for a DocFlavor can be obtained from &lt;a href=&quot;docflavor#hostEncoding&quot;&gt;&lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt;&lt;/a&gt; This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST DocFlavors may be used.</source>
          <target state="translated">선호되는 형식은 인코딩의 공식 IANA 기본 이름입니다. 텍스트 데이터를 스트리밍하는 응용 프로그램은 항상 MIME 유형으로 문자 집합을 지정해야하며, 이로 인해 해당 플랫폼의 인코딩에 저장된 데이터 (예 : 파일)에 대한 호스트 플랫폼의 인코딩이 필요합니다. 이에 대응로부터 얻어 질 수 DocFlavor에 대한 마임 타입에서의 사용에 적절한 CharSet &lt;a href=&quot;docflavor#hostEncoding&quot;&gt; &lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt; &lt;/a&gt; 항상 주 IANA 이름 않을 수도 있지만,이 VM에 의해 이해 될 것이 보장된다. 일반적인 풍미의 경우 사전 정의 된 * HOST DocFlavors를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d4fefc085f821e9d3a5fbae52dac81c3effbc7e" translate="yes" xml:space="preserve">
          <source>The preferred grid size that can be laid out by the grid bag layout.</source>
          <target state="translated">The preferred grid size that can be laid out by the grid bag layout.</target>
        </trans-unit>
        <trans-unit id="05d8afb011f2d6aa97450b5eeed5331327e17a1b" translate="yes" xml:space="preserve">
          <source>The preferred height of a grid layout is the largest preferred height of all of the components in the container times the number of rows, plus the vertical padding times the number of rows minus one, plus the top and bottom insets of the target container.</source>
          <target state="translated">The preferred height of a grid layout is the largest preferred height of all of the components in the container times the number of rows, plus the vertical padding times the number of rows minus one, plus the top and bottom insets of the target container.</target>
        </trans-unit>
        <trans-unit id="c8a8514ae55eb27d43368a36b34b29a4a95ecea4" translate="yes" xml:space="preserve">
          <source>The preferred scale of the returned result is equal to &lt;code&gt;this.scale()/2&lt;/code&gt;. The value of the returned result is always within one ulp of the exact decimal value for the precision in question. If the rounding mode is &lt;a href=&quot;roundingmode#HALF_UP&quot;&gt;&lt;code&gt;HALF_UP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;roundingmode#HALF_DOWN&quot;&gt;&lt;code&gt;HALF_DOWN&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;roundingmode#HALF_EVEN&quot;&gt;&lt;code&gt;HALF_EVEN&lt;/code&gt;&lt;/a&gt;, the result is within one half an ulp of the exact decimal value.</source>
          <target state="translated">The preferred scale of the returned result is equal to &lt;code&gt;this.scale()/2&lt;/code&gt; . The value of the returned result is always within one ulp of the exact decimal value for the precision in question. If the rounding mode is &lt;a href=&quot;roundingmode#HALF_UP&quot;&gt; &lt;code&gt;HALF_UP&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;roundingmode#HALF_DOWN&quot;&gt; &lt;code&gt;HALF_DOWN&lt;/code&gt; &lt;/a&gt;, or &lt;a href=&quot;roundingmode#HALF_EVEN&quot;&gt; &lt;code&gt;HALF_EVEN&lt;/code&gt; &lt;/a&gt;, the result is within one half an ulp of the exact decimal value.</target>
        </trans-unit>
        <trans-unit id="97d21f85809a776457475782a29383e91f9fd0e0" translate="yes" xml:space="preserve">
          <source>The preferred size of a &lt;code&gt;ScrollPane&lt;/code&gt; is the size of the insets, plus the preferred size of the viewport, plus the preferred size of the visible headers, plus the preferred size of the scrollbars that will appear given the current view and the current scrollbar displayPolicies.</source>
          <target state="translated">The preferred size of a &lt;code&gt;ScrollPane&lt;/code&gt; is the size of the insets, plus the preferred size of the viewport, plus the preferred size of the visible headers, plus the preferred size of the scrollbars that will appear given the current view and the current scrollbar displayPolicies.</target>
        </trans-unit>
        <trans-unit id="7e0c9711b77e17c2c4489dd5f3a52974aebe48d6" translate="yes" xml:space="preserve">
          <source>The preferred size of the radio button</source>
          <target state="translated">The preferred size of the radio button</target>
        </trans-unit>
        <trans-unit id="5e6038f90eeaa8ca2ee7e55f1a245305b2c41a38" translate="yes" xml:space="preserve">
          <source>The preferred way to listen for changes in list selection is to add &lt;code&gt;ListSelectionListener&lt;/code&gt;s directly to the &lt;code&gt;JList&lt;/code&gt;. &lt;code&gt;JList&lt;/code&gt; then takes care of listening to the selection model and notifying your listeners of change.</source>
          <target state="translated">The preferred way to listen for changes in list selection is to add &lt;code&gt;ListSelectionListener&lt;/code&gt; s directly to the &lt;code&gt;JList&lt;/code&gt; . &lt;code&gt;JList&lt;/code&gt; then takes care of listening to the selection model and notifying your listeners of change.</target>
        </trans-unit>
        <trans-unit id="48639e84ad6bcbf4597e147d7f6d16619a7c0136" translate="yes" xml:space="preserve">
          <source>The preferred width of a grid layout is the largest preferred width of all of the components in the container times the number of columns, plus the horizontal padding times the number of columns minus one, plus the left and right insets of the target container.</source>
          <target state="translated">The preferred width of a grid layout is the largest preferred width of all of the components in the container times the number of columns, plus the horizontal padding times the number of columns minus one, plus the left and right insets of the target container.</target>
        </trans-unit>
        <trans-unit id="b2b470a8c702b5603e9fd56840aa453b3eb2223e" translate="yes" xml:space="preserve">
          <source>The preferredSize of a JViewport whose view is this Scrollable.</source>
          <target state="translated">The preferredSize of a JViewport whose view is this Scrollable.</target>
        </trans-unit>
        <trans-unit id="0845b5b36ca2d4a9b8425c1235452d096e88e50c" translate="yes" xml:space="preserve">
          <source>The preferredSize of the list depends upon the layout orientation.</source>
          <target state="translated">The preferredSize of the list depends upon the layout orientation.</target>
        </trans-unit>
        <trans-unit id="9f1ee0aa7a4e77fdaf06191164b7988a841284af" translate="yes" xml:space="preserve">
          <source>The preferredSize of the list is total height of the rows and the maximum width of the cells. If JList.fixedCellHeight is specified then the total height of the rows is just (cellVerticalMargins + fixedCellHeight) * model.getSize() where rowVerticalMargins is the space we allocate for drawing the yellow focus outline. Similarly if fixedCellWidth is specified then we just use that.</source>
          <target state="translated">The preferredSize of the list is total height of the rows and the maximum width of the cells. If JList.fixedCellHeight is specified then the total height of the rows is just (cellVerticalMargins + fixedCellHeight) * model.getSize() where rowVerticalMargins is the space we allocate for drawing the yellow focus outline. Similarly if fixedCellWidth is specified then we just use that.</target>
        </trans-unit>
        <trans-unit id="4eac60dfdfde299257ae10fdc0b835ebccd24913" translate="yes" xml:space="preserve">
          <source>The prefix assigned to a &lt;code&gt;QName&lt;/code&gt; might &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; be valid in a different context. For example, a &lt;code&gt;QName&lt;/code&gt; may be assigned a prefix in the context of parsing a document but that prefix may be invalid in the context of a different document.</source>
          <target state="translated">The prefix assigned to a &lt;code&gt;QName&lt;/code&gt; might &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; be valid in a different context. For example, a &lt;code&gt;QName&lt;/code&gt; may be assigned a prefix in the context of parsing a document but that prefix may be invalid in the context of a different document.</target>
        </trans-unit>
        <trans-unit id="1623642ae83456ebc262cddb280ef298b22cf43d" translate="yes" xml:space="preserve">
          <source>The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows:</source>
          <target state="translated">접두사 개념은 다음과 같이 UNIX 플랫폼에서 루트 디렉토리를 처리하고 Microsoft Windows 플랫폼에서 지정자, 루트 디렉토리 및 UNC 경로 이름을 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83c74b98c1c103adeb72e47f23638fe0c6b5dd97" translate="yes" xml:space="preserve">
          <source>The prefix is included in &lt;code&gt;QName&lt;/code&gt; to retain lexical information &lt;strong&gt;&lt;em&gt;when present&lt;/em&gt;&lt;/strong&gt; in an &lt;a href=&quot;../transform/source&quot;&gt;&lt;code&gt;XML input source&lt;/code&gt;&lt;/a&gt;. The prefix is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; used in &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;QName.equals(Object)&lt;/code&gt;&lt;/a&gt; or to compute the &lt;a href=&quot;#hashCode()&quot;&gt;&lt;code&gt;QName.hashCode()&lt;/code&gt;&lt;/a&gt;. Equality and the hash code are defined using &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; the Namespace URI and local part.</source>
          <target state="translated">The prefix is included in &lt;code&gt;QName&lt;/code&gt; to retain lexical information &lt;strong&gt;&lt;em&gt;when present&lt;/em&gt;&lt;/strong&gt; in an &lt;a href=&quot;../transform/source&quot;&gt; &lt;code&gt;XML input source&lt;/code&gt; &lt;/a&gt;. The prefix is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; used in &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;QName.equals(Object)&lt;/code&gt; &lt;/a&gt; or to compute the &lt;a href=&quot;#hashCode()&quot;&gt; &lt;code&gt;QName.hashCode()&lt;/code&gt; &lt;/a&gt;. Equality and the hash code are defined using &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; the Namespace URI and local part.</target>
        </trans-unit>
        <trans-unit id="3f0a33b763f461c55c714ee683f971a7242fb300" translate="yes" xml:space="preserve">
          <source>The prefix value &lt;strong&gt;&lt;em&gt;CANNOT&lt;/em&gt;&lt;/strong&gt; be represented in the &lt;code&gt;String&lt;/code&gt; and will be set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The prefix value &lt;strong&gt;&lt;em&gt;CANNOT&lt;/em&gt;&lt;/strong&gt; be represented in the &lt;code&gt;String&lt;/code&gt; and will be set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8e1c1be1011e46771e6c940b6b8fa6d5e62a87e1" translate="yes" xml:space="preserve">
          <source>The prefixes, suffixes, and various symbols used for infinity, digits, thousands separators, decimal separators, etc. may be set to arbitrary values, and they will appear properly during formatting. However, care must be taken that the symbols and strings do not conflict, or parsing will be unreliable. For example, either the positive and negative prefixes or the suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able to distinguish positive from negative values. (If they are identical, then &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was specified.) Another example is that the decimal separator and thousands separator should be distinct characters, or parsing will be impossible.</source>
          <target state="translated">무한대, 숫자, 천 단위 구분 기호, 소수점 구분 기호 등에 사용되는 접두사, 접미사 및 다양한 기호는 임의의 값으로 설정 될 수 있으며 서식을 지정할 때 올바르게 나타납니다. 그러나 기호와 문자열이 충돌하지 않거나 구문 분석을 신뢰할 수 없도록주의해야합니다. 예를 들어 &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; 에서 양수와 음수를 구분 하려면 양수와 음수 접두사 또는 접미사를 구분해야 합니다. (동일한 경우 &lt;code&gt;DecimalFormat&lt;/code&gt; 은 음의 하위 패턴이 지정되지 않은 것처럼 작동합니다.) 또 다른 예는 소수점 구분 기호와 천 단위 구분 기호가 고유 한 문자이거나 구문 분석이 불가능하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfe9500d76701215dda5f0694197cf9ce7cabc59" translate="yes" xml:space="preserve">
          <source>The preprocessing operations &lt;code&gt;\l&lt;/code&gt;&lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt;.</source>
          <target state="translated">전처리 작업 &lt;code&gt;\l&lt;/code&gt; &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c9b0afc43dff8f62f02bd5e510a84044b62add" translate="yes" xml:space="preserve">
          <source>The presence of a &quot;throws TooManyListenersException&quot; clause on any given concrete implementation of the normally multicast &quot;void addXyzEventListener&quot; event listener registration pattern is used to annotate that interface as implementing a unicast Listener special case, that is, that one and only one Listener may be registered on the particular event listener source concurrently.</source>
          <target state="translated">일반적으로 멀티 캐스트 &quot;void addXyzEventListener&quot;이벤트 리스너 등록 패턴의 특정 구현에 &quot;throws TooManyListenersException&quot;절이 존재하면 해당 인터페이스에 유니 캐스트 리스너 특수 케이스를 구현하는 것으로 즉, 하나의 리스너 만 구현할 수 있습니다. 특정 이벤트 리스너 소스에 동시에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="bcfe2fa218fb85c049078854e31cba9eb33712aa" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;setProduct&lt;/code&gt; method now means that the &lt;code&gt;Product&lt;/code&gt; attribute is read/write. As before, the value of this attribute is an &lt;code&gt;ObjectName&lt;/code&gt;. When the attribute is set, the &lt;code&gt;ObjectName&lt;/code&gt; must be converted into the &lt;code&gt;ProductMXBean&lt;/code&gt; object that the &lt;code&gt;setProduct&lt;/code&gt; method expects. This object will be an MXBean proxy for the given &lt;code&gt;ObjectName&lt;/code&gt; in the same MBean Server.</source>
          <target state="translated">&lt;code&gt;setProduct&lt;/code&gt; 메소드가 존재 한다는 것은 이제 &lt;code&gt;Product&lt;/code&gt; 속성이 읽기 / 쓰기 임을 의미합니다 . 이전과 &lt;code&gt;ObjectName&lt;/code&gt; 속성의 값은 ObjectName 입니다. 속성이 설정되면 &lt;code&gt;ObjectName&lt;/code&gt; 이 &lt;code&gt;setProduct&lt;/code&gt; 메소드가 예상 하는 &lt;code&gt;ProductMXBean&lt;/code&gt; 오브젝트 로 변환되어야합니다 . 이 객체는 같은 MBean Server 내의 지정된 &lt;code&gt;ObjectName&lt;/code&gt; 의 MXBean 프록시가 됩니다.</target>
        </trans-unit>
        <trans-unit id="95fd8050fdd45b3295eab4ae02a17e8850afef7c" translate="yes" xml:space="preserve">
          <source>The preview panel property name.</source>
          <target state="translated">The preview panel property name.</target>
        </trans-unit>
        <trans-unit id="f3c1a6d5e06c70c525e18d6c292218418c439f71" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.</source>
          <target state="translated">The previous &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.</target>
        </trans-unit>
        <trans-unit id="6099ffaa8e5a95edca2a939c252763b26b2f5933" translate="yes" xml:space="preserve">
          <source>The previous example assumes you have not enabled filtering. If you have enabled filtering &lt;code&gt;convertRowIndexToView&lt;/code&gt; will return -1 for locations that are not visible in the view.</source>
          <target state="translated">The previous example assumes you have not enabled filtering. If you have enabled filtering &lt;code&gt;convertRowIndexToView&lt;/code&gt; will return -1 for locations that are not visible in the view.</target>
        </trans-unit>
        <trans-unit id="70c0c9bb4cb63f228dd9dcd36da40d2bf9a2afb1" translate="yes" xml:space="preserve">
          <source>The previous interest set</source>
          <target state="translated">The previous interest set</target>
        </trans-unit>
        <trans-unit id="f7113d8eb1505536f0ceef50cb4ab773d8857fa3" translate="yes" xml:space="preserve">
          <source>The previously-attached object, if any, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">이전에 연결된 객체 (있는 경우), 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3eace7397efd4ce2c5bc4bde921c89ec3d4523a0" translate="yes" xml:space="preserve">
          <source>The primary API of interest in this class for 3rd party component authors are the three methods which retrieve painters: #getBackgroundPainter, #getForegroundPainter, and #getBorderPainter.</source>
          <target state="translated">The primary API of interest in this class for 3rd party component authors are the three methods which retrieve painters: #getBackgroundPainter, #getForegroundPainter, and #getBorderPainter.</target>
        </trans-unit>
        <trans-unit id="3ab68026a150f7949b7b1dc414949fb8e8e07d81" translate="yes" xml:space="preserve">
          <source>The primary alternative to using this interface throughout your application is as follows.</source>
          <target state="translated">응용 프로그램 전체에서이 인터페이스를 사용하는 주요 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf540bb867becf7faa8d8a8f6a3aafda966d70ed" translate="yes" xml:space="preserve">
          <source>The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking-boolean-&quot;&gt;&lt;code&gt;non-blocking I/O (polling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt;&lt;code&gt;selectable non-blocking I/O&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffers&lt;/code&gt;&lt;/a&gt; or byte arrays, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 의 주요 차이점은 전송 메커니즘과 무관하게 인바운드 및 아웃 바운드 바이트 스트림에서 작동한다는 것입니다. 피어로의 안정적인 I / O 전송을 준비 하는 것은 &lt;code&gt;SSLEngine&lt;/code&gt; 사용자 의 책임입니다 . SSL / TLS 추상화를 I / O 전송 메커니즘에서 분리함으로써 &lt;code&gt;SSLEngine&lt;/code&gt; 은 &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking-boolean-&quot;&gt; &lt;code&gt;non-blocking I/O (polling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt; &lt;code&gt;selectable non-blocking I/O&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../java/net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 및 기존 입력 / 출력 스트림, 로컬 &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffers&lt;/code&gt; &lt;/a&gt; 또는 바이트 배열, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt;향후 비동기 I / O 모델&lt;/a&gt; 등</target>
        </trans-unit>
        <trans-unit id="f9ee17cce91342ad50a57f1b7253427e39e222db" translate="yes" xml:space="preserve">
          <source>The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS/DTLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking(boolean)&quot;&gt;&lt;code&gt;non-blocking I/O (polling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt;&lt;code&gt;selectable non-blocking I/O&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffers&lt;/code&gt;&lt;/a&gt; or byte arrays, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</source>
          <target state="translated">The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS/DTLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking(boolean)&quot;&gt; &lt;code&gt;non-blocking I/O (polling)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt; &lt;code&gt;selectable non-blocking I/O&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffers&lt;/code&gt; &lt;/a&gt; or byte arrays, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</target>
        </trans-unit>
        <trans-unit id="5ca999a61a413f3228e3e710618f31b417d296f9" translate="yes" xml:space="preserve">
          <source>The primary entry point for HTML View implementations to get their attributes is the &lt;a href=&quot;#getViewAttributes(javax.swing.text.View)&quot;&gt;&lt;code&gt;getViewAttributes&lt;/code&gt;&lt;/a&gt; method. This should be implemented to establish the desired policy used to associate attributes with the view. Each HTMLEditorKit (i.e. and therefore each associated JEditorPane) can have its own StyleSheet, but by default one sheet will be shared by all of the HTMLEditorKit instances. HTMLDocument instance can also have a StyleSheet, which holds the document-specific CSS specifications.</source>
          <target state="translated">The primary entry point for HTML View implementations to get their attributes is the &lt;a href=&quot;#getViewAttributes(javax.swing.text.View)&quot;&gt; &lt;code&gt;getViewAttributes&lt;/code&gt; &lt;/a&gt; method. This should be implemented to establish the desired policy used to associate attributes with the view. Each HTMLEditorKit (i.e. and therefore each associated JEditorPane) can have its own StyleSheet, but by default one sheet will be shared by all of the HTMLEditorKit instances. HTMLDocument instance can also have a StyleSheet, which holds the document-specific CSS specifications.</target>
        </trans-unit>
        <trans-unit id="853c2b2cc138799245561165af6aeca2d462a6c9" translate="yes" xml:space="preserve">
          <source>The primary intent is to support scaling and skewing, though other effects are possible.</source>
          <target state="translated">The primary intent is to support scaling and skewing, though other effects are possible.</target>
        </trans-unit>
        <trans-unit id="4616eb214fb3d1763d1d2d39382e94401c0c6dd6" translate="yes" xml:space="preserve">
          <source>The primary method for awaiting completion and extracting results of a task is &lt;a href=&quot;#join()&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, but there are several variants: The &lt;a href=&quot;future#get()&quot;&gt;&lt;code&gt;Future.get()&lt;/code&gt;&lt;/a&gt; methods support interruptible and/or timed waits for completion and report results using &lt;code&gt;Future&lt;/code&gt; conventions. Method &lt;a href=&quot;#invoke()&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt;&lt;/a&gt; is semantically equivalent to &lt;code&gt;fork(); join()&lt;/code&gt; but always attempts to begin execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method &lt;code&gt;invokeAll&lt;/code&gt; (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.</source>
          <target state="translated">The primary method for awaiting completion and extracting results of a task is &lt;a href=&quot;#join()&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;, but there are several variants: The &lt;a href=&quot;future#get()&quot;&gt; &lt;code&gt;Future.get()&lt;/code&gt; &lt;/a&gt; methods support interruptible and/or timed waits for completion and report results using &lt;code&gt;Future&lt;/code&gt; conventions. Method &lt;a href=&quot;#invoke()&quot;&gt; &lt;code&gt;invoke()&lt;/code&gt; &lt;/a&gt; is semantically equivalent to &lt;code&gt;fork(); join()&lt;/code&gt; but always attempts to begin execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method &lt;code&gt;invokeAll&lt;/code&gt; (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.</target>
        </trans-unit>
        <trans-unit id="5aa8250cbbb0c762aa091de1f6729c7a726f2772" translate="yes" xml:space="preserve">
          <source>The primary method for awaiting completion and extracting results of a task is &lt;a href=&quot;forkjointask#join--&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, but there are several variants: The &lt;a href=&quot;future#get--&quot;&gt;&lt;code&gt;Future.get()&lt;/code&gt;&lt;/a&gt; methods support interruptible and/or timed waits for completion and report results using &lt;code&gt;Future&lt;/code&gt; conventions. Method &lt;a href=&quot;forkjointask#invoke--&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt;&lt;/a&gt; is semantically equivalent to &lt;code&gt;fork(); join()&lt;/code&gt; but always attempts to begin execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method &lt;code&gt;invokeAll&lt;/code&gt; (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.</source>
          <target state="translated">완료를 기다리고 작업의 결과를 추출하는 기본 방법은 &lt;a href=&quot;forkjointask#join--&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 이지만 몇 가지 변형이 있습니다. &lt;a href=&quot;future#get--&quot;&gt; &lt;code&gt;Future.get()&lt;/code&gt; &lt;/a&gt; 메서드는 인터럽트 가능 및 / 또는 시간 초과 된 대기를 지원하고 &lt;code&gt;Future&lt;/code&gt; 규칙을 사용하여 결과를보고합니다 . &lt;a href=&quot;forkjointask#invoke--&quot;&gt; &lt;code&gt;invoke()&lt;/code&gt; &lt;/a&gt; 메소드 는 의미 적으로 &lt;code&gt;fork(); join()&lt;/code&gt; 와 같습니다 . join () 이지만 항상 현재 스레드에서 실행을 시작하려고합니다. 이러한 메소드 의 &quot; &lt;em&gt;조용한&lt;/em&gt; &quot;형식은 결과를 추출하거나 예외를보고하지 않습니다. 이는 일련의 작업이 실행될 때 유용 할 수 있으며 모든 작업이 완료 될 때까지 결과 또는 예외 처리를 지연시켜야합니다. 메소드 &lt;code&gt;invokeAll&lt;/code&gt; (여러 버전에서 사용 가능) 가장 일반적인 형태의 병렬 호출을 수행합니다. 일련의 작업을 분기하고 모든 작업을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="00886361fc8e5debb687daae7baa2873e040b957" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is for testing frameworks. Per-request headers can be set through one of the &lt;code&gt;HttpRequest&lt;/code&gt;&lt;a href=&quot;httprequest.builder#header(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">The primary purpose of this method is for testing frameworks. Per-request headers can be set through one of the &lt;code&gt;HttpRequest&lt;/code&gt; &lt;a href=&quot;httprequest.builder#header(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; methods.</target>
        </trans-unit>
        <trans-unit id="e7ff3a60b668a9b4f8ca3f3d80ba5d198b1e81f9" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제는 클래스 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99d4de701d15e3c0f3d5abd8f5d765bb2d14afb5" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description of &lt;code&gt;CertPathBuilder&lt;/code&gt; for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제 는 &lt;code&gt;CertPathBuilder&lt;/code&gt; 의 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bfe43c7ad82b7b062c6a1e827670b3dcd56247c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description of &lt;code&gt;CertPathValidator&lt;/code&gt; for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제 는 &lt;code&gt;CertPathValidator&lt;/code&gt; 의 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f3e653a9912f2fb83d0c6901343dcf8706cee3d" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow programmatic examination of the reasons behind the failure of the opening handshake. Some of these reasons might allow recovery.</source>
          <target state="translated">The primary purpose of this method is to allow programmatic examination of the reasons behind the failure of the opening handshake. Some of these reasons might allow recovery.</target>
        </trans-unit>
        <trans-unit id="0f492c04efa6c01604221d247f621ebc339b6f64" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83fc8baed5ef78ca23821a13e04a9d8ddd10f762" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">프리미티브 유형 &lt;code&gt;byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f471c30cb2c84f70470f03c585738bdc64b599e" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">원시 형 &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e44aee72206b87354d815ff88a92f784a937e888" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">원시 타입은 &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd515036f97bf6ba858fdf01810f65a40a4f0c9c" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3a71348ea0fed210633648dce17501818f0109" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dbfb61247c4fbf66782c11b9ea7234fee3f4c1e" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">기본 유형은 &lt;code&gt;long&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbd45dce2a86e7713945fe9ae4375a42101fb99a" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">기본 유형 &lt;code&gt;short&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13f1d1c5a513be9280a101289705bc830feffc07" translate="yes" xml:space="preserve">
          <source>The principal methods are defined to allow the throwing of an exception. In normal use, no exceptions will be thrown, however one possible implementation would be to obtain the time from a central time server across the network. Obviously, in this case the lookup could fail, and so the method is permitted to throw an exception.</source>
          <target state="translated">주요 메소드는 예외 발생을 허용하도록 정의됩니다. 정상적인 사용에서는 예외가 발생하지 않지만 네트워크를 통해 중앙 시간 서버에서 시간을 얻는 것이 가능합니다. 분명히이 경우 조회가 실패 할 수 있으므로 메소드에서 예외가 발생하도록 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="00414fce4c7455a893959b39576e22c2ae5eafaa" translate="yes" xml:space="preserve">
          <source>The principal operations on a &lt;code&gt;StringBuffer&lt;/code&gt; are the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;insert&lt;/code&gt; methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string buffer. The &lt;code&gt;append&lt;/code&gt; method always adds these characters at the end of the buffer; the &lt;code&gt;insert&lt;/code&gt; method adds the characters at a specified point.</source>
          <target state="translated">&lt;code&gt;StringBuffer&lt;/code&gt; 의 주요 작업 은 &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 방법이며, 모든 유형의 데이터를 허용하도록 오버로드됩니다. 각각은 주어진 데이텀을 효과적으로 문자열로 변환 한 다음 해당 문자열의 문자를 문자열 버퍼에 추가하거나 삽입합니다. &lt;code&gt;append&lt;/code&gt; 방법은 항상 버퍼의 끝에서 이러한 문자를 추가; &lt;code&gt;insert&lt;/code&gt; 방법은 지정된 지점에 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8d9eb8cbf18b97db213dc84e3622468146efcc16" translate="yes" xml:space="preserve">
          <source>The principal operations on a &lt;code&gt;StringBuilder&lt;/code&gt; are the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;insert&lt;/code&gt; methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string builder. The &lt;code&gt;append&lt;/code&gt; method always adds these characters at the end of the builder; the &lt;code&gt;insert&lt;/code&gt; method adds the characters at a specified point.</source>
          <target state="translated">&lt;code&gt;StringBuilder&lt;/code&gt; 의 주요 작업 은 &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 방법으로, 모든 유형의 데이터를 허용하도록 오버로드됩니다. 각각은 주어진 데이텀을 효과적으로 문자열로 변환 한 다음 해당 문자열의 문자를 문자열 빌더에 추가하거나 삽입합니다. &lt;code&gt;append&lt;/code&gt; 방법은 항상 빌더의 끝 부분에 이러한 문자를 추가; &lt;code&gt;insert&lt;/code&gt; 방법은 지정된 지점에 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cdd711677992dcb1524f6e2386709d058ae3ac67" translate="yes" xml:space="preserve">
          <source>The principal purpose of these additions is to allow the specification of tables to use in encoding abbreviated streams. The built-in JPEG writer will also accept an ordinary &lt;code&gt;ImageWriteParam&lt;/code&gt;, in which case the writer will construct the necessary tables internally.</source>
          <target state="translated">이러한 추가의 주요 목적은 테이블 지정이 축약 된 스트림을 인코딩하는 데 사용할 수 있도록하는 것입니다. 내장 JPEG 라이터는 일반적인 &lt;code&gt;ImageWriteParam&lt;/code&gt; 을 수용하며 ,이 경우 라이터는 필요한 테이블을 내부적으로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="79e1de7f953be5214dc8046cee3435b263a6bc9b" translate="yes" xml:space="preserve">
          <source>The print data and the processing instructions are separate entities. This means that:</source>
          <target state="translated">인쇄 데이터와 처리 지침은 별도의 엔터티입니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="87fa994137d2af295902c75d6d1e468277e6adf3" translate="yes" xml:space="preserve">
          <source>The print data format is unspecified (just an octet stream)</source>
          <target state="translated">인쇄 데이터 형식이 지정되지 않았습니다 (옥텟 스트림 만).</target>
        </trans-unit>
        <trans-unit id="2887ef4584b4a46b117c104e5d5bafd49277b4db" translate="yes" xml:space="preserve">
          <source>The print service indicates that a - possibly transient - problem may require external intervention before the print service can continue.</source>
          <target state="translated">The print service indicates that a - possibly transient - problem may require external intervention before the print service can continue.</target>
        </trans-unit>
        <trans-unit id="87d74c41b031f63a36b535b9f8f87b980e7f4993" translate="yes" xml:space="preserve">
          <source>The print service indicates that a - possibly transient - problem may require external intervention before the print service can continue. One example of an event that can generate this message is when the printer runs out of paper.</source>
          <target state="translated">인쇄 서비스는 일시적인 문제로 인해 인쇄 서비스를 계속하기 전에 외부 개입이 필요할 수 있음을 나타냅니다. 이 메시지를 생성 할 수있는 이벤트의 한 예는 프린터에 용지가 부족한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="8c9efeedc8343f07e9cac56c5db7dfd99892ddd9" translate="yes" xml:space="preserve">
          <source>The print service reports that the job cannot be completed.</source>
          <target state="translated">The print service reports that the job cannot be completed.</target>
        </trans-unit>
        <trans-unit id="6ffca2a80baec343c1fe37408ec848806e832a04" translate="yes" xml:space="preserve">
          <source>The print service reports that the job cannot be completed. The application must resubmit the job.</source>
          <target state="translated">인쇄 서비스에서 작업을 완료 할 수 없다고보고합니다. 응용 프로그램은 작업을 다시 제출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee3379a27f4d6bd5aea086e7d040f37f1b4e28e0" translate="yes" xml:space="preserve">
          <source>The printable area is specified to be a rectangle, within the overall dimensions of a media.</source>
          <target state="translated">인쇄 가능한 영역은 용지의 전체 크기 내에서 사각형으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a424ad159a01af0ae87f7797a6b6f5420eea6d5" translate="yes" xml:space="preserve">
          <source>The printer attempts to make the external job attribute values take precedence over embedded instructions in the documents' print data, however there is no guarantee.</source>
          <target state="translated">프린터가 외부 작업 속성 값을 문서의 인쇄 데이터에 포함 된 지시 사항보다 우선하게하려고하지만 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c845bc5a10dc5d6856a87ec303fc2db4c49089d3" translate="yes" xml:space="preserve">
          <source>The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="481ecce0067802bcb30b2bcd366ca961b211a6bb" translate="yes" xml:space="preserve">
          <source>The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt;). This reason is intended to cover any file access problem,including file does not exist and access denied because of an access control problem. Whether the printer aborts the job and moves the job to the &lt;code&gt;ABORTED&lt;/code&gt; job state or prints all documents that are accessible and moves the job to the &lt;code&gt;COMPLETED&lt;/code&gt; job state and adds the &lt;code&gt;COMPLETED_WITH_ERRORS&lt;/code&gt; reason to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute depends on implementation and/or site policy. This value should be supported if the printer supports doc flavors with &lt;code&gt;URL&lt;/code&gt; print data representation objects.</source>
          <target state="translated">The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt; ). This reason is intended to cover any file access problem,including file does not exist and access denied because of an access control problem. Whether the printer aborts the job and moves the job to the &lt;code&gt;ABORTED&lt;/code&gt; job state or prints all documents that are accessible and moves the job to the &lt;code&gt;COMPLETED&lt;/code&gt; job state and adds the &lt;code&gt;COMPLETED_WITH_ERRORS&lt;/code&gt; reason to the job's &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; attribute depends on implementation and/or site policy. This value should be supported if the printer supports doc flavors with &lt;code&gt;URL&lt;/code&gt; print data representation objects.</target>
        </trans-unit>
        <trans-unit id="22182d19201ff4051207c19a5ee208fd4a5a1b2f" translate="yes" xml:space="preserve">
          <source>The printer decides how to interpret the print data; the way this &quot;autosensing&quot; works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt;, &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">The printer decides how to interpret the print data; the way this &quot;autosensing&quot; works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt; , &lt;code&gt;URL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="420689a193f1513253aa8f7350cd70790dfdb9dd" translate="yes" xml:space="preserve">
          <source>The printer decides how to interpret the print data; the way this &quot;autosensing&quot; works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">프린터는 인쇄 데이터 해석 방법을 결정합니다. 이 &quot;자동 감지&quot;작동 방식은 구현에 따라 다릅니다. 일반적으로 미리 포맷 된 자동 감지 인쇄 데이터는 바이트 지향 표현 클래스 (바이트 배열, InputStream, URL)로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d27c6ece8fd59adc7c9db5b4829fd7026afa41" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer has not finished accessing or accepting all the print data yet.</source>
          <target state="translated">프린터가 인쇄 작업을 만들었지 만 프린터가 아직 모든 인쇄 데이터에 액세스하거나 수락하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5b838c048d7373b6f5fece71927c2c6d92736461" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state.</source>
          <target state="translated">The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state.</target>
        </trans-unit>
        <trans-unit id="f5116fa6c6a863806c7589febab48774aa25fcd4" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state. If a printer starts processing before it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; reason, but the &lt;code&gt;JOB_INCOMING&lt;/code&gt; reason remains. If a printer starts processing after it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; and &lt;code&gt;JOB_INCOMING&lt;/code&gt; reasons at the same time.</source>
          <target state="translated">The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state. If a printer starts processing before it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; reason, but the &lt;code&gt;JOB_INCOMING&lt;/code&gt; reason remains. If a printer starts processing after it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; and &lt;code&gt;JOB_INCOMING&lt;/code&gt; reasons at the same time.</target>
        </trans-unit>
        <trans-unit id="2c6e9c3b42f4bb17ba7645de0aa8f126f95272d5" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the PROCESSING state. If a printer starts processing before it has received all data, the printer removes the JOB_DATA_INSUFFICIENT reason, but the JOB_INCOMING reason remains. If a printer starts processing after it has received all data, the printer removes the JOB_DATA_INSUFFICIENT and JOB_INCOMING reasons at the same time.</source>
          <target state="translated">프린터가 인쇄 작업을 생성했지만 프린터가 작업을 처리 중 상태로 옮기기 전에 추가 인쇄 데이터가 필요합니다. 프린터가 모든 데이터를 받기 전에 처리를 시작하면 프린터는 JOB_DATA_INSUFFICIENT 이유를 제거하지만 JOB_INCOMING 이유는 남아 있습니다. 프린터가 모든 데이터를 수신 한 후 처리를 시작하면 프린터는 JOB_DATA_INSUFFICIENT 및 JOB_INCOMING 이유를 동시에 제거합니다.</target>
        </trans-unit>
        <trans-unit id="26f86c1fd10f95e2e1ce6d73964c40d138b16512" translate="yes" xml:space="preserve">
          <source>The printer has detected an error other than ones listed below.</source>
          <target state="translated">프린터가 아래 나열된 오류 이외의 오류를 감지했습니다.</target>
        </trans-unit>
        <trans-unit id="ee4d72184cd18cc72c7888278ace0c6fd62b60fb" translate="yes" xml:space="preserve">
          <source>The printer has made the job ready for printing, but the output device is not yet printing it, either because the job hasn't reached the output device or because the job is queued in the output device or some other spooler, awaiting the output device to print it.</source>
          <target state="translated">프린터가 작업을 인쇄 준비 상태로 만들었지 만 작업이 출력 장치에 도달하지 않았거나 출력 장치 또는 다른 스풀러에서 작업이 대기하여 출력 장치를 대기 중이기 때문에 출력 장치가 아직 인쇄하지 않습니다 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bb06ac1489baa54ea2bee8733b418deb9986e56c" translate="yes" xml:space="preserve">
          <source>The printer has scheduled a job on the output device and is in the process of connecting to a shared network output device (and might not be able to actually start printing the job for an arbitrarily long time depending on the usage of the output device by other servers on the network).</source>
          <target state="translated">프린터가 출력 장치에서 작업을 예약했으며 공유 네트워크 출력 장치에 연결하는 중입니다 (다른 장치의 출력 장치 사용에 따라 실제로 장시간 인쇄 작업을 시작하지 못할 수 있음) 네트워크상의 서버).</target>
        </trans-unit>
        <trans-unit id="8e0bf3607b8e2970cff88cf552730d6f2d8d625d" translate="yes" xml:space="preserve">
          <source>The printer is capable of some type of color printing, such as highlight color or full process color.</source>
          <target state="translated">프린터는 밝은 색상 또는 전체 프로세스 색상과 같은 일부 유형의 컬러 인쇄가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c005cdea131511c73720a6f53d9a8366cf1ca01d" translate="yes" xml:space="preserve">
          <source>The printer is currently accepting jobs.</source>
          <target state="translated">프린터가 현재 작업을 수락하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c387e9c6647fb266c1648f1dc120f6cc016ad4" translate="yes" xml:space="preserve">
          <source>The printer is currently rejecting any jobs sent to it.</source>
          <target state="translated">프린터가 현재 전송 된 작업을 거부하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="05b2fabb7aa801e323b9d634f91b48efaabae0c1" translate="yes" xml:space="preserve">
          <source>The printer is in the process of stopping the device and will be stopped in a while.</source>
          <target state="translated">The printer is in the process of stopping the device and will be stopped in a while.</target>
        </trans-unit>
        <trans-unit id="a53658e3838a5dc4333bc6672baea14965848810" translate="yes" xml:space="preserve">
          <source>The printer is in the process of stopping the device and will be stopped in a while. When the device is stopped, the printer will change the &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;STOPPED&lt;/code&gt;. The &lt;code&gt;STOPPING&lt;/code&gt; reason is never an error, even for a printer with a single output device. When an output device ceases accepting jobs, the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; will have this reason while the output device completes printing.</source>
          <target state="translated">The printer is in the process of stopping the device and will be stopped in a while. When the device is stopped, the printer will change the &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; to &lt;code&gt;STOPPED&lt;/code&gt; . The &lt;code&gt;STOPPING&lt;/code&gt; reason is never an error, even for a printer with a single output device. When an output device ceases accepting jobs, the printer's &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; will have this reason while the output device completes printing.</target>
        </trans-unit>
        <trans-unit id="c8b0ff98c2f13c970471be7702bd134d6dbdc6cc" translate="yes" xml:space="preserve">
          <source>The printer is in the process of stopping the device and will be stopped in a while. When the device is stopped, the printer will change the &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; to STOPPED. The STOPPING reason is never an error, even for a printer with a single output device. When an output device ceases accepting jobs, the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; will have this reason while the output device completes printing.</source>
          <target state="translated">프린터가 장치를 중지하는 중이며 잠시 후에 중지됩니다. 장치가 중지되면 프린터는 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 를 STOPPED로 변경합니다 . 단일 출력 장치가있는 프린터의 경우에도 STOPPING 이유는 오류가 아닙니다. 출력 장치가 작업 수락을 중단 하면 출력 장치가 인쇄를 완료하는 동안 프린터의 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 에이 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="54f62f72799c6d5e9a37cf0c00f4e1b535987780" translate="yes" xml:space="preserve">
          <source>The printer is not capable of any type of color printing.</source>
          <target state="translated">프린터는 어떤 유형의 컬러 인쇄도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b38e5fa5b8409dddee614ca089cd0362c79f47f" translate="yes" xml:space="preserve">
          <source>The printer is off-line and accepting no jobs.</source>
          <target state="translated">The printer is off-line and accepting no jobs.</target>
        </trans-unit>
        <trans-unit id="1afe6d85c12a8a8b5a7f1edd564ce3193ddf2261" translate="yes" xml:space="preserve">
          <source>The printer is off-line and accepting no jobs. All &lt;code&gt;PENDING&lt;/code&gt; jobs are put into the &lt;code&gt;PENDING_HELD&lt;/code&gt; state. This situation could be true if the service's or document transform's input is impaired or broken.</source>
          <target state="translated">The printer is off-line and accepting no jobs. All &lt;code&gt;PENDING&lt;/code&gt; jobs are put into the &lt;code&gt;PENDING_HELD&lt;/code&gt; state. This situation could be true if the service's or document transform's input is impaired or broken.</target>
        </trans-unit>
        <trans-unit id="a76ccbd08fd7ed213da23153a2832c1f11f3ddb7" translate="yes" xml:space="preserve">
          <source>The printer is off-line and accepting no jobs. All PENDING jobs are put into the PENDING_HELD state. This situation could be true if the service's or document transform's input is impaired or broken.</source>
          <target state="translated">프린터가 오프라인 상태이며 작업을 수락하지 않습니다. 모든 PENDING 작업은 PENDING_HELD 상태가됩니다. 서비스 또는 문서 변환의 입력이 손상되었거나 손상된 경우이 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ea5b5a51cabfc6ce87f4bba805d145bf23c69d" translate="yes" xml:space="preserve">
          <source>The printer is transmitting the job to the output device.</source>
          <target state="translated">프린터가 작업을 출력 장치로 전송하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1b431e7082d79aa73c78295a787c0420e076b7" translate="yes" xml:space="preserve">
          <source>The printer makes no attempt to make the external job attribute values take precedence over embedded instructions in the documents' print data.</source>
          <target state="translated">프린터는 문서의 인쇄 데이터에 포함 된 지시 사항보다 외부 작업 속성 값을 우선시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc15b2e767f5374c6b094a0dfd57a256c58156f6" translate="yes" xml:space="preserve">
          <source>The printer should make reasonable attempts to print the job, even if it cannot print it exactly as specified.</source>
          <target state="translated">프린터는 지정된대로 정확하게 인쇄 할 수 없더라도 작업 인쇄를 합리적으로 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="e18a8686bb628a68a2eaf4c30403e4349bfe5fcd" translate="yes" xml:space="preserve">
          <source>The printer state is unknown.</source>
          <target state="translated">프린터 상태를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95f20fd944e4a43232c41915ad9d367576e3c214" translate="yes" xml:space="preserve">
          <source>The printing system may request a page index more than once. On each occasion equal PageFormat parameters will be supplied.</source>
          <target state="translated">The printing system may request a page index more than once. On each occasion equal PageFormat parameters will be supplied.</target>
        </trans-unit>
        <trans-unit id="63d426c5363736a80887b7073605a6606087a1b4" translate="yes" xml:space="preserve">
          <source>The printing system will call &lt;code&gt;Printable.print(..)&lt;/code&gt; with page indexes which increase monotonically, although as noted above, the &lt;code&gt;Printable&lt;/code&gt; should expect multiple calls for a page index and that page indexes may be skipped, when page ranges are specified by the client, or by a user through a print dialog.</source>
          <target state="translated">The printing system will call &lt;code&gt;Printable.print(..)&lt;/code&gt; with page indexes which increase monotonically, although as noted above, the &lt;code&gt;Printable&lt;/code&gt; should expect multiple calls for a page index and that page indexes may be skipped, when page ranges are specified by the client, or by a user through a print dialog.</target>
        </trans-unit>
        <trans-unit id="08bc056d9ef081c3233d58a84e37a59beef78d75" translate="yes" xml:space="preserve">
          <source>The printwriter associated with this console</source>
          <target state="translated">이 콘솔과 관련된 인쇄기</target>
        </trans-unit>
        <trans-unit id="42f954696c5f60bbc139b566f392ccb1636872f4" translate="yes" xml:space="preserve">
          <source>The priority level of this glyph as it is growing.</source>
          <target state="translated">The priority level of this glyph as it is growing.</target>
        </trans-unit>
        <trans-unit id="628a678ead91170d2283b79dc824cb7b5316e893" translate="yes" xml:space="preserve">
          <source>The priority level of this glyph as it is shrinking.</source>
          <target state="translated">The priority level of this glyph as it is shrinking.</target>
        </trans-unit>
        <trans-unit id="6701aac4c822d072a47e34f47ed4c1b355734957" translate="yes" xml:space="preserve">
          <source>The priority of the newly created thread is set equal to the priority of the thread creating it, that is, the currently running thread. The method &lt;a href=&quot;#setPriority(int)&quot;&gt;setPriority&lt;/a&gt; may be used to change the priority to a new value.</source>
          <target state="translated">The priority of the newly created thread is set equal to the priority of the thread creating it, that is, the currently running thread. The method &lt;a href=&quot;#setPriority(int)&quot;&gt;setPriority&lt;/a&gt; may be used to change the priority to a new value.</target>
        </trans-unit>
        <trans-unit id="97a7ef6f1e3cb3a0aaedfb170ff09b511361e6da" translate="yes" xml:space="preserve">
          <source>The priority of the newly created thread is set equal to the priority of the thread creating it, that is, the currently running thread. The method &lt;a href=&quot;thread#setPriority-int-&quot;&gt;setPriority&lt;/a&gt; may be used to change the priority to a new value.</source>
          <target state="translated">새로 작성된 스레드의 우선 순위는 스레드를 작성하는 스레드의 우선 순위, 즉 현재 실행중인 스레드와 동일하게 설정됩니다. &lt;a href=&quot;thread#setPriority-int-&quot;&gt;setPriority&lt;/a&gt; 메소드 는 우선 순위를 새로운 값으로 변경하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad67cfc9e7ec6a73ea73ab912679bd94c7119e41" translate="yes" xml:space="preserve">
          <source>The priority of the thread associated with this &lt;code&gt;ThreadInfo&lt;/code&gt;.</source>
          <target state="translated">The priority of the thread associated with this &lt;code&gt;ThreadInfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c66994c2e5565d62182013ffae28875f5cf6f391" translate="yes" xml:space="preserve">
          <source>The probe result is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string must be parsable according to the grammar in the RFC 2045.</source>
          <target state="translated">프로브 결과는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 컨텐츠 유형 값의 문자열 형식입니다 . RFC 2045의 문법에 따라 문자열을 구문 분석 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2212334559e7a887fc928254facb62421de92a5a" translate="yes" xml:space="preserve">
          <source>The process is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the process continues executing asynchronously.</source>
          <target state="translated">The process is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the process continues executing asynchronously.</target>
        </trans-unit>
        <trans-unit id="b41ea041545c20c101d2c5766605f8c26aba0a1d" translate="yes" xml:space="preserve">
          <source>The process may be observed to have terminated with &lt;a href=&quot;#isAlive()&quot;&gt;&lt;code&gt;isAlive()&lt;/code&gt;&lt;/a&gt; before the ComputableFuture is completed and dependent actions are invoked.</source>
          <target state="translated">The process may be observed to have terminated with &lt;a href=&quot;#isAlive()&quot;&gt; &lt;code&gt;isAlive()&lt;/code&gt; &lt;/a&gt; before the ComputableFuture is completed and dependent actions are invoked.</target>
        </trans-unit>
        <trans-unit id="006b08040b73f5d34fb2e71fc14a1d7d47de63f1" translate="yes" xml:space="preserve">
          <source>The process may not terminate immediately. i.e. &lt;code&gt;isAlive()&lt;/code&gt; may return true for a brief period after &lt;code&gt;destroyForcibly()&lt;/code&gt; is called. This method may be chained to &lt;code&gt;waitFor()&lt;/code&gt; if needed.</source>
          <target state="translated">The process may not terminate immediately. i.e. &lt;code&gt;isAlive()&lt;/code&gt; may return true for a brief period after &lt;code&gt;destroyForcibly()&lt;/code&gt; is called. This method may be chained to &lt;code&gt;waitFor()&lt;/code&gt; if needed.</target>
        </trans-unit>
        <trans-unit id="880dec8515b711c27c013e6c9697d99218ffed43" translate="yes" xml:space="preserve">
          <source>The process of implementing a set by extending this class is identical to that of implementing a Collection by extending AbstractCollection, except that all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the &lt;code&gt;Set&lt;/code&gt; interface (for instance, the add method must not permit addition of multiple instances of an object to a set).</source>
          <target state="translated">이 클래스를 확장하여 세트를 구현하는 프로세스는이 클래스의 서브 클래스에있는 모든 메소드 및 생성자가 &lt;code&gt;Set&lt;/code&gt; 인터페이스 에 의해 부과 된 추가 제한 조건을 준수해야한다는 점을 제외하면 AbstractCollection을 확장하여 Collection을 구현하는 프로세스와 동일합니다 . add 메소드는 오브젝트의 여러 인스턴스를 세트에 추가 할 수 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="e1ec3b94c22e460ebbbb042de3db1027d96793ab" translate="yes" xml:space="preserve">
          <source>The process of normalization is specific to each calendar system. For example, in the ISO calendar system, the years and months are normalized but the days are not, such that &quot;15 months&quot; would be normalized to &quot;1 year and 3 months&quot;.</source>
          <target state="translated">정규화 프로세스는 각 달력 시스템에 따라 다릅니다. 예를 들어, ISO 달력 시스템에서 연도와 월은 정규화되지만 요일은 그렇지 않으므로 &quot;15 개월&quot;은 &quot;1 년 3 개월&quot;로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a0880060c6bd165f58bb9740e5b98b10e7366b11" translate="yes" xml:space="preserve">
          <source>The process of writing changes in a &lt;code&gt;RowSet&lt;/code&gt; object to its data source is known as</source>
          <target state="translated">The process of writing changes in a &lt;code&gt;RowSet&lt;/code&gt; object to its data source is known as</target>
        </trans-unit>
        <trans-unit id="cf7301191430bba9ec8368d5ffbc647fac0cf73d" translate="yes" xml:space="preserve">
          <source>The process that looks for a class name in the &lt;code&gt;META-INF/services/org.xml.sax.driver&lt;/code&gt; file in a jar file does not conform to the specification of the service-provider loading facility as defined in &lt;a href=&quot;../../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; and therefore does not support modularization. It is deprecated as of Java SE 9 and subject to removal in a future release.</source>
          <target state="translated">The process that looks for a class name in the &lt;code&gt;META-INF/services/org.xml.sax.driver&lt;/code&gt; file in a jar file does not conform to the specification of the service-provider loading facility as defined in &lt;a href=&quot;../../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; and therefore does not support modularization. It is deprecated as of Java SE 9 and subject to removal in a future release.</target>
        </trans-unit>
        <trans-unit id="455f1746aa3e2b37c23f02cccc11f1194c2bd1f7" translate="yes" xml:space="preserve">
          <source>The processing instruction does not specify how the print job processes the request; each processing instruction is only a description of the results of a print job. The print job determines the manner in which it achieves the results specified by the processing instructions. Representing processing instructions as descriptive items provides more flexibility for implementing print jobs.</source>
          <target state="translated">처리 명령은 인쇄 작업이 요청을 처리하는 방법을 지정하지 않습니다. 각 처리 명령은 인쇄 작업 결과에 대한 설명 일뿐입니다. 인쇄 작업에 따라 처리 지침에 지정된 결과를 얻는 방식이 결정됩니다. 처리 지침을 설명 항목으로 표시하면 인쇄 작업을보다 유연하게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21c5292c5f0f85748710a360b9fb4d2c8ebb894" translate="yes" xml:space="preserve">
          <source>The processor may choose to continue, but will not normally proceed to a successful completion.</source>
          <target state="translated">The processor may choose to continue, but will not normally proceed to a successful completion.</target>
        </trans-unit>
        <trans-unit id="6f696f02deb8ba447238e7b0ba963cade3056181" translate="yes" xml:space="preserve">
          <source>The profile includes the &lt;code&gt;redColorantTag&lt;/code&gt;, &lt;code&gt;greenColorantTag&lt;/code&gt;, &lt;code&gt;blueColorantTag&lt;/code&gt;, &lt;code&gt;redTRCTag&lt;/code&gt;, &lt;code&gt;greenTRCTag&lt;/code&gt;, &lt;code&gt;blueTRCTag&lt;/code&gt;, and &lt;code&gt;mediaWhitePointTag&lt;/code&gt; tags.</source>
          <target state="translated">The profile includes the &lt;code&gt;redColorantTag&lt;/code&gt; , &lt;code&gt;greenColorantTag&lt;/code&gt; , &lt;code&gt;blueColorantTag&lt;/code&gt; , &lt;code&gt;redTRCTag&lt;/code&gt; , &lt;code&gt;greenTRCTag&lt;/code&gt; , &lt;code&gt;blueTRCTag&lt;/code&gt; , and &lt;code&gt;mediaWhitePointTag&lt;/code&gt; tags.</target>
        </trans-unit>
        <trans-unit id="fd8dfde5161913039fba723df9c9b90bc3017769" translate="yes" xml:space="preserve">
          <source>The profile's color space type is RGB.</source>
          <target state="translated">The profile's color space type is RGB.</target>
        </trans-unit>
        <trans-unit id="b21468901598e18762161fbe3cf811efedaec007" translate="yes" xml:space="preserve">
          <source>The program</source>
          <target state="translated">프로그램</target>
        </trans-unit>
        <trans-unit id="345c1d3616f08664463e96baa7a67e8da0786160" translate="yes" xml:space="preserve">
          <source>The program number is zero-based (expressed from 0 to 127). Note that MIDI hardware displays and literature about MIDI typically use the range 1 to 128 instead.</source>
          <target state="translated">The program number is zero-based (expressed from 0 to 127). Note that MIDI hardware displays and literature about MIDI typically use the range 1 to 128 instead.</target>
        </trans-unit>
        <trans-unit id="76dfc7088829bdbf1569fb6f72d786a2251045f0" translate="yes" xml:space="preserve">
          <source>The program number is zero-based (expressed from 0 to 127). Note that MIDI hardware displays and literature about MIDI typically use the range 1 to 128 instead. It is possible that the underlying synthesizer does not support a specific program. In order to verify that a call to &lt;code&gt;programChange&lt;/code&gt; was successful, use &lt;code&gt;getProgram&lt;/code&gt;.</source>
          <target state="translated">프로그램 번호는 0부터 시작합니다 (0에서 127까지 표시). MIDI에 대한 MIDI 하드웨어 디스플레이 및 문헌은 일반적으로 1-128 범위를 사용합니다. 기본 신디사이저가 특정 프로그램을 지원하지 않을 수 있습니다. &lt;code&gt;programChange&lt;/code&gt; 호출 이 성공 했는지 확인 하려면 &lt;code&gt;getProgram&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="962e35562a0df5666bf7aad07b776ace67ab18a8" translate="yes" xml:space="preserve">
          <source>The program number of the instrument that this voice is currently using.</source>
          <target state="translated">The program number of the instrument that this voice is currently using.</target>
        </trans-unit>
        <trans-unit id="4155d56e171215de9c7037e45d7bce8a1282da2c" translate="yes" xml:space="preserve">
          <source>The program number of the instrument that this voice is currently using. The value ranges from 0 to 127 if the voice is active, and is unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 현재 사용중인 악기의 프로그램 번호입니다. 음성이 활성화 된 경우 값의 범위는 0-127이며 음성이 비활성화 된 경우 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1be1f5399b975af8c707420333db180e0981d19" translate="yes" xml:space="preserve">
          <source>The programmatic name of the property that was changed. May be null if multiple properties have changed.</source>
          <target state="translated">변경된 속성의 프로그래밍 방식 이름입니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad93de22f765c96c57d8527107c09122268deb2d" translate="yes" xml:space="preserve">
          <source>The programmatic name of the property/method/event</source>
          <target state="translated">속성 / 방법 / 이벤트의 프로그래밍 이름</target>
        </trans-unit>
        <trans-unit id="4a4ca8c0566e76e0bda81fc2154a3dd169f21dfd" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and &lt;code&gt;Collection&lt;/code&gt; constructor, as per the recommendation in the &lt;code&gt;Collection&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 &lt;code&gt;Collection&lt;/code&gt; 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="61075cdab1eeb6f09db5bfab67efc96a9fe1b4d1" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 컬렉션 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="37e4fc3e466260a434320ff485db7412afec1305" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the &lt;code&gt;Collection&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 컬렉션 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92e053e057575398190a0ac956a5817f3e0304d3" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the &lt;code&gt;Map&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Map&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 맵 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f01bb378f182b23e8ed67c381eb92c51c702d451" translate="yes" xml:space="preserve">
          <source>The progress bar changes to determinate</source>
          <target state="translated">The progress bar changes to determinate</target>
        </trans-unit>
        <trans-unit id="4b5b62e95c0464429469a4601f4eedbff960af77" translate="yes" xml:space="preserve">
          <source>The progress bar is determinate and becomes displayable</source>
          <target state="translated">The progress bar is determinate and becomes displayable</target>
        </trans-unit>
        <trans-unit id="e367352ef18d207387d0a16384a607086a84bf3e" translate="yes" xml:space="preserve">
          <source>The progress bar is displayable and becomes determinate</source>
          <target state="translated">The progress bar is displayable and becomes determinate</target>
        </trans-unit>
        <trans-unit id="ff7b207dcad61e50dde5ee3a8d51e2a89562a740" translate="yes" xml:space="preserve">
          <source>The progress bar is displayable and determinate and this UI is installed</source>
          <target state="translated">The progress bar is displayable and determinate and this UI is installed</target>
        </trans-unit>
        <trans-unit id="0b58ada95969c7cc2b96e1fd97a909c42b180449" translate="yes" xml:space="preserve">
          <source>The progress bar is no longer part of a displayable hierarchy</source>
          <target state="translated">진행률 표시 줄은 더 이상 표시 가능한 계층의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7db88831546fb954fc3d5d9710f6e0ab2f4739c8" translate="yes" xml:space="preserve">
          <source>The progress indicator displays activity without specifying what proportion of the progress is complete.</source>
          <target state="translated">진행률 표시기는 완료된 진행률을 지정하지 않고 활동을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="26c5212b411b32f2f4fb4ac337ae0a4ad3976b99" translate="yes" xml:space="preserve">
          <source>The progress indicator displays with normal color and determinate mode.</source>
          <target state="translated">진행률 표시기는 일반 색상 및 결정 모드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f47f32edf9816a4f888b251afa36f949fce0846c" translate="yes" xml:space="preserve">
          <source>The progress string is painted only if the &lt;code&gt;isStringPainted&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">진행률 문자열은 &lt;code&gt;isStringPainted&lt;/code&gt; 메서드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 경우에만 그려 집니다.</target>
        </trans-unit>
        <trans-unit id="391c694a427ff64d8dedbc35ef6300a0d16bfa8a" translate="yes" xml:space="preserve">
          <source>The proleptic year, such as 2012.</source>
          <target state="translated">2012 년과 같은 다산의 해.</target>
        </trans-unit>
        <trans-unit id="2f8941a3eade121ced3151a4fbe9a184aa501fb3" translate="yes" xml:space="preserve">
          <source>The proleptic-month based, counting months sequentially from year 0.</source>
          <target state="translated">0 년부터 순차적으로 월을 계산하는 proleptic-month based.</target>
        </trans-unit>
        <trans-unit id="4a56a02d5a817b1dc30304481e16ea69bcff2062" translate="yes" xml:space="preserve">
          <source>The properties for loggers and Handlers will have names starting with the dot-separated name for the handler or logger.</source>
          <target state="translated">로거 및 핸들러의 특성은 이름이 핸들러 또는 로거의 점으로 구분 된 이름으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="53b4cc1bbc02ad93af5b4e56711266aa46d88a87" translate="yes" xml:space="preserve">
          <source>The properties returned should contain properties set by the stylesheet, and these properties are &quot;defaulted&quot; by default properties specified by &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;section 16 of the XSL Transformations (XSLT) W3C Recommendation&lt;/a&gt;. The properties that were specifically set by the stylesheet should be in the base Properties list, while the XSLT default properties that were not specifically set should be in the &quot;default&quot; Properties list. Thus, getOutputProperties().getProperty(String key) will obtain any property in that was set by the stylesheet, &lt;em&gt;or&lt;/em&gt; the default properties, while getOutputProperties().get(String key) will only retrieve properties that were explicitly set in the stylesheet.</source>
          <target state="translated">반환 된 속성에는 스타일 시트에서 설정 한 속성이 포함되어야하며 이러한 속성은 &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;XSL 변환 (XSLT) W3C 권장 사항의 섹션 16에&lt;/a&gt; 지정된 기본 속성으로 &quot;기본값&quot; 입니다. 스타일 시트에서 특별히 설정 한 속성은 기본 속성 목록에 있어야하며 특별히 설정되지 않은 XSLT 기본 속성은 &quot;기본&quot;속성 목록에 있어야합니다. 따라서 getOutputProperties (). getProperty (String key)는 스타일 시트에 의해 설정된 속성 &lt;em&gt;또는&lt;/em&gt; 기본 속성을 가져 오는 반면 getOutputProperties (). get (String key)는 스타일 시트에 명시 적으로 설정된 속성 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="924030f16e4e6790ddf29e1281d8ffc937efbad3" translate="yes" xml:space="preserve">
          <source>The properties returned should contain properties set by the user, and properties set by the stylesheet, and these properties are &quot;defaulted&quot; by default properties specified by &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;section 16 of the XSL Transformations (XSLT) W3C Recommendation&lt;/a&gt;. The properties that were specifically set by the user or the stylesheet should be in the base Properties list, while the XSLT default properties that were not specifically set should be the default Properties list. Thus, getOutputProperties().getProperty(String key) will obtain any property in that was set by &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt;, in the stylesheet, &lt;em&gt;or&lt;/em&gt; the default properties, while getOutputProperties().get(String key) will only retrieve properties that were explicitly set by &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt;, or in the stylesheet.</source>
          <target state="translated">반환 된 속성에는 사용자가 설정 한 속성과 스타일 시트가 설정 한 속성이 포함되어야하며 이러한 속성은 &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;XSL 변환 (XSLT) W3C 권장 사항의 섹션 16에&lt;/a&gt; 지정된 기본 속성으로 &quot;기본값&quot; 입니다. 사용자 또는 스타일 시트가 특별히 설정 한 속성은 기본 속성 목록에 있어야하며 특별히 설정되지 않은 XSLT 기본 속성은 기본 속성 목록이어야합니다. 따라서 getOutputProperties는 (). getProperty에은 (문자열 키) 그 의해 설정된 임의의 속성을 획득 할 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 스타일 시트, &lt;em&gt;또는&lt;/em&gt;기본 속성이지만 getOutputProperties (). get (String key)는 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 의해 명시 적으로 설정된 속성 만 검색합니다 . 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="27f833fe6fa37acd5e76ba0606a69897f0ed235c" translate="yes" xml:space="preserve">
          <source>The properties-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; 를 포함하는 속성 전용 형식 &lt;code&gt;List&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="daa8bdb84e81154bc80370cc5e9727f554ff3e32" translate="yes" xml:space="preserve">
          <source>The properties-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;unmodifiable&lt;/a&gt;.</source>
          <target state="translated">속성은 전용 형식 &lt;code&gt;List&lt;/code&gt; 포함 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; . 이 &lt;code&gt;List&lt;/code&gt; 은 &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;수정할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d2cff9c6617a0baba314ee31c1929597466d86" translate="yes" xml:space="preserve">
          <source>The properties-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</source>
          <target state="translated">&lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; 를 포함하는 속성 전용 형식 &lt;code&gt;List&lt;/code&gt; 입니다. 이 &lt;code&gt;List&lt;/code&gt; 은 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="edbaf52dc9114c17a17b8e7f6f915d29977216eb" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;JInternalFrame.isPalette&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JInternalFrame.isPalette&lt;/code&gt; 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="cf5373aab850e2de634fb8554a90fb179e5380fa" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;JScrollBar.isFreeStanding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JScrollBar.isFreeStanding&lt;/code&gt; 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="be6722df6ec5a2e75cae3fda33dde1100cbb76cd" translate="yes" xml:space="preserve">
          <source>The property can be set with the following code line: &lt;code&gt;setProperty(&quot;javax.xml.stream.isRepairingNamespaces&quot;, new Boolean(true|false));&lt;/code&gt;</source>
          <target state="translated">속성은 다음 코드 줄을 사용하여 설정할 수 있습니다. &lt;code&gt;setProperty(&quot;javax.xml.stream.isRepairingNamespaces&quot;, new Boolean(true|false));&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90ef13d5a715c58badd6aeb3009b5ac9131a03a4" translate="yes" xml:space="preserve">
          <source>The property map may contain pre-defined implementation specific and default properties. Users are encouraged to read the information and fully understand the implications, before modifying pre-existing properties.</source>
          <target state="translated">특성 맵에는 사전 정의 된 구현 특정 및 기본 특성이 포함될 수 있습니다. 기존 속성을 수정하기 전에 정보를 읽고 그 의미를 완전히 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="216631b6a2b26fcac5c37473e2eaf40759dbb441" translate="yes" xml:space="preserve">
          <source>The property name &lt;code&gt;&quot;comment&quot;&lt;/code&gt; should be used to store an optional comment which can be presented to the application as a description of the image, its source, or its author.</source>
          <target state="translated">속성 이름 &lt;code&gt;&quot;comment&quot;&lt;/code&gt; 는 이미지, 소스 또는 작성자에 대한 설명으로 응용 프로그램에 표시 될 수있는 선택적 주석을 저장하는 데 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="05614fb918268cb256ef8ff9c79e7c509c6ff6a3" translate="yes" xml:space="preserve">
          <source>The property name for the description of the stream used to initialize the document.</source>
          <target state="translated">문서를 초기화하는 데 사용되는 스트림 설명의 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="65d307effbfb6738fbc49652b7df00c768e32304" translate="yes" xml:space="preserve">
          <source>The property name for the description of the stream used to initialize the document. This should be used if the document was initialized from a stream and anything is known about the stream.</source>
          <target state="translated">문서를 초기화하는 데 사용되는 스트림 설명의 속성 이름입니다. 문서가 스트림에서 초기화되고 스트림에 대해 알려진 경우에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55766c1c4623c812c3048cdf08c9f6f33926a54f" translate="yes" xml:space="preserve">
          <source>The property name for the title of the document, if there is one.</source>
          <target state="translated">문서 제목 (있는 경우)의 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="491a849b11e4c2c0acd318273c6a61f63270a3d9" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; to recognize a property name but temporarily be unable to return its value.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; 를이&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 일시적으로 그 값을 돌려 줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b04117b905a55eae82549e4e3a2b723556877a5c" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; to recognize a property name but to be unable to change the current value.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; 를이&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 현재의 값을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="765dd3a32bda74de713a08c9e42bf1083b24e6ca" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; to recognize a property name but temporarily be unable to return its value. Some property values may be available only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능 &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 일시적으로 그 값을 돌려 줄 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6fa366af3cd654c1c35b4f151e2781b11c57e03" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; to recognize a property name but to be unable to change the current value. Some property values may be immutable or mutable only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능 &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 현재의 값을 변경할 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 변경할 수 없거나 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9efd0eeaa6302fa4fd979a20db22dc2dc37765c" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; to recognize a property name but temporarily be unable to return its value. Some property values may be available only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; 로는&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 일시적으로 그 값을 돌려 줄 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c26b08882aefe98ea2b359c6337181f87d358da5" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; to recognize a property name but to be unable to change the current value. Some property values may be immutable or mutable only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; 로는&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 현재의 값을 변경할 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 변경할 수 없거나 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f21d91a82fc4c162b2dfd34fcdb2d44e94f0d92" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for an XMLReader to recognize a property name but temporarily be unable to return its value. Some property values may be available only in specific contexts, such as before, during, or after a parse.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. XMLReader가 속성 이름을 인식 할 수 있지만 일시적으로 해당 값을 반환 할 수 없습니다. 일부 속성 값은 구문 분석 전, 도중 또는 후와 같은 특정 컨텍스트에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7593858905d16bae87d6ea5c763c7dd7603e0f00" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for an XMLReader to recognize a property name but to be unable to change the current value. Some property values may be immutable or mutable only in specific contexts, such as before, during, or after a parse.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. XMLReader가 속성 이름을 인식 할 수 있지만 현재 값을 변경할 수는 없습니다. 일부 속성 값은 구문 분석 전, 도중 또는 후와 같은 특정 컨텍스트에서만 변경 불가능하거나 변경 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a44166bbcf01d577f1354b0551d5aad5a3ef464" translate="yes" xml:space="preserve">
          <source>The property resource defining the &lt;code&gt;{ID}&lt;/code&gt; variant</source>
          <target state="translated">&lt;code&gt;{ID}&lt;/code&gt; 변형을 정의하는 특성 자원</target>
        </trans-unit>
        <trans-unit id="af5b082804d7c2dde6ea05c46a90e42cc6381e7f" translate="yes" xml:space="preserve">
          <source>The property resource is located with the &lt;code&gt;calendars.properties&lt;/code&gt; file</source>
          <target state="translated">등록 정보 자원은 &lt;code&gt;calendars.properties&lt;/code&gt; 파일 과 함께 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f758999ea110228277da4c8ec83f3970f50ce67" translate="yes" xml:space="preserve">
          <source>The property that requires the parser to coalesce adjacent character data sections</source>
          <target state="translated">파서가 인접한 문자 데이터 섹션을 병합해야하는 속성</target>
        </trans-unit>
        <trans-unit id="e265780daa42ecc2e0802b3158af0dcc9a3d2876" translate="yes" xml:space="preserve">
          <source>The property that requires the parser to resolve external parsed entities</source>
          <target state="translated">파서가 외부 파싱 된 엔터티를 확인해야하는 속성</target>
        </trans-unit>
        <trans-unit id="13afb556feceeb83a36d49a0460475a7e85ddb79" translate="yes" xml:space="preserve">
          <source>The property that requires the parser to support DTDs</source>
          <target state="translated">DTD를 지원하기 위해 파서가 필요한 속성</target>
        </trans-unit>
        <trans-unit id="f462c466c77ecb8aecc01f7fc097bd0ef7bee433" translate="yes" xml:space="preserve">
          <source>The property used to set/get the implementation of the XMLReporter interface</source>
          <target state="translated">XMLReporter 인터페이스의 구현을 설정 / 가져 오는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="4325235510b04660062df652bfe8ef53233412c5" translate="yes" xml:space="preserve">
          <source>The property used to set/get the implementation of the XMLResolver</source>
          <target state="translated">XMLResolver의 구현을 설정 / 가져 오는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="50c756a437d7d9476e61751578d130ff92ae44bf" translate="yes" xml:space="preserve">
          <source>The property used to set/get the implementation of the allocator</source>
          <target state="translated">할당 자의 구현을 설정 / 가져 오는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="99399b40e8299eb71e8be6c59cb3bbd8473d04ed" translate="yes" xml:space="preserve">
          <source>The property used to turn on/off implementation specific validation</source>
          <target state="translated">구현 별 유효성 검사를 설정 / 해제하는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="df5033615f0d4c5aa6046366f6f557d55da8ce89" translate="yes" xml:space="preserve">
          <source>The property used to turn on/off namespace support, this is to support XML 1.0 documents, only the true setting must be supported</source>
          <target state="translated">네임 스페이스 지원을 켜고 끄는 데 사용되는 속성입니다. 이것은 XML 1.0 문서를 지원하기위한 것입니다. true 설정 만 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb305a13af061bdafc684dce06c7fea083824a3c" translate="yes" xml:space="preserve">
          <source>The property value as a human editable string.</source>
          <target state="translated">사람이 편집 할 수있는 문자열 인 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="928506a8e906ccfdc133220356a75d90280830ec" translate="yes" xml:space="preserve">
          <source>The property value as a string suitable for presentation to a human to edit.</source>
          <target state="translated">사람이 편집 할 수 있도록 적합한 문자열 인 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="73101b28e30a36efb57859ac5d834112bb90605f" translate="yes" xml:space="preserve">
          <source>The property value consists of the provider class name and the device name, separated by the hash mark (&quot;#&quot;). The provider class name is the fully-qualified name of a concrete &lt;a href=&quot;spi/midideviceprovider&quot;&gt;&lt;code&gt;MIDI device provider&lt;/code&gt;&lt;/a&gt; class. The device name is matched against the &lt;code&gt;String&lt;/code&gt; returned by the &lt;code&gt;getName&lt;/code&gt; method of &lt;code&gt;MidiDevice.Info&lt;/code&gt;. Either the class name, or the device name may be omitted. If only the class name is specified, the trailing hash mark is optional.</source>
          <target state="translated">속성 값은 공급자 클래스 이름과 장치 이름으로 구성되며 해시 표시 ( &quot;#&quot;)로 구분됩니다. 프로 바이더 클래스 이름은 구체적인 &lt;a href=&quot;spi/midideviceprovider&quot;&gt; &lt;code&gt;MIDI device provider&lt;/code&gt; &lt;/a&gt; 클래스 의 정규화 된 이름입니다 . 장치 이름은 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 의 &lt;code&gt;getName&lt;/code&gt; 메소드가 리턴 한 &lt;code&gt;String&lt;/code&gt; 과 일치 합니다 . 클래스 이름 또는 장치 이름이 생략 될 수 있습니다. 클래스 이름 만 지정하면 후미 해시 마크는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="0fda51bd535de894365d52df1f5e4d52b33dd40e" translate="yes" xml:space="preserve">
          <source>The property value consists of the provider class name and the mixer name, separated by the hash mark (&quot;#&quot;). The provider class name is the fully-qualified name of a concrete &lt;a href=&quot;spi/mixerprovider&quot;&gt;&lt;code&gt;mixer provider&lt;/code&gt;&lt;/a&gt; class. The mixer name is matched against the &lt;code&gt;String&lt;/code&gt; returned by the &lt;code&gt;getName&lt;/code&gt; method of &lt;code&gt;Mixer.Info&lt;/code&gt;. Either the class name, or the mixer name may be omitted. If only the class name is specified, the trailing hash mark is optional.</source>
          <target state="translated">속성 값은 공급자 클래스 이름과 믹서 이름으로 구성되며 해시 표시 ( &quot;#&quot;)로 구분됩니다. 제공자 클래스 이름은 콘크리트 &lt;a href=&quot;spi/mixerprovider&quot;&gt; &lt;code&gt;mixer provider&lt;/code&gt; &lt;/a&gt; 클래스 의 완전한 이름입니다 . 믹서 이름은 &lt;code&gt;Mixer.Info&lt;/code&gt; 의 &lt;code&gt;getName&lt;/code&gt; 메소드가 리턴 한 &lt;code&gt;String&lt;/code&gt; 과 일치합니다 . 클래스 이름 또는 믹서 이름을 생략 할 수 있습니다. 클래스 이름 만 지정하면 후미 해시 마크는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="839344a2affd2c29010b14b6d381310744ba6f63" translate="yes" xml:space="preserve">
          <source>The property value should be one of the forms accepted by &lt;code&gt;Font.decode(String)&lt;/code&gt; If the specified property is not found, or the executing code does not have permission to read the property, the &lt;code&gt;font&lt;/code&gt; argument is returned instead.</source>
          <target state="translated">속성 값은 &lt;code&gt;Font.decode(String)&lt;/code&gt; 허용하는 형식 중 하나 여야합니다 . 지정된 속성을 찾을 수 없거나 실행중인 코드에 속성을 읽을 수있는 권한이없는 경우 &lt;code&gt;font&lt;/code&gt; 인수가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="253fede9392a1c0b18e0b9824d151fca7a0e3b9d" translate="yes" xml:space="preserve">
          <source>The property value.</source>
          <target state="translated">속성 값</target>
        </trans-unit>
        <trans-unit id="a934d82554d845420400459f6c0dabc8ba77a442" translate="yes" xml:space="preserve">
          <source>The protected &lt;code&gt;EditorDelegate&lt;/code&gt; class.</source>
          <target state="translated">보호 된 &lt;code&gt;EditorDelegate&lt;/code&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="374ba4813aef129e3eb1f2074ac73df714237dfe" translate="yes" xml:space="preserve">
          <source>The protocol handler calls this method after a resource has been retrieved, and the ResponseCache must decide whether or not to store the resource in its cache.</source>
          <target state="translated">프로토콜 처리기는 리소스가 검색된 후이 메서드를 호출하고 ResponseCache는 리소스를 캐시에 저장할지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bca8021794336ac922184238ff13cedd04b4c6c" translate="yes" xml:space="preserve">
          <source>The protocol handler calls this method after a resource has been retrieved, and the ResponseCache must decide whether or not to store the resource in its cache. If the resource is to be cached, then put() must return a CacheRequest object which contains an OutputStream that the protocol handler will use to write the resource into the cache. If the resource is not to be cached, then put must return null.</source>
          <target state="translated">프로토콜 핸들러는 리소스가 검색된 후이 메소드를 호출하며 ResponseCache는 리소스를 캐시에 저장할지 여부를 결정해야합니다. 자원을 캐시하려면 put ()은 프로토콜 핸들러가 자원을 캐시에 쓰는 데 사용할 OutputStream을 포함하는 CacheRequest 객체를 반환해야합니다. 자원이 캐시되지 않으면 put은 널을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="4be2401bbc033d02d77ae8d018dde89f5a6c5180" translate="yes" xml:space="preserve">
          <source>The protocol part of the Service URL.</source>
          <target state="translated">서비스 URL의 프로토콜 부분.</target>
        </trans-unit>
        <trans-unit id="a28e98c099c58a5bda5e715045862d609dda783c" translate="yes" xml:space="preserve">
          <source>The protocol-specific requirements are defined in the &lt;a href=&quot;https://tools.ietf.org/html/rfc7540&quot;&gt;Hypertext Transfer Protocol Version 2 (HTTP/2)&lt;/a&gt;, the &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt; Hypertext Transfer Protocol (HTTP/1.1)&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;The WebSocket Protocol&lt;/a&gt;.</source>
          <target state="translated">프로토콜 별 요구 사항은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7540&quot;&gt;HTTP / 2 (Hypertext Transfer Protocol Version 2)&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;HTTP / 1.1 (Hypertext Transfer Protocol)&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;WebSocket 프로토콜에 정의되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c5465d2ff8a6fe16f37629d0bc86289e7d279a" translate="yes" xml:space="preserve">
          <source>The protocols must have been listed by &lt;code&gt;getSupportedProtocols()&lt;/code&gt; as being supported. Following a successful call to this method, only protocols listed in the &lt;code&gt;protocols&lt;/code&gt; parameter are enabled for use.</source>
          <target state="translated">프로토콜은 &lt;code&gt;getSupportedProtocols()&lt;/code&gt; 에 의해 지원되는 것으로 나열되어 있어야합니다 . 이 메소드를 성공적으로 호출하면 &lt;code&gt;protocols&lt;/code&gt; 매개 변수에 나열된 프로토콜 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ceb4dc01f774ca073a268387a29e005c274c187" translate="yes" xml:space="preserve">
          <source>The protocols must have been listed by getSupportedProtocols() as being supported. Following a successful call to this method, only protocols listed in the &lt;code&gt;protocols&lt;/code&gt; parameter are enabled for use.</source>
          <target state="translated">프로토콜은 getSupportedProtocols ()에 의해 지원되는 것으로 나열되어 있어야합니다. 이 메소드를 성공적으로 호출하면 &lt;code&gt;protocols&lt;/code&gt; 매개 변수에 나열된 프로토콜 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9210c3071d14625b46a43f122fc15299c196c44c" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;LocalDate&lt;/code&gt; is interpreted as the local date in the local time zone.</source>
          <target state="translated">제공된 &lt;code&gt;LocalDate&lt;/code&gt; 는 현지 시간대의 현지 날짜로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="276032490e07e1dda2172dc0392e83bfa40a5cb8" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;LocalDateTime&lt;/code&gt; is interpreted as the local date-time in the local time zone.</source>
          <target state="translated">제공된 &lt;code&gt;LocalDateTime&lt;/code&gt; 은 현지 시간대의 현지 날짜-시간으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="39ea298e1ed9cecc5248c7addf960c07d300fb1e" translate="yes" xml:space="preserve">
          <source>The provider class must be visible to the class loader.</source>
          <target state="translated">공급자 클래스는 클래스 로더에 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b819aa1e87112cebc844a816e2d9cca7e54bfec7" translate="yes" xml:space="preserve">
          <source>The provider package list is a string that is interpreted as a list of non-empty Java package names separated by vertical bars (&lt;code&gt;|&lt;/code&gt;). If the string is empty, then so is the provider package list. If the provider package list is not a String, or if it contains an element that is an empty string, a &lt;a href=&quot;jmxproviderexception&quot;&gt;&lt;code&gt;JMXProviderException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">제공자 패키지 목록은 비어 있지 않은 Java 패키지 이름의 목록으로 해석되는 문자열이며 세로 막대 ( &lt;code&gt;|&lt;/code&gt; )로 구분됩니다 . 문자열이 비어 있으면 공급자 패키지 목록도 비어 있습니다. 프로 바이더 패키지리스트가 String가 아닌 경우, 또는 비어있는 캐릭터 라인의 요소가 포함되어있는 경우, &lt;a href=&quot;jmxproviderexception&quot;&gt; &lt;code&gt;JMXProviderException&lt;/code&gt; &lt;/a&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="81ff5f0c2ed16bdcde6df10f629ec05f4f76b747" translate="yes" xml:space="preserve">
          <source>The provider properties each specify the name and location of a particular service implemented by the provider. By granting this permission, you let code replace the service specification with another one, thereby specifying a different implementation.</source>
          <target state="translated">공급자 속성은 각각 공급자가 구현 한 특정 서비스의 이름과 위치를 지정합니다. 이 권한을 부여하면 코드가 서비스 스펙을 다른 것으로 바꾸도록하여 다른 구현을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfdec86c531152b897fae56fc5431156beb1192" translate="yes" xml:space="preserve">
          <source>The provider relies on a &lt;code&gt;CallbackHandler&lt;/code&gt; to obtain authentication information from the caller (a PIN, for example). If the caller passes a &lt;code&gt;null&lt;/code&gt; handler to this method, the provider uses the handler set in the &lt;code&gt;setCallbackHandler&lt;/code&gt; method. If no handler was set in that method, the provider queries the</source>
          <target state="translated">공급자는 &lt;code&gt;CallbackHandler&lt;/code&gt; 를 사용하여 발신자 (예 : PIN)로부터 인증 정보를 얻습니다. 호출자 가이 메소드에 &lt;code&gt;null&lt;/code&gt; 핸들러를 전달 하면 제공자는 &lt;code&gt;setCallbackHandler&lt;/code&gt; 메소드에 설정된 핸들러를 사용합니다 . 해당 메소드에 핸들러가 설정되지 않은 경우 제공자는</target>
        </trans-unit>
        <trans-unit id="1c17253044a3e06989e7d90ee41703431073eb01" translate="yes" xml:space="preserve">
          <source>The provider resource file (&lt;code&gt;jndiprovider.properties&lt;/code&gt;) for the context being operated on.</source>
          <target state="translated">작동중인 컨텍스트에 대한 제공자 자원 파일 ( &lt;code&gt;jndiprovider.properties&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e7c1d350031806c332b9c24a137dd3c90b8b811" translate="yes" xml:space="preserve">
          <source>The provider that created this channel</source>
          <target state="translated">이 채널을 만든 제공 업체</target>
        </trans-unit>
        <trans-unit id="77a39cfcc4e9fe4e8ca3afc28026bfc41ca77e69" translate="yes" xml:space="preserve">
          <source>The provider that created this channel group</source>
          <target state="translated">이 채널 그룹을 만든 공급자</target>
        </trans-unit>
        <trans-unit id="bd0273ec6d54c15dbfb4d880d2bc546ddaf6772d" translate="yes" xml:space="preserve">
          <source>The provider that created this file system.</source>
          <target state="translated">이 파일 시스템을 만든 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="1d3d88e815a75e16ffb4c1ab7a620700614562f3" translate="yes" xml:space="preserve">
          <source>The provider type</source>
          <target state="translated">공급자 유형</target>
        </trans-unit>
        <trans-unit id="e97bc8d34251d21b62200936e722253994322277" translate="yes" xml:space="preserve">
          <source>The provider typically uses a KeyStore as a basis for making trust decisions.</source>
          <target state="translated">제공자는 일반적으로 신뢰 결정을 내리기위한 기준으로 KeyStore를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8eb1ab0ca4032f625e2e248a88d341a2ea149e6e" translate="yes" xml:space="preserve">
          <source>The provider typically uses a KeyStore for obtaining key material for use during secure socket negotiations. The KeyStore is generally password-protected.</source>
          <target state="translated">공급자는 일반적으로 보안 소켓 협상 중에 사용할 키 자료를 얻기 위해 KeyStore를 사용합니다. KeyStore는 일반적으로 비밀번호로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ee7c51b3de3d00b80da9b5d57be36f861ae7af" translate="yes" xml:space="preserve">
          <source>The provider uses this handler if one is not passed to the &lt;code&gt;login&lt;/code&gt; method. The provider also uses this handler if it invokes &lt;code&gt;login&lt;/code&gt; on behalf of callers. In either case if a handler is not set via this method, the provider queries the</source>
          <target state="translated">프로 바이더가 &lt;code&gt;login&lt;/code&gt; 메소드에 전달되지 않으면이 핸들러를 사용합니다 . 공급자는 발신자를 대신하여 &lt;code&gt;login&lt;/code&gt; 을 호출하는 경우에도이 핸들러를 사용합니다 . 두 경우 모두 핸들러가이 메소드를 통해 설정되지 않은 경우 제공자는</target>
        </trans-unit>
        <trans-unit id="9a14653f68a78cf5317ff6c4d28abc9bf7e7ffec" translate="yes" xml:space="preserve">
          <source>The proxy forwards all requests to the encapsulated transferable and automatically performs additional conversion on the data returned by the encapsulated transferable in case of local transfer.</source>
          <target state="translated">프록시는 모든 요청을 캡슐화 된 전송 가능 항목으로 전달하고 로컬 전송의 경우 캡슐화 된 전송 가능 항목에서 반환 된 데이터에 대해 추가 변환을 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b50d88e8c90fab7f40e58f79439f226bc1b3f211" translate="yes" xml:space="preserve">
          <source>The proxy implements all the remote interfaces implemented by the remote object's class.</source>
          <target state="translated">프록시는 원격 객체의 클래스에 의해 구현 된 모든 원격 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5fb92df931a046e4e96ec8a961568a0710597d9c" translate="yes" xml:space="preserve">
          <source>The proxy's class is defined according to the specifications for the &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy#membership&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; class, using the class loader of the remote object's class.</source>
          <target state="translated">프록시의 클래스는 원격 개체 클래스의 클래스 로더를 사용하여 &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy#membership&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 클래스 의 사양에 따라 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="09deea942a6e744cdc803da8c6c2dfa4a09a0e5d" translate="yes" xml:space="preserve">
          <source>The proxy's invocation handler is a &lt;a href=&quot;remoteobjectinvocationhandler&quot;&gt;&lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;&lt;/a&gt; instance constructed with a &lt;a href=&quot;remoteref&quot;&gt;&lt;code&gt;RemoteRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프록시의 호출 핸들러는 &lt;a href=&quot;remoteref&quot;&gt; &lt;code&gt;RemoteRef&lt;/code&gt; 로&lt;/a&gt; 구성된 &lt;a href=&quot;remoteobjectinvocationhandler&quot;&gt; &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt; &lt;/a&gt; 인스턴스 입니다.</target>
        </trans-unit>
        <trans-unit id="b083456a4a9c6284da1cf31e08008817ef68ed33" translate="yes" xml:space="preserve">
          <source>The pseudo code for the rescaling operation is as follows:</source>
          <target state="translated">크기 조정 작업을위한 의사 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cbb75c3c1cc6c2af9021f9f5e045df931d8ccd5" translate="yes" xml:space="preserve">
          <source>The pseudo-type corresponding to the keyword &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;void&lt;/code&gt; 에 해당하는 의사 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="94f0a25ea40a5d8f1223e160a1f04a7a4b183b85" translate="yes" xml:space="preserve">
          <source>The pseudo/hidden column may only be used in a SELECT list.</source>
          <target state="translated">의사 / 숨겨진 열은 SELECT 목록에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca6478c62d3dc1f97483e29223ff3d12797f8b7c" translate="yes" xml:space="preserve">
          <source>The pseudo/hidden column may only be used in a WHERE clause.</source>
          <target state="translated">의사 / 숨겨진 열은 WHERE 절에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4812bd2f1ef82113d348414069707122f4719cd1" translate="yes" xml:space="preserve">
          <source>The pseudocode for the resulting adapter looks as follows. In the code, &lt;code&gt;V&lt;/code&gt; represents the result type of the &lt;code&gt;try/finally&lt;/code&gt; construct; &lt;code&gt;A&lt;/code&gt;/&lt;code&gt;a&lt;/code&gt;, the types and values of arguments to the resulting handle consumed by the cleanup; and &lt;code&gt;B&lt;/code&gt;/&lt;code&gt;b&lt;/code&gt;, those of arguments to the resulting handle discarded by the cleanup.</source>
          <target state="translated">결과 어댑터의 의사 코드는 다음과 같습니다. 코드에서 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;try/finally&lt;/code&gt; 구문 의 결과 유형을 나타냅니다 . &lt;code&gt;A&lt;/code&gt; / &lt;code&gt;a&lt;/code&gt; , 정리에 사용되는 결과 핸들에 대한 인수의 유형 및 값. 및 &lt;code&gt;B&lt;/code&gt; / &lt;code&gt;b&lt;/code&gt; , 정리에 의해 폐기 된 결과 핸들에 대한 인수입니다.</target>
        </trans-unit>
        <trans-unit id="f1c0bbc66bdb6ee141f8f29a8594a0f7f7c26d71" translate="yes" xml:space="preserve">
          <source>The public exponent-value F4 = 65537.</source>
          <target state="translated">공개 지수 값 F4 = 65537.</target>
        </trans-unit>
        <trans-unit id="889b7ac5748f9ffaedc89e0966ff01f02908492a" translate="yes" xml:space="preserve">
          <source>The public identifier and system identifier are &lt;code&gt;null&lt;/code&gt;, and byte and character stream are either &lt;code&gt;null&lt;/code&gt; or contain no byte or character.</source>
          <target state="translated">공용 식별자 및 시스템 식별자는 &lt;code&gt;null&lt;/code&gt; 이고 바이트 및 문자 스트림은 &lt;code&gt;null&lt;/code&gt; 이거나 바이트 또는 문자를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="607a67c14bf23bd75e74af63fd58a783d5e8e1e8" translate="yes" xml:space="preserve">
          <source>The public identifier as a string, or null if none is available.</source>
          <target state="translated">공용 식별자 (문자열) 또는 사용할 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="666d68a6bc57f9864e5a56565fbc5a900e031826" translate="yes" xml:space="preserve">
          <source>The public identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">엔티티와 연관된 공용 식별자 (지정된 경우), 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3641e2bf5da57b5d4d6f8981fd5ba25936de99d5" translate="yes" xml:space="preserve">
          <source>The public identifier for the XML Schema definition that defines the XML tags and their valid values for a &lt;code&gt;WebRowSet&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;WebRowSet&lt;/code&gt; 구현에 대한 XML 태그 및 유효한 값을 정의하는 XML 스키마 정의의 공용 식별자입니다 .</target>
        </trans-unit>
        <trans-unit id="6082fcf3b4787c7e3fa7e05f8cd01a60bcc96655" translate="yes" xml:space="preserve">
          <source>The public identifier for this input source.</source>
          <target state="translated">이 입력 소스의 공개 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="306fe0d5ecd3a197943ce9157ab37545b45833fc" translate="yes" xml:space="preserve">
          <source>The public identifier for this input source. This may be mapped to an input source using an implementation dependent mechanism (such as catalogues or other mappings). The public identifier, if specified, may also be reported as part of the location information when errors are reported.</source>
          <target state="translated">이 입력 소스의 공개 식별자입니다. 이는 구현 종속 메커니즘 (예 : 카탈로그 또는 기타 매핑)을 사용하여 입력 소스에 매핑 될 수 있습니다. 지정된 경우 공개 식별자는 오류가보고 될 때 위치 정보의 일부로보고 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8616cf097304d23ed9bdee5a10da665d66f611aa" translate="yes" xml:space="preserve">
          <source>The public identifier is always optional: if the application writer includes one, it will be provided as part of the location information.</source>
          <target state="translated">공개 식별자는 항상 선택 사항입니다. 응용 프로그램 작성자에 포함 된 경우 위치 정보의 일부로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="084fd15bde5749cac40870c17b4a07ccada3bfac" translate="yes" xml:space="preserve">
          <source>The public identifier of the external subset.</source>
          <target state="translated">외부 하위 집합의 공개 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="e59aa7e65372678aa563cfbbb9d944fcecc85ead" translate="yes" xml:space="preserve">
          <source>The public identifier of this notation.</source>
          <target state="translated">이 표기법의 공용 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="af89db99417a364a5ed02edd579e71607f09ad52" translate="yes" xml:space="preserve">
          <source>The public identifier of this notation. If the public identifier was not specified, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 표기법의 공용 식별자입니다. 공용 식별자가 지정되지 않은 경우 이것은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="452a322725b189c1bd9848c6035428fa8271f855" translate="yes" xml:space="preserve">
          <source>The public identifier that was set with setPublicId, or null if setPublicId was not called.</source>
          <target state="translated">setPublicId로 설정된 공용 식별자 또는 setPublicId가 호출되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="1d7f2c29e78db86abe70e3052b6a63ed7f102e04" translate="yes" xml:space="preserve">
          <source>The public identifier, or null if none was supplied.</source>
          <target state="translated">공용 식별자 또는 제공되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="f26be22251f1ffca01d91cc5cb358dc14cdbbb9d" translate="yes" xml:space="preserve">
          <source>The public key or the signature algorithm has been constrained.</source>
          <target state="translated">공개 키 또는 서명 알고리즘이 제한되었습니다.</target>
        </trans-unit>
        <trans-unit id="c28eb2aa6086a8572e42d5f820ee00606327026e" translate="yes" xml:space="preserve">
          <source>The public methods of all &lt;code&gt;CertStoreSpi&lt;/code&gt; objects must be thread-safe. That is, multiple threads may concurrently invoke these methods on a single &lt;code&gt;CertStoreSpi&lt;/code&gt; object (or more than one) with no ill effects. This allows a &lt;code&gt;CertPathBuilder&lt;/code&gt; to search for a CRL while simultaneously searching for further certificates, for instance.</source>
          <target state="translated">모든 &lt;code&gt;CertStoreSpi&lt;/code&gt; 객체 의 공개 메소드는 스레드로부터 안전해야합니다. 즉, 여러 스레드가 동시에 단일 &lt;code&gt;CertStoreSpi&lt;/code&gt; 객체 (또는 둘 이상)에서 이러한 효과를 발생시키지 않으면 서 이러한 메서드를 호출 할 수 있습니다 . 이를 통해 &lt;code&gt;CertPathBuilder&lt;/code&gt; 는 예를 들어 추가 인증서를 동시에 검색하면서 CRL을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a02308f567fb58540f6ccefee2675e6a72ad544b" translate="yes" xml:space="preserve">
          <source>The public-exponent value F0 = 3.</source>
          <target state="translated">공개 지수 값 F0 = 3</target>
        </trans-unit>
        <trans-unit id="ffd416e4ee6aca89b81f63e35d9c17c738fb2e7a" translate="yes" xml:space="preserve">
          <source>The publisher returned by the &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;body&lt;/code&gt;&lt;/a&gt; method can be subscribed to only once. The first subscriber will receive the body response bytes if successfully subscribed, or will cause the subscription to be cancelled otherwise. If more subscriptions are attempted, the subsequent subscribers will be immediately subscribed with an empty subscription and their &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber#onError(java.lang.Throwable)&quot;&gt;&lt;code&gt;onError&lt;/code&gt;&lt;/a&gt; method will be invoked with an &lt;code&gt;IllegalStateException&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;body&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 게시자는 한 번만 구독 할 수 있습니다. 첫 번째 구독자는 성공적으로 구독하면 본문 응답 바이트를 수신하고 그렇지 않으면 구독이 취소됩니다. 더 많은 구독이 시도되면 후속 구독자는 빈 구독으로 즉시 구독되며 &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber#onError(java.lang.Throwable)&quot;&gt; &lt;code&gt;onError&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;code&gt;IllegalStateException&lt;/code&gt; 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="70b9b090e2e3af4d5dc6ecafb7583d4cc88b82f8" translate="yes" xml:space="preserve">
          <source>The purpose of the key that is to be selected.</source>
          <target state="translated">선택할 키의 목적입니다.</target>
        </trans-unit>
        <trans-unit id="0a218ad17fd93df6b98634337c4e7514b88c3517" translate="yes" xml:space="preserve">
          <source>The purpose of the methods to transform to/from the well-defined CIEXYZ color space is to support conversions between any two color spaces at a reasonably high degree of accuracy. It is expected that particular implementations of subclasses of ColorSpace (e.g. ICC_ColorSpace) will support high performance conversion based on underlying platform color management systems.</source>
          <target state="translated">잘 정의 된 CIEXYZ 색상 공간으로 /에서 변환하는 방법의 목적은 상당히 높은 정확도로 두 색상 공간 간의 변환을 지원하는 것입니다. ColorSpace의 하위 클래스 (예 : ICC_ColorSpace)의 특정 구현은 기본 플랫폼 색상 관리 시스템을 기반으로하는 고성능 변환을 지원할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="58212aee8e35283834dfaea45dcaab9b066bc5e9" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all &lt;code&gt;CertStore&lt;/code&gt; parameter specifications. All &lt;code&gt;CertStore&lt;/code&gt; parameter specifications must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 &lt;code&gt;CertStore&lt;/code&gt; 파라미터 사양 을 그룹화 (및 형태 안전성을 제공)하는 것입니다. 모든 &lt;code&gt;CertStore&lt;/code&gt; 매개 변수 스펙은이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="497084f3740257fa01928dfab9f2a8bd92f16644" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all certification path validator results. All results returned by the &lt;a href=&quot;certpathvalidator#validate(java.security.cert.CertPath,java.security.cert.CertPathParameters)&quot;&gt;&lt;code&gt;CertPathValidator.validate&lt;/code&gt;&lt;/a&gt; method must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 인증 경로 유효성 검사기 결과를 그룹화하고 유형 안전성을 제공하는 것입니다. &lt;a href=&quot;certpathvalidator#validate(java.security.cert.CertPath,java.security.cert.CertPathParameters)&quot;&gt; &lt;code&gt;CertPathValidator.validate&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 모든 결과는 이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f81245615bb3902dc0ddd73189d74b0875c911f" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all certification path validator results. All results returned by the &lt;a href=&quot;certpathvalidator#validate-java.security.cert.CertPath-java.security.cert.CertPathParameters-&quot;&gt;&lt;code&gt;CertPathValidator.validate&lt;/code&gt;&lt;/a&gt; method must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 인증 경로 유효성 검사기 결과를 그룹화하고 형식 안전성을 제공하는 것입니다. &lt;a href=&quot;certpathvalidator#validate-java.security.cert.CertPath-java.security.cert.CertPathParameters-&quot;&gt; &lt;code&gt;CertPathValidator.validate&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 모든 결과는 이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="f40bfb04d6225f59e5f6ed15eef633d42be0d88d" translate="yes" xml:space="preserve">
          <source>The pushback buffer.</source>
          <target state="translated">푸시 백 버퍼.</target>
        </trans-unit>
        <trans-unit id="c4aab08f812dbdbd1e2f17d2f57df09ad2f9651a" translate="yes" xml:space="preserve">
          <source>The quality of implementation specifications concern two properties, accuracy of the returned result and monotonicity of the method. Accuracy of the floating-point &lt;code&gt;Math&lt;/code&gt; methods is measured in terms of</source>
          <target state="translated">구현 사양의 품질은 반환 된 결과의 정확성과 메서드의 단일성이라는 두 가지 속성과 관련됩니다. 부동 소수점 &lt;code&gt;Math&lt;/code&gt; 방법 의 정확도 는</target>
        </trans-unit>
        <trans-unit id="f5cb0e2e965fe133bfc4b502b0d3bcf943a71b82" translate="yes" xml:space="preserve">
          <source>The quarter-of-year can only be calculated if the month-of-year is available.</source>
          <target state="translated">해당 연도는 해당 월을 사용할 수있는 경우에만 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddac52873ee50d0b150f5774b33d3171bd12498" translate="yes" xml:space="preserve">
          <source>The query can be used as follows:</source>
          <target state="translated">쿼리는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70bb5883a481eb39ca30783c6a7918ebefc04d35" translate="yes" xml:space="preserve">
          <source>The query component of a URI, if defined, only contains legal URI characters.</source>
          <target state="translated">URI의 쿼리 구성 요소는 정의 된 경우 유효한 URI 문자 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e864d8346a749cfdd6a77c410e2c3f6c279670bc" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;LocalDate&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6043cc3fa8c882b0feedaeddf7526a1d1132efc5" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;LocalTime&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;LocalTime&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b5e706d8394f50472ebf16e28898a8a1e6a58887" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;ZoneOffset&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a9d533d67b796aabaca7323db73ec2da2a5567db" translate="yes" xml:space="preserve">
          <source>The query submitted by the driver to validate the connection shall be executed in the context of the current transaction.</source>
          <target state="translated">연결을 확인하기 위해 드라이버가 제출 한 쿼리는 현재 트랜잭션의 컨텍스트에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b701fffe515ad54c8901b8edcc958e95fc0863c4" translate="yes" xml:space="preserve">
          <source>The quotes surrounding a quoted value, and any backslashes within that value, are considered to be part of the value.</source>
          <target state="translated">따옴표로 묶은 따옴표와 해당 값 내의 백 슬래시는 값의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a7d974dd7e85a61e651a1f194908d0947c9c72a3" translate="yes" xml:space="preserve">
          <source>The radix is either smaller than &lt;a href=&quot;character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or larger than &lt;a href=&quot;character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기수는 하나보다 작은 &lt;a href=&quot;character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt; 보다 작거나 큰 &lt;a href=&quot;character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aff07d7777d5b73265b5ea3b6fd0d12004a2b97" translate="yes" xml:space="preserve">
          <source>The range is never null. For example, the 'Year' field is shorthand for 'YearOfForever'. It therefore has a unit of 'Years' and a range of 'Forever'.</source>
          <target state="translated">범위는 null이 아닙니다. 예를 들어 'Year'필드는 'YearOfForever'의 줄임말입니다. 따라서 '년'단위와 '영원히'범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c3676b410b66174f1db5ce3adf03537f612813" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This date is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 날짜는 반환 범위의 정확성을 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 인해 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3be0f1078a3bff28a13de38bf87eb44d5f6cfd7c" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This date-time is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 날짜-시간은 반환 된 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91574718820af02ba334ca5d2fcaa8ec6eaea0fc" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This day-of-week is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 요일은 반환 된 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49564c5fdd906eee0231c2e097092a4591ff74b8" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This era is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 시대는 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d7949501ac98f64cd52d82177d9b4791e0d319f3" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This instant is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 순간은 반환 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a75a30588e66efcb4e03e0edc195ee3a6dc4a14" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This month is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 달은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e107332e6198f288dc13a1a398312820086bba7b" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This month-day is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 달은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="014329a030e2ab6f6b560564601eb56834e5e981" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This offset is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 오프셋은 반환 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8e7e158ec4085c5caa0000a57a4cf2e6742dd0c" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This time is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 시간은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="735932a1888a19dccb3e713207eb70618d6c1110" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This year is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 올해는 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="461a26e4d72a556581a55b26af7476b03a89d671" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This year-month is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 올해의 월은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85b6f271b8e9dbcfec00b32e847d50024b09f127" translate="yes" xml:space="preserve">
          <source>The range of a duration requires the storage of a number larger than a &lt;code&gt;long&lt;/code&gt;. To achieve this, the class stores a &lt;code&gt;long&lt;/code&gt; representing seconds and an &lt;code&gt;int&lt;/code&gt; representing nanosecond-of-second, which will always be between 0 and 999,999,999. The model is of a directed duration, meaning that the duration may be negative.</source>
          <target state="translated">기간의 범위에는 &lt;code&gt;long&lt;/code&gt; 보다 큰 수의 저장이 필요합니다 . 이를 달성하기 위해 클래스는 &lt;code&gt;long&lt;/code&gt; 을 나타내는 초와 나노초를 나타내는 &lt;code&gt;int&lt;/code&gt; 를 저장하며 , 항상 0에서 999,999,999 사이입니다. 모델의 지속 시간은 지속 시간이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32e38d37e14ca58b0618d587028515e73e2533f4" translate="yes" xml:space="preserve">
          <source>The range of an instant requires the storage of a number larger than a &lt;code&gt;long&lt;/code&gt;. To achieve this, the class stores a &lt;code&gt;long&lt;/code&gt; representing epoch-seconds and an &lt;code&gt;int&lt;/code&gt; representing nanosecond-of-second, which will always be between 0 and 999,999,999. The epoch-seconds are measured from the standard Java epoch of &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; where instants after the epoch have positive values, and earlier instants have negative values. For both the epoch-second and nanosecond parts, a larger value is always later on the time-line than a smaller value.</source>
          <target state="translated">인스턴트의 범위에는 &lt;code&gt;long&lt;/code&gt; 보다 큰 수의 저장이 필요합니다 . 이를 달성하기 위해 클래스는 &lt;code&gt;long&lt;/code&gt; 을 나타내는 초 (epoch-seconds)와 &lt;code&gt;int&lt;/code&gt; ( 초)를 나타내며, 항상 0에서 999,999,999 사이입니다. 신기원 초는 신기원 이후의 순간은 양수 값을 가지며 초기 순간은 음수 값 을 갖는 표준 Java 신기원 &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; 에서 측정 됩니다. 에포크 초 및 나노초 부분 모두에 대해, 더 큰 값은 항상 더 작은 값보다 타임 라인에서 늦습니다.</target>
        </trans-unit>
        <trans-unit id="9c4be6accb9dad9be6efe2a2837d3150210f72f4" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;#getBaseUnit()&quot;&gt;&lt;code&gt;getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 달라지는 기간입니다. 예를 들어 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;#getBaseUnit()&quot;&gt; &lt;code&gt;getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="679d54d91b72b6e361f360707cfcab80ec107617" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt;&lt;code&gt;TemporalField.getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 변하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt; &lt;code&gt;TemporalField.getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d54476f03a91c05aa619016f50c3163119ec639" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt;&lt;code&gt;getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 변하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt; &lt;code&gt;getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb9262661e91ed7bef2f4dcc6a38ba0c83ed604f" translate="yes" xml:space="preserve">
          <source>The range of valid Japanese eras can change over time due to the nature of the Japanese calendar system.</source>
          <target state="translated">유효한 일본 시대의 범위는 일본 달력 시스템의 특성으로 인해 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bed82254a2488e57b5e72ee8db8066e750b8a42" translate="yes" xml:space="preserve">
          <source>The range of valid values for a date-time field.</source>
          <target state="translated">날짜-시간 필드에 유효한 값의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="f74c7503d6071b30c8c61a8b75f2f1ec45dd13e0" translate="yes" xml:space="preserve">
          <source>The raw authority component of this URI, or &lt;code&gt;null&lt;/code&gt; if the authority is undefined</source>
          <target state="translated">이 URI의 원시 권한 컴퍼넌트. 또는 권한이 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0f93a7d9b2a593cc73021049a4babe847f8e5a" translate="yes" xml:space="preserve">
          <source>The raw fragment component of this URI, or &lt;code&gt;null&lt;/code&gt; if the fragment is undefined</source>
          <target state="translated">이 URI의 raw fragment 컴퍼넌트 . 프래그먼트가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08a189753abac31378f32795de3236540870ae3b" translate="yes" xml:space="preserve">
          <source>The raw query component of this URI, or &lt;code&gt;null&lt;/code&gt; if the query is undefined</source>
          <target state="translated">이 URI의 원시 쿼리 컴퍼넌트 . 쿼리가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05172f64d4d3b180d734e94e231efb1e5ba69223" translate="yes" xml:space="preserve">
          <source>The raw scheme-specific part of this URI (never &lt;code&gt;null&lt;/code&gt;)</source>
          <target state="translated">이 URI의 미가공 스킴 특정 부분 ( &lt;code&gt;null&lt;/code&gt; 은 아님)</target>
        </trans-unit>
        <trans-unit id="5e87c817a622606571e558fb125257b7d14ba713" translate="yes" xml:space="preserve">
          <source>The raw user-information component of this URI, or &lt;code&gt;null&lt;/code&gt; if the user information is undefined</source>
          <target state="translated">이 URI의 원시의 사용자 정보 컴퍼넌트 . 사용자 정보가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f41303d8fd6ce5aa0821756418e069b981b7b161" translate="yes" xml:space="preserve">
          <source>The read end of a pipe</source>
          <target state="translated">파이프의 읽기 끝</target>
        </trans-unit>
        <trans-unit id="2f625a725ca986b919f09071c8736ca180edd0b0" translate="yes" xml:space="preserve">
          <source>The read lock and write lock both support interruption during lock acquisition.</source>
          <target state="translated">읽기 잠금 및 쓰기 잠금은 잠금 획득 중 중단을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1910ace8ec568ce21c0234fca6b9fc966c9cfd9a" translate="yes" xml:space="preserve">
          <source>The read lock does not support a &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;readLock().newCondition()&lt;/code&gt; throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">읽기 잠금 장치가 지원하지 않는 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;readLock().newCondition()&lt;/code&gt; 발생 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가가 .</target>
        </trans-unit>
        <trans-unit id="2ef8ece400c68c93f9421b6ba44a9c57dd5cbaa4" translate="yes" xml:space="preserve">
          <source>The read lock is acquired by the current thread; or</source>
          <target state="translated">읽기 잠금은 현재 스레드에 의해 획득됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="c9ea905530375593b0c66214e6790341afceb692" translate="yes" xml:space="preserve">
          <source>The read operation may read up to</source>
          <target state="translated">읽기 작업은 최대</target>
        </trans-unit>
        <trans-unit id="2865a10b019911b5946864d5522b0a72162698af" translate="yes" xml:space="preserve">
          <source>The read position of the input stream is positioned to the next available byte after the encoded distinguished name.</source>
          <target state="translated">입력 스트림의 읽기 위치는 인코딩 된 식별 이름 다음에 사용 가능한 다음 바이트에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="634db75a4e5ec4659af37c3e0e8afa693c0276b7" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading and restoring the state of the object for its particular class using data written to the stream by the corresponding writeObject method. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object. Reading primitive data types is supported by DataInput.</source>
          <target state="translated">readObject 메소드는 해당 writeObject 메소드로 스트림에 기록 된 데이터를 사용하여 특정 클래스의 오브젝트 상태를 읽고 복원합니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. 개별 필드에 대한 ObjectInputStream에서 데이터를 읽고 오브젝트의 해당 필드에 지정하여 상태를 복원합니다. 기본 데이터 유형 읽기는 DataInput에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8520a1a1ecaa0cf4e920c8fe17c0f626c164c35d" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading from the stream and restoring the classes fields. It may call in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields. The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object. Reading primitive data types is supported by DataInput.</source>
          <target state="translated">readObject 메서드는 스트림에서 읽고 클래스 필드를 복원합니다. in.defaultReadObject를 호출하여 객체의 비 정적 및 비 일시적 필드를 복원하기위한 기본 메커니즘을 호출 할 수 있습니다. defaultReadObject 메서드는 스트림의 정보를 사용하여 스트림에 저장된 개체의 필드를 현재 개체의 해당 이름이 지정된 필드와 함께 할당합니다. 이것은 새로운 필드를 추가하기 위해 클래스가 진화 한 경우를 처리합니다. 이 메서드는 수퍼 클래스 나 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. 상태는 개별 필드에 대한 ObjectInputStream에서 데이터를 읽고 객체의 적절한 필드에 할당하여 복원됩니다. 기본 데이터 유형 읽기는 DataInput에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d20e6c840d9627a8eaa7891d9565907ed4a7abbb" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading from the stream and restoring the classes fields. It may call in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields. The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.</source>
          <target state="translated">readObject 메소드는 스트림에서 읽고 클래스 필드를 복원합니다. 객체의 비 정적 및 비 일시적 필드를 복원하기위한 기본 메커니즘을 호출하기 위해 in.defaultReadObject를 호출 할 수 있습니다. defaultReadObject 메소드는 스트림의 정보를 사용하여 스트림에 저장된 오브젝트의 필드를 현재 오브젝트의 해당 이름이 지정된 필드에 지정합니다. 이것은 클래스가 새로운 필드를 추가하도록 진화 한 경우를 처리합니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. writeObject 메소드를 사용하거나 DataOutput이 지원하는 기본 데이터 유형의 메소드를 사용하여 개별 필드를 ObjectOutputStream에 기록하여 상태가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1a89c7b63eeec0e71ccea53ce7c51271148781b8" translate="yes" xml:space="preserve">
          <source>The readObjectNoData method is responsible for initializing the state of the object for its particular class in the event that the serialization stream does not list the given class as a superclass of the object being deserialized. This may occur in cases where the receiving party uses a different version of the deserialized instance's class than the sending party, and the receiver's version extends classes that are not extended by the sender's version. This may also occur if the serialization stream has been tampered; hence, readObjectNoData is useful for initializing deserialized objects properly despite a &quot;hostile&quot; or incomplete source stream.</source>
          <target state="translated">readObjectNoData 메소드는 직렬화 스트림이 지정된 클래스를 직렬화 해제중인 오브젝트의 수퍼 클래스로 나열하지 않는 경우 특정 클래스의 오브젝트 상태를 초기화합니다. 이는 수신 측이 전송 측과 다른 버전의 직렬화 해제 인스턴스 클래스를 사용하고 수신자의 버전이 송신자 버전이 확장하지 않은 클래스를 확장하는 경우에 발생할 수 있습니다. 직렬화 스트림이 변조 된 경우에도 발생할 수 있습니다. 따라서 readObjectNoData는 &quot;적대적&quot;또는 불완전한 소스 스트림에도 불구하고 역 직렬화 된 객체를 올바르게 초기화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db45e6393a0e6e733dd17719a250e994558a12bb" translate="yes" xml:space="preserve">
          <source>The readStreamHeader method is provided to allow subclasses to read and verify their own stream headers.</source>
          <target state="translated">readStreamHeader 메소드는 서브 클래스가 자신의 스트림 헤더를 읽고 확인할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f02ead4cd4d703a4fc4aec1b89640970265ef72c" translate="yes" xml:space="preserve">
          <source>The readStreamHeader method is provided to allow subclasses to read and verify their own stream headers. It reads and verifies the magic number and version number.</source>
          <target state="translated">readStreamHeader 메소드는 서브 클래스가 자체 스트림 헤더를 읽고 확인할 수 있도록 제공됩니다. 마법 번호와 버전 번호를 읽고 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b8970b91121ef6350ebd73016d3cfaeca16ee503" translate="yes" xml:space="preserve">
          <source>The reader associated with this console</source>
          <target state="translated">이 콘솔과 관련된 독자</target>
        </trans-unit>
        <trans-unit id="34e5f7ec6cf4640a064600b8a13abb578ea1e6fd" translate="yes" xml:space="preserve">
          <source>The reader can be configured by registering actions (of type &lt;code&gt;HTMLDocument.HTMLReader.TagAction&lt;/code&gt;) that describe how to handle the action. The idea behind the actions provided is that the most natural text editing operations can be provided if the element structure boils down to paragraphs with runs of some kind of style in them. Some things are more naturally specified structurally, so arbitrary structure should be allowed above the paragraphs, but will need to be edited with structural actions. The implication of this is that some of the HTML elements specified in the stream being parsed will be collapsed into attributes, and in some cases paragraphs will be synthesized. When HTML elements have been converted to attributes, the attribute key will be of type HTML.Tag, and the value will be of type AttributeSet so that no information is lost. This enables many of the existing actions to work so that the user can type input, hit the return key, backspace, delete, etc and have a reasonable result. Selections can be created, and attributes applied or removed, etc. With this in mind, the work done by the reader can be categorized into the following kinds of tasks:</source>
          <target state="translated">리더는 &lt;code&gt;HTMLDocument.HTMLReader.TagAction&lt;/code&gt; 유형의 조치를 등록하여 구성 할 수 있습니다.) 작업을 처리하는 방법을 설명합니다. 제공된 작업의이면에있는 아이디어는 요소 구조가 어떤 종류의 스타일로 실행되는 단락으로 요약되는 경우 가장 자연스러운 텍스트 편집 작업이 제공 될 수 있다는 것입니다. 어떤 것들은 구조적으로 더 자연스럽게 지정되므로 임의의 구조가 단락 위에 허용되어야하지만 구조적 조치로 편집해야합니다. 이것의 의미는 구문 분석되는 스트림에 지정된 일부 HTML 요소가 속성으로 축소되고 경우에 따라 단락이 합성된다는 것입니다. HTML 요소가 속성으로 변환 된 경우 속성 키는 HTML.Tag 유형이되고 값은 정보가 손실되지 않도록 AttributeSet 유형이됩니다. 이것은 사용자가 입력을 입력하고 리턴 키를 누르고,백 스페이스, 삭제 등을 수행하고 합리적인 결과를 얻습니다. 선택을 생성하고 속성을 적용하거나 제거 할 수 있습니다.이를 염두에두고 독자가 수행 한 작업을 다음과 같은 종류의 작업으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf210785560df5e3fd9338a81e883e6a91061562" translate="yes" xml:space="preserve">
          <source>The reader for this &lt;code&gt;CachedRowSet&lt;/code&gt; object will use</source>
          <target state="translated">이 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체 의 리더는</target>
        </trans-unit>
        <trans-unit id="6c69219580471766868b9f3ba0f7605623a45c33" translate="yes" xml:space="preserve">
          <source>The reader must not be operated on during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">터미널 스트림 작업을 실행하는 동안 리더를 작동시키지 않아야합니다. 그렇지 않으면 터미널 스트림 작업의 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ae6624a403eb2ed6a2939e1c276174b1b68bae0" translate="yes" xml:space="preserve">
          <source>The reader's default action for malformed-input and unmappable-character errors is to &lt;a href=&quot;../charset/codingerroraction#REPORT&quot;&gt;report&lt;/a&gt; them. When more control over the error handling is required, the constructor that takes a &lt;a href=&quot;../charset/charsetdecoder&quot;&gt;CharsetDecoder&lt;/a&gt; should be used.</source>
          <target state="translated">잘못된 입력 및 매핑 할 수없는 문자 오류에 대한 독자의 기본 조치는이를 &lt;a href=&quot;../charset/codingerroraction#REPORT&quot;&gt;보고&lt;/a&gt; 하는 것입니다. 오류 처리에 대한 추가 제어가 필요한 경우 &lt;a href=&quot;../charset/charsetdecoder&quot;&gt;CharsetDecoder&lt;/a&gt; 를 사용 하는 생성자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="453ec519eda3fcb734a7ed183e48753d77c803a1" translate="yes" xml:space="preserve">
          <source>The reader/writer facility provided by the &lt;code&gt;SyncProvider&lt;/code&gt; class is pluggable, allowing for the customization of data retrieval and updating. If a different concurrency control mechanism is desired, a different implementation of &lt;code&gt;SyncProvider&lt;/code&gt; can be plugged in using the method &lt;code&gt;setSyncProvider&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SyncProvider&lt;/code&gt; 클래스에서 제공하는 리더 / 라이터 기능 은 플러그 가능하므로 데이터 검색 및 업데이트를 사용자 정의 할 수 있습니다. 다른 동시성 제어 메커니즘이 필요한 경우 &lt;code&gt;setSyncProvider&lt;/code&gt; 메소드를 사용하여 다른 &lt;code&gt;SyncProvider&lt;/code&gt; 구현을 플러그인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8998e48671432cbbcd265dfa2ebdacbf0a22841c" translate="yes" xml:space="preserve">
          <source>The real paint behavior occurs naturally from the association that the component has with its parent container (the same container hosting this view).</source>
          <target state="translated">실제 페인트 동작은 구성 요소가 부모 컨테이너 (이 뷰를 호스팅하는 동일한 컨테이너)와의 연관성에서 자연스럽게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6634676b2a3890f259f108b85e360b357783a624" translate="yes" xml:space="preserve">
          <source>The real paint behavior occurs naturally from the association that the component has with its parent container (the same container hosting this view). This is implemented to do nothing.</source>
          <target state="translated">실제 페인트 동작은 구성 요소가 부모 컨테이너 (이 뷰를 호스팅하는 동일한 컨테이너)와의 연관성에서 자연스럽게 발생합니다. 이것은 아무것도하지 않도록 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="1937fc02231b146a373cfbbd353a2e3a9bef7353" translate="yes" xml:space="preserve">
          <source>The real source.</source>
          <target state="translated">진짜 소스.</target>
        </trans-unit>
        <trans-unit id="b9d32ae3ca8a166a78d846fc7aad0c5b1d696a11" translate="yes" xml:space="preserve">
          <source>The reason string</source>
          <target state="translated">이유 문자열</target>
        </trans-unit>
        <trans-unit id="c02940838e2a0e7c78ef96311f0f4a5d64f9e4e9" translate="yes" xml:space="preserve">
          <source>The reason that listeners created with &lt;code&gt;EventHandler&lt;/code&gt; have such a small footprint is that the &lt;code&gt;Proxy&lt;/code&gt; class, on which the &lt;code&gt;EventHandler&lt;/code&gt; relies, shares implementations of identical interfaces. For example, if you use the &lt;code&gt;EventHandler create&lt;/code&gt; methods to make all the &lt;code&gt;ActionListener&lt;/code&gt;s in an application, all the action listeners will be instances of a single class (one created by the &lt;code&gt;Proxy&lt;/code&gt; class). In general, listeners based on the &lt;code&gt;Proxy&lt;/code&gt; class require one listener class to be created per &lt;em&gt;listener type&lt;/em&gt; (interface), whereas the inner class approach requires one class to be created per &lt;em&gt;listener&lt;/em&gt; (object that implements the interface).</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 로 생성 된 리스너의 풋 프린트가 작은 이유 는 &lt;code&gt;EventHandler&lt;/code&gt; 가 의존 하는 &lt;code&gt;Proxy&lt;/code&gt; 클래스 가 동일한 인터페이스의 구현을 공유하기 때문입니다. 예를 들어, &lt;code&gt;EventHandler create&lt;/code&gt; 메서드를 사용 하여 응용 프로그램의 모든 &lt;code&gt;ActionListener&lt;/code&gt; 를 만드는 경우 모든 작업 리스너는 단일 클래스 ( &lt;code&gt;Proxy&lt;/code&gt; 클래스에서 만든 클래스)의 인스턴스가 됩니다. 일반적으로 &lt;code&gt;Proxy&lt;/code&gt; 클래스를 기반으로하는 리스너는 &lt;em&gt;리스너 유형&lt;/em&gt; (인터페이스) 당 하나의 리스너 클래스를 생성 해야하지만 내부 클래스 접근 방식에서는 &lt;em&gt;리스너&lt;/em&gt; 당 하나의 클래스를 생성해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; (인터페이스를 구현하는 객체).</target>
        </trans-unit>
        <trans-unit id="343e073c1a04a45f15bfaa37758a836c0b9ae1dd" translate="yes" xml:space="preserve">
          <source>The reason that listeners created with &lt;code&gt;EventHandler&lt;/code&gt; have such a small footprint is that the &lt;code&gt;Proxy&lt;/code&gt; class, on which the &lt;code&gt;EventHandler&lt;/code&gt; relies, shares implementations of identical interfaces. For example, if you use the &lt;code&gt;EventHandler&lt;/code&gt;&lt;code&gt;create&lt;/code&gt; methods to make all the &lt;code&gt;ActionListener&lt;/code&gt;s in an application, all the action listeners will be instances of a single class (one created by the &lt;code&gt;Proxy&lt;/code&gt; class). In general, listeners based on the &lt;code&gt;Proxy&lt;/code&gt; class require one listener class to be created per &lt;em&gt;listener type&lt;/em&gt; (interface), whereas the inner class approach requires one class to be created per &lt;em&gt;listener&lt;/em&gt; (object that implements the interface).</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 로 작성된 리스너의 공간이 작은 이유 는 &lt;code&gt;EventHandler&lt;/code&gt; 가 의존 하는 &lt;code&gt;Proxy&lt;/code&gt; 클래스 가 동일한 인터페이스의 구현을 공유하기 때문입니다. 예를 들어, &lt;code&gt;EventHandler&lt;/code&gt; &lt;code&gt;create&lt;/code&gt; 메소드를 사용 하여 애플리케이션에서 모든 &lt;code&gt;ActionListener&lt;/code&gt; 를 작성 하는 경우 모든 조치 리스너는 단일 클래스 ( &lt;code&gt;Proxy&lt;/code&gt; 클래스에 의해 작성된 것)의 인스턴스가 됩니다. 일반적으로 &lt;code&gt;Proxy&lt;/code&gt; 클래스를 기반으로하는 리스너는 &lt;em&gt;리스너 유형&lt;/em&gt; (인터페이스) 당 하나의 리스너 클래스를 작성 해야하지만 내부 클래스 접근 방식은 &lt;em&gt;리스너&lt;/em&gt; 당 하나의 클래스를 작성해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; (인터페이스를 구현하는 객체).</target>
        </trans-unit>
        <trans-unit id="4bcf2d174d6450c449f0d4b03a4ca6b52b25a266" translate="yes" xml:space="preserve">
          <source>The reason the validation algorithm failed.</source>
          <target state="translated">유효성 검증 알고리즘이 실패한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="fad799b782c71b721e74eb716a062272a08611cd" translate="yes" xml:space="preserve">
          <source>The reason to deny access can vary. For example, the requested permission might be of an incorrect type, contain an invalid value, or request access that is not allowed according to the security policy. Such information should be given whenever possible at the time the exception is thrown.</source>
          <target state="translated">액세스를 거부하는 이유는 다양 할 수 있습니다. 예를 들어 요청 된 권한의 유형이 잘못되었거나 유효하지 않은 값을 포함하거나 보안 정책에 따라 허용되지 않은 요청 액세스가있을 수 있습니다. 그러한 정보는 예외가 발생했을 때 가능할 때마다 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1aeeb073ceae77eaa12f37a803ff57f9b6861457" translate="yes" xml:space="preserve">
          <source>The receiving interface of &lt;code&gt;WebSocket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WebSocket&lt;/code&gt; 의 수신 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="19aa33a5763e532698ec85898ffde7fa19da36dd" translate="yes" xml:space="preserve">
          <source>The recommended approach to waiting is to check the condition being awaited in a &lt;code&gt;while&lt;/code&gt; loop around the call to &lt;code&gt;wait&lt;/code&gt;, as shown in the example below. Among other things, this approach avoids problems that can be caused by spurious wakeups.</source>
          <target state="translated">대기에 권장되는 방법은 아래 예제와 같이 &lt;code&gt;wait&lt;/code&gt; 호출 주위의 &lt;code&gt;while&lt;/code&gt; 루프 에서 대기중인 조건을 확인하는 것 입니다. 무엇보다도이 접근 방식은 가짜 깨우기로 인해 발생할 수있는 문제를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="8b540068386b3455f296a75095372235296b6e2b" translate="yes" xml:space="preserve">
          <source>The recommended usage is to use &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; to identify resources, then convert it into a &lt;a href=&quot;url&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; when it is time to access the resource. From that URL, you can either get the &lt;a href=&quot;urlconnection&quot;&gt;&lt;code&gt;URLConnection&lt;/code&gt;&lt;/a&gt; for fine control, or get directly the InputStream.</source>
          <target state="translated">권장되는 사용법은 &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 를 사용 하여 자원을 식별 한 다음 자원 에 액세스 할 때 &lt;a href=&quot;url&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt; 로 변환하는 것입니다. 해당 URL에서 세부 제어를 위해 &lt;a href=&quot;urlconnection&quot;&gt; &lt;code&gt;URLConnection&lt;/code&gt; &lt;/a&gt; 을 가져 오거나 InputStream을 직접 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02d456a5b72dc15bc50cf4cbcbe8e2427ba00e2" translate="yes" xml:space="preserve">
          <source>The rectangular printable area is defined thus: The (x,y) origin is positioned at the top-left of the paper in portrait mode regardless of the orientation specified in the requesting context. For example a printable area for A4 paper in portrait or landscape orientation will have height &amp;gt; width.</source>
          <target state="translated">직사각형 인쇄 가능 영역은 다음과 같이 정의됩니다. (x, y) 원점은 요청 컨텍스트에 지정된 방향에 관계없이 세로 모드에서 용지의 왼쪽 상단에 배치됩니다. 예를 들어 세로 또는 가로 방향의 A4 용지의 인쇄 가능 영역은 높이&amp;gt; 너비를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="078eace4dd337040ba2ae72d27be838bc237864c" translate="yes" xml:space="preserve">
          <source>The red color component for the specified pixel, as an int.</source>
          <target state="translated">지정된 픽셀의 빨간색 구성 요소 (int)입니다.</target>
        </trans-unit>
        <trans-unit id="98a309e25e6dab75aafbad36b2cae3eb6daac137" translate="yes" xml:space="preserve">
          <source>The redefinition may change method bodies, the constant pool and attributes (unless explicitly prohibited). The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. The redefinition must not change the &lt;code&gt;NestHost&lt;/code&gt; or &lt;code&gt;NestMembers&lt;/code&gt; attributes. These restrictions may be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재정의는 메서드 본문, 상수 풀 및 속성을 변경할 수 있습니다 (명시 적으로 금지되지 않는 한). 재정의는 필드 또는 메서드를 추가, 제거 또는 이름 변경하거나 메서드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 재정의는 &lt;code&gt;NestHost&lt;/code&gt; 또는 &lt;code&gt;NestMembers&lt;/code&gt; 속성을 변경해서는 안됩니다 . 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 클래스 파일 바이트는 변환이 적용될 때까지 검사, 확인 및 설치되지 않으며 결과 바이트에 오류가있는 경우이 메서드는 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="6cf742cf21d433441fd0b0bc61621152f8db92ae" translate="yes" xml:space="preserve">
          <source>The redefinition may change method bodies, the constant pool and attributes. The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재정의는 메소드 본문, 상수 풀 및 속성을 변경할 수 있습니다. 재정의는 필드 나 메소드를 추가, 제거 또는 이름 변경하거나 메소드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 변환이 적용될 때까지 클래스 파일 바이트는 확인, 확인 및 설치되지 않습니다. 결과 바이트에 오류가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6f19c83b6a43c97e8d1cefd627e0b3c8dadfded2" translate="yes" xml:space="preserve">
          <source>The reference &lt;code&gt;x&lt;/code&gt; must be convertible to the first parameter type of the target.</source>
          <target state="translated">참조 &lt;code&gt;x&lt;/code&gt; 는 대상의 첫 번째 매개 변수 유형으로 변환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="44017fc6a35a5f9dd8fcf726c29aa2e0e60bb2ce" translate="yes" xml:space="preserve">
          <source>The reference implementation (RI) provides two synchronization providers.</source>
          <target state="translated">참조 구현 (RI)은 두 개의 동기화 공급자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5409eeca3c33981649af20f4b7e7f4d34b54dae8" translate="yes" xml:space="preserve">
          <source>The reference implementation is targeted to ship with J2SE 1.5, which will include an additional resource file that may be edited by hand. Here is an example of the properties file included in the reference implementation:</source>
          <target state="translated">참조 구현은 직접 편집 할 수있는 추가 리소스 파일을 포함하는 J2SE 1.5와 함께 제공됩니다. 다음은 참조 구현에 포함 된 속성 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="60999b6f0306efbef13e0ce2d4acd07ba041bfaf" translate="yes" xml:space="preserve">
          <source>The reference implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface provided by Oracle Corporation is a standard implementation. Developers may use this implementation just as it is, they may extend it, or they may choose to write their own implementations of this interface.</source>
          <target state="translated">Oracle Corporation에서 제공 하는 &lt;code&gt;CachedRowSet&lt;/code&gt; 인터페이스 의 참조 구현은 표준 구현입니다. 개발자는이 구현을 그대로 사용하거나 확장하거나이 인터페이스의 자체 구현을 작성하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdbc6f393391fdc2aa74409e53d076bab2c56284" translate="yes" xml:space="preserve">
          <source>The reference implementation of the &lt;code&gt;JdbcRowSet&lt;/code&gt; interface, &lt;code&gt;JdbcRowSetImpl&lt;/code&gt;, provides an implementation of the default constructor. A new instance is initialized with default values, which can be set with new values as needed. A new instance is not really functional until its &lt;code&gt;execute&lt;/code&gt; method is called. In general, this method does the following:</source>
          <target state="translated">의 레퍼런스 구현 &lt;code&gt;JdbcRowSet&lt;/code&gt; 인터페이스, &lt;code&gt;JdbcRowSetImpl&lt;/code&gt; 는 기본 생성자의 구현을 제공합니다. 새 인스턴스는 기본값으로 초기화되며 필요에 따라 새 값으로 설정할 수 있습니다. 새 인스턴스는 &lt;code&gt;execute&lt;/code&gt; 메서드가 호출 될 때까지 실제로 작동하지 않습니다 . 일반적으로이 방법은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1bef56dc5a152e5cab8e0b183e0324bc9dbed6ee" translate="yes" xml:space="preserve">
          <source>The reference implementation of this method returns the MIME type &lt;code&gt;String&lt;/code&gt; of the specified &lt;code&gt;DataFlavor&lt;/code&gt; prefixed with &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt;.</source>
          <target state="translated">이 메서드의 참조 구현은 &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt; 접두사가 붙은 지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 의 MIME 유형 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0db6d72998455f6d8d159947d15deb882e4e6208" translate="yes" xml:space="preserve">
          <source>The reference implementation of this method returns the specified MIME type &lt;code&gt;String&lt;/code&gt; prefixed with &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt;.</source>
          <target state="translated">이 메서드의 참조 구현은 &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt; 접두사가 붙은 지정된 MIME 유형 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3c96b6a18efdd8f02c853b851fa382edd202cc59" translate="yes" xml:space="preserve">
          <source>The reference is parsed into the scheme, authority, path, query and fragment parts. If the path component is empty and the scheme, authority, and query components are undefined, then the new URL is a reference to the current document. Otherwise, the fragment and query parts present in the spec are used in the new URL.</source>
          <target state="translated">참조는 체계, 권한, 경로, 쿼리 및 조각 부분으로 구문 분석됩니다. 경로 구성 요소가 비어 있고 구성표, 권한 및 조회 구성 요소가 정의되지 않은 경우 새 URL은 현재 문서에 대한 참조입니다. 그렇지 않으면 사양에있는 조각 및 쿼리 부분이 새 URL에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1b7f522e51adfd670896cc10d510ac4a355747" translate="yes" xml:space="preserve">
          <source>The reference to the module's content</source>
          <target state="translated">모듈 콘텐츠에 대한 참조</target>
        </trans-unit>
        <trans-unit id="2cf99cd156e1535ee0739b3761f44ba4ad8f59a0" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by extension from the other type definition if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and at least one of the &lt;em&gt;derivation methods&lt;/em&gt; involved is an extension.</source>
          <target state="translated">참조 형식 정의에서 {base type definition} 속성을 따라 다른 형식 정의에 재귀 적으로 도달 할 수 있고 관련된 &lt;em&gt;파생 메서드&lt;/em&gt; 중 하나 이상이 확장 인 경우 참조 형식 정의는 다른 형식 정의의 확장에 의해 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="d289101b23ccf25d80de6a72dd72816e3bcb1157" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by list from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; or &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt;, T2 is derived from the other type definition by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt;, T1 has {variety} &lt;em&gt;list&lt;/em&gt;, and T2 is the {item type definition}. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</source>
          <target state="translated">참조 유형 정의는 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 또는 &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt; 에 의해 T1에서 파생 된 참조 유형 정의와 같이 두 개의 유형 정의 T1 및 T2가있는 경우 다른 유형 정의의 목록에 의해 파생되며 , T2는 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 에 의해 다른 유형 정의에서 파생되고 , T1은 {variety} &lt;em&gt;목록&lt;/em&gt; , T2는 {item type definition}입니다. T1은 참조 유형 정의와 같을 수 있고 T2는 다른 유형 정의와 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dffb6e6d8b2d6f55eafb2e232eb84ee4de39afa8" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by restriction from the other type definition if the other type definition is the same as the reference type definition, or if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and all the &lt;em&gt;derivation methods&lt;/em&gt; involved are restriction.</source>
          <target state="translated">참조 유형 정의는 다른 유형 정의가 참조 유형 정의와 동일하거나 참조 유형 정의의 {base type definition} 속성을 따라 다른 유형 정의에 재귀 적으로 도달 할 수있는 경우 다른 유형 정의의 제한에 의해 파생됩니다. , 관련된 모든 &lt;em&gt;파생 방법&lt;/em&gt; 은 제한입니다.</target>
        </trans-unit>
        <trans-unit id="16ef2fe88de2d7e30fdc46db81d300b65bcac937" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by union from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; or &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt;, T2 is derived from the other type definition by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt;, T1 has {variety} &lt;em&gt;union&lt;/em&gt;, and one of the {member type definitions} is T2. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</source>
          <target state="translated">참조 유형 정의가 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 또는 &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt; 에 의해 T1에서 파생되는 것과 같이 두 개의 유형 정의 T1 및 T2가 존재하는 경우 참조 유형 정의는 다른 유형 정의에서 통합에 의해 파생되며, T2는 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 에 의해 다른 유형 정의에서 파생되고 , T1은 {variety} &lt;em&gt;union&lt;/em&gt; 이며 {member type definitions} 중 하나는 T2입니다. T1은 참조 유형 정의와 같을 수 있고 T2는 다른 유형 정의와 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27a0672b9281e7b40b24731935d7c4c815d57f66" translate="yes" xml:space="preserve">
          <source>The referral context is created using &lt;code&gt;env&lt;/code&gt; as its environment properties. This method should be used instead of the no-arg overloaded form when the caller needs to use different environment properties for the referral context. It might need to do this, for example, when it needs to supply different authentication information to the referred server in order to create the referral context.</source>
          <target state="translated">참조 컨텍스트는 환경 특성으로 &lt;code&gt;env&lt;/code&gt; 를 사용하여 작성 됩니다. 호출자가 참조 컨텍스트에 대해 다른 환경 속성을 사용해야하는 경우 인수가없는 오버로드 된 양식 대신이 메소드를 사용해야합니다. 예를 들어, 참조 컨텍스트를 작성하기 위해 참조 된 서버에 다른 인증 정보를 제공해야하는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4ce274ab6ae3f0c9ee72f8b65f07fb79d7e2a06" translate="yes" xml:space="preserve">
          <source>The region of interest is defined by the bounding box of the source &lt;code&gt;Image&lt;/code&gt;. This bounding box is specified in Image Space, which is the &lt;code&gt;Image&lt;/code&gt; object's local coordinate system.</source>
          <target state="translated">관심 영역은 소스 &lt;code&gt;Image&lt;/code&gt; 의 경계 상자로 정의됩니다 . 이 경계 상자는 &lt;code&gt;Image&lt;/code&gt; 객체의 로컬 좌표계 인 Image Space에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae7c56b2cdef8fa8f60172c89227929f50be69e" translate="yes" xml:space="preserve">
          <source>The region of the image to be written is determined by first intersecting the actual bounds of the image with the rectangle specified by &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt;, if any. If the resulting rectangle has a width or height of zero, the writer will throw an &lt;code&gt;IIOException&lt;/code&gt;. If the intersection is non-empty, writing will commence with the first subsampled pixel and include additional pixels within the intersected bounds according to the horizontal and vertical subsampling factors specified by &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기록 될 이미지의 영역은 먼저 이미지의 실제 경계를 &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt; 에 지정된 사각형 (있는 경우)과 교차하여 결정됩니다 . 결과 사각형의 너비 또는 높이가 0이면 작성기는 &lt;code&gt;IIOException&lt;/code&gt; 을 발생 시킵니다. 교차점이 비어 있지 않으면 쓰기가 첫 번째 서브 샘플링 된 픽셀부터 시작되고 &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에서&lt;/a&gt; 지정한 수평 및 수직 서브 샘플링 인자에 따라 교차 된 경계 내에 추가 픽셀이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0ee23ed794b80c251d3a1fe843993862775ce5a" translate="yes" xml:space="preserve">
          <source>The region of the image to be written is determined by first intersecting the actual bounds of the image with the rectangle specified by &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt;, if any. If the resulting rectangle has a width or height of zero, the writer will throw an &lt;code&gt;IIOException&lt;/code&gt;. If the intersection is non-empty, writing will commence with the first subsampled pixel and include additional pixels within the intersected bounds according to the horizontal and vertical subsampling factors specified by &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기록 될 이미지의 영역은 이미지의 실제 경계를 &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt; 에 의해 지정된 사각형 (있는 경우)과 먼저 교차시킴으로써 결정됩니다 . 결과 사각형의 너비 또는 높이가 0이면 작성기는 &lt;code&gt;IIOException&lt;/code&gt; 을 발생 시킵니다. 교차점이 비어 있지 않으면 쓰기는 첫 번째 서브 샘플링 된 픽셀로 시작하고 &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 의해 지정된 수평 및 수직 서브 샘플링 요소에 따라 교차 된 경계 내에 추가 픽셀을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="bf75c137f4d08f499b676efedda08b261ecc10e0" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The two-argument &lt;a href=&quot;#lock(A,java.nio.channels.CompletionHandler)&quot;&gt;&lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. If a lock that overlaps the requested region is already held by this Java virtual machine, or this method has been invoked to lock an overlapping region and that operation has not completed, then this method throws &lt;a href=&quot;overlappingfilelockexception&quot;&gt;&lt;code&gt;OverlappingFileLockException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 은 실제 기본 파일 내에 포함되거나 겹칠 필요가 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역이 처음에 파일의 끝을 포함하고 파일이 영역을 넘어서 커지면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일의 크기가 커질 것으로 예상되고 전체 파일에 대한 잠금이 필요한 경우 0에서 시작하고 예상되는 파일의 최대 크기보다 작지 않은 영역을 잠 가야합니다. 두 인수 &lt;a href=&quot;#lock(A,java.nio.channels.CompletionHandler)&quot;&gt; &lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메서드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다.. 요청 된 영역과 겹치는 잠금이 이미이 JVM (Java Virtual Machine)에 의해 유지되거나 겹치는 영역을 잠그기 위해이 메소드가 호출되었으며 해당 작업이 완료되지 않은 경우이 메소드는 &lt;a href=&quot;overlappingfilelockexception&quot;&gt; &lt;code&gt;OverlappingFileLockException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="412cd087a882e3390f6eb99cb3444e0f99865817" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The two-argument &lt;a href=&quot;asynchronousfilechannel#lock-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. If a lock that overlaps the requested region is already held by this Java virtual machine, or this method has been invoked to lock an overlapping region and that operation has not completed, then this method throws &lt;a href=&quot;overlappingfilelockexception&quot;&gt;&lt;code&gt;OverlappingFileLockException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 2 인수 &lt;a href=&quot;asynchronousfilechannel#lock-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다.. 요청 된 영역과 겹치는 잠금이이 Java 가상 머신에 의해 이미 보유되어 있거나 겹치는 영역을 잠그기 위해이 메소드가 호출되었고 조작이 완료되지 않은 경우이 메소드는 &lt;a href=&quot;overlappingfilelockexception&quot;&gt; &lt;code&gt;OverlappingFileLockException&lt;/code&gt; 을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="7f8ccadc40b179a069619b37209e7a82323388a3" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;#lock()&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 은 실제 기본 파일 내에 포함되거나 겹칠 필요가 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역이 처음에 파일의 끝을 포함하고 파일이 영역을 넘어서 커지면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일의 크기가 커질 것으로 예상되고 전체 파일에 대한 잠금이 필요한 경우 0에서 시작하고 예상되는 파일의 최대 크기보다 작지 않은 영역을 잠 가야합니다. 인수가없는 &lt;a href=&quot;#lock()&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 메서드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="6cff2d7fbc06e1a140db665b0a54e775297aaed1" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;#tryLock()&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 은 실제 기본 파일 내에 포함되거나 겹칠 필요가 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역이 처음에 파일의 끝을 포함하고 파일이 영역을 넘어서 커지면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일의 크기가 커질 것으로 예상되고 전체 파일에 대한 잠금이 필요한 경우 0에서 시작하고 예상되는 파일의 최대 크기보다 작지 않은 영역을 잠 가야합니다. 인수가없는 &lt;a href=&quot;#tryLock()&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메서드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="813d5453cbb41f59eb6e5e97b38357b9ea00bdde" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;filechannel#lock--&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 인수가 0 인 &lt;a href=&quot;filechannel#lock--&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="617ac4e34e018358f5e81a33f698a400aa0685af" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;filechannel#tryLock--&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 인수가 0 인 &lt;a href=&quot;filechannel#tryLock--&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="2018bb0b35a071dd77f0537c6308e64613671b58" translate="yes" xml:space="preserve">
          <source>The registered &lt;a href=&quot;#addConfigurationListener(java.lang.Runnable)&quot;&gt;configuration listeners&lt;/a&gt; will be invoked after the configuration is successfully updated.</source>
          <target state="translated">등록 된 &lt;a href=&quot;#addConfigurationListener(java.lang.Runnable)&quot;&gt;구성 리스너&lt;/a&gt; 는 구성이 성공적으로 업데이트 된 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3d0fc73493ecda447bb85c445c6e4f953b759f7f" translate="yes" xml:space="preserve">
          <source>The registration/deregistration methods accept an instance of &lt;code&gt;NamingListener&lt;/code&gt;. There are subinterfaces of &lt;code&gt;NamingListener&lt;/code&gt; for different of event types of &lt;code&gt;NamingEvent&lt;/code&gt;. For example, the &lt;code&gt;ObjectChangeListener&lt;/code&gt; interface is for the &lt;code&gt;NamingEvent.OBJECT_CHANGED&lt;/code&gt; event type. To register interest in multiple event types, the listener implementation should implement multiple &lt;code&gt;NamingListener&lt;/code&gt; subinterfaces and use a single invocation of &lt;code&gt;addNamingListener()&lt;/code&gt;. In addition to reducing the number of method calls and possibly the code size of the listeners, this allows some service providers to optimize the registration.</source>
          <target state="translated">등록 / 파기 메소드는 &lt;code&gt;NamingListener&lt;/code&gt; 의 인스턴스를 받아들 입니다. &lt;code&gt;NamingEvent&lt;/code&gt; 의 다른 이벤트 타입에 대한 &lt;code&gt;NamingListener&lt;/code&gt; 의 서브 인터페이스가 있습니다 . 예를 들어, &lt;code&gt;ObjectChangeListener&lt;/code&gt; 인터페이스는 &lt;code&gt;NamingEvent.OBJECT_CHANGED&lt;/code&gt; 이벤트 유형에 대한 것입니다. 여러 이벤트 유형에 관심을 등록하려면 리스너 구현에서 여러 &lt;code&gt;NamingListener&lt;/code&gt; 서브 인터페이스를 구현 하고 &lt;code&gt;addNamingListener()&lt;/code&gt; 의 단일 호출을 사용해야합니다 . 메소드 호출 수와 리스너의 코드 크기를 줄이는 것 외에도 일부 서비스 제공 업체는 등록을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6005af0d0e955fa02a5ecc341d6d2cbed8810f0c" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;.&lt;/code&gt; matches any character except a line terminator unless the &lt;a href=&quot;#DOTALL&quot;&gt;&lt;code&gt;DOTALL&lt;/code&gt;&lt;/a&gt; flag is specified.</source>
          <target state="translated">정규식 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;#DOTALL&quot;&gt; &lt;code&gt;DOTALL&lt;/code&gt; &lt;/a&gt; 플래그가 지정 되지 않은 경우 줄 종결자를 제외한 모든 문자와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="d4b28ceb290f94f79d557bc3e4312d5d5404a206" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;.&lt;/code&gt; matches any character except a line terminator unless the &lt;a href=&quot;pattern#DOTALL&quot;&gt;&lt;code&gt;DOTALL&lt;/code&gt;&lt;/a&gt; flag is specified.</source>
          <target state="translated">정규식 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;pattern#DOTALL&quot;&gt; &lt;code&gt;DOTALL&lt;/code&gt; &lt;/a&gt; 플래그가 지정 되지 않은 경우 줄 종결자를 제외한 모든 문자와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="06c07dbec7777602883d6500283e28c86a80e923" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;DOMError.type&lt;/code&gt; dependent data if any.</source>
          <target state="translated">관련 &lt;code&gt;DOMError.type&lt;/code&gt; 종속 데이터 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="92e8bde63f8804130f51216402f7e58eed8b42f4" translate="yes" xml:space="preserve">
          <source>The related platform dependent exception if any.</source>
          <target state="translated">관련 플랫폼 종속 예외 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="6e4b1af8982753fca149df2aa7452224b647d528" translate="yes" xml:space="preserve">
          <source>The relation objects of that type will be removed from the Relation Service.</source>
          <target state="translated">해당 유형의 관계 개체는 관계 서비스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="aa44fb4b73ba3a7eb0fa699a55544e1d6fb4e2cf" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;floorDiv&lt;/code&gt; and &lt;code&gt;floorMod&lt;/code&gt; is such that:</source>
          <target state="translated">&lt;code&gt;floorDiv&lt;/code&gt; 와 &lt;code&gt;floorMod&lt;/code&gt; 의 관계는 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6427ac31d87ab27b06603a0df3c2ae4a7cbf6dfa" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;this&lt;/code&gt;&lt;code&gt;XMLGregorianCalendar&lt;/code&gt; and the specified &lt;code&gt;xmlGregorianCalendar&lt;/code&gt; as &lt;a href=&quot;datatypeconstants#LESSER&quot;&gt;&lt;code&gt;DatatypeConstants.LESSER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;datatypeconstants#EQUAL&quot;&gt;&lt;code&gt;DatatypeConstants.EQUAL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;datatypeconstants#GREATER&quot;&gt;&lt;code&gt;DatatypeConstants.GREATER&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;datatypeconstants#INDETERMINATE&quot;&gt;&lt;code&gt;DatatypeConstants.INDETERMINATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 와 지정된 &lt;code&gt;xmlGregorianCalendar&lt;/code&gt; ( &lt;a href=&quot;datatypeconstants#LESSER&quot;&gt; &lt;code&gt;DatatypeConstants.LESSER&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;datatypeconstants#EQUAL&quot;&gt; &lt;code&gt;DatatypeConstants.EQUAL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;datatypeconstants#GREATER&quot;&gt; &lt;code&gt;DatatypeConstants.GREATER&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;datatypeconstants#INDETERMINATE&quot;&gt; &lt;code&gt;DatatypeConstants.INDETERMINATE&lt;/code&gt; )&lt;/a&gt; 간의 관계 입니다.</target>
        </trans-unit>
        <trans-unit id="e5c08d18f5dc47b416f3b07369175323c6d88f7a" translate="yes" xml:space="preserve">
          <source>The relationship between a WebSocket and the associated Listener is analogous to that of a Subscription and the associated Subscriber of type &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow&quot;&gt;&lt;code&gt;Flow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">WebSocket과 관련 리스너 간의 관계는 구독 및 &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow&quot;&gt; &lt;code&gt;Flow&lt;/code&gt; &lt;/a&gt; 유형의 관련 구독자의 관계와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1d34477c420fd977fd8f945aedd832fb3f7c9dfd" translate="yes" xml:space="preserve">
          <source>The relative URL need not specify all the components of a URL. If the protocol, host name, or port number is missing, the value is inherited from the fully specified URL. The file component must be specified. The optional fragment is not inherited.</source>
          <target state="translated">상대 URL은 URL의 모든 구성 요소를 지정할 필요는 없습니다. 프로토콜, 호스트 이름 또는 포트 번호가 누락되면 값은 완전히 지정된 URL에서 상속됩니다. 파일 구성 요소를 지정해야합니다. 선택적 조각은 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f061ca1fba773cc35eb218fcd97124e40600f26" translate="yes" xml:space="preserve">
          <source>The relative index of the first mismatch between this and the given buffer, otherwise -1 if no mismatch.</source>
          <target state="translated">이 버퍼와 주어진 버퍼 사이의 첫 번째 불일치의 상대 색인입니다. 그렇지 않으면 불일치가 없으면 -1입니다.</target>
        </trans-unit>
        <trans-unit id="c5c5f181f6e29a7276bf6337e3a4edd8b847077a" translate="yes" xml:space="preserve">
          <source>The relativization of the given URI against this URI is computed as follows:</source>
          <target state="translated">이 URI에 대한 지정된 URI의 상대 성화는 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e707cc2158f347f5aab8350d2339ff22d2e3b87b" translate="yes" xml:space="preserve">
          <source>The reliability of this method is important for the ability to use it to make security decisions, so its implementation should not just test if the class in question extends &lt;code&gt;Proxy&lt;/code&gt;.</source>
          <target state="translated">이 방법의 안정성은 보안 결정을 내리는 데 사용하기에 중요하므로 구현시 해당 클래스가 &lt;code&gt;Proxy&lt;/code&gt; 를 확장하는지 테스트하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f22668315e9121681e1e68864a75519fe9de5684" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산 이 &lt;em&gt;아닙니다&lt;/em&gt; (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="8b7ae0cdf8ad17c67c6a33deb5e3ca85d6e010c4" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt;. Note that this is not the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산이 아닙니다 (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="e82e7847d0c5f7329094a894a4727d5cc71d2c00" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor,
 mc).multiply(divisor))&lt;/code&gt;. Note that this is not the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor, mc).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산이 아닙니다 (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="cbccf12ec336d37bab08d7866f9df36a1069a2aa" translate="yes" xml:space="preserve">
          <source>The remaining SPI methods &lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt; have more complicated exception behavior. They are not specified to throw &lt;code&gt;BackingStoreException&lt;/code&gt;, as they can generally obey their contracts even if the backing store is unavailable. This is true because they return no information and their effects are not required to become permanent until a subsequent call to &lt;a href=&quot;preferences#flush()&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;preferences#sync()&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;. Generally speaking, these SPI methods should not throw exceptions. In some implementations, there may be circumstances under which these calls cannot even enqueue the requested operation for later processing. Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception. Under these circumstances, however, subsequently invoking &lt;code&gt;flush()&lt;/code&gt; or &lt;code&gt;sync&lt;/code&gt; would not imply that all previous operations had successfully been made permanent.</source>
          <target state="translated">나머지 SPI 메서드 &lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt; 에는 더 복잡한 예외 동작이 있습니다. &lt;code&gt;BackingStoreException&lt;/code&gt; 을 던지도록 지정되지 않았습니다. 일반적으로 백업 저장소를 사용할 수없는 경우에도 계약을 따를 수 있기 때문입니다. 이는 정보를 반환하지 않으며 그 효과는 &lt;a href=&quot;preferences#flush()&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;preferences#sync()&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; &lt;/a&gt; 대한 후속 호출이있을 때까지 영구적으로 유지 될 필요가 없기 때문에 사실입니다.. 일반적으로 이러한 SPI 메서드는 예외를 throw해서는 안됩니다. 일부 구현에서는 이러한 호출이 나중에 처리하기 위해 요청 된 작업을 대기열에 넣을 수없는 상황이있을 수 있습니다. 이러한 상황에서도 일반적으로 예외를 던지는 것보다 단순히 호출을 무시하고 반환하는 것이 좋습니다. 그러나 이러한 상황에서 이후에 &lt;code&gt;flush()&lt;/code&gt; 또는 &lt;code&gt;sync&lt;/code&gt; 를 호출 한다고해서 이전의 모든 작업이 성공적으로 영구적으로 수행되었음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="47da9e589f25b7bfcd11328b7b51fd360a0d60ec" translate="yes" xml:space="preserve">
          <source>The remaining SPI methods &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt; have more complicated exception behavior. They are not specified to throw &lt;code&gt;BackingStoreException&lt;/code&gt;, as they can generally obey their contracts even if the backing store is unavailable. This is true because they return no information and their effects are not required to become permanent until a subsequent call to &lt;a href=&quot;preferences#flush--&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;preferences#sync--&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;. Generally speaking, these SPI methods should not throw exceptions. In some implementations, there may be circumstances under which these calls cannot even enqueue the requested operation for later processing. Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception. Under these circumstances, however, all subsequent invocations of &lt;code&gt;flush()&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; should return &lt;code&gt;false&lt;/code&gt;, as returning &lt;code&gt;true&lt;/code&gt; would imply that all previous operations had successfully been made permanent.</source>
          <target state="translated">나머지 SPI 메소드 &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt; 에는 더 복잡한 예외 동작이 있습니다. &lt;code&gt;BackingStoreException&lt;/code&gt; 을 던지도록 지정되어 있지 않습니다. 일반적으로 백업 저장소를 사용할 수없는 경우에도 계약을 따를 수 있습니다. 이는 정보를 반환하지 않으며, &lt;a href=&quot;preferences#flush--&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;preferences#sync--&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; &lt;/a&gt; 대한 후속 호출까지 그 효과가 영구적이 될 필요가 없기 때문에 사실입니다.. 일반적으로 이러한 SPI 메소드는 예외를 발생시키지 않아야합니다. 일부 구현들에서, 이러한 호출들이 추후 처리를 위해 요청 된 동작을 큐에 넣을 수없는 상황이있을 수있다. 이러한 상황에서도 일반적으로 예외를 던지기보다는 단순히 호출과 반환을 무시하는 것이 좋습니다. 그러나 이러한 상황에서 &lt;code&gt;flush()&lt;/code&gt; 및 &lt;code&gt;sync&lt;/code&gt; 의 모든 후속 호출은 &lt;code&gt;false&lt;/code&gt; 를 리턴해야합니다. &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 이전의 모든 조작이 모두 영구적으로 완료되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="04a436b0f38850e482765bfe8b244ada2271191c" translate="yes" xml:space="preserve">
          <source>The remaining characters of the result represent the magnitude of the first argument. If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character. The following ASCII characters are used as digits:</source>
          <target state="translated">결과의 나머지 문자는 첫 번째 인수의 크기를 나타냅니다. 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면, 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 ASCII 문자는 숫자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b031f20190ca11166d6c7b1f498a8021f1fd8160" translate="yes" xml:space="preserve">
          <source>The remaining details of the &lt;code&gt;MBeanInfo&lt;/code&gt; for a Standard MBean are not specified. This includes the description of any contained constructors, and notifications; the names of parameters to constructors and operations; and the descriptions of constructor parameters.</source>
          <target state="translated">표준 MBean 에 대한 &lt;code&gt;MBeanInfo&lt;/code&gt; 의 나머지 세부 사항이 지정되지 않았습니다. 여기에는 포함 된 생성자에 대한 설명 및 알림이 포함됩니다. 생성자와 오퍼레이션에 대한 매개 변수 이름; 생성자 매개 변수에 대한 설명</target>
        </trans-unit>
        <trans-unit id="c7f4b12e2049eb0d2dbae4e0935da9f089467437" translate="yes" xml:space="preserve">
          <source>The remaining unresolved portion of the name. Cannot be null but empty OK.</source>
          <target state="translated">이름의 나머지 해결되지 않은 부분. null 일 수는 없지만 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7050822aac2eaeaa73f4b961d1cb35d5d5e11578" translate="yes" xml:space="preserve">
          <source>The remapping function should not modify this map during computation.</source>
          <target state="translated">리매핑 함수는 계산 중에이 맵을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc31c724cb4c9ebbaec1ed20f6acbd3909843172" translate="yes" xml:space="preserve">
          <source>The remote address; &lt;code&gt;null&lt;/code&gt; if the channel's socket is not connected</source>
          <target state="translated">원격 주소 채널의 소켓이 접속되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e7bc56b939ee7935299e6e6d043373f7df2f25b" translate="yes" xml:space="preserve">
          <source>The remote object becomes available. The header fields and the contents of the remote object can be accessed.</source>
          <target state="translated">원격 객체를 사용할 수있게됩니다. 원격 객체의 헤더 필드와 내용에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e100a0f6c2f94294ad6e3cd0c330ac89e4c13e0" translate="yes" xml:space="preserve">
          <source>The removal is not guaranteed to be persistent until the &lt;code&gt;flush&lt;/code&gt; method is called on this node (or an ancestor).</source>
          <target state="translated">이 노드 (또는 상위 노드) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 제거가 지속되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a80e61fbbbe10c51d6c88507a5031484ad5e8f17" translate="yes" xml:space="preserve">
          <source>The removal may or may not cause a reduction in the actual file size.</source>
          <target state="translated">제거하면 실제 파일 크기가 줄어들거나 줄어들지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d723447722497695e77f4caccb3c9a5c643a12a5" translate="yes" xml:space="preserve">
          <source>The removal of a node needn't become persistent until the &lt;code&gt;flush&lt;/code&gt; method is invoked on this node (or an ancestor).</source>
          <target state="translated">이 노드 (또는 상위 노드) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 노드 제거가 지속될 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b282c26f23a8ff63876d094fed5b0b9dceb07331" translate="yes" xml:space="preserve">
          <source>The remove operation is not supported by this implementation of &lt;code&gt;Iterator&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Iterator&lt;/code&gt; 구현에서는 remove 오퍼레이션이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4efa145e520c4a7598346c393df2dbbefdc968" translate="yes" xml:space="preserve">
          <source>The removed value.</source>
          <target state="translated">제거 된 값.</target>
        </trans-unit>
        <trans-unit id="6ff8f9058796bef90ed321ab88ccf0d012f42526" translate="yes" xml:space="preserve">
          <source>The renamed node. This is either the specified node or the new node that was created to replace the specified node.</source>
          <target state="translated">이름이 바뀐 노드. 이는 지정된 노드 또는 지정된 노드를 대체하기 위해 작성된 새 노드입니다.</target>
        </trans-unit>
        <trans-unit id="fb9b7cdcd454dd83954d48a119b69fc6d29f5c43" translate="yes" xml:space="preserve">
          <source>The renderer used to draw the data cells of the column.</source>
          <target state="translated">열의 데이터 셀을 그리는 데 사용되는 렌더러입니다.</target>
        </trans-unit>
        <trans-unit id="713971eadcf5411214bfe63ca9c0cd65073e7a98" translate="yes" xml:space="preserve">
          <source>The renderer used to draw the header of the column.</source>
          <target state="translated">열의 헤더를 그리는 데 사용되는 렌더러입니다.</target>
        </trans-unit>
        <trans-unit id="ac7f1cf8057b8bea9aa3a7381065318220564c73" translate="yes" xml:space="preserve">
          <source>The reordering array need not specify an actual permutation. An incoming argument will be duplicated if its index appears more than once in the array, and an incoming argument will be dropped if its index does not appear in the array. As in the case of &lt;a href=&quot;#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)&quot;&gt;&lt;code&gt;dropArguments&lt;/code&gt;&lt;/a&gt;, incoming arguments which are not mentioned in the reordering array may be of any type, as determined only by &lt;code&gt;newType&lt;/code&gt;.</source>
          <target state="translated">재정렬 배열은 실제 순열을 지정할 필요가 없습니다. 인덱스가 배열에 두 번 이상 나타나면 들어오는 인수가 복제되고 인덱스가 배열에 나타나지 않으면 들어오는 인수가 삭제됩니다. &lt;a href=&quot;#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)&quot;&gt; &lt;code&gt;dropArguments&lt;/code&gt; &lt;/a&gt; 의 경우와 마찬가지로 재정렬 배열에 언급되지 않은 들어오는 인수는 &lt;code&gt;newType&lt;/code&gt; 에 의해서만 결정되는 모든 유형이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee9a68c9011522398b40024ebeb43b4a5fda590" translate="yes" xml:space="preserve">
          <source>The reordering array need not specify an actual permutation. An incoming argument will be duplicated if its index appears more than once in the array, and an incoming argument will be dropped if its index does not appear in the array. As in the case of &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt;&lt;code&gt;dropArguments&lt;/code&gt;&lt;/a&gt;, incoming arguments which are not mentioned in the reordering array are may be any type, as determined only by &lt;code&gt;newType&lt;/code&gt;.</source>
          <target state="translated">재정렬 배열은 실제 순열을 지정할 필요가 없습니다. 인덱스가 배열에 두 번 이상 나타나면 들어오는 인수가 복제되고 인덱스가 배열에 나타나지 않으면 들어오는 인수가 삭제됩니다. &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt; &lt;code&gt;dropArguments&lt;/code&gt; &lt;/a&gt; 의 경우와 같이 , 재정렬 배열에서 언급되지 않은 들어오는 인수는 &lt;code&gt;newType&lt;/code&gt; 에 의해서만 결정되는 모든 유형일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f51e74f5d8487e855f129611f92abf36e6a28994" translate="yes" xml:space="preserve">
          <source>The replacement string may contain references to subsequences captured during the previous match: Each occurrence of &lt;code&gt;$&lt;/code&gt;</source>
          <target state="translated">대체 문자열에는 이전 일치 중에 캡처 된 하위 시퀀스에 대한 참조가 포함될 수 있습니다. 각 &lt;code&gt;$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11b366ce3d5519585e67264e9f68f215e953b69e" translate="yes" xml:space="preserve">
          <source>The replacement string may contain references to subsequences captured during the previous match: Each occurrence of &lt;code&gt;${&lt;/code&gt;</source>
          <target state="translated">대체 문자열에는 이전 일치 중 캡처 된 하위 시퀀스에 대한 참조가 포함될 수 있습니다. 각 &lt;code&gt;${&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ab89b061a41906c8763945c85297d70e2bd282" translate="yes" xml:space="preserve">
          <source>The replacement text of the entity.</source>
          <target state="translated">엔티티의 대체 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="75ec87cf75e7574e625f69514e58b5152817990b" translate="yes" xml:space="preserve">
          <source>The replacement text of the entity. This method will only return non-null if this is an internal entity.</source>
          <target state="translated">엔티티의 대체 텍스트입니다. 이 메서드는 내부 엔터티 인 경우에만 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cf33c4bd273f01e0c22bc67185a111143ddb62b3" translate="yes" xml:space="preserve">
          <source>The replacer function should not modify this matcher's state during replacement. This method will, on a best-effort basis, throw a &lt;a href=&quot;../concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; if such modification is detected.</source>
          <target state="translated">replacer 함수는 교체 중에이 matcher의 상태를 수정해서는 안됩니다. 이 메서드는 최선의 노력으로 그러한 수정이 감지되면 &lt;a href=&quot;../concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3a325ac974e7b645dae1cacad32338ebd82736bc" translate="yes" xml:space="preserve">
          <source>The reported coordinates for mouse drag events are clipped to fit within the bounds of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; associated with the &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">마우스 드래그 이벤트에 대해보고 된 좌표 는 &lt;code&gt;Component&lt;/code&gt; 와 관련된 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 경계 내에 맞도록 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="eb6b8031115b561f37eb9a4d7da91ed0656b375b" translate="yes" xml:space="preserve">
          <source>The reported coordinates for mouse drag events are clipped to fit within the bounds of the virtual device associated with the &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">마우스 드래그 이벤트에 대해보고 된 좌표는 &lt;code&gt;Component&lt;/code&gt; 와 관련된 가상 장치의 경계 내에 맞도록 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="288c5e2c9b272e95a0d7c59900658548e9747ef2" translate="yes" xml:space="preserve">
          <source>The reporter that will be set on any XMLStreamReader or XMLEventReader created by this factory instance.</source>
          <target state="translated">이 팩토리 인스턴스에 의해 생성 된 XMLStreamReader 또는 XMLEventReader에 설정 될 리포터입니다.</target>
        </trans-unit>
        <trans-unit id="55f25e93574df5310447cf5bb1c8796f989fc6ae" translate="yes" xml:space="preserve">
          <source>The reporting of parameter entities (including the external DTD subset) is optional, and SAX2 drivers that report LexicalHandler events may not implement it; you can use the &lt;code&gt;http://xml.org/sax/features/lexical-handler/parameter-entities&lt;/code&gt; feature to query or control the reporting of parameter entities.</source>
          <target state="translated">매개 변수 엔터티 (외부 DTD 하위 집합 포함)보고는 선택 사항이며 LexicalHandler 이벤트를보고하는 SAX2 드라이버는이를 구현하지 않을 수 있습니다. &lt;code&gt;http://xml.org/sax/features/lexical-handler/parameter-entities&lt;/code&gt; 기능을 사용하여 매개 변수 엔티티의보고를 쿼리하거나 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6083e0509485bc16d1b67f9cd0c180d1fac35b49" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java programming language of an SQL ROWID value.</source>
          <target state="translated">SQL ROWID 값의 Java 프로그래밍 언어 표현 (매핑).</target>
        </trans-unit>
        <trans-unit id="0acb89110741064b366cdd1922c5e4764ac516a3" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java programming language of an SQL ROWID value. An SQL ROWID is a built-in type, a value of which can be thought of as an address for its identified row in a database table. Whether that address is logical or, in any respects, physical is determined by its originating data source.</source>
          <target state="translated">SQL ROWID 값의 Java 프로그래밍 언어 표현 (매핑). SQL ROWID는 기본 제공 유형으로, 그 값은 데이터베이스 테이블에서 식별 된 행의 주소로 간주 될 수 있습니다. 해당 주소가 논리적인지 여부에 관계없이 물리적 주소는 원래 데이터 소스에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a234babedabfce29cc4aa701cb753ce00ac220" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java&amp;trade; programming language of an SQL &lt;code&gt;BLOB&lt;/code&gt; value.</source>
          <target state="translated">SQL &lt;code&gt;BLOB&lt;/code&gt; 값 의 Java &amp;trade; 프로그래밍 언어 표현 (매핑) .</target>
        </trans-unit>
        <trans-unit id="4d77c9a7464d84c1e1a1e7121b389a8cb2d1668e" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java&amp;trade; programming language of an SQL &lt;code&gt;BLOB&lt;/code&gt; value. An SQL &lt;code&gt;BLOB&lt;/code&gt; is a built-in type that stores a Binary Large Object as a column value in a row of a database table. By default drivers implement &lt;code&gt;Blob&lt;/code&gt; using an SQL &lt;code&gt;locator(BLOB)&lt;/code&gt;, which means that a &lt;code&gt;Blob&lt;/code&gt; object contains a logical pointer to the SQL &lt;code&gt;BLOB&lt;/code&gt; data rather than the data itself. A &lt;code&gt;Blob&lt;/code&gt; object is valid for the duration of the transaction in which is was created.</source>
          <target state="translated">SQL &lt;code&gt;BLOB&lt;/code&gt; 값 의 Java &amp;trade; 프로그래밍 언어 표현 (매핑) . SQL &lt;code&gt;BLOB&lt;/code&gt; 는 데이터베이스 테이블의 행에 열 값으로 Binary Large Object를 저장하는 내장 유형입니다. 기본적으로 드라이버 는 SQL &lt;code&gt;locator(BLOB)&lt;/code&gt; 사용하여 &lt;code&gt;Blob&lt;/code&gt; 을 구현 합니다. 즉, &lt;code&gt;Blob&lt;/code&gt; 개체에는 데이터 자체가 아닌 SQL &lt;code&gt;BLOB&lt;/code&gt; 데이터에 대한 논리적 포인터가 포함 됩니다. &lt;code&gt;Blob&lt;/code&gt; 객체가 생성되는 트랜잭션 (transaction)의 기간 중에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3b478ac46ccb7d878a2f5619e7d5a35540bff2b2" translate="yes" xml:space="preserve">
          <source>The representation class associated with this &lt;code&gt;DataFlavor&lt;/code&gt; identifies the Java type of an object returned as a reference from an invocation &lt;code&gt;java.awt.datatransfer.getTransferData&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;DataFlavor&lt;/code&gt; 와 연관된 표현 클래스 는 호출 &lt;code&gt;java.awt.datatransfer.getTransferData&lt;/code&gt; 에서 참조로 반환 된 객체의 Java 유형을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="2b778106af4a2d34f18fd72da9905b02ac996017" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Double.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Double.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="58244bdf257d357f8d92e2421ad210e0d7962bd1" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Float.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Float.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="ded2585e0b6c084c04a4f0859a53141f76d123ae" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Integer.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Integer.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="6aab087f6a2f2da33d64c153ee96c99fa034a1e7" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Long.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Long.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="b9a0adc7cc916f3011d7fe2d1b1539f1d22e7cd4" translate="yes" xml:space="preserve">
          <source>The representation of a savepoint, which is a point within the current transaction that can be referenced from the &lt;code&gt;Connection.rollback&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Connection.rollback&lt;/code&gt; 메서드 에서 참조 할 수있는 현재 트랜잭션 내의 지점 인 저장 점의 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="16e0f89431331e3c19f8e9168d79da480c3ea351" translate="yes" xml:space="preserve">
          <source>The representation of a savepoint, which is a point within the current transaction that can be referenced from the &lt;code&gt;Connection.rollback&lt;/code&gt; method. When a transaction is rolled back to a savepoint all changes made after that savepoint are undone.</source>
          <target state="translated">&lt;code&gt;Connection.rollback&lt;/code&gt; 메서드 에서 참조 할 수있는 현재 트랜잭션 내의 지점 인 저장 점의 표현입니다 . 트랜잭션이 저장 점으로 롤백되면 해당 저장 점 이후의 모든 변경 사항이 실행 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="c10c8df535a59f66cf15a0bfa27c32d6f30bfdb3" translate="yes" xml:space="preserve">
          <source>The representation of an SGML DTD.</source>
          <target state="translated">SGML DTD의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="f354ab4341294adf05dcc226d6afe0dd75fdc477" translate="yes" xml:space="preserve">
          <source>The representation of an SGML DTD. DTD describes a document syntax and is used in parsing of HTML documents. It contains a list of elements and their attributes as well as a list of entities defined in the DTD.</source>
          <target state="translated">SGML DTD의 표현입니다. DTD는 문서 구문을 설명하며 HTML 문서 구문 분석에 사용됩니다. 여기에는 요소 및 해당 속성 목록과 DTD에 정의 된 엔티티 목록이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0d60a9c0e70768f0432c0076bb2b850f773e5a83" translate="yes" xml:space="preserve">
          <source>The request controls supplied to the initial context constructor are &lt;em&gt;not&lt;/em&gt; used as the context request controls for subsequent context operations such as searches and lookups. Context request controls are set and updated by using &lt;code&gt;setRequestControls()&lt;/code&gt;.</source>
          <target state="translated">초기 컨텍스트 생성자에 제공된 요청 컨트롤은 검색 및 조회와 같은 후속 컨텍스트 작업에 대한 컨텍스트 요청 컨트롤로 사용 &lt;em&gt;되지 않습니다&lt;/em&gt; . 컨텍스트 요청 컨트롤은 &lt;code&gt;setRequestControls()&lt;/code&gt; 를 사용하여 설정 및 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c538826a3a1f2f420e3436c5b667643e5f793cd" translate="yes" xml:space="preserve">
          <source>The request-host is a HDN (not IP address) and has the form HD, where D is the value of the Domain attribute, and H is a string that contains one or more dots.</source>
          <target state="translated">요청 호스트는 IP 주소가 아닌 HDN이며 HD 형식입니다. 여기서 D는 도메인 속성 값이고 H는 하나 이상의 점이 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a57362ff710e86a82bac45526ef9e2b2169857b3" translate="yes" xml:space="preserve">
          <source>The requested &lt;code&gt;Locale&lt;/code&gt; may contain an &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt; extension&lt;/a&gt; for specifying the desired numbering system. For example, &lt;code&gt;&quot;ar-u-nu-arab&quot;&lt;/code&gt; (in the BCP 47 language tag form) specifies Arabic with the Arabic-Indic digits and symbols, while &lt;code&gt;&quot;ar-u-nu-latn&quot;&lt;/code&gt; specifies Arabic with the Latin digits and symbols. Refer to the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification for numbering systems.</source>
          <target state="translated">요청 된 &lt;code&gt;Locale&lt;/code&gt; 에는 원하는 번호 시스템을 지정하기 위한 &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;확장자&lt;/a&gt; 가 포함될 수 있습니다 . 예를 들어, &lt;code&gt;&quot;ar-u-nu-arab&quot;&lt;/code&gt; (BCP 47 언어 태그 형식)은 아랍어-인도 숫자 및 기호로 아랍어를 지정하고 &lt;code&gt;&quot;ar-u-nu-latn&quot;&lt;/code&gt; 은 라틴 숫자 및 기호로 아랍어를 지정합니다. . 번호 시스템에 대해서는 &lt;em&gt;LDML (Unicode Locale Data Markup Language)&lt;/em&gt; 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4313d8db2408961b8c6e4e788b166da71d191f7" translate="yes" xml:space="preserve">
          <source>The requested coder-result object</source>
          <target state="translated">요청 된 코더 결과 객체</target>
        </trans-unit>
        <trans-unit id="c473246769f43aa19b3ba4b2ef431369ba324d78" translate="yes" xml:space="preserve">
          <source>The requested data array element as an integer.</source>
          <target state="translated">요청 된 데이터 배열 요소 (정수).</target>
        </trans-unit>
        <trans-unit id="bc4af42dc723a89b139169dad6f6ac48341fa317" translate="yes" xml:space="preserve">
          <source>The requested type is any line that matches the description in the provided &lt;code&gt;Line.Info&lt;/code&gt; object. For example, if the info object represents a speaker port, and the mixer supports exactly one speaker port, this method should return 1. If the info object represents a source data line and the mixer supports the use of 32 source data lines simultaneously, the return value should be 32. If there is no limit, this function returns &lt;a href=&quot;audiosystem#NOT_SPECIFIED&quot;&gt;&lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청 된 유형은 제공된 &lt;code&gt;Line.Info&lt;/code&gt; 개체 의 설명과 일치하는 모든 줄입니다 . 예를 들어, info 객체가 스피커 포트를 나타내고 믹서가 정확히 하나의 스피커 포트를 지원하는 경우이 메서드는 1을 반환해야합니다. info 객체가 소스 데이터 라인을 나타내고 믹서가 32 개의 소스 데이터 라인 사용을 동시에 지원하는 경우 반환 값은 32 여야합니다. 제한이 없으면이 함수는 &lt;a href=&quot;audiosystem#NOT_SPECIFIED&quot;&gt; &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="248e76eb2ee596cc71b6a4da144a1ff22287b387" translate="yes" xml:space="preserve">
          <source>The requested type must have a return type of &lt;code&gt;void&lt;/code&gt;. (This is consistent with the JVM's treatment of constructor type descriptors.)</source>
          <target state="translated">요청 된 유형의 반환 유형은 &lt;code&gt;void&lt;/code&gt; 입니다. (이것은 JVM이 생성자 유형 설명자를 처리하는 것과 일치합니다.)</target>
        </trans-unit>
        <trans-unit id="516805460907e538d55b063de2a7d8a474251df4" translate="yes" xml:space="preserve">
          <source>The requester has canceled the job or the printer has aborted the job, but the printer is still performing some actions on the job until a specified stop point occurs or job termination/cleanup is completed.</source>
          <target state="translated">요청자가 작업을 취소했거나 프린터가 작업을 중단했지만 지정된 중지 지점이 발생하거나 작업 종료 / 정리가 완료 될 때까지 프린터는 여전히 작업에 대해 일부 작업을 수행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f22f6979881830731d65c0765a1fe0d7c814e17" translate="yes" xml:space="preserve">
          <source>The required</source>
          <target state="translated">필요한</target>
        </trans-unit>
        <trans-unit id="745e1e490c53f8464a11eebd65e0f35408648502" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;hashCode&lt;/code&gt; behavior for Permission Objects is the following:</source>
          <target state="translated">권한 객체에 필요한 &lt;code&gt;hashCode&lt;/code&gt; 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b8bab1511c52f5ddaa9f2aab1201197de8e2410" translate="yes" xml:space="preserve">
          <source>The requirement of lookup object matching provides a &quot;fast fail&quot; behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use &lt;a href=&quot;methodhandles#reflectAs(java.lang.Class,java.lang.invoke.MethodHandle)&quot;&gt;&lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt;&lt;/a&gt; to override this limitation.</source>
          <target state="translated">조회 개체 일치의 요구 사항은 예기치 않은 범위에서 기호 정보 (또는 호출자 바인딩)가있는 메서드 핸들의 잘못된 표시를 신뢰할 수있는 프로그램에 대해 &quot;빠른 실패&quot;동작을 제공합니다. 이 제한을 무시 하려면 &lt;a href=&quot;methodhandles#reflectAs(java.lang.Class,java.lang.invoke.MethodHandle)&quot;&gt; &lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="55d02efa54b09ebdcdd937fdc51b7ffc1d272c16" translate="yes" xml:space="preserve">
          <source>The requirement of lookup object matching provides a &quot;fast fail&quot; behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use &lt;a href=&quot;methodhandles#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-&quot;&gt;&lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt;&lt;/a&gt; to override this limitation.</source>
          <target state="translated">조회 오브젝트 일치 요구 사항은 예상치 못한 범위의 기호 정보 (또는 호출자 바인딩)가있는 메소드 핸들의 잘못된 계시를 신뢰할 수있는 프로그램에 대해 &quot;빠른 실패&quot;동작을 제공합니다. 이 제한을 무시 하려면 &lt;a href=&quot;methodhandles#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-&quot;&gt; &lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cbf46ff6901cb358f2bf2adf82f26fea12aff47" translate="yes" xml:space="preserve">
          <source>The reseedable and prediction resistance capabilities of a DRBG.</source>
          <target state="translated">DRBG의 재배치 가능 및 예측 저항 기능.</target>
        </trans-unit>
        <trans-unit id="88faedd860fdc4cb6207174dad3840e3bf7612c6" translate="yes" xml:space="preserve">
          <source>The reserved method name &quot;new&quot; may be used to call a class's constructor as if all classes defined static &quot;new&quot; methods. Constructor invocations are typically considered &lt;code&gt;Expression&lt;/code&gt;s rather than &lt;code&gt;Statement&lt;/code&gt;s as they return a value.</source>
          <target state="translated">예약 된 메소드 이름 &quot;new&quot;는 모든 클래스가 정적 &quot;new&quot;메소드를 정의한 것처럼 클래스의 생성자를 호출하는 데 사용될 수 있습니다. 생성자 호출은 일반적으로 값을 반환 할 때 &lt;code&gt;Statement&lt;/code&gt; 가 아닌 &lt;code&gt;Expression&lt;/code&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="754706891133e7ad865e654b5b80f53d473f0298" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;DocumentBuilder&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;EntityResolver&lt;/code&gt; and &lt;code&gt;ErrorHandler&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;DocumentBuilder&lt;/code&gt; 는 동일한 &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; 를 갖는다 고 보장되지 않습니다 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 예 : Object.equals (Object obj)) . 기능적으로 동일한 &lt;code&gt;EntityResolver&lt;/code&gt; 및 &lt;code&gt;ErrorHandler&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7e567940636717249f219f15560c4ebd13f7896" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;SAXParser&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;../validation/schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;Schema&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;SAXParser&lt;/code&gt; 는 동일한 &lt;a href=&quot;../validation/schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; (예 : &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 를 가지도록 보장되지 않습니다 . 기능적으로 동일한 &lt;code&gt;Schema&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c30f2a2b35a74fb90b7aae0cc5ec8665873d5df5" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;Transformer&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;uriresolver&quot;&gt;&lt;code&gt;URIResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;errorlistener&quot;&gt;&lt;code&gt;ErrorListener&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;URIResolver&lt;/code&gt; and &lt;code&gt;ErrorListener&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;Transformer&lt;/code&gt; 는 동일한 &lt;a href=&quot;uriresolver&quot;&gt; &lt;code&gt;URIResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;errorlistener&quot;&gt; &lt;code&gt;ErrorListener&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; 를 가지도록 보장되지 않습니다 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 예 : Object.equals (Object obj)) . 기능적으로 동일한 &lt;code&gt;URIResolver&lt;/code&gt; 및 &lt;code&gt;ErrorListener&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="01b3d7c853e31dc0a7995e2fca623c0cc7a8afec" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;Validator&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;LSResourceResolver&lt;/code&gt; and &lt;code&gt;ErrorHandler&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;Validator&lt;/code&gt; 는 동일한 &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; 를 가지도록 보장되지 않습니다 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 예 : Object.equals (Object obj)) . 기능적으로 동일한 &lt;code&gt;LSResourceResolver&lt;/code&gt; 및 &lt;code&gt;ErrorHandler&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f47dccbff991860b05f0ad7e168ff6056c8b397" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;XPath&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../namespace/namespacecontext&quot;&gt;&lt;code&gt;NamespaceContext&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;XPathFunctionResolver&lt;/code&gt;, &lt;code&gt;XPathVariableResolver&lt;/code&gt; and &lt;code&gt;NamespaceContext&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;XPath&lt;/code&gt; 는 동일한 &lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../namespace/namespacecontext&quot;&gt; &lt;code&gt;NamespaceContext&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; , 예를 들어 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 를 갖는다 고 보장되지 않습니다 . 기능적으로 동일한 &lt;code&gt;XPathFunctionResolver&lt;/code&gt; , &lt;code&gt;XPathVariableResolver&lt;/code&gt; 및 &lt;code&gt;NamespaceContext&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="df87b115c664fd653afbf26bb11c0fc8970cab09" translate="yes" xml:space="preserve">
          <source>The resolution of the system identifiers associated with entities is done using &lt;code&gt;Document.documentURI&lt;/code&gt;. However, when the feature &quot;LS&quot; defined in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407&quot;&gt;DOM Level 3 Load and Save&lt;/a&gt;] is supported by the DOM implementation, the parameter &quot;resource-resolver&quot; can also be used on &lt;code&gt;DOMConfiguration&lt;/code&gt; objects attached to &lt;code&gt;Document&lt;/code&gt; nodes. If this parameter is set, &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; will invoke the resource resolver instead of using &lt;code&gt;Document.documentURI&lt;/code&gt;.</source>
          <target state="translated">엔티티와 관련된 시스템 식별자의 확인은 &lt;code&gt;Document.documentURI&lt;/code&gt; 를 사용하여 수행됩니다 . 그러나 [ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407&quot;&gt;DOM 레벨 3로드 및 저장&lt;/a&gt; ]에 정의 된 기능 &quot;LS&quot; 가 DOM 구현에 의해 지원되는 경우 &quot;resource-resolver&quot;매개 변수 는 &lt;code&gt;Document&lt;/code&gt; 노드에 첨부 된 &lt;code&gt;DOMConfiguration&lt;/code&gt; 객체 에서도 사용할 수 있습니다 . 이 매개 변수가 설정되면 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 는 &lt;code&gt;Document.documentURI&lt;/code&gt; 를 사용하는 대신 리소스 확인자를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1022ae785514449efe40f2c8963abb11d2504058" translate="yes" xml:space="preserve">
          <source>The resolve phase is controlled by two parameters, set on this class.</source>
          <target state="translated">확인 단계는이 클래스에서 설정 한 두 개의 매개 변수로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="6ad35174cec491d7c90515cea6438bbe6eeb865e" translate="yes" xml:space="preserve">
          <source>The resolved module with the given name or an empty &lt;code&gt;
         Optional&lt;/code&gt; if there isn't a module with this name in this configuration or any parent configurations</source>
          <target state="translated">주어진 이름을 가진 해결 된 모듈 또는 이 구성 또는 상위 구성에이 이름을 가진 모듈이없는 경우 빈 &lt;code&gt; Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a888b0082bf1bba928794b9e262d95500605aec" translate="yes" xml:space="preserve">
          <source>The resolved type descriptor at the call site of &lt;code&gt;invoke&lt;/code&gt; must be a valid argument to the receivers &lt;code&gt;asType&lt;/code&gt; method. In particular, the caller must specify the same argument arity as the callee's type, if the callee is not a &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity collector&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;invoke&lt;/code&gt; 의 호출 사이트에서 확인 된 유형 설명 자는 수신자 &lt;code&gt;asType&lt;/code&gt; 메소드에 대한 유효한 인수 여야합니다 . 특히 피 호출자가 &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity collector&lt;/a&gt; 가 아닌 경우 호출자는 피 호출자의 유형과 동일한 인수 arity를 ​​지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c2a61f04ea30a79177449a58b04a28b104802818" translate="yes" xml:space="preserve">
          <source>The resolved type descriptor at the call site of &lt;code&gt;invoke&lt;/code&gt; must be a valid argument to the receivers &lt;code&gt;asType&lt;/code&gt; method. In particular, the caller must specify the same argument arity as the callee's type, if the callee is not a &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity collector&lt;/a&gt;.</source>
          <target state="translated">의 호출 사이트에서 확인 된 유형 설명 &lt;code&gt;invoke&lt;/code&gt; 수신기에 대한 유효한 인수해야 &lt;code&gt;asType&lt;/code&gt; 의 방법. 특히, 수신자가 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;가변 arity 콜렉터&lt;/a&gt; 가 아닌 경우 호출자는 수신자 유형과 동일한 인수 arity를 ​​지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eea421ae13a64e1dbdbe93927bc945b3bf0f2116" translate="yes" xml:space="preserve">
          <source>The resolver that will be set on any XMLStreamReader or XMLEventReader created by this factory instance.</source>
          <target state="translated">이 팩토리 인스턴스에 의해 생성 된 XMLStreamReader 또는 XMLEventReader에 설정 될 리졸버입니다.</target>
        </trans-unit>
        <trans-unit id="adc8b5b806ac4d1ec6811f56446ced5b92623119" translate="yes" xml:space="preserve">
          <source>The resolver will first search the system-type of entries with the specified &lt;code&gt;systemId&lt;/code&gt;. The system entries include &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;rewriteSystem&lt;/code&gt; and &lt;code&gt;systemSuffix&lt;/code&gt; entries.</source>
          <target state="translated">해석기는 먼저 지정된 &lt;code&gt;systemId&lt;/code&gt; 를 사용하여 시스템 유형 항목을 검색합니다 . 시스템 항목에는 &lt;code&gt;system&lt;/code&gt; , &lt;code&gt;rewriteSystem&lt;/code&gt; 및 &lt;code&gt;systemSuffix&lt;/code&gt; 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="043a5d4e92d9440bd14303d4b664c8b6162aa2d5" translate="yes" xml:space="preserve">
          <source>The resource manager is doing work outside a global transaction.</source>
          <target state="translated">리소스 관리자는 전역 트랜잭션 외부에서 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3a78066f6d7d65570a29e16f616bfab963bff0e5" translate="yes" xml:space="preserve">
          <source>The resource manager returns zero or more XIDs of the transaction branches that are currently in a prepared or heuristically completed state. If an error occurs during the operation, the resource manager should throw the appropriate XAException.</source>
          <target state="translated">리소스 관리자는 현재 준비되었거나 경험적으로 완료된 상태에있는 트랜잭션 분기의 XID를 0 개 이상 반환합니다. 조작 중에 오류가 발생하면 자원 관리자는 적절한 XAException을 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="71062e973d41f6ccd0f7868eee574273010d7036" translate="yes" xml:space="preserve">
          <source>The resource manager rolled back the transaction branch for a reason not on this list.</source>
          <target state="translated">자원 관리자가이 목록에없는 이유로 트랜잭션 분기를 롤백했습니다.</target>
        </trans-unit>
        <trans-unit id="9ef095cc8f8eb9deb63e621a30579efd048e54dd" translate="yes" xml:space="preserve">
          <source>The resource requested or null.</source>
          <target state="translated">요청 된 리소스 또는 null입니다.</target>
        </trans-unit>
        <trans-unit id="4cdbf0e8f46078714d3bc07542a4974803f2d6c4" translate="yes" xml:space="preserve">
          <source>The resources will be located when the returned stream is evaluated. If the evaluation results in an &lt;code&gt;IOException&lt;/code&gt; then the I/O exception is wrapped in an &lt;a href=&quot;../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; that is then thrown.</source>
          <target state="translated">반환 된 스트림이 평가 될 때 리소스를 찾습니다. 평가 결과 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 I / O 예외가 발생 하는 &lt;a href=&quot;../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 으로&lt;/a&gt; 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3d61363b6633b0d99e034696664c54cea2da612" translate="yes" xml:space="preserve">
          <source>The response body can be discarded using one of &lt;a href=&quot;httpresponse.bodyhandlers#discarding()&quot;&gt;&lt;code&gt;discarding&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;httpresponse.bodyhandlers#replacing(U)&quot;&gt;&lt;code&gt;replacing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응답 본문은 &lt;a href=&quot;httpresponse.bodyhandlers#discarding()&quot;&gt; &lt;code&gt;discarding&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;httpresponse.bodyhandlers#replacing(U)&quot;&gt; &lt;code&gt;replacing&lt;/code&gt; &lt;/a&gt; 중 하나를 사용하여 폐기 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e89a0946db3ad76329915dbe1fb2d058415e9c15" translate="yes" xml:space="preserve">
          <source>The response body is not available through this, or the &lt;code&gt;
 HttpResponse&lt;/code&gt; API, but instead all response body is forwarded to the given &lt;code&gt;subscriber&lt;/code&gt;, which should make it available, if appropriate, through some other mechanism, e.g. an entry in a database, etc.</source>
          <target state="translated">응답 본문은이 또는 &lt;code&gt; HttpResponse&lt;/code&gt; API를 통해 사용할 수 없지만, 대신 모든 응답 본문이 주어진 &lt;code&gt;subscriber&lt;/code&gt; 에게 전달되며, 적절한 경우 데이터베이스의 항목과 같은 다른 메커니즘을 통해 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6dd06ecc31472bc0ffa478932d69394294897b00" translate="yes" xml:space="preserve">
          <source>The restore button text property.</source>
          <target state="translated">복원 단추 텍스트 속성입니다.</target>
        </trans-unit>
        <trans-unit id="99b6d2884fc55c38d82210c2985b9069bbb9d028" translate="yes" xml:space="preserve">
          <source>The result code. A zero value indicates success.</source>
          <target state="translated">결과 코드 값이 0이면 성공을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8613290fff9e558c87a48402abefab9874ccc8e4" translate="yes" xml:space="preserve">
          <source>The result does not depend on the local time zone.</source>
          <target state="translated">결과는 현지 시간대에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="921d7223769295c006da8a5575b7156fcaa03cc8" translate="yes" xml:space="preserve">
          <source>The result from JDK classes implementing &lt;code&gt;TemporalAccessor&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;TemporalAccessor&lt;/code&gt; 를 구현하는 JDK 클래스의 결과 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="295420590a431895b0a9587ea2bb7cf9aa9bc5d8" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;
 null&lt;/code&gt; and is a &lt;code&gt;FileTime&lt;/code&gt; that represents the same time. This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">결과는 &lt;code&gt;true&lt;/code&gt; 인수가 아닌 경우에만 경우 &lt;code&gt; null&lt;/code&gt; 과이다 &lt;code&gt;FileTime&lt;/code&gt; 같은 시간을 나타냅니다. 이 메서드는 &lt;code&gt;Object.equals&lt;/code&gt; 메서드 의 일반 계약을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="f6bd1c0a2aca7f162dd073e90d5740cb1616d84f" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;Color&lt;/code&gt; object that has the same red, green, blue, and alpha values as this object.</source>
          <target state="translated">결과는 인수가 &lt;code&gt;null&lt;/code&gt; 이 &lt;code&gt;Color&lt;/code&gt; 객체와 동일한 빨강, 녹색, 파랑 및 알파 값을 가진 Color 객체 인 경우에만 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17e6a87b8d0781fae57ea50faf6f5b7a370d70bb" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;FileTime&lt;/code&gt; that represents the same time. This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">결과는 &lt;code&gt;true&lt;/code&gt; 인수가 아닌 경우에만 경우 &lt;code&gt;null&lt;/code&gt; 과이다 &lt;code&gt;FileTime&lt;/code&gt; 같은 시간을 나타냅니다. 이 메소드는 &lt;code&gt;Object.equals&lt;/code&gt; 메소드 의 일반 계약을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5e94f4c32498ea093ba8d30e7750bbbc7e9c3bb7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;Rectangle&lt;/code&gt; object that has the same upper-left corner, width, and height as this &lt;code&gt;Rectangle&lt;/code&gt;.</source>
          <target state="translated">그 결과는 &lt;code&gt;true&lt;/code&gt; 인수가없는 경우 만 &lt;code&gt;null&lt;/code&gt; 및 인 &lt;code&gt;Rectangle&lt;/code&gt; 이 같은 왼쪽 상단, 폭 및 높이를 갖는 객체 &lt;code&gt;Rectangle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ad28501616ab98234ec816e4489d80b5e85181f" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is an &lt;code&gt;AlphaComposite&lt;/code&gt; object that has the same compositing rule and alpha value as this object.</source>
          <target state="translated">결과는 인수가 &lt;code&gt;null&lt;/code&gt; 이 &lt;code&gt;AlphaComposite&lt;/code&gt; 개체와 동일한 합성 규칙 및 알파 값을 가진 AlphaComposite 개체 인 경우에만 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0dee0b193f5269aef268cfda1e03af61caf65f1" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; only if two cookies come from same domain (case-insensitive), have same name (case-insensitive), and have same path (case-sensitive).</source>
          <target state="translated">결과는 두 개의 쿠키가 동일한 도메인 (대소 문자 구분)에서 왔으며 동일한 이름 (대소 문자 구분)이없고 동일한 경로 (대소 문자 구분) 가있는 &lt;code&gt;true&lt;/code&gt; 에만 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="838dc70d106c3ae54e71b7f7448a352db88afffd" translate="yes" xml:space="preserve">
          <source>The result is a Unicode character</source>
          <target state="translated">결과는 유니 코드 문자입니다</target>
        </trans-unit>
        <trans-unit id="432ed2e9a36f0af4da6066cc56714de8ffa1b599" translate="yes" xml:space="preserve">
          <source>The result is a lexical representation generated by &lt;a href=&quot;#toXMLFormat()&quot;&gt;&lt;code&gt;toXMLFormat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과는 &lt;a href=&quot;#toXMLFormat()&quot;&gt; &lt;code&gt;toXMLFormat()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 어휘 표현 입니다.</target>
        </trans-unit>
        <trans-unit id="35b56830c2c27888962f73364e19ecf38d296dd4" translate="yes" xml:space="preserve">
          <source>The result is a literal &lt;code&gt;'%'&lt;/code&gt; (&lt;code&gt;'\u0025'&lt;/code&gt;)</source>
          <target state="translated">결과는 리터럴 &lt;code&gt;'%'&lt;/code&gt; ( &lt;code&gt;'\u0025'&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="ef02a3668d69ce2348a1bc4508f08e4804908b1b" translate="yes" xml:space="preserve">
          <source>The result is a string that represents the sign and magnitude (absolute value) of the argument</source>
          <target state="translated">결과는 인수의 부호와 크기 (절대 값)를 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="50a9d6bfa24192970ed8fb8258874aefd0c97173" translate="yes" xml:space="preserve">
          <source>The result is a string that represents the sign and magnitude (absolute value) of the argument. The formatting of the sign is described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt;. The formatting of the magnitude</source>
          <target state="translated">결과는 인수의 부호와 크기 (절대 값)를 나타내는 문자열입니다. 부호의 형식은 &lt;a href=&quot;#L10nAlgorithm&quot;&gt;현지화 알고리즘에&lt;/a&gt; 설명되어 있습니다. 크기의 서식</target>
        </trans-unit>
        <trans-unit id="f2cfd2a95bfe92fd8ecc073d54de4e5f2a29bf7c" translate="yes" xml:space="preserve">
          <source>The result is associated with the first type that successfully parses. Normally, applications will use &lt;code&gt;instanceof&lt;/code&gt; to check the result. For example:</source>
          <target state="translated">결과는 성공적으로 구문 분석 한 첫 번째 유형과 연관됩니다. 일반적으로 응용 프로그램은 &lt;code&gt;instanceof&lt;/code&gt; 를 사용 하여 결과를 확인합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2603fe8103afc50e2378d77be85a45908bf61f3a" translate="yes" xml:space="preserve">
          <source>The result is formatted according to the XML Schema 1.0 spec and can be always parsed back later into the equivalent &lt;code&gt;Duration Object&lt;/code&gt; by &lt;a href=&quot;datatypefactory#newDuration(java.lang.String)&quot;&gt;&lt;code&gt;DatatypeFactory.newDuration(String  lexicalRepresentation)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과는 XML Schema 1.0 사양에 따라 형식이 지정되며 나중에 &lt;a href=&quot;datatypefactory#newDuration(java.lang.String)&quot;&gt; &lt;code&gt;DatatypeFactory.newDuration(String lexicalRepresentation)&lt;/code&gt; &lt;/a&gt; 의해 항상 동등한 &lt;code&gt;Duration Object&lt;/code&gt; 로 다시 구문 분석 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c479cf3264a2832bd0cd79a44afc9492a7822f3" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal integer</source>
          <target state="translated">결과는 십진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="1baf7d104748e0c4f8533df16bd664f663e30ad1" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal number</source>
          <target state="translated">결과는 10 진수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="5f14b19f3b75abbc59e057304d121d6548d56189" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal number in computerized scientific notation</source>
          <target state="translated">결과는 컴퓨터 공학 표기법에서 10 진수로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ab4d798c9eeb9edc29f6dcdd7b9bd66fea5cc6a" translate="yes" xml:space="preserve">
          <source>The result is formatted as a hexadecimal floating-point number with a significand and an exponent. This conversion is &lt;b&gt;not&lt;/b&gt; supported for the &lt;code&gt;BigDecimal&lt;/code&gt; type despite the latter's being in the</source>
          <target state="translated">결과는 유효하고 지수가있는 16 진수 부동 소수점 숫자로 형식이 지정됩니다. &lt;code&gt;BigDecimal&lt;/code&gt; 유형은 후자에 &lt;b&gt;있지만&lt;/b&gt; 이 변환은 지원 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="42563538eaee038d859706aa7ad8dd76aaba6a51" translate="yes" xml:space="preserve">
          <source>The result is formatted as a hexadecimal integer</source>
          <target state="translated">결과는 16 진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="5e4dac5beac66ef686eb3d95b633320454953615" translate="yes" xml:space="preserve">
          <source>The result is formatted as an octal integer</source>
          <target state="translated">결과는 8 진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="b924acf7a536ce1992d3ebe1342457a6f36dca7a" translate="yes" xml:space="preserve">
          <source>The result is formatted using computerized scientific notation or decimal format, depending on the precision and the value after rounding.</source>
          <target state="translated">결과는 반올림 후의 정밀도와 값에 따라 컴퓨터 화 된 과학적 표기법 또는 10 진수 형식을 사용하여 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9909e6819bf8d3b2b56ef5ec3cec62f6ed40ce7e" translate="yes" xml:space="preserve">
          <source>The result is obtained by invoking &lt;code&gt;Integer.toHexString(arg.hashCode())&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;Integer.toHexString(arg.hashCode())&lt;/code&gt; 를 호출하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb45f182258a186b18790c8b6cad368f2f9319d" translate="yes" xml:space="preserve">
          <source>The result is returned in an enumeration of &lt;code&gt;SearchResult&lt;/code&gt;s. Each &lt;code&gt;SearchResult&lt;/code&gt; contains the name of the object and other information about the object (see SearchResult). The name is either relative to the target context of the search (which is named by the &lt;code&gt;name&lt;/code&gt; parameter), or it is a URL string. If the target context is included in the enumeration (as is possible when &lt;code&gt;cons&lt;/code&gt; specifies a search scope of &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; or &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt;), its name is the empty string. The &lt;code&gt;SearchResult&lt;/code&gt; may also contain attributes of the matching object if the &lt;code&gt;cons&lt;/code&gt; argument specified that attributes be returned.</source>
          <target state="translated">결과는 &lt;code&gt;SearchResult&lt;/code&gt; 의 열거로 리턴됩니다 . 각 &lt;code&gt;SearchResult&lt;/code&gt; 에는 객체 이름과 객체에 대한 기타 정보가 포함됩니다 (SearchResult 참조). 이름은 검색의 대상 컨텍스트 ( &lt;code&gt;name&lt;/code&gt; 매개 변수로 이름 지정)에 상대적 이거나 URL 문자열입니다. 대상 컨텍스트가 열거에 포함 된 경우 ( &lt;code&gt;cons&lt;/code&gt; 가 &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; 또는 &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt; 의 검색 범위를 지정할 때 가능한 것처럼 ) 해당 이름은 빈 문자열입니다. &lt;code&gt;SearchResult&lt;/code&gt; 경우도 일치하는 객체의 속성을 포함 할 수있다 &lt;code&gt;cons&lt;/code&gt; 인수는 속성이 반환되도록 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="06f5e6bd8fe2e41c0946b6e4854fa774421e66fe" translate="yes" xml:space="preserve">
          <source>The result is that two threads are running concurrently: the current thread (which returns from the call to the &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its &lt;code&gt;run&lt;/code&gt; method).</source>
          <target state="translated">결과적으로 두 스레드가 동시에 실행됩니다. 현재 스레드 ( &lt;code&gt;start&lt;/code&gt; 메소드 호출에서 리턴 )와 다른 스레드 ( &lt;code&gt;run&lt;/code&gt; 메소드 실행 ).</target>
        </trans-unit>
        <trans-unit id="d28d29bf955a0a2e562abe4616fe55325dd93e91" translate="yes" xml:space="preserve">
          <source>The result is the platform-specific line separator</source>
          <target state="translated">결과는 플랫폼 별 행 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="41412fe4e863ea723be458262dd0cc609691ec90" translate="yes" xml:space="preserve">
          <source>The result is undefined if a given argument is out of bounds.</source>
          <target state="translated">주어진 인수가 범위를 벗어난 경우 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="058151d93a1ffc55deb73095cbeeabd4b91f7162" translate="yes" xml:space="preserve">
          <source>The result may be the same object or a different object. If the requested target view isn't available then the given bean is returned.</source>
          <target state="translated">결과는 동일한 객체이거나 다른 객체 일 수 있습니다. 요청 된 대상 뷰를 사용할 수 없으면 지정된 Bean이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d71f2225914f95f63b3119e8410020da3a87b63a" translate="yes" xml:space="preserve">
          <source>The result must be a concrete subclass of StartTlsResponse and must have a public zero-argument constructor.</source>
          <target state="translated">결과는 StartTlsResponse의 구체적인 서브 클래스 여야하며 인수없는 공용 인수 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="77ef281b848eda832ef63d0cbb4b3167978fdaff" translate="yes" xml:space="preserve">
          <source>The result of a match operation.</source>
          <target state="translated">일치 작업의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="16ff2b07c82c6850565061f19a2fba35ea83719e" translate="yes" xml:space="preserve">
          <source>The result of any attempt to modify a node passed to a &lt;code&gt;LSSerializerFilter&lt;/code&gt; is implementation dependent.</source>
          <target state="translated">&lt;code&gt;LSSerializerFilter&lt;/code&gt; 에 전달 된 노드를 수정하려는 시도의 결과 는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="86cbe802aaee405937142c5c8477e8e564f921ce" translate="yes" xml:space="preserve">
          <source>The result of applying this method to these arguments.</source>
          <target state="translated">이 방법을 이러한 인수에 적용한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="b31380d4fb2e0fe70212e83955d24c3b92a4b2b8" translate="yes" xml:space="preserve">
          <source>The result of dereferencing a &lt;code&gt;URIReference&lt;/code&gt; is either an instance of &lt;a href=&quot;octetstreamdata&quot;&gt;&lt;code&gt;OctetStreamData&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;nodesetdata&quot;&gt;&lt;code&gt;NodeSetData&lt;/code&gt;&lt;/a&gt;. Unless the &lt;code&gt;URIReference&lt;/code&gt; is a</source>
          <target state="translated">&lt;code&gt;URIReference&lt;/code&gt; 를 역 참조한 결과는 &lt;a href=&quot;octetstreamdata&quot;&gt; &lt;code&gt;OctetStreamData&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;nodesetdata&quot;&gt; &lt;code&gt;NodeSetData&lt;/code&gt; &lt;/a&gt; 인스턴스입니다 . 하지 않는 한 &lt;code&gt;URIReference&lt;/code&gt; 를가 인</target>
        </trans-unit>
        <trans-unit id="57688b2e9247501954c4e97e1843bbe216d0db07" translate="yes" xml:space="preserve">
          <source>The result of evaluating an XPath expression as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">XPath 표현식을 &lt;code&gt;String&lt;/code&gt; 으로 평가 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="187dde591e1a356faf91de53b761157c44b78684" translate="yes" xml:space="preserve">
          <source>The result of evaluating an XPath expression as an &lt;code&gt;Object&lt;/code&gt; of &lt;code&gt;returnType&lt;/code&gt;.</source>
          <target state="translated">int로서 XPath 식을 평가 한 결과 &lt;code&gt;Object&lt;/code&gt; 의 &lt;code&gt;returnType&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="06c9132221a6a96dee79b4ca2f11200dc474b3d2" translate="yes" xml:space="preserve">
          <source>The result of evaluating the &lt;code&gt;XPath&lt;/code&gt; function as an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XPath&lt;/code&gt; 함수를 &lt;code&gt;Object&lt;/code&gt; 로 평가 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="0fbfd9ab10f2fcfc0e43605231238f6c0ded7faf" translate="yes" xml:space="preserve">
          <source>The result of evaluating the expression.</source>
          <target state="translated">식을 평가 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="5429cf36c8fd7a2562aad20c9d7f000fb4661122" translate="yes" xml:space="preserve">
          <source>The result of invoking &lt;code&gt;toString()&lt;/code&gt; on the destination for the output</source>
          <target state="translated">출력 대상에서 &lt;code&gt;toString()&lt;/code&gt; 을 호출 한 결과</target>
        </trans-unit>
        <trans-unit id="f10bfc6a52d64bcc34aea2bf2ebde23c53dfafd9" translate="yes" xml:space="preserve">
          <source>The result of parsing drives these callback methods.</source>
          <target state="translated">파싱 ​​결과는 이러한 콜백 메서드를 구동합니다.</target>
        </trans-unit>
        <trans-unit id="73d45b66d9ffa1146363db71d3dd68e129484be6" translate="yes" xml:space="preserve">
          <source>The result of parsing drives these callback methods. The open and close actions should be balanced. The &lt;code&gt;flush&lt;/code&gt; method will be the last method called, to give the receiver a chance to flush any pending data into the document.</source>
          <target state="translated">파싱 ​​결과는 이러한 콜백 메서드를 구동합니다. 열기와 닫기 동작은 균형을 이루어야합니다. &lt;code&gt;flush&lt;/code&gt; 방법은 수신자에게 문서에 보류중인 데이터를 플러시 할 수있는 기회를주고, 마지막으로 호출 방법이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="44e206b266ba20a6d4c2e1a04be2e9225595f101" translate="yes" xml:space="preserve">
          <source>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</source>
          <target state="translated">주어진 입력을 처리 한 결과는 다른 입력의 존재 또는 부재 (직교성)의 함수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fe195ae57fa315bdb0e05f0a54cdd78c21fbbf3c" translate="yes" xml:space="preserve">
          <source>The result of this algorithm is chosen arbitrarily from the methods with most specific return type among all selected methods from step 3. Let R be a return type of a method M from the set of all selected methods from step 3. M is a method with most specific return type if there is no such method N != M from the same set, having return type S != R, such that S is a subtype of R as determined by R.class.&lt;a href=&quot;#isAssignableFrom(java.lang.Class)&quot;&gt;&lt;code&gt;isAssignableFrom(java.lang.Class&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;(S.class).</source>
          <target state="translated">이 알고리즘의 결과는 3 단계에서 선택한 모든 방법 중 가장 구체적인 반환 유형을 가진 방법에서 임의로 선택됩니다. R을 3 단계에서 선택한 모든 방법 집합에서 방법 M의 반환 유형이라고 가정합니다. M은 다음과 같은 방법입니다. 동일한 세트에서 N! = M 메소드가없는 경우 가장 구체적인 리턴 유형은 리턴 유형 S! = R을 갖습니다. S는 R.class에 의해 결정된 R의 하위 유형입니다. &lt;a href=&quot;#isAssignableFrom(java.lang.Class)&quot;&gt; &lt;code&gt;isAssignableFrom(java.lang.Class&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; (S.class).</target>
        </trans-unit>
        <trans-unit id="e7fdb4e83c0852b667620524f411ba48b7948b95" translate="yes" xml:space="preserve">
          <source>The result of this algorithm is the union of all selected methods from step 3.</source>
          <target state="translated">이 알고리즘의 결과는 3 단계에서 선택한 모든 방법의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="53dcb69ac17959659b0334122a358f8985fa05ac" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. In most cases, the positive/negative sign will be the same in each of the supported fields.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 대부분의 경우 양수 / 음수 부호는 지원되는 각 필드에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7daa711ab9261153416c162a0aec24648bdcf12b" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 음수 부호는 매년, 월, 일마다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="70f2097d3f2bdbf3980ebc845ba5296b4a7310cf" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. To guarantee to obtain a positive duration call &lt;a href=&quot;#abs()&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; on the result.</source>
          <target state="translated">이 방법의 결과는 종료가 시작 이전 인 경우 음수 기간이 될 수 있습니다. 양수 기간을 확보하려면 결과에 대해 &lt;a href=&quot;#abs()&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="84fc9d37222c832e8afbf150d8f6699253efda20" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. To guarantee to obtain a positive duration call &lt;a href=&quot;duration#abs--&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; on the result.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 결과에 대해 긍정적 인 지속 시간을 얻기 위해 &lt;a href=&quot;duration#abs--&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="fdc023462e3c1d38fa0fae3a92e16cba6d2639d7" translate="yes" xml:space="preserve">
          <source>The result of this method is &lt;code&gt;TemporalAccessor&lt;/code&gt; which represents the data as seen in the input. Values are not validated, thus parsing a date string of '2012-00-65' would result in a temporal with three fields - year of '2012', month of '0' and day-of-month of '65'.</source>
          <target state="translated">이 메소드의 결과 는 입력에 표시된대로 데이터를 나타내는 &lt;code&gt;TemporalAccessor&lt;/code&gt; 입니다. 값의 유효성이 검사되지 않으므로 '2012-00-65'날짜 문자열을 구문 분석하면 '2012'연도, '0'월 및 '65'월의 세 필드로 된 시간이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52fc7eddd6f4fde58aa8d10634dec95344d469b7" translate="yes" xml:space="preserve">
          <source>The result of this method is absolute if, and only if, either this URI is absolute or the given URI is absolute.</source>
          <target state="translated">이 URI가 절대이거나 지정된 URI가 절대 인 경우에만이 메소드의 결과는 절대입니다.</target>
        </trans-unit>
        <trans-unit id="09c0c8baacc8b26a7914b1dbea349839039a03cd" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;#insert(int,java.lang.CharSequence,int,int)&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메서드의 결과는 마치이 개체의 &lt;a href=&quot;#insert(int,java.lang.CharSequence,int,int)&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메서드 의 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="33f42a4bb7c7ad421307948fd84808d9ca5b7265" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;stringbuffer#insert-int-java.lang.CharSequence-int-int-&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메소드의 결과는이 오브젝트의 &lt;a href=&quot;stringbuffer#insert-int-java.lang.CharSequence-int-int-&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메소드를 호출 한 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e72a2494b9f2adf3a9c829328a4201155a935ee8" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;stringbuilder#insert-int-java.lang.CharSequence-int-int-&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메소드의 결과는이 오브젝트의 &lt;a href=&quot;stringbuilder#insert-int-java.lang.CharSequence-int-int-&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메소드를 호출 한 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8aac06f8f47a270c52f5af0438f30546f8c15210" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this.append(s, 0, s.length());</source>
          <target state="translated">이 메소드의 결과는 this.append (s, 0, s.length ())의 호출 인 경우와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7b7539ebe1108c837cb3ebf5e22050282d869cda" translate="yes" xml:space="preserve">
          <source>The result of this method is never null. This method only associates the returned &lt;code&gt;KeyTab&lt;/code&gt; object with the default keytab file and does not read it.</source>
          <target state="translated">이 메소드의 결과는 결코 null이 아닙니다. 이 메소드는 리턴 된 &lt;code&gt;KeyTab&lt;/code&gt; 오브젝트를 기본 키탭 파일 에만 연관시키고 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7001452e9a69f2ce57bba98f6683a9cf75e695fd" translate="yes" xml:space="preserve">
          <source>The result of this method is never null. This method only associates the returned &lt;code&gt;KeyTab&lt;/code&gt; object with the file and does not read it.</source>
          <target state="translated">이 메소드의 결과는 결코 null이 아닙니다. 이 메소드는 리턴 된 &lt;code&gt;KeyTab&lt;/code&gt; 오브젝트 만 파일과 연관시키고 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5dddf426eb8badc7192516892b3925d64fec814" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;../temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;../temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="c493abfdae35894af24f4901c426e667b33769ca" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;../temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;../temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="cf14aaf159e93918c79f0986121a7011b52fe97e" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporaladjuster#adjustInto(java.time.temporal.Temporal)&quot;&gt;&lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt;&lt;/a&gt; method on the specified adjuster passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporaladjuster#adjustInto(java.time.temporal.Temporal)&quot;&gt; &lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 조정기에 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="c9079bf22411247394dc7e14291f74d7e689d317" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporaladjuster#adjustInto-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt;&lt;/a&gt; method on the specified adjuster passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporaladjuster#adjustInto-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 조정기에 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="952caf818a8c4cd6663bea809ef9d640be5e151b" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="ed9634345d8412156512a42500e34a894cf4c2f5" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="9b7fc7cadcbbb563002dfc29694594763d5fe98f" translate="yes" xml:space="preserve">
          <source>The result of this method will make up the contents of the SASL buffer as defined in RFC 2222 without the leading four octet field that represents the length. &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; specify the portion of &lt;code&gt;outgoing&lt;/code&gt; to use.</source>
          <target state="translated">이 방법의 결과는 길이를 나타내는 선행 4 옥텟 필드없이 RFC 2222에 정의 된대로 SASL 버퍼의 내용을 구성합니다. &lt;code&gt;offset&lt;/code&gt; 과 &lt;code&gt;len&lt;/code&gt; 은 사용할 &lt;code&gt;outgoing&lt;/code&gt; 부분을 ​​지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b8cb5fb0da99e3e289350d5c66fac89988702d0" translate="yes" xml:space="preserve">
          <source>The result returned by the &lt;a href=&quot;keyselector#select(javax.xml.crypto.dsig.keyinfo.KeyInfo,javax.xml.crypto.KeySelector.Purpose,javax.xml.crypto.AlgorithmMethod,javax.xml.crypto.XMLCryptoContext)&quot;&gt;&lt;code&gt;KeySelector.select&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;keyselector#select(javax.xml.crypto.dsig.keyinfo.KeyInfo,javax.xml.crypto.KeySelector.Purpose,javax.xml.crypto.AlgorithmMethod,javax.xml.crypto.XMLCryptoContext)&quot;&gt; &lt;code&gt;KeySelector.select&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 결과 입니다.</target>
        </trans-unit>
        <trans-unit id="9369d2fab7f01eadc45cae17b70a104674f355e1" translate="yes" xml:space="preserve">
          <source>The result returned by the call is boxed if it is a primitive, or forced to null if the return type is void.</source>
          <target state="translated">호출이 리턴 한 결과는 기본 인 경우 상자로 표시되거나 리턴 유형이 void 인 경우 강제로 널로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="806535d76174a264f9b4ff6d7c99faca08eddf1e" translate="yes" xml:space="preserve">
          <source>The result returned by the hook must be a method handle of exactly the same type as the call site.</source>
          <target state="translated">후크가 리턴 한 결과는 호출 사이트와 정확히 동일한 유형의 메소드 핸들이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ab16e8f218d193e2ac56d5cea7e3ab465621608f" translate="yes" xml:space="preserve">
          <source>The result set contains one row for each array element, with two columns in each row. The second column stores the element value; the first column stores the index into the array for that element (with the first array element being at index 1). The rows are in ascending order corresponding to the order of the indices.</source>
          <target state="translated">결과 집합에는 각 배열 요소에 대해 하나의 행이 포함되며 각 행에는 두 개의 열이 있습니다. 두 번째 열은 요소 값을 저장합니다. 첫 번째 열은 해당 요소의 배열에 색인을 저장합니다 (첫 번째 배열 요소는 색인 1에 있음). 행은 인덱스 순서에 따라 오름차순입니다.</target>
        </trans-unit>
        <trans-unit id="c7fbca7853e7e584b81e78e65665e66e2c6c2224" translate="yes" xml:space="preserve">
          <source>The result set has one row for each element of the SQL array designated by this object, with the first row containing the element at index &lt;code&gt;index&lt;/code&gt;. The result set has up to &lt;code&gt;count&lt;/code&gt; rows in ascending order based on the indices. Each row has two columns: The second column stores the element value; the first column stores the index into the array for that element.</source>
          <target state="translated">결과 집합에는이 개체가 지정한 SQL 배열의 각 요소에 대해 하나의 행이 있으며 첫 번째 행에는 index &lt;code&gt;index&lt;/code&gt; 의 요소가 포함 됩니다. 결과 집합에는 인덱스에 따라 오름차순으로 행 &lt;code&gt;count&lt;/code&gt; 있습니다. 각 행에는 두 개의 열이 있습니다. 두 번째 열에는 요소 값이 저장됩니다. 첫 번째 열은 해당 요소의 배열에 인덱스를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="59d025c7c37030729df1da6ef20378d1c89b991c" translate="yes" xml:space="preserve">
          <source>The result should use a conversion-dependent alternate form</source>
          <target state="translated">결과는 변환 종속 대체 양식을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="8f5827a90eb65856b4b89ffb933882240c216cc7" translate="yes" xml:space="preserve">
          <source>The result type of a &lt;a href=&quot;filevisitor&quot;&gt;&lt;code&gt;FileVisitor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;filevisitor&quot;&gt; &lt;code&gt;FileVisitor&lt;/code&gt; &lt;/a&gt; 의 결과 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2d7644c465280fb43e327f5847a1469aaa7aec19" translate="yes" xml:space="preserve">
          <source>The result will always include a sign</source>
          <target state="translated">결과는 항상 부호를 포함합니다</target>
        </trans-unit>
        <trans-unit id="c5f0ab9813b2497b6aace9d0a659cb51a7b9e650" translate="yes" xml:space="preserve">
          <source>The result will be left-justified.</source>
          <target state="translated">결과는 왼쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5cd03f8040d572a14698fa4790b45d2dea79538f" translate="yes" xml:space="preserve">
          <source>The result will be null if it is called on the root Logger in the namespace.</source>
          <target state="translated">네임 스페이스의 루트 로거에서 호출 된 경우 결과는 null입니다.</target>
        </trans-unit>
        <trans-unit id="eebffb3b7f508dfd870235eaedb8bd617c34fb42" translate="yes" xml:space="preserve">
          <source>The result will be zero-padded</source>
          <target state="translated">결과는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="ac5d38a04d258f50b2e728006d792d84ec797c12" translate="yes" xml:space="preserve">
          <source>The result will enclose negative numbers in parentheses</source>
          <target state="translated">결과는 괄호 안에 음수를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="b60dbdb0c739a0db71280a2d5057407b2907dcbf" translate="yes" xml:space="preserve">
          <source>The result will include a leading space for positive values</source>
          <target state="translated">결과는 양수 값을위한 선행 공간을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="99b73d58b5f8e32d7a839a384b8c3e4612121e9f" translate="yes" xml:space="preserve">
          <source>The result will include locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;grouping separators&lt;/a&gt;</source>
          <target state="translated">결과에는 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;그룹화 구분 기호&lt;/a&gt; 가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="86565ee42252b8d90b6fc4f6a7e56b8ff7846015" translate="yes" xml:space="preserve">
          <source>The result will include locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separators&lt;/a&gt;</source>
          <target state="translated">결과는 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;그룹 구분 기호를 포함합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da36d6b79c4c033f7a27b28c533a4819c6e58026" translate="yes" xml:space="preserve">
          <source>The resultant byte array</source>
          <target state="translated">결과 바이트 배열</target>
        </trans-unit>
        <trans-unit id="094bc7c12af1c9c170e626d26c061113ab22168d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Class&lt;/code&gt; object</source>
          <target state="translated">결과 &lt;code&gt;Class&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="776a2beb758c091693ee57d4a8d599511a9379bd" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Class&lt;/code&gt; object, or &lt;code&gt;null&lt;/code&gt; if the class could not be found.</source>
          <target state="translated">결과 &lt;code&gt;Class&lt;/code&gt; 객체 . 클래스를 찾을 수없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04d7e541442907c4718e4aa6df8cb95ea6facb8b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Path&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;Path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d9cee928349ecad8207afb80abfb3ac1e49b7c6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;String&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9c998e00f65f9ad466e49086e9abcbd51c428c9" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Version&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;Version&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2eb30aecd9ce3fd342fd1fb862917adbede7e62" translate="yes" xml:space="preserve">
          <source>The resulting Class object.</source>
          <target state="translated">결과 Class 객체.</target>
        </trans-unit>
        <trans-unit id="64fd0e638650ed8a264bb09d0464e8bdf66b1c52" translate="yes" xml:space="preserve">
          <source>The resulting URI</source>
          <target state="translated">결과 URI</target>
        </trans-unit>
        <trans-unit id="f09e99077085a93a3362b510af059c6626ecc325" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed as if by invoking the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor and then invoking the &lt;a href=&quot;#parseServerAuthority()&quot;&gt;&lt;code&gt;parseServerAuthority()&lt;/code&gt;&lt;/a&gt; method upon the result; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">결과 URI 문자열은 &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출 한 다음 결과에 대해 &lt;a href=&quot;#parseServerAuthority()&quot;&gt; &lt;code&gt;parseServerAuthority()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하는 것처럼 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7419fc69db0c5232d5bde59115b8e8bbc2a129ee" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed as if by invoking the &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor and then invoking the &lt;a href=&quot;uri#parseServerAuthority--&quot;&gt;&lt;code&gt;parseServerAuthority()&lt;/code&gt;&lt;/a&gt; method upon the result; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">결과 URI 문자열은 마치 &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출 한 다음 결과에 따라 &lt;a href=&quot;uri#parseServerAuthority--&quot;&gt; &lt;code&gt;parseServerAuthority()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것처럼 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0092d38cbcba375e121b4dfada28b43109355f6" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed in order to create the new URI instance as if by invoking the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">결과 URI 문자열은 마치 &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출하는 것처럼 새 URI 인스턴스를 만들기 위해 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a50f9807a1fa543061a71bf50d779ccfe528067" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed in order to create the new URI instance as if by invoking the &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">&lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출하는 것처럼 새 URI 인스턴스를 작성하기 위해 결과 URI 문자열이 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1cbbe9ae02dde33f88ed9dbc263ec8e5ac65206" translate="yes" xml:space="preserve">
          <source>The resulting adapter is the same type as the target, except that the first parameter type is dropped, if it corresponds to the result of the combiner.</source>
          <target state="translated">결과 어댑터는 첫 번째 매개 변수 유형이 결합기의 결과에 해당하는 경우 삭제되는 것을 제외하고 대상과 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0492a8e1954857252e9e87bc20c1aba15bfe6e4d" translate="yes" xml:space="preserve">
          <source>The resulting arc begins at &lt;code&gt;startAngle&lt;/code&gt; and extends for &lt;code&gt;arcAngle&lt;/code&gt; degrees, using the current color. Angles are interpreted such that 0 degrees is at the 3 o'clock position. A positive value indicates a counter-clockwise rotation while a negative value indicates a clockwise rotation.</source>
          <target state="translated">결과 호는 &lt;code&gt;startAngle&lt;/code&gt; 에서 시작 하여 현재 색상을 사용하여 &lt;code&gt;arcAngle&lt;/code&gt; 각도로 확장됩니다 . 각도는 0 도가 3시 위치에 있도록 해석됩니다. 양수 값은 시계 반대 방향 회전을 나타내고 음수 값은 시계 방향 회전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="43e6530ff8fe5ba50d8fda3e44fc6556cf949d6b" translate="yes" xml:space="preserve">
          <source>The resulting arc begins at &lt;code&gt;startAngle&lt;/code&gt; and extends for &lt;code&gt;arcAngle&lt;/code&gt; degrees. Angles are interpreted such that 0 degrees is at the 3 o'clock position. A positive value indicates a counter-clockwise rotation while a negative value indicates a clockwise rotation.</source>
          <target state="translated">결과 호는 &lt;code&gt;startAngle&lt;/code&gt; 에서 시작하여 &lt;code&gt;arcAngle&lt;/code&gt; 각도로 확장됩니다 . 각도는 0 도가 3시 위치에 있도록 해석됩니다. 양수 값은 시계 반대 방향 회전을 나타내고 음수 값은 시계 방향 회전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f03fd98b1be6d4bac23f1b8c056fc776f2b93ba7" translate="yes" xml:space="preserve">
          <source>The resulting arc covers an area &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels wide by &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels tall.</source>
          <target state="translated">결과 호는 영역 &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 너비 x &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 높이를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6c786abb2aba329e942d81e1d06f1d11b97967b9" translate="yes" xml:space="preserve">
          <source>The resulting array is of exactly the same class as the original array.</source>
          <target state="translated">결과 배열은 원래 배열과 정확히 같은 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c5a1157b9f760855069d2f10df624ea637e64ca4" translate="yes" xml:space="preserve">
          <source>The resulting asynchronous channel group reuses a fixed number of threads. At any point, at most &lt;code&gt;nThreads&lt;/code&gt; threads will be active processing tasks that are submitted to handle I/O events and dispatch completion results for operations initiated on asynchronous channels in the group.</source>
          <target state="translated">결과 비동기 채널 그룹은 고정 된 수의 스레드를 재사용합니다. 어느 시점에서나 최대 &lt;code&gt;nThreads&lt;/code&gt; 스레드는 I / O 이벤트를 처리하고 그룹의 비동기 채널에서 시작된 작업에 대한 완료 결과를 디스패치하기 위해 제출되는 활성 처리 작업입니다.</target>
        </trans-unit>
        <trans-unit id="2e1c0df7b54fbf773f3c4b5bcdbc4bfa62115cb7" translate="yes" xml:space="preserve">
          <source>The resulting attribute has the set difference of its prior value set and the specified value set. If no values are specified, deletes the entire attribute. If the attribute does not exist, or if some or all members of the specified value set do not exist, this absence may be ignored and the operation succeeds, or a NamingException may be thrown to indicate the absence. Removal of the last value will remove the attribute if the attribute is required to have at least one value.</source>
          <target state="translated">결과 속성에는 이전 값 세트와 지정된 값 세트의 차이가 설정됩니다. 값을 지정하지 않으면 전체 속성을 삭제합니다. 속성이 존재하지 않거나 지정된 값 세트의 일부 또는 모든 멤버가 존재하지 않으면이 부재가 무시되고 조작이 성공하거나 부재를 표시하기 위해 NamingException이 발생 될 수 있습니다. 속성에 하나 이상의 값이 필요한 경우 마지막 값을 제거하면 속성이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8b051c029a9cb257557ce55a86701099f33ad0" translate="yes" xml:space="preserve">
          <source>The resulting channel is associated with default thread pool to which tasks are submitted to handle I/O events and dispatch to completion handlers that consume the result of asynchronous operations performed on the resulting channel.</source>
          <target state="translated">결과 채널은 I / O 이벤트를 처리하고 결과 채널에서 수행 된 비동기 작업의 결과를 사용하는 완료 핸들러로 디스패치하기 위해 태스크가 제출되는 기본 스레드 풀과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="2e0477159a435eb4c7b6e87913d4947dad931600" translate="yes" xml:space="preserve">
          <source>The resulting channel will not be buffered; it will simply redirect its I/O operations to the given stream. Closing the channel will in turn cause the stream to be closed.</source>
          <target state="translated">결과 채널은 버퍼링되지 않습니다. 단순히 I / O 작업을 지정된 스트림으로 리디렉션합니다. 채널을 닫으면 스트림이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="2e7f4afa7fa2b1530937581bdba920189b54b7a0" translate="yes" xml:space="preserve">
          <source>The resulting context is for resolving URLs of the scheme &lt;code&gt;scheme&lt;/code&gt;. The resulting context is not tied to a specific URL. It is able to handle arbitrary URLs with the specified scheme.</source>
          <target state="translated">결과 컨텍스트는 체계 &lt;code&gt;scheme&lt;/code&gt; URL을 확인하기위한 것 입니다. 결과 컨텍스트는 특정 URL에 연결되지 않습니다. 지정된 체계로 임의의 URL을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b4ed36145c18184a4c0192876b36f57186eb11b9" translate="yes" xml:space="preserve">
          <source>The resulting file attribute view can be used to read or update the attributes of file in this directory. The &lt;code&gt;type&lt;/code&gt; parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; always returns an instance of that class that is bound to the file in the directory.</source>
          <target state="translated">결과 파일 속성보기를 사용하여이 디렉토리에서 파일의 속성을 읽거나 업데이트 할 수 있습니다. &lt;code&gt;type&lt;/code&gt; 파라미터 속성보기 유형을 지정하고 지원하는 경우에있어서 그 타입의 인스턴스를 리턴한다. &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 를 얻기 위해이 메소드를 호출하면 항상 디렉토리의 파일에 바인드 된 해당 클래스의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d791ce15a89946bb449aad309d10e2028011d0e0" translate="yes" xml:space="preserve">
          <source>The resulting file attribute view can be used to read or update the attributes of this (open) directory. The &lt;code&gt;type&lt;/code&gt; parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; always returns an instance of that class that is bound to this open directory.</source>
          <target state="translated">결과 파일 속성보기를 사용하여이 (열린) 디렉토리의 속성을 읽거나 업데이트 할 수 있습니다. &lt;code&gt;type&lt;/code&gt; 파라미터 속성보기 유형을 지정하고 지원하는 경우에있어서 그 타입의 인스턴스를 리턴한다. &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 를 얻기 위해이 메소드를 호출하면 항상이 열린 디렉토리에 바인드 된 해당 클래스의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1c0268e4ebd731468a02d197d2029a7d6d6cfbfc" translate="yes" xml:space="preserve">
          <source>The resulting file names must match exactly as strings with their occurrences in the JAR file.</source>
          <target state="translated">결과 파일 이름은 JAR 파일에서 발생하는 문자열과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d48fd783d3474da2a240f1521be0f07a0215d13" translate="yes" xml:space="preserve">
          <source>The resulting filter performs the limit checks and then tries to match the class, if any. If any of the limits are exceeded, the filter returns &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt;&lt;code&gt;Status.REJECTED&lt;/code&gt;&lt;/a&gt;. If the class is an array type, the class to be matched is the element type. Arrays of any number of dimensions are treated the same as the element type. For example, a pattern of &quot;&lt;code&gt;!example.Foo&lt;/code&gt;&quot;, rejects creation of any instance or array of &lt;code&gt;example.Foo&lt;/code&gt;. The first pattern that matches, working from left to right, determines the &lt;a href=&quot;objectinputfilter.status#ALLOWED&quot;&gt;&lt;code&gt;Status.ALLOWED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt;&lt;code&gt;Status.REJECTED&lt;/code&gt;&lt;/a&gt; result. If the limits are not exceeded and no pattern matches the class, the result is &lt;a href=&quot;objectinputfilter.status#UNDECIDED&quot;&gt;&lt;code&gt;Status.UNDECIDED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 필터는 제한 검사를 수행 한 다음 클래스 일치를 시도합니다 (있는 경우). 한도를 초과하면 필터는 &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt; &lt;code&gt;Status.REJECTED&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 클래스가 배열 유형 인 경우 일치 할 클래스는 요소 유형입니다. 모든 차원의 배열은 요소 유형과 동일하게 처리됩니다. 예를 들어, &quot;패턴 &lt;code&gt;!example.Foo&lt;/code&gt; &quot;의 인스턴스 또는 어레이의 제작 거부 &lt;code&gt;example.Foo&lt;/code&gt; 를 . 일치하는 첫 번째 패턴 (왼쪽에서 오른쪽으로 작동)은 &lt;a href=&quot;objectinputfilter.status#ALLOWED&quot;&gt; &lt;code&gt;Status.ALLOWED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt; &lt;code&gt;Status.REJECTED&lt;/code&gt; &lt;/a&gt; 결과를 결정합니다 . 한계를 초과하지 않고 클래스와 일치하는 패턴이없는 경우 결과는 &lt;a href=&quot;objectinputfilter.status#UNDECIDED&quot;&gt; &lt;code&gt;Status.UNDECIDED&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39b37f06bbf698636d93a2ea1a9e0ccaad0b21fe" translate="yes" xml:space="preserve">
          <source>The resulting formatted String will normally include a localized and formatted version of the LogRecord's message field. It is recommended to use the &lt;a href=&quot;#formatMessage(java.util.logging.LogRecord)&quot;&gt;&lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt;&lt;/a&gt; convenience method to localize and format the message field.</source>
          <target state="translated">결과 형식화 된 문자열에는 일반적으로 LogRecord 메시지 필드의 현지화 및 형식화 된 버전이 포함됩니다. &lt;a href=&quot;#formatMessage(java.util.logging.LogRecord)&quot;&gt; &lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt; &lt;/a&gt; 편의 메서드를 사용하여 메시지 필드를 지역화하고 형식을 지정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c1dd0222947bfa0316d9b432e87769219a094695" translate="yes" xml:space="preserve">
          <source>The resulting formatted String will normally include a localized and formatted version of the LogRecord's message field. It is recommended to use the &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt;&lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt;&lt;/a&gt; convenience method to localize and format the message field.</source>
          <target state="translated">결과 형식화 된 문자열에는 일반적으로 현지화 된 형식의 LogRecord 메시지 필드 버전이 포함됩니다. 메시지 필드를 현지화하고 형식화하려면 &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt; &lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt; &lt;/a&gt; 편의 메소드 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a440b10bec8baf92c276afc34bf461c3ea93f484" translate="yes" xml:space="preserve">
          <source>The resulting handle will have the same return type as the target handle.</source>
          <target state="translated">결과 핸들은 대상 핸들과 동일한 반환 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f9b393261c3425d386d8251817252af6f14e85a9" translate="yes" xml:space="preserve">
          <source>The resulting instance of the required type will respond to invocation of the type's uniquely named method by calling the given target on the incoming arguments, and returning or throwing whatever the target returns or throws. The invocation will be as if by &lt;code&gt;target.invoke&lt;/code&gt;. The target's type will be checked before the instance is created, as if by a call to &lt;code&gt;asType&lt;/code&gt;, which may result in a &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.</source>
          <target state="translated">필요한 형식의 결과 인스턴스는 들어오는 인수에서 지정된 대상을 호출하고 대상이 반환하거나 던지는 모든 것을 반환하거나 던져서 형식의 고유 한 명명 된 메서드 호출에 응답합니다. &lt;code&gt;target.invoke&lt;/code&gt; 에 의한 호출이됩니다 . 인스턴스가 생성되기 전에 목표의 유형 것처럼 호출하여 체크한다 &lt;code&gt;asType&lt;/code&gt; A의 발생할 수 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de4b752490153330ced19eb1636ec25661fe14d" translate="yes" xml:space="preserve">
          <source>The resulting list is &lt;code&gt;[a, c, d, b, e]&lt;/code&gt;.</source>
          <target state="translated">결과 목록은 &lt;code&gt;[a, c, d, b, e]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c292f8233ecc218c4ef8e408a4e751545e0593e6" translate="yes" xml:space="preserve">
          <source>The resulting list would contain &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;&quot;def&quot;&lt;/code&gt;, the empty string, and &lt;code&gt;&quot;ghi&quot;&lt;/code&gt;.</source>
          <target state="translated">결과 목록에는 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , &lt;code&gt;&quot;def&quot;&lt;/code&gt; , 빈 문자열 및 &lt;code&gt;&quot;ghi&quot;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="2678a315bb7b0ca19efcf39c01d949c69b6ab3c7" translate="yes" xml:space="preserve">
          <source>The resulting lookup's capabilities for loading classes (used during &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt;&lt;code&gt;findClass(java.lang.String)&lt;/code&gt;&lt;/a&gt; invocations) are determined by the lookup class' loader, which may change due to this operation.</source>
          <target state="translated">클래스를로드하기위한 결과 조회 기능 ( &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt; &lt;code&gt;findClass(java.lang.String)&lt;/code&gt; &lt;/a&gt; 호출 중에 사용됨 )은 조회 클래스의 로더에 의해 결정되며, 이는이 작업으로 인해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf2be7ac8c067fddb839990370820b0eb8d4e56d" translate="yes" xml:space="preserve">
          <source>The resulting loop handle's result type and parameter signature are determined as follows:</source>
          <target state="translated">결과 루프 핸들의 결과 유형 및 매개 변수 서명은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="1884f6b5e1183ba90dbd15f7cef2ddc5936af5e3" translate="yes" xml:space="preserve">
          <source>The resulting metadata object is only responsible for returning documents in the format named by &lt;code&gt;formatName&lt;/code&gt;. Within any documents that are returned, only nodes whose names are members of &lt;code&gt;nodeNames&lt;/code&gt; are required to be returned. In this way, the amount of metadata processing done by the reader may be kept to a minimum, based on what information is actually needed.</source>
          <target state="translated">결과 메타 데이터 개체는 &lt;code&gt;formatName&lt;/code&gt; 으로 명명 된 형식의 문서 만 반환합니다 . 리턴 된 문서 내에서 이름이 &lt;code&gt;nodeNames&lt;/code&gt; 의 구성원 인 노드 만 리턴 해야합니다. 이러한 방식으로, 판독기에 의해 수행되는 메타 데이터 처리량은 실제로 필요한 정보에 기초하여 최소로 유지 될 수있다.</target>
        </trans-unit>
        <trans-unit id="9c5c220cd80df632d39ecb3d8b6a70f850252346" translate="yes" xml:space="preserve">
          <source>The resulting period will be day-based, with the amount of days equal to the number of weeks multiplied by 7. The years and months units will be zero.</source>
          <target state="translated">결과 기간은 일 수를 기준으로하며 일 수는 주 수에 7을 곱한 값입니다. 연도 및 월 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="a6b95edf4e81e9e6b6619e37b7ddbb8faf120000" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified days. The years and months units will be zero.</source>
          <target state="translated">결과 기간에는 지정된 요일이 있습니다. 연도 및 월 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="9ed86d9dd063303868aa5b67521032ff19d3dd44" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified months. The years and days units will be zero.</source>
          <target state="translated">결과 기간에는 지정된 월이 있습니다. 년과 일 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="29d3631062d098fb17c4652fb16c3cf33dfe26c4" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified years. The months and days units will be zero.</source>
          <target state="translated">결과 기간은 지정된 연도입니다. 월 및 일 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="95444b5a8c83dcd2572f1e1d42e1076adc4c44ce" translate="yes" xml:space="preserve">
          <source>The resulting proxy class must not exceed any limits imposed on classes by the virtual machine. For example, the VM may limit the number of interfaces that a class may implement to 65535; in that case, the size of the &lt;code&gt;interfaces&lt;/code&gt; array must not exceed 65535.</source>
          <target state="translated">결과 프록시 클래스는 가상 머신에 의해 클래스에 부과 된 제한을 초과 할 수 없습니다. 예를 들어, VM은 클래스가 구현할 수있는 인터페이스 수를 65535로 제한 할 수 있습니다. 이 경우, 크기 &lt;code&gt;interfaces&lt;/code&gt; 배열 65535을 초과하지 않아야한다.</target>
        </trans-unit>
        <trans-unit id="6387f721ca72aada5ca623b823df6496720b727a" translate="yes" xml:space="preserve">
          <source>The resulting reader will start reading at the given &lt;code&gt;offset&lt;/code&gt;. The total number of &lt;code&gt;char&lt;/code&gt; values that can be read from this reader will be either &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;buf.length-offset&lt;/code&gt;, whichever is smaller.</source>
          <target state="translated">결과 판독기는 주어진 &lt;code&gt;offset&lt;/code&gt; 에서 읽기 시작 합니다. 이 리더에서 읽을 수있는 총 &lt;code&gt;char&lt;/code&gt; 값 수는 &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;buf.length-offset&lt;/code&gt; 중 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="913ac6b499d59e4b63e4cdaa10016b85296c4fef" translate="yes" xml:space="preserve">
          <source>The resulting region is then subsampled according to the factors given in &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;. The first pixel, the number of pixels per row, and the number of rows all depend on the subsampling settings. Call the minimum X and Y coordinates of the resulting rectangle (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;), its width &lt;code&gt;w&lt;/code&gt; and its height &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">그런 다음 결과 영역은 &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 제공된 요소에 따라 서브 샘플링됩니다 . 첫 번째 픽셀, 행당 픽셀 수 및 행 수는 모두 서브 샘플링 설정에 따라 다릅니다. 결과 사각형 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; ), 너비 &lt;code&gt;w&lt;/code&gt; 및 높이 &lt;code&gt;h&lt;/code&gt; 의 최소 ​​X 및 Y 좌표를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf284259891b966795d0320eaa89a9efa9f184a" translate="yes" xml:space="preserve">
          <source>The resulting region is then subsampled according to the factors given in &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;. The first pixel, the number of pixels per row, and the number of rows all depend on the subsampling settings. Call the minimum X and Y coordinates of the resulting rectangle (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;), its width &lt;code&gt;w&lt;/code&gt; and its height &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">결과 영역은 &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 주어진 요소에 따라 서브 샘플링됩니다 . 첫 번째 픽셀, 행당 픽셀 수 및 행 수는 모두 서브 샘플링 설정에 따라 다릅니다. 결과 사각형의 최소 X 및 Y 좌표 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; ), 너비 &lt;code&gt;w&lt;/code&gt; 및 높이 &lt;code&gt;h&lt;/code&gt; 를호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a3bd1f6e9cb9121d8ce0c043ff1f95fd3d713991" translate="yes" xml:space="preserve">
          <source>The resulting schema contains components from the specified sources. The same result would be achieved if all these sources were imported, using appropriate values for schemaLocation and namespace, into a single schema document with a different targetNamespace and no components of its own, if the import elements were given in the same order as the sources. Section 4.2.3 of the XML Schema recommendation describes the options processors have in this regard. While a processor should be consistent in its treatment of JAXP schema sources and XML Schema imports, the behaviour between JAXP-compliant parsers may vary; in particular, parsers may choose to ignore all but the first &lt;code&gt;&amp;lt;import&amp;gt;&lt;/code&gt; for a given namespace, regardless of information provided in schemaLocation.</source>
          <target state="translated">결과 스키마에는 지정된 소스의 구성 요소가 포함됩니다. 이러한 모든 소스를 schemaLocation 및 네임 스페이스에 대한 적절한 값을 사용하여 다른 targetNamespace를 사용하고 자체 구성 요소가없는 단일 스키마 문서로 가져온 경우 동일한 결과를 얻을 수 있습니다. . XML 스키마 권장 사항의 섹션 4.2.3에서는 프로세서가 이와 관련하여 갖는 옵션을 설명합니다. 프로세서는 JAXP 스키마 소스 및 XML 스키마 가져 오기를 처리 할 때 일관성이 있어야하지만 JAXP 호환 파서 간의 동작은 다를 수 있습니다. 특히 파서는 schemaLocation에 제공된 정보에 관계없이 주어진 네임 스페이스에 대한 첫 번째 &lt;code&gt;&amp;lt;import&amp;gt;&lt;/code&gt; 를 제외한 모든 것을 무시하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5fb5a6cf150b79c1760d1a0a2b75c334f95c52c" translate="yes" xml:space="preserve">
          <source>The resulting sequence may be empty if the &lt;code&gt;hasNext&lt;/code&gt; predicate does not hold on the seed value. Otherwise the first element will be the supplied &lt;code&gt;seed&lt;/code&gt; value, the next element (if present) will be the result of applying the &lt;code&gt;next&lt;/code&gt; function to the &lt;code&gt;seed&lt;/code&gt; value, and so on iteratively until the &lt;code&gt;hasNext&lt;/code&gt; predicate indicates that the stream should terminate.</source>
          <target state="translated">&lt;code&gt;hasNext&lt;/code&gt; 술어가 시드 값을 보유하지 않는 경우 결과 시퀀스는 비어있을 수 있습니다 . 그렇지 않으면 첫 번째 요소는 제공된 &lt;code&gt;seed&lt;/code&gt; 값이되고, 다음 요소 (있는 경우)는 &lt;code&gt;seed&lt;/code&gt; 값에 &lt;code&gt;next&lt;/code&gt; 함수를 적용한 결과 가됩니다. &lt;code&gt;hasNext&lt;/code&gt; 술어가 스트림이 종료되어야 함을 나타낼 때까지 반복적으로 계속 됩니다.</target>
        </trans-unit>
        <trans-unit id="59cf2006f3357a0978267c2dafbd40a8eb21f662" translate="yes" xml:space="preserve">
          <source>The resulting stream is sequential and ordered. All stream elements are non-null.</source>
          <target state="translated">결과 스트림은 순차적이고 순서가 지정됩니다. 모든 스트림 요소는 널이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fc6e671adbb8a182924f1ac35bcd56e979e41944" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal input buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;read&lt;/code&gt; methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered, and it will not support the &lt;a href=&quot;../../io/reader#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/reader#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">결과 스트림에는 최소 &lt;code&gt;minBufferCap&lt;/code&gt; 바이트 의 내부 입력 버퍼가 포함 됩니다. 스트림의 &lt;code&gt;read&lt;/code&gt; 메서드는 필요에 따라 기본 채널에서 바이트를 읽어 버퍼를 채 웁니다. 바이트를 읽을 때 채널이 비 차단 모드이면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 결과 스트림은 그렇지 않으면 버퍼링되지 않으며 &lt;a href=&quot;../../io/reader#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/reader#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를 지원하지 않습니다 . 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7927acc85bf7485dc11e63b36c81bfd277412443" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal input buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;read&lt;/code&gt; methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered, and it will not support the &lt;a href=&quot;../../io/reader#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/reader#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">생성 된 스트림은 적어도 내부 입력 버퍼 포함 &lt;code&gt;minBufferCap&lt;/code&gt; 가 바이트. 스트림의 &lt;code&gt;read&lt;/code&gt; 방법은, 필요에 따라 기본 채널의 바이트를 판독하여 버퍼를 채울 것이다; 채널은 다음 바이트가 판독 할 때 비 블록 모드에 있으면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 발생한다. 생성 된 스트림은 별도로 버퍼되지 않고,지지되지 &lt;a href=&quot;../../io/reader#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/reader#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 방법. 스트림을 닫는 것은 채널 원인 차례로 폐쇄 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d580035bd2b566457432a5e4d925677447d221a" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal output buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;write&lt;/code&gt; methods will, as needed, flush the buffer by writing bytes to the underlying channel; if the channel is in non-blocking mode when bytes are to be written then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">결과 스트림에는 최소한 &lt;code&gt;minBufferCap&lt;/code&gt; 바이트 의 내부 출력 버퍼가 포함 됩니다. 스트림의 &lt;code&gt;write&lt;/code&gt; 메소드는 필요에 따라 기본 채널에 바이트를 써서 버퍼를 플러시합니다. 바이트를 쓸 때 채널이 비 블로킹 모드에 있으면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 그렇지 않으면 결과 스트림이 버퍼링되지 않습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b5709861225c7ba3b6865800d13497f86bd85df6" translate="yes" xml:space="preserve">
          <source>The resulting string</source>
          <target state="translated">결과 문자열</target>
        </trans-unit>
        <trans-unit id="7323183be989f820aa6475e0d8caa99ce479a4fb" translate="yes" xml:space="preserve">
          <source>The resulting string may vary depending on the platform's default encoding.</source>
          <target state="translated">결과 문자열은 플랫폼의 기본 인코딩에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec362e72494de8b3c1c872dc58fe0a8f261890f" translate="yes" xml:space="preserve">
          <source>The resulting string may vary depending on the platform's default encoding. Instead, use the decode(String,String) method to specify the encoding.</source>
          <target state="translated">결과 문자열은 플랫폼의 기본 인코딩에 따라 달라질 수 있습니다. 대신 decode (String, String) 메서드를 사용하여 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b48d31f1fb8209f2d9205d68efebbcc7c9cbd82b" translate="yes" xml:space="preserve">
          <source>The resulting string may vary depending on the platform's default encoding. Instead, use the encode(String,String) method to specify the encoding.</source>
          <target state="translated">결과 문자열은 플랫폼의 기본 인코딩에 따라 달라질 수 있습니다. 대신 encode (String, String) 메서드를 사용하여 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0242c011bc55e1252b1407ded7fa2f64f005fdf7" translate="yes" xml:space="preserve">
          <source>The resulting value for these property will be stored in the LogManager properties, but &lt;code&gt;updateConfiguration&lt;/code&gt; will not parse or process their values.</source>
          <target state="translated">이러한 속성의 결과 값은 LogManager 속성에 저장되지만 &lt;code&gt;updateConfiguration&lt;/code&gt; 은 해당 값을 구문 분석하거나 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74bf552fafa0986a788039357cfc15a0f6c622fd" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable and its use is generally not recommended; see the notes under the &lt;a href=&quot;#%3Cinit%3E(double)&quot;&gt;&lt;code&gt;BigDecimal(double)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없으며 일반적으로 사용하지 않는 것이 좋습니다. &lt;a href=&quot;#%3Cinit%3E(double)&quot;&gt; &lt;code&gt;BigDecimal(double)&lt;/code&gt; &lt;/a&gt; 생성자 아래의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65db06e467299c29537ab9336bf47bbbf5cdbd84" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable and its use is generally not recommended; see the notes under the &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt;&lt;code&gt;BigDecimal(double)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없으며 일반적으로 사용하지 않는 것이 좋습니다. &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt; &lt;code&gt;BigDecimal(double)&lt;/code&gt; &lt;/a&gt; 생성자 아래의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbb3bb7280c618deda0717f345ca0d0a3e5a617a" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable. One might assume that writing &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; in Java creates a &lt;code&gt;BigDecimal&lt;/code&gt; which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a &lt;code&gt;double&lt;/code&gt; (or, for that matter, as a binary fraction of any finite length). Thus, the value that is being passed</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없습니다. 하나는 쓰는 것을 가정 할 수 &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; 자바 것은 생성 &lt;code&gt;BigDecimal&lt;/code&gt; (1의 규모로, 1의 스케일 없음의 값) 0.1 정확하게 일치이지만, 실제로 0.1000000000000000055511151231257827021181583404541015625 같음. 이는 0.1을 정확히 &lt;code&gt;double&lt;/code&gt; 로 표현할 수 없기 때문입니다 (또는이 문제의 경우 유한 길이의 이진 분수). 따라서 전달되는 가치</target>
        </trans-unit>
        <trans-unit id="a60e1eda493280339b2d07bf3ec089112f276d07" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable. One might assume that writing &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; in Java creates a &lt;code&gt;BigDecimal&lt;/code&gt; which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a &lt;code&gt;double&lt;/code&gt; (or, for that matter, as a binary fraction of any finite length). Thus, the value that is being passed &lt;em&gt;in&lt;/em&gt; to the constructor is not exactly equal to 0.1, appearances notwithstanding.</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없습니다. 하나는 쓰는 것을 가정 할 수 &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; 자바 것은 생성 &lt;code&gt;BigDecimal&lt;/code&gt; (1의 규모로, 1의 스케일 없음의 값) 0.1 정확하게 일치이지만, 실제로 0.1000000000000000055511151231257827021181583404541015625 같음. 0.1은 정확히 &lt;code&gt;double&lt;/code&gt; 로 표현할 수 없기 때문입니다 (또는 유한 길이의 이진 분수 로 표현할 수 없습니다 ). 따라서, 전달되는 값 &lt;em&gt;에&lt;/em&gt; 생성자 0.1, 외관에도 불구하고 정확하게 동일하지 않다.</target>
        </trans-unit>
        <trans-unit id="93760e92a1fc812ab19b0ed28984ff85fa220322" translate="yes" xml:space="preserve">
          <source>The results only need to be adjusted if they are to be stored back into a destination buffer that holds data that is not premultiplied, using the following equations:</source>
          <target state="translated">결과는 다음 방정식을 사용하여 미리 곱해지지 않은 데이터를 보유하는 대상 버퍼에 다시 저장되는 경우에만 조정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7164f77665270f67e8f397eca3785e4e6b5066" translate="yes" xml:space="preserve">
          <source>The results should be the same as obtaining all the &lt;code&gt;PrintServices&lt;/code&gt; and querying each one individually on its support for the specified attributes and flavors, but the process can be more efficient by taking advantage of the capabilities of lookup services for the print services.</source>
          <target state="translated">결과는 모든 &lt;code&gt;PrintServices&lt;/code&gt; 를 얻고 지정된 속성 및 특징에 대한 지원에 대해 개별적으로 쿼리 하는 것과 동일해야 하지만 인쇄 서비스에 대한 조회 서비스 기능을 활용하면 프로세스가 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b26f2b5e9e76c38d5206ceaa707fac001defe0" translate="yes" xml:space="preserve">
          <source>The results should be the same as obtaining all the PrintServices and querying each one individually on its support for the specified attributes and flavors, but the process can be more efficient by taking advantage of the capabilities of lookup services for the print services.</source>
          <target state="translated">결과는 모든 PrintService를 가져 와서 지정된 속성 및 특징에 대한 지원에 대해 각각 개별적으로 쿼리하는 것과 동일해야하지만 인쇄 서비스에 대한 조회 서비스 기능을 활용하면 프로세스가 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3cf3e1fd73a22414ddca5e3fb189a104cf44e85" translate="yes" xml:space="preserve">
          <source>The retransformation may change method bodies, the constant pool and attributes (unless explicitly prohibited). The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. The retransformation must not change the &lt;code&gt;NestHost&lt;/code&gt; or &lt;code&gt;NestMembers&lt;/code&gt; attributes. These restrictions may be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재 변환은 메서드 본문, 상수 풀 및 속성을 변경할 수 있습니다 (명시 적으로 금지되지 않는 한). 재 변환은 필드 또는 메서드를 추가, 제거 또는 이름 변경하거나 메서드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 재 변환은 &lt;code&gt;NestHost&lt;/code&gt; 또는 &lt;code&gt;NestMembers&lt;/code&gt; 속성을 변경해서는 안됩니다 . 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 클래스 파일 바이트는 변환이 적용될 때까지 검사, 확인 및 설치되지 않으며 결과 바이트에 오류가있는 경우이 메서드는 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="2f2a2d456b1fe7f946cf6afcde99facfbb1b054d" translate="yes" xml:space="preserve">
          <source>The retransformation may change method bodies, the constant pool and attributes. The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재 변환은 메소드 본문, 상수 풀 및 속성을 변경할 수 있습니다. 재 변환은 필드 또는 메소드를 추가, 제거 또는 이름 변경하거나 메소드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 변환이 적용될 때까지 클래스 파일 바이트는 확인, 확인 및 설치되지 않습니다. 결과 바이트에 오류가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="62fd7b2e815ada1d9ad838170833576f45e44251" translate="yes" xml:space="preserve">
          <source>The return of a &lt;code&gt;false&lt;/code&gt; value for a given access mode indicates that an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is thrown on invocation of the corresponding access mode method.</source>
          <target state="translated">주어진 액세스 모드에 대해 &lt;code&gt;false&lt;/code&gt; 값 이 반환 되면 해당 액세스 모드 메서드 호출시 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 throw 됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ca960eb615ad53bc0b3135b373d2036434995b22" translate="yes" xml:space="preserve">
          <source>The return type Rt is void, or the return type Ra is not void and is adaptable to Rt</source>
          <target state="translated">반환 유형 Rt가 비어 있거나 반환 유형 Ra가 비어 있지 않으며 Rt에 적용 가능</target>
        </trans-unit>
        <trans-unit id="0a90f1198e5deb5b2534122b1f369aa219e8f116" translate="yes" xml:space="preserve">
          <source>The return type in &lt;code&gt;concatType&lt;/code&gt; is assignable from &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;concatType&lt;/code&gt; 의 반환 유형 은 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 에서 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa2e82a8911ac326301fece552df2e83f13bdc2" translate="yes" xml:space="preserve">
          <source>The return type in &lt;code&gt;concatType&lt;/code&gt; is assignable from &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, and matches the return type of the returned &lt;a href=&quot;methodhandle&quot;&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;concatType&lt;/code&gt; 의 반환 유형 은 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 에서 할당 할 수 있으며 반환 된 &lt;a href=&quot;methodhandle&quot;&gt; &lt;code&gt;MethodHandle&lt;/code&gt; &lt;/a&gt; 의 반환 유형과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="08c7dcac11b655355c8f407e5172d1bcf0c4208a" translate="yes" xml:space="preserve">
          <source>The return type is specified by a &lt;a href=&quot;../namespace/qname&quot;&gt;&lt;code&gt;QName&lt;/code&gt;&lt;/a&gt; parameter in method call used to evaluate the expression, which is either a call to &lt;code&gt;XPathExpression.evalute(...)&lt;/code&gt; or &lt;code&gt;XPath.evaluate(...)&lt;/code&gt; methods.</source>
          <target state="translated">반환 유형은 &lt;code&gt;XPathExpression.evalute(...)&lt;/code&gt; 또는 &lt;code&gt;XPath.evaluate(...)&lt;/code&gt; 메서드에 대한 호출 인 식을 평가하는 데 사용되는 메서드 호출 의 &lt;a href=&quot;../namespace/qname&quot;&gt; &lt;code&gt;QName&lt;/code&gt; &lt;/a&gt; 매개 변수에 의해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="92c09d015f75e8bee39bac035a68343e43b9f9d8" translate="yes" xml:space="preserve">
          <source>The return type of the filter replaces the return type of the target in the resulting adapted method handle. The argument type of the filter (if any) must be identical to the return type of the target.</source>
          <target state="translated">필터의 리턴 유형은 결과로 적용된 메소드 핸들에서 대상의 리턴 유형을 대체합니다. 필터의 인수 유형 (있는 경우)은 대상의 리턴 유형과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6a026e7ef017e49a86ae81d83b570e4f3b988ce" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;eval(Reader, ScriptContext)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval(Reader, ScriptContext)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="d250b67419c015be49448c5b2b4064b04039b13f" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;eval(String, ScriptContext)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval(String, ScriptContext)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="18c586324069b76d67cca48a59dcffb8f32f65de" translate="yes" xml:space="preserve">
          <source>The return value from the script execution</source>
          <target state="translated">스크립트 실행의 반환 값</target>
        </trans-unit>
        <trans-unit id="3e87c8c10ff310371a9f3d96d03e6c0bad31b37f" translate="yes" xml:space="preserve">
          <source>The return value here is a hint, it is ultimately up to the look and feel to honor the return value in some meaningful way.</source>
          <target state="translated">여기서 반환 값은 힌트이며 의미있는 방식으로 반환 값을 존중하는 것은 궁극적으로 모양과 느낌에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="339d740994f90a652ddcc5a1527a27502fd12e3d" translate="yes" xml:space="preserve">
          <source>The return value here is a hint, it is ultimately up to the look and feel to honor the return value in some meaningful way. For example, a look and feel may wish to render each &lt;code&gt;AbstractColorChooserPanel&lt;/code&gt; in a &lt;code&gt;JTabbedPane&lt;/code&gt;, and further use this return value to underline a character in the &lt;code&gt;getDisplayName&lt;/code&gt;.</source>
          <target state="translated">여기서 반환 값은 힌트이며 의미있는 방식으로 반환 값을 존중하는 것은 궁극적으로 모양과 느낌에 달려 있습니다. 예를 들어, 룩앤필 은 &lt;code&gt;JTabbedPane&lt;/code&gt; 에서 각 &lt;code&gt;AbstractColorChooserPanel&lt;/code&gt; 을 렌더링 하고이 반환 값을 추가로 사용하여 &lt;code&gt;getDisplayName&lt;/code&gt; 의 문자에 밑줄을 긋고 싶을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7e61cce8a603e1ed7dd41104b64452e72191f66" translate="yes" xml:space="preserve">
          <source>The return value indicates whether the deadline has elapsed, which can be used as follows:</source>
          <target state="translated">반환 값은 최종 기한이 지 났는지 여부를 나타내며 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b117098b5c546c14491ff8cf89569aadc8a2ea4" translate="yes" xml:space="preserve">
          <source>The return value is a constant for the lifetime of the implementing instance</source>
          <target state="translated">반환 값은 구현 인스턴스의 수명 동안 상수입니다.</target>
        </trans-unit>
        <trans-unit id="ef240b9287f693729ee8736cf3b50be17225bd35" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the column number in the document entity or external parsed entity where the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 열 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="1b239c60495bf8042c7d3c6cd2a1059554bfa5e2" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the column number in the document entity or external parsed entity where the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 열 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="8ffa6dc5a63793e0cd89ca59a2500e0682da449a" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the line number in the document entity or external parsed entity where the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 줄 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="df14b7af1f8f1168f052f357a4d4d570216b0e96" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the line number in the document entity or external parsed entity where the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 줄 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="57e62b909f604f540851de4e9220c29855a3c379" translate="yes" xml:space="preserve">
          <source>The return value is not intended to take into account the current size and position of &lt;code&gt;component2&lt;/code&gt; or &lt;code&gt;component1&lt;/code&gt;. The return value may take into consideration various properties of the components. For example, the space may vary based on font size, or the preferred size of the component.</source>
          <target state="translated">반환 값은 &lt;code&gt;component2&lt;/code&gt; 또는 &lt;code&gt;component1&lt;/code&gt; 의 현재 크기와 위치를 고려하지 않습니다 . 반환 값은 구성 요소의 다양한 속성을 고려할 수 있습니다. 예를 들어, 공간은 글꼴 크기 또는 구성 요소의 기본 크기에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6862bdbf23c8a75ce946b35c34fe4f5784a92cab" translate="yes" xml:space="preserve">
          <source>The return value is reassigned to the variable &lt;code&gt;y&lt;/code&gt;, because a new array will be allocated and returned if the collection &lt;code&gt;x&lt;/code&gt; has too many elements to fit into the existing array &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">컬렉션 &lt;code&gt;x&lt;/code&gt; 에 기존 배열 &lt;code&gt;y&lt;/code&gt; 에 맞지 않는 요소가 너무 많으면 새 배열이 할당되고 반환되므로 반환 값이 변수 &lt;code&gt;y&lt;/code&gt; 에 다시 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf5abc13dd7f11ea0e437763bb82152d9c9c44c6" translate="yes" xml:space="preserve">
          <source>The return value is the public identifier of the document entity or of the external parsed entity in which the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 공용 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="4eab4f2d235e9eb1c2ee1b4d56bb6a0656d5046f" translate="yes" xml:space="preserve">
          <source>The return value is the public identifier of the document entity or of the external parsed entity in which the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 공용 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="79298db5b9ecefcf08a93ac7001f8247745f88be" translate="yes" xml:space="preserve">
          <source>The return value is the same as the return value for getType(int).</source>
          <target state="translated">반환 값은 getType (int)의 반환 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ad228ac22a92c30a5a17bbe1cc5511d3e6d6efe6" translate="yes" xml:space="preserve">
          <source>The return value is the same as the return value for getValue(int).</source>
          <target state="translated">반환 값은 getValue (int)의 반환 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="305fb729cefceff62bd86eeab21b84fdfc657b36" translate="yes" xml:space="preserve">
          <source>The return value is the system identifier of the document entity or of the external parsed entity in which the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="157a1ea5a78e25b7b7edb134a522fe0ad73f0731" translate="yes" xml:space="preserve">
          <source>The return value is the system identifier of the document entity or of the external parsed entity in which the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="d5e42cb5bf57e4282c3a4431545a3164ae31c157" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;dispatchEvent&lt;/code&gt; indicates whether any of the listeners which handled the event called &lt;code&gt;preventDefault&lt;/code&gt;. If &lt;code&gt;preventDefault&lt;/code&gt; was called the value is false, else the value is true.</source>
          <target state="translated">&lt;code&gt;dispatchEvent&lt;/code&gt; 의 반환 값은 &lt;code&gt;preventDefault&lt;/code&gt; 라는 이벤트 를 처리 한 리스너가 있는지 여부를 나타냅니다 . 경우 &lt;code&gt;preventDefault&lt;/code&gt; 값 호출 된 다른 값이 true, false입니다.</target>
        </trans-unit>
        <trans-unit id="4219f41ab6bb669a3af2e1f70f85e439bc1d24f1" translate="yes" xml:space="preserve">
          <source>The return value of this method is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string is guaranteed to be parsable according to the grammar in the RFC.</source>
          <target state="translated">이 메소드의 리턴 값은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 컨텐츠 유형 값의 문자열 형식입니다 . RFC의 문법에 따라 문자열을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d6884c96ab13575074a3fd88c171169562433f" translate="yes" xml:space="preserve">
          <source>The return value will always meet this requirement. A request to read a number of bytes representing a non-integral number of sample frames cannot be fulfilled and may result in an IllegalArgumentException.</source>
          <target state="translated">반환 값은 항상이 요구 사항을 충족합니다. 비 적분 수의 샘플 프레임을 나타내는 다수의 바이트 읽기 요청은 이행 될 수 없으며 IllegalArgumentException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bab3d5729e7a670151bb1fa0f6d52b4a1a2b1601" translate="yes" xml:space="preserve">
          <source>The return value will always meet this requirement. A request to write a number of bytes representing a non-integral number of sample frames cannot be fulfilled and may result in an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">반환 값은 항상이 요구 사항을 충족합니다. 정수가 아닌 샘플 프레임을 나타내는 바이트 수 쓰기 요청을 이행 할 수 없으며 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb820cab50d0998d1ebde65dd99e143bc7773114" translate="yes" xml:space="preserve">
          <source>The return value will be a PageFormat equivalent to the selections in the PrintRequestAttributeSet. If the user cancels the dialog, the attributes will not reflect any changes made by the user, and the return value will be null.</source>
          <target state="translated">반환 값은 PrintRequestAttributeSet의 선택 항목에 해당하는 PageFormat입니다. 사용자가 대화 상자를 취소하면 속성은 사용자가 변경 한 내용을 반영하지 않으며 반환 값은 null이됩니다.</target>
        </trans-unit>
        <trans-unit id="7a1cb10291ece8ab0cb0d59c17a95c5985d00fc8" translate="yes" xml:space="preserve">
          <source>The return value will be one of &lt;a href=&quot;#INITIATE_ONLY&quot;&gt;&lt;code&gt;INITIATE_ONLY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ACCEPT_ONLY&quot;&gt;&lt;code&gt;ACCEPT_ONLY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#INITIATE_AND_ACCEPT&quot;&gt;&lt;code&gt;INITIATE_AND_ACCEPT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 값은 &lt;a href=&quot;#INITIATE_ONLY&quot;&gt; &lt;code&gt;INITIATE_ONLY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ACCEPT_ONLY&quot;&gt; &lt;code&gt;ACCEPT_ONLY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#INITIATE_AND_ACCEPT&quot;&gt; &lt;code&gt;INITIATE_AND_ACCEPT&lt;/code&gt; &lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="f6bfc96df054b19c8bae5f8772d6621a71f8e532" translate="yes" xml:space="preserve">
          <source>The return values of navigation methods may be ambiguous in implementations that permit &lt;code&gt;null&lt;/code&gt; elements. However, even in this case the result can be disambiguated by checking &lt;code&gt;contains(null)&lt;/code&gt;. To avoid such issues, implementations of this interface are encouraged to &lt;em&gt;not&lt;/em&gt; permit insertion of &lt;code&gt;null&lt;/code&gt; elements. (Note that sorted sets of &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; elements intrinsically do not permit &lt;code&gt;null&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 요소 를 허용하는 구현에서는 탐색 메서드의 반환 값이 모호 할 수 있습니다 . 그러나이 경우에도 &lt;code&gt;contains(null)&lt;/code&gt; 을 확인하여 결과를 명확하게 할 수 있습니다 . 이러한 문제를 피하기 위해이 인터페이스의 구현 은 &lt;code&gt;null&lt;/code&gt; 요소의 삽입을 허용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다 . 정렬 된 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 요소 세트는 본질적으로 &lt;code&gt;null&lt;/code&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c185003fa3929e25d997e006634131e9b1d47337" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to a resolved &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 모든 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 형식 을 지정하고 해결 된 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; 로&lt;/a&gt; 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="75a801763a5d854e8d95b623a5d3a94dcbfe58f1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to the type specified. The type must be one that is supported by &lt;a href=&quot;#parse(java.lang.CharSequence)&quot;&gt;&lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 의 형식을 지정하고 지정된 유형으로 구문 분석합니다. 유형은 &lt;a href=&quot;#parse(java.lang.CharSequence)&quot;&gt; &lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt; &lt;/a&gt; 지원하는 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4d4661665beda529a4501a1035be4de025066b7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to the type specified. The type must be one that is supported by &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-&quot;&gt;&lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 모든 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 의 형식을 지정하고 지정된 형식으로 구문 분석합니다. 유형은 &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-&quot;&gt; &lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt; &lt;/a&gt; 가 지원하는 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6130888b3d4f3e79271a0f0fd2b1121269c73460" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instance supports the same usages as do the &lt;a href=&quot;../../../lang/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt; monitor methods (&lt;a href=&quot;../../../lang/object#wait()&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../lang/object#notify()&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../../lang/object#notifyAll()&quot;&gt;&lt;code&gt;notifyAll&lt;/code&gt;&lt;/a&gt;) when used with the built-in monitor lock.</source>
          <target state="translated">반환 된 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 인스턴스는 기본 제공 모니터 잠금과 함께 사용할 때 &lt;a href=&quot;../../../lang/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 모니터 메서드 ( &lt;a href=&quot;../../../lang/object#wait()&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../lang/object#notify()&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../lang/object#notifyAll()&quot;&gt; &lt;code&gt;notifyAll&lt;/code&gt; &lt;/a&gt; ) 와 동일한 사용법을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5dd44d28dfbc6bc47cbc61187f37930a55da27" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instance supports the same usages as do the &lt;a href=&quot;../../../lang/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt; monitor methods (&lt;a href=&quot;../../../lang/object#wait--&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../lang/object#notify--&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../../lang/object#notifyAll--&quot;&gt;&lt;code&gt;notifyAll&lt;/code&gt;&lt;/a&gt;) when used with the built-in monitor lock.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 인스턴스는 내장 모니터 잠금과 함께 사용될 때 &lt;a href=&quot;../../../lang/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 모니터 메소드 ( &lt;a href=&quot;../../../lang/object#wait--&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../lang/object#notify--&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../lang/object#notifyAll--&quot;&gt; &lt;code&gt;notifyAll&lt;/code&gt; &lt;/a&gt; ) 와 동일한 사용법을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="903fab1dd6031a929646339ff8331ce972297982" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; object assumes that if documents refer to the same URL in the schema location hints, they will always resolve to the same schema document. This asusmption allows implementations to reuse parsed results of schema documents so that multiple validations against the same schema will run faster.</source>
          <target state="translated">반환 된 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; 개체는 문서가 스키마 위치 힌트에서 동일한 URL을 참조하는 경우 항상 동일한 스키마 문서로 확인된다고 가정합니다. 이러한 가정을 통해 구현에서 스키마 문서의 구문 분석 된 결과를 재사용 할 수 있으므로 동일한 스키마에 대한 여러 유효성 검사가 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1bdefa0087b8327c86ac80a033c0a312632ffe64" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;ActionMap&lt;/code&gt; contains &lt;code&gt;Actions&lt;/code&gt; that embody the ability to render an auditory cue. These auditory cues map onto user and system activities that may be useful for an end user to know about (such as a dialog box appearing).</source>
          <target state="translated">반환 된 &lt;code&gt;ActionMap&lt;/code&gt; 에는 청각 신호를 렌더링하는 기능을 구현하는 &lt;code&gt;Actions&lt;/code&gt; 이 포함 됩니다. 이러한 청각 신호는 최종 사용자가 알면 유용 할 수있는 사용자 및 시스템 활동 (예 : 대화 상자 표시)에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7d12400bfb4401dc47af91d14c791db925e333" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 를 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 삽입 할 필요가없는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc1730d912a2f1b769dce259c025673a7214e32" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시 적이 지 않습니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 삽입 될 필요가없는 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="455cc87f0f7a7b7d3bd10e8e76906fe2717f5568" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 를 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 할 필요가없는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce3945a38794bedbeea1ec896b627af457c67f5" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 를 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 할 필요가없는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt; &lt;/a&gt; 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7e9e01d3dfa3cb980421cf908b620f48d72c26" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 될 필요가없는 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43da3d7de62b7245f65cab710cfb2f032f89515e" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt; &lt;/a&gt; 사용 하면 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 될 필요가없는 경우 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57c6b99569016327c62bebb7ad77957c25e8eed6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting &lt;code&gt;Map&lt;/code&gt; collector is not required, using &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function)&quot;&gt;&lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 &lt;code&gt;Map&lt;/code&gt; 수집기 에 요소가 나타나는 순서 를 &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function)&quot;&gt; &lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt; &lt;/a&gt; 필요가없는 경우 groupingByConcurrent (Function)를 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cbd679a1ec8205268de13a97a9624457c2a964" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting &lt;code&gt;Map&lt;/code&gt; collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과 &lt;code&gt;Map&lt;/code&gt; 콜렉터 에 요소가 나타나는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt; &lt;/a&gt; 사용하면 병렬 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6ca58a5af4a56d396c6a6e708ba41db7d674a1" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 요소가 다운 스트림 수집기에 표시되는 순서를 &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt; &lt;/a&gt; 필요가없는 경우 groupingByConcurrent (Function, Supplier, Collector)를 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45a9fc109957eb2a04aabfd7fb897648b56499d3" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 요소가 다운 스트림 컬렉터에 표시되는 순서를 &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt; &lt;/a&gt; 필요가없는 경우 groupingByConcurrent (Function, Collector)를 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac6dd6552e8a0aeddbedc87ca5a64e77ba22719" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 다운 스트림 콜렉터에 요소가 표시되는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt; &lt;/a&gt; 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbaf8d671c4e4b5aa32fa0703a9603589a87b608" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시 적이 지 않습니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 요소가 다운 스트림 콜렉터에 표시되는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt; &lt;/a&gt; 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="592e2671cbce0f06db4108a4c9a20ac5ff26eb80" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following characteristics:</source>
          <target state="translated">반환 된 &lt;code&gt;DataFlavor&lt;/code&gt; 는 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="641ba86405285a860416ed87151b9ce572461645" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;HttpRequest&lt;/code&gt; may not be the initiating request provided when &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;sending&lt;/a&gt;. For example, if the initiating request was redirected, then the request returned by this method will have the redirected URI, which will be different from the initiating request URI.</source>
          <target state="translated">반환 된 &lt;code&gt;HttpRequest&lt;/code&gt; 는를&lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;보낼&lt;/a&gt; 때 제공된 시작 요청이 아닐 수 있습니다 . 예를 들어, 시작 요청이 리디렉션 된 경우이 메서드에서 반환 된 요청에는 시작 요청 URI와 다른 리디렉션 된 URI가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59f34697c17be29d15a67dae37118e8cb592e3b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Map&lt;/code&gt; always contains mappings for both &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the &lt;code&gt;Map&lt;/code&gt; returned.</source>
          <target state="translated">반환 된 &lt;code&gt;Map&lt;/code&gt; 에는 항상 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; 키에 대한 매핑이 포함 됩니다. 반환 된 &lt;code&gt;Map&lt;/code&gt; 의 유형, 변경 가능성, 직렬화 가능성 또는 스레드 안전성에 대한 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d858b7e7a502a697faadc883094465ade5ac1148" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Printable&lt;/code&gt; can be printed on any thread.</source>
          <target state="translated">반환 된 &lt;code&gt;Printable&lt;/code&gt; 은 모든 스레드에서 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3084584bbfa81c3dd9e5d128a1532aa3f6cd7c81" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Printable&lt;/code&gt; shares the &lt;code&gt;document&lt;/code&gt; with this &lt;code&gt;JTextComponent&lt;/code&gt;. It is the responsibility of the developer to ensure that the &lt;code&gt;document&lt;/code&gt; is not mutated while this &lt;code&gt;Printable&lt;/code&gt; is used. Printing behavior is undefined when the &lt;code&gt;document&lt;/code&gt; is mutated during printing.</source>
          <target state="translated">반환 된 &lt;code&gt;Printable&lt;/code&gt; 은이 &lt;code&gt;JTextComponent&lt;/code&gt; 와 &lt;code&gt;document&lt;/code&gt; 를 공유합니다 . 이 &lt;code&gt;Printable&lt;/code&gt; 이 사용되는 동안 &lt;code&gt;document&lt;/code&gt; 가 변경되지 않도록하는 것은 개발자의 책임입니다 . 인쇄 중에 &lt;code&gt;document&lt;/code&gt; 가 변경 되면 인쇄 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="22281dd911bd249a01a74dd9023a085760102f82" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Printable&lt;/code&gt; when printed, formats the document content appropriately for the page size. For correct line wrapping the &lt;code&gt;imageable width&lt;/code&gt; of all pages must be the same. See &lt;a href=&quot;../../../java/awt/print/pageformat#getImageableWidth()&quot;&gt;&lt;code&gt;PageFormat.getImageableWidth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Printable&lt;/code&gt; 될 때 반환 된 Printable 은 페이지 크기에 맞게 문서 내용의 형식을 지정합니다. 올바른 줄 바꿈을 위해 모든 페이지 의 &lt;code&gt;imageable width&lt;/code&gt; 가 동일해야합니다. &lt;a href=&quot;../../../java/awt/print/pageformat#getImageableWidth()&quot;&gt; &lt;code&gt;PageFormat.getImageableWidth()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25ddc39787057b4a5d98836cd1d91a3011cd8509" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject 내부의 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 의해 지원됩니다 . 반환에 대한 모든 변경 &lt;code&gt;Set&lt;/code&gt; 내부에 영향을 미치는 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 은 물론입니다.</target>
        </trans-unit>
        <trans-unit id="5d4e1626c242857a248f0940fc4963421f11cce0" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal private Credential &lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal private Credential &lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 비공개 자격 &lt;code&gt;Set&lt;/code&gt; 의해 지원됩니다 . 반환 된 &lt;code&gt;Set&lt;/code&gt; 을 수정 하면 내부 개인 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="92eab9cfd3076bb306b67853f4acd835335f8a36" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal public Credential &lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal public Credential &lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 공개 자격 &lt;code&gt;Set&lt;/code&gt; 의해 지원됩니다 . 반환 된 &lt;code&gt;Set&lt;/code&gt; 을 수정 하면 내부 공개 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="615020d8b91ea3150d89b8eb5df521518f2bf0e3" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject 내부의 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 에 대한 수정 은 내부 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60e6e37a29504c686a29d93cf1b8a805cadab51b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal private Credential &lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal private Credential &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 비공개 자격 &lt;code&gt;Set&lt;/code&gt; 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 수정 해도 내부 개인 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4a692bd81d1139698e9955f1301dc1ea4476c6cb" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal public Credential &lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal public Credential &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 공개 자격 &lt;code&gt;Set&lt;/code&gt; 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 수정 해도 내부 공개 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ee6fed903cbcc5abb5de7f51ad1081371937c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;SourceDataLine&lt;/code&gt;'s default audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;SourceDataLine&lt;/code&gt; 의 기본 오디오 형식은 형식으로 초기화 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10e5de58fd5281c7858b3f0d4c85924e449e2f2d" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TargetDataLine&lt;/code&gt;'s default audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;TargetDataLine&lt;/code&gt; 의 기본 오디오 형식은 형식으로 초기화 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5203d861af68a72a81fc4a8395381f4dbaed35cd" translate="yes" xml:space="preserve">
          <source>The returned Collector disallows null keys and values. If either mapping function returns null, &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">반환 된 Collector는 null 키 및 값을 허용하지 않습니다. 매핑 함수가 null을 반환하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="1fd9c231706d0da0d4eddb1a0ac608bee0a7ed4e" translate="yes" xml:space="preserve">
          <source>The returned SecureRandom object has not been seeded. To seed the returned object, call the &lt;code&gt;setSeed&lt;/code&gt; method. If &lt;code&gt;setSeed&lt;/code&gt; is not called, the first call to &lt;code&gt;nextBytes&lt;/code&gt; will force the SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">리턴 된 SecureRandom 오브젝트가 시드되지 않았습니다. 리턴 된 오브젝트를 시드하려면 &lt;code&gt;setSeed&lt;/code&gt; 메소드를 호출하십시오 . 경우 &lt;code&gt;setSeed&lt;/code&gt; 호출되지 않습니다, 최초의 호출 &lt;code&gt;nextBytes&lt;/code&gt; 자신을 배정하는 SecureRandom 오브젝트를 강제 할 것이다. &lt;code&gt;setSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자체 시드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4f45b323d8e60fb385aaaddf4bf5212cf5012ca" translate="yes" xml:space="preserve">
          <source>The returned array comprises all the code signers that have signed this entry.</source>
          <target state="translated">리턴 된 배열은이 항목에 서명 한 모든 코드 서명자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="90a2eb89a967b2512d9881060ad43029b93df120" translate="yes" xml:space="preserve">
          <source>The returned array contains the MIDI controller numbers for which the listener will now receive events. Some sequencers might not support controller event notification, in which case the array has a length of 0. Other sequencers might support notification for some controllers but not all. This method may be invoked repeatedly. Each time, the returned array indicates all the controllers that the listener will be notified about, not only the controllers requested in that particular invocation.</source>
          <target state="translated">반환 된 배열에는 리스너가 이제 이벤트를 수신 할 MIDI 컨트롤러 번호가 포함됩니다. 일부 시퀀서는 컨트롤러 이벤트 알림을 지원하지 않을 수 있으며,이 경우 어레이의 길이는 0입니다. 다른 시퀀서는 일부 컨트롤러에 대한 알림을 지원하지만 일부는 지원하지 않을 수 있습니다. 이 메소드는 반복적으로 호출 될 수 있습니다. 매번 반환 된 배열은 특정 호출에서 요청 된 컨트롤러뿐만 아니라 리스너에게 통보 할 모든 컨트롤러를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="77ab42c8180b6e9c1c6e98009e4ce02c9ee2fc2b" translate="yes" xml:space="preserve">
          <source>The returned array includes cipher suites from the list of standard cipher suite names in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt; JSSE Cipher Suite Names&lt;/a&gt; section of the Java Cryptography Architecture Standard Algorithm Name Documentation, and may also include other cipher suites that the provider supports.</source>
          <target state="translated">반환 된 배열에는 Java Cryptography Architecture Standard Algorithm Name Documentation 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt;JSSE Cipher Suite Names&lt;/a&gt; 섹션에있는 표준 암호 제품군 이름 목록의 암호 제품군이 포함되며 공급자가 지원하는 다른 암호 제품군도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47f2116b38feb165a5a7fcbeabdd2f6355db1df7" translate="yes" xml:space="preserve">
          <source>The returned array is a copy of the actual array and may be modified in any way without affecting the system tray. To remove a &lt;code&gt;TrayIcon&lt;/code&gt; from the &lt;code&gt;SystemTray&lt;/code&gt;, use the &lt;a href=&quot;#remove(java.awt.TrayIcon)&quot;&gt;&lt;code&gt;remove(TrayIcon)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">반환 된 배열은 실제 배열의 복사본이며 시스템 트레이에 영향을주지 않고 어떤 방식 으로든 수정할 수 있습니다. &lt;code&gt;SystemTray&lt;/code&gt; 에서 &lt;code&gt;TrayIcon&lt;/code&gt; 을 제거하려면 remove &lt;a href=&quot;#remove(java.awt.TrayIcon)&quot;&gt; &lt;code&gt;remove(TrayIcon)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3624c3e8b713f9750ee56a62c2997bd2cc1b21d9" translate="yes" xml:space="preserve">
          <source>The returned array is a shallow copy of the internal array, which means that it is a copy of the internal array of references to the &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; objects but that each referenced &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; object is not copied.</source>
          <target state="translated">리턴 된 배열은 내부 배열의 얕은 사본입니다. 즉, &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; 오브젝트 에 대한 내부 참조 배열의 사본 이지만 참조 된 각 &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; 오브젝트는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fcde0250fbd9f37a68a63dc986de2a345538306" translate="yes" xml:space="preserve">
          <source>The returned array is a shallow copy of the internal array, which means that it is a copy of the internal array of references to the &lt;code&gt;MBeanParameterInfo&lt;/code&gt; objects but that each referenced &lt;code&gt;MBeanParameterInfo&lt;/code&gt; object is not copied.</source>
          <target state="translated">리턴 된 배열은 내부 배열의 얕은 사본입니다. 즉, &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 오브젝트 에 대한 내부 참조 배열의 사본 이지만 참조 된 각 &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 오브젝트는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05ba6a5f60e0641d1235e4005ef40904baaa60b1" translate="yes" xml:space="preserve">
          <source>The returned array never contains methods with names &quot;&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;&quot; or &quot;&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">반환 된 배열에는 이름이 &quot; &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; &quot;인 메서드가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f6c37647bf61a5b5c430747eb2b5e030dc0e7ee8" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 컬렉션에 의해 참조되는 배열이 없기 때문에 &quot;안전&quot;합니다. 다시 말해서,이 메소드는이 콜렉션이 배열에 의해 지원 되더라도 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c7b12233cde488615989699afe78dcad6ed4384" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 배열에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b26c8c7a310fbb9e54174ebdb2dbcf36348363" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this list. (In other words, this method must allocate a new array even if this list is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 목록에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드가이 목록을 배열로 지원하더라도이 메소드는 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9957755e8c40fe5adbd7d7d8d5843d2e55923750" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 목록에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e282460816c42a0ccd3dcea485b9239559bb18e" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 큐에 의해 참조되는 배열이 없으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e87afccdc8466069c7b753215ae2cacd201fd10" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 세트에 의해 참조되는 배열이 없기 때문에 &quot;안전&quot;합니다. 즉,이 메소드가 배열에 의해 지원 되더라도이 메소드는 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8651aa449d701f684570ddf36fba5191566388d6" translate="yes" xml:space="preserve">
          <source>The returned attribute information is limited to runs that contain the current character.</source>
          <target state="translated">리턴 된 속성 정보는 현재 문자가 포함 된 실행으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3d33c31d474f6dd046417604a6a9ae4803e6b9" translate="yes" xml:space="preserve">
          <source>The returned certificate array comprises all the signer certificates that were used to verify this entry. Each signer certificate is followed by its supporting certificate chain (which may be empty). Each signer certificate and its supporting certificate chain are ordered bottom-to-top (i.e., with the signer certificate first and the (root) certificate authority last).</source>
          <target state="translated">리턴 된 인증 배열은이 항목을 확인하는 데 사용 된 모든 서명자 인증으로 구성됩니다. 각 서명자 인증서 뒤에는 지원 인증서 체인 (비어있을 수 있음)이옵니다. 각 서명자 인증서 및 지원 인증서 체인은 맨 아래에서 순서대로 주문됩니다 (즉, 서명자 인증서가 먼저 있고 (루트) 인증 기관이 마지막에 있음).</target>
        </trans-unit>
        <trans-unit id="61c3a6711385606db98b86cc4dc71d68bdea4436" translate="yes" xml:space="preserve">
          <source>The returned clip must be opened with the &lt;code&gt;open(AudioFormat)&lt;/code&gt; or &lt;code&gt;open(AudioInputStream)&lt;/code&gt; method.</source>
          <target state="translated">반환 된 클립은 &lt;code&gt;open(AudioFormat)&lt;/code&gt; 또는 &lt;code&gt;open(AudioInputStream)&lt;/code&gt; 메서드로 열어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ceb417aa63a35568772d2ba08459a4d0f57ffbee" translate="yes" xml:space="preserve">
          <source>The returned collection does</source>
          <target state="translated">반환 된 컬렉션은</target>
        </trans-unit>
        <trans-unit id="b07c416f52316fbf6c7d40a634719186c13469b3" translate="yes" xml:space="preserve">
          <source>The returned collection will be serializable if the specified collection is serializable.</source>
          <target state="translated">지정된 콜렉션이 직렬화 가능한 경우, 리턴 된 콜렉션은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3be1f1672220475d8271f6e01c1f720a84f08e5b" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable (assuming the specified comparator is also serializable or &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">반환 된 비교기는 직렬화 가능합니다 (지정된 비교기가 직렬화 가능 또는 &lt;code&gt;null&lt;/code&gt; 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="2812de92165ec02fbb836f9148b615e9ccc3b5b2" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">반환 된 비교기는 직렬화 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; &lt;code&gt;null&lt;/code&gt; 를 비교할 때 NullPointerException을 Throw 합니다.</target>
        </trans-unit>
        <trans-unit id="77a6f4be0bfa1c8aa5aedc5a42831ad20378a870" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing an entry with a null key.</source>
          <target state="translated">리턴 된 비교기는 직렬화 가능하며 항목을 널 키와 비교할 때 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="22bf28f66c9f612e083df0a59239e3c46c04c933" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing an entry with null values.</source>
          <target state="translated">리턴 된 비교기는 직렬화 가능하며 항목을 널값과 비교할 때 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="51644083b4b8fda187f5a628a6258b22d611a598" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified comparator is also serializable.</source>
          <target state="translated">지정된 비교기가 직렬화 가능한 경우, 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d69bb8caf8d86905d98a11aab0d0a3baa774bad3" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified comparator is serializable.</source>
          <target state="translated">지정된 비교기가 직렬화 가능하면, 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f0576c7aa360de3b65d8c8efe158571eec213ab2" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified function and comparator are both serializable.</source>
          <target state="translated">지정된 함수와 비교기가 모두 직렬화 가능하면 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ba917226177854af620439263d809c330c5d69cf" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified function is also serializable.</source>
          <target state="translated">지정된 함수도 직렬화 가능하면 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0334b290d5844794dff470460f3065bc09010f74" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable.</source>
          <target state="translated">반환 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="84b94e59406a95c4ca5a8d11de2db0b0bbe9f7c0" translate="yes" xml:space="preserve">
          <source>The returned completable future completes exceptionally with:</source>
          <target state="translated">반환 된 완성 가능한 미래는 다음과 같이 예외적으로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c615624e02206189b87ea763df189e93fca46655" translate="yes" xml:space="preserve">
          <source>The returned completable future, if completed successfully, completes with an &lt;a href=&quot;httpresponse&quot;&gt;&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; that contains the response status, headers, and body ( as handled by given response body handler ).</source>
          <target state="translated">반환 된 완료 가능한 미래는 성공적으로 완료되면 응답 상태, 헤더 및 본문이 포함 된 &lt;a href=&quot;httpresponse&quot;&gt; &lt;code&gt;HttpResponse&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (주어진 응답 본문 핸들러에서 처리됨)로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d33135e5a1f395b41fad98d6b20e99dae320a6" translate="yes" xml:space="preserve">
          <source>The returned era will be a singleton capable of being compared with the constants in &lt;a href=&quot;chrono/isochronology&quot;&gt;&lt;code&gt;IsoChronology&lt;/code&gt;&lt;/a&gt; using the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">반환 된 시대는 &lt;code&gt;==&lt;/code&gt; 연산자를 사용하여 &lt;a href=&quot;chrono/isochronology&quot;&gt; &lt;code&gt;IsoChronology&lt;/code&gt; &lt;/a&gt; 의 상수와 비교할 수있는 싱글 톤 입니다.</target>
        </trans-unit>
        <trans-unit id="8932377dd8e02a84a648c771d6426ce831a87e6f" translate="yes" xml:space="preserve">
          <source>The returned filter uses &lt;a href=&quot;../../../java.base/java/util/regex/matcher#find()&quot;&gt;&lt;code&gt;Matcher.find()&lt;/code&gt;&lt;/a&gt; to test for inclusion. To test for exact matches use the characters '^' and '$' to match the beginning and end of the string respectively. For example, &quot;^foo$&quot; includes only rows whose string is exactly &quot;foo&quot; and not, for example, &quot;food&quot;. See &lt;a href=&quot;../../../java.base/java/util/regex/pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; for a complete description of the supported regular-expression constructs.</source>
          <target state="translated">반환 된 필터는 &lt;a href=&quot;../../../java.base/java/util/regex/matcher#find()&quot;&gt; &lt;code&gt;Matcher.find()&lt;/code&gt; &lt;/a&gt; 를 사용하여 포함 여부를 테스트합니다. 정확한 일치를 테스트하려면 문자 '^'및 '$'를 사용하여 각각 문자열의 시작과 끝을 일치 시키십시오. 예를 들어, &quot;^ foo $&quot;는 문자열이 정확히 &quot;foo&quot;인 행만 포함하고 &quot;food&quot;는 포함하지 않습니다. 지원되는 정규식 구성에 대한 전체 설명은 &lt;a href=&quot;../../../java.base/java/util/regex/pattern&quot;&gt; &lt;code&gt;Pattern&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="685a6e900daf413e8d8765bf083707c3fc12c8e0" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록 ISO의 연대기가 설정되어 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="617ab648dccda8ea4bfed9ff5c0e4dca48843eb4" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style. The &lt;code&gt;FULL&lt;/code&gt; and &lt;code&gt;LONG&lt;/code&gt; styles typically require a time-zone. When formatting using these styles, a &lt;code&gt;ZoneId&lt;/code&gt; must be available, either by using &lt;code&gt;ZonedDateTime&lt;/code&gt; or &lt;a href=&quot;#withZone(java.time.ZoneId)&quot;&gt;&lt;code&gt;withZone(java.time.ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록하기 위해 설정된 ISO 연대기가 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 . &lt;code&gt;FULL&lt;/code&gt; 및 &lt;code&gt;LONG&lt;/code&gt; 스타일은 일반적으로 시간대를 필요로한다. 이러한 스타일을 사용하여 서식 때, &lt;code&gt;ZoneId&lt;/code&gt; 은 사용 중, 사용 가능해야합니다 &lt;code&gt;ZonedDateTime&lt;/code&gt; 또는 &lt;a href=&quot;#withZone(java.time.ZoneId)&quot;&gt; &lt;code&gt;withZone(java.time.ZoneId)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7747f70640f1e4a45424ed0c1270bbc9549330f" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#STRICT&quot;&gt;&lt;code&gt;STRICT&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록 ISO의 연대기가 설정되어 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#STRICT&quot;&gt; &lt;code&gt;STRICT&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c3dda27b1c2af94aa2edb7b9c334041c2040aee1" translate="yes" xml:space="preserve">
          <source>The returned formatter has no override chronology or zone. It uses &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 재정의 연대기 또는 영역이 없습니다. &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="65f23c4bdba155d972d5a5c334ace90811627c2f" translate="yes" xml:space="preserve">
          <source>The returned formatter has no override chronology or zone. It uses the &lt;a href=&quot;resolverstyle#STRICT&quot;&gt;&lt;code&gt;STRICT&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 재정의 연대기 또는 영역이 없습니다. &lt;a href=&quot;resolverstyle#STRICT&quot;&gt; &lt;code&gt;STRICT&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="93e620ed0c6b2f581405e4ca186e0d0c26a039f0" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt; providing that the base clock is.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; , 기본 클록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ebf894963bb17de1c19228a9892a378efc764d2" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="16aec74c31404fdf24dbc2481edc9947ae28ae7f" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;system(ZoneId.systemDefault())&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 그것은 동등 &lt;code&gt;system(ZoneId.systemDefault())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e83331df05c75aa0965f68cf383b4fa1ce4775" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;system(ZoneOffset.UTC)&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. &lt;code&gt;system(ZoneOffset.UTC)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="256a067cbdccb5e2e330ac00c3dcdb3f79fff5d2" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofMillis(1))&lt;/code&gt;.</source>
          <target state="translated">반환 된 구현은 변경 불가능하고 스레드로부터 안전하며 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofMillis(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39695b971886168cd9e28cf54007c2987d52ae31" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofMinutes(1))&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 이것은와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofMinutes(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d8edb2d119f60ce6b547f8aeea62c8bb10250e" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofSeconds(1))&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 이것은와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofSeconds(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab8e6a2c1e29941612774d35818b8817f708321" translate="yes" xml:space="preserve">
          <source>The returned index is the largest value</source>
          <target state="translated">반환 된 인덱스는 가장 큰 값입니다</target>
        </trans-unit>
        <trans-unit id="324947fcc7f39d43c0a0080101a27650dcd91d17" translate="yes" xml:space="preserve">
          <source>The returned index is the largest value &lt;code&gt;k&lt;/code&gt; for which:</source>
          <target state="translated">반환 된 인덱스는 다음과 같은 가장 큰 값 &lt;code&gt;k&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1010f5a375a5d3f29e20face9e80371d4a90f440" translate="yes" xml:space="preserve">
          <source>The returned index is the smallest value</source>
          <target state="translated">반환 된 인덱스는 가장 작은 값입니다</target>
        </trans-unit>
        <trans-unit id="b96444254cceb87f3cb7ff9401f1b082c1d382c7" translate="yes" xml:space="preserve">
          <source>The returned index is the smallest value &lt;code&gt;k&lt;/code&gt; for which:</source>
          <target state="translated">반환 된 인덱스는 다음과 같은 최소값 &lt;code&gt;k&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30fb35855f9641f7209a86fa609966716cae03af" translate="yes" xml:space="preserve">
          <source>The returned indexes are limited to the range of the iterator.</source>
          <target state="translated">반환 된 인덱스는 반복자의 범위로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="e45bc891e1f438dd01ea7196d9842b794781ae4f" translate="yes" xml:space="preserve">
          <source>The returned instants from &lt;code&gt;Clock&lt;/code&gt; work on a time-scale that ignores leap seconds, as described in &lt;a href=&quot;instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt;. If the implementation wraps a source that provides leap second information, then a mechanism should be used to &quot;smooth&quot; the leap second. The Java Time-Scale mandates the use of UTC-SLS, however clock implementations may choose how accurate they are with the time-scale so long as they document how they work. Implementations are therefore not required to actually perform the UTC-SLS slew or to otherwise be aware of leap seconds.</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 에서 반환 된 인스턴트 는 &lt;a href=&quot;instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; 에&lt;/a&gt; 설명 된대로 윤초를 무시하는 시간 단위로 작동합니다 . 구현이 윤초 정보를 제공하는 소스를 래핑하는 경우 윤초를 &quot;부드럽게&quot;하기 위해 메커니즘을 사용해야합니다. Java Time-Scale은 UTC-SLS의 사용을 의무화하지만 시계 구현은 작동 방식을 문서화하는 한 시간 단위로 얼마나 정확한지 선택할 수 있습니다. 따라서 실제로 UTC-SLS 회전을 수행하거나 윤초를 인식 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dfea46346d425f47431ab48a0b9973f65d3a3d0" translate="yes" xml:space="preserve">
          <source>The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 반복자는 &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;빠른 속도입니다.&lt;/i&gt;&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d825a47643cf28fa3b87aadae1a13cf5b1f8bb0" translate="yes" xml:space="preserve">
          <source>The returned iterator is &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 반복자는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;약하게 일관성이 있습니다.&lt;/i&gt;&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9ef6fd11db72e67c90473d6e296ebd844318cf20" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt; method.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="dd06f34d84c884510eb2daefd756631c982e6784" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;add&lt;/code&gt; methods.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;add&lt;/code&gt; 를 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="6c8995a19beeeaa38d931dd04ead46af4bf6aeaf" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the set when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt; method.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 세트 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="b28ef914634dbd42c57b4fb798bc270a1b137343" translate="yes" xml:space="preserve">
          <source>The returned line should be opened with the &lt;code&gt;open(AudioFormat)&lt;/code&gt; or &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; method.</source>
          <target state="translated">반환 된 줄은 &lt;code&gt;open(AudioFormat)&lt;/code&gt; 또는 &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; 메서드로 합니다.</target>
        </trans-unit>
        <trans-unit id="603df59fcea4e98e66008bfad2caba193eee7e62" translate="yes" xml:space="preserve">
          <source>The returned list consists of language ranges from the given &lt;code&gt;ranges&lt;/code&gt; and their equivalents found in the IANA Language Subtag Registry. For example, if the given &lt;code&gt;ranges&lt;/code&gt; is &lt;code&gt;&quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;&lt;/code&gt;, the elements in the list to be returned are:</source>
          <target state="translated">리턴 된 목록은 주어진 &lt;code&gt;ranges&lt;/code&gt; 의 언어 범위 와 IANA 언어 서브 태그 레지스트리에있는 해당 범위로 구성됩니다 . 예를 들어, 주어진 &lt;code&gt;ranges&lt;/code&gt; 가 &lt;code&gt;&quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;&lt;/code&gt; 인 경우 반환되는 목록의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4e4b3e38d248cd7e5998a34d9a87596fd1c1fda" translate="yes" xml:space="preserve">
          <source>The returned list is modifiable so as to facilitate changes to the existing ACL. The &lt;a href=&quot;#setAcl(java.util.List)&quot;&gt;&lt;code&gt;setAcl&lt;/code&gt;&lt;/a&gt; method is used to update the file's ACL attribute.</source>
          <target state="translated">반환 된 목록은 기존 ACL을 쉽게 변경할 수 있도록 수정할 수 있습니다. &lt;a href=&quot;#setAcl(java.util.List)&quot;&gt; &lt;code&gt;setAcl&lt;/code&gt; &lt;/a&gt; 방법은 파일의 ACL 속성을 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afce95588c0380c39f79771261da47a2d309e9a8" translate="yes" xml:space="preserve">
          <source>The returned list is modifiable so as to facilitate changes to the existing ACL. The &lt;a href=&quot;aclfileattributeview#setAcl-java.util.List-&quot;&gt;&lt;code&gt;setAcl&lt;/code&gt;&lt;/a&gt; method is used to update the file's ACL attribute.</source>
          <target state="translated">리턴 된 목록은 기존 ACL을 쉽게 변경할 수 있도록 수정할 수 있습니다. &lt;a href=&quot;aclfileattributeview#setAcl-java.util.List-&quot;&gt; &lt;code&gt;setAcl&lt;/code&gt; &lt;/a&gt; 방법은 파일의 ACL 속성을 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c503093f4e0ea3beb8f9f47ec55e6810f3e4744d" translate="yes" xml:space="preserve">
          <source>The returned list is not necessarily exhaustive. That is, the MBean may have a public constructor that is not in the list. In this case, the MBean server can construct another instance of this MBean's class using that constructor, even though it is not listed here.</source>
          <target state="translated">반환 된 목록이 반드시 완전한 것은 아닙니다. 즉, MBean에는 목록에없는 공용 생성자가있을 수 있습니다. 이 경우, MBean 서버는 여기에 나열되어 있지 않더라도 해당 생성자를 사용하여이 MBean 클래스의 다른 인스턴스를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4ba1a6fc0e1176884c27c61e7f3010f2b892f0" translate="yes" xml:space="preserve">
          <source>The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 목록 반복자가 &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;실패했습니다.&lt;/i&gt;&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca9df76291579b501b3fdfee2f39774c2720a485" translate="yes" xml:space="preserve">
          <source>The returned list will be serializable if the specified list is serializable.</source>
          <target state="translated">지정된 목록이 직렬화 가능하면 리턴 된 목록은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b51e7cf95fea371d30e6037819047e729ec2ba1c" translate="yes" xml:space="preserve">
          <source>The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; if the specified list does.</source>
          <target state="translated">지정된 목록이 직렬화 가능하면 리턴 된 목록은 직렬화 가능합니다. 마찬가지로 반환 된 목록은 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 를 구현합니다. 지정된 목록 합니다.</target>
        </trans-unit>
        <trans-unit id="bf755a47227812109e329812c17f2e30f9fb6597" translate="yes" xml:space="preserve">
          <source>The returned logger will perform message localization as specified by &lt;a href=&quot;system.loggerfinder#getLocalizedLogger(java.lang.String,java.util.ResourceBundle,java.lang.Module)&quot;&gt;&lt;code&gt;LoggerFinder.getLocalizedLogger(name, bundle, module)&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;module&lt;/code&gt; is the caller's module. In cases where &lt;code&gt;System.getLogger&lt;/code&gt; is called from a context where there is no caller frame on the stack (e.g when called directly from a JNI attached thread), &lt;code&gt;IllegalCallerException&lt;/code&gt; is thrown. To obtain a logger in such a context, use an auxiliary class that will implicitly be identified as the caller, or use the system &lt;a href=&quot;system.loggerfinder#getLoggerFinder()&quot;&gt;&lt;code&gt;LoggerFinder&lt;/code&gt;&lt;/a&gt; to obtain a logger instead. Note that doing the latter may eagerly initialize the underlying logging system.</source>
          <target state="translated">반환 된 로거는 &lt;a href=&quot;system.loggerfinder#getLocalizedLogger(java.lang.String,java.util.ResourceBundle,java.lang.Module)&quot;&gt; &lt;code&gt;LoggerFinder.getLocalizedLogger(name, bundle, module)&lt;/code&gt; &lt;/a&gt; 지정된대로 메시지 현지화를 수행합니다 . 여기서 &lt;code&gt;module&lt;/code&gt; 은 호출자의 모듈입니다. 스택에 호출자 프레임이없는 컨텍스트 에서 &lt;code&gt;System.getLogger&lt;/code&gt; 가 호출되는 경우 (예 : JNI 연결 스레드에서 직접 호출되는 경우) &lt;code&gt;IllegalCallerException&lt;/code&gt; 이 발생합니다. 이러한 컨텍스트에서 로거를 얻으려면 암시 ​​적으로 호출자로 식별되는 보조 클래스를 사용하거나 대신 시스템 &lt;a href=&quot;system.loggerfinder#getLoggerFinder()&quot;&gt; &lt;code&gt;LoggerFinder&lt;/code&gt; &lt;/a&gt; 를 사용하여 로거를 얻습니다. 후자를 수행하면 기본 로깅 시스템을 열심히 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3cf87e163405abbca1ef35f4f6b362d57c5c392" translate="yes" xml:space="preserve">
          <source>The returned map and its collection views may not obey the general contract of the &lt;a href=&quot;object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;object#hashCode()&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">반환 된 맵과 컬렉션 뷰는 &lt;a href=&quot;object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;object#hashCode()&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 메서드 의 일반 계약을 따르지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04550933f42e1b20dd67a722e85a83b892d29e8b" translate="yes" xml:space="preserve">
          <source>The returned map and its collection views may not obey the general contract of the &lt;a href=&quot;object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">리턴 된 맵 및 해당 콜렉션보기는 &lt;a href=&quot;object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 의 일반 계약을 준수하지 않을 수 있습니다. 메소드 .</target>
        </trans-unit>
        <trans-unit id="bd8d64063c7ed0ea19647d547170466cdf6c7ae7" translate="yes" xml:space="preserve">
          <source>The returned map does not permit null keys or values. Attempting to insert or query the presence of a null key or value will throw a &lt;a href=&quot;nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;. Attempting to query the presence of a key or value which is not of type &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;classcastexception&quot;&gt;&lt;code&gt;ClassCastException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 맵은 널 키 또는 값을 허용하지 않습니다. null 키 또는 값이 있는지 삽입하거나 쿼리하려고하면 &lt;a href=&quot;nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형이 아닌 키 또는 값의 존재를 쿼리하려고 하면 &lt;a href=&quot;classcastexception&quot;&gt; &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6adecd8da1fa6d74979ab4b71410df2ad020d787" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵에는 &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. 식 &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;m&lt;/code&gt; 본질적으로 동등한 &lt;code&gt;m&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="de626c9a4a06c5beb2eb08bc7e1023f6785c4bcc" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵의 순서는 &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일합니다 . &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 표현식 은 기본적으로 &lt;code&gt;m&lt;/code&gt; 과 동등한 &lt;code&gt;m&lt;/code&gt; 의 뷰를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e78c6f35b029ca60ae6001c0f097568236673e" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵에는 &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. 식 &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;m&lt;/code&gt; 본질적으로 동등한 &lt;code&gt;m&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="47af6d18a03dd37ca75973b55abf606e91a20528" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵의 순서는 &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt; 와 동일합니다 . &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 표현식 은 기본적으로 &lt;code&gt;m&lt;/code&gt; 과 동등한 &lt;code&gt;m&lt;/code&gt; 의 뷰를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a6919fc63dffbd2b665571fbe3d0e62befa5d6f" translate="yes" xml:space="preserve">
          <source>The returned map implements all optional &lt;a href=&quot;../sortedmap&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; operations</source>
          <target state="translated">리턴 된 맵은 모든 선택적 &lt;a href=&quot;../sortedmap&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt; 조작을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3e60ce6cdb39e55f6aea0270ae6050c5d468141c" translate="yes" xml:space="preserve">
          <source>The returned map is typically case-sensitive on all platforms.</source>
          <target state="translated">리턴 된 맵은 일반적으로 모든 플랫폼에서 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ebb8ac95b0820624300e6c51aa32adf9bf40ac27" translate="yes" xml:space="preserve">
          <source>The returned map will be serializable if the specified map is serializable.</source>
          <target state="translated">지정된 맵이 직렬화 가능하면 리턴 된 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3580abdef3f87a6bd80d4bea2b490670bec97aa7" translate="yes" xml:space="preserve">
          <source>The returned map will never contain null keys or values. Attempting to query the presence of a null key or value will throw a &lt;a href=&quot;nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;. Attempting to query the presence of a key or value which is not of type &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;classcastexception&quot;&gt;&lt;code&gt;ClassCastException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 맵에는 널 키 또는 값이 포함되지 않습니다. null 키 또는 값이 있는지 쿼리하려고하면 &lt;a href=&quot;nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형이 아닌 키 또는 값의 존재를 쿼리하려고 하면 &lt;a href=&quot;classcastexception&quot;&gt; &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="186b57fc3142be2ab7c06b068233e86af34426e7" translate="yes" xml:space="preserve">
          <source>The returned map will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert a key outside its range.</source>
          <target state="translated">돌려 주어지는 맵은 그 범위 외의 키를 삽입하려고 하면 (자) &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="38495ee31c82f624af115d8608382ab49eee4275" translate="yes" xml:space="preserve">
          <source>The returned map will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.</source>
          <target state="translated">돌려 주어진 맵은 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 범위를 벗어난 키를 삽입하거나 엔드 포인트가 범위 밖에있는 서브맵을 구성하려는 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3b7da5ac39ea912d89eb86cf1f58a17a89487bae" translate="yes" xml:space="preserve">
          <source>The returned method handle is equivalent to &lt;code&gt;dropArguments(zero(type.returnType()), 0, type.parameterList())&lt;/code&gt;.</source>
          <target state="translated">반환 된 메서드 핸들은 &lt;code&gt;dropArguments(zero(type.returnType()), 0, type.parameterList())&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="be839b6e9781e2a92a16b75b05df60ab61f8f103" translate="yes" xml:space="preserve">
          <source>The returned method handle is equivalent to &lt;code&gt;empty(methodType(type))&lt;/code&gt;. It is also equivalent to &lt;code&gt;explicitCastArguments(constant(Object.class, null), methodType(type))&lt;/code&gt;, since &lt;code&gt;explicitCastArguments&lt;/code&gt; converts &lt;code&gt;null&lt;/code&gt; to default values.</source>
          <target state="translated">반환 된 메서드 핸들은 &lt;code&gt;empty(methodType(type))&lt;/code&gt; 과 동일합니다 . 또한 &lt;code&gt;explicitCastArguments&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 을 기본값 으로 변환 하므로 explicitCastArguments &lt;code&gt;explicitCastArguments(constant(Object.class, null), methodType(type))&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="bf341b930019b986feaa3025d94588cbf0b07082" translate="yes" xml:space="preserve">
          <source>The returned method handle is equivalent to &lt;code&gt;identity(type).bindTo(value)&lt;/code&gt;.</source>
          <target state="translated">리턴 된 메소드 핸들은 &lt;code&gt;identity(type).bindTo(value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08c6e093f65426cb1d1abfa5dcc5c30c713506d0" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt; if and only if the constructor's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">반환 된 메서드 핸들은 생성자의 가변 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity&lt;/a&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="68be879cb87a23db36e0a68951f564309bd3df0e" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument. (If the trailing array argument is the only argument, the given receiver value will be bound to it.)</source>
          <target state="translated">반환 된 메서드 핸들은 메서드의 가변 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정 &lt;em&gt;되고&lt;/em&gt; 후행 배열 인수가 유일한 인수가 아닌 경우에만 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity&lt;/a&gt; 를 갖습니다 . (후행 배열 인수가 유일한 인수 인 경우 지정된 수신자 값이 여기에 바인딩됩니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97d70a1480f82e4e58a7bae7833050abcbcd7b02" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">반환 된 메서드 핸들은 메서드의 가변 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity&lt;/a&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="cf12e977e77f8c538e96bf14109eaad3316041c8" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the constructor's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">생성자의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 반환 된 메소드 핸들에 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b84ac4232d79eefcfa3e985c888ae7cb52f78ae" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument. (If the trailing array argument is the only argument, the given receiver value will be bound to it.)</source>
          <target state="translated">메소드의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정 &lt;em&gt;되고&lt;/em&gt; 후행 배열 인수가 유일한 인수가 아닌 경우에만 리턴 된 메소드 핸들은 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 를 갖습니다 . 후행 배열 인수가 유일한 인수이면 지정된 수신자 값이 바인딩됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdb52f5efb367c3a0c6f85b8e5a561c3fd955c91" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">메소드의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 리턴 된 메소드 핸들에 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7fc53c29677f5d1950f8b1cceaed84e97f9c71b" translate="yes" xml:space="preserve">
          <source>The returned multicaster contains all the listeners in this multicaster with the exception of all occurrences of &lt;code&gt;oldl&lt;/code&gt;. If the resulting multicaster contains only one regular listener the regular listener may be returned. If the resulting multicaster is empty, then &lt;code&gt;null&lt;/code&gt; may be returned instead.</source>
          <target state="translated">반환 된 멀티 캐스터는 모든 &lt;code&gt;oldl&lt;/code&gt; 발생을 제외하고이 멀티 캐스터의 모든 리스너를 포함합니다 . 결과 멀티 캐스터에 일반 리스너가 하나만 포함 된 경우 일반 리스너가 반환 될 수 있습니다. 결과 멀티 캐스터가 비어 있으면 대신 &lt;code&gt;null&lt;/code&gt; 이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b799c087978df49d2fe6286478b6ecedece7b2a8" translate="yes" xml:space="preserve">
          <source>The returned navigable map will be serializable if the specified navigable map is serializable.</source>
          <target state="translated">지정된 탐색 가능한지도가 직렬화 가능한 경우 반환 된 탐색 가능한지도는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="63e22369ffd2f4700f3d4c6318fbd029fc94516b" translate="yes" xml:space="preserve">
          <source>The returned navigable set will be serializable if the specified navigable set is serializable.</source>
          <target state="translated">지정된 탐색 가능 세트가 직렬화 가능하면 리턴 된 탐색 가능 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="22109190c7021a569021e7447b7b84963fc23137" translate="yes" xml:space="preserve">
          <source>The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after this call. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine. This method makes no guarantee that write operations to this file system will succeed.</source>
          <target state="translated">반환 된 사용 가능한 바이트 수는 힌트이지만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는이 호출 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다. 이 방법은이 파일 시스템에 대한 쓰기 작업이 성공한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37078f56cceda1a46ec4284d20998d8403b393be" translate="yes" xml:space="preserve">
          <source>The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of usable bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this Java virtual machine.</source>
          <target state="translated">반환 된 사용 가능한 바이트 수는 힌트이지만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 사용 가능한 바이트 수는 공간 속성을 얻은 직후에 정확할 가능성이 높습니다. 이 Java 가상 머신 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9ec8ab1c6179c271d12fffbe706c3b736240a28" translate="yes" xml:space="preserve">
          <source>The returned number of unallocated bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine.</source>
          <target state="translated">반환 된 할당되지 않은 바이트 수는 힌트 일 뿐이지 만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는 공간 속성을 얻은 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4abb292a819da63fe264f4077cd386242fe657dd" translate="yes" xml:space="preserve">
          <source>The returned number of unallocated bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after this call. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine. This method makes no guarantee that write operations to this file system will succeed.</source>
          <target state="translated">반환 된 할당되지 않은 바이트 수는 힌트 일 뿐이지 만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는이 호출 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다. 이 방법은이 파일 시스템에 대한 쓰기 작업이 성공한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bf3ae18f78108540f59e74bf023c42294fa7cf2" translate="yes" xml:space="preserve">
          <source>The returned object is unmodifiable and contains the tag names of all &lt;code&gt;TIFFTag&lt;/code&gt;s in this &lt;code&gt;TIFFTagSet&lt;/code&gt; sorted into ascending order according to &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt;&lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 수정할 수 &lt;code&gt;TIFFTagSet&lt;/code&gt; &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt; &lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 오름차순으로 정렬 된이 TIFFTagSet 의 모든 &lt;code&gt;TIFFTag&lt;/code&gt; 태그 이름을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="9e796af45c9611651ce65ec6c4b30604165ccfde" translate="yes" xml:space="preserve">
          <source>The returned object is unmodifiable and contains the tag numbers of all &lt;code&gt;TIFFTag&lt;/code&gt;s in this &lt;code&gt;TIFFTagSet&lt;/code&gt; sorted into ascending order according to &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt;&lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 수정할 수 &lt;code&gt;TIFFTag&lt;/code&gt; &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt; &lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 오름차순으로 정렬 된이 &lt;code&gt;TIFFTagSet&lt;/code&gt; 의 모든 TIFFTag 태그 번호를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="492c119dd4628b39858412c60847fb3a194906f2" translate="yes" xml:space="preserve">
          <source>The returned object may be modified using ordinary &lt;a href=&quot;../util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; operations. These modifications will be visible to subprocesses started via the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. Two &lt;code&gt;ProcessBuilder&lt;/code&gt; instances always contain independent process environments, so changes to the returned map will never be reflected in any other &lt;code&gt;ProcessBuilder&lt;/code&gt; instance or the values returned by &lt;a href=&quot;system#getenv(java.lang.String)&quot;&gt;&lt;code&gt;System.getenv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 일반적인 &lt;a href=&quot;../util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 작업을 사용하여 수정할 수 있습니다 . 이러한 수정 사항은 &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 시작된 하위 프로세스에 표시됩니다 . 두 개의 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스에는 항상 독립적 인 프로세스 환경이 포함되어 있으므로 반환 된 맵의 변경 사항은 다른 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스 또는 &lt;a href=&quot;system#getenv(java.lang.String)&quot;&gt; &lt;code&gt;System.getenv&lt;/code&gt; 에서&lt;/a&gt; 반환 된 값에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c0e131d9f7c12cd49d0e3def257a8126d1849784" translate="yes" xml:space="preserve">
          <source>The returned object may be modified using ordinary &lt;a href=&quot;../util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; operations. These modifications will be visible to subprocesses started via the &lt;a href=&quot;processbuilder#start--&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. Two &lt;code&gt;ProcessBuilder&lt;/code&gt; instances always contain independent process environments, so changes to the returned map will never be reflected in any other &lt;code&gt;ProcessBuilder&lt;/code&gt; instance or the values returned by &lt;a href=&quot;system#getenv-java.lang.String-&quot;&gt;&lt;code&gt;System.getenv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 일반 &lt;a href=&quot;../util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 작업을 사용하여 수정할 수 있습니다 . 이러한 수정 사항은 &lt;a href=&quot;processbuilder#start--&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 시작된 하위 프로세스에 표시됩니다 . 두 개의 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스는 항상 독립적 인 프로세스 환경을 포함하므로 리턴 된 맵에 대한 변경 사항은 다른 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스 또는 &lt;a href=&quot;system#getenv-java.lang.String-&quot;&gt; &lt;code&gt;System.getenv&lt;/code&gt; 가&lt;/a&gt; 리턴 한 값에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10758f1a6b50ea2e6c130aeb5c0b77e0c66fbab0" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/datagramsocket&quot;&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/datagramsocket&quot;&gt; &lt;code&gt;DatagramSocket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메서드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6661a89d64621663c740fc5bd7a203767c62c2b9" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/serversocket&quot;&gt;&lt;code&gt;ServerSocket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/serversocket&quot;&gt; &lt;code&gt;ServerSocket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메소드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b4f4ca2ce4cf8222c87458553d37b2d17a03fa4b" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메소드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0472b263351c4d126d5ea013a83e7af5df81b296" translate="yes" xml:space="preserve">
          <source>The returned parameter object must be initialized via a call to &lt;code&gt;init&lt;/code&gt;, using an appropriate parameter specification or parameter encoding.</source>
          <target state="translated">리턴 된 매개 변수 오브젝트는 적절한 매개 변수 스펙 또는 매개 변수 인코딩을 사용하여 &lt;code&gt;init&lt;/code&gt; 호출을 통해 초기화되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="47dc492778d2d3b5a2a328f21d3d9313d13e099e" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/c14nmethodparameterspec&quot;&gt;&lt;code&gt;C14NMethodParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/c14nmethodparameterspec&quot;&gt; &lt;code&gt;C14NMethodParameterSpec&lt;/code&gt; &lt;/a&gt; 개체 로 형변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ddc417851bcf3ea126e833b688c0a6913e44637" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/digestmethodparameterspec&quot;&gt;&lt;code&gt;DigestMethodParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/digestmethodparameterspec&quot;&gt; &lt;code&gt;DigestMethodParameterSpec&lt;/code&gt; &lt;/a&gt; 객체 로 타입 캐스트 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83acc9ac6764336702eb89931e745c9306c55b1b" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/signaturemethodparameterspec&quot;&gt;&lt;code&gt;SignatureMethodParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/signaturemethodparameterspec&quot;&gt; &lt;code&gt;SignatureMethodParameterSpec&lt;/code&gt; &lt;/a&gt; 개체 로 형변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e366a23cd79e1859b47622e908ca1f0d6b5314" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/transformparameterspec&quot;&gt;&lt;code&gt;TransformParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/transformparameterspec&quot;&gt; &lt;code&gt;TransformParameterSpec&lt;/code&gt; &lt;/a&gt; 개체 로 형변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4df3bd992ed9cf08b8043aa23cc9ef35cfb0d899" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 암호를 초기화하는 데 사용 된 것과 동일하거나이 암호에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 암호 구현에 의해 사용되는 기본 및 무작위 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752ffb538b7e9750a71c7c4cf9e60e4eee90c425" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this signature engine, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature engine requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 서명 엔진을 초기화하는 데 사용 된 것과 동일하거나,이 서명 엔진에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 서명 구현에서 사용되는 기본 및 무작위로 생성 된 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45bd612510ae15a9437f55deeaebac11cc09c8c" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this signature, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 서명을 초기화하는 데 사용 된 것과 동일하거나,이 서명에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 서명 구현에서 사용되는 기본 및 무작위로 생성 된 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c3309fd588c4ac6caa981d38e4c41575c42f8ec" translate="yes" xml:space="preserve">
          <source>The returned path string uses the default name &lt;a href=&quot;filesystem#getSeparator()&quot;&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/a&gt; to separate names in the path.</source>
          <target state="translated">반환 된 경로 문자열은 기본 이름 &lt;a href=&quot;filesystem#getSeparator()&quot;&gt; &lt;code&gt;separator&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로에서 이름을 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="31a706d9a79d6d8447286cc51c0dbac2857f3fb0" translate="yes" xml:space="preserve">
          <source>The returned path string uses the default name &lt;a href=&quot;filesystem#getSeparator--&quot;&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/a&gt; to separate names in the path.</source>
          <target state="translated">반환 된 경로 문자열은 기본 이름 &lt;a href=&quot;filesystem#getSeparator--&quot;&gt; &lt;code&gt;separator&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로에서 이름을 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="adf31a0a552eb3e572f95b3b75985ef817599500" translate="yes" xml:space="preserve">
          <source>The returned period is immutable and thread-safe.</source>
          <target state="translated">반환 된 기간은 변경 불가능하고 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0fc1b4afe410c4184d3ee0067023a81a530b2ac3" translate="yes" xml:space="preserve">
          <source>The returned queue will be serializable if the specified queue is serializable.</source>
          <target state="translated">지정된 큐가 직렬화 가능하면 리턴 된 큐는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="be45c831c6cb6ad3b20e650176014c1026fccd42" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">반환 된 집합에는 &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 표현식 은 본질적으로 &lt;code&gt;s&lt;/code&gt; 와 동등한 &lt;code&gt;s&lt;/code&gt; 뷰를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e3b490a0b68921e5f2d54982954ae5db0e3015e" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">리턴 된 세트는 &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동등한 순서를 갖습니다 . 식 &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;s&lt;/code&gt; 과 본질적으로 동등한 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="377684bc5b679d5593f89c67fdae0d1615f86030" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">반환 된 집합에는 &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 표현식 은 본질적으로 &lt;code&gt;s&lt;/code&gt; 와 동등한 &lt;code&gt;s&lt;/code&gt; 뷰를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3e0a450b88e9e02addbc6c115aa54b248453093" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">리턴 된 세트는 &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt; 와 동등한 순서를 갖습니다 . 식 &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;s&lt;/code&gt; 과 본질적으로 동등한 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="220883a1d6410f4ba7ef330e4aa7ccfbc79da085" translate="yes" xml:space="preserve">
          <source>The returned set is a modifiable copy of the flags.</source>
          <target state="translated">리턴 된 세트는 수정 가능한 플래그 사본입니다.</target>
        </trans-unit>
        <trans-unit id="c5cb0f1cda390591cbbfdd982f4f651a475f6f50" translate="yes" xml:space="preserve">
          <source>The returned set is a modifiable copy of the permissions.</source>
          <target state="translated">리턴 된 세트는 수정 가능한 권한의 사본입니다.</target>
        </trans-unit>
        <trans-unit id="130457322e83b65d75a40390b0669abbd4a7d5d4" translate="yes" xml:space="preserve">
          <source>The returned set is not backed by the &lt;code&gt;Properties&lt;/code&gt; object. Changes to this &lt;code&gt;Properties&lt;/code&gt; are not reflected in the set, or vice versa.</source>
          <target state="translated">리턴 된 세트는 &lt;code&gt;Properties&lt;/code&gt; 오브젝트에 의해 지원되지 않습니다 . 이 &lt;code&gt;Properties&lt;/code&gt; 대한 변경 사항 은 세트에 반영되지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="109db5fe06aff8f3e5ce1040e372e7064c0c41dd" translate="yes" xml:space="preserve">
          <source>The returned set is not backed by this &lt;code&gt;Properties&lt;/code&gt; object. Changes to this &lt;code&gt;Properties&lt;/code&gt; object are not reflected in the returned set.</source>
          <target state="translated">반환 된 집합은이 &lt;code&gt;Properties&lt;/code&gt; 개체에 의해 지원되지 않습니다 . 이 &lt;code&gt;Properties&lt;/code&gt; 개체에 대한 변경 사항 은 반환 된 집합에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e9bbc6259b7b305420033286153988e609e2dfe" translate="yes" xml:space="preserve">
          <source>The returned set will be serializable if the specified set is serializable.</source>
          <target state="translated">지정된 세트가 직렬화 가능한 경우, 리턴 된 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6add43a3d565273146ff21959e52c46e37133f8b" translate="yes" xml:space="preserve">
          <source>The returned set will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert an element outside its range.</source>
          <target state="translated">돌려 주어진 세트는 그 범위 외의 요소를 삽입하려고 하면 (자) &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="08dbebf4ee48b0815ada6801ab8ff9946c69da0f" translate="yes" xml:space="preserve">
          <source>The returned socket is configured using the socket options established for this factory, and is set to use server mode when handshaking (see &lt;a href=&quot;sslsocket#setUseClientMode(boolean)&quot;&gt;&lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">반환 된 소켓은이 팩토리에 대해 설정된 소켓 옵션을 사용하여 구성되며 핸드 셰이 &lt;a href=&quot;sslsocket#setUseClientMode(boolean)&quot;&gt; &lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt; &lt;/a&gt; 서버 모드를 사용하도록 설정됩니다 ( SSLSocket.setUseClientMode (boolean) 참조 ).</target>
        </trans-unit>
        <trans-unit id="36ef4c7e56e059e7cc6ecb7f25266519a33c9874" translate="yes" xml:space="preserve">
          <source>The returned socket is configured using the socket options established for this factory, and is set to use server mode when handshaking (see &lt;a href=&quot;sslsocket#setUseClientMode-boolean-&quot;&gt;&lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">리턴 된 소켓은이 팩토리에 대해 설정된 소켓 옵션을 사용하여 구성되며 핸드 쉐이킹시 서버 모드를 사용하도록 설정됩니다 ( &lt;a href=&quot;sslsocket#setUseClientMode-boolean-&quot;&gt; &lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f90f95fa6a4a814b30bb64a73971367f5cea036" translate="yes" xml:space="preserve">
          <source>The returned sorted map will be serializable if the specified sorted map is serializable.</source>
          <target state="translated">지정된 정렬 맵이 직렬화 가능하면 리턴 된 정렬 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="84b2dfe035ba12d83875affd06b6d4712350f778" translate="yes" xml:space="preserve">
          <source>The returned sorted set will be serializable if the specified sorted set is serializable.</source>
          <target state="translated">지정된 정렬 세트가 직렬화 가능하면 리턴 된 정렬 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0daff3577dae1f88c6b38a7fd8e4b3abd97adeb1" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report. (For example, if it is known the array will not be further modified, specify &lt;code&gt;IMMUTABLE&lt;/code&gt;; if the array data is considered to have an an encounter order, specify &lt;code&gt;ORDERED&lt;/code&gt;). The method &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt;&lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt;&lt;/a&gt; can often be used instead, which returns a spliterator that reports &lt;code&gt;SIZED&lt;/code&gt;, &lt;code&gt;SUBSIZED&lt;/code&gt;, &lt;code&gt;IMMUTABLE&lt;/code&gt;, and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator 항상 특성 보고서 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 스플리터가보고 할 추가 특성을 제공 할 수 있습니다. 예를 들어, 배열이 더 이상 수정되지 않는 것으로 알려진 경우 &lt;code&gt;IMMUTABLE&lt;/code&gt; 을 지정 하십시오. 배열 데이터가 발생 순서로 간주되는 경우 &lt;code&gt;ORDERED&lt;/code&gt; 를 지정 하십시오. 메소드 &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt; &lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt; &lt;/a&gt; spliterator보고 그 반환 자주 대신 사용할 수 있습니다, &lt;code&gt;SIZED&lt;/code&gt; , &lt;code&gt;SUBSIZED&lt;/code&gt; , &lt;code&gt;IMMUTABLE&lt;/code&gt; 는 한 &lt;code&gt;ORDERED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e608e572bf2565a5091c6b2b59f30af46dea54ce" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report. (For example, if it is known the array will not be further modified, specify &lt;code&gt;IMMUTABLE&lt;/code&gt;; if the array data is considered to have an encounter order, specify &lt;code&gt;ORDERED&lt;/code&gt;). The method &lt;a href=&quot;arrays#spliterator(long%5B%5D,int,int)&quot;&gt;&lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt;&lt;/a&gt; can often be used instead, which returns a spliterator that reports &lt;code&gt;SIZED&lt;/code&gt;, &lt;code&gt;SUBSIZED&lt;/code&gt;, &lt;code&gt;IMMUTABLE&lt;/code&gt;, and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator 항상 특성 보고서 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 분할자가보고 할 추가 특성을 제공 할 수 있습니다. (예를 들어, 배열이 더 이상 수정되지 않는 것으로 알려진 경우 &lt;code&gt;IMMUTABLE&lt;/code&gt; 을 지정 하고 배열 데이터에 발생 순서가있는 것으로 간주되면 &lt;code&gt;ORDERED&lt;/code&gt; 를 지정 하십시오.) 방법 &lt;a href=&quot;arrays#spliterator(long%5B%5D,int,int)&quot;&gt; &lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt; &lt;/a&gt; 리포트하는 spliterator 반환 대신에 종종 사용될 수 &lt;code&gt;SIZED&lt;/code&gt; , &lt;code&gt;SUBSIZED&lt;/code&gt; , &lt;code&gt;IMMUTABLE&lt;/code&gt; 는 한 &lt;code&gt;ORDERED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f1d245446dcb633ef538a6c950f3a6bc13a27b6" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify &lt;code&gt;IMMUTABLE&lt;/code&gt; and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator은 항상 특성을보고 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 스플리터가보고 할 추가 특성을 제공 할 수 있습니다. &lt;code&gt;IMMUTABLE&lt;/code&gt; 및 &lt;code&gt;ORDERED&lt;/code&gt; 를 추가로 지정하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="448ee2ba55f195d0baa345b55208a1fe5ff52b70" translate="yes" xml:space="preserve">
          <source>The returned spliterator is &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 스플리터는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;약하게 일관성이&lt;/i&gt;&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f2400d7a2aaaa17fc5812d2a385fbf8098fa7b6" translate="yes" xml:space="preserve">
          <source>The returned spliterator should report the set of characteristics derived from the stream pipeline (namely the characteristics derived from the stream source spliterator and the intermediate operations). Implementations may report a sub-set of those characteristics. For example, it may be too expensive to compute the entire set for some or all possible stream pipelines.</source>
          <target state="translated">반환 된 분할자는 스트림 파이프 라인에서 파생 된 특성 집합 (즉, 스트림 소스 분할 자 및 중간 작업에서 파생 된 특성)을보고해야합니다. 구현시 이러한 특성의 하위 집합을보고 할 수 있습니다. 예를 들어 가능한 일부 또는 모든 스트림 파이프 라인에 대해 전체 세트를 계산하는 것은 너무 비쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39320309f6acb1e293c4b0f88be30f7d21cd9419" translate="yes" xml:space="preserve">
          <source>The returned stream contains a reference to an open directory. The directory is closed by closing the stream.</source>
          <target state="translated">반환 된 스트림에는 열린 디렉토리에 대한 참조가 포함됩니다. 스트림을 닫으면 디렉토리가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7b8591462e635ab93bf50430fdf54a1ccdf66f0b" translate="yes" xml:space="preserve">
          <source>The returned stream contains a reference to an open file. The file is closed by closing the stream.</source>
          <target state="translated">반환 된 스트림에는 열린 파일에 대한 참조가 포함됩니다. 스트림을 닫으면 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d2ceba9dd83dd39b4220abff8b7e79783a77866b" translate="yes" xml:space="preserve">
          <source>The returned stream contains references to one or more open directories. The directories are closed by closing the stream.</source>
          <target state="translated">반환 된 스트림에는 하나 이상의 열린 디렉토리에 대한 참조가 포함됩니다. 스트림을 닫으면 디렉토리가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="17f6fef10c7c1d7faa5f4bb6d1cad19315fbac4b" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates a &lt;a href=&quot;../../io/reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt;. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed.</source>
          <target state="translated">반환 된 스트림은 &lt;a href=&quot;../../io/reader&quot;&gt; &lt;code&gt;Reader&lt;/code&gt; 를&lt;/a&gt; 캡슐화합니다. . 파일 시스템 자원을 적시에 폐기해야하는 경우 , 스트림 조작이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 try-with-resources 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ddd602fbd78f0cc6b843db33e616208261076d4" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates a &lt;a href=&quot;directorystream&quot;&gt;&lt;code&gt;DirectoryStream&lt;/code&gt;&lt;/a&gt;. If timely disposal of file system resources is required, the &lt;code&gt;try&lt;/code&gt;-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed.</source>
          <target state="translated">리턴 된 스트림은 &lt;a href=&quot;directorystream&quot;&gt; &lt;code&gt;DirectoryStream&lt;/code&gt; 을&lt;/a&gt; 캡슐화합니다 . 파일 시스템 자원을 적시에 폐기 해야하는 경우 , 스트림 작업이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 &lt;code&gt;try&lt;/code&gt; -with-resources 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d94964406c818caac85b35a4e7cb8afabde4f74" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates one or more &lt;a href=&quot;directorystream&quot;&gt;&lt;code&gt;DirectoryStream&lt;/code&gt;&lt;/a&gt;s. If timely disposal of file system resources is required, the &lt;code&gt;try&lt;/code&gt;-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed. Operating on a closed stream will result in an &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 스트림은 하나 이상의 &lt;a href=&quot;directorystream&quot;&gt; &lt;code&gt;DirectoryStream&lt;/code&gt; 을&lt;/a&gt; 캡슐화 합니다. 파일 시스템 자원을 적시에 폐기 해야하는 경우 , 스트림 작업이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 &lt;code&gt;try&lt;/code&gt; -with-resources 구문을 사용해야합니다 . 닫힌 스트림에서 작동하면 &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="0a3477259359f64c96ff7a386ac7319ab96e368d" translate="yes" xml:space="preserve">
          <source>The returned string corresponds to the single-string representation of a Kerberos Principal name as specified in Section 2.1 of &lt;a href=&quot;http://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964&lt;/a&gt;.</source>
          <target state="translated">리턴 된 문자열은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964의&lt;/a&gt; 2.1 절에 지정된 Kerberos 프린시 펄 이름의 단일 문자열 표현에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f1a1f202277c175f03aecd904b2c2e11e846fece" translate="yes" xml:space="preserve">
          <source>The returned subscriber delegates its &lt;a href=&quot;httpresponse.bodysubscriber#getBody()&quot;&gt;&lt;code&gt;getBody()&lt;/code&gt;&lt;/a&gt; method to the downstream subscriber.</source>
          <target state="translated">반환 된 구독자는 &lt;a href=&quot;httpresponse.bodysubscriber#getBody()&quot;&gt; &lt;code&gt;getBody()&lt;/code&gt; &lt;/a&gt; 메서드를 다운 스트림 구독자 에게 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="65a647177496c8d5054ff3cb3925fa8f89b66ac7" translate="yes" xml:space="preserve">
          <source>The returned system identifier is always &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">반환 된 시스템 식별자는 항상 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0df4196fa6df65f0d8f0e826fb8a455f9827860" translate="yes" xml:space="preserve">
          <source>The returned value can be different from the &lt;code&gt;SecureRandomParameters&lt;/code&gt; object passed into a &lt;code&gt;getInstance&lt;/code&gt; method, but it cannot change during the lifetime of this &lt;code&gt;SecureRandom&lt;/code&gt; object.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;getInstance&lt;/code&gt; 메서드에 전달 된 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 개체 와 다를 수 있지만이 &lt;code&gt;SecureRandom&lt;/code&gt; 개체 의 수명 동안 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="655c3437b11ed617a579abf2fa9ff34b511b4b98" translate="yes" xml:space="preserve">
          <source>The returned value consists of a quote ('&quot;'), a sequence of characters corresponding to the characters of &lt;code&gt;s&lt;/code&gt;, and another quote. Characters in &lt;code&gt;s&lt;/code&gt; appear unchanged within the returned value except:</source>
          <target state="translated">반환 된 값은 &lt;code&gt;s&lt;/code&gt; 의 문자에 해당하는 일련의 문자 인 따옴표 ( ' &quot;')로 구성됩니다. 및 다른 따옴표로 구성됩니다. &lt;code&gt;s&lt;/code&gt; 의 문자는 다음을 제외하고 반환 된 값 내에서 변경되지 않은 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e492071d6dc92885ae84e7ac0ea668a268c3161b" translate="yes" xml:space="preserve">
          <source>The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of the buffer's data by the time that an invocation of this method returns.</source>
          <target state="translated">기본 오퍼레이팅 시스템이이 메소드 호출이 리턴 될 때까지 일부 버퍼 데이터를 페이징 아웃했을 수 있으므로 리턴 된 값은 보증이 아니라 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="87f3edcf1a031a34eab7ff35463ec7ac1c19de38" translate="yes" xml:space="preserve">
          <source>The returned value may be unmodifiable. If it is modifiable, changing it has no effect on this ObjectName.</source>
          <target state="translated">반환 된 값을 수정할 수 없습니다. 수정 가능한 경우 변경해도이 ObjectName에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ea1bfc4ee9b99c8f427dd634732ade255abe11d" translate="yes" xml:space="preserve">
          <source>The returned value may or may not be identical to &lt;code&gt;name&lt;/code&gt;. Calling this method twice with the same parameters may return the same object or two equal but not identical objects.</source>
          <target state="translated">반환 값은 &lt;code&gt;name&lt;/code&gt; 과 같거나 같지 않을 수 있습니다 . 동일한 매개 변수를 사용하여이 메소드를 두 번 호출하면 동일한 오브젝트 또는 동일하지만 동일하지 않은 두 오브젝트를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d51a48610ecce7391c6a83d6ba1a127d5dea1ff" translate="yes" xml:space="preserve">
          <source>The returned value represents the maximum column size for the given parameter. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. 0 is returned for data types where the column size is not applicable.</source>
          <target state="translated">반환 된 값은 주어진 매개 변수의 최대 열 크기를 나타냅니다. 숫자 데이터의 경우 이것은 최대 정밀도입니다. 문자 데이터의 경우 문자 길이입니다. datetime 데이터 유형의 경우 이것은 문자열 표현의 문자 길이입니다 (초 분수 구성 요소의 최대 허용 정밀도 가정). 이진 데이터의 경우 길이 (바이트)입니다. ROWID 데이터 유형의 경우 길이 (바이트)입니다. 열 크기를 적용 할 수없는 데이터 유형에 대해서는 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f40fbf63a5d2b277e35cf6ac3daf6ae7ec5474ac" translate="yes" xml:space="preserve">
          <source>The returned versions remain available and valid for the lifetime of the application. A dynamic provider may increase the set of versions as more data becomes available.</source>
          <target state="translated">반환 된 버전은 응용 프로그램 수명 동안 유효하고 유효합니다. 더 많은 데이터를 사용할 수있게되면 동적 공급자가 버전 집합을 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37fa82a55b240bd660f3e3d8cef39a1191e27f3f" translate="yes" xml:space="preserve">
          <source>The returned zone IDs remain available and valid for the lifetime of the application. A dynamic provider may increase the set of IDs as more data becomes available.</source>
          <target state="translated">반환 된 영역 ID는 응용 프로그램 수명 동안 사용 가능하고 유효합니다. 더 많은 데이터를 사용할 수있게되면 동적 공급자가 ID 집합을 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce5b7000f5b21a055cbac4854384a1e8094660e0" translate="yes" xml:space="preserve">
          <source>The returns a normalized &lt;code&gt;ZoneId&lt;/code&gt; that can be used in place of this ID. The result will have &lt;code&gt;ZoneRules&lt;/code&gt; equivalent to those returned by this object, however the ID returned by &lt;code&gt;getId()&lt;/code&gt; may be different.</source>
          <target state="translated">이 ID 대신 사용할 수 있는 정규화 된 &lt;code&gt;ZoneId&lt;/code&gt; 를 반환합니다 . 결과는 이 객체가 리턴 한 것과 동일한 &lt;code&gt;ZoneRules&lt;/code&gt; 를 가지지 만 &lt;code&gt;getId()&lt;/code&gt; 가 리턴 한 ID는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36bbd913f2a35dc1f4e96953ef2e235b576a9f17" translate="yes" xml:space="preserve">
          <source>The reverberation parameters provided by &lt;code&gt;ReverbType&lt;/code&gt; consist of the delay time and intensity of early reflections, the delay time and intensity of late reflections, and an overall decay time. Early reflections are the initial individual low-order reflections of the direct signal off the surfaces in the room. The late Reflections are the dense, high-order reflections that characterize the room's reverberation. The delay times for the start of these two reflection types give the listener a sense of the overall size and complexity of the room's shape and contents. The larger the room, the longer the reflection delay times. The early and late reflections' intensities define the gain (in decibels) of the reflected signals as compared to the direct signal. These intensities give the listener an impression of the absorptive nature of the surfaces and objects in the room. The decay time defines how long the reverberation takes to exponentially decay until it is no longer perceptible (&quot;effective zero&quot;). The larger and less absorbent the surfaces, the longer the decay time.</source>
          <target state="translated">에 의해 제공되는 잔향 파라미터 &lt;code&gt;ReverbType&lt;/code&gt; 이초기 반사의 지연 시간 및 강도, 늦은 반사의 지연 시간 및 강도 및 전체 감쇠 시간으로 구성됩니다. 초기 반사는 실내 표면에서 직접 신호의 초기 개별 하위 반사입니다. 늦은 반사는 방의 잔향을 특징 짓는 조밀하고 고차 반사입니다. 이 두 가지 반사 유형의 시작에 대한 지연 시간은 청취자에게 방의 모양과 내용의 전체 크기와 복잡성을 감지합니다. 방이 클수록 반사 지연 시간이 길어집니다. 초기 및 후기 반사 강도는 직접 신호와 비교하여 반사 된 신호의 게인 (데시벨)을 정의합니다. 이러한 강도는 청취자에게 방의 표면과 물체의 흡수성에 대한 인상을줍니다.감쇠 시간은 잔향이 더 이상 감지 할 수 없을 때까지 ( &quot;유효 제로&quot;) 지수 적으로 감쇠하는 데 걸리는 시간을 정의합니다. 표면의 흡수가 클수록 감쇠 시간이 길어집니다.</target>
        </trans-unit>
        <trans-unit id="b9b984f130a384b4996712c3a39651b3107b8463" translate="yes" xml:space="preserve">
          <source>The reverberation parameters provided by &lt;code&gt;ReverbType&lt;/code&gt; consist of the delay time and intensity of early reflections, the delay time and intensity of late reflections, and an overall decay time. Early reflections are the initial individual low-order reflections of the direct signal off the surfaces in the room. The late reflections are the dense, high-order reflections that characterize the room's reverberation. The delay times for the start of these two reflection types give the listener a sense of the overall size and complexity of the room's shape and contents. The larger the room, the longer the reflection delay times. The early and late reflections' intensities define the gain (in decibels) of the reflected signals as compared to the direct signal. These intensities give the listener an impression of the absorptive nature of the surfaces and objects in the room. The decay time defines how long the reverberation takes to exponentially decay until it is no longer perceptible (&quot;effective zero&quot;). The larger and less absorbent the surfaces, the longer the decay time.</source>
          <target state="translated">&lt;code&gt;ReverbType&lt;/code&gt; 에서 제공하는 잔향 매개 변수지연 시간과 초기 반사의 강도, 지연 시간과 후기 반사의 강도, 전체 감쇠 시간으로 구성됩니다. 초기 반사는 실내 표면에서 직접 신호의 초기 개별 저차 반사입니다. 후기 반사는 방의 잔향을 특징 짓는 고밀도의 고차 반사입니다. 이 두 가지 반사 유형의 시작에 대한 지연 시간은 청취자에게 방의 모양과 내용의 전체적인 크기와 복잡성에 대한 감각을 제공합니다. 공간이 클수록 반사 지연 시간이 길어집니다. 초기 및 후기 반사의 강도는 직접 신호와 비교하여 반사 된 신호의 이득 (데시벨 단위)을 정의합니다. 이러한 강도는 청취자에게 실내 표면과 물체의 흡수 특성에 대한 인상을줍니다.감쇠 시간은 잔향이 더 이상 인식 할 수 없을 때까지 기하 급수적으로 감쇠하는 데 걸리는 시간을 정의합니다 ( &quot;유효 제로&quot;). 표면이 크고 흡수성이 적을수록 붕괴 시간이 길어집니다.</target>
        </trans-unit>
        <trans-unit id="2c7630f4923d39844ce7c44d0bac8d9004f68f3b" translate="yes" xml:space="preserve">
          <source>The reverse mapping is illustrated by the following change to the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface:</source>
          <target state="translated">리버스 맵핑은 &lt;code&gt;ModuleMXBean&lt;/code&gt; 인터페이스 에 대한 다음 변경으로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="4492356e6ba71c3c852cf9939e4f74a8d7a573fe" translate="yes" xml:space="preserve">
          <source>The revocation status of the certificate could not be determined.</source>
          <target state="translated">인증서의 해지 상태를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="119ef6d6012154c68b97d88f0635440451102e2a" translate="yes" xml:space="preserve">
          <source>The right inset of the border.</source>
          <target state="translated">테두리의 오른쪽 삽입.</target>
        </trans-unit>
        <trans-unit id="898927d0724755ab7db22d60f2744e42ca622381" translate="yes" xml:space="preserve">
          <source>The right or bottom component.</source>
          <target state="translated">오른쪽 또는 아래쪽 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="315fe5d039365e7227ec2a4b72b363b039df2bd0" translate="yes" xml:space="preserve">
          <source>The root class from which all event state objects shall be derived.</source>
          <target state="translated">모든 이벤트 상태 객체가 파생되는 루트 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="f75abe063c2e29766eb9c4fdf22b1d6554824455" translate="yes" xml:space="preserve">
          <source>The root event class for all AWT events.</source>
          <target state="translated">모든 AWT 이벤트에 대한 루트 이벤트 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7d1ec967c823196dca7258196b828781578926c4" translate="yes" xml:space="preserve">
          <source>The root event class for all AWT events. This class and its subclasses supersede the original java.awt.Event class. Subclasses of this root AWTEvent class defined outside of the java.awt.event package should define event ID values greater than the value defined by RESERVED_ID_MAX.</source>
          <target state="translated">모든 AWT 이벤트에 대한 루트 이벤트 클래스입니다. 이 클래스와 그 서브 클래스는 원래 java.awt.Event 클래스를 대체합니다. java.awt.event 패키지 외부에 정의 된이 루트 AWTEvent 클래스의 서브 클래스는 RESERVED_ID_MAX에 정의 된 값보다 큰 이벤트 ID 값을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8aa66cdd224b61725fb7c7f0951cf9aec6e9c9d4" translate="yes" xml:space="preserve">
          <source>The root event class for all component-level input events.</source>
          <target state="translated">모든 구성 요소 수준 입력 이벤트에 대한 루트 이벤트 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1b9b7f573454243c391475013425ee8ac3d59559" translate="yes" xml:space="preserve">
          <source>The root event class for all component-level input events. Input events are delivered to listeners before they are processed normally by the source where they originated. This allows listeners and component subclasses to &quot;consume&quot; the event so that the source will not process them in their default manner. For example, consuming mousePressed events on a Button component will prevent the Button from being activated.</source>
          <target state="translated">모든 구성 요소 수준 입력 이벤트에 대한 루트 이벤트 클래스입니다. 입력 이벤트는 시작된 소스에서 정상적으로 처리되기 전에 리스너에게 전달됩니다. 이를 통해 리스너와 컴포넌트 서브 클래스가 이벤트를 &quot;소비&quot;할 수 있으므로 소스가 기본 방식으로 이벤트를 처리하지 않습니다. 예를 들어 Button 구성 요소에서 mousePressed 이벤트를 사용하면 Button이 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e57f0a87b56114c25a3425b649a0fc72c9816ae3" translate="yes" xml:space="preserve">
          <source>The root interface in the</source>
          <target state="translated">의 루트 인터페이스</target>
        </trans-unit>
        <trans-unit id="d09865ec5ef96bb1232174ca8eb33da20d24915d" translate="yes" xml:space="preserve">
          <source>The root is a leaf node</source>
          <target state="translated">루트는 리프 노드입니다.</target>
        </trans-unit>
        <trans-unit id="72cdacd0ec76595acc856611a3b1130c6dda01a1" translate="yes" xml:space="preserve">
          <source>The root is collapsed</source>
          <target state="translated">뿌리가 무너져</target>
        </trans-unit>
        <trans-unit id="59bb7a92b878735bfc6bdf6731b3391ad71122f8" translate="yes" xml:space="preserve">
          <source>The root node has a node name of the empty string (&quot;&quot;). Every other node has an arbitrary node name, specified at the time it is created. The only restrictions on this name are that it cannot be the empty string, and it cannot contain the slash character ('/').</source>
          <target state="translated">루트 노드에는 빈 문자열 ( &quot;&quot;)의 노드 이름이 있습니다. 다른 모든 노드에는 생성시 지정된 임의의 노드 이름이 있습니다. 이 이름에 대한 유일한 제한 사항은 빈 문자열이 될 수 없으며 슬래시 문자 ( '/')를 포함 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c4a2a95c5adac20299823e2ab805439c46a7560" translate="yes" xml:space="preserve">
          <source>The root node has an absolute path name of &lt;code&gt;&quot;/&quot;&lt;/code&gt;. Children of the root node have absolute path names of &lt;code&gt;&quot;/&quot; + &lt;/code&gt;</source>
          <target state="translated">루트 노드의 절대 경로 이름은 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 입니다. 루트 노드의 자식에는 절대 경로 이름이 &lt;code&gt;&quot;/&quot; + &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d033ca267a4e43656fa30a33c122a68a94a7f29" translate="yes" xml:space="preserve">
          <source>The root node of the &lt;code&gt;NodeIterator&lt;/code&gt;, as specified when it was created.</source>
          <target state="translated">생성시 지정된 &lt;code&gt;NodeIterator&lt;/code&gt; 의 루트 노드입니다 .</target>
        </trans-unit>
        <trans-unit id="d6f015d10efdbb0ad4a1e372a60c869566bb49e0" translate="yes" xml:space="preserve">
          <source>The root object is completely restored when all of its fields and the objects it references are completely restored. At this point the object validation callbacks are executed in order based on their registered priorities. The callbacks are registered by objects (in the readObject special methods) as they are individually restored.</source>
          <target state="translated">루트 오브젝트는 모든 필드와 참조하는 오브젝트가 완전히 복원되면 완전히 복원됩니다. 이 시점에서 객체 유효성 검사 콜백은 등록 된 우선 순위에 따라 순서대로 실행됩니다. 콜백은 개별적으로 복원 될 때 객체 (readObject 특수 메소드에서)에 의해 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="a2dd63def1d3b47ca894c952456612a156d812ba" translate="yes" xml:space="preserve">
          <source>The row header child.</source>
          <target state="translated">행 헤더 하위입니다.</target>
        </trans-unit>
        <trans-unit id="7abd29b02efd947317ce37795d7811a15d2cbbad" translate="yes" xml:space="preserve">
          <source>The row header child. Default is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">행 헤더 하위입니다. 기본값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2605996690cb3e7a1bcd3ac39232dc16f382f39c" translate="yes" xml:space="preserve">
          <source>The row header, if present and visible, gets its preferred width and the viewport's height.</source>
          <target state="translated">행 헤더가 있고 보이는 경우 선호하는 너비와 뷰포트의 높이를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="638fc291740e16e3557281ff224cfb954c40e4a5" translate="yes" xml:space="preserve">
          <source>The rules about the first class defined in a package determining the set of certificates for the package, and the restrictions on class names are identical to those specified in the documentation for &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-java.security.ProtectionDomain-&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지에 대한 인증서 세트를 결정하는 패키지에 정의 된 첫 번째 클래스에 대한 규칙 및 클래스 이름에 대한 제한은 &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-java.security.ProtectionDomain-&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 지정된 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c634f0f52823012e70f8192869edd96115163537" translate="yes" xml:space="preserve">
          <source>The rules about the first class defined in a package determining the set of certificates for the package, the restrictions on class names, and the defined package of the class are identical to those specified in the documentation for &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지에 대한 인증서 집합, 클래스 이름에 대한 제한 사항 및 클래스의 정의 된 패키지를 결정하는 패키지에 정의 된 첫 번째 클래스에 대한 규칙은 &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 지정된 규칙과 동일합니다. , int, ProtectionDomain) .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
