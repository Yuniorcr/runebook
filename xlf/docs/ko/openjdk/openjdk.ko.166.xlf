<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="d20e6c840d9627a8eaa7891d9565907ed4a7abbb" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading from the stream and restoring the classes fields. It may call in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields. The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.</source>
          <target state="translated">readObject 메소드는 스트림에서 읽고 클래스 필드를 복원합니다. 객체의 비 정적 및 비 일시적 필드를 복원하기위한 기본 메커니즘을 호출하기 위해 in.defaultReadObject를 호출 할 수 있습니다. defaultReadObject 메소드는 스트림의 정보를 사용하여 스트림에 저장된 오브젝트의 필드를 현재 오브젝트의 해당 이름이 지정된 필드에 지정합니다. 이것은 클래스가 새로운 필드를 추가하도록 진화 한 경우를 처리합니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. writeObject 메소드를 사용하거나 DataOutput이 지원하는 기본 데이터 유형의 메소드를 사용하여 개별 필드를 ObjectOutputStream에 기록하여 상태가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1a89c7b63eeec0e71ccea53ce7c51271148781b8" translate="yes" xml:space="preserve">
          <source>The readObjectNoData method is responsible for initializing the state of the object for its particular class in the event that the serialization stream does not list the given class as a superclass of the object being deserialized. This may occur in cases where the receiving party uses a different version of the deserialized instance's class than the sending party, and the receiver's version extends classes that are not extended by the sender's version. This may also occur if the serialization stream has been tampered; hence, readObjectNoData is useful for initializing deserialized objects properly despite a &quot;hostile&quot; or incomplete source stream.</source>
          <target state="translated">readObjectNoData 메소드는 직렬화 스트림이 지정된 클래스를 직렬화 해제중인 오브젝트의 수퍼 클래스로 나열하지 않는 경우 특정 클래스의 오브젝트 상태를 초기화합니다. 이는 수신 측이 전송 측과 다른 버전의 직렬화 해제 인스턴스 클래스를 사용하고 수신자의 버전이 송신자 버전이 확장하지 않은 클래스를 확장하는 경우에 발생할 수 있습니다. 직렬화 스트림이 변조 된 경우에도 발생할 수 있습니다. 따라서 readObjectNoData는 &quot;적대적&quot;또는 불완전한 소스 스트림에도 불구하고 역 직렬화 된 객체를 올바르게 초기화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db45e6393a0e6e733dd17719a250e994558a12bb" translate="yes" xml:space="preserve">
          <source>The readStreamHeader method is provided to allow subclasses to read and verify their own stream headers.</source>
          <target state="translated">readStreamHeader 메소드는 서브 클래스가 자신의 스트림 헤더를 읽고 확인할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f02ead4cd4d703a4fc4aec1b89640970265ef72c" translate="yes" xml:space="preserve">
          <source>The readStreamHeader method is provided to allow subclasses to read and verify their own stream headers. It reads and verifies the magic number and version number.</source>
          <target state="translated">readStreamHeader 메소드는 서브 클래스가 자체 스트림 헤더를 읽고 확인할 수 있도록 제공됩니다. 마법 번호와 버전 번호를 읽고 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b8970b91121ef6350ebd73016d3cfaeca16ee503" translate="yes" xml:space="preserve">
          <source>The reader associated with this console</source>
          <target state="translated">이 콘솔과 관련된 독자</target>
        </trans-unit>
        <trans-unit id="34e5f7ec6cf4640a064600b8a13abb578ea1e6fd" translate="yes" xml:space="preserve">
          <source>The reader can be configured by registering actions (of type &lt;code&gt;HTMLDocument.HTMLReader.TagAction&lt;/code&gt;) that describe how to handle the action. The idea behind the actions provided is that the most natural text editing operations can be provided if the element structure boils down to paragraphs with runs of some kind of style in them. Some things are more naturally specified structurally, so arbitrary structure should be allowed above the paragraphs, but will need to be edited with structural actions. The implication of this is that some of the HTML elements specified in the stream being parsed will be collapsed into attributes, and in some cases paragraphs will be synthesized. When HTML elements have been converted to attributes, the attribute key will be of type HTML.Tag, and the value will be of type AttributeSet so that no information is lost. This enables many of the existing actions to work so that the user can type input, hit the return key, backspace, delete, etc and have a reasonable result. Selections can be created, and attributes applied or removed, etc. With this in mind, the work done by the reader can be categorized into the following kinds of tasks:</source>
          <target state="translated">리더는 &lt;code&gt;HTMLDocument.HTMLReader.TagAction&lt;/code&gt; 유형의 조치를 등록하여 구성 할 수 있습니다.) 작업을 처리하는 방법을 설명합니다. 제공된 작업의이면에있는 아이디어는 요소 구조가 어떤 종류의 스타일로 실행되는 단락으로 요약되는 경우 가장 자연스러운 텍스트 편집 작업이 제공 될 수 있다는 것입니다. 어떤 것들은 구조적으로 더 자연스럽게 지정되므로 임의의 구조가 단락 위에 허용되어야하지만 구조적 조치로 편집해야합니다. 이것의 의미는 구문 분석되는 스트림에 지정된 일부 HTML 요소가 속성으로 축소되고 경우에 따라 단락이 합성된다는 것입니다. HTML 요소가 속성으로 변환 된 경우 속성 키는 HTML.Tag 유형이되고 값은 정보가 손실되지 않도록 AttributeSet 유형이됩니다. 이것은 사용자가 입력을 입력하고 리턴 키를 누르고,백 스페이스, 삭제 등을 수행하고 합리적인 결과를 얻습니다. 선택을 생성하고 속성을 적용하거나 제거 할 수 있습니다.이를 염두에두고 독자가 수행 한 작업을 다음과 같은 종류의 작업으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf210785560df5e3fd9338a81e883e6a91061562" translate="yes" xml:space="preserve">
          <source>The reader for this &lt;code&gt;CachedRowSet&lt;/code&gt; object will use</source>
          <target state="translated">이 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체 의 리더는</target>
        </trans-unit>
        <trans-unit id="6c69219580471766868b9f3ba0f7605623a45c33" translate="yes" xml:space="preserve">
          <source>The reader must not be operated on during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">터미널 스트림 작업을 실행하는 동안 리더를 작동시키지 않아야합니다. 그렇지 않으면 터미널 스트림 작업의 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ae6624a403eb2ed6a2939e1c276174b1b68bae0" translate="yes" xml:space="preserve">
          <source>The reader's default action for malformed-input and unmappable-character errors is to &lt;a href=&quot;../charset/codingerroraction#REPORT&quot;&gt;report&lt;/a&gt; them. When more control over the error handling is required, the constructor that takes a &lt;a href=&quot;../charset/charsetdecoder&quot;&gt;CharsetDecoder&lt;/a&gt; should be used.</source>
          <target state="translated">잘못된 입력 및 매핑 할 수없는 문자 오류에 대한 독자의 기본 조치는이를 &lt;a href=&quot;../charset/codingerroraction#REPORT&quot;&gt;보고&lt;/a&gt; 하는 것입니다. 오류 처리에 대한 추가 제어가 필요한 경우 &lt;a href=&quot;../charset/charsetdecoder&quot;&gt;CharsetDecoder&lt;/a&gt; 를 사용 하는 생성자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="453ec519eda3fcb734a7ed183e48753d77c803a1" translate="yes" xml:space="preserve">
          <source>The reader/writer facility provided by the &lt;code&gt;SyncProvider&lt;/code&gt; class is pluggable, allowing for the customization of data retrieval and updating. If a different concurrency control mechanism is desired, a different implementation of &lt;code&gt;SyncProvider&lt;/code&gt; can be plugged in using the method &lt;code&gt;setSyncProvider&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SyncProvider&lt;/code&gt; 클래스에서 제공하는 리더 / 라이터 기능 은 플러그 가능하므로 데이터 검색 및 업데이트를 사용자 정의 할 수 있습니다. 다른 동시성 제어 메커니즘이 필요한 경우 &lt;code&gt;setSyncProvider&lt;/code&gt; 메소드를 사용하여 다른 &lt;code&gt;SyncProvider&lt;/code&gt; 구현을 플러그인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8998e48671432cbbcd265dfa2ebdacbf0a22841c" translate="yes" xml:space="preserve">
          <source>The real paint behavior occurs naturally from the association that the component has with its parent container (the same container hosting this view).</source>
          <target state="translated">실제 페인트 동작은 구성 요소가 부모 컨테이너 (이 뷰를 호스팅하는 동일한 컨테이너)와의 연관성에서 자연스럽게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6634676b2a3890f259f108b85e360b357783a624" translate="yes" xml:space="preserve">
          <source>The real paint behavior occurs naturally from the association that the component has with its parent container (the same container hosting this view). This is implemented to do nothing.</source>
          <target state="translated">실제 페인트 동작은 구성 요소가 부모 컨테이너 (이 뷰를 호스팅하는 동일한 컨테이너)와의 연관성에서 자연스럽게 발생합니다. 이것은 아무것도하지 않도록 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="1937fc02231b146a373cfbbd353a2e3a9bef7353" translate="yes" xml:space="preserve">
          <source>The real source.</source>
          <target state="translated">진짜 소스.</target>
        </trans-unit>
        <trans-unit id="b9d32ae3ca8a166a78d846fc7aad0c5b1d696a11" translate="yes" xml:space="preserve">
          <source>The reason string</source>
          <target state="translated">이유 문자열</target>
        </trans-unit>
        <trans-unit id="c02940838e2a0e7c78ef96311f0f4a5d64f9e4e9" translate="yes" xml:space="preserve">
          <source>The reason that listeners created with &lt;code&gt;EventHandler&lt;/code&gt; have such a small footprint is that the &lt;code&gt;Proxy&lt;/code&gt; class, on which the &lt;code&gt;EventHandler&lt;/code&gt; relies, shares implementations of identical interfaces. For example, if you use the &lt;code&gt;EventHandler create&lt;/code&gt; methods to make all the &lt;code&gt;ActionListener&lt;/code&gt;s in an application, all the action listeners will be instances of a single class (one created by the &lt;code&gt;Proxy&lt;/code&gt; class). In general, listeners based on the &lt;code&gt;Proxy&lt;/code&gt; class require one listener class to be created per &lt;em&gt;listener type&lt;/em&gt; (interface), whereas the inner class approach requires one class to be created per &lt;em&gt;listener&lt;/em&gt; (object that implements the interface).</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 로 생성 된 리스너의 풋 프린트가 작은 이유 는 &lt;code&gt;EventHandler&lt;/code&gt; 가 의존 하는 &lt;code&gt;Proxy&lt;/code&gt; 클래스 가 동일한 인터페이스의 구현을 공유하기 때문입니다. 예를 들어, &lt;code&gt;EventHandler create&lt;/code&gt; 메서드를 사용 하여 응용 프로그램의 모든 &lt;code&gt;ActionListener&lt;/code&gt; 를 만드는 경우 모든 작업 리스너는 단일 클래스 ( &lt;code&gt;Proxy&lt;/code&gt; 클래스에서 만든 클래스)의 인스턴스가 됩니다. 일반적으로 &lt;code&gt;Proxy&lt;/code&gt; 클래스를 기반으로하는 리스너는 &lt;em&gt;리스너 유형&lt;/em&gt; (인터페이스) 당 하나의 리스너 클래스를 생성 해야하지만 내부 클래스 접근 방식에서는 &lt;em&gt;리스너&lt;/em&gt; 당 하나의 클래스를 생성해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; (인터페이스를 구현하는 객체).</target>
        </trans-unit>
        <trans-unit id="343e073c1a04a45f15bfaa37758a836c0b9ae1dd" translate="yes" xml:space="preserve">
          <source>The reason that listeners created with &lt;code&gt;EventHandler&lt;/code&gt; have such a small footprint is that the &lt;code&gt;Proxy&lt;/code&gt; class, on which the &lt;code&gt;EventHandler&lt;/code&gt; relies, shares implementations of identical interfaces. For example, if you use the &lt;code&gt;EventHandler&lt;/code&gt;&lt;code&gt;create&lt;/code&gt; methods to make all the &lt;code&gt;ActionListener&lt;/code&gt;s in an application, all the action listeners will be instances of a single class (one created by the &lt;code&gt;Proxy&lt;/code&gt; class). In general, listeners based on the &lt;code&gt;Proxy&lt;/code&gt; class require one listener class to be created per &lt;em&gt;listener type&lt;/em&gt; (interface), whereas the inner class approach requires one class to be created per &lt;em&gt;listener&lt;/em&gt; (object that implements the interface).</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 로 작성된 리스너의 공간이 작은 이유 는 &lt;code&gt;EventHandler&lt;/code&gt; 가 의존 하는 &lt;code&gt;Proxy&lt;/code&gt; 클래스 가 동일한 인터페이스의 구현을 공유하기 때문입니다. 예를 들어, &lt;code&gt;EventHandler&lt;/code&gt; &lt;code&gt;create&lt;/code&gt; 메소드를 사용 하여 애플리케이션에서 모든 &lt;code&gt;ActionListener&lt;/code&gt; 를 작성 하는 경우 모든 조치 리스너는 단일 클래스 ( &lt;code&gt;Proxy&lt;/code&gt; 클래스에 의해 작성된 것)의 인스턴스가 됩니다. 일반적으로 &lt;code&gt;Proxy&lt;/code&gt; 클래스를 기반으로하는 리스너는 &lt;em&gt;리스너 유형&lt;/em&gt; (인터페이스) 당 하나의 리스너 클래스를 작성 해야하지만 내부 클래스 접근 방식은 &lt;em&gt;리스너&lt;/em&gt; 당 하나의 클래스를 작성해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; (인터페이스를 구현하는 객체).</target>
        </trans-unit>
        <trans-unit id="4bcf2d174d6450c449f0d4b03a4ca6b52b25a266" translate="yes" xml:space="preserve">
          <source>The reason the validation algorithm failed.</source>
          <target state="translated">유효성 검증 알고리즘이 실패한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="fad799b782c71b721e74eb716a062272a08611cd" translate="yes" xml:space="preserve">
          <source>The reason to deny access can vary. For example, the requested permission might be of an incorrect type, contain an invalid value, or request access that is not allowed according to the security policy. Such information should be given whenever possible at the time the exception is thrown.</source>
          <target state="translated">액세스를 거부하는 이유는 다양 할 수 있습니다. 예를 들어 요청 된 권한의 유형이 잘못되었거나 유효하지 않은 값을 포함하거나 보안 정책에 따라 허용되지 않은 요청 액세스가있을 수 있습니다. 그러한 정보는 예외가 발생했을 때 가능할 때마다 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1aeeb073ceae77eaa12f37a803ff57f9b6861457" translate="yes" xml:space="preserve">
          <source>The receiving interface of &lt;code&gt;WebSocket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WebSocket&lt;/code&gt; 의 수신 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="19aa33a5763e532698ec85898ffde7fa19da36dd" translate="yes" xml:space="preserve">
          <source>The recommended approach to waiting is to check the condition being awaited in a &lt;code&gt;while&lt;/code&gt; loop around the call to &lt;code&gt;wait&lt;/code&gt;, as shown in the example below. Among other things, this approach avoids problems that can be caused by spurious wakeups.</source>
          <target state="translated">대기에 권장되는 방법은 아래 예제와 같이 &lt;code&gt;wait&lt;/code&gt; 호출 주위의 &lt;code&gt;while&lt;/code&gt; 루프 에서 대기중인 조건을 확인하는 것 입니다. 무엇보다도이 접근 방식은 가짜 깨우기로 인해 발생할 수있는 문제를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="8b540068386b3455f296a75095372235296b6e2b" translate="yes" xml:space="preserve">
          <source>The recommended usage is to use &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; to identify resources, then convert it into a &lt;a href=&quot;url&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; when it is time to access the resource. From that URL, you can either get the &lt;a href=&quot;urlconnection&quot;&gt;&lt;code&gt;URLConnection&lt;/code&gt;&lt;/a&gt; for fine control, or get directly the InputStream.</source>
          <target state="translated">권장되는 사용법은 &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 를 사용 하여 자원을 식별 한 다음 자원 에 액세스 할 때 &lt;a href=&quot;url&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt; 로 변환하는 것입니다. 해당 URL에서 세부 제어를 위해 &lt;a href=&quot;urlconnection&quot;&gt; &lt;code&gt;URLConnection&lt;/code&gt; &lt;/a&gt; 을 가져 오거나 InputStream을 직접 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="578396e39ec38d7bef97bc806ee34eccfc93aa26" translate="yes" xml:space="preserve">
          <source>The recommended way to transform a diagnostic command name into a MBean operation name is as follows:</source>
          <target state="translated">진단 명령 이름을 MBean 작업 이름으로 변환하는 권장 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4b6352f99070e472d8efe1d2a56870b1ae33835" translate="yes" xml:space="preserve">
          <source>The record class declaring this record component.</source>
          <target state="translated">이 레코드 구성 요소를 선언하는 레코드 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="58defc644c6b9584268a16fa887f610fbf3769e6" translate="yes" xml:space="preserve">
          <source>The recording is closed and all resources that are associated with the recording are released.</source>
          <target state="translated">녹음이 닫히고 녹음과 관련된 모든 리소스가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2687517b4d680e346376dafc9478b171de0e8a" translate="yes" xml:space="preserve">
          <source>The recording is recording data and an invocation of the &lt;a href=&quot;recording#stop()&quot;&gt;&lt;code&gt;Recording.stop()&lt;/code&gt;&lt;/a&gt; method will transition the recording to the &lt;code&gt;STOPPED&lt;/code&gt; state.</source>
          <target state="translated">기록은 데이터를 기록하고 &lt;a href=&quot;recording#stop()&quot;&gt; &lt;code&gt;Recording.stop()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하면 기록이 &lt;code&gt;STOPPED&lt;/code&gt; 상태 로 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c86b78d094fd89c1accafbcca74e0924941ef97" translate="yes" xml:space="preserve">
          <source>The recording is scheduled to start with a start time in the future.</source>
          <target state="translated">녹화는 미래의 시작 시간으로 시작하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1637c88eac1e949cc3286252e2a81aa6ec585cf9" translate="yes" xml:space="preserve">
          <source>The recording is stopped and is holding recorded data that can be dumped to disk.</source>
          <target state="translated">기록이 중지되고 디스크에 덤프 될 수있는 기록 된 데이터가 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="611441fb9860b54f9a8f66c2bf62fee1547405d0" translate="yes" xml:space="preserve">
          <source>The recording with the specified ID must be stopped before a stream can be opened. This restriction might be lifted in future releases.</source>
          <target state="translated">지정된 ID로 녹화를 중지해야 스트림을 열 수 있습니다. 이 제한은 향후 릴리스에서 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02d456a5b72dc15bc50cf4cbcbe8e2427ba00e2" translate="yes" xml:space="preserve">
          <source>The rectangular printable area is defined thus: The (x,y) origin is positioned at the top-left of the paper in portrait mode regardless of the orientation specified in the requesting context. For example a printable area for A4 paper in portrait or landscape orientation will have height &amp;gt; width.</source>
          <target state="translated">직사각형 인쇄 가능 영역은 다음과 같이 정의됩니다. (x, y) 원점은 요청 컨텍스트에 지정된 방향에 관계없이 세로 모드에서 용지의 왼쪽 상단에 배치됩니다. 예를 들어 세로 또는 가로 방향의 A4 용지의 인쇄 가능 영역은 높이&amp;gt; 너비를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="078eace4dd337040ba2ae72d27be838bc237864c" translate="yes" xml:space="preserve">
          <source>The red color component for the specified pixel, as an int.</source>
          <target state="translated">지정된 픽셀의 빨간색 구성 요소 (int)입니다.</target>
        </trans-unit>
        <trans-unit id="98a309e25e6dab75aafbad36b2cae3eb6daac137" translate="yes" xml:space="preserve">
          <source>The redefinition may change method bodies, the constant pool and attributes (unless explicitly prohibited). The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. The redefinition must not change the &lt;code&gt;NestHost&lt;/code&gt; or &lt;code&gt;NestMembers&lt;/code&gt; attributes. These restrictions may be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재정의는 메서드 본문, 상수 풀 및 속성을 변경할 수 있습니다 (명시 적으로 금지되지 않는 한). 재정의는 필드 또는 메서드를 추가, 제거 또는 이름 변경하거나 메서드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 재정의는 &lt;code&gt;NestHost&lt;/code&gt; 또는 &lt;code&gt;NestMembers&lt;/code&gt; 속성을 변경해서는 안됩니다 . 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 클래스 파일 바이트는 변환이 적용될 때까지 검사, 확인 및 설치되지 않으며 결과 바이트에 오류가있는 경우이 메서드는 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="6cf742cf21d433441fd0b0bc61621152f8db92ae" translate="yes" xml:space="preserve">
          <source>The redefinition may change method bodies, the constant pool and attributes. The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재정의는 메소드 본문, 상수 풀 및 속성을 변경할 수 있습니다. 재정의는 필드 나 메소드를 추가, 제거 또는 이름 변경하거나 메소드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 변환이 적용될 때까지 클래스 파일 바이트는 확인, 확인 및 설치되지 않습니다. 결과 바이트에 오류가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6f19c83b6a43c97e8d1cefd627e0b3c8dadfded2" translate="yes" xml:space="preserve">
          <source>The reference &lt;code&gt;x&lt;/code&gt; must be convertible to the first parameter type of the target.</source>
          <target state="translated">참조 &lt;code&gt;x&lt;/code&gt; 는 대상의 첫 번째 매개 변수 유형으로 변환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="44017fc6a35a5f9dd8fcf726c29aa2e0e60bb2ce" translate="yes" xml:space="preserve">
          <source>The reference implementation (RI) provides two synchronization providers.</source>
          <target state="translated">참조 구현 (RI)은 두 개의 동기화 공급자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5409eeca3c33981649af20f4b7e7f4d34b54dae8" translate="yes" xml:space="preserve">
          <source>The reference implementation is targeted to ship with J2SE 1.5, which will include an additional resource file that may be edited by hand. Here is an example of the properties file included in the reference implementation:</source>
          <target state="translated">참조 구현은 직접 편집 할 수있는 추가 리소스 파일을 포함하는 J2SE 1.5와 함께 제공됩니다. 다음은 참조 구현에 포함 된 속성 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="60999b6f0306efbef13e0ce2d4acd07ba041bfaf" translate="yes" xml:space="preserve">
          <source>The reference implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface provided by Oracle Corporation is a standard implementation. Developers may use this implementation just as it is, they may extend it, or they may choose to write their own implementations of this interface.</source>
          <target state="translated">Oracle Corporation에서 제공 하는 &lt;code&gt;CachedRowSet&lt;/code&gt; 인터페이스 의 참조 구현은 표준 구현입니다. 개발자는이 구현을 그대로 사용하거나 확장하거나이 인터페이스의 자체 구현을 작성하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdbc6f393391fdc2aa74409e53d076bab2c56284" translate="yes" xml:space="preserve">
          <source>The reference implementation of the &lt;code&gt;JdbcRowSet&lt;/code&gt; interface, &lt;code&gt;JdbcRowSetImpl&lt;/code&gt;, provides an implementation of the default constructor. A new instance is initialized with default values, which can be set with new values as needed. A new instance is not really functional until its &lt;code&gt;execute&lt;/code&gt; method is called. In general, this method does the following:</source>
          <target state="translated">의 레퍼런스 구현 &lt;code&gt;JdbcRowSet&lt;/code&gt; 인터페이스, &lt;code&gt;JdbcRowSetImpl&lt;/code&gt; 는 기본 생성자의 구현을 제공합니다. 새 인스턴스는 기본값으로 초기화되며 필요에 따라 새 값으로 설정할 수 있습니다. 새 인스턴스는 &lt;code&gt;execute&lt;/code&gt; 메서드가 호출 될 때까지 실제로 작동하지 않습니다 . 일반적으로이 방법은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1bef56dc5a152e5cab8e0b183e0324bc9dbed6ee" translate="yes" xml:space="preserve">
          <source>The reference implementation of this method returns the MIME type &lt;code&gt;String&lt;/code&gt; of the specified &lt;code&gt;DataFlavor&lt;/code&gt; prefixed with &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt;.</source>
          <target state="translated">이 메서드의 참조 구현은 &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt; 접두사가 붙은 지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 의 MIME 유형 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0db6d72998455f6d8d159947d15deb882e4e6208" translate="yes" xml:space="preserve">
          <source>The reference implementation of this method returns the specified MIME type &lt;code&gt;String&lt;/code&gt; prefixed with &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt;.</source>
          <target state="translated">이 메서드의 참조 구현은 &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt; 접두사가 붙은 지정된 MIME 유형 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3c96b6a18efdd8f02c853b851fa382edd202cc59" translate="yes" xml:space="preserve">
          <source>The reference is parsed into the scheme, authority, path, query and fragment parts. If the path component is empty and the scheme, authority, and query components are undefined, then the new URL is a reference to the current document. Otherwise, the fragment and query parts present in the spec are used in the new URL.</source>
          <target state="translated">참조는 체계, 권한, 경로, 쿼리 및 조각 부분으로 구문 분석됩니다. 경로 구성 요소가 비어 있고 구성표, 권한 및 조회 구성 요소가 정의되지 않은 경우 새 URL은 현재 문서에 대한 참조입니다. 그렇지 않으면 사양에있는 조각 및 쿼리 부분이 새 URL에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1b7f522e51adfd670896cc10d510ac4a355747" translate="yes" xml:space="preserve">
          <source>The reference to the module's content</source>
          <target state="translated">모듈 콘텐츠에 대한 참조</target>
        </trans-unit>
        <trans-unit id="2cf99cd156e1535ee0739b3761f44ba4ad8f59a0" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by extension from the other type definition if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and at least one of the &lt;em&gt;derivation methods&lt;/em&gt; involved is an extension.</source>
          <target state="translated">참조 형식 정의에서 {base type definition} 속성을 따라 다른 형식 정의에 재귀 적으로 도달 할 수 있고 관련된 &lt;em&gt;파생 메서드&lt;/em&gt; 중 하나 이상이 확장 인 경우 참조 형식 정의는 다른 형식 정의의 확장에 의해 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="d289101b23ccf25d80de6a72dd72816e3bcb1157" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by list from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; or &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt;, T2 is derived from the other type definition by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt;, T1 has {variety} &lt;em&gt;list&lt;/em&gt;, and T2 is the {item type definition}. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</source>
          <target state="translated">참조 유형 정의는 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 또는 &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt; 에 의해 T1에서 파생 된 참조 유형 정의와 같이 두 개의 유형 정의 T1 및 T2가있는 경우 다른 유형 정의의 목록에 의해 파생되며 , T2는 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 에 의해 다른 유형 정의에서 파생되고 , T1은 {variety} &lt;em&gt;목록&lt;/em&gt; , T2는 {item type definition}입니다. T1은 참조 유형 정의와 같을 수 있고 T2는 다른 유형 정의와 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dffb6e6d8b2d6f55eafb2e232eb84ee4de39afa8" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by restriction from the other type definition if the other type definition is the same as the reference type definition, or if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and all the &lt;em&gt;derivation methods&lt;/em&gt; involved are restriction.</source>
          <target state="translated">참조 유형 정의는 다른 유형 정의가 참조 유형 정의와 동일하거나 참조 유형 정의의 {base type definition} 속성을 따라 다른 유형 정의에 재귀 적으로 도달 할 수있는 경우 다른 유형 정의의 제한에 의해 파생됩니다. , 관련된 모든 &lt;em&gt;파생 방법&lt;/em&gt; 은 제한입니다.</target>
        </trans-unit>
        <trans-unit id="16ef2fe88de2d7e30fdc46db81d300b65bcac937" translate="yes" xml:space="preserve">
          <source>The reference type definition is derived by union from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; or &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt;, T2 is derived from the other type definition by &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt;, T1 has {variety} &lt;em&gt;union&lt;/em&gt;, and one of the {member type definitions} is T2. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</source>
          <target state="translated">참조 유형 정의가 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 또는 &lt;code&gt;DERIVATION_EXTENSION&lt;/code&gt; 에 의해 T1에서 파생되는 것과 같이 두 개의 유형 정의 T1 및 T2가 존재하는 경우 참조 유형 정의는 다른 유형 정의에서 통합에 의해 파생되며, T2는 &lt;code&gt;DERIVATION_RESTRICTION&lt;/code&gt; 에 의해 다른 유형 정의에서 파생되고 , T1은 {variety} &lt;em&gt;union&lt;/em&gt; 이며 {member type definitions} 중 하나는 T2입니다. T1은 참조 유형 정의와 같을 수 있고 T2는 다른 유형 정의와 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27a0672b9281e7b40b24731935d7c4c815d57f66" translate="yes" xml:space="preserve">
          <source>The referral context is created using &lt;code&gt;env&lt;/code&gt; as its environment properties. This method should be used instead of the no-arg overloaded form when the caller needs to use different environment properties for the referral context. It might need to do this, for example, when it needs to supply different authentication information to the referred server in order to create the referral context.</source>
          <target state="translated">참조 컨텍스트는 환경 특성으로 &lt;code&gt;env&lt;/code&gt; 를 사용하여 작성 됩니다. 호출자가 참조 컨텍스트에 대해 다른 환경 속성을 사용해야하는 경우 인수가없는 오버로드 된 양식 대신이 메소드를 사용해야합니다. 예를 들어, 참조 컨텍스트를 작성하기 위해 참조 된 서버에 다른 인증 정보를 제공해야하는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4ce274ab6ae3f0c9ee72f8b65f07fb79d7e2a06" translate="yes" xml:space="preserve">
          <source>The region of interest is defined by the bounding box of the source &lt;code&gt;Image&lt;/code&gt;. This bounding box is specified in Image Space, which is the &lt;code&gt;Image&lt;/code&gt; object's local coordinate system.</source>
          <target state="translated">관심 영역은 소스 &lt;code&gt;Image&lt;/code&gt; 의 경계 상자로 정의됩니다 . 이 경계 상자는 &lt;code&gt;Image&lt;/code&gt; 객체의 로컬 좌표계 인 Image Space에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae7c56b2cdef8fa8f60172c89227929f50be69e" translate="yes" xml:space="preserve">
          <source>The region of the image to be written is determined by first intersecting the actual bounds of the image with the rectangle specified by &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt;, if any. If the resulting rectangle has a width or height of zero, the writer will throw an &lt;code&gt;IIOException&lt;/code&gt;. If the intersection is non-empty, writing will commence with the first subsampled pixel and include additional pixels within the intersected bounds according to the horizontal and vertical subsampling factors specified by &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기록 될 이미지의 영역은 먼저 이미지의 실제 경계를 &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt; 에 지정된 사각형 (있는 경우)과 교차하여 결정됩니다 . 결과 사각형의 너비 또는 높이가 0이면 작성기는 &lt;code&gt;IIOException&lt;/code&gt; 을 발생 시킵니다. 교차점이 비어 있지 않으면 쓰기가 첫 번째 서브 샘플링 된 픽셀부터 시작되고 &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에서&lt;/a&gt; 지정한 수평 및 수직 서브 샘플링 인자에 따라 교차 된 경계 내에 추가 픽셀이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0ee23ed794b80c251d3a1fe843993862775ce5a" translate="yes" xml:space="preserve">
          <source>The region of the image to be written is determined by first intersecting the actual bounds of the image with the rectangle specified by &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt;, if any. If the resulting rectangle has a width or height of zero, the writer will throw an &lt;code&gt;IIOException&lt;/code&gt;. If the intersection is non-empty, writing will commence with the first subsampled pixel and include additional pixels within the intersected bounds according to the horizontal and vertical subsampling factors specified by &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기록 될 이미지의 영역은 이미지의 실제 경계를 &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt; 에 의해 지정된 사각형 (있는 경우)과 먼저 교차시킴으로써 결정됩니다 . 결과 사각형의 너비 또는 높이가 0이면 작성기는 &lt;code&gt;IIOException&lt;/code&gt; 을 발생 시킵니다. 교차점이 비어 있지 않으면 쓰기는 첫 번째 서브 샘플링 된 픽셀로 시작하고 &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 의해 지정된 수평 및 수직 서브 샘플링 요소에 따라 교차 된 경계 내에 추가 픽셀을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="bf75c137f4d08f499b676efedda08b261ecc10e0" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The two-argument &lt;a href=&quot;#lock(A,java.nio.channels.CompletionHandler)&quot;&gt;&lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. If a lock that overlaps the requested region is already held by this Java virtual machine, or this method has been invoked to lock an overlapping region and that operation has not completed, then this method throws &lt;a href=&quot;overlappingfilelockexception&quot;&gt;&lt;code&gt;OverlappingFileLockException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 은 실제 기본 파일 내에 포함되거나 겹칠 필요가 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역이 처음에 파일의 끝을 포함하고 파일이 영역을 넘어서 커지면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일의 크기가 커질 것으로 예상되고 전체 파일에 대한 잠금이 필요한 경우 0에서 시작하고 예상되는 파일의 최대 크기보다 작지 않은 영역을 잠 가야합니다. 두 인수 &lt;a href=&quot;#lock(A,java.nio.channels.CompletionHandler)&quot;&gt; &lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메서드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다.. 요청 된 영역과 겹치는 잠금이 이미이 JVM (Java Virtual Machine)에 의해 유지되거나 겹치는 영역을 잠그기 위해이 메소드가 호출되었으며 해당 작업이 완료되지 않은 경우이 메소드는 &lt;a href=&quot;overlappingfilelockexception&quot;&gt; &lt;code&gt;OverlappingFileLockException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="412cd087a882e3390f6eb99cb3444e0f99865817" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The two-argument &lt;a href=&quot;asynchronousfilechannel#lock-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. If a lock that overlaps the requested region is already held by this Java virtual machine, or this method has been invoked to lock an overlapping region and that operation has not completed, then this method throws &lt;a href=&quot;overlappingfilelockexception&quot;&gt;&lt;code&gt;OverlappingFileLockException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 2 인수 &lt;a href=&quot;asynchronousfilechannel#lock-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다.. 요청 된 영역과 겹치는 잠금이이 Java 가상 머신에 의해 이미 보유되어 있거나 겹치는 영역을 잠그기 위해이 메소드가 호출되었고 조작이 완료되지 않은 경우이 메소드는 &lt;a href=&quot;overlappingfilelockexception&quot;&gt; &lt;code&gt;OverlappingFileLockException&lt;/code&gt; 을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="7f8ccadc40b179a069619b37209e7a82323388a3" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;#lock()&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 은 실제 기본 파일 내에 포함되거나 겹칠 필요가 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역이 처음에 파일의 끝을 포함하고 파일이 영역을 넘어서 커지면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일의 크기가 커질 것으로 예상되고 전체 파일에 대한 잠금이 필요한 경우 0에서 시작하고 예상되는 파일의 최대 크기보다 작지 않은 영역을 잠 가야합니다. 인수가없는 &lt;a href=&quot;#lock()&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 메서드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="6cff2d7fbc06e1a140db665b0a54e775297aaed1" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;#tryLock()&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 은 실제 기본 파일 내에 포함되거나 겹칠 필요가 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역이 처음에 파일의 끝을 포함하고 파일이 영역을 넘어서 커지면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일의 크기가 커질 것으로 예상되고 전체 파일에 대한 잠금이 필요한 경우 0에서 시작하고 예상되는 파일의 최대 크기보다 작지 않은 영역을 잠 가야합니다. 인수가없는 &lt;a href=&quot;#tryLock()&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메서드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="813d5453cbb41f59eb6e5e97b38357b9ea00bdde" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;filechannel#lock--&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 인수가 0 인 &lt;a href=&quot;filechannel#lock--&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="617ac4e34e018358f5e81a33f698a400aa0685af" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;filechannel#tryLock--&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 인수가 0 인 &lt;a href=&quot;filechannel#tryLock--&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="2018bb0b35a071dd77f0537c6308e64613671b58" translate="yes" xml:space="preserve">
          <source>The registered &lt;a href=&quot;#addConfigurationListener(java.lang.Runnable)&quot;&gt;configuration listeners&lt;/a&gt; will be invoked after the configuration is successfully updated.</source>
          <target state="translated">등록 된 &lt;a href=&quot;#addConfigurationListener(java.lang.Runnable)&quot;&gt;구성 리스너&lt;/a&gt; 는 구성이 성공적으로 업데이트 된 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3d0fc73493ecda447bb85c445c6e4f953b759f7f" translate="yes" xml:space="preserve">
          <source>The registration/deregistration methods accept an instance of &lt;code&gt;NamingListener&lt;/code&gt;. There are subinterfaces of &lt;code&gt;NamingListener&lt;/code&gt; for different of event types of &lt;code&gt;NamingEvent&lt;/code&gt;. For example, the &lt;code&gt;ObjectChangeListener&lt;/code&gt; interface is for the &lt;code&gt;NamingEvent.OBJECT_CHANGED&lt;/code&gt; event type. To register interest in multiple event types, the listener implementation should implement multiple &lt;code&gt;NamingListener&lt;/code&gt; subinterfaces and use a single invocation of &lt;code&gt;addNamingListener()&lt;/code&gt;. In addition to reducing the number of method calls and possibly the code size of the listeners, this allows some service providers to optimize the registration.</source>
          <target state="translated">등록 / 파기 메소드는 &lt;code&gt;NamingListener&lt;/code&gt; 의 인스턴스를 받아들 입니다. &lt;code&gt;NamingEvent&lt;/code&gt; 의 다른 이벤트 타입에 대한 &lt;code&gt;NamingListener&lt;/code&gt; 의 서브 인터페이스가 있습니다 . 예를 들어, &lt;code&gt;ObjectChangeListener&lt;/code&gt; 인터페이스는 &lt;code&gt;NamingEvent.OBJECT_CHANGED&lt;/code&gt; 이벤트 유형에 대한 것입니다. 여러 이벤트 유형에 관심을 등록하려면 리스너 구현에서 여러 &lt;code&gt;NamingListener&lt;/code&gt; 서브 인터페이스를 구현 하고 &lt;code&gt;addNamingListener()&lt;/code&gt; 의 단일 호출을 사용해야합니다 . 메소드 호출 수와 리스너의 코드 크기를 줄이는 것 외에도 일부 서비스 제공 업체는 등록을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6005af0d0e955fa02a5ecc341d6d2cbed8810f0c" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;.&lt;/code&gt; matches any character except a line terminator unless the &lt;a href=&quot;#DOTALL&quot;&gt;&lt;code&gt;DOTALL&lt;/code&gt;&lt;/a&gt; flag is specified.</source>
          <target state="translated">정규식 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;#DOTALL&quot;&gt; &lt;code&gt;DOTALL&lt;/code&gt; &lt;/a&gt; 플래그가 지정 되지 않은 경우 줄 종결자를 제외한 모든 문자와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="d4b28ceb290f94f79d557bc3e4312d5d5404a206" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;.&lt;/code&gt; matches any character except a line terminator unless the &lt;a href=&quot;pattern#DOTALL&quot;&gt;&lt;code&gt;DOTALL&lt;/code&gt;&lt;/a&gt; flag is specified.</source>
          <target state="translated">정규식 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;pattern#DOTALL&quot;&gt; &lt;code&gt;DOTALL&lt;/code&gt; &lt;/a&gt; 플래그가 지정 되지 않은 경우 줄 종결자를 제외한 모든 문자와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="06c07dbec7777602883d6500283e28c86a80e923" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;DOMError.type&lt;/code&gt; dependent data if any.</source>
          <target state="translated">관련 &lt;code&gt;DOMError.type&lt;/code&gt; 종속 데이터 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="92e8bde63f8804130f51216402f7e58eed8b42f4" translate="yes" xml:space="preserve">
          <source>The related platform dependent exception if any.</source>
          <target state="translated">관련 플랫폼 종속 예외 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="6e4b1af8982753fca149df2aa7452224b647d528" translate="yes" xml:space="preserve">
          <source>The relation objects of that type will be removed from the Relation Service.</source>
          <target state="translated">해당 유형의 관계 개체는 관계 서비스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="aa44fb4b73ba3a7eb0fa699a55544e1d6fb4e2cf" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;floorDiv&lt;/code&gt; and &lt;code&gt;floorMod&lt;/code&gt; is such that:</source>
          <target state="translated">&lt;code&gt;floorDiv&lt;/code&gt; 와 &lt;code&gt;floorMod&lt;/code&gt; 의 관계는 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6427ac31d87ab27b06603a0df3c2ae4a7cbf6dfa" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;this&lt;/code&gt;&lt;code&gt;XMLGregorianCalendar&lt;/code&gt; and the specified &lt;code&gt;xmlGregorianCalendar&lt;/code&gt; as &lt;a href=&quot;datatypeconstants#LESSER&quot;&gt;&lt;code&gt;DatatypeConstants.LESSER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;datatypeconstants#EQUAL&quot;&gt;&lt;code&gt;DatatypeConstants.EQUAL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;datatypeconstants#GREATER&quot;&gt;&lt;code&gt;DatatypeConstants.GREATER&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;datatypeconstants#INDETERMINATE&quot;&gt;&lt;code&gt;DatatypeConstants.INDETERMINATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 와 지정된 &lt;code&gt;xmlGregorianCalendar&lt;/code&gt; ( &lt;a href=&quot;datatypeconstants#LESSER&quot;&gt; &lt;code&gt;DatatypeConstants.LESSER&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;datatypeconstants#EQUAL&quot;&gt; &lt;code&gt;DatatypeConstants.EQUAL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;datatypeconstants#GREATER&quot;&gt; &lt;code&gt;DatatypeConstants.GREATER&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;datatypeconstants#INDETERMINATE&quot;&gt; &lt;code&gt;DatatypeConstants.INDETERMINATE&lt;/code&gt; )&lt;/a&gt; 간의 관계 입니다.</target>
        </trans-unit>
        <trans-unit id="e5c08d18f5dc47b416f3b07369175323c6d88f7a" translate="yes" xml:space="preserve">
          <source>The relationship between a WebSocket and the associated Listener is analogous to that of a Subscription and the associated Subscriber of type &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow&quot;&gt;&lt;code&gt;Flow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">WebSocket과 관련 리스너 간의 관계는 구독 및 &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow&quot;&gt; &lt;code&gt;Flow&lt;/code&gt; &lt;/a&gt; 유형의 관련 구독자의 관계와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1f651804f5ccc3a0272c1aca813a81ab9ff66d03" translate="yes" xml:space="preserve">
          <source>The relationship between a registered reference object and its queue is one-sided. That is, a queue does not keep track of the references that are registered with it. If a registered reference becomes unreachable itself, then it will never be enqueued. It is the responsibility of the program using reference objects to ensure that the objects remain reachable for as long as the program is interested in their referents.</source>
          <target state="translated">등록 된 참조 개체와 해당 큐 간의 관계는 일방적입니다. 즉, 큐는 등록 된 참조를 추적하지 않습니다. 등록 된 참조가 자체적으로 도달 할 수 없게되면 대기열에 포함되지 않습니다. 프로그램이 참조 대상에 관심이있는 한 객체에 도달 할 수 있도록하는 것은 참조 객체를 사용하는 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="1d34477c420fd977fd8f945aedd832fb3f7c9dfd" translate="yes" xml:space="preserve">
          <source>The relative URL need not specify all the components of a URL. If the protocol, host name, or port number is missing, the value is inherited from the fully specified URL. The file component must be specified. The optional fragment is not inherited.</source>
          <target state="translated">상대 URL은 URL의 모든 구성 요소를 지정할 필요는 없습니다. 프로토콜, 호스트 이름 또는 포트 번호가 누락되면 값은 완전히 지정된 URL에서 상속됩니다. 파일 구성 요소를 지정해야합니다. 선택적 조각은 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f061ca1fba773cc35eb218fcd97124e40600f26" translate="yes" xml:space="preserve">
          <source>The relative index of the first mismatch between this and the given buffer, otherwise -1 if no mismatch.</source>
          <target state="translated">이 버퍼와 주어진 버퍼 사이의 첫 번째 불일치의 상대 색인입니다. 그렇지 않으면 불일치가 없으면 -1입니다.</target>
        </trans-unit>
        <trans-unit id="c5c5f181f6e29a7276bf6337e3a4edd8b847077a" translate="yes" xml:space="preserve">
          <source>The relativization of the given URI against this URI is computed as follows:</source>
          <target state="translated">이 URI에 대한 지정된 URI의 상대 성화는 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e707cc2158f347f5aab8350d2339ff22d2e3b87b" translate="yes" xml:space="preserve">
          <source>The reliability of this method is important for the ability to use it to make security decisions, so its implementation should not just test if the class in question extends &lt;code&gt;Proxy&lt;/code&gt;.</source>
          <target state="translated">이 방법의 안정성은 보안 결정을 내리는 데 사용하기에 중요하므로 구현시 해당 클래스가 &lt;code&gt;Proxy&lt;/code&gt; 를 확장하는지 테스트하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f22668315e9121681e1e68864a75519fe9de5684" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산 이 &lt;em&gt;아닙니다&lt;/em&gt; (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="8b7ae0cdf8ad17c67c6a33deb5e3ca85d6e010c4" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt;. Note that this is not the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산이 아닙니다 (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="e82e7847d0c5f7329094a894a4727d5cc71d2c00" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor,
 mc).multiply(divisor))&lt;/code&gt;. Note that this is not the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor, mc).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산이 아닙니다 (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="cbccf12ec336d37bab08d7866f9df36a1069a2aa" translate="yes" xml:space="preserve">
          <source>The remaining SPI methods &lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt; have more complicated exception behavior. They are not specified to throw &lt;code&gt;BackingStoreException&lt;/code&gt;, as they can generally obey their contracts even if the backing store is unavailable. This is true because they return no information and their effects are not required to become permanent until a subsequent call to &lt;a href=&quot;preferences#flush()&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;preferences#sync()&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;. Generally speaking, these SPI methods should not throw exceptions. In some implementations, there may be circumstances under which these calls cannot even enqueue the requested operation for later processing. Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception. Under these circumstances, however, subsequently invoking &lt;code&gt;flush()&lt;/code&gt; or &lt;code&gt;sync&lt;/code&gt; would not imply that all previous operations had successfully been made permanent.</source>
          <target state="translated">나머지 SPI 메서드 &lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt; 에는 더 복잡한 예외 동작이 있습니다. &lt;code&gt;BackingStoreException&lt;/code&gt; 을 던지도록 지정되지 않았습니다. 일반적으로 백업 저장소를 사용할 수없는 경우에도 계약을 따를 수 있기 때문입니다. 이는 정보를 반환하지 않으며 그 효과는 &lt;a href=&quot;preferences#flush()&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;preferences#sync()&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; &lt;/a&gt; 대한 후속 호출이있을 때까지 영구적으로 유지 될 필요가 없기 때문에 사실입니다.. 일반적으로 이러한 SPI 메서드는 예외를 throw해서는 안됩니다. 일부 구현에서는 이러한 호출이 나중에 처리하기 위해 요청 된 작업을 대기열에 넣을 수없는 상황이있을 수 있습니다. 이러한 상황에서도 일반적으로 예외를 던지는 것보다 단순히 호출을 무시하고 반환하는 것이 좋습니다. 그러나 이러한 상황에서 이후에 &lt;code&gt;flush()&lt;/code&gt; 또는 &lt;code&gt;sync&lt;/code&gt; 를 호출 한다고해서 이전의 모든 작업이 성공적으로 영구적으로 수행되었음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="47da9e589f25b7bfcd11328b7b51fd360a0d60ec" translate="yes" xml:space="preserve">
          <source>The remaining SPI methods &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt; have more complicated exception behavior. They are not specified to throw &lt;code&gt;BackingStoreException&lt;/code&gt;, as they can generally obey their contracts even if the backing store is unavailable. This is true because they return no information and their effects are not required to become permanent until a subsequent call to &lt;a href=&quot;preferences#flush--&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;preferences#sync--&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;. Generally speaking, these SPI methods should not throw exceptions. In some implementations, there may be circumstances under which these calls cannot even enqueue the requested operation for later processing. Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception. Under these circumstances, however, all subsequent invocations of &lt;code&gt;flush()&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; should return &lt;code&gt;false&lt;/code&gt;, as returning &lt;code&gt;true&lt;/code&gt; would imply that all previous operations had successfully been made permanent.</source>
          <target state="translated">나머지 SPI 메소드 &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt; 에는 더 복잡한 예외 동작이 있습니다. &lt;code&gt;BackingStoreException&lt;/code&gt; 을 던지도록 지정되어 있지 않습니다. 일반적으로 백업 저장소를 사용할 수없는 경우에도 계약을 따를 수 있습니다. 이는 정보를 반환하지 않으며, &lt;a href=&quot;preferences#flush--&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;preferences#sync--&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; &lt;/a&gt; 대한 후속 호출까지 그 효과가 영구적이 될 필요가 없기 때문에 사실입니다.. 일반적으로 이러한 SPI 메소드는 예외를 발생시키지 않아야합니다. 일부 구현들에서, 이러한 호출들이 추후 처리를 위해 요청 된 동작을 큐에 넣을 수없는 상황이있을 수있다. 이러한 상황에서도 일반적으로 예외를 던지기보다는 단순히 호출과 반환을 무시하는 것이 좋습니다. 그러나 이러한 상황에서 &lt;code&gt;flush()&lt;/code&gt; 및 &lt;code&gt;sync&lt;/code&gt; 의 모든 후속 호출은 &lt;code&gt;false&lt;/code&gt; 를 리턴해야합니다. &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 이전의 모든 조작이 모두 영구적으로 완료되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="04a436b0f38850e482765bfe8b244ada2271191c" translate="yes" xml:space="preserve">
          <source>The remaining characters of the result represent the magnitude of the first argument. If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character. The following ASCII characters are used as digits:</source>
          <target state="translated">결과의 나머지 문자는 첫 번째 인수의 크기를 나타냅니다. 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면, 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 ASCII 문자는 숫자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b031f20190ca11166d6c7b1f498a8021f1fd8160" translate="yes" xml:space="preserve">
          <source>The remaining details of the &lt;code&gt;MBeanInfo&lt;/code&gt; for a Standard MBean are not specified. This includes the description of any contained constructors, and notifications; the names of parameters to constructors and operations; and the descriptions of constructor parameters.</source>
          <target state="translated">표준 MBean 에 대한 &lt;code&gt;MBeanInfo&lt;/code&gt; 의 나머지 세부 사항이 지정되지 않았습니다. 여기에는 포함 된 생성자에 대한 설명 및 알림이 포함됩니다. 생성자와 오퍼레이션에 대한 매개 변수 이름; 생성자 매개 변수에 대한 설명</target>
        </trans-unit>
        <trans-unit id="c7f4b12e2049eb0d2dbae4e0935da9f089467437" translate="yes" xml:space="preserve">
          <source>The remaining unresolved portion of the name. Cannot be null but empty OK.</source>
          <target state="translated">이름의 나머지 해결되지 않은 부분. null 일 수는 없지만 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea85bdd68a733447d59816d26042ab04cf3dcc37" translate="yes" xml:space="preserve">
          <source>The remapping function must not modify this map during computation.</source>
          <target state="translated">리매핑 함수는 계산 중에이 맵을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7050822aac2eaeaa73f4b961d1cb35d5d5e11578" translate="yes" xml:space="preserve">
          <source>The remapping function should not modify this map during computation.</source>
          <target state="translated">리매핑 함수는 계산 중에이 맵을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc31c724cb4c9ebbaec1ed20f6acbd3909843172" translate="yes" xml:space="preserve">
          <source>The remote address; &lt;code&gt;null&lt;/code&gt; if the channel's socket is not connected</source>
          <target state="translated">원격 주소 채널의 소켓이 접속되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="673bd2ce7ddc2683e972ea4f5e6861895e8c2684" translate="yes" xml:space="preserve">
          <source>The remote agent runs in the execution process (separate from the main JShell process).</source>
          <target state="translated">원격 에이전트는 실행 프로세스에서 실행됩니다 (기본 JShell 프로세스와 별도로).</target>
        </trans-unit>
        <trans-unit id="cb8323319dc2708c5b633b881cd58ff8450c0c14" translate="yes" xml:space="preserve">
          <source>The remote agent runs in the execution process (separate from the main JShell process). This agent loads code over a socket from the main JShell process, executes the code, and other misc, Specialization of &lt;a href=&quot;directexecutioncontrol&quot;&gt;&lt;code&gt;DirectExecutionControl&lt;/code&gt;&lt;/a&gt; which adds stop support controlled by an external process. Designed to work with &lt;a href=&quot;jdidefaultexecutioncontrol&quot;&gt;&lt;code&gt;JdiDefaultExecutionControl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원격 에이전트는 실행 프로세스에서 실행됩니다 (기본 JShell 프로세스와 별도로). 이 에이전트는 메인 JShell 프로세스에서 소켓을 통해 코드를로드하고 코드 및 기타 기타 &lt;a href=&quot;directexecutioncontrol&quot;&gt; &lt;code&gt;DirectExecutionControl&lt;/code&gt; 의&lt;/a&gt; 특수화를 실행 하여 외부 프로세스에 의해 제어되는 중지 지원을 추가합니다. &lt;a href=&quot;jdidefaultexecutioncontrol&quot;&gt; &lt;code&gt;JdiDefaultExecutionControl&lt;/code&gt; &lt;/a&gt; 과 함께 작동하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="cef7ea0baae0260a25616113571983d978e4ff08" translate="yes" xml:space="preserve">
          <source>The remote agent to launch.</source>
          <target state="translated">시작할 원격 에이전트입니다.</target>
        </trans-unit>
        <trans-unit id="0e7bc56b939ee7935299e6e6d043373f7df2f25b" translate="yes" xml:space="preserve">
          <source>The remote object becomes available. The header fields and the contents of the remote object can be accessed.</source>
          <target state="translated">원격 객체를 사용할 수있게됩니다. 원격 객체의 헤더 필드와 내용에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e100a0f6c2f94294ad6e3cd0c330ac89e4c13e0" translate="yes" xml:space="preserve">
          <source>The removal is not guaranteed to be persistent until the &lt;code&gt;flush&lt;/code&gt; method is called on this node (or an ancestor).</source>
          <target state="translated">이 노드 (또는 상위 노드) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 제거가 지속되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a80e61fbbbe10c51d6c88507a5031484ad5e8f17" translate="yes" xml:space="preserve">
          <source>The removal may or may not cause a reduction in the actual file size.</source>
          <target state="translated">제거하면 실제 파일 크기가 줄어들거나 줄어들지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d723447722497695e77f4caccb3c9a5c643a12a5" translate="yes" xml:space="preserve">
          <source>The removal of a node needn't become persistent until the &lt;code&gt;flush&lt;/code&gt; method is invoked on this node (or an ancestor).</source>
          <target state="translated">이 노드 (또는 상위 노드) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 노드 제거가 지속될 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b282c26f23a8ff63876d094fed5b0b9dceb07331" translate="yes" xml:space="preserve">
          <source>The remove operation is not supported by this implementation of &lt;code&gt;Iterator&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Iterator&lt;/code&gt; 구현에서는 remove 오퍼레이션이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4efa145e520c4a7598346c393df2dbbefdc968" translate="yes" xml:space="preserve">
          <source>The removed value.</source>
          <target state="translated">제거 된 값.</target>
        </trans-unit>
        <trans-unit id="6ff8f9058796bef90ed321ab88ccf0d012f42526" translate="yes" xml:space="preserve">
          <source>The renamed node. This is either the specified node or the new node that was created to replace the specified node.</source>
          <target state="translated">이름이 바뀐 노드. 이는 지정된 노드 또는 지정된 노드를 대체하기 위해 작성된 새 노드입니다.</target>
        </trans-unit>
        <trans-unit id="fb9b7cdcd454dd83954d48a119b69fc6d29f5c43" translate="yes" xml:space="preserve">
          <source>The renderer used to draw the data cells of the column.</source>
          <target state="translated">열의 데이터 셀을 그리는 데 사용되는 렌더러입니다.</target>
        </trans-unit>
        <trans-unit id="713971eadcf5411214bfe63ca9c0cd65073e7a98" translate="yes" xml:space="preserve">
          <source>The renderer used to draw the header of the column.</source>
          <target state="translated">열의 헤더를 그리는 데 사용되는 렌더러입니다.</target>
        </trans-unit>
        <trans-unit id="ac7f1cf8057b8bea9aa3a7381065318220564c73" translate="yes" xml:space="preserve">
          <source>The reordering array need not specify an actual permutation. An incoming argument will be duplicated if its index appears more than once in the array, and an incoming argument will be dropped if its index does not appear in the array. As in the case of &lt;a href=&quot;#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)&quot;&gt;&lt;code&gt;dropArguments&lt;/code&gt;&lt;/a&gt;, incoming arguments which are not mentioned in the reordering array may be of any type, as determined only by &lt;code&gt;newType&lt;/code&gt;.</source>
          <target state="translated">재정렬 배열은 실제 순열을 지정할 필요가 없습니다. 인덱스가 배열에 두 번 이상 나타나면 들어오는 인수가 복제되고 인덱스가 배열에 나타나지 않으면 들어오는 인수가 삭제됩니다. &lt;a href=&quot;#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)&quot;&gt; &lt;code&gt;dropArguments&lt;/code&gt; &lt;/a&gt; 의 경우와 마찬가지로 재정렬 배열에 언급되지 않은 들어오는 인수는 &lt;code&gt;newType&lt;/code&gt; 에 의해서만 결정되는 모든 유형이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee9a68c9011522398b40024ebeb43b4a5fda590" translate="yes" xml:space="preserve">
          <source>The reordering array need not specify an actual permutation. An incoming argument will be duplicated if its index appears more than once in the array, and an incoming argument will be dropped if its index does not appear in the array. As in the case of &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt;&lt;code&gt;dropArguments&lt;/code&gt;&lt;/a&gt;, incoming arguments which are not mentioned in the reordering array are may be any type, as determined only by &lt;code&gt;newType&lt;/code&gt;.</source>
          <target state="translated">재정렬 배열은 실제 순열을 지정할 필요가 없습니다. 인덱스가 배열에 두 번 이상 나타나면 들어오는 인수가 복제되고 인덱스가 배열에 나타나지 않으면 들어오는 인수가 삭제됩니다. &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt; &lt;code&gt;dropArguments&lt;/code&gt; &lt;/a&gt; 의 경우와 같이 , 재정렬 배열에서 언급되지 않은 들어오는 인수는 &lt;code&gt;newType&lt;/code&gt; 에 의해서만 결정되는 모든 유형일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94e20896a8d370dd44b10d541260e63623383466" translate="yes" xml:space="preserve">
          <source>The reordering array need not specify an actual permutation. An incoming coordinate will be duplicated if its index appears more than once in the array, and an incoming coordinate will be dropped if its index does not appear in the array.</source>
          <target state="translated">재정렬 배열은 실제 순열을 지정할 필요가 없습니다. 인덱스가 배열에 두 번 이상 나타나면 들어오는 좌표가 복제되고 인덱스가 배열에 나타나지 않으면 들어오는 좌표가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f51e74f5d8487e855f129611f92abf36e6a28994" translate="yes" xml:space="preserve">
          <source>The replacement string may contain references to subsequences captured during the previous match: Each occurrence of &lt;code&gt;$&lt;/code&gt;</source>
          <target state="translated">대체 문자열에는 이전 일치 중에 캡처 된 하위 시퀀스에 대한 참조가 포함될 수 있습니다. 각 &lt;code&gt;$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11b366ce3d5519585e67264e9f68f215e953b69e" translate="yes" xml:space="preserve">
          <source>The replacement string may contain references to subsequences captured during the previous match: Each occurrence of &lt;code&gt;${&lt;/code&gt;</source>
          <target state="translated">대체 문자열에는 이전 일치 중 캡처 된 하위 시퀀스에 대한 참조가 포함될 수 있습니다. 각 &lt;code&gt;${&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ab89b061a41906c8763945c85297d70e2bd282" translate="yes" xml:space="preserve">
          <source>The replacement text of the entity.</source>
          <target state="translated">엔티티의 대체 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="75ec87cf75e7574e625f69514e58b5152817990b" translate="yes" xml:space="preserve">
          <source>The replacement text of the entity. This method will only return non-null if this is an internal entity.</source>
          <target state="translated">엔티티의 대체 텍스트입니다. 이 메서드는 내부 엔터티 인 경우에만 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cf33c4bd273f01e0c22bc67185a111143ddb62b3" translate="yes" xml:space="preserve">
          <source>The replacer function should not modify this matcher's state during replacement. This method will, on a best-effort basis, throw a &lt;a href=&quot;../concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; if such modification is detected.</source>
          <target state="translated">replacer 함수는 교체 중에이 matcher의 상태를 수정해서는 안됩니다. 이 메서드는 최선의 노력으로 그러한 수정이 감지되면 &lt;a href=&quot;../concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3a325ac974e7b645dae1cacad32338ebd82736bc" translate="yes" xml:space="preserve">
          <source>The reported coordinates for mouse drag events are clipped to fit within the bounds of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; associated with the &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">마우스 드래그 이벤트에 대해보고 된 좌표 는 &lt;code&gt;Component&lt;/code&gt; 와 관련된 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 경계 내에 맞도록 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="eb6b8031115b561f37eb9a4d7da91ed0656b375b" translate="yes" xml:space="preserve">
          <source>The reported coordinates for mouse drag events are clipped to fit within the bounds of the virtual device associated with the &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">마우스 드래그 이벤트에 대해보고 된 좌표는 &lt;code&gt;Component&lt;/code&gt; 와 관련된 가상 장치의 경계 내에 맞도록 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="288c5e2c9b272e95a0d7c59900658548e9747ef2" translate="yes" xml:space="preserve">
          <source>The reporter that will be set on any XMLStreamReader or XMLEventReader created by this factory instance.</source>
          <target state="translated">이 팩토리 인스턴스에 의해 생성 된 XMLStreamReader 또는 XMLEventReader에 설정 될 리포터입니다.</target>
        </trans-unit>
        <trans-unit id="55f25e93574df5310447cf5bb1c8796f989fc6ae" translate="yes" xml:space="preserve">
          <source>The reporting of parameter entities (including the external DTD subset) is optional, and SAX2 drivers that report LexicalHandler events may not implement it; you can use the &lt;code&gt;http://xml.org/sax/features/lexical-handler/parameter-entities&lt;/code&gt; feature to query or control the reporting of parameter entities.</source>
          <target state="translated">매개 변수 엔터티 (외부 DTD 하위 집합 포함)보고는 선택 사항이며 LexicalHandler 이벤트를보고하는 SAX2 드라이버는이를 구현하지 않을 수 있습니다. &lt;code&gt;http://xml.org/sax/features/lexical-handler/parameter-entities&lt;/code&gt; 기능을 사용하여 매개 변수 엔티티의보고를 쿼리하거나 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c61cf9cb2860f72199b40004f9fd1739f05d6c2" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java programming language of an SQL &lt;code&gt;BLOB&lt;/code&gt; value.</source>
          <target state="translated">SQL &lt;code&gt;BLOB&lt;/code&gt; 값 의 Java 프로그래밍 언어 표현 (매핑) .</target>
        </trans-unit>
        <trans-unit id="a2aa7611b6b32d07253ef65ff7e061cbf6527495" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java programming language of an SQL &lt;code&gt;BLOB&lt;/code&gt; value. An SQL &lt;code&gt;BLOB&lt;/code&gt; is a built-in type that stores a Binary Large Object as a column value in a row of a database table. By default drivers implement &lt;code&gt;Blob&lt;/code&gt; using an SQL &lt;code&gt;locator(BLOB)&lt;/code&gt;, which means that a &lt;code&gt;Blob&lt;/code&gt; object contains a logical pointer to the SQL &lt;code&gt;BLOB&lt;/code&gt; data rather than the data itself. A &lt;code&gt;Blob&lt;/code&gt; object is valid for the duration of the transaction in which is was created.</source>
          <target state="translated">SQL &lt;code&gt;BLOB&lt;/code&gt; 값 의 Java 프로그래밍 언어 표현 (매핑) . SQL &lt;code&gt;BLOB&lt;/code&gt; 는 데이터베이스 테이블의 행에 열 값으로 Binary Large Object를 저장하는 기본 제공 유형입니다. 기본적으로 드라이버 는 SQL &lt;code&gt;locator(BLOB)&lt;/code&gt; 사용하여 &lt;code&gt;Blob&lt;/code&gt; 을 구현 합니다. 즉, &lt;code&gt;Blob&lt;/code&gt; 개체에는 데이터 자체가 아닌 SQL &lt;code&gt;BLOB&lt;/code&gt; 데이터에 대한 논리적 포인터가 포함 됩니다. &lt;code&gt;Blob&lt;/code&gt; 객체가 생성되는 트랜잭션 (transaction)의 기간 중에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="6083e0509485bc16d1b67f9cd0c180d1fac35b49" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java programming language of an SQL ROWID value.</source>
          <target state="translated">SQL ROWID 값의 Java 프로그래밍 언어 표현 (매핑).</target>
        </trans-unit>
        <trans-unit id="0acb89110741064b366cdd1922c5e4764ac516a3" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java programming language of an SQL ROWID value. An SQL ROWID is a built-in type, a value of which can be thought of as an address for its identified row in a database table. Whether that address is logical or, in any respects, physical is determined by its originating data source.</source>
          <target state="translated">SQL ROWID 값의 Java 프로그래밍 언어 표현 (매핑). SQL ROWID는 기본 제공 유형으로, 그 값은 데이터베이스 테이블에서 식별 된 행의 주소로 간주 될 수 있습니다. 해당 주소가 논리적인지 여부에 관계없이 물리적 주소는 원래 데이터 소스에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a234babedabfce29cc4aa701cb753ce00ac220" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java&amp;trade; programming language of an SQL &lt;code&gt;BLOB&lt;/code&gt; value.</source>
          <target state="translated">SQL &lt;code&gt;BLOB&lt;/code&gt; 값 의 Java &amp;trade; 프로그래밍 언어 표현 (매핑) .</target>
        </trans-unit>
        <trans-unit id="4d77c9a7464d84c1e1a1e7121b389a8cb2d1668e" translate="yes" xml:space="preserve">
          <source>The representation (mapping) in the Java&amp;trade; programming language of an SQL &lt;code&gt;BLOB&lt;/code&gt; value. An SQL &lt;code&gt;BLOB&lt;/code&gt; is a built-in type that stores a Binary Large Object as a column value in a row of a database table. By default drivers implement &lt;code&gt;Blob&lt;/code&gt; using an SQL &lt;code&gt;locator(BLOB)&lt;/code&gt;, which means that a &lt;code&gt;Blob&lt;/code&gt; object contains a logical pointer to the SQL &lt;code&gt;BLOB&lt;/code&gt; data rather than the data itself. A &lt;code&gt;Blob&lt;/code&gt; object is valid for the duration of the transaction in which is was created.</source>
          <target state="translated">SQL &lt;code&gt;BLOB&lt;/code&gt; 값 의 Java &amp;trade; 프로그래밍 언어 표현 (매핑) . SQL &lt;code&gt;BLOB&lt;/code&gt; 는 데이터베이스 테이블의 행에 열 값으로 Binary Large Object를 저장하는 내장 유형입니다. 기본적으로 드라이버 는 SQL &lt;code&gt;locator(BLOB)&lt;/code&gt; 사용하여 &lt;code&gt;Blob&lt;/code&gt; 을 구현 합니다. 즉, &lt;code&gt;Blob&lt;/code&gt; 개체에는 데이터 자체가 아닌 SQL &lt;code&gt;BLOB&lt;/code&gt; 데이터에 대한 논리적 포인터가 포함 됩니다. &lt;code&gt;Blob&lt;/code&gt; 객체가 생성되는 트랜잭션 (transaction)의 기간 중에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3b478ac46ccb7d878a2f5619e7d5a35540bff2b2" translate="yes" xml:space="preserve">
          <source>The representation class associated with this &lt;code&gt;DataFlavor&lt;/code&gt; identifies the Java type of an object returned as a reference from an invocation &lt;code&gt;java.awt.datatransfer.getTransferData&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;DataFlavor&lt;/code&gt; 와 연관된 표현 클래스 는 호출 &lt;code&gt;java.awt.datatransfer.getTransferData&lt;/code&gt; 에서 참조로 반환 된 객체의 Java 유형을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="2b778106af4a2d34f18fd72da9905b02ac996017" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Double.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Double.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="58244bdf257d357f8d92e2421ad210e0d7962bd1" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Float.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Float.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="ded2585e0b6c084c04a4f0859a53141f76d123ae" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Integer.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Integer.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="6aab087f6a2f2da33d64c153ee96c99fa034a1e7" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Long.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Long.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="b9a0adc7cc916f3011d7fe2d1b1539f1d22e7cd4" translate="yes" xml:space="preserve">
          <source>The representation of a savepoint, which is a point within the current transaction that can be referenced from the &lt;code&gt;Connection.rollback&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Connection.rollback&lt;/code&gt; 메서드 에서 참조 할 수있는 현재 트랜잭션 내의 지점 인 저장 점의 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="16e0f89431331e3c19f8e9168d79da480c3ea351" translate="yes" xml:space="preserve">
          <source>The representation of a savepoint, which is a point within the current transaction that can be referenced from the &lt;code&gt;Connection.rollback&lt;/code&gt; method. When a transaction is rolled back to a savepoint all changes made after that savepoint are undone.</source>
          <target state="translated">&lt;code&gt;Connection.rollback&lt;/code&gt; 메서드 에서 참조 할 수있는 현재 트랜잭션 내의 지점 인 저장 점의 표현입니다 . 트랜잭션이 저장 점으로 롤백되면 해당 저장 점 이후의 모든 변경 사항이 실행 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="c10c8df535a59f66cf15a0bfa27c32d6f30bfdb3" translate="yes" xml:space="preserve">
          <source>The representation of an SGML DTD.</source>
          <target state="translated">SGML DTD의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="f354ab4341294adf05dcc226d6afe0dd75fdc477" translate="yes" xml:space="preserve">
          <source>The representation of an SGML DTD. DTD describes a document syntax and is used in parsing of HTML documents. It contains a list of elements and their attributes as well as a list of entities defined in the DTD.</source>
          <target state="translated">SGML DTD의 표현입니다. DTD는 문서 구문을 설명하며 HTML 문서 구문 분석에 사용됩니다. 여기에는 요소 및 해당 속성 목록과 DTD에 정의 된 엔티티 목록이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0d60a9c0e70768f0432c0076bb2b850f773e5a83" translate="yes" xml:space="preserve">
          <source>The request controls supplied to the initial context constructor are &lt;em&gt;not&lt;/em&gt; used as the context request controls for subsequent context operations such as searches and lookups. Context request controls are set and updated by using &lt;code&gt;setRequestControls()&lt;/code&gt;.</source>
          <target state="translated">초기 컨텍스트 생성자에 제공된 요청 컨트롤은 검색 및 조회와 같은 후속 컨텍스트 작업에 대한 컨텍스트 요청 컨트롤로 사용 &lt;em&gt;되지 않습니다&lt;/em&gt; . 컨텍스트 요청 컨트롤은 &lt;code&gt;setRequestControls()&lt;/code&gt; 를 사용하여 설정 및 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c538826a3a1f2f420e3436c5b667643e5f793cd" translate="yes" xml:space="preserve">
          <source>The request-host is a HDN (not IP address) and has the form HD, where D is the value of the Domain attribute, and H is a string that contains one or more dots.</source>
          <target state="translated">요청 호스트는 IP 주소가 아닌 HDN이며 HD 형식입니다. 여기서 D는 도메인 속성 값이고 H는 하나 이상의 점이 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a57362ff710e86a82bac45526ef9e2b2169857b3" translate="yes" xml:space="preserve">
          <source>The requested &lt;code&gt;Locale&lt;/code&gt; may contain an &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt; extension&lt;/a&gt; for specifying the desired numbering system. For example, &lt;code&gt;&quot;ar-u-nu-arab&quot;&lt;/code&gt; (in the BCP 47 language tag form) specifies Arabic with the Arabic-Indic digits and symbols, while &lt;code&gt;&quot;ar-u-nu-latn&quot;&lt;/code&gt; specifies Arabic with the Latin digits and symbols. Refer to the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification for numbering systems.</source>
          <target state="translated">요청 된 &lt;code&gt;Locale&lt;/code&gt; 에는 원하는 번호 시스템을 지정하기 위한 &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;확장자&lt;/a&gt; 가 포함될 수 있습니다 . 예를 들어, &lt;code&gt;&quot;ar-u-nu-arab&quot;&lt;/code&gt; (BCP 47 언어 태그 형식)은 아랍어-인도 숫자 및 기호로 아랍어를 지정하고 &lt;code&gt;&quot;ar-u-nu-latn&quot;&lt;/code&gt; 은 라틴 숫자 및 기호로 아랍어를 지정합니다. . 번호 시스템에 대해서는 &lt;em&gt;LDML (Unicode Locale Data Markup Language)&lt;/em&gt; 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4313d8db2408961b8c6e4e788b166da71d191f7" translate="yes" xml:space="preserve">
          <source>The requested coder-result object</source>
          <target state="translated">요청 된 코더 결과 객체</target>
        </trans-unit>
        <trans-unit id="c473246769f43aa19b3ba4b2ef431369ba324d78" translate="yes" xml:space="preserve">
          <source>The requested data array element as an integer.</source>
          <target state="translated">요청 된 데이터 배열 요소 (정수).</target>
        </trans-unit>
        <trans-unit id="bc4af42dc723a89b139169dad6f6ac48341fa317" translate="yes" xml:space="preserve">
          <source>The requested type is any line that matches the description in the provided &lt;code&gt;Line.Info&lt;/code&gt; object. For example, if the info object represents a speaker port, and the mixer supports exactly one speaker port, this method should return 1. If the info object represents a source data line and the mixer supports the use of 32 source data lines simultaneously, the return value should be 32. If there is no limit, this function returns &lt;a href=&quot;audiosystem#NOT_SPECIFIED&quot;&gt;&lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청 된 유형은 제공된 &lt;code&gt;Line.Info&lt;/code&gt; 개체 의 설명과 일치하는 모든 줄입니다 . 예를 들어, info 객체가 스피커 포트를 나타내고 믹서가 정확히 하나의 스피커 포트를 지원하는 경우이 메서드는 1을 반환해야합니다. info 객체가 소스 데이터 라인을 나타내고 믹서가 32 개의 소스 데이터 라인 사용을 동시에 지원하는 경우 반환 값은 32 여야합니다. 제한이 없으면이 함수는 &lt;a href=&quot;audiosystem#NOT_SPECIFIED&quot;&gt; &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="248e76eb2ee596cc71b6a4da144a1ff22287b387" translate="yes" xml:space="preserve">
          <source>The requested type must have a return type of &lt;code&gt;void&lt;/code&gt;. (This is consistent with the JVM's treatment of constructor type descriptors.)</source>
          <target state="translated">요청 된 유형의 반환 유형은 &lt;code&gt;void&lt;/code&gt; 입니다. (이것은 JVM이 생성자 유형 설명자를 처리하는 것과 일치합니다.)</target>
        </trans-unit>
        <trans-unit id="516805460907e538d55b063de2a7d8a474251df4" translate="yes" xml:space="preserve">
          <source>The requester has canceled the job or the printer has aborted the job, but the printer is still performing some actions on the job until a specified stop point occurs or job termination/cleanup is completed.</source>
          <target state="translated">요청자가 작업을 취소했거나 프린터가 작업을 중단했지만 지정된 중지 지점이 발생하거나 작업 종료 / 정리가 완료 될 때까지 프린터는 여전히 작업에 대해 일부 작업을 수행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f22f6979881830731d65c0765a1fe0d7c814e17" translate="yes" xml:space="preserve">
          <source>The required</source>
          <target state="translated">필요한</target>
        </trans-unit>
        <trans-unit id="745e1e490c53f8464a11eebd65e0f35408648502" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;hashCode&lt;/code&gt; behavior for Permission Objects is the following:</source>
          <target state="translated">권한 객체에 필요한 &lt;code&gt;hashCode&lt;/code&gt; 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b8bab1511c52f5ddaa9f2aab1201197de8e2410" translate="yes" xml:space="preserve">
          <source>The requirement of lookup object matching provides a &quot;fast fail&quot; behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use &lt;a href=&quot;methodhandles#reflectAs(java.lang.Class,java.lang.invoke.MethodHandle)&quot;&gt;&lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt;&lt;/a&gt; to override this limitation.</source>
          <target state="translated">조회 개체 일치의 요구 사항은 예기치 않은 범위에서 기호 정보 (또는 호출자 바인딩)가있는 메서드 핸들의 잘못된 표시를 신뢰할 수있는 프로그램에 대해 &quot;빠른 실패&quot;동작을 제공합니다. 이 제한을 무시 하려면 &lt;a href=&quot;methodhandles#reflectAs(java.lang.Class,java.lang.invoke.MethodHandle)&quot;&gt; &lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="55d02efa54b09ebdcdd937fdc51b7ffc1d272c16" translate="yes" xml:space="preserve">
          <source>The requirement of lookup object matching provides a &quot;fast fail&quot; behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use &lt;a href=&quot;methodhandles#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-&quot;&gt;&lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt;&lt;/a&gt; to override this limitation.</source>
          <target state="translated">조회 오브젝트 일치 요구 사항은 예상치 못한 범위의 기호 정보 (또는 호출자 바인딩)가있는 메소드 핸들의 잘못된 계시를 신뢰할 수있는 프로그램에 대해 &quot;빠른 실패&quot;동작을 제공합니다. 이 제한을 무시 하려면 &lt;a href=&quot;methodhandles#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-&quot;&gt; &lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cbf46ff6901cb358f2bf2adf82f26fea12aff47" translate="yes" xml:space="preserve">
          <source>The reseedable and prediction resistance capabilities of a DRBG.</source>
          <target state="translated">DRBG의 재배치 가능 및 예측 저항 기능.</target>
        </trans-unit>
        <trans-unit id="88faedd860fdc4cb6207174dad3840e3bf7612c6" translate="yes" xml:space="preserve">
          <source>The reserved method name &quot;new&quot; may be used to call a class's constructor as if all classes defined static &quot;new&quot; methods. Constructor invocations are typically considered &lt;code&gt;Expression&lt;/code&gt;s rather than &lt;code&gt;Statement&lt;/code&gt;s as they return a value.</source>
          <target state="translated">예약 된 메소드 이름 &quot;new&quot;는 모든 클래스가 정적 &quot;new&quot;메소드를 정의한 것처럼 클래스의 생성자를 호출하는 데 사용될 수 있습니다. 생성자 호출은 일반적으로 값을 반환 할 때 &lt;code&gt;Statement&lt;/code&gt; 가 아닌 &lt;code&gt;Expression&lt;/code&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="754706891133e7ad865e654b5b80f53d473f0298" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;DocumentBuilder&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;EntityResolver&lt;/code&gt; and &lt;code&gt;ErrorHandler&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;DocumentBuilder&lt;/code&gt; 는 동일한 &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; 를 갖는다 고 보장되지 않습니다 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 예 : Object.equals (Object obj)) . 기능적으로 동일한 &lt;code&gt;EntityResolver&lt;/code&gt; 및 &lt;code&gt;ErrorHandler&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7e567940636717249f219f15560c4ebd13f7896" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;SAXParser&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;../validation/schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;Schema&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;SAXParser&lt;/code&gt; 는 동일한 &lt;a href=&quot;../validation/schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; (예 : &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 를 가지도록 보장되지 않습니다 . 기능적으로 동일한 &lt;code&gt;Schema&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c30f2a2b35a74fb90b7aae0cc5ec8665873d5df5" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;Transformer&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;uriresolver&quot;&gt;&lt;code&gt;URIResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;errorlistener&quot;&gt;&lt;code&gt;ErrorListener&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;URIResolver&lt;/code&gt; and &lt;code&gt;ErrorListener&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;Transformer&lt;/code&gt; 는 동일한 &lt;a href=&quot;uriresolver&quot;&gt; &lt;code&gt;URIResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;errorlistener&quot;&gt; &lt;code&gt;ErrorListener&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; 를 가지도록 보장되지 않습니다 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 예 : Object.equals (Object obj)) . 기능적으로 동일한 &lt;code&gt;URIResolver&lt;/code&gt; 및 &lt;code&gt;ErrorListener&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="01b3d7c853e31dc0a7995e2fca623c0cc7a8afec" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;Validator&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;LSResourceResolver&lt;/code&gt; and &lt;code&gt;ErrorHandler&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;Validator&lt;/code&gt; 는 동일한 &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; 를 가지도록 보장되지 않습니다 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 예 : Object.equals (Object obj)) . 기능적으로 동일한 &lt;code&gt;LSResourceResolver&lt;/code&gt; 및 &lt;code&gt;ErrorHandler&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f47dccbff991860b05f0ad7e168ff6056c8b397" translate="yes" xml:space="preserve">
          <source>The reset &lt;code&gt;XPath&lt;/code&gt; is not guaranteed to have the same &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../namespace/namespacecontext&quot;&gt;&lt;code&gt;NamespaceContext&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Object&lt;/code&gt;s, e.g. &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object obj)&lt;/code&gt;&lt;/a&gt;. It is guaranteed to have a functionally equal &lt;code&gt;XPathFunctionResolver&lt;/code&gt;, &lt;code&gt;XPathVariableResolver&lt;/code&gt; and &lt;code&gt;NamespaceContext&lt;/code&gt;.</source>
          <target state="translated">재설정 된 &lt;code&gt;XPath&lt;/code&gt; 는 동일한 &lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../namespace/namespacecontext&quot;&gt; &lt;code&gt;NamespaceContext&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Object&lt;/code&gt; , 예를 들어 &lt;a href=&quot;../../../../java.base/java/lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object obj)&lt;/code&gt; &lt;/a&gt; 를 갖는다 고 보장되지 않습니다 . 기능적으로 동일한 &lt;code&gt;XPathFunctionResolver&lt;/code&gt; , &lt;code&gt;XPathVariableResolver&lt;/code&gt; 및 &lt;code&gt;NamespaceContext&lt;/code&gt; 를 갖도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="df87b115c664fd653afbf26bb11c0fc8970cab09" translate="yes" xml:space="preserve">
          <source>The resolution of the system identifiers associated with entities is done using &lt;code&gt;Document.documentURI&lt;/code&gt;. However, when the feature &quot;LS&quot; defined in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407&quot;&gt;DOM Level 3 Load and Save&lt;/a&gt;] is supported by the DOM implementation, the parameter &quot;resource-resolver&quot; can also be used on &lt;code&gt;DOMConfiguration&lt;/code&gt; objects attached to &lt;code&gt;Document&lt;/code&gt; nodes. If this parameter is set, &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; will invoke the resource resolver instead of using &lt;code&gt;Document.documentURI&lt;/code&gt;.</source>
          <target state="translated">엔티티와 관련된 시스템 식별자의 확인은 &lt;code&gt;Document.documentURI&lt;/code&gt; 를 사용하여 수행됩니다 . 그러나 [ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407&quot;&gt;DOM 레벨 3로드 및 저장&lt;/a&gt; ]에 정의 된 기능 &quot;LS&quot; 가 DOM 구현에 의해 지원되는 경우 &quot;resource-resolver&quot;매개 변수 는 &lt;code&gt;Document&lt;/code&gt; 노드에 첨부 된 &lt;code&gt;DOMConfiguration&lt;/code&gt; 객체 에서도 사용할 수 있습니다 . 이 매개 변수가 설정되면 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 는 &lt;code&gt;Document.documentURI&lt;/code&gt; 를 사용하는 대신 리소스 확인자를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="15648f82ccf848914068cb11110f72edc4adf8dc" translate="yes" xml:space="preserve">
          <source>The resolution of the system identifiers associated with entities is done using &lt;code&gt;Document.documentURI&lt;/code&gt;. However, when the feature &quot;LS&quot; defined in [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407&quot;&gt;DOM Level 3 Load and Save&lt;/a&gt;] is supported by the DOM implementation, the parameter &quot;resource-resolver&quot; can also be used on &lt;code&gt;DOMConfiguration&lt;/code&gt; objects attached to &lt;code&gt;Document&lt;/code&gt; nodes. If this parameter is set, &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; will invoke the resource resolver instead of using &lt;code&gt;Document.documentURI&lt;/code&gt;.</source>
          <target state="translated">엔티티와 연관된 시스템 식별자의 분석은 &lt;code&gt;Document.documentURI&lt;/code&gt; 를 사용하여 수행됩니다 . 그러나 [ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407&quot;&gt;DOM 레벨 3로드 및 저장&lt;/a&gt; ]에 정의 된 기능 &quot;LS&quot; 가 DOM 구현에서 지원되는 경우 &quot;resource-resolver&quot;매개 변수 는 &lt;code&gt;Document&lt;/code&gt; 노드에 첨부 된 &lt;code&gt;DOMConfiguration&lt;/code&gt; 객체 에서도 사용할 수 있습니다 . 이 매개 변수가 설정되면 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 는 &lt;code&gt;Document.documentURI&lt;/code&gt; 를 사용하는 대신 리소스 확인자를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1022ae785514449efe40f2c8963abb11d2504058" translate="yes" xml:space="preserve">
          <source>The resolve phase is controlled by two parameters, set on this class.</source>
          <target state="translated">확인 단계는이 클래스에서 설정 한 두 개의 매개 변수로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="6ad35174cec491d7c90515cea6438bbe6eeb865e" translate="yes" xml:space="preserve">
          <source>The resolved module with the given name or an empty &lt;code&gt;
         Optional&lt;/code&gt; if there isn't a module with this name in this configuration or any parent configurations</source>
          <target state="translated">주어진 이름을 가진 해결 된 모듈 또는 이 구성 또는 상위 구성에이 이름을 가진 모듈이없는 경우 빈 &lt;code&gt; Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a888b0082bf1bba928794b9e262d95500605aec" translate="yes" xml:space="preserve">
          <source>The resolved type descriptor at the call site of &lt;code&gt;invoke&lt;/code&gt; must be a valid argument to the receivers &lt;code&gt;asType&lt;/code&gt; method. In particular, the caller must specify the same argument arity as the callee's type, if the callee is not a &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity collector&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;invoke&lt;/code&gt; 의 호출 사이트에서 확인 된 유형 설명 자는 수신자 &lt;code&gt;asType&lt;/code&gt; 메소드에 대한 유효한 인수 여야합니다 . 특히 피 호출자가 &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity collector&lt;/a&gt; 가 아닌 경우 호출자는 피 호출자의 유형과 동일한 인수 arity를 ​​지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c2a61f04ea30a79177449a58b04a28b104802818" translate="yes" xml:space="preserve">
          <source>The resolved type descriptor at the call site of &lt;code&gt;invoke&lt;/code&gt; must be a valid argument to the receivers &lt;code&gt;asType&lt;/code&gt; method. In particular, the caller must specify the same argument arity as the callee's type, if the callee is not a &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity collector&lt;/a&gt;.</source>
          <target state="translated">의 호출 사이트에서 확인 된 유형 설명 &lt;code&gt;invoke&lt;/code&gt; 수신기에 대한 유효한 인수해야 &lt;code&gt;asType&lt;/code&gt; 의 방법. 특히, 수신자가 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;가변 arity 콜렉터&lt;/a&gt; 가 아닌 경우 호출자는 수신자 유형과 동일한 인수 arity를 ​​지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eea421ae13a64e1dbdbe93927bc945b3bf0f2116" translate="yes" xml:space="preserve">
          <source>The resolver that will be set on any XMLStreamReader or XMLEventReader created by this factory instance.</source>
          <target state="translated">이 팩토리 인스턴스에 의해 생성 된 XMLStreamReader 또는 XMLEventReader에 설정 될 리졸버입니다.</target>
        </trans-unit>
        <trans-unit id="adc8b5b806ac4d1ec6811f56446ced5b92623119" translate="yes" xml:space="preserve">
          <source>The resolver will first search the system-type of entries with the specified &lt;code&gt;systemId&lt;/code&gt;. The system entries include &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;rewriteSystem&lt;/code&gt; and &lt;code&gt;systemSuffix&lt;/code&gt; entries.</source>
          <target state="translated">해석기는 먼저 지정된 &lt;code&gt;systemId&lt;/code&gt; 를 사용하여 시스템 유형 항목을 검색합니다 . 시스템 항목에는 &lt;code&gt;system&lt;/code&gt; , &lt;code&gt;rewriteSystem&lt;/code&gt; 및 &lt;code&gt;systemSuffix&lt;/code&gt; 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="043a5d4e92d9440bd14303d4b664c8b6162aa2d5" translate="yes" xml:space="preserve">
          <source>The resource manager is doing work outside a global transaction.</source>
          <target state="translated">리소스 관리자는 전역 트랜잭션 외부에서 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3a78066f6d7d65570a29e16f616bfab963bff0e5" translate="yes" xml:space="preserve">
          <source>The resource manager returns zero or more XIDs of the transaction branches that are currently in a prepared or heuristically completed state. If an error occurs during the operation, the resource manager should throw the appropriate XAException.</source>
          <target state="translated">리소스 관리자는 현재 준비되었거나 경험적으로 완료된 상태에있는 트랜잭션 분기의 XID를 0 개 이상 반환합니다. 조작 중에 오류가 발생하면 자원 관리자는 적절한 XAException을 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="71062e973d41f6ccd0f7868eee574273010d7036" translate="yes" xml:space="preserve">
          <source>The resource manager rolled back the transaction branch for a reason not on this list.</source>
          <target state="translated">자원 관리자가이 목록에없는 이유로 트랜잭션 분기를 롤백했습니다.</target>
        </trans-unit>
        <trans-unit id="9ef095cc8f8eb9deb63e621a30579efd048e54dd" translate="yes" xml:space="preserve">
          <source>The resource requested or null.</source>
          <target state="translated">요청 된 리소스 또는 null입니다.</target>
        </trans-unit>
        <trans-unit id="4cdbf0e8f46078714d3bc07542a4974803f2d6c4" translate="yes" xml:space="preserve">
          <source>The resources will be located when the returned stream is evaluated. If the evaluation results in an &lt;code&gt;IOException&lt;/code&gt; then the I/O exception is wrapped in an &lt;a href=&quot;../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; that is then thrown.</source>
          <target state="translated">반환 된 스트림이 평가 될 때 리소스를 찾습니다. 평가 결과 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 I / O 예외가 발생 하는 &lt;a href=&quot;../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 으로&lt;/a&gt; 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3d61363b6633b0d99e034696664c54cea2da612" translate="yes" xml:space="preserve">
          <source>The response body can be discarded using one of &lt;a href=&quot;httpresponse.bodyhandlers#discarding()&quot;&gt;&lt;code&gt;discarding&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;httpresponse.bodyhandlers#replacing(U)&quot;&gt;&lt;code&gt;replacing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응답 본문은 &lt;a href=&quot;httpresponse.bodyhandlers#discarding()&quot;&gt; &lt;code&gt;discarding&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;httpresponse.bodyhandlers#replacing(U)&quot;&gt; &lt;code&gt;replacing&lt;/code&gt; &lt;/a&gt; 중 하나를 사용하여 폐기 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e89a0946db3ad76329915dbe1fb2d058415e9c15" translate="yes" xml:space="preserve">
          <source>The response body is not available through this, or the &lt;code&gt;
 HttpResponse&lt;/code&gt; API, but instead all response body is forwarded to the given &lt;code&gt;subscriber&lt;/code&gt;, which should make it available, if appropriate, through some other mechanism, e.g. an entry in a database, etc.</source>
          <target state="translated">응답 본문은이 또는 &lt;code&gt; HttpResponse&lt;/code&gt; API를 통해 사용할 수 없지만, 대신 모든 응답 본문이 주어진 &lt;code&gt;subscriber&lt;/code&gt; 에게 전달되며, 적절한 경우 데이터베이스의 항목과 같은 다른 메커니즘을 통해 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6dd06ecc31472bc0ffa478932d69394294897b00" translate="yes" xml:space="preserve">
          <source>The restore button text property.</source>
          <target state="translated">복원 단추 텍스트 속성입니다.</target>
        </trans-unit>
        <trans-unit id="99b6d2884fc55c38d82210c2985b9069bbb9d028" translate="yes" xml:space="preserve">
          <source>The result code. A zero value indicates success.</source>
          <target state="translated">결과 코드 값이 0이면 성공을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8613290fff9e558c87a48402abefab9874ccc8e4" translate="yes" xml:space="preserve">
          <source>The result does not depend on the local time zone.</source>
          <target state="translated">결과는 현지 시간대에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="921d7223769295c006da8a5575b7156fcaa03cc8" translate="yes" xml:space="preserve">
          <source>The result from JDK classes implementing &lt;code&gt;TemporalAccessor&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;TemporalAccessor&lt;/code&gt; 를 구현하는 JDK 클래스의 결과 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="295420590a431895b0a9587ea2bb7cf9aa9bc5d8" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;
 null&lt;/code&gt; and is a &lt;code&gt;FileTime&lt;/code&gt; that represents the same time. This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">결과는 &lt;code&gt;true&lt;/code&gt; 인수가 아닌 경우에만 경우 &lt;code&gt; null&lt;/code&gt; 과이다 &lt;code&gt;FileTime&lt;/code&gt; 같은 시간을 나타냅니다. 이 메서드는 &lt;code&gt;Object.equals&lt;/code&gt; 메서드 의 일반 계약을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="f6bd1c0a2aca7f162dd073e90d5740cb1616d84f" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;Color&lt;/code&gt; object that has the same red, green, blue, and alpha values as this object.</source>
          <target state="translated">결과는 인수가 &lt;code&gt;null&lt;/code&gt; 이 &lt;code&gt;Color&lt;/code&gt; 객체와 동일한 빨강, 녹색, 파랑 및 알파 값을 가진 Color 객체 인 경우에만 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17e6a87b8d0781fae57ea50faf6f5b7a370d70bb" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;FileTime&lt;/code&gt; that represents the same time. This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">결과는 &lt;code&gt;true&lt;/code&gt; 인수가 아닌 경우에만 경우 &lt;code&gt;null&lt;/code&gt; 과이다 &lt;code&gt;FileTime&lt;/code&gt; 같은 시간을 나타냅니다. 이 메소드는 &lt;code&gt;Object.equals&lt;/code&gt; 메소드 의 일반 계약을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5e94f4c32498ea093ba8d30e7750bbbc7e9c3bb7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;Rectangle&lt;/code&gt; object that has the same upper-left corner, width, and height as this &lt;code&gt;Rectangle&lt;/code&gt;.</source>
          <target state="translated">그 결과는 &lt;code&gt;true&lt;/code&gt; 인수가없는 경우 만 &lt;code&gt;null&lt;/code&gt; 및 인 &lt;code&gt;Rectangle&lt;/code&gt; 이 같은 왼쪽 상단, 폭 및 높이를 갖는 객체 &lt;code&gt;Rectangle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ad28501616ab98234ec816e4489d80b5e85181f" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is an &lt;code&gt;AlphaComposite&lt;/code&gt; object that has the same compositing rule and alpha value as this object.</source>
          <target state="translated">결과는 인수가 &lt;code&gt;null&lt;/code&gt; 이 &lt;code&gt;AlphaComposite&lt;/code&gt; 개체와 동일한 합성 규칙 및 알파 값을 가진 AlphaComposite 개체 인 경우에만 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0dee0b193f5269aef268cfda1e03af61caf65f1" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; only if two cookies come from same domain (case-insensitive), have same name (case-insensitive), and have same path (case-sensitive).</source>
          <target state="translated">결과는 두 개의 쿠키가 동일한 도메인 (대소 문자 구분)에서 왔으며 동일한 이름 (대소 문자 구분)이없고 동일한 경로 (대소 문자 구분) 가있는 &lt;code&gt;true&lt;/code&gt; 에만 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="838dc70d106c3ae54e71b7f7448a352db88afffd" translate="yes" xml:space="preserve">
          <source>The result is a Unicode character</source>
          <target state="translated">결과는 유니 코드 문자입니다</target>
        </trans-unit>
        <trans-unit id="bc5bbca2ba8440cf736ca085cdafbcea982ef541" translate="yes" xml:space="preserve">
          <source>The result is a boolean as defined by .</source>
          <target state="translated">결과는에 정의 된 부울입니다.</target>
        </trans-unit>
        <trans-unit id="6daca0572fa2e3689be9cd969023993b388ff672" translate="yes" xml:space="preserve">
          <source>The result is a boolean as defined by . Document modification does not invalidate the boolean, but may mean that reevaluation would not yield the same boolean.</source>
          <target state="translated">결과는에 정의 된 부울입니다. 문서 수정은 부울을 무효화하지 않지만 재평가가 동일한 부울을 생성하지 않음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432ed2e9a36f0af4da6066cc56714de8ffa1b599" translate="yes" xml:space="preserve">
          <source>The result is a lexical representation generated by &lt;a href=&quot;#toXMLFormat()&quot;&gt;&lt;code&gt;toXMLFormat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과는 &lt;a href=&quot;#toXMLFormat()&quot;&gt; &lt;code&gt;toXMLFormat()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 어휘 표현 입니다.</target>
        </trans-unit>
        <trans-unit id="35b56830c2c27888962f73364e19ecf38d296dd4" translate="yes" xml:space="preserve">
          <source>The result is a literal &lt;code&gt;'%'&lt;/code&gt; (&lt;code&gt;'\u0025'&lt;/code&gt;)</source>
          <target state="translated">결과는 리터럴 &lt;code&gt;'%'&lt;/code&gt; ( &lt;code&gt;'\u0025'&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="ae4eff0014f50b7dcbf3e89936f518508841602b" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by and will be accessed as a single node, which may be &lt;code&gt;null&lt;/code&gt; if the node set is empty.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이며 단일 노드로 액세스됩니다 . 노드 집합이 비어 있으면 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96f3383429aa4ff51f0bc6d090c4af1239ac45bb" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by and will be accessed as a single node, which may be &lt;code&gt;null&lt;/code&gt; if the node set is empty. Document modification does not invalidate the node, but may mean that the result node no longer corresponds to the current document. This is a convenience that permits optimization since the implementation can stop once the first node in document order of the resulting set has been found.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이며 단일 노드로 액세스됩니다 . 노드 집합이 비어 있으면 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 . 문서 수정은 노드를 무효화하지 않지만 결과 노드가 더 이상 현재 문서와 일치하지 않음을 의미 할 수 있습니다. 이는 결과 집합의 문서 순서에서 첫 번째 노드가 발견되면 구현이 중지 될 수 있으므로 최적화를 허용하는 편리함입니다.</target>
        </trans-unit>
        <trans-unit id="cdb1726b9875e2a160bca58ffbe30b5ab0c41014" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by and will be accessed as a single node, which may be &lt;code&gt;null&lt;/code&gt;if the node set is empty.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이며 단일 노드로 액세스됩니다 . 노드 집합이 비어 있으면 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="358c732c868abb77279bab5cc8355ef2118ac571" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by and will be accessed as a single node, which may be &lt;code&gt;null&lt;/code&gt;if the node set is empty. Document modification does not invalidate the node, but may mean that the result node no longer corresponds to the current document. This is a convenience that permits optimization since the implementation can stop once any node in the in the resulting set has been found.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이며 단일 노드로 액세스됩니다 . 노드 집합이 비어 있으면 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 . 문서 수정은 노드를 무효화하지 않지만 결과 노드가 더 이상 현재 문서와 일치하지 않음을 의미 할 수 있습니다. 이는 결과 집합의 노드가 발견되면 구현이 중지 될 수 있으므로 최적화를 허용하는 편리함입니다.</target>
        </trans-unit>
        <trans-unit id="85edb7883c94b4c8f105d8587ec9c989aef0737b" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed as a snapshot list of nodes that may not be in a particular order.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이 특정 순서가 아닐 수있는 노드의 스냅 샷 목록으로 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="174b1d816c94549926923caa33456b0dc42ce588" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed as a snapshot list of nodes that may not be in a particular order. Document modification does not invalidate the snapshot but may mean that reevaluation would not yield the same snapshot and nodes in the snapshot may have been altered, moved, or removed from the document.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이 특정 순서가 아닐 수있는 노드의 스냅 샷 목록으로 액세스됩니다. 문서 수정은 스냅 샷을 무효화하지 않지만 재평가로 인해 동일한 스냅 샷이 생성되지 않고 스냅 샷의 노드가 문서에서 변경, 이동 또는 제거되었을 수 있음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="843611d51bb59b3e46eddfa39c865102ee04bd8a" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed as a snapshot list of nodes that will be in original document order.</source>
          <target state="translated">결과는 원래 문서 순서로 될 노드의 스냅 샷 목록으로 액세스되는에 정의 된 노드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="15beecaa1540be581986e19ad22b5b109e2aea0a" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed as a snapshot list of nodes that will be in original document order. Document modification does not invalidate the snapshot but may mean that reevaluation would not yield the same snapshot and nodes in the snapshot may have been altered, moved, or removed from the document.</source>
          <target state="translated">결과는 원래 문서 순서로 될 노드의 스냅 샷 목록으로 액세스되는에 정의 된 노드 세트입니다. 문서 수정은 스냅 샷을 무효화하지 않지만 재평가로 인해 동일한 스냅 샷이 생성되지 않고 스냅 샷의 노드가 문서에서 변경, 이동 또는 제거되었을 수 있음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="800140e8356bd90792a7a183fb4673bef95846e1" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed iteratively, which may not produce nodes in a particular order.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이 반복적으로 액세스되며 특정 순서로 노드를 생성하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6f70ef0354dbeb103906c1ec6e6a7165b67c87a" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed iteratively, which may not produce nodes in a particular order. Document modification invalidates the iteration.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이 반복적으로 액세스되며 특정 순서로 노드를 생성하지 않을 수 있습니다. 문서 수정은 반복을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="1e4784f6a3b87d1fb8bfb9674268f934c807402e" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed iteratively, which will produce document-ordered nodes.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이 반복적으로 액세스되어 문서 순서 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cd68e4dbc9bd25a15e9385de489db23b32943a06" translate="yes" xml:space="preserve">
          <source>The result is a node set as defined by that will be accessed iteratively, which will produce document-ordered nodes. Document modification invalidates the iteration.</source>
          <target state="translated">결과는에 의해 정의 된 노드 집합이 반복적으로 액세스되어 문서 순서 노드를 생성합니다. 문서 수정은 반복을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="15b70fea7b0375f4f023b9de739b0c74b0a84fcb" translate="yes" xml:space="preserve">
          <source>The result is a number as defined by .</source>
          <target state="translated">결과는에 정의 된 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="366c87b0e726800596d866a1e609cd6c5037d777" translate="yes" xml:space="preserve">
          <source>The result is a number as defined by . Document modification does not invalidate the number, but may mean that reevaluation would not yield the same number.</source>
          <target state="translated">결과는에 정의 된 숫자입니다. 문서를 수정해도 번호가 무효화되지는 않지만 재평가에서 동일한 번호가 산출되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5d5a70ee2f877804a1742cf70fe027bad91629" translate="yes" xml:space="preserve">
          <source>The result is a string as defined by .</source>
          <target state="translated">결과는에 정의 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8727572713e384109dec911a60ada1205deaeec1" translate="yes" xml:space="preserve">
          <source>The result is a string as defined by . Document modification does not invalidate the string, but may mean that the string no longer corresponds to the current document.</source>
          <target state="translated">결과는에 정의 된 문자열입니다. 문서 수정은 문자열을 무효화하지 않지만 문자열이 더 이상 현재 문서와 일치하지 않음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef02a3668d69ce2348a1bc4508f08e4804908b1b" translate="yes" xml:space="preserve">
          <source>The result is a string that represents the sign and magnitude (absolute value) of the argument</source>
          <target state="translated">결과는 인수의 부호와 크기 (절대 값)를 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="50a9d6bfa24192970ed8fb8258874aefd0c97173" translate="yes" xml:space="preserve">
          <source>The result is a string that represents the sign and magnitude (absolute value) of the argument. The formatting of the sign is described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt;. The formatting of the magnitude</source>
          <target state="translated">결과는 인수의 부호와 크기 (절대 값)를 나타내는 문자열입니다. 부호의 형식은 &lt;a href=&quot;#L10nAlgorithm&quot;&gt;현지화 알고리즘에&lt;/a&gt; 설명되어 있습니다. 크기의 서식</target>
        </trans-unit>
        <trans-unit id="f2cfd2a95bfe92fd8ecc073d54de4e5f2a29bf7c" translate="yes" xml:space="preserve">
          <source>The result is associated with the first type that successfully parses. Normally, applications will use &lt;code&gt;instanceof&lt;/code&gt; to check the result. For example:</source>
          <target state="translated">결과는 성공적으로 구문 분석 한 첫 번째 유형과 연관됩니다. 일반적으로 응용 프로그램은 &lt;code&gt;instanceof&lt;/code&gt; 를 사용 하여 결과를 확인합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2603fe8103afc50e2378d77be85a45908bf61f3a" translate="yes" xml:space="preserve">
          <source>The result is formatted according to the XML Schema 1.0 spec and can be always parsed back later into the equivalent &lt;code&gt;Duration Object&lt;/code&gt; by &lt;a href=&quot;datatypefactory#newDuration(java.lang.String)&quot;&gt;&lt;code&gt;DatatypeFactory.newDuration(String  lexicalRepresentation)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과는 XML Schema 1.0 사양에 따라 형식이 지정되며 나중에 &lt;a href=&quot;datatypefactory#newDuration(java.lang.String)&quot;&gt; &lt;code&gt;DatatypeFactory.newDuration(String lexicalRepresentation)&lt;/code&gt; &lt;/a&gt; 의해 항상 동등한 &lt;code&gt;Duration Object&lt;/code&gt; 로 다시 구문 분석 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c479cf3264a2832bd0cd79a44afc9492a7822f3" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal integer</source>
          <target state="translated">결과는 십진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="1baf7d104748e0c4f8533df16bd664f663e30ad1" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal number</source>
          <target state="translated">결과는 10 진수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="5f14b19f3b75abbc59e057304d121d6548d56189" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal number in computerized scientific notation</source>
          <target state="translated">결과는 컴퓨터 공학 표기법에서 10 진수로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ab4d798c9eeb9edc29f6dcdd7b9bd66fea5cc6a" translate="yes" xml:space="preserve">
          <source>The result is formatted as a hexadecimal floating-point number with a significand and an exponent. This conversion is &lt;b&gt;not&lt;/b&gt; supported for the &lt;code&gt;BigDecimal&lt;/code&gt; type despite the latter's being in the</source>
          <target state="translated">결과는 유효하고 지수가있는 16 진수 부동 소수점 숫자로 형식이 지정됩니다. &lt;code&gt;BigDecimal&lt;/code&gt; 유형은 후자에 &lt;b&gt;있지만&lt;/b&gt; 이 변환은 지원 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="42563538eaee038d859706aa7ad8dd76aaba6a51" translate="yes" xml:space="preserve">
          <source>The result is formatted as a hexadecimal integer</source>
          <target state="translated">결과는 16 진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="5e4dac5beac66ef686eb3d95b633320454953615" translate="yes" xml:space="preserve">
          <source>The result is formatted as an octal integer</source>
          <target state="translated">결과는 8 진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="b924acf7a536ce1992d3ebe1342457a6f36dca7a" translate="yes" xml:space="preserve">
          <source>The result is formatted using computerized scientific notation or decimal format, depending on the precision and the value after rounding.</source>
          <target state="translated">결과는 반올림 후의 정밀도와 값에 따라 컴퓨터 화 된 과학적 표기법 또는 10 진수 형식을 사용하여 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9909e6819bf8d3b2b56ef5ec3cec62f6ed40ce7e" translate="yes" xml:space="preserve">
          <source>The result is obtained by invoking &lt;code&gt;Integer.toHexString(arg.hashCode())&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;Integer.toHexString(arg.hashCode())&lt;/code&gt; 를 호출하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb45f182258a186b18790c8b6cad368f2f9319d" translate="yes" xml:space="preserve">
          <source>The result is returned in an enumeration of &lt;code&gt;SearchResult&lt;/code&gt;s. Each &lt;code&gt;SearchResult&lt;/code&gt; contains the name of the object and other information about the object (see SearchResult). The name is either relative to the target context of the search (which is named by the &lt;code&gt;name&lt;/code&gt; parameter), or it is a URL string. If the target context is included in the enumeration (as is possible when &lt;code&gt;cons&lt;/code&gt; specifies a search scope of &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; or &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt;), its name is the empty string. The &lt;code&gt;SearchResult&lt;/code&gt; may also contain attributes of the matching object if the &lt;code&gt;cons&lt;/code&gt; argument specified that attributes be returned.</source>
          <target state="translated">결과는 &lt;code&gt;SearchResult&lt;/code&gt; 의 열거로 리턴됩니다 . 각 &lt;code&gt;SearchResult&lt;/code&gt; 에는 객체 이름과 객체에 대한 기타 정보가 포함됩니다 (SearchResult 참조). 이름은 검색의 대상 컨텍스트 ( &lt;code&gt;name&lt;/code&gt; 매개 변수로 이름 지정)에 상대적 이거나 URL 문자열입니다. 대상 컨텍스트가 열거에 포함 된 경우 ( &lt;code&gt;cons&lt;/code&gt; 가 &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; 또는 &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt; 의 검색 범위를 지정할 때 가능한 것처럼 ) 해당 이름은 빈 문자열입니다. &lt;code&gt;SearchResult&lt;/code&gt; 경우도 일치하는 객체의 속성을 포함 할 수있다 &lt;code&gt;cons&lt;/code&gt; 인수는 속성이 반환되도록 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="06f5e6bd8fe2e41c0946b6e4854fa774421e66fe" translate="yes" xml:space="preserve">
          <source>The result is that two threads are running concurrently: the current thread (which returns from the call to the &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its &lt;code&gt;run&lt;/code&gt; method).</source>
          <target state="translated">결과적으로 두 스레드가 동시에 실행됩니다. 현재 스레드 ( &lt;code&gt;start&lt;/code&gt; 메소드 호출에서 리턴 )와 다른 스레드 ( &lt;code&gt;run&lt;/code&gt; 메소드 실행 ).</target>
        </trans-unit>
        <trans-unit id="d28d29bf955a0a2e562abe4616fe55325dd93e91" translate="yes" xml:space="preserve">
          <source>The result is the platform-specific line separator</source>
          <target state="translated">결과는 플랫폼 별 행 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="16028df40d71c4c09ff419d356b5d9be1d2801c3" translate="yes" xml:space="preserve">
          <source>The result is the same as when using the following code:</source>
          <target state="translated">결과는 다음 코드를 사용할 때와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="41412fe4e863ea723be458262dd0cc609691ec90" translate="yes" xml:space="preserve">
          <source>The result is undefined if a given argument is out of bounds.</source>
          <target state="translated">주어진 인수가 범위를 벗어난 경우 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="058151d93a1ffc55deb73095cbeeabd4b91f7162" translate="yes" xml:space="preserve">
          <source>The result may be the same object or a different object. If the requested target view isn't available then the given bean is returned.</source>
          <target state="translated">결과는 동일한 객체이거나 다른 객체 일 수 있습니다. 요청 된 대상 뷰를 사용할 수 없으면 지정된 Bean이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d71f2225914f95f63b3119e8410020da3a87b63a" translate="yes" xml:space="preserve">
          <source>The result must be a concrete subclass of StartTlsResponse and must have a public zero-argument constructor.</source>
          <target state="translated">결과는 StartTlsResponse의 구체적인 서브 클래스 여야하며 인수없는 공용 인수 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="af94abbaed2e088160b3ad60033de749b3e7b4aa" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;analyzeCompletion(String input)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;analyzeCompletion(String input)&lt;/code&gt; 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="be5518c091fb9ed01f7f40cd601b33ede38bcea9" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;analyzeCompletion(String input)&lt;/code&gt;. Describes the completeness of the first snippet in the given input.</source>
          <target state="translated">&lt;code&gt;analyzeCompletion(String input)&lt;/code&gt; 의 결과입니다 . 주어진 입력에서 첫 번째 스 니펫의 완전성을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ddede63825319f46b754a759b7ce8eb4372db01a" translate="yes" xml:space="preserve">
          <source>The result of a DNS lookup for an LDAP URL.</source>
          <target state="translated">LDAP URL에 대한 DNS 조회 결과입니다.</target>
        </trans-unit>
        <trans-unit id="f6582fb948afbcc413b57e54cea0b30bde81e737" translate="yes" xml:space="preserve">
          <source>The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment do not overlap, but refer to overlapping regions of the same backing storage using different addresses. For example, this may occur if the same file is &lt;a href=&quot;#mapFromPath(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)&quot;&gt;&lt;code&gt;mapped&lt;/code&gt;&lt;/a&gt; to two segments.</source>
          <target state="translated">일반적이지 않은 경우 소스 세그먼트와이 세그먼트가 겹치지 않지만 다른 주소를 사용하는 동일한 백업 스토리지의 겹치는 영역을 참조하는 경우 대량 복사의 결과는 지정되지 않습니다. 예를 들어, 동일한 파일이 두 세그먼트에 &lt;a href=&quot;#mapFromPath(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)&quot;&gt; &lt;code&gt;mapped&lt;/code&gt; &lt;/a&gt; 경우이 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77ef281b848eda832ef63d0cbb4b3167978fdaff" translate="yes" xml:space="preserve">
          <source>The result of a match operation.</source>
          <target state="translated">일치 작업의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="16ff2b07c82c6850565061f19a2fba35ea83719e" translate="yes" xml:space="preserve">
          <source>The result of any attempt to modify a node passed to a &lt;code&gt;LSSerializerFilter&lt;/code&gt; is implementation dependent.</source>
          <target state="translated">&lt;code&gt;LSSerializerFilter&lt;/code&gt; 에 전달 된 노드를 수정하려는 시도의 결과 는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="86cbe802aaee405937142c5c8477e8e564f921ce" translate="yes" xml:space="preserve">
          <source>The result of applying this method to these arguments.</source>
          <target state="translated">이 방법을 이러한 인수에 적용한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="b31380d4fb2e0fe70212e83955d24c3b92a4b2b8" translate="yes" xml:space="preserve">
          <source>The result of dereferencing a &lt;code&gt;URIReference&lt;/code&gt; is either an instance of &lt;a href=&quot;octetstreamdata&quot;&gt;&lt;code&gt;OctetStreamData&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;nodesetdata&quot;&gt;&lt;code&gt;NodeSetData&lt;/code&gt;&lt;/a&gt;. Unless the &lt;code&gt;URIReference&lt;/code&gt; is a</source>
          <target state="translated">&lt;code&gt;URIReference&lt;/code&gt; 를 역 참조한 결과는 &lt;a href=&quot;octetstreamdata&quot;&gt; &lt;code&gt;OctetStreamData&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;nodesetdata&quot;&gt; &lt;code&gt;NodeSetData&lt;/code&gt; &lt;/a&gt; 인스턴스입니다 . 하지 않는 한 &lt;code&gt;URIReference&lt;/code&gt; 를가 인</target>
        </trans-unit>
        <trans-unit id="57688b2e9247501954c4e97e1843bbe216d0db07" translate="yes" xml:space="preserve">
          <source>The result of evaluating an XPath expression as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">XPath 표현식을 &lt;code&gt;String&lt;/code&gt; 으로 평가 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="187dde591e1a356faf91de53b761157c44b78684" translate="yes" xml:space="preserve">
          <source>The result of evaluating an XPath expression as an &lt;code&gt;Object&lt;/code&gt; of &lt;code&gt;returnType&lt;/code&gt;.</source>
          <target state="translated">int로서 XPath 식을 평가 한 결과 &lt;code&gt;Object&lt;/code&gt; 의 &lt;code&gt;returnType&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="06c9132221a6a96dee79b4ca2f11200dc474b3d2" translate="yes" xml:space="preserve">
          <source>The result of evaluating the &lt;code&gt;XPath&lt;/code&gt; function as an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XPath&lt;/code&gt; 함수를 &lt;code&gt;Object&lt;/code&gt; 로 평가 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="0fbfd9ab10f2fcfc0e43605231238f6c0ded7faf" translate="yes" xml:space="preserve">
          <source>The result of evaluating the expression.</source>
          <target state="translated">식을 평가 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="5429cf36c8fd7a2562aad20c9d7f000fb4661122" translate="yes" xml:space="preserve">
          <source>The result of invoking &lt;code&gt;toString()&lt;/code&gt; on the destination for the output</source>
          <target state="translated">출력 대상에서 &lt;code&gt;toString()&lt;/code&gt; 을 호출 한 결과</target>
        </trans-unit>
        <trans-unit id="f10bfc6a52d64bcc34aea2bf2ebde23c53dfafd9" translate="yes" xml:space="preserve">
          <source>The result of parsing drives these callback methods.</source>
          <target state="translated">파싱 ​​결과는 이러한 콜백 메서드를 구동합니다.</target>
        </trans-unit>
        <trans-unit id="73d45b66d9ffa1146363db71d3dd68e129484be6" translate="yes" xml:space="preserve">
          <source>The result of parsing drives these callback methods. The open and close actions should be balanced. The &lt;code&gt;flush&lt;/code&gt; method will be the last method called, to give the receiver a chance to flush any pending data into the document.</source>
          <target state="translated">파싱 ​​결과는 이러한 콜백 메서드를 구동합니다. 열기와 닫기 동작은 균형을 이루어야합니다. &lt;code&gt;flush&lt;/code&gt; 방법은 수신자에게 문서에 보류중인 데이터를 플러시 할 수있는 기회를주고, 마지막으로 호출 방법이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="44e206b266ba20a6d4c2e1a04be2e9225595f101" translate="yes" xml:space="preserve">
          <source>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</source>
          <target state="translated">주어진 입력을 처리 한 결과는 다른 입력의 존재 또는 부재 (직교성)의 함수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="352941c0badf85a2fe4b0a279f773a8faeda5d6a" translate="yes" xml:space="preserve">
          <source>The result of the evaluation of the XPath expression.For XPath 1.0 results, this object will be of type &lt;code&gt;XPathResult&lt;/code&gt;.</source>
          <target state="translated">XPath 식의 평가 결과입니다. XPath 1.0 결과의 경우이 개체는 &lt;code&gt;XPathResult&lt;/code&gt; 형식이됩니다 .For XPath 1.0 results, this object will be of type XPathResult .</target>
        </trans-unit>
        <trans-unit id="fe195ae57fa315bdb0e05f0a54cdd78c21fbbf3c" translate="yes" xml:space="preserve">
          <source>The result of this algorithm is chosen arbitrarily from the methods with most specific return type among all selected methods from step 3. Let R be a return type of a method M from the set of all selected methods from step 3. M is a method with most specific return type if there is no such method N != M from the same set, having return type S != R, such that S is a subtype of R as determined by R.class.&lt;a href=&quot;#isAssignableFrom(java.lang.Class)&quot;&gt;&lt;code&gt;isAssignableFrom(java.lang.Class&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;(S.class).</source>
          <target state="translated">이 알고리즘의 결과는 3 단계에서 선택한 모든 방법 중 가장 구체적인 반환 유형을 가진 방법에서 임의로 선택됩니다. R을 3 단계에서 선택한 모든 방법 집합에서 방법 M의 반환 유형이라고 가정합니다. M은 다음과 같은 방법입니다. 동일한 세트에서 N! = M 메소드가없는 경우 가장 구체적인 리턴 유형은 리턴 유형 S! = R을 갖습니다. S는 R.class에 의해 결정된 R의 하위 유형입니다. &lt;a href=&quot;#isAssignableFrom(java.lang.Class)&quot;&gt; &lt;code&gt;isAssignableFrom(java.lang.Class&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; (S.class).</target>
        </trans-unit>
        <trans-unit id="e7fdb4e83c0852b667620524f411ba48b7948b95" translate="yes" xml:space="preserve">
          <source>The result of this algorithm is the union of all selected methods from step 3.</source>
          <target state="translated">이 알고리즘의 결과는 3 단계에서 선택한 모든 방법의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="53dcb69ac17959659b0334122a358f8985fa05ac" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. In most cases, the positive/negative sign will be the same in each of the supported fields.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 대부분의 경우 양수 / 음수 부호는 지원되는 각 필드에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7daa711ab9261153416c162a0aec24648bdcf12b" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 음수 부호는 매년, 월, 일마다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="70f2097d3f2bdbf3980ebc845ba5296b4a7310cf" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. To guarantee to obtain a positive duration call &lt;a href=&quot;#abs()&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; on the result.</source>
          <target state="translated">이 방법의 결과는 종료가 시작 이전 인 경우 음수 기간이 될 수 있습니다. 양수 기간을 확보하려면 결과에 대해 &lt;a href=&quot;#abs()&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="84fc9d37222c832e8afbf150d8f6699253efda20" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. To guarantee to obtain a positive duration call &lt;a href=&quot;duration#abs--&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; on the result.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 결과에 대해 긍정적 인 지속 시간을 얻기 위해 &lt;a href=&quot;duration#abs--&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="fdc023462e3c1d38fa0fae3a92e16cba6d2639d7" translate="yes" xml:space="preserve">
          <source>The result of this method is &lt;code&gt;TemporalAccessor&lt;/code&gt; which represents the data as seen in the input. Values are not validated, thus parsing a date string of '2012-00-65' would result in a temporal with three fields - year of '2012', month of '0' and day-of-month of '65'.</source>
          <target state="translated">이 메소드의 결과 는 입력에 표시된대로 데이터를 나타내는 &lt;code&gt;TemporalAccessor&lt;/code&gt; 입니다. 값의 유효성이 검사되지 않으므로 '2012-00-65'날짜 문자열을 구문 분석하면 '2012'연도, '0'월 및 '65'월의 세 필드로 된 시간이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52fc7eddd6f4fde58aa8d10634dec95344d469b7" translate="yes" xml:space="preserve">
          <source>The result of this method is absolute if, and only if, either this URI is absolute or the given URI is absolute.</source>
          <target state="translated">이 URI가 절대이거나 지정된 URI가 절대 인 경우에만이 메소드의 결과는 절대입니다.</target>
        </trans-unit>
        <trans-unit id="09c0c8baacc8b26a7914b1dbea349839039a03cd" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;#insert(int,java.lang.CharSequence,int,int)&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메서드의 결과는 마치이 개체의 &lt;a href=&quot;#insert(int,java.lang.CharSequence,int,int)&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메서드 의 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="33f42a4bb7c7ad421307948fd84808d9ca5b7265" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;stringbuffer#insert-int-java.lang.CharSequence-int-int-&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메소드의 결과는이 오브젝트의 &lt;a href=&quot;stringbuffer#insert-int-java.lang.CharSequence-int-int-&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메소드를 호출 한 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e72a2494b9f2adf3a9c829328a4201155a935ee8" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;stringbuilder#insert-int-java.lang.CharSequence-int-int-&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메소드의 결과는이 오브젝트의 &lt;a href=&quot;stringbuilder#insert-int-java.lang.CharSequence-int-int-&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메소드를 호출 한 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8aac06f8f47a270c52f5af0438f30546f8c15210" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this.append(s, 0, s.length());</source>
          <target state="translated">이 메소드의 결과는 this.append (s, 0, s.length ())의 호출 인 경우와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7b7539ebe1108c837cb3ebf5e22050282d869cda" translate="yes" xml:space="preserve">
          <source>The result of this method is never null. This method only associates the returned &lt;code&gt;KeyTab&lt;/code&gt; object with the default keytab file and does not read it.</source>
          <target state="translated">이 메소드의 결과는 결코 null이 아닙니다. 이 메소드는 리턴 된 &lt;code&gt;KeyTab&lt;/code&gt; 오브젝트를 기본 키탭 파일 에만 연관시키고 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7001452e9a69f2ce57bba98f6683a9cf75e695fd" translate="yes" xml:space="preserve">
          <source>The result of this method is never null. This method only associates the returned &lt;code&gt;KeyTab&lt;/code&gt; object with the file and does not read it.</source>
          <target state="translated">이 메소드의 결과는 결코 null이 아닙니다. 이 메소드는 리턴 된 &lt;code&gt;KeyTab&lt;/code&gt; 오브젝트 만 파일과 연관시키고 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5dddf426eb8badc7192516892b3925d64fec814" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;../temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;../temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="c493abfdae35894af24f4901c426e667b33769ca" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;../temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;../temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="cf14aaf159e93918c79f0986121a7011b52fe97e" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporaladjuster#adjustInto(java.time.temporal.Temporal)&quot;&gt;&lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt;&lt;/a&gt; method on the specified adjuster passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporaladjuster#adjustInto(java.time.temporal.Temporal)&quot;&gt; &lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 조정기에 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="c9079bf22411247394dc7e14291f74d7e689d317" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporaladjuster#adjustInto-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt;&lt;/a&gt; method on the specified adjuster passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporaladjuster#adjustInto-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 조정기에 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="952caf818a8c4cd6663bea809ef9d640be5e151b" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporalquery#queryFrom(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="ed9634345d8412156512a42500e34a894cf4c2f5" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="9b7fc7cadcbbb563002dfc29694594763d5fe98f" translate="yes" xml:space="preserve">
          <source>The result of this method will make up the contents of the SASL buffer as defined in RFC 2222 without the leading four octet field that represents the length. &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; specify the portion of &lt;code&gt;outgoing&lt;/code&gt; to use.</source>
          <target state="translated">이 방법의 결과는 길이를 나타내는 선행 4 옥텟 필드없이 RFC 2222에 정의 된대로 SASL 버퍼의 내용을 구성합니다. &lt;code&gt;offset&lt;/code&gt; 과 &lt;code&gt;len&lt;/code&gt; 은 사용할 &lt;code&gt;outgoing&lt;/code&gt; 부분을 ​​지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b8cb5fb0da99e3e289350d5c66fac89988702d0" translate="yes" xml:space="preserve">
          <source>The result returned by the &lt;a href=&quot;keyselector#select(javax.xml.crypto.dsig.keyinfo.KeyInfo,javax.xml.crypto.KeySelector.Purpose,javax.xml.crypto.AlgorithmMethod,javax.xml.crypto.XMLCryptoContext)&quot;&gt;&lt;code&gt;KeySelector.select&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;keyselector#select(javax.xml.crypto.dsig.keyinfo.KeyInfo,javax.xml.crypto.KeySelector.Purpose,javax.xml.crypto.AlgorithmMethod,javax.xml.crypto.XMLCryptoContext)&quot;&gt; &lt;code&gt;KeySelector.select&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 결과 입니다.</target>
        </trans-unit>
        <trans-unit id="9369d2fab7f01eadc45cae17b70a104674f355e1" translate="yes" xml:space="preserve">
          <source>The result returned by the call is boxed if it is a primitive, or forced to null if the return type is void.</source>
          <target state="translated">호출이 리턴 한 결과는 기본 인 경우 상자로 표시되거나 리턴 유형이 void 인 경우 강제로 널로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="806535d76174a264f9b4ff6d7c99faca08eddf1e" translate="yes" xml:space="preserve">
          <source>The result returned by the hook must be a method handle of exactly the same type as the call site.</source>
          <target state="translated">후크가 리턴 한 결과는 호출 사이트와 정확히 동일한 유형의 메소드 핸들이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ab16e8f218d193e2ac56d5cea7e3ab465621608f" translate="yes" xml:space="preserve">
          <source>The result set contains one row for each array element, with two columns in each row. The second column stores the element value; the first column stores the index into the array for that element (with the first array element being at index 1). The rows are in ascending order corresponding to the order of the indices.</source>
          <target state="translated">결과 집합에는 각 배열 요소에 대해 하나의 행이 포함되며 각 행에는 두 개의 열이 있습니다. 두 번째 열은 요소 값을 저장합니다. 첫 번째 열은 해당 요소의 배열에 색인을 저장합니다 (첫 번째 배열 요소는 색인 1에 있음). 행은 인덱스 순서에 따라 오름차순입니다.</target>
        </trans-unit>
        <trans-unit id="c7fbca7853e7e584b81e78e65665e66e2c6c2224" translate="yes" xml:space="preserve">
          <source>The result set has one row for each element of the SQL array designated by this object, with the first row containing the element at index &lt;code&gt;index&lt;/code&gt;. The result set has up to &lt;code&gt;count&lt;/code&gt; rows in ascending order based on the indices. Each row has two columns: The second column stores the element value; the first column stores the index into the array for that element.</source>
          <target state="translated">결과 집합에는이 개체가 지정한 SQL 배열의 각 요소에 대해 하나의 행이 있으며 첫 번째 행에는 index &lt;code&gt;index&lt;/code&gt; 의 요소가 포함 됩니다. 결과 집합에는 인덱스에 따라 오름차순으로 행 &lt;code&gt;count&lt;/code&gt; 있습니다. 각 행에는 두 개의 열이 있습니다. 두 번째 열에는 요소 값이 저장됩니다. 첫 번째 열은 해당 요소의 배열에 인덱스를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="59d025c7c37030729df1da6ef20378d1c89b991c" translate="yes" xml:space="preserve">
          <source>The result should use a conversion-dependent alternate form</source>
          <target state="translated">결과는 변환 종속 대체 양식을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="8f5827a90eb65856b4b89ffb933882240c216cc7" translate="yes" xml:space="preserve">
          <source>The result type of a &lt;a href=&quot;filevisitor&quot;&gt;&lt;code&gt;FileVisitor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;filevisitor&quot;&gt; &lt;code&gt;FileVisitor&lt;/code&gt; &lt;/a&gt; 의 결과 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3849090ea96c80661699ab68840a57cdce6665f1" translate="yes" xml:space="preserve">
          <source>The result value of successful run.</source>
          <target state="translated">성공적인 실행의 결과 값입니다.</target>
        </trans-unit>
        <trans-unit id="abb40e009ce6b33ab82fd10fa336473f4e491d2a" translate="yes" xml:space="preserve">
          <source>The result value of successful run. The value is null if not executed or an exception was thrown.</source>
          <target state="translated">성공적인 실행의 결과 값입니다. 실행되지 않았거나 예외가 발생한 경우 값은 null입니다.</target>
        </trans-unit>
        <trans-unit id="2d7644c465280fb43e327f5847a1469aaa7aec19" translate="yes" xml:space="preserve">
          <source>The result will always include a sign</source>
          <target state="translated">결과는 항상 부호를 포함합니다</target>
        </trans-unit>
        <trans-unit id="c5f0ab9813b2497b6aace9d0a659cb51a7b9e650" translate="yes" xml:space="preserve">
          <source>The result will be left-justified.</source>
          <target state="translated">결과는 왼쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5cd03f8040d572a14698fa4790b45d2dea79538f" translate="yes" xml:space="preserve">
          <source>The result will be null if it is called on the root Logger in the namespace.</source>
          <target state="translated">네임 스페이스의 루트 로거에서 호출 된 경우 결과는 null입니다.</target>
        </trans-unit>
        <trans-unit id="eebffb3b7f508dfd870235eaedb8bd617c34fb42" translate="yes" xml:space="preserve">
          <source>The result will be zero-padded</source>
          <target state="translated">결과는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="ac5d38a04d258f50b2e728006d792d84ec797c12" translate="yes" xml:space="preserve">
          <source>The result will enclose negative numbers in parentheses</source>
          <target state="translated">결과는 괄호 안에 음수를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="b60dbdb0c739a0db71280a2d5057407b2907dcbf" translate="yes" xml:space="preserve">
          <source>The result will include a leading space for positive values</source>
          <target state="translated">결과는 양수 값을위한 선행 공간을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="99b73d58b5f8e32d7a839a384b8c3e4612121e9f" translate="yes" xml:space="preserve">
          <source>The result will include locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;grouping separators&lt;/a&gt;</source>
          <target state="translated">결과에는 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;그룹화 구분 기호&lt;/a&gt; 가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="86565ee42252b8d90b6fc4f6a7e56b8ff7846015" translate="yes" xml:space="preserve">
          <source>The result will include locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separators&lt;/a&gt;</source>
          <target state="translated">결과는 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;그룹 구분 기호를 포함합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da36d6b79c4c033f7a27b28c533a4819c6e58026" translate="yes" xml:space="preserve">
          <source>The resultant byte array</source>
          <target state="translated">결과 바이트 배열</target>
        </trans-unit>
        <trans-unit id="094bc7c12af1c9c170e626d26c061113ab22168d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Class&lt;/code&gt; object</source>
          <target state="translated">결과 &lt;code&gt;Class&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="776a2beb758c091693ee57d4a8d599511a9379bd" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Class&lt;/code&gt; object, or &lt;code&gt;null&lt;/code&gt; if the class could not be found.</source>
          <target state="translated">결과 &lt;code&gt;Class&lt;/code&gt; 객체 . 클래스를 찾을 수없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04d7e541442907c4718e4aa6df8cb95ea6facb8b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Path&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;Path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d9cee928349ecad8207afb80abfb3ac1e49b7c6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;String&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9c998e00f65f9ad466e49086e9abcbd51c428c9" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Version&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;Version&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2eb30aecd9ce3fd342fd1fb862917adbede7e62" translate="yes" xml:space="preserve">
          <source>The resulting Class object.</source>
          <target state="translated">결과 Class 객체.</target>
        </trans-unit>
        <trans-unit id="64fd0e638650ed8a264bb09d0464e8bdf66b1c52" translate="yes" xml:space="preserve">
          <source>The resulting URI</source>
          <target state="translated">결과 URI</target>
        </trans-unit>
        <trans-unit id="f09e99077085a93a3362b510af059c6626ecc325" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed as if by invoking the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor and then invoking the &lt;a href=&quot;#parseServerAuthority()&quot;&gt;&lt;code&gt;parseServerAuthority()&lt;/code&gt;&lt;/a&gt; method upon the result; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">결과 URI 문자열은 &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출 한 다음 결과에 대해 &lt;a href=&quot;#parseServerAuthority()&quot;&gt; &lt;code&gt;parseServerAuthority()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하는 것처럼 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7419fc69db0c5232d5bde59115b8e8bbc2a129ee" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed as if by invoking the &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor and then invoking the &lt;a href=&quot;uri#parseServerAuthority--&quot;&gt;&lt;code&gt;parseServerAuthority()&lt;/code&gt;&lt;/a&gt; method upon the result; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">결과 URI 문자열은 마치 &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출 한 다음 결과에 따라 &lt;a href=&quot;uri#parseServerAuthority--&quot;&gt; &lt;code&gt;parseServerAuthority()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것처럼 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0092d38cbcba375e121b4dfada28b43109355f6" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed in order to create the new URI instance as if by invoking the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">결과 URI 문자열은 마치 &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출하는 것처럼 새 URI 인스턴스를 만들기 위해 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a50f9807a1fa543061a71bf50d779ccfe528067" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed in order to create the new URI instance as if by invoking the &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">&lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출하는 것처럼 새 URI 인스턴스를 작성하기 위해 결과 URI 문자열이 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1cbbe9ae02dde33f88ed9dbc263ec8e5ac65206" translate="yes" xml:space="preserve">
          <source>The resulting adapter is the same type as the target, except that the first parameter type is dropped, if it corresponds to the result of the combiner.</source>
          <target state="translated">결과 어댑터는 첫 번째 매개 변수 유형이 결합기의 결과에 해당하는 경우 삭제되는 것을 제외하고 대상과 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0492a8e1954857252e9e87bc20c1aba15bfe6e4d" translate="yes" xml:space="preserve">
          <source>The resulting arc begins at &lt;code&gt;startAngle&lt;/code&gt; and extends for &lt;code&gt;arcAngle&lt;/code&gt; degrees, using the current color. Angles are interpreted such that 0 degrees is at the 3 o'clock position. A positive value indicates a counter-clockwise rotation while a negative value indicates a clockwise rotation.</source>
          <target state="translated">결과 호는 &lt;code&gt;startAngle&lt;/code&gt; 에서 시작 하여 현재 색상을 사용하여 &lt;code&gt;arcAngle&lt;/code&gt; 각도로 확장됩니다 . 각도는 0 도가 3시 위치에 있도록 해석됩니다. 양수 값은 시계 반대 방향 회전을 나타내고 음수 값은 시계 방향 회전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="43e6530ff8fe5ba50d8fda3e44fc6556cf949d6b" translate="yes" xml:space="preserve">
          <source>The resulting arc begins at &lt;code&gt;startAngle&lt;/code&gt; and extends for &lt;code&gt;arcAngle&lt;/code&gt; degrees. Angles are interpreted such that 0 degrees is at the 3 o'clock position. A positive value indicates a counter-clockwise rotation while a negative value indicates a clockwise rotation.</source>
          <target state="translated">결과 호는 &lt;code&gt;startAngle&lt;/code&gt; 에서 시작하여 &lt;code&gt;arcAngle&lt;/code&gt; 각도로 확장됩니다 . 각도는 0 도가 3시 위치에 있도록 해석됩니다. 양수 값은 시계 반대 방향 회전을 나타내고 음수 값은 시계 방향 회전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f03fd98b1be6d4bac23f1b8c056fc776f2b93ba7" translate="yes" xml:space="preserve">
          <source>The resulting arc covers an area &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels wide by &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels tall.</source>
          <target state="translated">결과 호는 영역 &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 너비 x &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 높이를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6c786abb2aba329e942d81e1d06f1d11b97967b9" translate="yes" xml:space="preserve">
          <source>The resulting array is of exactly the same class as the original array.</source>
          <target state="translated">결과 배열은 원래 배열과 정확히 같은 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c5a1157b9f760855069d2f10df624ea637e64ca4" translate="yes" xml:space="preserve">
          <source>The resulting asynchronous channel group reuses a fixed number of threads. At any point, at most &lt;code&gt;nThreads&lt;/code&gt; threads will be active processing tasks that are submitted to handle I/O events and dispatch completion results for operations initiated on asynchronous channels in the group.</source>
          <target state="translated">결과 비동기 채널 그룹은 고정 된 수의 스레드를 재사용합니다. 어느 시점에서나 최대 &lt;code&gt;nThreads&lt;/code&gt; 스레드는 I / O 이벤트를 처리하고 그룹의 비동기 채널에서 시작된 작업에 대한 완료 결과를 디스패치하기 위해 제출되는 활성 처리 작업입니다.</target>
        </trans-unit>
        <trans-unit id="2e1c0df7b54fbf773f3c4b5bcdbc4bfa62115cb7" translate="yes" xml:space="preserve">
          <source>The resulting attribute has the set difference of its prior value set and the specified value set. If no values are specified, deletes the entire attribute. If the attribute does not exist, or if some or all members of the specified value set do not exist, this absence may be ignored and the operation succeeds, or a NamingException may be thrown to indicate the absence. Removal of the last value will remove the attribute if the attribute is required to have at least one value.</source>
          <target state="translated">결과 속성에는 이전 값 세트와 지정된 값 세트의 차이가 설정됩니다. 값을 지정하지 않으면 전체 속성을 삭제합니다. 속성이 존재하지 않거나 지정된 값 세트의 일부 또는 모든 멤버가 존재하지 않으면이 부재가 무시되고 조작이 성공하거나 부재를 표시하기 위해 NamingException이 발생 될 수 있습니다. 속성에 하나 이상의 값이 필요한 경우 마지막 값을 제거하면 속성이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5f77135844d22a07c9384b526ec687f24d01356f" translate="yes" xml:space="preserve">
          <source>The resulting buffer's byte order is &lt;a href=&quot;../../../../java.base/java/nio/byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;; this can be changed using &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer#order(java.nio.ByteOrder)&quot;&gt;&lt;code&gt;ByteBuffer.order(java.nio.ByteOrder)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 버퍼의 바이트 순서는 &lt;a href=&quot;../../../../java.base/java/nio/byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; 입니다&lt;/a&gt; . 이것은 &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer#order(java.nio.ByteOrder)&quot;&gt; &lt;code&gt;ByteBuffer.order(java.nio.ByteOrder)&lt;/code&gt; &lt;/a&gt; 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a8b051c029a9cb257557ce55a86701099f33ad0" translate="yes" xml:space="preserve">
          <source>The resulting channel is associated with default thread pool to which tasks are submitted to handle I/O events and dispatch to completion handlers that consume the result of asynchronous operations performed on the resulting channel.</source>
          <target state="translated">결과 채널은 I / O 이벤트를 처리하고 결과 채널에서 수행 된 비동기 작업의 결과를 사용하는 완료 핸들러로 디스패치하기 위해 태스크가 제출되는 기본 스레드 풀과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="2e0477159a435eb4c7b6e87913d4947dad931600" translate="yes" xml:space="preserve">
          <source>The resulting channel will not be buffered; it will simply redirect its I/O operations to the given stream. Closing the channel will in turn cause the stream to be closed.</source>
          <target state="translated">결과 채널은 버퍼링되지 않습니다. 단순히 I / O 작업을 지정된 스트림으로 리디렉션합니다. 채널을 닫으면 스트림이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b0000228e6c4ee5b53397bc48274afbcc1060a57" translate="yes" xml:space="preserve">
          <source>The resulting collector functions do the following:</source>
          <target state="translated">결과 수집기 함수는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7c15e2a1ba12feb9a34cac207a386731897606ad" translate="yes" xml:space="preserve">
          <source>The resulting collector is &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt;&lt;code&gt;Collector.Characteristics.UNORDERED&lt;/code&gt;&lt;/a&gt; if both downstream collectors are unordered and &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt;&lt;code&gt;Collector.Characteristics.CONCURRENT&lt;/code&gt;&lt;/a&gt; if both downstream collectors are concurrent.</source>
          <target state="translated">두 다운 스트림 콜렉터가 모두 순서가 지정되지 않은 경우 결과 콜렉터는 &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt; &lt;code&gt;Collector.Characteristics.UNORDERED&lt;/code&gt; &lt;/a&gt; 이고 두 다운 스트림 콜렉터가 동시에있는 경우 &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt; &lt;code&gt;Collector.Characteristics.CONCURRENT&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e7f4afa7fa2b1530937581bdba920189b54b7a0" translate="yes" xml:space="preserve">
          <source>The resulting context is for resolving URLs of the scheme &lt;code&gt;scheme&lt;/code&gt;. The resulting context is not tied to a specific URL. It is able to handle arbitrary URLs with the specified scheme.</source>
          <target state="translated">결과 컨텍스트는 체계 &lt;code&gt;scheme&lt;/code&gt; URL을 확인하기위한 것 입니다. 결과 컨텍스트는 특정 URL에 연결되지 않습니다. 지정된 체계로 임의의 URL을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b4ed36145c18184a4c0192876b36f57186eb11b9" translate="yes" xml:space="preserve">
          <source>The resulting file attribute view can be used to read or update the attributes of file in this directory. The &lt;code&gt;type&lt;/code&gt; parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; always returns an instance of that class that is bound to the file in the directory.</source>
          <target state="translated">결과 파일 속성보기를 사용하여이 디렉토리에서 파일의 속성을 읽거나 업데이트 할 수 있습니다. &lt;code&gt;type&lt;/code&gt; 파라미터 속성보기 유형을 지정하고 지원하는 경우에있어서 그 타입의 인스턴스를 리턴한다. &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 를 얻기 위해이 메소드를 호출하면 항상 디렉토리의 파일에 바인드 된 해당 클래스의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d791ce15a89946bb449aad309d10e2028011d0e0" translate="yes" xml:space="preserve">
          <source>The resulting file attribute view can be used to read or update the attributes of this (open) directory. The &lt;code&gt;type&lt;/code&gt; parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; always returns an instance of that class that is bound to this open directory.</source>
          <target state="translated">결과 파일 속성보기를 사용하여이 (열린) 디렉토리의 속성을 읽거나 업데이트 할 수 있습니다. &lt;code&gt;type&lt;/code&gt; 파라미터 속성보기 유형을 지정하고 지원하는 경우에있어서 그 타입의 인스턴스를 리턴한다. &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 를 얻기 위해이 메소드를 호출하면 항상이 열린 디렉토리에 바인드 된 해당 클래스의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1c0268e4ebd731468a02d197d2029a7d6d6cfbfc" translate="yes" xml:space="preserve">
          <source>The resulting file names must match exactly as strings with their occurrences in the JAR file.</source>
          <target state="translated">결과 파일 이름은 JAR 파일에서 발생하는 문자열과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d48fd783d3474da2a240f1521be0f07a0215d13" translate="yes" xml:space="preserve">
          <source>The resulting filter performs the limit checks and then tries to match the class, if any. If any of the limits are exceeded, the filter returns &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt;&lt;code&gt;Status.REJECTED&lt;/code&gt;&lt;/a&gt;. If the class is an array type, the class to be matched is the element type. Arrays of any number of dimensions are treated the same as the element type. For example, a pattern of &quot;&lt;code&gt;!example.Foo&lt;/code&gt;&quot;, rejects creation of any instance or array of &lt;code&gt;example.Foo&lt;/code&gt;. The first pattern that matches, working from left to right, determines the &lt;a href=&quot;objectinputfilter.status#ALLOWED&quot;&gt;&lt;code&gt;Status.ALLOWED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt;&lt;code&gt;Status.REJECTED&lt;/code&gt;&lt;/a&gt; result. If the limits are not exceeded and no pattern matches the class, the result is &lt;a href=&quot;objectinputfilter.status#UNDECIDED&quot;&gt;&lt;code&gt;Status.UNDECIDED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 필터는 제한 검사를 수행 한 다음 클래스 일치를 시도합니다 (있는 경우). 한도를 초과하면 필터는 &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt; &lt;code&gt;Status.REJECTED&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 클래스가 배열 유형 인 경우 일치 할 클래스는 요소 유형입니다. 모든 차원의 배열은 요소 유형과 동일하게 처리됩니다. 예를 들어, &quot;패턴 &lt;code&gt;!example.Foo&lt;/code&gt; &quot;의 인스턴스 또는 어레이의 제작 거부 &lt;code&gt;example.Foo&lt;/code&gt; 를 . 일치하는 첫 번째 패턴 (왼쪽에서 오른쪽으로 작동)은 &lt;a href=&quot;objectinputfilter.status#ALLOWED&quot;&gt; &lt;code&gt;Status.ALLOWED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt; &lt;code&gt;Status.REJECTED&lt;/code&gt; &lt;/a&gt; 결과를 결정합니다 . 한계를 초과하지 않고 클래스와 일치하는 패턴이없는 경우 결과는 &lt;a href=&quot;objectinputfilter.status#UNDECIDED&quot;&gt; &lt;code&gt;Status.UNDECIDED&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39b37f06bbf698636d93a2ea1a9e0ccaad0b21fe" translate="yes" xml:space="preserve">
          <source>The resulting formatted String will normally include a localized and formatted version of the LogRecord's message field. It is recommended to use the &lt;a href=&quot;#formatMessage(java.util.logging.LogRecord)&quot;&gt;&lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt;&lt;/a&gt; convenience method to localize and format the message field.</source>
          <target state="translated">결과 형식화 된 문자열에는 일반적으로 LogRecord 메시지 필드의 현지화 및 형식화 된 버전이 포함됩니다. &lt;a href=&quot;#formatMessage(java.util.logging.LogRecord)&quot;&gt; &lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt; &lt;/a&gt; 편의 메서드를 사용하여 메시지 필드를 지역화하고 형식을 지정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c1dd0222947bfa0316d9b432e87769219a094695" translate="yes" xml:space="preserve">
          <source>The resulting formatted String will normally include a localized and formatted version of the LogRecord's message field. It is recommended to use the &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt;&lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt;&lt;/a&gt; convenience method to localize and format the message field.</source>
          <target state="translated">결과 형식화 된 문자열에는 일반적으로 현지화 된 형식의 LogRecord 메시지 필드 버전이 포함됩니다. 메시지 필드를 현지화하고 형식화하려면 &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt; &lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt; &lt;/a&gt; 편의 메소드 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a440b10bec8baf92c276afc34bf461c3ea93f484" translate="yes" xml:space="preserve">
          <source>The resulting handle will have the same return type as the target handle.</source>
          <target state="translated">결과 핸들은 대상 핸들과 동일한 반환 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f9b393261c3425d386d8251817252af6f14e85a9" translate="yes" xml:space="preserve">
          <source>The resulting instance of the required type will respond to invocation of the type's uniquely named method by calling the given target on the incoming arguments, and returning or throwing whatever the target returns or throws. The invocation will be as if by &lt;code&gt;target.invoke&lt;/code&gt;. The target's type will be checked before the instance is created, as if by a call to &lt;code&gt;asType&lt;/code&gt;, which may result in a &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.</source>
          <target state="translated">필요한 형식의 결과 인스턴스는 들어오는 인수에서 지정된 대상을 호출하고 대상이 반환하거나 던지는 모든 것을 반환하거나 던져서 형식의 고유 한 명명 된 메서드 호출에 응답합니다. &lt;code&gt;target.invoke&lt;/code&gt; 에 의한 호출이됩니다 . 인스턴스가 생성되기 전에 목표의 유형 것처럼 호출하여 체크한다 &lt;code&gt;asType&lt;/code&gt; A의 발생할 수 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de4b752490153330ced19eb1636ec25661fe14d" translate="yes" xml:space="preserve">
          <source>The resulting list is &lt;code&gt;[a, c, d, b, e]&lt;/code&gt;.</source>
          <target state="translated">결과 목록은 &lt;code&gt;[a, c, d, b, e]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c292f8233ecc218c4ef8e408a4e751545e0593e6" translate="yes" xml:space="preserve">
          <source>The resulting list would contain &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;&quot;def&quot;&lt;/code&gt;, the empty string, and &lt;code&gt;&quot;ghi&quot;&lt;/code&gt;.</source>
          <target state="translated">결과 목록에는 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , &lt;code&gt;&quot;def&quot;&lt;/code&gt; , 빈 문자열 및 &lt;code&gt;&quot;ghi&quot;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="2678a315bb7b0ca19efcf39c01d949c69b6ab3c7" translate="yes" xml:space="preserve">
          <source>The resulting lookup's capabilities for loading classes (used during &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt;&lt;code&gt;findClass(java.lang.String)&lt;/code&gt;&lt;/a&gt; invocations) are determined by the lookup class' loader, which may change due to this operation.</source>
          <target state="translated">클래스를로드하기위한 결과 조회 기능 ( &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt; &lt;code&gt;findClass(java.lang.String)&lt;/code&gt; &lt;/a&gt; 호출 중에 사용됨 )은 조회 클래스의 로더에 의해 결정되며, 이는이 작업으로 인해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf2be7ac8c067fddb839990370820b0eb8d4e56d" translate="yes" xml:space="preserve">
          <source>The resulting loop handle's result type and parameter signature are determined as follows:</source>
          <target state="translated">결과 루프 핸들의 결과 유형 및 매개 변수 서명은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="04a2c48749521167a182d6f3ff0325e14730438e" translate="yes" xml:space="preserve">
          <source>The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt; for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see &lt;a href=&quot;#ALL_ACCESS&quot;&gt;&lt;code&gt;ALL_ACCESS&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">결과 메모리 세그먼트는 백업 어레이에 대한 참조를 유지하여 세그먼트 의 수명 동안 &lt;em&gt;도달 할 수&lt;/em&gt; 있도록합니다 . 세그먼트는 모든 &lt;a href=&quot;#access-modes&quot;&gt;액세스 모드를 제공합니다&lt;/a&gt; ( &lt;a href=&quot;#ALL_ACCESS&quot;&gt; &lt;code&gt;ALL_ACCESS&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eb42de5b1a780911505c096c6696a965b40d19d6" translate="yes" xml:space="preserve">
          <source>The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt; for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</source>
          <target state="translated">결과 메모리 세그먼트는 백업 어레이에 대한 참조를 유지하여 세그먼트 의 수명 동안 &lt;em&gt;도달 할 수&lt;/em&gt; 있도록합니다 . 세그먼트는 모든 &lt;a href=&quot;#access-modes&quot;&gt;액세스 모드를 제공합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8bc2d5a235fa88774ad990ce639f2528d31aaae" translate="yes" xml:space="preserve">
          <source>The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt; for the life-time of the segment.</source>
          <target state="translated">결과 메모리 세그먼트는 백업 버퍼에 대한 참조를 유지하여 세그먼트 의 수명 동안 &lt;em&gt;도달 할 수&lt;/em&gt; 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="1884f6b5e1183ba90dbd15f7cef2ddc5936af5e3" translate="yes" xml:space="preserve">
          <source>The resulting metadata object is only responsible for returning documents in the format named by &lt;code&gt;formatName&lt;/code&gt;. Within any documents that are returned, only nodes whose names are members of &lt;code&gt;nodeNames&lt;/code&gt; are required to be returned. In this way, the amount of metadata processing done by the reader may be kept to a minimum, based on what information is actually needed.</source>
          <target state="translated">결과 메타 데이터 개체는 &lt;code&gt;formatName&lt;/code&gt; 으로 명명 된 형식의 문서 만 반환합니다 . 리턴 된 문서 내에서 이름이 &lt;code&gt;nodeNames&lt;/code&gt; 의 구성원 인 노드 만 리턴 해야합니다. 이러한 방식으로, 판독기에 의해 수행되는 메타 데이터 처리량은 실제로 필요한 정보에 기초하여 최소로 유지 될 수있다.</target>
        </trans-unit>
        <trans-unit id="9c5c220cd80df632d39ecb3d8b6a70f850252346" translate="yes" xml:space="preserve">
          <source>The resulting period will be day-based, with the amount of days equal to the number of weeks multiplied by 7. The years and months units will be zero.</source>
          <target state="translated">결과 기간은 일 수를 기준으로하며 일 수는 주 수에 7을 곱한 값입니다. 연도 및 월 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="a6b95edf4e81e9e6b6619e37b7ddbb8faf120000" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified days. The years and months units will be zero.</source>
          <target state="translated">결과 기간에는 지정된 요일이 있습니다. 연도 및 월 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="9ed86d9dd063303868aa5b67521032ff19d3dd44" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified months. The years and days units will be zero.</source>
          <target state="translated">결과 기간에는 지정된 월이 있습니다. 년과 일 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="29d3631062d098fb17c4652fb16c3cf33dfe26c4" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified years. The months and days units will be zero.</source>
          <target state="translated">결과 기간은 지정된 연도입니다. 월 및 일 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="95444b5a8c83dcd2572f1e1d42e1076adc4c44ce" translate="yes" xml:space="preserve">
          <source>The resulting proxy class must not exceed any limits imposed on classes by the virtual machine. For example, the VM may limit the number of interfaces that a class may implement to 65535; in that case, the size of the &lt;code&gt;interfaces&lt;/code&gt; array must not exceed 65535.</source>
          <target state="translated">결과 프록시 클래스는 가상 머신에 의해 클래스에 부과 된 제한을 초과 할 수 없습니다. 예를 들어, VM은 클래스가 구현할 수있는 인터페이스 수를 65535로 제한 할 수 있습니다. 이 경우, 크기 &lt;code&gt;interfaces&lt;/code&gt; 배열 65535을 초과하지 않아야한다.</target>
        </trans-unit>
        <trans-unit id="6387f721ca72aada5ca623b823df6496720b727a" translate="yes" xml:space="preserve">
          <source>The resulting reader will start reading at the given &lt;code&gt;offset&lt;/code&gt;. The total number of &lt;code&gt;char&lt;/code&gt; values that can be read from this reader will be either &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;buf.length-offset&lt;/code&gt;, whichever is smaller.</source>
          <target state="translated">결과 판독기는 주어진 &lt;code&gt;offset&lt;/code&gt; 에서 읽기 시작 합니다. 이 리더에서 읽을 수있는 총 &lt;code&gt;char&lt;/code&gt; 값 수는 &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;buf.length-offset&lt;/code&gt; 중 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="913ac6b499d59e4b63e4cdaa10016b85296c4fef" translate="yes" xml:space="preserve">
          <source>The resulting region is then subsampled according to the factors given in &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;. The first pixel, the number of pixels per row, and the number of rows all depend on the subsampling settings. Call the minimum X and Y coordinates of the resulting rectangle (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;), its width &lt;code&gt;w&lt;/code&gt; and its height &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">그런 다음 결과 영역은 &lt;a href=&quot;iioparam#setSourceSubsampling(int,int,int,int)&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 제공된 요소에 따라 서브 샘플링됩니다 . 첫 번째 픽셀, 행당 픽셀 수 및 행 수는 모두 서브 샘플링 설정에 따라 다릅니다. 결과 사각형 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; ), 너비 &lt;code&gt;w&lt;/code&gt; 및 높이 &lt;code&gt;h&lt;/code&gt; 의 최소 ​​X 및 Y 좌표를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf284259891b966795d0320eaa89a9efa9f184a" translate="yes" xml:space="preserve">
          <source>The resulting region is then subsampled according to the factors given in &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;. The first pixel, the number of pixels per row, and the number of rows all depend on the subsampling settings. Call the minimum X and Y coordinates of the resulting rectangle (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;), its width &lt;code&gt;w&lt;/code&gt; and its height &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">결과 영역은 &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 주어진 요소에 따라 서브 샘플링됩니다 . 첫 번째 픽셀, 행당 픽셀 수 및 행 수는 모두 서브 샘플링 설정에 따라 다릅니다. 결과 사각형의 최소 X 및 Y 좌표 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; ), 너비 &lt;code&gt;w&lt;/code&gt; 및 높이 &lt;code&gt;h&lt;/code&gt; 를호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a3bd1f6e9cb9121d8ce0c043ff1f95fd3d713991" translate="yes" xml:space="preserve">
          <source>The resulting schema contains components from the specified sources. The same result would be achieved if all these sources were imported, using appropriate values for schemaLocation and namespace, into a single schema document with a different targetNamespace and no components of its own, if the import elements were given in the same order as the sources. Section 4.2.3 of the XML Schema recommendation describes the options processors have in this regard. While a processor should be consistent in its treatment of JAXP schema sources and XML Schema imports, the behaviour between JAXP-compliant parsers may vary; in particular, parsers may choose to ignore all but the first &lt;code&gt;&amp;lt;import&amp;gt;&lt;/code&gt; for a given namespace, regardless of information provided in schemaLocation.</source>
          <target state="translated">결과 스키마에는 지정된 소스의 구성 요소가 포함됩니다. 이러한 모든 소스를 schemaLocation 및 네임 스페이스에 대한 적절한 값을 사용하여 다른 targetNamespace를 사용하고 자체 구성 요소가없는 단일 스키마 문서로 가져온 경우 동일한 결과를 얻을 수 있습니다. . XML 스키마 권장 사항의 섹션 4.2.3에서는 프로세서가 이와 관련하여 갖는 옵션을 설명합니다. 프로세서는 JAXP 스키마 소스 및 XML 스키마 가져 오기를 처리 할 때 일관성이 있어야하지만 JAXP 호환 파서 간의 동작은 다를 수 있습니다. 특히 파서는 schemaLocation에 제공된 정보에 관계없이 주어진 네임 스페이스에 대한 첫 번째 &lt;code&gt;&amp;lt;import&amp;gt;&lt;/code&gt; 를 제외한 모든 것을 무시하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5fb5a6cf150b79c1760d1a0a2b75c334f95c52c" translate="yes" xml:space="preserve">
          <source>The resulting sequence may be empty if the &lt;code&gt;hasNext&lt;/code&gt; predicate does not hold on the seed value. Otherwise the first element will be the supplied &lt;code&gt;seed&lt;/code&gt; value, the next element (if present) will be the result of applying the &lt;code&gt;next&lt;/code&gt; function to the &lt;code&gt;seed&lt;/code&gt; value, and so on iteratively until the &lt;code&gt;hasNext&lt;/code&gt; predicate indicates that the stream should terminate.</source>
          <target state="translated">&lt;code&gt;hasNext&lt;/code&gt; 술어가 시드 값을 보유하지 않는 경우 결과 시퀀스는 비어있을 수 있습니다 . 그렇지 않으면 첫 번째 요소는 제공된 &lt;code&gt;seed&lt;/code&gt; 값이되고, 다음 요소 (있는 경우)는 &lt;code&gt;seed&lt;/code&gt; 값에 &lt;code&gt;next&lt;/code&gt; 함수를 적용한 결과 가됩니다. &lt;code&gt;hasNext&lt;/code&gt; 술어가 스트림이 종료되어야 함을 나타낼 때까지 반복적으로 계속 됩니다.</target>
        </trans-unit>
        <trans-unit id="59cf2006f3357a0978267c2dafbd40a8eb21f662" translate="yes" xml:space="preserve">
          <source>The resulting stream is sequential and ordered. All stream elements are non-null.</source>
          <target state="translated">결과 스트림은 순차적이고 순서가 지정됩니다. 모든 스트림 요소는 널이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fc6e671adbb8a182924f1ac35bcd56e979e41944" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal input buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;read&lt;/code&gt; methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered, and it will not support the &lt;a href=&quot;../../io/reader#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/reader#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">결과 스트림에는 최소 &lt;code&gt;minBufferCap&lt;/code&gt; 바이트 의 내부 입력 버퍼가 포함 됩니다. 스트림의 &lt;code&gt;read&lt;/code&gt; 메서드는 필요에 따라 기본 채널에서 바이트를 읽어 버퍼를 채 웁니다. 바이트를 읽을 때 채널이 비 차단 모드이면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 결과 스트림은 그렇지 않으면 버퍼링되지 않으며 &lt;a href=&quot;../../io/reader#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/reader#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를 지원하지 않습니다 . 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7927acc85bf7485dc11e63b36c81bfd277412443" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal input buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;read&lt;/code&gt; methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered, and it will not support the &lt;a href=&quot;../../io/reader#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/reader#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">생성 된 스트림은 적어도 내부 입력 버퍼 포함 &lt;code&gt;minBufferCap&lt;/code&gt; 가 바이트. 스트림의 &lt;code&gt;read&lt;/code&gt; 방법은, 필요에 따라 기본 채널의 바이트를 판독하여 버퍼를 채울 것이다; 채널은 다음 바이트가 판독 할 때 비 블록 모드에 있으면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 발생한다. 생성 된 스트림은 별도로 버퍼되지 않고,지지되지 &lt;a href=&quot;../../io/reader#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/reader#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 방법. 스트림을 닫는 것은 채널 원인 차례로 폐쇄 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d580035bd2b566457432a5e4d925677447d221a" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal output buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;write&lt;/code&gt; methods will, as needed, flush the buffer by writing bytes to the underlying channel; if the channel is in non-blocking mode when bytes are to be written then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">결과 스트림에는 최소한 &lt;code&gt;minBufferCap&lt;/code&gt; 바이트 의 내부 출력 버퍼가 포함 됩니다. 스트림의 &lt;code&gt;write&lt;/code&gt; 메소드는 필요에 따라 기본 채널에 바이트를 써서 버퍼를 플러시합니다. 바이트를 쓸 때 채널이 비 블로킹 모드에 있으면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 그렇지 않으면 결과 스트림이 버퍼링되지 않습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b5709861225c7ba3b6865800d13497f86bd85df6" translate="yes" xml:space="preserve">
          <source>The resulting string</source>
          <target state="translated">결과 문자열</target>
        </trans-unit>
        <trans-unit id="7323183be989f820aa6475e0d8caa99ce479a4fb" translate="yes" xml:space="preserve">
          <source>The resulting string may vary depending on the platform's default encoding.</source>
          <target state="translated">결과 문자열은 플랫폼의 기본 인코딩에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec362e72494de8b3c1c872dc58fe0a8f261890f" translate="yes" xml:space="preserve">
          <source>The resulting string may vary depending on the platform's default encoding. Instead, use the decode(String,String) method to specify the encoding.</source>
          <target state="translated">결과 문자열은 플랫폼의 기본 인코딩에 따라 달라질 수 있습니다. 대신 decode (String, String) 메서드를 사용하여 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b48d31f1fb8209f2d9205d68efebbcc7c9cbd82b" translate="yes" xml:space="preserve">
          <source>The resulting string may vary depending on the platform's default encoding. Instead, use the encode(String,String) method to specify the encoding.</source>
          <target state="translated">결과 문자열은 플랫폼의 기본 인코딩에 따라 달라질 수 있습니다. 대신 encode (String, String) 메서드를 사용하여 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0242c011bc55e1252b1407ded7fa2f64f005fdf7" translate="yes" xml:space="preserve">
          <source>The resulting value for these property will be stored in the LogManager properties, but &lt;code&gt;updateConfiguration&lt;/code&gt; will not parse or process their values.</source>
          <target state="translated">이러한 속성의 결과 값은 LogManager 속성에 저장되지만 &lt;code&gt;updateConfiguration&lt;/code&gt; 은 해당 값을 구문 분석하거나 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c5ccef77ff39639671b29d2b92776dcab2dc448" translate="yes" xml:space="preserve">
          <source>The resulting var handle will feature the same access modes (see &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode&quot;&gt;&lt;code&gt;VarHandle.AccessMode&lt;/code&gt;&lt;/a&gt; and atomic access guarantees as those featured by the target var handle.</source>
          <target state="translated">결과 var 핸들은 동일한 액세스 모드를 제공합니다 ( &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode&quot;&gt; &lt;code&gt;VarHandle.AccessMode&lt;/code&gt; &lt;/a&gt; 및 atomic 액세스 보장은 대상 var 핸들에서 제공하는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="07dbe5f1c9e0316638391b2baf771ad39103ad09" translate="yes" xml:space="preserve">
          <source>The resulting var handle will feature the same access modes (see &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode&quot;&gt;&lt;code&gt;VarHandle.AccessMode&lt;/code&gt;&lt;/a&gt;) and atomic access guarantees as those featured by the target var handle.</source>
          <target state="translated">결과 var 핸들은 대상 var 핸들이 제공하는 것과 동일한 액세스 모드 ( &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode&quot;&gt; &lt;code&gt;VarHandle.AccessMode&lt;/code&gt; &lt;/a&gt; 참조 ) 및 원자 적 액세스 보장을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74bf552fafa0986a788039357cfc15a0f6c622fd" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable and its use is generally not recommended; see the notes under the &lt;a href=&quot;#%3Cinit%3E(double)&quot;&gt;&lt;code&gt;BigDecimal(double)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없으며 일반적으로 사용하지 않는 것이 좋습니다. &lt;a href=&quot;#%3Cinit%3E(double)&quot;&gt; &lt;code&gt;BigDecimal(double)&lt;/code&gt; &lt;/a&gt; 생성자 아래의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65db06e467299c29537ab9336bf47bbbf5cdbd84" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable and its use is generally not recommended; see the notes under the &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt;&lt;code&gt;BigDecimal(double)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없으며 일반적으로 사용하지 않는 것이 좋습니다. &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt; &lt;code&gt;BigDecimal(double)&lt;/code&gt; &lt;/a&gt; 생성자 아래의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbb3bb7280c618deda0717f345ca0d0a3e5a617a" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable. One might assume that writing &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; in Java creates a &lt;code&gt;BigDecimal&lt;/code&gt; which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a &lt;code&gt;double&lt;/code&gt; (or, for that matter, as a binary fraction of any finite length). Thus, the value that is being passed</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없습니다. 하나는 쓰는 것을 가정 할 수 &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; 자바 것은 생성 &lt;code&gt;BigDecimal&lt;/code&gt; (1의 규모로, 1의 스케일 없음의 값) 0.1 정확하게 일치이지만, 실제로 0.1000000000000000055511151231257827021181583404541015625 같음. 이는 0.1을 정확히 &lt;code&gt;double&lt;/code&gt; 로 표현할 수 없기 때문입니다 (또는이 문제의 경우 유한 길이의 이진 분수). 따라서 전달되는 가치</target>
        </trans-unit>
        <trans-unit id="a60e1eda493280339b2d07bf3ec089112f276d07" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable. One might assume that writing &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; in Java creates a &lt;code&gt;BigDecimal&lt;/code&gt; which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a &lt;code&gt;double&lt;/code&gt; (or, for that matter, as a binary fraction of any finite length). Thus, the value that is being passed &lt;em&gt;in&lt;/em&gt; to the constructor is not exactly equal to 0.1, appearances notwithstanding.</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없습니다. 하나는 쓰는 것을 가정 할 수 &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; 자바 것은 생성 &lt;code&gt;BigDecimal&lt;/code&gt; (1의 규모로, 1의 스케일 없음의 값) 0.1 정확하게 일치이지만, 실제로 0.1000000000000000055511151231257827021181583404541015625 같음. 0.1은 정확히 &lt;code&gt;double&lt;/code&gt; 로 표현할 수 없기 때문입니다 (또는 유한 길이의 이진 분수 로 표현할 수 없습니다 ). 따라서, 전달되는 값 &lt;em&gt;에&lt;/em&gt; 생성자 0.1, 외관에도 불구하고 정확하게 동일하지 않다.</target>
        </trans-unit>
        <trans-unit id="93760e92a1fc812ab19b0ed28984ff85fa220322" translate="yes" xml:space="preserve">
          <source>The results only need to be adjusted if they are to be stored back into a destination buffer that holds data that is not premultiplied, using the following equations:</source>
          <target state="translated">결과는 다음 방정식을 사용하여 미리 곱해지지 않은 데이터를 보유하는 대상 버퍼에 다시 저장되는 경우에만 조정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7164f77665270f67e8f397eca3785e4e6b5066" translate="yes" xml:space="preserve">
          <source>The results should be the same as obtaining all the &lt;code&gt;PrintServices&lt;/code&gt; and querying each one individually on its support for the specified attributes and flavors, but the process can be more efficient by taking advantage of the capabilities of lookup services for the print services.</source>
          <target state="translated">결과는 모든 &lt;code&gt;PrintServices&lt;/code&gt; 를 얻고 지정된 속성 및 특징에 대한 지원에 대해 개별적으로 쿼리 하는 것과 동일해야 하지만 인쇄 서비스에 대한 조회 서비스 기능을 활용하면 프로세스가 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b26f2b5e9e76c38d5206ceaa707fac001defe0" translate="yes" xml:space="preserve">
          <source>The results should be the same as obtaining all the PrintServices and querying each one individually on its support for the specified attributes and flavors, but the process can be more efficient by taking advantage of the capabilities of lookup services for the print services.</source>
          <target state="translated">결과는 모든 PrintService를 가져 와서 지정된 속성 및 특징에 대한 지원에 대해 각각 개별적으로 쿼리하는 것과 동일해야하지만 인쇄 서비스에 대한 조회 서비스 기능을 활용하면 프로세스가 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5af3a05b778776e5694ec63dd4fb3b5fc8fb0b8" translate="yes" xml:space="preserve">
          <source>The resumption of other threads during the invocation can be prevented by specifying the &lt;a href=&quot;#INVOKE_SINGLE_THREADED&quot;&gt;&lt;code&gt;INVOKE_SINGLE_THREADED&lt;/code&gt;&lt;/a&gt; bit flag in the &lt;code&gt;options&lt;/code&gt; argument; however, there is no protection against or recovery from the deadlocks described above, so this option should be used with great caution. Only the specified thread will be resumed (as described for all threads above). Upon completion of a single threaded invoke, the invoking thread will be suspended once again. Note that any threads started during the single threaded invocation will not be suspended when the invocation completes.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 인수 에 &lt;a href=&quot;#INVOKE_SINGLE_THREADED&quot;&gt; &lt;code&gt;INVOKE_SINGLE_THREADED&lt;/code&gt; &lt;/a&gt; 비트 플래그를 지정하여 호출 중 다른 스레드의 재개를 방지 할 수 있습니다 . 그러나 위에서 설명한 교착 상태에 대한 보호 또는 복구가 없으므로이 옵션은 매우주의해서 사용해야합니다. 지정된 스레드 만 재개됩니다 (위의 모든 스레드에 대해 설명 됨). 단일 스레드 호출이 완료되면 호출 스레드가 다시 일시 중지됩니다. 단일 스레드 호출 중에 시작된 스레드는 호출이 완료 될 때 일시 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13feddb193cd0cfdf609b74927a9c48142c61e19" translate="yes" xml:space="preserve">
          <source>The resumption of other threads during the invocation can be prevented by specifying the &lt;a href=&quot;classtype#INVOKE_SINGLE_THREADED&quot;&gt;&lt;code&gt;ClassType.INVOKE_SINGLE_THREADED&lt;/code&gt;&lt;/a&gt; bit flag in the &lt;code&gt;options&lt;/code&gt; argument; however, there is no protection against or recovery from the deadlocks described above, so this option should be used with great caution. Only the specified thread will be resumed (as described for all threads above). Upon completion of a single threaded invoke, the invoking thread will be suspended once again. Note that any threads started during the single threaded invocation will not be suspended when the invocation completes.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 인수 에 &lt;a href=&quot;classtype#INVOKE_SINGLE_THREADED&quot;&gt; &lt;code&gt;ClassType.INVOKE_SINGLE_THREADED&lt;/code&gt; &lt;/a&gt; 비트 플래그를 지정하여 호출 중 다른 스레드의 재개를 방지 할 수 있습니다 . 그러나 위에서 설명한 교착 상태에 대한 보호 또는 복구가 없으므로이 옵션은 매우주의해서 사용해야합니다. 지정된 스레드 만 재개됩니다 (위의 모든 스레드에 대해 설명 됨). 단일 스레드 호출이 완료되면 호출 스레드가 다시 일시 중지됩니다. 단일 스레드 호출 중에 시작된 스레드는 호출이 완료 될 때 일시 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3cf3e1fd73a22414ddca5e3fb189a104cf44e85" translate="yes" xml:space="preserve">
          <source>The retransformation may change method bodies, the constant pool and attributes (unless explicitly prohibited). The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. The retransformation must not change the &lt;code&gt;NestHost&lt;/code&gt; or &lt;code&gt;NestMembers&lt;/code&gt; attributes. These restrictions may be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재 변환은 메서드 본문, 상수 풀 및 속성을 변경할 수 있습니다 (명시 적으로 금지되지 않는 한). 재 변환은 필드 또는 메서드를 추가, 제거 또는 이름 변경하거나 메서드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 재 변환은 &lt;code&gt;NestHost&lt;/code&gt; 또는 &lt;code&gt;NestMembers&lt;/code&gt; 속성을 변경해서는 안됩니다 . 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 클래스 파일 바이트는 변환이 적용될 때까지 검사, 확인 및 설치되지 않으며 결과 바이트에 오류가있는 경우이 메서드는 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="2f2a2d456b1fe7f946cf6afcde99facfbb1b054d" translate="yes" xml:space="preserve">
          <source>The retransformation may change method bodies, the constant pool and attributes. The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재 변환은 메소드 본문, 상수 풀 및 속성을 변경할 수 있습니다. 재 변환은 필드 또는 메소드를 추가, 제거 또는 이름 변경하거나 메소드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 변환이 적용될 때까지 클래스 파일 바이트는 확인, 확인 및 설치되지 않습니다. 결과 바이트에 오류가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="62fd7b2e815ada1d9ad838170833576f45e44251" translate="yes" xml:space="preserve">
          <source>The return of a &lt;code&gt;false&lt;/code&gt; value for a given access mode indicates that an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is thrown on invocation of the corresponding access mode method.</source>
          <target state="translated">주어진 액세스 모드에 대해 &lt;code&gt;false&lt;/code&gt; 값 이 반환 되면 해당 액세스 모드 메서드 호출시 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 throw 됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ca960eb615ad53bc0b3135b373d2036434995b22" translate="yes" xml:space="preserve">
          <source>The return type Rt is void, or the return type Ra is not void and is adaptable to Rt</source>
          <target state="translated">반환 유형 Rt가 비어 있거나 반환 유형 Ra가 비어 있지 않으며 Rt에 적용 가능</target>
        </trans-unit>
        <trans-unit id="0a90f1198e5deb5b2534122b1f369aa219e8f116" translate="yes" xml:space="preserve">
          <source>The return type in &lt;code&gt;concatType&lt;/code&gt; is assignable from &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;concatType&lt;/code&gt; 의 반환 유형 은 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 에서 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa2e82a8911ac326301fece552df2e83f13bdc2" translate="yes" xml:space="preserve">
          <source>The return type in &lt;code&gt;concatType&lt;/code&gt; is assignable from &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, and matches the return type of the returned &lt;a href=&quot;methodhandle&quot;&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;concatType&lt;/code&gt; 의 반환 유형 은 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 에서 할당 할 수 있으며 반환 된 &lt;a href=&quot;methodhandle&quot;&gt; &lt;code&gt;MethodHandle&lt;/code&gt; &lt;/a&gt; 의 반환 유형과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="08c7dcac11b655355c8f407e5172d1bcf0c4208a" translate="yes" xml:space="preserve">
          <source>The return type is specified by a &lt;a href=&quot;../namespace/qname&quot;&gt;&lt;code&gt;QName&lt;/code&gt;&lt;/a&gt; parameter in method call used to evaluate the expression, which is either a call to &lt;code&gt;XPathExpression.evalute(...)&lt;/code&gt; or &lt;code&gt;XPath.evaluate(...)&lt;/code&gt; methods.</source>
          <target state="translated">반환 유형은 &lt;code&gt;XPathExpression.evalute(...)&lt;/code&gt; 또는 &lt;code&gt;XPath.evaluate(...)&lt;/code&gt; 메서드에 대한 호출 인 식을 평가하는 데 사용되는 메서드 호출 의 &lt;a href=&quot;../namespace/qname&quot;&gt; &lt;code&gt;QName&lt;/code&gt; &lt;/a&gt; 매개 변수에 의해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="151afbc17f6742b5bf10a29157b5cc4cbd7ee6c5" translate="yes" xml:space="preserve">
          <source>The return type may be a primitive type or a subclass of &lt;a href=&quot;recordedobject&quot;&gt;&lt;code&gt;RecordedObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 유형은 기본 유형이거나 &lt;a href=&quot;recordedobject&quot;&gt; &lt;code&gt;RecordedObject&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92c09d015f75e8bee39bac035a68343e43b9f9d8" translate="yes" xml:space="preserve">
          <source>The return type of the filter replaces the return type of the target in the resulting adapted method handle. The argument type of the filter (if any) must be identical to the return type of the target.</source>
          <target state="translated">필터의 리턴 유형은 결과로 적용된 메소드 핸들에서 대상의 리턴 유형을 대체합니다. 필터의 인수 유형 (있는 경우)은 대상의 리턴 유형과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6a026e7ef017e49a86ae81d83b570e4f3b988ce" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;eval(Reader, ScriptContext)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval(Reader, ScriptContext)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="d250b67419c015be49448c5b2b4064b04039b13f" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;eval(String, ScriptContext)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval(String, ScriptContext)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="18c586324069b76d67cca48a59dcffb8f32f65de" translate="yes" xml:space="preserve">
          <source>The return value from the script execution</source>
          <target state="translated">스크립트 실행의 반환 값</target>
        </trans-unit>
        <trans-unit id="3e87c8c10ff310371a9f3d96d03e6c0bad31b37f" translate="yes" xml:space="preserve">
          <source>The return value here is a hint, it is ultimately up to the look and feel to honor the return value in some meaningful way.</source>
          <target state="translated">여기서 반환 값은 힌트이며 의미있는 방식으로 반환 값을 존중하는 것은 궁극적으로 모양과 느낌에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="339d740994f90a652ddcc5a1527a27502fd12e3d" translate="yes" xml:space="preserve">
          <source>The return value here is a hint, it is ultimately up to the look and feel to honor the return value in some meaningful way. For example, a look and feel may wish to render each &lt;code&gt;AbstractColorChooserPanel&lt;/code&gt; in a &lt;code&gt;JTabbedPane&lt;/code&gt;, and further use this return value to underline a character in the &lt;code&gt;getDisplayName&lt;/code&gt;.</source>
          <target state="translated">여기서 반환 값은 힌트이며 의미있는 방식으로 반환 값을 존중하는 것은 궁극적으로 모양과 느낌에 달려 있습니다. 예를 들어, 룩앤필 은 &lt;code&gt;JTabbedPane&lt;/code&gt; 에서 각 &lt;code&gt;AbstractColorChooserPanel&lt;/code&gt; 을 렌더링 하고이 반환 값을 추가로 사용하여 &lt;code&gt;getDisplayName&lt;/code&gt; 의 문자에 밑줄을 긋고 싶을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7e61cce8a603e1ed7dd41104b64452e72191f66" translate="yes" xml:space="preserve">
          <source>The return value indicates whether the deadline has elapsed, which can be used as follows:</source>
          <target state="translated">반환 값은 최종 기한이 지 났는지 여부를 나타내며 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b117098b5c546c14491ff8cf89569aadc8a2ea4" translate="yes" xml:space="preserve">
          <source>The return value is a constant for the lifetime of the implementing instance</source>
          <target state="translated">반환 값은 구현 인스턴스의 수명 동안 상수입니다.</target>
        </trans-unit>
        <trans-unit id="ef240b9287f693729ee8736cf3b50be17225bd35" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the column number in the document entity or external parsed entity where the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 열 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="1b239c60495bf8042c7d3c6cd2a1059554bfa5e2" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the column number in the document entity or external parsed entity where the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 열 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="8ffa6dc5a63793e0cd89ca59a2500e0682da449a" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the line number in the document entity or external parsed entity where the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 줄 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="df14b7af1f8f1168f052f357a4d4d570216b0e96" translate="yes" xml:space="preserve">
          <source>The return value is an approximation of the line number in the document entity or external parsed entity where the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티에있는 줄 번호의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="5d010f320e15d99aa04c62f2ae7a00fe4348d9c8" translate="yes" xml:space="preserve">
          <source>The return value is never null.</source>
          <target state="translated">반환 값은 null이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="873937197ae1055f97215cc23c27aad938455d09" translate="yes" xml:space="preserve">
          <source>The return value is non-negative in the range of &lt;code&gt;0&lt;/code&gt; (inclusive) up to &lt;code&gt;unitSize&lt;/code&gt; (exclusive), with zero indicating that the address of the byte at the index is aligned for the unit size, and a positive value that the address is misaligned for the unit size. If the address of the byte at the index is misaligned, the return value represents how much the index should be adjusted to locate a byte at an aligned address. Specifically, the index should either be decremented by the return value if the latter is not greater than &lt;code&gt;index&lt;/code&gt;, or be incremented by the unit size minus the return value. Therefore given</source>
          <target state="translated">반환 값은 &lt;code&gt;0&lt;/code&gt; (포함)에서 &lt;code&gt;unitSize&lt;/code&gt; (배타적 )까지 의 범위에서 음수가 아닙니다. 0 은 인덱스의 바이트 주소가 단위 크기에 맞게 정렬되었음을 나타내며 양수 값은 주소가 잘못 정렬되었음을 나타냅니다. 단위 크기. 인덱스의 바이트 주소가 잘못 정렬 된 경우 반환 값은 정렬 된 주소에서 바이트를 찾기 위해 인덱스를 조정해야하는 정도를 나타냅니다. 특히, 인덱스는 후자가 &lt;code&gt;index&lt;/code&gt; 보다 크지 않은 경우 반환 값만큼 감소 하거나 단위 크기에서 반환 값을 뺀 값만큼 증가해야합니다. 따라서 주어진</target>
        </trans-unit>
        <trans-unit id="57e62b909f604f540851de4e9220c29855a3c379" translate="yes" xml:space="preserve">
          <source>The return value is not intended to take into account the current size and position of &lt;code&gt;component2&lt;/code&gt; or &lt;code&gt;component1&lt;/code&gt;. The return value may take into consideration various properties of the components. For example, the space may vary based on font size, or the preferred size of the component.</source>
          <target state="translated">반환 값은 &lt;code&gt;component2&lt;/code&gt; 또는 &lt;code&gt;component1&lt;/code&gt; 의 현재 크기와 위치를 고려하지 않습니다 . 반환 값은 구성 요소의 다양한 속성을 고려할 수 있습니다. 예를 들어, 공간은 글꼴 크기 또는 구성 요소의 기본 크기에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6862bdbf23c8a75ce946b35c34fe4f5784a92cab" translate="yes" xml:space="preserve">
          <source>The return value is reassigned to the variable &lt;code&gt;y&lt;/code&gt;, because a new array will be allocated and returned if the collection &lt;code&gt;x&lt;/code&gt; has too many elements to fit into the existing array &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">컬렉션 &lt;code&gt;x&lt;/code&gt; 에 기존 배열 &lt;code&gt;y&lt;/code&gt; 에 맞지 않는 요소가 너무 많으면 새 배열이 할당되고 반환되므로 반환 값이 변수 &lt;code&gt;y&lt;/code&gt; 에 다시 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf5abc13dd7f11ea0e437763bb82152d9c9c44c6" translate="yes" xml:space="preserve">
          <source>The return value is the public identifier of the document entity or of the external parsed entity in which the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 공용 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="4eab4f2d235e9eb1c2ee1b4d56bb6a0656d5046f" translate="yes" xml:space="preserve">
          <source>The return value is the public identifier of the document entity or of the external parsed entity in which the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 공용 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="79298db5b9ecefcf08a93ac7001f8247745f88be" translate="yes" xml:space="preserve">
          <source>The return value is the same as the return value for getType(int).</source>
          <target state="translated">반환 값은 getType (int)의 반환 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ad228ac22a92c30a5a17bbe1cc5511d3e6d6efe6" translate="yes" xml:space="preserve">
          <source>The return value is the same as the return value for getValue(int).</source>
          <target state="translated">반환 값은 getValue (int)의 반환 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="305fb729cefceff62bd86eeab21b84fdfc657b36" translate="yes" xml:space="preserve">
          <source>The return value is the system identifier of the document entity or of the external parsed entity in which the markup that triggered the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거 한 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="157a1ea5a78e25b7b7edb134a522fe0ad73f0731" translate="yes" xml:space="preserve">
          <source>The return value is the system identifier of the document entity or of the external parsed entity in which the markup triggering the event appears.</source>
          <target state="translated">반환 값은 이벤트를 트리거하는 마크 업이 나타나는 문서 엔터티 또는 구문 분석 된 외부 엔터티의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="d5e42cb5bf57e4282c3a4431545a3164ae31c157" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;dispatchEvent&lt;/code&gt; indicates whether any of the listeners which handled the event called &lt;code&gt;preventDefault&lt;/code&gt;. If &lt;code&gt;preventDefault&lt;/code&gt; was called the value is false, else the value is true.</source>
          <target state="translated">&lt;code&gt;dispatchEvent&lt;/code&gt; 의 반환 값은 &lt;code&gt;preventDefault&lt;/code&gt; 라는 이벤트 를 처리 한 리스너가 있는지 여부를 나타냅니다 . 경우 &lt;code&gt;preventDefault&lt;/code&gt; 값 호출 된 다른 값이 true, false입니다.</target>
        </trans-unit>
        <trans-unit id="6589d2c87a3593f5b725f019c0648f0fe516d29b" translate="yes" xml:space="preserve">
          <source>The return value of the method specifies whether the event is to be written to the Flight Recorder system or not.</source>
          <target state="translated">메서드의 반환 값은 이벤트를 Flight Recorder 시스템에 기록할지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4219f41ab6bb669a3af2e1f70f85e439bc1d24f1" translate="yes" xml:space="preserve">
          <source>The return value of this method is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string is guaranteed to be parsable according to the grammar in the RFC.</source>
          <target state="translated">이 메소드의 리턴 값은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 컨텐츠 유형 값의 문자열 형식입니다 . RFC의 문법에 따라 문자열을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="365783bcde1708d89a0bd8c6da5a4edb395db805" translate="yes" xml:space="preserve">
          <source>The return value of this method is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string is guaranteed to be parsable according to the grammar in the RFC.</source>
          <target state="translated">이 메서드의 반환 값은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) Part One : Format of Internet Message Bodies에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 콘텐츠 유형 값의 문자열 형식입니다 . 문자열은 RFC의 문법에 따라 구문 분석이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="59d6884c96ab13575074a3fd88c171169562433f" translate="yes" xml:space="preserve">
          <source>The return value will always meet this requirement. A request to read a number of bytes representing a non-integral number of sample frames cannot be fulfilled and may result in an IllegalArgumentException.</source>
          <target state="translated">반환 값은 항상이 요구 사항을 충족합니다. 비 적분 수의 샘플 프레임을 나타내는 다수의 바이트 읽기 요청은 이행 될 수 없으며 IllegalArgumentException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bab3d5729e7a670151bb1fa0f6d52b4a1a2b1601" translate="yes" xml:space="preserve">
          <source>The return value will always meet this requirement. A request to write a number of bytes representing a non-integral number of sample frames cannot be fulfilled and may result in an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">반환 값은 항상이 요구 사항을 충족합니다. 정수가 아닌 샘플 프레임을 나타내는 바이트 수 쓰기 요청을 이행 할 수 없으며 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb820cab50d0998d1ebde65dd99e143bc7773114" translate="yes" xml:space="preserve">
          <source>The return value will be a PageFormat equivalent to the selections in the PrintRequestAttributeSet. If the user cancels the dialog, the attributes will not reflect any changes made by the user, and the return value will be null.</source>
          <target state="translated">반환 값은 PrintRequestAttributeSet의 선택 항목에 해당하는 PageFormat입니다. 사용자가 대화 상자를 취소하면 속성은 사용자가 변경 한 내용을 반영하지 않으며 반환 값은 null이됩니다.</target>
        </trans-unit>
        <trans-unit id="7a1cb10291ece8ab0cb0d59c17a95c5985d00fc8" translate="yes" xml:space="preserve">
          <source>The return value will be one of &lt;a href=&quot;#INITIATE_ONLY&quot;&gt;&lt;code&gt;INITIATE_ONLY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ACCEPT_ONLY&quot;&gt;&lt;code&gt;ACCEPT_ONLY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#INITIATE_AND_ACCEPT&quot;&gt;&lt;code&gt;INITIATE_AND_ACCEPT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 값은 &lt;a href=&quot;#INITIATE_ONLY&quot;&gt; &lt;code&gt;INITIATE_ONLY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ACCEPT_ONLY&quot;&gt; &lt;code&gt;ACCEPT_ONLY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#INITIATE_AND_ACCEPT&quot;&gt; &lt;code&gt;INITIATE_AND_ACCEPT&lt;/code&gt; &lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="f6bfc96df054b19c8bae5f8772d6621a71f8e532" translate="yes" xml:space="preserve">
          <source>The return values of navigation methods may be ambiguous in implementations that permit &lt;code&gt;null&lt;/code&gt; elements. However, even in this case the result can be disambiguated by checking &lt;code&gt;contains(null)&lt;/code&gt;. To avoid such issues, implementations of this interface are encouraged to &lt;em&gt;not&lt;/em&gt; permit insertion of &lt;code&gt;null&lt;/code&gt; elements. (Note that sorted sets of &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; elements intrinsically do not permit &lt;code&gt;null&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 요소 를 허용하는 구현에서는 탐색 메서드의 반환 값이 모호 할 수 있습니다 . 그러나이 경우에도 &lt;code&gt;contains(null)&lt;/code&gt; 을 확인하여 결과를 명확하게 할 수 있습니다 . 이러한 문제를 피하기 위해이 인터페이스의 구현 은 &lt;code&gt;null&lt;/code&gt; 요소의 삽입을 허용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다 . 정렬 된 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 요소 세트는 본질적으로 &lt;code&gt;null&lt;/code&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c185003fa3929e25d997e006634131e9b1d47337" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to a resolved &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 모든 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 형식 을 지정하고 해결 된 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; 로&lt;/a&gt; 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="75a801763a5d854e8d95b623a5d3a94dcbfe58f1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to the type specified. The type must be one that is supported by &lt;a href=&quot;#parse(java.lang.CharSequence)&quot;&gt;&lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 의 형식을 지정하고 지정된 유형으로 구문 분석합니다. 유형은 &lt;a href=&quot;#parse(java.lang.CharSequence)&quot;&gt; &lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt; &lt;/a&gt; 지원하는 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4d4661665beda529a4501a1035be4de025066b7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to the type specified. The type must be one that is supported by &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-&quot;&gt;&lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 모든 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 의 형식을 지정하고 지정된 형식으로 구문 분석합니다. 유형은 &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-&quot;&gt; &lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt; &lt;/a&gt; 가 지원하는 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6130888b3d4f3e79271a0f0fd2b1121269c73460" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instance supports the same usages as do the &lt;a href=&quot;../../../lang/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt; monitor methods (&lt;a href=&quot;../../../lang/object#wait()&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../lang/object#notify()&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../../lang/object#notifyAll()&quot;&gt;&lt;code&gt;notifyAll&lt;/code&gt;&lt;/a&gt;) when used with the built-in monitor lock.</source>
          <target state="translated">반환 된 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 인스턴스는 기본 제공 모니터 잠금과 함께 사용할 때 &lt;a href=&quot;../../../lang/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 모니터 메서드 ( &lt;a href=&quot;../../../lang/object#wait()&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../lang/object#notify()&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../lang/object#notifyAll()&quot;&gt; &lt;code&gt;notifyAll&lt;/code&gt; &lt;/a&gt; ) 와 동일한 사용법을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5dd44d28dfbc6bc47cbc61187f37930a55da27" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instance supports the same usages as do the &lt;a href=&quot;../../../lang/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt; monitor methods (&lt;a href=&quot;../../../lang/object#wait--&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../lang/object#notify--&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../../lang/object#notifyAll--&quot;&gt;&lt;code&gt;notifyAll&lt;/code&gt;&lt;/a&gt;) when used with the built-in monitor lock.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 인스턴스는 내장 모니터 잠금과 함께 사용될 때 &lt;a href=&quot;../../../lang/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 모니터 메소드 ( &lt;a href=&quot;../../../lang/object#wait--&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../lang/object#notify--&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../lang/object#notifyAll--&quot;&gt; &lt;code&gt;notifyAll&lt;/code&gt; &lt;/a&gt; ) 와 동일한 사용법을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="903fab1dd6031a929646339ff8331ce972297982" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; object assumes that if documents refer to the same URL in the schema location hints, they will always resolve to the same schema document. This asusmption allows implementations to reuse parsed results of schema documents so that multiple validations against the same schema will run faster.</source>
          <target state="translated">반환 된 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; 개체는 문서가 스키마 위치 힌트에서 동일한 URL을 참조하는 경우 항상 동일한 스키마 문서로 확인된다고 가정합니다. 이러한 가정을 통해 구현에서 스키마 문서의 구문 분석 된 결과를 재사용 할 수 있으므로 동일한 스키마에 대한 여러 유효성 검사가 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1bdefa0087b8327c86ac80a033c0a312632ffe64" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;ActionMap&lt;/code&gt; contains &lt;code&gt;Actions&lt;/code&gt; that embody the ability to render an auditory cue. These auditory cues map onto user and system activities that may be useful for an end user to know about (such as a dialog box appearing).</source>
          <target state="translated">반환 된 &lt;code&gt;ActionMap&lt;/code&gt; 에는 청각 신호를 렌더링하는 기능을 구현하는 &lt;code&gt;Actions&lt;/code&gt; 이 포함 됩니다. 이러한 청각 신호는 최종 사용자가 알면 유용 할 수있는 사용자 및 시스템 활동 (예 : 대화 상자 표시)에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7d12400bfb4401dc47af91d14c791db925e333" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 를 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 삽입 할 필요가없는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc1730d912a2f1b769dce259c025673a7214e32" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시 적이 지 않습니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 삽입 될 필요가없는 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="455cc87f0f7a7b7d3bd10e8e76906fe2717f5568" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 를 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 할 필요가없는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce3945a38794bedbeea1ec896b627af457c67f5" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 를 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 할 필요가없는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt; &lt;/a&gt; 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7e9e01d3dfa3cb980421cf908b620f48d72c26" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 될 필요가없는 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43da3d7de62b7245f65cab710cfb2f032f89515e" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt; &lt;/a&gt; 사용 하면 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 될 필요가없는 경우 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57c6b99569016327c62bebb7ad77957c25e8eed6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting &lt;code&gt;Map&lt;/code&gt; collector is not required, using &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function)&quot;&gt;&lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 결과 &lt;code&gt;Map&lt;/code&gt; 수집기 에 요소가 나타나는 순서 를 &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function)&quot;&gt; &lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt; &lt;/a&gt; 필요가없는 경우 groupingByConcurrent (Function)를 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cbd679a1ec8205268de13a97a9624457c2a964" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting &lt;code&gt;Map&lt;/code&gt; collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과 &lt;code&gt;Map&lt;/code&gt; 콜렉터 에 요소가 나타나는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt; &lt;/a&gt; 사용하면 병렬 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6ca58a5af4a56d396c6a6e708ba41db7d674a1" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 요소가 다운 스트림 수집기에 표시되는 순서를 &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt; &lt;/a&gt; 필요가없는 경우 groupingByConcurrent (Function, Supplier, Collector)를 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45a9fc109957eb2a04aabfd7fb897648b56499d3" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">반환 된 &lt;code&gt;Collector&lt;/code&gt; 는 동시성이 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵의 키를 다른 맵으로 병합하는 방식으로 작동하므로 비용이 많이들 수 있습니다. 요소가 다운 스트림 컬렉터에 표시되는 순서를 &lt;a href=&quot;#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt; &lt;/a&gt; 필요가없는 경우 groupingByConcurrent (Function, Collector)를 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac6dd6552e8a0aeddbedc87ca5a64e77ba22719" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 다운 스트림 콜렉터에 요소가 표시되는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt; &lt;/a&gt; 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbaf8d671c4e4b5aa32fa0703a9603589a87b608" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시 적이 지 않습니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 요소가 다운 스트림 콜렉터에 표시되는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt; &lt;/a&gt; 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="592e2671cbce0f06db4108a4c9a20ac5ff26eb80" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following characteristics:</source>
          <target state="translated">반환 된 &lt;code&gt;DataFlavor&lt;/code&gt; 는 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="641ba86405285a860416ed87151b9ce572461645" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;HttpRequest&lt;/code&gt; may not be the initiating request provided when &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;sending&lt;/a&gt;. For example, if the initiating request was redirected, then the request returned by this method will have the redirected URI, which will be different from the initiating request URI.</source>
          <target state="translated">반환 된 &lt;code&gt;HttpRequest&lt;/code&gt; 는를&lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;보낼&lt;/a&gt; 때 제공된 시작 요청이 아닐 수 있습니다 . 예를 들어, 시작 요청이 리디렉션 된 경우이 메서드에서 반환 된 요청에는 시작 요청 URI와 다른 리디렉션 된 URI가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59f34697c17be29d15a67dae37118e8cb592e3b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Map&lt;/code&gt; always contains mappings for both &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the &lt;code&gt;Map&lt;/code&gt; returned.</source>
          <target state="translated">반환 된 &lt;code&gt;Map&lt;/code&gt; 에는 항상 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; 키에 대한 매핑이 포함 됩니다. 반환 된 &lt;code&gt;Map&lt;/code&gt; 의 유형, 변경 가능성, 직렬화 가능성 또는 스레드 안전성에 대한 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d858b7e7a502a697faadc883094465ade5ac1148" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Printable&lt;/code&gt; can be printed on any thread.</source>
          <target state="translated">반환 된 &lt;code&gt;Printable&lt;/code&gt; 은 모든 스레드에서 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3084584bbfa81c3dd9e5d128a1532aa3f6cd7c81" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Printable&lt;/code&gt; shares the &lt;code&gt;document&lt;/code&gt; with this &lt;code&gt;JTextComponent&lt;/code&gt;. It is the responsibility of the developer to ensure that the &lt;code&gt;document&lt;/code&gt; is not mutated while this &lt;code&gt;Printable&lt;/code&gt; is used. Printing behavior is undefined when the &lt;code&gt;document&lt;/code&gt; is mutated during printing.</source>
          <target state="translated">반환 된 &lt;code&gt;Printable&lt;/code&gt; 은이 &lt;code&gt;JTextComponent&lt;/code&gt; 와 &lt;code&gt;document&lt;/code&gt; 를 공유합니다 . 이 &lt;code&gt;Printable&lt;/code&gt; 이 사용되는 동안 &lt;code&gt;document&lt;/code&gt; 가 변경되지 않도록하는 것은 개발자의 책임입니다 . 인쇄 중에 &lt;code&gt;document&lt;/code&gt; 가 변경 되면 인쇄 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="22281dd911bd249a01a74dd9023a085760102f82" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Printable&lt;/code&gt; when printed, formats the document content appropriately for the page size. For correct line wrapping the &lt;code&gt;imageable width&lt;/code&gt; of all pages must be the same. See &lt;a href=&quot;../../../java/awt/print/pageformat#getImageableWidth()&quot;&gt;&lt;code&gt;PageFormat.getImageableWidth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Printable&lt;/code&gt; 될 때 반환 된 Printable 은 페이지 크기에 맞게 문서 내용의 형식을 지정합니다. 올바른 줄 바꿈을 위해 모든 페이지 의 &lt;code&gt;imageable width&lt;/code&gt; 가 동일해야합니다. &lt;a href=&quot;../../../java/awt/print/pageformat#getImageableWidth()&quot;&gt; &lt;code&gt;PageFormat.getImageableWidth()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25ddc39787057b4a5d98836cd1d91a3011cd8509" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject 내부의 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 의해 지원됩니다 . 반환에 대한 모든 변경 &lt;code&gt;Set&lt;/code&gt; 내부에 영향을 미치는 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 은 물론입니다.</target>
        </trans-unit>
        <trans-unit id="5d4e1626c242857a248f0940fc4963421f11cce0" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal private Credential &lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal private Credential &lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 비공개 자격 &lt;code&gt;Set&lt;/code&gt; 의해 지원됩니다 . 반환 된 &lt;code&gt;Set&lt;/code&gt; 을 수정 하면 내부 개인 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="92eab9cfd3076bb306b67853f4acd835335f8a36" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal public Credential &lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal public Credential &lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 공개 자격 &lt;code&gt;Set&lt;/code&gt; 의해 지원됩니다 . 반환 된 &lt;code&gt;Set&lt;/code&gt; 을 수정 하면 내부 공개 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="615020d8b91ea3150d89b8eb5df521518f2bf0e3" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject 내부의 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 에 대한 수정 은 내부 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60e6e37a29504c686a29d93cf1b8a805cadab51b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal private Credential &lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal private Credential &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 비공개 자격 &lt;code&gt;Set&lt;/code&gt; 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 수정 해도 내부 개인 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4a692bd81d1139698e9955f1301dc1ea4476c6cb" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal public Credential &lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal public Credential &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 공개 자격 &lt;code&gt;Set&lt;/code&gt; 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 수정 해도 내부 공개 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ee6fed903cbcc5abb5de7f51ad1081371937c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;SourceDataLine&lt;/code&gt;'s default audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;SourceDataLine&lt;/code&gt; 의 기본 오디오 형식은 형식으로 초기화 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10e5de58fd5281c7858b3f0d4c85924e449e2f2d" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TargetDataLine&lt;/code&gt;'s default audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;TargetDataLine&lt;/code&gt; 의 기본 오디오 형식은 형식으로 초기화 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5203d861af68a72a81fc4a8395381f4dbaed35cd" translate="yes" xml:space="preserve">
          <source>The returned Collector disallows null keys and values. If either mapping function returns null, &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">반환 된 Collector는 null 키 및 값을 허용하지 않습니다. 매핑 함수가 null을 반환하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="8630bcc03c8d8bdf7a974e7ae6032481c51ae1c3" translate="yes" xml:space="preserve">
          <source>The returned ReferenceType will be a &lt;a href=&quot;classtype&quot;&gt;&lt;code&gt;ClassType&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;arraytype&quot;&gt;&lt;code&gt;ArrayType&lt;/code&gt;&lt;/a&gt; and never an &lt;a href=&quot;interfacetype&quot;&gt;&lt;code&gt;InterfaceType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 ReferenceType은 &lt;a href=&quot;classtype&quot;&gt; &lt;code&gt;ClassType&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;arraytype&quot;&gt; &lt;code&gt;ArrayType&lt;/code&gt; &lt;/a&gt; 이며 &lt;a href=&quot;interfacetype&quot;&gt; &lt;code&gt;InterfaceType&lt;/code&gt; 이&lt;/a&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="1fd9c231706d0da0d4eddb1a0ac608bee0a7ed4e" translate="yes" xml:space="preserve">
          <source>The returned SecureRandom object has not been seeded. To seed the returned object, call the &lt;code&gt;setSeed&lt;/code&gt; method. If &lt;code&gt;setSeed&lt;/code&gt; is not called, the first call to &lt;code&gt;nextBytes&lt;/code&gt; will force the SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">리턴 된 SecureRandom 오브젝트가 시드되지 않았습니다. 리턴 된 오브젝트를 시드하려면 &lt;code&gt;setSeed&lt;/code&gt; 메소드를 호출하십시오 . 경우 &lt;code&gt;setSeed&lt;/code&gt; 호출되지 않습니다, 최초의 호출 &lt;code&gt;nextBytes&lt;/code&gt; 자신을 배정하는 SecureRandom 오브젝트를 강제 할 것이다. &lt;code&gt;setSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자체 시드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4f45b323d8e60fb385aaaddf4bf5212cf5012ca" translate="yes" xml:space="preserve">
          <source>The returned array comprises all the code signers that have signed this entry.</source>
          <target state="translated">리턴 된 배열은이 항목에 서명 한 모든 코드 서명자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="90a2eb89a967b2512d9881060ad43029b93df120" translate="yes" xml:space="preserve">
          <source>The returned array contains the MIDI controller numbers for which the listener will now receive events. Some sequencers might not support controller event notification, in which case the array has a length of 0. Other sequencers might support notification for some controllers but not all. This method may be invoked repeatedly. Each time, the returned array indicates all the controllers that the listener will be notified about, not only the controllers requested in that particular invocation.</source>
          <target state="translated">반환 된 배열에는 리스너가 이제 이벤트를 수신 할 MIDI 컨트롤러 번호가 포함됩니다. 일부 시퀀서는 컨트롤러 이벤트 알림을 지원하지 않을 수 있으며,이 경우 어레이의 길이는 0입니다. 다른 시퀀서는 일부 컨트롤러에 대한 알림을 지원하지만 일부는 지원하지 않을 수 있습니다. 이 메소드는 반복적으로 호출 될 수 있습니다. 매번 반환 된 배열은 특정 호출에서 요청 된 컨트롤러뿐만 아니라 리스너에게 통보 할 모든 컨트롤러를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="75b91bbe61375a64edfb1c042e15ed189b6a5113" translate="yes" xml:space="preserve">
          <source>The returned array does not include &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;hidden classes or interfaces&lt;/a&gt; or array classes whose &lt;a href=&quot;../../../../java.base/java/lang/class#componentType()&quot;&gt;element type&lt;/a&gt; is a &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;hidden class or interface&lt;/a&gt;. as they cannot be discovered by any class loader.</source>
          <target state="translated">반환 된 배열에는 &lt;a href=&quot;../../../../java.base/java/lang/class#componentType()&quot;&gt;요소 유형&lt;/a&gt; 이 &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;숨겨진 클래스 또는 인터페이스&lt;/a&gt; 인 &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;숨겨진 클래스 또는 인터페이스&lt;/a&gt; 또는 배열 클래스가 포함되지 않습니다 . 어떤 클래스 로더에서도 찾을 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="77ab42c8180b6e9c1c6e98009e4ce02c9ee2fc2b" translate="yes" xml:space="preserve">
          <source>The returned array includes cipher suites from the list of standard cipher suite names in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt; JSSE Cipher Suite Names&lt;/a&gt; section of the Java Cryptography Architecture Standard Algorithm Name Documentation, and may also include other cipher suites that the provider supports.</source>
          <target state="translated">반환 된 배열에는 Java Cryptography Architecture Standard Algorithm Name Documentation 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt;JSSE Cipher Suite Names&lt;/a&gt; 섹션에있는 표준 암호 제품군 이름 목록의 암호 제품군이 포함되며 공급자가 지원하는 다른 암호 제품군도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c51d4e4d3bd5a97c993f659d1ebf0700b61499" translate="yes" xml:space="preserve">
          <source>The returned array includes cipher suites from the list of standard cipher suite names in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt; JSSE Cipher Suite Names&lt;/a&gt; section of the Java Cryptography Architecture Standard Algorithm Name Documentation, and may also include other cipher suites that the provider supports.</source>
          <target state="translated">반환 된 배열에는 Java Cryptography Architecture Standard Algorithm Name Documentation 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt;JSSE Cipher Suite Names&lt;/a&gt; 섹션에있는 표준 암호 제품군 이름 목록의 암호 제품군이 포함되며 공급자가 지원하는 다른 암호 제품군도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="430c0e4d4b5300f2390bbbd1594ba94d4fe7bf7e" translate="yes" xml:space="preserve">
          <source>The returned array includes only the nest members recorded in the &lt;code&gt;NestMembers&lt;/code&gt; attribute, and not any hidden classes that were added to the nest via &lt;a href=&quot;invoke/methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt;&lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 배열에는 &lt;code&gt;NestMembers&lt;/code&gt; 속성에 기록 된 중첩 멤버 만 포함 되며 &lt;a href=&quot;invoke/methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt; &lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt; &lt;/a&gt; 를 통해 중첩에 추가 된 숨겨진 클래스는 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="47f2116b38feb165a5a7fcbeabdd2f6355db1df7" translate="yes" xml:space="preserve">
          <source>The returned array is a copy of the actual array and may be modified in any way without affecting the system tray. To remove a &lt;code&gt;TrayIcon&lt;/code&gt; from the &lt;code&gt;SystemTray&lt;/code&gt;, use the &lt;a href=&quot;#remove(java.awt.TrayIcon)&quot;&gt;&lt;code&gt;remove(TrayIcon)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">반환 된 배열은 실제 배열의 복사본이며 시스템 트레이에 영향을주지 않고 어떤 방식 으로든 수정할 수 있습니다. &lt;code&gt;SystemTray&lt;/code&gt; 에서 &lt;code&gt;TrayIcon&lt;/code&gt; 을 제거하려면 remove &lt;a href=&quot;#remove(java.awt.TrayIcon)&quot;&gt; &lt;code&gt;remove(TrayIcon)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3624c3e8b713f9750ee56a62c2997bd2cc1b21d9" translate="yes" xml:space="preserve">
          <source>The returned array is a shallow copy of the internal array, which means that it is a copy of the internal array of references to the &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; objects but that each referenced &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; object is not copied.</source>
          <target state="translated">리턴 된 배열은 내부 배열의 얕은 사본입니다. 즉, &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; 오브젝트 에 대한 내부 참조 배열의 사본 이지만 참조 된 각 &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; 오브젝트는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fcde0250fbd9f37a68a63dc986de2a345538306" translate="yes" xml:space="preserve">
          <source>The returned array is a shallow copy of the internal array, which means that it is a copy of the internal array of references to the &lt;code&gt;MBeanParameterInfo&lt;/code&gt; objects but that each referenced &lt;code&gt;MBeanParameterInfo&lt;/code&gt; object is not copied.</source>
          <target state="translated">리턴 된 배열은 내부 배열의 얕은 사본입니다. 즉, &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 오브젝트 에 대한 내부 참조 배열의 사본 이지만 참조 된 각 &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 오브젝트는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05ba6a5f60e0641d1235e4005ef40904baaa60b1" translate="yes" xml:space="preserve">
          <source>The returned array never contains methods with names &quot;&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;&quot; or &quot;&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">반환 된 배열에는 이름이 &quot; &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; &quot;인 메서드가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f6c37647bf61a5b5c430747eb2b5e030dc0e7ee8" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 컬렉션에 의해 참조되는 배열이 없기 때문에 &quot;안전&quot;합니다. 다시 말해서,이 메소드는이 콜렉션이 배열에 의해 지원 되더라도 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c7b12233cde488615989699afe78dcad6ed4384" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 배열에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b26c8c7a310fbb9e54174ebdb2dbcf36348363" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this list. (In other words, this method must allocate a new array even if this list is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 목록에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드가이 목록을 배열로 지원하더라도이 메소드는 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9957755e8c40fe5adbd7d7d8d5843d2e55923750" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 목록에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e282460816c42a0ccd3dcea485b9239559bb18e" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 큐에 의해 참조되는 배열이 없으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e87afccdc8466069c7b753215ae2cacd201fd10" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 세트에 의해 참조되는 배열이 없기 때문에 &quot;안전&quot;합니다. 즉,이 메소드가 배열에 의해 지원 되더라도이 메소드는 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8651aa449d701f684570ddf36fba5191566388d6" translate="yes" xml:space="preserve">
          <source>The returned attribute information is limited to runs that contain the current character.</source>
          <target state="translated">리턴 된 속성 정보는 현재 문자가 포함 된 실행으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3d33c31d474f6dd046417604a6a9ae4803e6b9" translate="yes" xml:space="preserve">
          <source>The returned certificate array comprises all the signer certificates that were used to verify this entry. Each signer certificate is followed by its supporting certificate chain (which may be empty). Each signer certificate and its supporting certificate chain are ordered bottom-to-top (i.e., with the signer certificate first and the (root) certificate authority last).</source>
          <target state="translated">리턴 된 인증 배열은이 항목을 확인하는 데 사용 된 모든 서명자 인증으로 구성됩니다. 각 서명자 인증서 뒤에는 지원 인증서 체인 (비어있을 수 있음)이옵니다. 각 서명자 인증서 및 지원 인증서 체인은 맨 아래에서 순서대로 주문됩니다 (즉, 서명자 인증서가 먼저 있고 (루트) 인증 기관이 마지막에 있음).</target>
        </trans-unit>
        <trans-unit id="61c3a6711385606db98b86cc4dc71d68bdea4436" translate="yes" xml:space="preserve">
          <source>The returned clip must be opened with the &lt;code&gt;open(AudioFormat)&lt;/code&gt; or &lt;code&gt;open(AudioInputStream)&lt;/code&gt; method.</source>
          <target state="translated">반환 된 클립은 &lt;code&gt;open(AudioFormat)&lt;/code&gt; 또는 &lt;code&gt;open(AudioInputStream)&lt;/code&gt; 메서드로 열어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ceb417aa63a35568772d2ba08459a4d0f57ffbee" translate="yes" xml:space="preserve">
          <source>The returned collection does</source>
          <target state="translated">반환 된 컬렉션은</target>
        </trans-unit>
        <trans-unit id="b07c416f52316fbf6c7d40a634719186c13469b3" translate="yes" xml:space="preserve">
          <source>The returned collection will be serializable if the specified collection is serializable.</source>
          <target state="translated">지정된 콜렉션이 직렬화 가능한 경우, 리턴 된 콜렉션은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3be1f1672220475d8271f6e01c1f720a84f08e5b" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable (assuming the specified comparator is also serializable or &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">반환 된 비교기는 직렬화 가능합니다 (지정된 비교기가 직렬화 가능 또는 &lt;code&gt;null&lt;/code&gt; 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="2812de92165ec02fbb836f9148b615e9ccc3b5b2" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">반환 된 비교기는 직렬화 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; &lt;code&gt;null&lt;/code&gt; 를 비교할 때 NullPointerException을 Throw 합니다.</target>
        </trans-unit>
        <trans-unit id="77a6f4be0bfa1c8aa5aedc5a42831ad20378a870" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing an entry with a null key.</source>
          <target state="translated">리턴 된 비교기는 직렬화 가능하며 항목을 널 키와 비교할 때 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="22bf28f66c9f612e083df0a59239e3c46c04c933" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing an entry with null values.</source>
          <target state="translated">리턴 된 비교기는 직렬화 가능하며 항목을 널값과 비교할 때 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="51644083b4b8fda187f5a628a6258b22d611a598" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified comparator is also serializable.</source>
          <target state="translated">지정된 비교기가 직렬화 가능한 경우, 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d69bb8caf8d86905d98a11aab0d0a3baa774bad3" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified comparator is serializable.</source>
          <target state="translated">지정된 비교기가 직렬화 가능하면, 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f0576c7aa360de3b65d8c8efe158571eec213ab2" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified function and comparator are both serializable.</source>
          <target state="translated">지정된 함수와 비교기가 모두 직렬화 가능하면 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ba917226177854af620439263d809c330c5d69cf" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified function is also serializable.</source>
          <target state="translated">지정된 함수도 직렬화 가능하면 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0334b290d5844794dff470460f3065bc09010f74" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable.</source>
          <target state="translated">반환 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="84b94e59406a95c4ca5a8d11de2db0b0bbe9f7c0" translate="yes" xml:space="preserve">
          <source>The returned completable future completes exceptionally with:</source>
          <target state="translated">반환 된 완성 가능한 미래는 다음과 같이 예외적으로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c615624e02206189b87ea763df189e93fca46655" translate="yes" xml:space="preserve">
          <source>The returned completable future, if completed successfully, completes with an &lt;a href=&quot;httpresponse&quot;&gt;&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; that contains the response status, headers, and body ( as handled by given response body handler ).</source>
          <target state="translated">반환 된 완료 가능한 미래는 성공적으로 완료되면 응답 상태, 헤더 및 본문이 포함 된 &lt;a href=&quot;httpresponse&quot;&gt; &lt;code&gt;HttpResponse&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (주어진 응답 본문 핸들러에서 처리됨)로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d33135e5a1f395b41fad98d6b20e99dae320a6" translate="yes" xml:space="preserve">
          <source>The returned era will be a singleton capable of being compared with the constants in &lt;a href=&quot;chrono/isochronology&quot;&gt;&lt;code&gt;IsoChronology&lt;/code&gt;&lt;/a&gt; using the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">반환 된 시대는 &lt;code&gt;==&lt;/code&gt; 연산자를 사용하여 &lt;a href=&quot;chrono/isochronology&quot;&gt; &lt;code&gt;IsoChronology&lt;/code&gt; &lt;/a&gt; 의 상수와 비교할 수있는 싱글 톤 입니다.</target>
        </trans-unit>
        <trans-unit id="8932377dd8e02a84a648c771d6426ce831a87e6f" translate="yes" xml:space="preserve">
          <source>The returned filter uses &lt;a href=&quot;../../../java.base/java/util/regex/matcher#find()&quot;&gt;&lt;code&gt;Matcher.find()&lt;/code&gt;&lt;/a&gt; to test for inclusion. To test for exact matches use the characters '^' and '$' to match the beginning and end of the string respectively. For example, &quot;^foo$&quot; includes only rows whose string is exactly &quot;foo&quot; and not, for example, &quot;food&quot;. See &lt;a href=&quot;../../../java.base/java/util/regex/pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; for a complete description of the supported regular-expression constructs.</source>
          <target state="translated">반환 된 필터는 &lt;a href=&quot;../../../java.base/java/util/regex/matcher#find()&quot;&gt; &lt;code&gt;Matcher.find()&lt;/code&gt; &lt;/a&gt; 를 사용하여 포함 여부를 테스트합니다. 정확한 일치를 테스트하려면 문자 '^'및 '$'를 사용하여 각각 문자열의 시작과 끝을 일치 시키십시오. 예를 들어, &quot;^ foo $&quot;는 문자열이 정확히 &quot;foo&quot;인 행만 포함하고 &quot;food&quot;는 포함하지 않습니다. 지원되는 정규식 구성에 대한 전체 설명은 &lt;a href=&quot;../../../java.base/java/util/regex/pattern&quot;&gt; &lt;code&gt;Pattern&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="685a6e900daf413e8d8765bf083707c3fc12c8e0" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록 ISO의 연대기가 설정되어 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="617ab648dccda8ea4bfed9ff5c0e4dca48843eb4" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style. The &lt;code&gt;FULL&lt;/code&gt; and &lt;code&gt;LONG&lt;/code&gt; styles typically require a time-zone. When formatting using these styles, a &lt;code&gt;ZoneId&lt;/code&gt; must be available, either by using &lt;code&gt;ZonedDateTime&lt;/code&gt; or &lt;a href=&quot;#withZone(java.time.ZoneId)&quot;&gt;&lt;code&gt;withZone(java.time.ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록하기 위해 설정된 ISO 연대기가 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 . &lt;code&gt;FULL&lt;/code&gt; 및 &lt;code&gt;LONG&lt;/code&gt; 스타일은 일반적으로 시간대를 필요로한다. 이러한 스타일을 사용하여 서식 때, &lt;code&gt;ZoneId&lt;/code&gt; 은 사용 중, 사용 가능해야합니다 &lt;code&gt;ZonedDateTime&lt;/code&gt; 또는 &lt;a href=&quot;#withZone(java.time.ZoneId)&quot;&gt; &lt;code&gt;withZone(java.time.ZoneId)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7747f70640f1e4a45424ed0c1270bbc9549330f" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#STRICT&quot;&gt;&lt;code&gt;STRICT&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록 ISO의 연대기가 설정되어 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#STRICT&quot;&gt; &lt;code&gt;STRICT&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c3dda27b1c2af94aa2edb7b9c334041c2040aee1" translate="yes" xml:space="preserve">
          <source>The returned formatter has no override chronology or zone. It uses &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 재정의 연대기 또는 영역이 없습니다. &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="65f23c4bdba155d972d5a5c334ace90811627c2f" translate="yes" xml:space="preserve">
          <source>The returned formatter has no override chronology or zone. It uses the &lt;a href=&quot;resolverstyle#STRICT&quot;&gt;&lt;code&gt;STRICT&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 재정의 연대기 또는 영역이 없습니다. &lt;a href=&quot;resolverstyle#STRICT&quot;&gt; &lt;code&gt;STRICT&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="93e620ed0c6b2f581405e4ca186e0d0c26a039f0" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt; providing that the base clock is.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; , 기본 클록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ebf894963bb17de1c19228a9892a378efc764d2" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="16aec74c31404fdf24dbc2481edc9947ae28ae7f" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;system(ZoneId.systemDefault())&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 그것은 동등 &lt;code&gt;system(ZoneId.systemDefault())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e83331df05c75aa0965f68cf383b4fa1ce4775" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;system(ZoneOffset.UTC)&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. &lt;code&gt;system(ZoneOffset.UTC)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="256a067cbdccb5e2e330ac00c3dcdb3f79fff5d2" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofMillis(1))&lt;/code&gt;.</source>
          <target state="translated">반환 된 구현은 변경 불가능하고 스레드로부터 안전하며 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofMillis(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39695b971886168cd9e28cf54007c2987d52ae31" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofMinutes(1))&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 이것은와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofMinutes(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d8edb2d119f60ce6b547f8aeea62c8bb10250e" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofSeconds(1))&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 이것은와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofSeconds(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab8e6a2c1e29941612774d35818b8817f708321" translate="yes" xml:space="preserve">
          <source>The returned index is the largest value</source>
          <target state="translated">반환 된 인덱스는 가장 큰 값입니다</target>
        </trans-unit>
        <trans-unit id="324947fcc7f39d43c0a0080101a27650dcd91d17" translate="yes" xml:space="preserve">
          <source>The returned index is the largest value &lt;code&gt;k&lt;/code&gt; for which:</source>
          <target state="translated">반환 된 인덱스는 다음과 같은 가장 큰 값 &lt;code&gt;k&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1010f5a375a5d3f29e20face9e80371d4a90f440" translate="yes" xml:space="preserve">
          <source>The returned index is the smallest value</source>
          <target state="translated">반환 된 인덱스는 가장 작은 값입니다</target>
        </trans-unit>
        <trans-unit id="b96444254cceb87f3cb7ff9401f1b082c1d382c7" translate="yes" xml:space="preserve">
          <source>The returned index is the smallest value &lt;code&gt;k&lt;/code&gt; for which:</source>
          <target state="translated">반환 된 인덱스는 다음과 같은 최소값 &lt;code&gt;k&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30fb35855f9641f7209a86fa609966716cae03af" translate="yes" xml:space="preserve">
          <source>The returned indexes are limited to the range of the iterator.</source>
          <target state="translated">반환 된 인덱스는 반복자의 범위로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c52ca666bd6ac96a80f0c043191a66ce94fda2cf" translate="yes" xml:space="preserve">
          <source>The returned instance will have its &lt;a href=&quot;#isUnordered()&quot;&gt;&lt;code&gt;unordered&lt;/code&gt;&lt;/a&gt; value set to &lt;code&gt;false&lt;/code&gt;, its &lt;a href=&quot;#timeToLive()&quot;&gt;&lt;code&gt;timeToLive&lt;/code&gt;&lt;/a&gt; value set to &lt;code&gt;0&lt;/code&gt;, its &lt;a href=&quot;#isComplete()&quot;&gt;&lt;code&gt;complete&lt;/code&gt;&lt;/a&gt; value set to &lt;code&gt;true&lt;/code&gt;, and its &lt;a href=&quot;#payloadProtocolID()&quot;&gt;&lt;code&gt;payloadProtocolID&lt;/code&gt;&lt;/a&gt; value set to &lt;code&gt;0&lt;/code&gt;. These values, if required, can be set through the appropriate setter method before sending the message.</source>
          <target state="translated">반환 된 인스턴스는 것이다 &lt;a href=&quot;#isUnordered()&quot;&gt; &lt;code&gt;unordered&lt;/code&gt; &lt;/a&gt; 가치 설정 &lt;code&gt;false&lt;/code&gt; , 그것 &lt;a href=&quot;#timeToLive()&quot;&gt; &lt;code&gt;timeToLive&lt;/code&gt; &lt;/a&gt; 로 설정된 값 &lt;code&gt;0&lt;/code&gt; , 그것의 &lt;a href=&quot;#isComplete()&quot;&gt; &lt;code&gt;complete&lt;/code&gt; &lt;/a&gt; 가치 세트 &lt;code&gt;true&lt;/code&gt; , 그 &lt;a href=&quot;#payloadProtocolID()&quot;&gt; &lt;code&gt;payloadProtocolID&lt;/code&gt; 의&lt;/a&gt; 가치 세트 &lt;code&gt;0&lt;/code&gt; . 필요한 경우 이러한 값은 메시지를 보내기 전에 적절한 setter 메서드를 통해 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45bc891e1f438dd01ea7196d9842b794781ae4f" translate="yes" xml:space="preserve">
          <source>The returned instants from &lt;code&gt;Clock&lt;/code&gt; work on a time-scale that ignores leap seconds, as described in &lt;a href=&quot;instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt;. If the implementation wraps a source that provides leap second information, then a mechanism should be used to &quot;smooth&quot; the leap second. The Java Time-Scale mandates the use of UTC-SLS, however clock implementations may choose how accurate they are with the time-scale so long as they document how they work. Implementations are therefore not required to actually perform the UTC-SLS slew or to otherwise be aware of leap seconds.</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 에서 반환 된 인스턴트 는 &lt;a href=&quot;instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; 에&lt;/a&gt; 설명 된대로 윤초를 무시하는 시간 단위로 작동합니다 . 구현이 윤초 정보를 제공하는 소스를 래핑하는 경우 윤초를 &quot;부드럽게&quot;하기 위해 메커니즘을 사용해야합니다. Java Time-Scale은 UTC-SLS의 사용을 의무화하지만 시계 구현은 작동 방식을 문서화하는 한 시간 단위로 얼마나 정확한지 선택할 수 있습니다. 따라서 실제로 UTC-SLS 회전을 수행하거나 윤초를 인식 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dfea46346d425f47431ab48a0b9973f65d3a3d0" translate="yes" xml:space="preserve">
          <source>The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 반복자는 &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;빠른 속도입니다.&lt;/i&gt;&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d825a47643cf28fa3b87aadae1a13cf5b1f8bb0" translate="yes" xml:space="preserve">
          <source>The returned iterator is &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 반복자는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;약하게 일관성이 있습니다.&lt;/i&gt;&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9ef6fd11db72e67c90473d6e296ebd844318cf20" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt; method.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="dd06f34d84c884510eb2daefd756631c982e6784" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;add&lt;/code&gt; methods.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;add&lt;/code&gt; 를 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="6c8995a19beeeaa38d931dd04ead46af4bf6aeaf" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the set when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt; method.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 세트 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="b28ef914634dbd42c57b4fb798bc270a1b137343" translate="yes" xml:space="preserve">
          <source>The returned line should be opened with the &lt;code&gt;open(AudioFormat)&lt;/code&gt; or &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; method.</source>
          <target state="translated">반환 된 줄은 &lt;code&gt;open(AudioFormat)&lt;/code&gt; 또는 &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; 메서드로 합니다.</target>
        </trans-unit>
        <trans-unit id="603df59fcea4e98e66008bfad2caba193eee7e62" translate="yes" xml:space="preserve">
          <source>The returned list consists of language ranges from the given &lt;code&gt;ranges&lt;/code&gt; and their equivalents found in the IANA Language Subtag Registry. For example, if the given &lt;code&gt;ranges&lt;/code&gt; is &lt;code&gt;&quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;&lt;/code&gt;, the elements in the list to be returned are:</source>
          <target state="translated">리턴 된 목록은 주어진 &lt;code&gt;ranges&lt;/code&gt; 의 언어 범위 와 IANA 언어 서브 태그 레지스트리에있는 해당 범위로 구성됩니다 . 예를 들어, 주어진 &lt;code&gt;ranges&lt;/code&gt; 가 &lt;code&gt;&quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;&lt;/code&gt; 인 경우 반환되는 목록의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea6ef8590a840eacd817ee2b90a2f4e62a449824" translate="yes" xml:space="preserve">
          <source>The returned list does not include &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;hidden classes or interfaces&lt;/a&gt; or array classes whose &lt;a href=&quot;arraytype#componentType()&quot;&gt;element type&lt;/a&gt; is a &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;hidden class or interface&lt;/a&gt;. as they cannot be discovered by any class loader</source>
          <target state="translated">반환 된 목록에는 &lt;a href=&quot;arraytype#componentType()&quot;&gt;요소 유형&lt;/a&gt; 이 &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;숨겨진 클래스 또는 인터페이스&lt;/a&gt; 인 &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;숨겨진 클래스 또는 인터페이스&lt;/a&gt; 또는 배열 클래스가 포함되지 않습니다 . 어떤 클래스 로더에서도 찾을 수 없기 때문에</target>
        </trans-unit>
        <trans-unit id="eb1e0c77eddff020314d13ac5b80139ee3a974d0" translate="yes" xml:space="preserve">
          <source>The returned list implements the optional &lt;code&gt;Collection&lt;/code&gt; methods, except those that would change the size of the returned list. Those methods leave the list unchanged and throw &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 목록은 반환 된 목록 의 크기를 변경하는 경우를 제외하고 선택적 &lt;code&gt;Collection&lt;/code&gt; 메서드를 구현 합니다. 이러한 메서드는 목록을 변경하지 않고 &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e8ccf04805571d510869c52da4e3447fdf55cace" translate="yes" xml:space="preserve">
          <source>The returned list includes all reference types, including &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt;&lt;code&gt;hidden classes or interfaces&lt;/code&gt;&lt;/a&gt;, loaded at least to the point of preparation and types (like array) for which preparation is not defined.</source>
          <target state="translated">반환 된 목록에는 적어도 준비 지점까지로드 된 &lt;a href=&quot;../../../../java.base/java/lang/class#isHidden()&quot;&gt; &lt;code&gt;hidden classes or interfaces&lt;/code&gt; &lt;/a&gt; 포함한 모든 참조 유형 과 준비가 정의되지 않은 유형 (예 : 배열)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e4e4b3e38d248cd7e5998a34d9a87596fd1c1fda" translate="yes" xml:space="preserve">
          <source>The returned list is modifiable so as to facilitate changes to the existing ACL. The &lt;a href=&quot;#setAcl(java.util.List)&quot;&gt;&lt;code&gt;setAcl&lt;/code&gt;&lt;/a&gt; method is used to update the file's ACL attribute.</source>
          <target state="translated">반환 된 목록은 기존 ACL을 쉽게 변경할 수 있도록 수정할 수 있습니다. &lt;a href=&quot;#setAcl(java.util.List)&quot;&gt; &lt;code&gt;setAcl&lt;/code&gt; &lt;/a&gt; 방법은 파일의 ACL 속성을 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afce95588c0380c39f79771261da47a2d309e9a8" translate="yes" xml:space="preserve">
          <source>The returned list is modifiable so as to facilitate changes to the existing ACL. The &lt;a href=&quot;aclfileattributeview#setAcl-java.util.List-&quot;&gt;&lt;code&gt;setAcl&lt;/code&gt;&lt;/a&gt; method is used to update the file's ACL attribute.</source>
          <target state="translated">리턴 된 목록은 기존 ACL을 쉽게 변경할 수 있도록 수정할 수 있습니다. &lt;a href=&quot;aclfileattributeview#setAcl-java.util.List-&quot;&gt; &lt;code&gt;setAcl&lt;/code&gt; &lt;/a&gt; 방법은 파일의 ACL 속성을 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c503093f4e0ea3beb8f9f47ec55e6810f3e4744d" translate="yes" xml:space="preserve">
          <source>The returned list is not necessarily exhaustive. That is, the MBean may have a public constructor that is not in the list. In this case, the MBean server can construct another instance of this MBean's class using that constructor, even though it is not listed here.</source>
          <target state="translated">반환 된 목록이 반드시 완전한 것은 아닙니다. 즉, MBean에는 목록에없는 공용 생성자가있을 수 있습니다. 이 경우, MBean 서버는 여기에 나열되어 있지 않더라도 해당 생성자를 사용하여이 MBean 클래스의 다른 인스턴스를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4ba1a6fc0e1176884c27c61e7f3010f2b892f0" translate="yes" xml:space="preserve">
          <source>The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 목록 반복자가 &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;실패했습니다.&lt;/i&gt;&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e5480482a345877ff721b616ca16ea8ed32101e" translate="yes" xml:space="preserve">
          <source>The returned list may contain multiple locations for a particular line number, if the compiler and/or VM has mapped that line to two or more disjoint code index ranges.</source>
          <target state="translated">컴파일러 및 / 또는 VM이 ​​해당 줄을 둘 이상의 분리 된 코드 인덱스 범위에 매핑 한 경우 반환 된 목록에는 특정 줄 번호에 대한 여러 위치가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca9df76291579b501b3fdfee2f39774c2720a485" translate="yes" xml:space="preserve">
          <source>The returned list will be serializable if the specified list is serializable.</source>
          <target state="translated">지정된 목록이 직렬화 가능하면 리턴 된 목록은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b51e7cf95fea371d30e6037819047e729ec2ba1c" translate="yes" xml:space="preserve">
          <source>The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; if the specified list does.</source>
          <target state="translated">지정된 목록이 직렬화 가능하면 리턴 된 목록은 직렬화 가능합니다. 마찬가지로 반환 된 목록은 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 를 구현합니다. 지정된 목록 합니다.</target>
        </trans-unit>
        <trans-unit id="04d0f9b8a9ef829e7c7e0bf6383b9f855499c50e" translate="yes" xml:space="preserve">
          <source>The returned list will include reference types loaded at least to the point of preparation and types (like array) for which preparation is not defined.</source>
          <target state="translated">반환 된 목록에는 적어도 준비 시점까지로드 된 참조 유형과 준비가 정의되지 않은 유형 (예 : 배열)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bf755a47227812109e329812c17f2e30f9fb6597" translate="yes" xml:space="preserve">
          <source>The returned logger will perform message localization as specified by &lt;a href=&quot;system.loggerfinder#getLocalizedLogger(java.lang.String,java.util.ResourceBundle,java.lang.Module)&quot;&gt;&lt;code&gt;LoggerFinder.getLocalizedLogger(name, bundle, module)&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;module&lt;/code&gt; is the caller's module. In cases where &lt;code&gt;System.getLogger&lt;/code&gt; is called from a context where there is no caller frame on the stack (e.g when called directly from a JNI attached thread), &lt;code&gt;IllegalCallerException&lt;/code&gt; is thrown. To obtain a logger in such a context, use an auxiliary class that will implicitly be identified as the caller, or use the system &lt;a href=&quot;system.loggerfinder#getLoggerFinder()&quot;&gt;&lt;code&gt;LoggerFinder&lt;/code&gt;&lt;/a&gt; to obtain a logger instead. Note that doing the latter may eagerly initialize the underlying logging system.</source>
          <target state="translated">반환 된 로거는 &lt;a href=&quot;system.loggerfinder#getLocalizedLogger(java.lang.String,java.util.ResourceBundle,java.lang.Module)&quot;&gt; &lt;code&gt;LoggerFinder.getLocalizedLogger(name, bundle, module)&lt;/code&gt; &lt;/a&gt; 지정된대로 메시지 현지화를 수행합니다 . 여기서 &lt;code&gt;module&lt;/code&gt; 은 호출자의 모듈입니다. 스택에 호출자 프레임이없는 컨텍스트 에서 &lt;code&gt;System.getLogger&lt;/code&gt; 가 호출되는 경우 (예 : JNI 연결 스레드에서 직접 호출되는 경우) &lt;code&gt;IllegalCallerException&lt;/code&gt; 이 발생합니다. 이러한 컨텍스트에서 로거를 얻으려면 암시 ​​적으로 호출자로 식별되는 보조 클래스를 사용하거나 대신 시스템 &lt;a href=&quot;system.loggerfinder#getLoggerFinder()&quot;&gt; &lt;code&gt;LoggerFinder&lt;/code&gt; &lt;/a&gt; 를 사용하여 로거를 얻습니다. 후자를 수행하면 기본 로깅 시스템을 열심히 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3cf87e163405abbca1ef35f4f6b362d57c5c392" translate="yes" xml:space="preserve">
          <source>The returned map and its collection views may not obey the general contract of the &lt;a href=&quot;object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;object#hashCode()&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">반환 된 맵과 컬렉션 뷰는 &lt;a href=&quot;object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;object#hashCode()&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 메서드 의 일반 계약을 따르지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04550933f42e1b20dd67a722e85a83b892d29e8b" translate="yes" xml:space="preserve">
          <source>The returned map and its collection views may not obey the general contract of the &lt;a href=&quot;object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">리턴 된 맵 및 해당 콜렉션보기는 &lt;a href=&quot;object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 의 일반 계약을 준수하지 않을 수 있습니다. 메소드 .</target>
        </trans-unit>
        <trans-unit id="2592b2ccc5cce39b4370391737f4d234053e34d0" translate="yes" xml:space="preserve">
          <source>The returned map contains one entry for each tab to be added in the tabbed pane in a JConsole window with the tab name as the key and the &lt;a href=&quot;../../../../../java.desktop/javax/swing/jpanel&quot;&gt;&lt;code&gt;JPanel&lt;/code&gt;&lt;/a&gt; object as the value. This method returns an empty map if no tab is added by this plugin. This method will be called from the</source>
          <target state="translated">반환 된 맵에는 탭 이름을 키로 사용하고 &lt;a href=&quot;../../../../../java.desktop/javax/swing/jpanel&quot;&gt; &lt;code&gt;JPanel&lt;/code&gt; &lt;/a&gt; 개체를 값으로 사용하여 JConsole 창의 탭 창에 추가 할 각 탭에 대한 항목이 하나씩 포함 됩니다. 이 플러그인에 의해 추가 된 탭이없는 경우이 메소드는 빈지도를 반환합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이 메서드는</target>
        </trans-unit>
        <trans-unit id="bd8d64063c7ed0ea19647d547170466cdf6c7ae7" translate="yes" xml:space="preserve">
          <source>The returned map does not permit null keys or values. Attempting to insert or query the presence of a null key or value will throw a &lt;a href=&quot;nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;. Attempting to query the presence of a key or value which is not of type &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;classcastexception&quot;&gt;&lt;code&gt;ClassCastException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 맵은 널 키 또는 값을 허용하지 않습니다. null 키 또는 값이 있는지 삽입하거나 쿼리하려고하면 &lt;a href=&quot;nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형이 아닌 키 또는 값의 존재를 쿼리하려고 하면 &lt;a href=&quot;classcastexception&quot;&gt; &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6adecd8da1fa6d74979ab4b71410df2ad020d787" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵에는 &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. 식 &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;m&lt;/code&gt; 본질적으로 동등한 &lt;code&gt;m&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="de626c9a4a06c5beb2eb08bc7e1023f6785c4bcc" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵의 순서는 &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일합니다 . &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 표현식 은 기본적으로 &lt;code&gt;m&lt;/code&gt; 과 동등한 &lt;code&gt;m&lt;/code&gt; 의 뷰를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e78c6f35b029ca60ae6001c0f097568236673e" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵에는 &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. 식 &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;m&lt;/code&gt; 본질적으로 동등한 &lt;code&gt;m&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="47af6d18a03dd37ca75973b55abf606e91a20528" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵의 순서는 &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt; 와 동일합니다 . &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 표현식 은 기본적으로 &lt;code&gt;m&lt;/code&gt; 과 동등한 &lt;code&gt;m&lt;/code&gt; 의 뷰를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a6919fc63dffbd2b665571fbe3d0e62befa5d6f" translate="yes" xml:space="preserve">
          <source>The returned map implements all optional &lt;a href=&quot;../sortedmap&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; operations</source>
          <target state="translated">리턴 된 맵은 모든 선택적 &lt;a href=&quot;../sortedmap&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt; 조작을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3e60ce6cdb39e55f6aea0270ae6050c5d468141c" translate="yes" xml:space="preserve">
          <source>The returned map is typically case-sensitive on all platforms.</source>
          <target state="translated">리턴 된 맵은 일반적으로 모든 플랫폼에서 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ebb8ac95b0820624300e6c51aa32adf9bf40ac27" translate="yes" xml:space="preserve">
          <source>The returned map will be serializable if the specified map is serializable.</source>
          <target state="translated">지정된 맵이 직렬화 가능하면 리턴 된 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3580abdef3f87a6bd80d4bea2b490670bec97aa7" translate="yes" xml:space="preserve">
          <source>The returned map will never contain null keys or values. Attempting to query the presence of a null key or value will throw a &lt;a href=&quot;nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;. Attempting to query the presence of a key or value which is not of type &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;classcastexception&quot;&gt;&lt;code&gt;ClassCastException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 맵에는 널 키 또는 값이 포함되지 않습니다. null 키 또는 값이 있는지 쿼리하려고하면 &lt;a href=&quot;nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형이 아닌 키 또는 값의 존재를 쿼리하려고 하면 &lt;a href=&quot;classcastexception&quot;&gt; &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="186b57fc3142be2ab7c06b068233e86af34426e7" translate="yes" xml:space="preserve">
          <source>The returned map will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert a key outside its range.</source>
          <target state="translated">돌려 주어지는 맵은 그 범위 외의 키를 삽입하려고 하면 (자) &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="38495ee31c82f624af115d8608382ab49eee4275" translate="yes" xml:space="preserve">
          <source>The returned map will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.</source>
          <target state="translated">돌려 주어진 맵은 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 범위를 벗어난 키를 삽입하거나 엔드 포인트가 범위 밖에있는 서브맵을 구성하려는 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="cb7427863a48aa5f4ceb84b369a735b8a29e3170" translate="yes" xml:space="preserve">
          <source>The returned method (if non-null) is a component of &lt;a href=&quot;classtype&quot;&gt;&lt;code&gt;ClassType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 메서드 (null이 아닌 경우)는 &lt;a href=&quot;classtype&quot;&gt; &lt;code&gt;ClassType&lt;/code&gt; &lt;/a&gt; 의 구성 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="3b7da5ac39ea912d89eb86cf1f58a17a89487bae" translate="yes" xml:space="preserve">
          <source>The returned method handle is equivalent to &lt;code&gt;dropArguments(zero(type.returnType()), 0, type.parameterList())&lt;/code&gt;.</source>
          <target state="translated">반환 된 메서드 핸들은 &lt;code&gt;dropArguments(zero(type.returnType()), 0, type.parameterList())&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="be839b6e9781e2a92a16b75b05df60ab61f8f103" translate="yes" xml:space="preserve">
          <source>The returned method handle is equivalent to &lt;code&gt;empty(methodType(type))&lt;/code&gt;. It is also equivalent to &lt;code&gt;explicitCastArguments(constant(Object.class, null), methodType(type))&lt;/code&gt;, since &lt;code&gt;explicitCastArguments&lt;/code&gt; converts &lt;code&gt;null&lt;/code&gt; to default values.</source>
          <target state="translated">반환 된 메서드 핸들은 &lt;code&gt;empty(methodType(type))&lt;/code&gt; 과 동일합니다 . 또한 &lt;code&gt;explicitCastArguments&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 을 기본값 으로 변환 하므로 explicitCastArguments &lt;code&gt;explicitCastArguments(constant(Object.class, null), methodType(type))&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="bf341b930019b986feaa3025d94588cbf0b07082" translate="yes" xml:space="preserve">
          <source>The returned method handle is equivalent to &lt;code&gt;identity(type).bindTo(value)&lt;/code&gt;.</source>
          <target state="translated">리턴 된 메소드 핸들은 &lt;code&gt;identity(type).bindTo(value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08c6e093f65426cb1d1abfa5dcc5c30c713506d0" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt; if and only if the constructor's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">반환 된 메서드 핸들은 생성자의 가변 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity&lt;/a&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="68be879cb87a23db36e0a68951f564309bd3df0e" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument. (If the trailing array argument is the only argument, the given receiver value will be bound to it.)</source>
          <target state="translated">반환 된 메서드 핸들은 메서드의 가변 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정 &lt;em&gt;되고&lt;/em&gt; 후행 배열 인수가 유일한 인수가 아닌 경우에만 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity&lt;/a&gt; 를 갖습니다 . (후행 배열 인수가 유일한 인수 인 경우 지정된 수신자 값이 여기에 바인딩됩니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97d70a1480f82e4e58a7bae7833050abcbcd7b02" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">반환 된 메서드 핸들은 메서드의 가변 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;가변 arity&lt;/a&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="cf12e977e77f8c538e96bf14109eaad3316041c8" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the constructor's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">생성자의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 반환 된 메소드 핸들에 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b84ac4232d79eefcfa3e985c888ae7cb52f78ae" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument. (If the trailing array argument is the only argument, the given receiver value will be bound to it.)</source>
          <target state="translated">메소드의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정 &lt;em&gt;되고&lt;/em&gt; 후행 배열 인수가 유일한 인수가 아닌 경우에만 리턴 된 메소드 핸들은 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 를 갖습니다 . 후행 배열 인수가 유일한 인수이면 지정된 수신자 값이 바인딩됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdb52f5efb367c3a0c6f85b8e5a561c3fd955c91" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">메소드의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 리턴 된 메소드 핸들에 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7fc53c29677f5d1950f8b1cceaed84e97f9c71b" translate="yes" xml:space="preserve">
          <source>The returned multicaster contains all the listeners in this multicaster with the exception of all occurrences of &lt;code&gt;oldl&lt;/code&gt;. If the resulting multicaster contains only one regular listener the regular listener may be returned. If the resulting multicaster is empty, then &lt;code&gt;null&lt;/code&gt; may be returned instead.</source>
          <target state="translated">반환 된 멀티 캐스터는 모든 &lt;code&gt;oldl&lt;/code&gt; 발생을 제외하고이 멀티 캐스터의 모든 리스너를 포함합니다 . 결과 멀티 캐스터에 일반 리스너가 하나만 포함 된 경우 일반 리스너가 반환 될 수 있습니다. 결과 멀티 캐스터가 비어 있으면 대신 &lt;code&gt;null&lt;/code&gt; 이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="812acb325d7ae416383679e0dc980c9b542376d7" translate="yes" xml:space="preserve">
          <source>The returned name is dependent on VM's default stratum (&lt;a href=&quot;virtualmachine#getDefaultStratum()&quot;&gt;&lt;code&gt;VirtualMachine.getDefaultStratum()&lt;/code&gt;&lt;/a&gt;). In the reference implementation, when using the base stratum, the returned string is the unqualified name of the source file containing the declaration of this type. In other strata the returned source name is the first source name for that stratum. Since other languages may have more than one source name for a reference type, the use of &lt;a href=&quot;location#sourceName()&quot;&gt;&lt;code&gt;Location.sourceName()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#sourceNames(java.lang.String)&quot;&gt;&lt;code&gt;sourceNames(String)&lt;/code&gt;&lt;/a&gt; is preferred.</source>
          <target state="translated">반환 된 이름은 VM의 기본 계층 ( &lt;a href=&quot;virtualmachine#getDefaultStratum()&quot;&gt; &lt;code&gt;VirtualMachine.getDefaultStratum()&lt;/code&gt; &lt;/a&gt; ) 에 따라 다릅니다 . 참조 구현에서 기본 계층을 사용할 때 반환되는 문자열은이 유형의 선언을 포함하는 소스 파일의 정규화되지 않은 이름입니다. 다른 계층에서 반환 된 소스 이름은 해당 계층의 첫 번째 소스 이름입니다. 다른 언어는 참조 유형에 대해 둘 이상의 소스 이름을 가질 수 있으므로 &lt;a href=&quot;location#sourceName()&quot;&gt; &lt;code&gt;Location.sourceName()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#sourceNames(java.lang.String)&quot;&gt; &lt;code&gt;sourceNames(String)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="221f6133ad0d362e01edda7bf12ed28159130583" translate="yes" xml:space="preserve">
          <source>The returned names are for the specified stratum (see &lt;a href=&quot;location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; for a description of strata). In the reference implementation, when using the Java programming language stratum, the returned List contains one element: a String which is the unqualified name of the source file containing the declaration of this type. In other strata the returned source names are all the source names defined for that stratum.</source>
          <target state="translated">반환 된 이름은 지정된 계층 에 대한 것입니다 (지층에 대한 설명 은 &lt;a href=&quot;location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 참조 ). 참조 구현에서 Java 프로그래밍 언어 계층을 사용할 때 리턴 된 List에는이 유형의 선언을 포함하는 소스 파일의 규정되지 않은 이름 인 String이라는 하나의 요소가 포함됩니다. 다른 계층에서 반환 된 소스 이름은 해당 계층에 대해 정의 된 모든 소스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b799c087978df49d2fe6286478b6ecedece7b2a8" translate="yes" xml:space="preserve">
          <source>The returned navigable map will be serializable if the specified navigable map is serializable.</source>
          <target state="translated">지정된 탐색 가능한지도가 직렬화 가능한 경우 반환 된 탐색 가능한지도는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="63e22369ffd2f4700f3d4c6318fbd029fc94516b" translate="yes" xml:space="preserve">
          <source>The returned navigable set will be serializable if the specified navigable set is serializable.</source>
          <target state="translated">지정된 탐색 가능 세트가 직렬화 가능하면 리턴 된 탐색 가능 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a727d4e4fbf63ea3befd9b45ef8b69bf9cfb1312" translate="yes" xml:space="preserve">
          <source>The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of available bytes is most likely to be accurate immediately after this call. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine. This method makes no guarantee that write operations to this file system will succeed.</source>
          <target state="translated">반환 된 사용 가능한 바이트 수는 힌트이지만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 아닙니다. 사용 가능한 바이트 수는이 호출 직후 정확할 가능성이 높습니다. 이 가상 머신 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 부정확해질 수 있습니다. 이 방법은이 파일 시스템에 대한 쓰기 작업의 성공을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22109190c7021a569021e7447b7b84963fc23137" translate="yes" xml:space="preserve">
          <source>The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after this call. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine. This method makes no guarantee that write operations to this file system will succeed.</source>
          <target state="translated">반환 된 사용 가능한 바이트 수는 힌트이지만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는이 호출 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다. 이 방법은이 파일 시스템에 대한 쓰기 작업이 성공한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37078f56cceda1a46ec4284d20998d8403b393be" translate="yes" xml:space="preserve">
          <source>The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of usable bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this Java virtual machine.</source>
          <target state="translated">반환 된 사용 가능한 바이트 수는 힌트이지만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 사용 가능한 바이트 수는 공간 속성을 얻은 직후에 정확할 가능성이 높습니다. 이 Java 가상 머신 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9ec8ab1c6179c271d12fffbe706c3b736240a28" translate="yes" xml:space="preserve">
          <source>The returned number of unallocated bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine.</source>
          <target state="translated">반환 된 할당되지 않은 바이트 수는 힌트 일 뿐이지 만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는 공간 속성을 얻은 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4abb292a819da63fe264f4077cd386242fe657dd" translate="yes" xml:space="preserve">
          <source>The returned number of unallocated bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after this call. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine. This method makes no guarantee that write operations to this file system will succeed.</source>
          <target state="translated">반환 된 할당되지 않은 바이트 수는 힌트 일 뿐이지 만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는이 호출 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다. 이 방법은이 파일 시스템에 대한 쓰기 작업이 성공한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bf3ae18f78108540f59e74bf023c42294fa7cf2" translate="yes" xml:space="preserve">
          <source>The returned object is unmodifiable and contains the tag names of all &lt;code&gt;TIFFTag&lt;/code&gt;s in this &lt;code&gt;TIFFTagSet&lt;/code&gt; sorted into ascending order according to &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt;&lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 수정할 수 &lt;code&gt;TIFFTagSet&lt;/code&gt; &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt; &lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 오름차순으로 정렬 된이 TIFFTagSet 의 모든 &lt;code&gt;TIFFTag&lt;/code&gt; 태그 이름을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="9e796af45c9611651ce65ec6c4b30604165ccfde" translate="yes" xml:space="preserve">
          <source>The returned object is unmodifiable and contains the tag numbers of all &lt;code&gt;TIFFTag&lt;/code&gt;s in this &lt;code&gt;TIFFTagSet&lt;/code&gt; sorted into ascending order according to &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt;&lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 수정할 수 &lt;code&gt;TIFFTag&lt;/code&gt; &lt;a href=&quot;../../../../../java.base/java/lang/comparable#compareTo(T)&quot;&gt; &lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 오름차순으로 정렬 된이 &lt;code&gt;TIFFTagSet&lt;/code&gt; 의 모든 TIFFTag 태그 번호를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="492c119dd4628b39858412c60847fb3a194906f2" translate="yes" xml:space="preserve">
          <source>The returned object may be modified using ordinary &lt;a href=&quot;../util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; operations. These modifications will be visible to subprocesses started via the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. Two &lt;code&gt;ProcessBuilder&lt;/code&gt; instances always contain independent process environments, so changes to the returned map will never be reflected in any other &lt;code&gt;ProcessBuilder&lt;/code&gt; instance or the values returned by &lt;a href=&quot;system#getenv(java.lang.String)&quot;&gt;&lt;code&gt;System.getenv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 일반적인 &lt;a href=&quot;../util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 작업을 사용하여 수정할 수 있습니다 . 이러한 수정 사항은 &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 시작된 하위 프로세스에 표시됩니다 . 두 개의 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스에는 항상 독립적 인 프로세스 환경이 포함되어 있으므로 반환 된 맵의 변경 사항은 다른 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스 또는 &lt;a href=&quot;system#getenv(java.lang.String)&quot;&gt; &lt;code&gt;System.getenv&lt;/code&gt; 에서&lt;/a&gt; 반환 된 값에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c0e131d9f7c12cd49d0e3def257a8126d1849784" translate="yes" xml:space="preserve">
          <source>The returned object may be modified using ordinary &lt;a href=&quot;../util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; operations. These modifications will be visible to subprocesses started via the &lt;a href=&quot;processbuilder#start--&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. Two &lt;code&gt;ProcessBuilder&lt;/code&gt; instances always contain independent process environments, so changes to the returned map will never be reflected in any other &lt;code&gt;ProcessBuilder&lt;/code&gt; instance or the values returned by &lt;a href=&quot;system#getenv-java.lang.String-&quot;&gt;&lt;code&gt;System.getenv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 일반 &lt;a href=&quot;../util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 작업을 사용하여 수정할 수 있습니다 . 이러한 수정 사항은 &lt;a href=&quot;processbuilder#start--&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 시작된 하위 프로세스에 표시됩니다 . 두 개의 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스는 항상 독립적 인 프로세스 환경을 포함하므로 리턴 된 맵에 대한 변경 사항은 다른 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스 또는 &lt;a href=&quot;system#getenv-java.lang.String-&quot;&gt; &lt;code&gt;System.getenv&lt;/code&gt; 가&lt;/a&gt; 리턴 한 값에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10758f1a6b50ea2e6c130aeb5c0b77e0c66fbab0" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/datagramsocket&quot;&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/datagramsocket&quot;&gt; &lt;code&gt;DatagramSocket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메서드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6661a89d64621663c740fc5bd7a203767c62c2b9" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/serversocket&quot;&gt;&lt;code&gt;ServerSocket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/serversocket&quot;&gt; &lt;code&gt;ServerSocket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메소드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b4f4ca2ce4cf8222c87458553d37b2d17a03fa4b" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메소드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0472b263351c4d126d5ea013a83e7af5df81b296" translate="yes" xml:space="preserve">
          <source>The returned parameter object must be initialized via a call to &lt;code&gt;init&lt;/code&gt;, using an appropriate parameter specification or parameter encoding.</source>
          <target state="translated">리턴 된 매개 변수 오브젝트는 적절한 매개 변수 스펙 또는 매개 변수 인코딩을 사용하여 &lt;code&gt;init&lt;/code&gt; 호출을 통해 초기화되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="47dc492778d2d3b5a2a328f21d3d9313d13e099e" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/c14nmethodparameterspec&quot;&gt;&lt;code&gt;C14NMethodParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/c14nmethodparameterspec&quot;&gt; &lt;code&gt;C14NMethodParameterSpec&lt;/code&gt; &lt;/a&gt; 개체 로 형변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ddc417851bcf3ea126e833b688c0a6913e44637" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/digestmethodparameterspec&quot;&gt;&lt;code&gt;DigestMethodParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/digestmethodparameterspec&quot;&gt; &lt;code&gt;DigestMethodParameterSpec&lt;/code&gt; &lt;/a&gt; 객체 로 타입 캐스트 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83acc9ac6764336702eb89931e745c9306c55b1b" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/signaturemethodparameterspec&quot;&gt;&lt;code&gt;SignatureMethodParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/signaturemethodparameterspec&quot;&gt; &lt;code&gt;SignatureMethodParameterSpec&lt;/code&gt; &lt;/a&gt; 개체 로 형변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e366a23cd79e1859b47622e908ca1f0d6b5314" translate="yes" xml:space="preserve">
          <source>The returned parameters can be typecast to a &lt;a href=&quot;spec/transformparameterspec&quot;&gt;&lt;code&gt;TransformParameterSpec&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">반환 된 매개 변수는 &lt;a href=&quot;spec/transformparameterspec&quot;&gt; &lt;code&gt;TransformParameterSpec&lt;/code&gt; &lt;/a&gt; 개체 로 형변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4df3bd992ed9cf08b8043aa23cc9ef35cfb0d899" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 암호를 초기화하는 데 사용 된 것과 동일하거나이 암호에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 암호 구현에 의해 사용되는 기본 및 무작위 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752ffb538b7e9750a71c7c4cf9e60e4eee90c425" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this signature engine, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature engine requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 서명 엔진을 초기화하는 데 사용 된 것과 동일하거나,이 서명 엔진에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 서명 구현에서 사용되는 기본 및 무작위로 생성 된 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45bd612510ae15a9437f55deeaebac11cc09c8c" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this signature, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 서명을 초기화하는 데 사용 된 것과 동일하거나,이 서명에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 서명 구현에서 사용되는 기본 및 무작위로 생성 된 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c3309fd588c4ac6caa981d38e4c41575c42f8ec" translate="yes" xml:space="preserve">
          <source>The returned path string uses the default name &lt;a href=&quot;filesystem#getSeparator()&quot;&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/a&gt; to separate names in the path.</source>
          <target state="translated">반환 된 경로 문자열은 기본 이름 &lt;a href=&quot;filesystem#getSeparator()&quot;&gt; &lt;code&gt;separator&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로에서 이름을 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="31a706d9a79d6d8447286cc51c0dbac2857f3fb0" translate="yes" xml:space="preserve">
          <source>The returned path string uses the default name &lt;a href=&quot;filesystem#getSeparator--&quot;&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/a&gt; to separate names in the path.</source>
          <target state="translated">반환 된 경로 문자열은 기본 이름 &lt;a href=&quot;filesystem#getSeparator--&quot;&gt; &lt;code&gt;separator&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로에서 이름을 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="b0933f83db192e30cf7d1d42e8e9f97596c83f59" translate="yes" xml:space="preserve">
          <source>The returned paths are for the specified stratum (see &lt;a href=&quot;location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; for a description of strata). In the reference implementation, for strata which do not explicitly specify source path (the Java programming language stratum never does), the returned strings are the &lt;a href=&quot;#sourceNames(java.lang.String)&quot;&gt;&lt;code&gt;sourceNames(String)&lt;/code&gt;&lt;/a&gt; prefixed by the package name of this ReferenceType converted to a platform dependent path. For example, on a Windows platform, &lt;code&gt;java.lang.Thread&lt;/code&gt; would return a List containing one element: &lt;code&gt;&quot;java\lang\Thread.java&quot;&lt;/code&gt;.</source>
          <target state="translated">반환 된 경로는 지정된 계층 에 대한 것입니다 (지층에 대한 설명 은 &lt;a href=&quot;location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 참조 ). 참조 구현에서 소스 경로를 명시 적으로 지정하지 않는 계층의 경우 (Java 프로그래밍 언어 계층은 절대 지정하지 않음) 반환 된 문자열은 플랫폼 종속 경로로 변환 된이 ReferenceType의 패키지 이름 접두사가 붙은 &lt;a href=&quot;#sourceNames(java.lang.String)&quot;&gt; &lt;code&gt;sourceNames(String)&lt;/code&gt; &lt;/a&gt; 입니다. 예를 들어 Windows 플랫폼에서 &lt;code&gt;java.lang.Thread&lt;/code&gt; 는 &lt;code&gt;&quot;java\lang\Thread.java&quot;&lt;/code&gt; 요소 하나를 포함하는 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="adf31a0a552eb3e572f95b3b75985ef817599500" translate="yes" xml:space="preserve">
          <source>The returned period is immutable and thread-safe.</source>
          <target state="translated">반환 된 기간은 변경 불가능하고 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0fc1b4afe410c4184d3ee0067023a81a530b2ac3" translate="yes" xml:space="preserve">
          <source>The returned queue will be serializable if the specified queue is serializable.</source>
          <target state="translated">지정된 큐가 직렬화 가능하면 리턴 된 큐는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="94748f1f2e891952e253a00d663b435df6de9323" translate="yes" xml:space="preserve">
          <source>The returned request will control stepping only in the specified &lt;code&gt;thread&lt;/code&gt;; all other threads will be unaffected. A &lt;code&gt;size&lt;/code&gt; value of &lt;a href=&quot;steprequest#STEP_MIN&quot;&gt;&lt;code&gt;StepRequest.STEP_MIN&lt;/code&gt;&lt;/a&gt; will generate a step event each time the code index changes. It represents the smallest step size available and often maps to the instruction level. A &lt;code&gt;size&lt;/code&gt; value of &lt;a href=&quot;steprequest#STEP_LINE&quot;&gt;&lt;code&gt;StepRequest.STEP_LINE&lt;/code&gt;&lt;/a&gt; will generate a step event each time the source line changes unless line number information is not available, in which case a STEP_MIN will be done instead. For example, no line number information is available during the execution of a method that has been rendered obsolete by by a &lt;a href=&quot;../virtualmachine#redefineClasses(java.util.Map)&quot;&gt;&lt;code&gt;VirtualMachine.redefineClasses(java.util.Map&amp;lt;? extends com.sun.jdi.ReferenceType, byte[]&amp;gt;)&lt;/code&gt;&lt;/a&gt; operation. A &lt;code&gt;depth&lt;/code&gt; value of &lt;a href=&quot;steprequest#STEP_INTO&quot;&gt;&lt;code&gt;StepRequest.STEP_INTO&lt;/code&gt;&lt;/a&gt; will generate step events in any called methods. A &lt;code&gt;depth&lt;/code&gt; value of &lt;a href=&quot;steprequest#STEP_OVER&quot;&gt;&lt;code&gt;StepRequest.STEP_OVER&lt;/code&gt;&lt;/a&gt; restricts step events to the current frame or caller frames. A &lt;code&gt;depth&lt;/code&gt; value of &lt;a href=&quot;steprequest#STEP_OUT&quot;&gt;&lt;code&gt;StepRequest.STEP_OUT&lt;/code&gt;&lt;/a&gt; restricts step events to caller frames only. All depth restrictions are relative to the call stack immediately before the step takes place.</source>
          <target state="translated">반환 된 요청은 지정된 &lt;code&gt;thread&lt;/code&gt; 에서만 스테핑을 제어합니다 . 다른 모든 스레드는 영향을받지 않습니다. &lt;a href=&quot;steprequest#STEP_MIN&quot;&gt; &lt;code&gt;StepRequest.STEP_MIN&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;size&lt;/code&gt; 값은 코드 인덱스가 변경 될 때마다 단계 이벤트를 생성합니다. 사용 가능한 가장 작은 단계 크기를 나타내며 종종 지침 수준에 매핑됩니다. &lt;a href=&quot;steprequest#STEP_LINE&quot;&gt; &lt;code&gt;StepRequest.STEP_LINE&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;size&lt;/code&gt; 값은 행 번호 정보를 사용할 수없는 경우가 아니면 대신 STEP_MIN이 수행되는 경우가 아니면 소스 행이 변경 될 때마다 단계 이벤트를 생성합니다. 예를 들어, 사용자가 쓸모 없게 만든 메서드를 실행하는 동안에는 줄 번호 정보를 사용할 수 없습니다.&lt;a href=&quot;../virtualmachine#redefineClasses(java.util.Map)&quot;&gt; &lt;code&gt;VirtualMachine.redefineClasses(java.util.Map&amp;lt;? extends com.sun.jdi.ReferenceType, byte[]&amp;gt;)&lt;/code&gt; &lt;/a&gt; 작업을 확장 합니다. &lt;a href=&quot;steprequest#STEP_INTO&quot;&gt; &lt;code&gt;StepRequest.STEP_INTO&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;depth&lt;/code&gt; 값은호출 된 모든 메소드에서 단계 이벤트를 생성합니다. &lt;a href=&quot;steprequest#STEP_OVER&quot;&gt; &lt;code&gt;StepRequest.STEP_OVER&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;depth&lt;/code&gt; 값은단계 이벤트를 현재 프레임 또는 호출자 프레임으로 제한합니다. &lt;a href=&quot;steprequest#STEP_OUT&quot;&gt; &lt;code&gt;StepRequest.STEP_OUT&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;depth&lt;/code&gt; 값은단계 이벤트를 호출자 프레임으로 만 제한합니다. 모든 깊이 제한은 단계가 발생하기 직전에 호출 스택과 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="be45c831c6cb6ad3b20e650176014c1026fccd42" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">반환 된 집합에는 &lt;a href=&quot;../collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 표현식 은 본질적으로 &lt;code&gt;s&lt;/code&gt; 와 동등한 &lt;code&gt;s&lt;/code&gt; 뷰를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e3b490a0b68921e5f2d54982954ae5db0e3015e" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">리턴 된 세트는 &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동등한 순서를 갖습니다 . 식 &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;s&lt;/code&gt; 과 본질적으로 동등한 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="377684bc5b679d5593f89c67fdae0d1615f86030" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">반환 된 집합에는 &lt;a href=&quot;collections#reverseOrder(java.util.Comparator)&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일한 순서가 있습니다. &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 표현식 은 본질적으로 &lt;code&gt;s&lt;/code&gt; 와 동등한 &lt;code&gt;s&lt;/code&gt; 뷰를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3e0a450b88e9e02addbc6c115aa54b248453093" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">리턴 된 세트는 &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt; 와 동등한 순서를 갖습니다 . 식 &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;s&lt;/code&gt; 과 본질적으로 동등한 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="220883a1d6410f4ba7ef330e4aa7ccfbc79da085" translate="yes" xml:space="preserve">
          <source>The returned set is a modifiable copy of the flags.</source>
          <target state="translated">리턴 된 세트는 수정 가능한 플래그 사본입니다.</target>
        </trans-unit>
        <trans-unit id="c5cb0f1cda390591cbbfdd982f4f651a475f6f50" translate="yes" xml:space="preserve">
          <source>The returned set is a modifiable copy of the permissions.</source>
          <target state="translated">리턴 된 세트는 수정 가능한 권한의 사본입니다.</target>
        </trans-unit>
        <trans-unit id="130457322e83b65d75a40390b0669abbd4a7d5d4" translate="yes" xml:space="preserve">
          <source>The returned set is not backed by the &lt;code&gt;Properties&lt;/code&gt; object. Changes to this &lt;code&gt;Properties&lt;/code&gt; are not reflected in the set, or vice versa.</source>
          <target state="translated">리턴 된 세트는 &lt;code&gt;Properties&lt;/code&gt; 오브젝트에 의해 지원되지 않습니다 . 이 &lt;code&gt;Properties&lt;/code&gt; 대한 변경 사항 은 세트에 반영되지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="109db5fe06aff8f3e5ce1040e372e7064c0c41dd" translate="yes" xml:space="preserve">
          <source>The returned set is not backed by this &lt;code&gt;Properties&lt;/code&gt; object. Changes to this &lt;code&gt;Properties&lt;/code&gt; object are not reflected in the returned set.</source>
          <target state="translated">반환 된 집합은이 &lt;code&gt;Properties&lt;/code&gt; 개체에 의해 지원되지 않습니다 . 이 &lt;code&gt;Properties&lt;/code&gt; 개체에 대한 변경 사항 은 반환 된 집합에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47d177e63a245cb42be905e7f49ce82ba1aab77e" translate="yes" xml:space="preserve">
          <source>The returned set of associations is a snapshot of the open associations at the time that this method is invoked.</source>
          <target state="translated">반환 된 연결 집합은이 메서드가 호출 될 때 열린 연결의 스냅 샷입니다.</target>
        </trans-unit>
        <trans-unit id="3e9bbc6259b7b305420033286153988e609e2dfe" translate="yes" xml:space="preserve">
          <source>The returned set will be serializable if the specified set is serializable.</source>
          <target state="translated">지정된 세트가 직렬화 가능한 경우, 리턴 된 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6add43a3d565273146ff21959e52c46e37133f8b" translate="yes" xml:space="preserve">
          <source>The returned set will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert an element outside its range.</source>
          <target state="translated">돌려 주어진 세트는 그 범위 외의 요소를 삽입하려고 하면 (자) &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="08dbebf4ee48b0815ada6801ab8ff9946c69da0f" translate="yes" xml:space="preserve">
          <source>The returned socket is configured using the socket options established for this factory, and is set to use server mode when handshaking (see &lt;a href=&quot;sslsocket#setUseClientMode(boolean)&quot;&gt;&lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">반환 된 소켓은이 팩토리에 대해 설정된 소켓 옵션을 사용하여 구성되며 핸드 셰이 &lt;a href=&quot;sslsocket#setUseClientMode(boolean)&quot;&gt; &lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt; &lt;/a&gt; 서버 모드를 사용하도록 설정됩니다 ( SSLSocket.setUseClientMode (boolean) 참조 ).</target>
        </trans-unit>
        <trans-unit id="36ef4c7e56e059e7cc6ecb7f25266519a33c9874" translate="yes" xml:space="preserve">
          <source>The returned socket is configured using the socket options established for this factory, and is set to use server mode when handshaking (see &lt;a href=&quot;sslsocket#setUseClientMode-boolean-&quot;&gt;&lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">리턴 된 소켓은이 팩토리에 대해 설정된 소켓 옵션을 사용하여 구성되며 핸드 쉐이킹시 서버 모드를 사용하도록 설정됩니다 ( &lt;a href=&quot;sslsocket#setUseClientMode-boolean-&quot;&gt; &lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f90f95fa6a4a814b30bb64a73971367f5cea036" translate="yes" xml:space="preserve">
          <source>The returned sorted map will be serializable if the specified sorted map is serializable.</source>
          <target state="translated">지정된 정렬 맵이 직렬화 가능하면 리턴 된 정렬 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="84b2dfe035ba12d83875affd06b6d4712350f778" translate="yes" xml:space="preserve">
          <source>The returned sorted set will be serializable if the specified sorted set is serializable.</source>
          <target state="translated">지정된 정렬 세트가 직렬화 가능하면 리턴 된 정렬 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0daff3577dae1f88c6b38a7fd8e4b3abd97adeb1" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report. (For example, if it is known the array will not be further modified, specify &lt;code&gt;IMMUTABLE&lt;/code&gt;; if the array data is considered to have an an encounter order, specify &lt;code&gt;ORDERED&lt;/code&gt;). The method &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt;&lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt;&lt;/a&gt; can often be used instead, which returns a spliterator that reports &lt;code&gt;SIZED&lt;/code&gt;, &lt;code&gt;SUBSIZED&lt;/code&gt;, &lt;code&gt;IMMUTABLE&lt;/code&gt;, and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator 항상 특성 보고서 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 스플리터가보고 할 추가 특성을 제공 할 수 있습니다. 예를 들어, 배열이 더 이상 수정되지 않는 것으로 알려진 경우 &lt;code&gt;IMMUTABLE&lt;/code&gt; 을 지정 하십시오. 배열 데이터가 발생 순서로 간주되는 경우 &lt;code&gt;ORDERED&lt;/code&gt; 를 지정 하십시오. 메소드 &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt; &lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt; &lt;/a&gt; spliterator보고 그 반환 자주 대신 사용할 수 있습니다, &lt;code&gt;SIZED&lt;/code&gt; , &lt;code&gt;SUBSIZED&lt;/code&gt; , &lt;code&gt;IMMUTABLE&lt;/code&gt; 는 한 &lt;code&gt;ORDERED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e608e572bf2565a5091c6b2b59f30af46dea54ce" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report. (For example, if it is known the array will not be further modified, specify &lt;code&gt;IMMUTABLE&lt;/code&gt;; if the array data is considered to have an encounter order, specify &lt;code&gt;ORDERED&lt;/code&gt;). The method &lt;a href=&quot;arrays#spliterator(long%5B%5D,int,int)&quot;&gt;&lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt;&lt;/a&gt; can often be used instead, which returns a spliterator that reports &lt;code&gt;SIZED&lt;/code&gt;, &lt;code&gt;SUBSIZED&lt;/code&gt;, &lt;code&gt;IMMUTABLE&lt;/code&gt;, and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator 항상 특성 보고서 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 분할자가보고 할 추가 특성을 제공 할 수 있습니다. (예를 들어, 배열이 더 이상 수정되지 않는 것으로 알려진 경우 &lt;code&gt;IMMUTABLE&lt;/code&gt; 을 지정 하고 배열 데이터에 발생 순서가있는 것으로 간주되면 &lt;code&gt;ORDERED&lt;/code&gt; 를 지정 하십시오.) 방법 &lt;a href=&quot;arrays#spliterator(long%5B%5D,int,int)&quot;&gt; &lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt; &lt;/a&gt; 리포트하는 spliterator 반환 대신에 종종 사용될 수 &lt;code&gt;SIZED&lt;/code&gt; , &lt;code&gt;SUBSIZED&lt;/code&gt; , &lt;code&gt;IMMUTABLE&lt;/code&gt; 는 한 &lt;code&gt;ORDERED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f1d245446dcb633ef538a6c950f3a6bc13a27b6" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify &lt;code&gt;IMMUTABLE&lt;/code&gt; and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator은 항상 특성을보고 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 스플리터가보고 할 추가 특성을 제공 할 수 있습니다. &lt;code&gt;IMMUTABLE&lt;/code&gt; 및 &lt;code&gt;ORDERED&lt;/code&gt; 를 추가로 지정하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="9c6cec62aaea6011c796172046e0e045b666f75f" translate="yes" xml:space="preserve">
          <source>The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then be processed in parallel by multiple threads (if the access mode &lt;a href=&quot;#ACQUIRE&quot;&gt;&lt;code&gt;ACQUIRE&lt;/code&gt;&lt;/a&gt; is set). While closing the segment (see &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;) during pending concurrent execution will generally fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread is actively working on it using &lt;a href=&quot;../../../../java.base/java/util/spliterator#tryAdvance(java.util.function.Consumer)&quot;&gt;&lt;code&gt;Spliterator.tryAdvance(Consumer)&lt;/code&gt;&lt;/a&gt;; in such cases, any subsequent call to &lt;a href=&quot;../../../../java.base/java/util/spliterator#tryAdvance(java.util.function.Consumer)&quot;&gt;&lt;code&gt;Spliterator.tryAdvance(Consumer)&lt;/code&gt;&lt;/a&gt; will fail with an exception.</source>
          <target state="translated">반환 된 분할자는 세그먼트를 분리 된 하위 세그먼트로 분할 할 수 있으며, 그런 다음 여러 스레드에서 병렬로 처리 할 수 ​​있습니다 (액세스 모드 &lt;a href=&quot;#ACQUIRE&quot;&gt; &lt;code&gt;ACQUIRE&lt;/code&gt; &lt;/a&gt; 가 설정된 경우). 보류중인 동시 실행 중에 세그먼트를 닫는 동안 ( &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 참조 ) 일반적으로 예외와 함께 실패하지만 Spliterator를 얻었지만 &lt;a href=&quot;../../../../java.base/java/util/spliterator#tryAdvance(java.util.function.Consumer)&quot;&gt; &lt;code&gt;Spliterator.tryAdvance(Consumer)&lt;/code&gt; &lt;/a&gt; 사용하여 스레드가 활발하게 작업하지 않을 때 세그먼트를 닫을 수 있습니다 . 이러한 경우 &lt;a href=&quot;../../../../java.base/java/util/spliterator#tryAdvance(java.util.function.Consumer)&quot;&gt; &lt;code&gt;Spliterator.tryAdvance(Consumer)&lt;/code&gt; &lt;/a&gt; 대한 후속 호출 은 예외와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="448ee2ba55f195d0baa345b55208a1fe5ff52b70" translate="yes" xml:space="preserve">
          <source>The returned spliterator is &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 스플리터는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;약하게 일관성이&lt;/i&gt;&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f2400d7a2aaaa17fc5812d2a385fbf8098fa7b6" translate="yes" xml:space="preserve">
          <source>The returned spliterator should report the set of characteristics derived from the stream pipeline (namely the characteristics derived from the stream source spliterator and the intermediate operations). Implementations may report a sub-set of those characteristics. For example, it may be too expensive to compute the entire set for some or all possible stream pipelines.</source>
          <target state="translated">반환 된 분할자는 스트림 파이프 라인에서 파생 된 특성 집합 (즉, 스트림 소스 분할 자 및 중간 작업에서 파생 된 특성)을보고해야합니다. 구현시 이러한 특성의 하위 집합을보고 할 수 있습니다. 예를 들어 가능한 일부 또는 모든 스트림 파이프 라인에 대해 전체 세트를 계산하는 것은 너무 비쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6234e63cf95b525ef3e4e3cac2e74c567f7b62ce" translate="yes" xml:space="preserve">
          <source>The returned spliterator splits the segment according to the specified sequence layout; that is, if the supplied layout is a sequence layout whose element count is &lt;code&gt;N&lt;/code&gt;, then calling &lt;a href=&quot;../../../../java.base/java/util/spliterator#trySplit()&quot;&gt;&lt;code&gt;Spliterator.trySplit()&lt;/code&gt;&lt;/a&gt; will result in a spliterator serving approximatively &lt;code&gt;N/2&lt;/code&gt; elements (depending on whether N is even or not). As such, splitting is possible as long as &lt;code&gt;N &amp;gt;= 2&lt;/code&gt;. The spliterator returns segments that feature the same &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; as the given segment less the &lt;a href=&quot;#CLOSE&quot;&gt;&lt;code&gt;CLOSE&lt;/code&gt;&lt;/a&gt; access mode.</source>
          <target state="translated">반환 된 분할자는 지정된 시퀀스 레이아웃에 따라 세그먼트를 분할합니다. 즉, 제공된 레이아웃이 요소 수가 &lt;code&gt;N&lt;/code&gt; 인 시퀀스 레이아웃 인 경우 &lt;a href=&quot;../../../../java.base/java/util/spliterator#trySplit()&quot;&gt; &lt;code&gt;Spliterator.trySplit()&lt;/code&gt; &lt;/a&gt; 을 호출 하면 &lt;code&gt;N/2&lt;/code&gt; 개의 요소 (N이 짝수인지 여부에 따라 다름)를 제공하는 분할자가 생성됩니다 . 따라서 &lt;code&gt;N &amp;gt;= 2&lt;/code&gt; 인 한 분할이 가능합니다 . 스플리터는 &lt;a href=&quot;#CLOSE&quot;&gt; &lt;code&gt;CLOSE&lt;/code&gt; &lt;/a&gt; 액세스 모드를 제외한 지정된 세그먼트 와 동일한 &lt;a href=&quot;#access-modes&quot;&gt;액세스 모드&lt;/a&gt; 를 특징으로하는 세그먼트를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="39320309f6acb1e293c4b0f88be30f7d21cd9419" translate="yes" xml:space="preserve">
          <source>The returned stream contains a reference to an open directory. The directory is closed by closing the stream.</source>
          <target state="translated">반환 된 스트림에는 열린 디렉토리에 대한 참조가 포함됩니다. 스트림을 닫으면 디렉토리가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7b8591462e635ab93bf50430fdf54a1ccdf66f0b" translate="yes" xml:space="preserve">
          <source>The returned stream contains a reference to an open file. The file is closed by closing the stream.</source>
          <target state="translated">반환 된 스트림에는 열린 파일에 대한 참조가 포함됩니다. 스트림을 닫으면 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d2ceba9dd83dd39b4220abff8b7e79783a77866b" translate="yes" xml:space="preserve">
          <source>The returned stream contains references to one or more open directories. The directories are closed by closing the stream.</source>
          <target state="translated">반환 된 스트림에는 하나 이상의 열린 디렉토리에 대한 참조가 포함됩니다. 스트림을 닫으면 디렉토리가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="17f6fef10c7c1d7faa5f4bb6d1cad19315fbac4b" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates a &lt;a href=&quot;../../io/reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt;. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed.</source>
          <target state="translated">반환 된 스트림은 &lt;a href=&quot;../../io/reader&quot;&gt; &lt;code&gt;Reader&lt;/code&gt; 를&lt;/a&gt; 캡슐화합니다. . 파일 시스템 자원을 적시에 폐기해야하는 경우 , 스트림 조작이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 try-with-resources 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ddd602fbd78f0cc6b843db33e616208261076d4" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates a &lt;a href=&quot;directorystream&quot;&gt;&lt;code&gt;DirectoryStream&lt;/code&gt;&lt;/a&gt;. If timely disposal of file system resources is required, the &lt;code&gt;try&lt;/code&gt;-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed.</source>
          <target state="translated">리턴 된 스트림은 &lt;a href=&quot;directorystream&quot;&gt; &lt;code&gt;DirectoryStream&lt;/code&gt; 을&lt;/a&gt; 캡슐화합니다 . 파일 시스템 자원을 적시에 폐기 해야하는 경우 , 스트림 작업이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 &lt;code&gt;try&lt;/code&gt; -with-resources 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d94964406c818caac85b35a4e7cb8afabde4f74" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates one or more &lt;a href=&quot;directorystream&quot;&gt;&lt;code&gt;DirectoryStream&lt;/code&gt;&lt;/a&gt;s. If timely disposal of file system resources is required, the &lt;code&gt;try&lt;/code&gt;-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed. Operating on a closed stream will result in an &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 스트림은 하나 이상의 &lt;a href=&quot;directorystream&quot;&gt; &lt;code&gt;DirectoryStream&lt;/code&gt; 을&lt;/a&gt; 캡슐화 합니다. 파일 시스템 자원을 적시에 폐기 해야하는 경우 , 스트림 작업이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 &lt;code&gt;try&lt;/code&gt; -with-resources 구문을 사용해야합니다 . 닫힌 스트림에서 작동하면 &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="0a3477259359f64c96ff7a386ac7319ab96e368d" translate="yes" xml:space="preserve">
          <source>The returned string corresponds to the single-string representation of a Kerberos Principal name as specified in Section 2.1 of &lt;a href=&quot;http://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964&lt;/a&gt;.</source>
          <target state="translated">리턴 된 문자열은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964의&lt;/a&gt; 2.1 절에 지정된 Kerberos 프린시 펄 이름의 단일 문자열 표현에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="aeaa1ef305cb08fffd452f88478ffdf5d9519170" translate="yes" xml:space="preserve">
          <source>The returned string corresponds to the single-string representation of a Kerberos Principal name as specified in Section 2.1 of &lt;a href=&quot;https://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964&lt;/a&gt;.</source>
          <target state="translated">반환 된 문자열은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964의&lt;/a&gt; 섹션 2.1에 지정된 Kerberos Principal 이름의 단일 문자열 표현에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="26feeececce41b9d8c59910820970f32523261ba" translate="yes" xml:space="preserve">
          <source>The returned string is the unqualified name of the source file for this Location. For example, &lt;code&gt;java.lang.Thread&lt;/code&gt; would return &lt;code&gt;&quot;Thread.java&quot;&lt;/code&gt;.</source>
          <target state="translated">리턴 된 문자열은이 위치에 대한 소스 파일의 규정되지 않은 이름입니다. 예를 들어, &lt;code&gt;java.lang.Thread&lt;/code&gt; 는 &lt;code&gt;&quot;Thread.java&quot;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="039a60e7c46840b10c86b70b65de45c83c9d707d" translate="yes" xml:space="preserve">
          <source>The returned string must be &lt;a href=&quot;https://www.w3.org/TR/html52/dom.html#flow-content&quot;&gt;flow content&lt;/a&gt;, or any valid fragment of HTML code that may appear in the body of a document. There may be additional constraints, depending on how the tag is to be used in a documentation comment: for example, if the tag may be used within an inline element such as &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;, the taglet must not return a string containing block tags, like &lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">반환 된 문자열은 &lt;a href=&quot;https://www.w3.org/TR/html52/dom.html#flow-content&quot;&gt;흐름 콘텐츠&lt;/a&gt; 이거나 문서 본문에 나타날 수있는 유효한 HTML 코드 조각 이어야합니다 . 문서 주석에서 태그를 사용하는 방법에 따라 추가 제약이있을 수 있습니다. 예를 들어 태그가 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 와 같은 인라인 요소 내에서 사용될 수있는 경우 태그 렛은 문자열을 반환하지 않아야합니다. &lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 와 같은 블록 태그를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="841859c36cd0dcf425672ed5d01487176dcb8a7a" translate="yes" xml:space="preserve">
          <source>The returned string must be suitable content for a definition list, or &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt; element. It will typically be a series of pairs of &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;dd&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">반환 된 문자열은 정의 목록 또는 &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt; 요소에 적합한 콘텐츠 여야합니다 . 일반적으로 일련의 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;dd&amp;gt;&lt;/code&gt; 요소 쌍입니다 .</target>
        </trans-unit>
        <trans-unit id="f1a1f202277c175f03aecd904b2c2e11e846fece" translate="yes" xml:space="preserve">
          <source>The returned subscriber delegates its &lt;a href=&quot;httpresponse.bodysubscriber#getBody()&quot;&gt;&lt;code&gt;getBody()&lt;/code&gt;&lt;/a&gt; method to the downstream subscriber.</source>
          <target state="translated">반환 된 구독자는 &lt;a href=&quot;httpresponse.bodysubscriber#getBody()&quot;&gt; &lt;code&gt;getBody()&lt;/code&gt; &lt;/a&gt; 메서드를 다운 스트림 구독자 에게 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="65a647177496c8d5054ff3cb3925fa8f89b66ac7" translate="yes" xml:space="preserve">
          <source>The returned system identifier is always &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">반환 된 시스템 식별자는 항상 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0df4196fa6df65f0d8f0e826fb8a455f9827860" translate="yes" xml:space="preserve">
          <source>The returned value can be different from the &lt;code&gt;SecureRandomParameters&lt;/code&gt; object passed into a &lt;code&gt;getInstance&lt;/code&gt; method, but it cannot change during the lifetime of this &lt;code&gt;SecureRandom&lt;/code&gt; object.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;getInstance&lt;/code&gt; 메서드에 전달 된 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 개체 와 다를 수 있지만이 &lt;code&gt;SecureRandom&lt;/code&gt; 개체 의 수명 동안 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="655c3437b11ed617a579abf2fa9ff34b511b4b98" translate="yes" xml:space="preserve">
          <source>The returned value consists of a quote ('&quot;'), a sequence of characters corresponding to the characters of &lt;code&gt;s&lt;/code&gt;, and another quote. Characters in &lt;code&gt;s&lt;/code&gt; appear unchanged within the returned value except:</source>
          <target state="translated">반환 된 값은 &lt;code&gt;s&lt;/code&gt; 의 문자에 해당하는 일련의 문자 인 따옴표 ( ' &quot;')로 구성됩니다. 및 다른 따옴표로 구성됩니다. &lt;code&gt;s&lt;/code&gt; 의 문자는 다음을 제외하고 반환 된 값 내에서 변경되지 않은 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e492071d6dc92885ae84e7ac0ea668a268c3161b" translate="yes" xml:space="preserve">
          <source>The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of the buffer's data by the time that an invocation of this method returns.</source>
          <target state="translated">기본 오퍼레이팅 시스템이이 메소드 호출이 리턴 될 때까지 일부 버퍼 데이터를 페이징 아웃했을 수 있으므로 리턴 된 값은 보증이 아니라 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="0bbbc5f5c0326fb3e876924f2d2c9ce847035850" translate="yes" xml:space="preserve">
          <source>The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of the segment's data by the time that an invocation of this method returns.</source>
          <target state="translated">반환 된 값은 보증이 아니라 힌트입니다. 기본 운영 체제가이 메서드 호출이 반환 될 때까지 세그먼트의 일부 데이터를 페이지 아웃했을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="425df3891c9eb5df84066e4a31f4cde44028c0f6" translate="yes" xml:space="preserve">
          <source>The returned value is relying upon information from some underlying system font, and the correctness of that information is outside of AWT's control.</source>
          <target state="translated">반환 된 값은 일부 기본 시스템 글꼴의 정보에 의존하며 해당 정보의 정확성은 AWT의 제어 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="87f3edcf1a031a34eab7ff35463ec7ac1c19de38" translate="yes" xml:space="preserve">
          <source>The returned value may be unmodifiable. If it is modifiable, changing it has no effect on this ObjectName.</source>
          <target state="translated">반환 된 값을 수정할 수 없습니다. 수정 가능한 경우 변경해도이 ObjectName에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ea1bfc4ee9b99c8f427dd634732ade255abe11d" translate="yes" xml:space="preserve">
          <source>The returned value may or may not be identical to &lt;code&gt;name&lt;/code&gt;. Calling this method twice with the same parameters may return the same object or two equal but not identical objects.</source>
          <target state="translated">반환 값은 &lt;code&gt;name&lt;/code&gt; 과 같거나 같지 않을 수 있습니다 . 동일한 매개 변수를 사용하여이 메소드를 두 번 호출하면 동일한 오브젝트 또는 동일하지만 동일하지 않은 두 오브젝트를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d51a48610ecce7391c6a83d6ba1a127d5dea1ff" translate="yes" xml:space="preserve">
          <source>The returned value represents the maximum column size for the given parameter. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. 0 is returned for data types where the column size is not applicable.</source>
          <target state="translated">반환 된 값은 주어진 매개 변수의 최대 열 크기를 나타냅니다. 숫자 데이터의 경우 이것은 최대 정밀도입니다. 문자 데이터의 경우 문자 길이입니다. datetime 데이터 유형의 경우 이것은 문자열 표현의 문자 길이입니다 (초 분수 구성 요소의 최대 허용 정밀도 가정). 이진 데이터의 경우 길이 (바이트)입니다. ROWID 데이터 유형의 경우 길이 (바이트)입니다. 열 크기를 적용 할 수없는 데이터 유형에 대해서는 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="acbe0bb1e8cac70ef2ee8e36d939f9c27237d0ec" translate="yes" xml:space="preserve">
          <source>The returned var handle can be used to conveniently treat unsigned primitive data types as if they were a wider signed primitive type. For example, it is often convenient to model an</source>
          <target state="translated">반환 된 var 핸들을 사용하면 부호없는 기본 데이터 유형을 마치 더 넓은 서명 된 기본 유형 인 것처럼 편리하게 처리 할 수 ​​있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들어, 종종</target>
        </trans-unit>
        <trans-unit id="e3c26af39a02a98d0e1210295352bef1d03e4602" translate="yes" xml:space="preserve">
          <source>The returned var handle will feature the variable type &lt;code&gt;adaptedType&lt;/code&gt;, and the same access coordinates, the same access modes (see &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode&quot;&gt;&lt;code&gt;VarHandle.AccessMode&lt;/code&gt;&lt;/a&gt;, and the same atomic access guarantees, as those featured by the &lt;code&gt;target&lt;/code&gt; var handle.</source>
          <target state="translated">반환 된 var 핸들은 &lt;code&gt;adaptedType&lt;/code&gt; 변수 유형 , 동일한 액세스 좌표, 동일한 액세스 모드 ( &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode&quot;&gt; &lt;code&gt;VarHandle.AccessMode&lt;/code&gt; &lt;/a&gt; 참조 ) 및 &lt;code&gt;target&lt;/code&gt; var 핸들이 특징으로하는 것과 동일한 원자 적 액세스 보장을 특징으로합니다 .</target>
        </trans-unit>
        <trans-unit id="f40fbf63a5d2b277e35cf6ac3daf6ae7ec5474ac" translate="yes" xml:space="preserve">
          <source>The returned versions remain available and valid for the lifetime of the application. A dynamic provider may increase the set of versions as more data becomes available.</source>
          <target state="translated">반환 된 버전은 응용 프로그램 수명 동안 유효하고 유효합니다. 더 많은 데이터를 사용할 수있게되면 동적 공급자가 버전 집합을 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37fa82a55b240bd660f3e3d8cef39a1191e27f3f" translate="yes" xml:space="preserve">
          <source>The returned zone IDs remain available and valid for the lifetime of the application. A dynamic provider may increase the set of IDs as more data becomes available.</source>
          <target state="translated">반환 된 영역 ID는 응용 프로그램 수명 동안 사용 가능하고 유효합니다. 더 많은 데이터를 사용할 수있게되면 동적 공급자가 ID 집합을 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce5b7000f5b21a055cbac4854384a1e8094660e0" translate="yes" xml:space="preserve">
          <source>The returns a normalized &lt;code&gt;ZoneId&lt;/code&gt; that can be used in place of this ID. The result will have &lt;code&gt;ZoneRules&lt;/code&gt; equivalent to those returned by this object, however the ID returned by &lt;code&gt;getId()&lt;/code&gt; may be different.</source>
          <target state="translated">이 ID 대신 사용할 수 있는 정규화 된 &lt;code&gt;ZoneId&lt;/code&gt; 를 반환합니다 . 결과는 이 객체가 리턴 한 것과 동일한 &lt;code&gt;ZoneRules&lt;/code&gt; 를 가지지 만 &lt;code&gt;getId()&lt;/code&gt; 가 리턴 한 ID는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36bbd913f2a35dc1f4e96953ef2e235b576a9f17" translate="yes" xml:space="preserve">
          <source>The reverberation parameters provided by &lt;code&gt;ReverbType&lt;/code&gt; consist of the delay time and intensity of early reflections, the delay time and intensity of late reflections, and an overall decay time. Early reflections are the initial individual low-order reflections of the direct signal off the surfaces in the room. The late Reflections are the dense, high-order reflections that characterize the room's reverberation. The delay times for the start of these two reflection types give the listener a sense of the overall size and complexity of the room's shape and contents. The larger the room, the longer the reflection delay times. The early and late reflections' intensities define the gain (in decibels) of the reflected signals as compared to the direct signal. These intensities give the listener an impression of the absorptive nature of the surfaces and objects in the room. The decay time defines how long the reverberation takes to exponentially decay until it is no longer perceptible (&quot;effective zero&quot;). The larger and less absorbent the surfaces, the longer the decay time.</source>
          <target state="translated">에 의해 제공되는 잔향 파라미터 &lt;code&gt;ReverbType&lt;/code&gt; 이초기 반사의 지연 시간 및 강도, 늦은 반사의 지연 시간 및 강도 및 전체 감쇠 시간으로 구성됩니다. 초기 반사는 실내 표면에서 직접 신호의 초기 개별 하위 반사입니다. 늦은 반사는 방의 잔향을 특징 짓는 조밀하고 고차 반사입니다. 이 두 가지 반사 유형의 시작에 대한 지연 시간은 청취자에게 방의 모양과 내용의 전체 크기와 복잡성을 감지합니다. 방이 클수록 반사 지연 시간이 길어집니다. 초기 및 후기 반사 강도는 직접 신호와 비교하여 반사 된 신호의 게인 (데시벨)을 정의합니다. 이러한 강도는 청취자에게 방의 표면과 물체의 흡수성에 대한 인상을줍니다.감쇠 시간은 잔향이 더 이상 감지 할 수 없을 때까지 ( &quot;유효 제로&quot;) 지수 적으로 감쇠하는 데 걸리는 시간을 정의합니다. 표면의 흡수가 클수록 감쇠 시간이 길어집니다.</target>
        </trans-unit>
        <trans-unit id="b9b984f130a384b4996712c3a39651b3107b8463" translate="yes" xml:space="preserve">
          <source>The reverberation parameters provided by &lt;code&gt;ReverbType&lt;/code&gt; consist of the delay time and intensity of early reflections, the delay time and intensity of late reflections, and an overall decay time. Early reflections are the initial individual low-order reflections of the direct signal off the surfaces in the room. The late reflections are the dense, high-order reflections that characterize the room's reverberation. The delay times for the start of these two reflection types give the listener a sense of the overall size and complexity of the room's shape and contents. The larger the room, the longer the reflection delay times. The early and late reflections' intensities define the gain (in decibels) of the reflected signals as compared to the direct signal. These intensities give the listener an impression of the absorptive nature of the surfaces and objects in the room. The decay time defines how long the reverberation takes to exponentially decay until it is no longer perceptible (&quot;effective zero&quot;). The larger and less absorbent the surfaces, the longer the decay time.</source>
          <target state="translated">&lt;code&gt;ReverbType&lt;/code&gt; 에서 제공하는 잔향 매개 변수지연 시간과 초기 반사의 강도, 지연 시간과 후기 반사의 강도, 전체 감쇠 시간으로 구성됩니다. 초기 반사는 실내 표면에서 직접 신호의 초기 개별 저차 반사입니다. 후기 반사는 방의 잔향을 특징 짓는 고밀도의 고차 반사입니다. 이 두 가지 반사 유형의 시작에 대한 지연 시간은 청취자에게 방의 모양과 내용의 전체적인 크기와 복잡성에 대한 감각을 제공합니다. 공간이 클수록 반사 지연 시간이 길어집니다. 초기 및 후기 반사의 강도는 직접 신호와 비교하여 반사 된 신호의 이득 (데시벨 단위)을 정의합니다. 이러한 강도는 청취자에게 실내 표면과 물체의 흡수 특성에 대한 인상을줍니다.감쇠 시간은 잔향이 더 이상 인식 할 수 없을 때까지 기하 급수적으로 감쇠하는 데 걸리는 시간을 정의합니다 ( &quot;유효 제로&quot;). 표면이 크고 흡수성이 적을수록 붕괴 시간이 길어집니다.</target>
        </trans-unit>
        <trans-unit id="2c7630f4923d39844ce7c44d0bac8d9004f68f3b" translate="yes" xml:space="preserve">
          <source>The reverse mapping is illustrated by the following change to the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface:</source>
          <target state="translated">리버스 맵핑은 &lt;code&gt;ModuleMXBean&lt;/code&gt; 인터페이스 에 대한 다음 변경으로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="4492356e6ba71c3c852cf9939e4f74a8d7a573fe" translate="yes" xml:space="preserve">
          <source>The revocation status of the certificate could not be determined.</source>
          <target state="translated">인증서의 해지 상태를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="119ef6d6012154c68b97d88f0635440451102e2a" translate="yes" xml:space="preserve">
          <source>The right inset of the border.</source>
          <target state="translated">테두리의 오른쪽 삽입.</target>
        </trans-unit>
        <trans-unit id="898927d0724755ab7db22d60f2744e42ca622381" translate="yes" xml:space="preserve">
          <source>The right or bottom component.</source>
          <target state="translated">오른쪽 또는 아래쪽 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="315fe5d039365e7227ec2a4b72b363b039df2bd0" translate="yes" xml:space="preserve">
          <source>The root class from which all event state objects shall be derived.</source>
          <target state="translated">모든 이벤트 상태 객체가 파생되는 루트 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="f75abe063c2e29766eb9c4fdf22b1d6554824455" translate="yes" xml:space="preserve">
          <source>The root event class for all AWT events.</source>
          <target state="translated">모든 AWT 이벤트에 대한 루트 이벤트 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7d1ec967c823196dca7258196b828781578926c4" translate="yes" xml:space="preserve">
          <source>The root event class for all AWT events. This class and its subclasses supersede the original java.awt.Event class. Subclasses of this root AWTEvent class defined outside of the java.awt.event package should define event ID values greater than the value defined by RESERVED_ID_MAX.</source>
          <target state="translated">모든 AWT 이벤트에 대한 루트 이벤트 클래스입니다. 이 클래스와 그 서브 클래스는 원래 java.awt.Event 클래스를 대체합니다. java.awt.event 패키지 외부에 정의 된이 루트 AWTEvent 클래스의 서브 클래스는 RESERVED_ID_MAX에 정의 된 값보다 큰 이벤트 ID 값을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8aa66cdd224b61725fb7c7f0951cf9aec6e9c9d4" translate="yes" xml:space="preserve">
          <source>The root event class for all component-level input events.</source>
          <target state="translated">모든 구성 요소 수준 입력 이벤트에 대한 루트 이벤트 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1b9b7f573454243c391475013425ee8ac3d59559" translate="yes" xml:space="preserve">
          <source>The root event class for all component-level input events. Input events are delivered to listeners before they are processed normally by the source where they originated. This allows listeners and component subclasses to &quot;consume&quot; the event so that the source will not process them in their default manner. For example, consuming mousePressed events on a Button component will prevent the Button from being activated.</source>
          <target state="translated">모든 구성 요소 수준 입력 이벤트에 대한 루트 이벤트 클래스입니다. 입력 이벤트는 시작된 소스에서 정상적으로 처리되기 전에 리스너에게 전달됩니다. 이를 통해 리스너와 컴포넌트 서브 클래스가 이벤트를 &quot;소비&quot;할 수 있으므로 소스가 기본 방식으로 이벤트를 처리하지 않습니다. 예를 들어 Button 구성 요소에서 mousePressed 이벤트를 사용하면 Button이 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e57f0a87b56114c25a3425b649a0fc72c9816ae3" translate="yes" xml:space="preserve">
          <source>The root interface in the</source>
          <target state="translated">의 루트 인터페이스</target>
        </trans-unit>
        <trans-unit id="d09865ec5ef96bb1232174ca8eb33da20d24915d" translate="yes" xml:space="preserve">
          <source>The root is a leaf node</source>
          <target state="translated">루트는 리프 노드입니다.</target>
        </trans-unit>
        <trans-unit id="72cdacd0ec76595acc856611a3b1130c6dda01a1" translate="yes" xml:space="preserve">
          <source>The root is collapsed</source>
          <target state="translated">뿌리가 무너져</target>
        </trans-unit>
        <trans-unit id="59bb7a92b878735bfc6bdf6731b3391ad71122f8" translate="yes" xml:space="preserve">
          <source>The root node has a node name of the empty string (&quot;&quot;). Every other node has an arbitrary node name, specified at the time it is created. The only restrictions on this name are that it cannot be the empty string, and it cannot contain the slash character ('/').</source>
          <target state="translated">루트 노드에는 빈 문자열 ( &quot;&quot;)의 노드 이름이 있습니다. 다른 모든 노드에는 생성시 지정된 임의의 노드 이름이 있습니다. 이 이름에 대한 유일한 제한 사항은 빈 문자열이 될 수 없으며 슬래시 문자 ( '/')를 포함 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c4a2a95c5adac20299823e2ab805439c46a7560" translate="yes" xml:space="preserve">
          <source>The root node has an absolute path name of &lt;code&gt;&quot;/&quot;&lt;/code&gt;. Children of the root node have absolute path names of &lt;code&gt;&quot;/&quot; + &lt;/code&gt;</source>
          <target state="translated">루트 노드의 절대 경로 이름은 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 입니다. 루트 노드의 자식에는 절대 경로 이름이 &lt;code&gt;&quot;/&quot; + &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d033ca267a4e43656fa30a33c122a68a94a7f29" translate="yes" xml:space="preserve">
          <source>The root node of the &lt;code&gt;NodeIterator&lt;/code&gt;, as specified when it was created.</source>
          <target state="translated">생성시 지정된 &lt;code&gt;NodeIterator&lt;/code&gt; 의 루트 노드입니다 .</target>
        </trans-unit>
        <trans-unit id="d6f015d10efdbb0ad4a1e372a60c869566bb49e0" translate="yes" xml:space="preserve">
          <source>The root object is completely restored when all of its fields and the objects it references are completely restored. At this point the object validation callbacks are executed in order based on their registered priorities. The callbacks are registered by objects (in the readObject special methods) as they are individually restored.</source>
          <target state="translated">루트 오브젝트는 모든 필드와 참조하는 오브젝트가 완전히 복원되면 완전히 복원됩니다. 이 시점에서 객체 유효성 검사 콜백은 등록 된 우선 순위에 따라 순서대로 실행됩니다. 콜백은 개별적으로 복원 될 때 객체 (readObject 특수 메소드에서)에 의해 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="a2dd63def1d3b47ca894c952456612a156d812ba" translate="yes" xml:space="preserve">
          <source>The row header child.</source>
          <target state="translated">행 헤더 하위입니다.</target>
        </trans-unit>
        <trans-unit id="7abd29b02efd947317ce37795d7811a15d2cbbad" translate="yes" xml:space="preserve">
          <source>The row header child. Default is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">행 헤더 하위입니다. 기본값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2605996690cb3e7a1bcd3ac39232dc16f382f39c" translate="yes" xml:space="preserve">
          <source>The row header, if present and visible, gets its preferred width and the viewport's height.</source>
          <target state="translated">행 헤더가 있고 보이는 경우 선호하는 너비와 뷰포트의 높이를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="368a0506317221347890aff306183d4c221ad4af" translate="yes" xml:space="preserve">
          <source>The rule is a &lt;code&gt;CSSCharsetRule&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;CSSCharsetRule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="377aa5ac1c817533652bfbc40c05fc01592b6213" translate="yes" xml:space="preserve">
          <source>The rule is a &lt;code&gt;CSSFontFaceRule&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;CSSFontFaceRule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52291a8aa5284cca277c8cdbd32533837ec40b6c" translate="yes" xml:space="preserve">
          <source>The rule is a &lt;code&gt;CSSImportRule&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;CSSImportRule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fbd8e0d4e219d1f2eba921548f6799cf70cf769d" translate="yes" xml:space="preserve">
          <source>The rule is a &lt;code&gt;CSSMediaRule&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;CSSMediaRule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4221ce3291c07892e72179b20d969dff2727a78e" translate="yes" xml:space="preserve">
          <source>The rule is a &lt;code&gt;CSSPageRule&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;CSSPageRule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b4530f91d2c77e8e183455a252d4df7dbf8b891" translate="yes" xml:space="preserve">
          <source>The rule is a &lt;code&gt;CSSStyleRule&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;CSSStyleRule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63c0c64e3398dc278a079fe0a4f79c79410410b6" translate="yes" xml:space="preserve">
          <source>The rule is a &lt;code&gt;CSSUnknownRule&lt;/code&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;CSSUnknownRule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="638fc291740e16e3557281ff224cfb954c40e4a5" translate="yes" xml:space="preserve">
          <source>The rules about the first class defined in a package determining the set of certificates for the package, and the restrictions on class names are identical to those specified in the documentation for &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-java.security.ProtectionDomain-&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지에 대한 인증서 세트를 결정하는 패키지에 정의 된 첫 번째 클래스에 대한 규칙 및 클래스 이름에 대한 제한은 &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-java.security.ProtectionDomain-&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 지정된 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c634f0f52823012e70f8192869edd96115163537" translate="yes" xml:space="preserve">
          <source>The rules about the first class defined in a package determining the set of certificates for the package, the restrictions on class names, and the defined package of the class are identical to those specified in the documentation for &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지에 대한 인증서 집합, 클래스 이름에 대한 제한 사항 및 클래스의 정의 된 패키지를 결정하는 패키지에 정의 된 첫 번째 클래스에 대한 규칙은 &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 지정된 규칙과 동일합니다. , int, ProtectionDomain) .</target>
        </trans-unit>
        <trans-unit id="6d45a10a6e24eaa7c3cdfde29bd66f6b11f5bc37" translate="yes" xml:space="preserve">
          <source>The rules are loaded via &lt;a href=&quot;zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt; using a &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;. The same rules may be shared internally between multiple zone IDs.</source>
          <target state="translated">규칙은 &lt;a href=&quot;zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 를 통해로드됩니다 . 여러 구역 ID간에 ​​동일한 규칙이 내부적으로 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7d29710bebc6dfb854d9319d167bdaa66f76644" translate="yes" xml:space="preserve">
          <source>The rules are stored as named styles, and other information is stored to translate the context of an element to a rule quickly. The following code fragment will display the named styles, and therefore the CSS rules contained.</source>
          <target state="translated">규칙은 명명 된 스타일로 저장되고 다른 정보는 요소의 컨텍스트를 규칙으로 빠르게 변환하기 위해 저장됩니다. 다음 코드 조각은 명명 된 스타일을 표시하므로 CSS 규칙이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4c558d54ff2e89b5ae0559dc27450ddadbb740a9" translate="yes" xml:space="preserve">
          <source>The rules are supplied by &lt;a href=&quot;zone/zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt;. An advanced provider may support dynamic updates to the rules without restarting the Java Runtime. If so, then the result of this method may change over time. Each individual call will be still remain thread-safe.</source>
          <target state="translated">규칙은 &lt;a href=&quot;zone/zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; 에서&lt;/a&gt; 제공합니다 . 고급 공급자는 Java 런타임을 다시 시작하지 않고도 규칙에 대한 동적 업데이트를 지원할 수 있습니다. 그렇다면이 방법의 결과는 시간이 지남에 따라 변경 될 수 있습니다. 각 개별 통화는 여전히 스레드 안전 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1bccb89406bfb2d00bc457815b4e62d2470b7af9" translate="yes" xml:space="preserve">
          <source>The rules defining how the zone offset varies for a single time-zone.</source>
          <target state="translated">단일 시간대에 대한 영역 오프셋의 변화를 정의하는 규칙.</target>
        </trans-unit>
        <trans-unit id="1b49d1af7b23bfa9889a2696229a5d15447e0c34" translate="yes" xml:space="preserve">
          <source>The rules for &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; collectively define the notion of a &lt;em&gt;getter&lt;/em&gt;. The rule for &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; defines the notion of a &lt;em&gt;setter&lt;/em&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 하고 &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 집합 적 개념 정의 &lt;em&gt;게터를&lt;/em&gt; . 의 규칙 &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; a의 개념 정의 &lt;em&gt;세터&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="23679fbbad04df1e812f689c70ce1d6ec4726cea" translate="yes" xml:space="preserve">
          <source>The rules for addition add the number of week-based-years to the existing value for the week-based-year field retaining the week-of-week-based-year and day-of-week, unless the week number it too large for the target year. In that case, the week is set to the last week of the year with the same day-of-week.</source>
          <target state="translated">더하기 규칙은 주 번호가 너무 크지 않은 한 주별 요일 및 요일을 유지하는 주별 필드의 기존 값에 요일 수를 추가합니다. 목표 연도. 이 경우주는 같은 요일을 사용하여 마지막 주로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe755e8390c62eea10e1546677bdab04050afb0" translate="yes" xml:space="preserve">
          <source>The rules for addition add the number of week-based-years to the existing value for the week-based-year field. If the resulting week-based-year only has 52 weeks, then the date will be in week 1 of the following week-based-year.</source>
          <target state="translated">추가 규칙은 주별 연도 수를 주별 연도 필드의 기존 값에 추가합니다. 결과 주별 연도에 52 주만있는 경우 날짜는 다음 주 기반 연도의 1 주일입니다.</target>
        </trans-unit>
        <trans-unit id="b8227871731be6c3964a85ded8d67582566b32f1" translate="yes" xml:space="preserve">
          <source>The rules for using quotes within message format patterns unfortunately have shown to be somewhat confusing. In particular, it isn't always obvious to localizers whether single quotes need to be doubled or not. Make sure to inform localizers about the rules, and tell them (for example, by using comments in resource bundle source files) which strings will be processed by &lt;code&gt;MessageFormat&lt;/code&gt;. Note that localizers may need to use single quotes in translated strings where the original version doesn't have them.</source>
          <target state="translated">불행히도 메시지 형식 패턴 내에서 따옴표를 사용하는 규칙은 다소 혼란스러운 것으로 나타났습니다. 특히 작은 따옴표를 두 배로 늘릴 필요가 있는지 여부는 로컬 라이저에게 분명하지 않습니다. 로컬 라이저에게 규칙에 대해 알리고 (예를 들어, 자원 번들 소스 파일에 주석을 사용하여) &lt;code&gt;MessageFormat&lt;/code&gt; 에서 처리 할 문자열을 알려 주십시오. 로컬 라이저는 번역본에 작은 따옴표를 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38de80f84a46f228ca25c1f0d5e10459bf313f19" translate="yes" xml:space="preserve">
          <source>The rules model all the historic and future transitions for a time-zone. &lt;a href=&quot;zoneoffsettransition&quot;&gt;&lt;code&gt;ZoneOffsetTransition&lt;/code&gt;&lt;/a&gt; is used for known transitions, typically historic. &lt;a href=&quot;zoneoffsettransitionrule&quot;&gt;&lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt;&lt;/a&gt; is used for future transitions that are based on the result of an algorithm.</source>
          <target state="translated">규칙은 시간대에 대한 모든 과거 및 미래 전환을 모델링합니다. &lt;a href=&quot;zoneoffsettransition&quot;&gt; &lt;code&gt;ZoneOffsetTransition&lt;/code&gt; &lt;/a&gt; 은 일반적으로 기록 된 알려진 전환에 사용됩니다. &lt;a href=&quot;zoneoffsettransitionrule&quot;&gt; &lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt; &lt;/a&gt; 은 알고리즘 결과를 기반으로하는 향후 전환에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dca1ae5cccdb05f3a9c9df600b491c9af1bbd005" translate="yes" xml:space="preserve">
          <source>The rules on special characters and quoting apply regardless of which constructor is used to make an ObjectName.</source>
          <target state="translated">특수 문자 및 인용에 대한 규칙은 ObjectName을 만드는 데 사용되는 생성자에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1083994538afe151cee646e2eddf1109ecd48eef" translate="yes" xml:space="preserve">
          <source>The rules provide the functionality associated with a time-zone, such as finding the offset for a given instant or local date-time.</source>
          <target state="translated">규칙은 특정 인스턴트 또는 현지 날짜-시간의 오프셋 찾기와 같은 시간대와 관련된 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a48b9196407480649d1d001e180f9ae21afeae3" translate="yes" xml:space="preserve">
          <source>The rules used to interpret an &lt;code&gt;ObservedAttribute&lt;/code&gt; like &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; are as follows. Suppose the string is</source>
          <target state="translated">&lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; 와 같은 &lt;code&gt;ObservedAttribute&lt;/code&gt; 를 해석하는 데 사용되는 규칙 은 다음과 같습니다. 문자열이</target>
        </trans-unit>
        <trans-unit id="b9da9e1a0bb979727268d68de18fe949fd2aa76a" translate="yes" xml:space="preserve">
          <source>The rules will always return this offset when queried. The implementation class is immutable, thread-safe and serializable.</source>
          <target state="translated">규칙은 쿼리시 항상이 오프셋을 반환합니다. 구현 클래스는 변경 불가능하고 스레드로부터 안전하며 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3470726a7bfc514d0ba03c927d548da38eafa9b5" translate="yes" xml:space="preserve">
          <source>The runnable method for this class.</source>
          <target state="translated">이 클래스의 실행 가능 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="a744db65793d8a5bd6e364f10507f38a106bc516" translate="yes" xml:space="preserve">
          <source>The runnable method for this class. This will produce an image using the current RenderableImage and RenderContext and send it to all the ImageConsumer currently registered with this class.</source>
          <target state="translated">이 클래스의 실행 가능 메서드입니다. 그러면 현재 RenderableImage 및 RenderContext를 사용하여 이미지를 생성하고이 클래스에 현재 등록 된 모든 ImageConsumer로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="033cb38b43d17b8786bafc897bec4b3c4ae8e783" translate="yes" xml:space="preserve">
          <source>The sRGB color space defined at &lt;a href=&quot;http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html&quot;&gt; http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html &lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html&quot;&gt;http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html에&lt;/a&gt; 정의 된 sRGB 색 공간 .</target>
        </trans-unit>
        <trans-unit id="d2e3c9fbb81bbccde31fafa3b8f93c84d7d348af" translate="yes" xml:space="preserve">
          <source>The sRGB color space defined at &lt;a href=&quot;https://www.w3.org/pub/WWW/Graphics/Color/sRGB.html&quot;&gt; http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/pub/WWW/Graphics/Color/sRGB.html&quot;&gt;http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html에&lt;/a&gt; 정의 된 sRGB 색상 공간 .</target>
        </trans-unit>
        <trans-unit id="a0b7df0e9c02bba95c1b1a33d5e13601bd0ce3f8" translate="yes" xml:space="preserve">
          <source>The same call site may be used in several places at once.</source>
          <target state="translated">동일한 통화 사이트를 한 번에 여러 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfba385507e5c958ec5cdd390b4ae7ee0ff23620" translate="yes" xml:space="preserve">
          <source>The same conversions are allowed as for &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandle.asType&lt;/code&gt;&lt;/a&gt;, and some additional conversions are also applied if those conversions fail. Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied if possible, before or instead of any conversions done by &lt;code&gt;asType&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandle.asType&lt;/code&gt; &lt;/a&gt; 과 동일한 변환이 허용되며 이러한 변환이 실패 할 경우 일부 추가 변환도 적용됩니다. 유형 &lt;em&gt;T0&lt;/em&gt; , &lt;em&gt;T1이&lt;/em&gt; 주어지면 가능한 경우 &lt;code&gt;asType&lt;/code&gt; 에 의해 수행 된 변환 전이나 대신 다음 변환 중 하나가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="28bec6c576b1271de1ae3d70fc04df24e271a729" translate="yes" xml:space="preserve">
          <source>The same conversions are allowed as for &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;MethodHandle.asType&lt;/code&gt;&lt;/a&gt;, and some additional conversions are also applied if those conversions fail. Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied if possible, before or instead of any conversions done by &lt;code&gt;asType&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;MethodHandle.asType&lt;/code&gt; &lt;/a&gt; 과 동일한 변환이 허용되며 이러한 변환이 실패하면 일부 추가 변환도 적용됩니다. &lt;em&gt;T0&lt;/em&gt; , &lt;em&gt;T1&lt;/em&gt; 유형이 주어지면 가능한 경우 &lt;code&gt;asType&lt;/code&gt; 으로 수행되는 변환 전에 또는 대신 다음 변환 중 하나가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6ab80d33fa4b7f4a321447e169ab216836d5a87" translate="yes" xml:space="preserve">
          <source>The same example, dropping arguments and using combinators:</source>
          <target state="translated">동일한 예, 인수를 삭제하고 결합자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3156cf800cbaf487594e90d4f19f68e8ba277657" translate="yes" xml:space="preserve">
          <source>The same listener object may be added more than once, and will be called as many times as it is added. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is taken.</source>
          <target state="translated">동일한 리스너 객체는 두 번 이상 추가 될 수 있으며 추가 된 횟수만큼 호출됩니다. &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="791680086f6d9e78094100fb9300338027ea15fa" translate="yes" xml:space="preserve">
          <source>The same naming conventions are applied to the methods in an MXBean as in a Standard MBean:</source>
          <target state="translated">표준 MBean에서와 동일한 이름 지정 규칙이 MXBean의 메소드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="681f3cced20ba9e0fb93240854ee9634fa1a6146" translate="yes" xml:space="preserve">
          <source>The same output can be generated with this code, which uses a regular expression to parse all four tokens at once:</source>
          <target state="translated">이 코드를 사용하여 동일한 출력을 생성 할 수 있습니다. 정규식을 사용하여 4 개의 토큰을 한 번에 모두 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="1aca9034c5ce7f0103f2b633705ed622da3b779f" translate="yes" xml:space="preserve">
          <source>The same principle holds true for setting layout managers, removing components, listing children, etc. All these methods are invoked on the &lt;code&gt;contentPane&lt;/code&gt; instead of on the &lt;code&gt;JRootPane&lt;/code&gt;.</source>
          <target state="translated">레이아웃 관리자 설정, 구성 요소 제거, 자식 나열 등에 대해서도 동일한 원칙이 적용됩니다. 이러한 모든 메서드는 &lt;code&gt;JRootPane&lt;/code&gt; 대신 &lt;code&gt;contentPane&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7706c997f0206204d48e6784227fbc2dcd70a39c" translate="yes" xml:space="preserve">
          <source>The same rules are used for locating the configuration properties as are used at startup. So normally the logging properties will be re-read from the same file that was used at startup.</source>
          <target state="translated">시작시 사용되는 것과 동일한 규칙이 구성 특성을 찾는 데 사용됩니다. 따라서 일반적으로 로깅 특성은 시작시 사용한 동일한 파일에서 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="40c696d758a9065648ff0c79befb43bf73945edb" translate="yes" xml:space="preserve">
          <source>The same value</source>
          <target state="translated">같은 가치</target>
        </trans-unit>
        <trans-unit id="457dd191617eea60f8880ece3469c77e1ea4e638" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.1, with all elements divided by 2.</source>
          <target state="translated">모든 요소를 ​​2로 나눈 JPEG 사양 표 K.1에 제공된 샘플 색차 양자화 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="66abdaa3d456aeedbf328a69ececa50ab9fd015c" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.1, with all elements divided by 2. According to the specification, these values produce &quot;very good&quot; quality output. This is the table usually used for &quot;visually lossless&quot; encoding, and is the default chrominance table used if the default tables and quality settings are used.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 색차 양자화 테이블은 모든 요소를 ​​2로 나눈 값입니다. 사양에 따라이 값은 &quot;매우 우수한&quot;품질 출력을 생성합니다. 이 테이블은 일반적으로 &quot;시각적 손실없는&quot;인코딩에 사용되는 테이블이며 기본 테이블 및 품질 설정을 사용하는 경우 사용되는 기본 색차 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="b5e23252dc7982b61ec60d6fa4b1c02b4d854c18" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.2.</source>
          <target state="translated">JPEG 사양, 표 K.2에 제공된 샘플 색차 양자화 테이블.</target>
        </trans-unit>
        <trans-unit id="1cb7bb906bae31a02cfce6b8aa3fb45b84e3040c" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.2. According to the specification, these values produce &quot;good&quot; quality output.</source>
          <target state="translated">JPEG 사양, 표 K.2에 주어진 샘플 색차 양자화 테이블. 사양에 따르면이 값은 &quot;양호한&quot;품질 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="25c651e5098644d6cd24f42dc03c0a707b13d70d" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1, with all elements divided by 2.</source>
          <target state="translated">모든 요소를 ​​2로 나눈 JPEG 사양, 표 K.1에 제공된 샘플 휘도 양자화 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="e37dceb33c264c204dc116d8ce75114c90f4c7a3" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1, with all elements divided by 2. According to the specification, these values produce &quot;very good&quot; quality output. This is the table usually used for &quot;visually lossless&quot; encoding, and is the default luminance table used if the default tables and quality settings are used.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 휘도 양자화 테이블은 모든 요소를 ​​2로 나눈 값입니다. 사양에 따라이 값은 &quot;매우 우수한&quot;품질 출력을 생성합니다. 이 테이블은 일반적으로 &quot;시각적 손실없는&quot;인코딩에 사용되는 테이블이며 기본 테이블 및 품질 설정을 사용하는 경우 사용되는 기본 광도 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="d0b62fba0a5289bbc7385bf5f89b4ca6d49b2768" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1.</source>
          <target state="translated">JPEG 사양, 표 K.1에 제공된 샘플 휘도 양자화 표.</target>
        </trans-unit>
        <trans-unit id="41d6745b125ca8d196d6a79815800d21e82cdffb" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1. According to the specification, these values produce &quot;good&quot; quality output.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 휘도 양자화 테이블. 사양에 따르면이 값은 &quot;양호한&quot;품질 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b999ec10517f908ef6af8dfcfecb7806f54e48fb" translate="yes" xml:space="preserve">
          <source>The scale of the returned &lt;code&gt;BigDecimal&lt;/code&gt; will be the number of digits in the fraction, or zero if the string contains no decimal point, subject to adjustment for any exponent; if the string contains an exponent, the exponent is subtracted from the scale. The value of the resulting scale must lie between &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; and &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, inclusive.</source>
          <target state="translated">리턴 된 &lt;code&gt;BigDecimal&lt;/code&gt; 의 스케일은 분수의 자릿수이거나 문자열에 소수점이없는 경우 0이됩니다. 지수에 따라 조정됩니다. 문자열에 지수가 포함되어 있으면 지수에서 지수를 뺍니다. 결과 스케일의 값은 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; ~ &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 사이 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="7396cf813336a30d0a1bab52aed3246ae5a6aefb" translate="yes" xml:space="preserve">
          <source>The scanner can also use delimiters other than whitespace. This example reads several items in from a string:</source>
          <target state="translated">스캐너는 공백 이외의 구분 기호를 사용할 수도 있습니다. 이 예제는 문자열에서 여러 항목을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a4947ea8b0c611076ba187f044654968e3ab9ec3" translate="yes" xml:space="preserve">
          <source>The scheduling policy of StampedLock does not consistently prefer readers over writers or vice versa. All &quot;try&quot; methods are best-effort and do not necessarily conform to any scheduling or fairness policy. A zero return from any &quot;try&quot; method for acquiring or converting locks does not carry any information about the state of the lock; a subsequent invocation may succeed.</source>
          <target state="translated">StampedLock의 스케쥴링 정책은 독자보다 독자를 선호하지 않으며 그 반대도 마찬가지입니다. 모든 &quot;시도&quot;방법은 최선의 노력이며 일정이나 공정성 정책을 반드시 준수하지는 않습니다. 잠금을 획득하거나 변환하기위한 &quot;시도&quot;방법에서 0을 반환해도 잠금 상태에 대한 정보는 없습니다. 후속 호출이 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b03631e0a864ad17eff8a3140236f245127ccd24" translate="yes" xml:space="preserve">
          <source>The schema columns are:</source>
          <target state="translated">스키마 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e88c8d4c87637576e7f0f88b7eb8972efe2f3f6" translate="yes" xml:space="preserve">
          <source>The schema definition describes the internal data of a &lt;code&gt;RowSet&lt;/code&gt; object in three distinct areas:</source>
          <target state="translated">스키마 정의는 세 가지 영역에서 &lt;code&gt;RowSet&lt;/code&gt; 개체 의 내부 데이터를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="0bb86dfd7dd2cb7c7dabbe5b9afa0ca86ee85837" translate="yes" xml:space="preserve">
          <source>The scheme component of a URI cannot contain escaped octets, hence this method does not perform any decoding.</source>
          <target state="translated">URI의 스킴 구성 요소는 이스케이프 된 옥텟을 포함 할 수 없으므로이 메소드는 디코딩을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03f4421d79610120278b2b05c4ad70853ae92f0a" translate="yes" xml:space="preserve">
          <source>The scheme component of a URI, if defined, only contains characters in the</source>
          <target state="translated">URI의 스킴 구성 요소 (정의 된 경우)에는</target>
        </trans-unit>
        <trans-unit id="552a02db11e3a965b8192d8915eaba47a77bf1a7" translate="yes" xml:space="preserve">
          <source>The scheme component of this URI, or &lt;code&gt;null&lt;/code&gt; if the scheme is undefined</source>
          <target state="translated">이 URI 스킴 컴퍼넌트 . 스킴이 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347507e3914af1d8c1191601bb5aa53cb19b0fe4" translate="yes" xml:space="preserve">
          <source>The scheme-specific part of a URI only contains legal URI characters.</source>
          <target state="translated">URI의 체계 별 부분에는 유효한 URI 문자 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="786e33a9934f50290255272a6f6e5a002f9a8ca7" translate="yes" xml:space="preserve">
          <source>The scope that is printed out may be a filename, in which case it may convey local system information. For example, here's a sample printout of an identity named &quot;carol&quot;, who is marked not trusted in the user's identity database:</source>
          <target state="translated">인쇄되는 범위는 파일 이름 일 수 있으며,이 경우 로컬 시스템 정보를 전달할 수 있습니다. 예를 들어, 다음은 사용자의 신원 데이터베이스에서 신뢰할 수없는 것으로 표시된 &quot;carol&quot;이라는 신원의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="b44f515dc7972f5ec50a61a5a4b5d182cf8f1fa1" translate="yes" xml:space="preserve">
          <source>The scope, returningObj flag, and returningAttributes flag from the search controls &lt;code&gt;ctls&lt;/code&gt; are used to control the selection of objects that the listener is interested in, and determines what information is returned in the eventual &lt;code&gt;NamingEvent&lt;/code&gt; object. Note that the requested information to be returned might not be present in the &lt;code&gt;NamingEvent&lt;/code&gt; object if they are unavailable or could not be obtained by the service provider or service.</source>
          <target state="translated">검색 제어 &lt;code&gt;ctls&lt;/code&gt; 에서 scope, returningObj 플래그 및 returningAttributes 플래그 는 리스너가 관심있는 오브젝트의 선택을 제어하고 최종 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 리턴되는 정보를 판별하는 데 사용됩니다 . 요청 된 정보 가 사용 불가능하거나 서비스 제공 업체 또는 서비스에서 확보 할 수없는 경우 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e7ec0bc18757e2695eb1c71f854b0d45664eafa" translate="yes" xml:space="preserve">
          <source>The script code, or the empty string if none is defined.</source>
          <target state="translated">스크립트 코드 또는 정의되지 않은 경우 빈 문자열</target>
        </trans-unit>
        <trans-unit id="76538a8f01a55793d97f2332439c69463ccd6129" translate="yes" xml:space="preserve">
          <source>The script content of the element.</source>
          <target state="translated">요소의 스크립트 내용입니다.</target>
        </trans-unit>
        <trans-unit id="f9cd18270d845ffc1ce9a3c3c4df5a00249e7be6" translate="yes" xml:space="preserve">
          <source>The script names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid script names accepted and defined by &lt;a href=&quot;../../lang/character.unicodescript#forName(java.lang.String)&quot;&gt;&lt;code&gt;UnicodeScript.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에서 지원하는 스크립트 이름은 &lt;a href=&quot;../../lang/character.unicodescript#forName(java.lang.String)&quot;&gt; &lt;code&gt;UnicodeScript.forName&lt;/code&gt; 에서&lt;/a&gt; 허용하고 정의한 유효한 스크립트 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="ef23874ea1d91d27f386b1f20ccc288696d91d71" translate="yes" xml:space="preserve">
          <source>The script names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid script names accepted and defined by &lt;a href=&quot;../../lang/character.unicodescript#forName-java.lang.String-&quot;&gt;&lt;code&gt;UnicodeScript.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에서 지원하는 스크립트 이름은 &lt;a href=&quot;../../lang/character.unicodescript#forName-java.lang.String-&quot;&gt; &lt;code&gt;UnicodeScript.forName&lt;/code&gt; 에서&lt;/a&gt; 허용하고 정의한 유효한 스크립트 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="afafae7f294d0de7bc87bb9a26199785990e9648" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java &lt;sup&gt;TM&lt;/sup&gt; Scripting Engines and provides a framework for their use in Java applications.</source>
          <target state="translated">스크립팅 API는 Java &lt;sup&gt;TM&lt;/sup&gt; 스크립팅 엔진 을 정의 하고 Java 응용 프로그램에서 사용하기위한 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9c43eef002cb23064cdf0bd61ad8d93fd63d843" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java &lt;sup&gt;TM&lt;/sup&gt; Scripting Engines and provides a framework for their use in Java applications. This API is intended for use by application programmers who wish to execute programs written in scripting languages in their Java applications. The scripting language programs are usually provided by the end-users of the applications.</source>
          <target state="translated">스크립팅 API는 Java &lt;sup&gt;TM&lt;/sup&gt; 스크립팅 엔진 을 정의 하고 Java 응용 프로그램에서 사용하기위한 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다 . 이 API는 Java 응용 프로그램에서 스크립팅 언어로 작성된 프로그램을 실행하려는 응용 프로그램 프로그래머가 사용하기위한 것입니다. 스크립팅 언어 프로그램은 일반적으로 응용 프로그램의 최종 사용자가 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d96741ff8c133f9dbd116d9cc354913f3613d032" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java Scripting Engines and provides a framework for their use in Java applications.</source>
          <target state="translated">스크립팅 API는 자바 스크립팅 엔진을 정의하고 자바 애플리케이션에서 사용할 수있는 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb830255138e90189174d64ec193b2360d58854" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java Scripting Engines and provides a framework for their use in Java applications. This API is intended for use by application programmers who wish to execute programs written in scripting languages in their Java applications. The scripting language programs are usually provided by the end-users of the applications.</source>
          <target state="translated">스크립팅 API는 자바 스크립팅 엔진을 정의하고 자바 애플리케이션에서 사용할 수있는 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다. 이 API는 자바 애플리케이션에서 스크립팅 언어로 작성된 프로그램을 실행하려는 애플리케이션 프로그래머를위한 것입니다. 스크립팅 언어 프로그램은 일반적으로 응용 프로그램의 최종 사용자가 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91a09023d6539d10b0c1f584fa294076db23ca2e" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java&amp;trade; Scripting Engines and provides a framework for their use in Java applications.</source>
          <target state="translated">스크립팅 API는 Java &amp;trade; 스크립팅 엔진을 정의하고 Java 애플리케이션에서 사용하기위한 프레임 워크를 제공하는 인터페이스 및 클래스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dbb04c3cbf16a517019ff0d16573062dacfefe7e" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java&amp;trade; Scripting Engines and provides a framework for their use in Java applications. This API is intended for use by application programmers who wish to execute programs written in scripting languages in their Java applications. The scripting language programs are usually provided by the end-users of the applications.</source>
          <target state="translated">스크립팅 API는 Java &amp;trade; 스크립팅 엔진을 정의하고 Java 애플리케이션에서 사용하기위한 프레임 워크를 제공하는 인터페이스 및 클래스로 구성됩니다. 이 API는 자바 애플리케이션에서 스크립팅 언어로 작성된 프로그램을 실행하려는 애플리케이션 프로그래머를위한 것입니다. 스크립팅 언어 프로그램은 일반적으로 응용 프로그램의 최종 사용자가 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1874cbc91889750bd4ed8944d7e77907c076a39f" translate="yes" xml:space="preserve">
          <source>The scroll bar's bubble may not be displayed when it is not moveable (e.g. when it takes up the entire length of the scroll bar's track, or when the scroll bar is disabled). Whether the bubble is displayed or not will not affect the value returned by &lt;code&gt;getVisibleAmount&lt;/code&gt;.</source>
          <target state="translated">스크롤 바의 버블은 움직일 수없는 경우 표시되지 않을 수 있습니다 (예 : 스크롤 바 트랙의 전체 길이를 차지하거나 스크롤 바가 비활성화 된 경우). 풍선이 표시되는지 여부는 &lt;code&gt;getVisibleAmount&lt;/code&gt; 가 반환하는 값에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="97033424809eec61b4328169ae2d5e8590d94a71" translate="yes" xml:space="preserve">
          <source>The scroll begin event.</source>
          <target state="translated">스크롤 시작 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="bbde2811daac4486a0d468cb8007d4cb47236d0e" translate="yes" xml:space="preserve">
          <source>The scroll end event.</source>
          <target state="translated">스크롤 종료 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="004e7fbf09f50fe4e8b7ac9e967dfbe4024d2b0c" translate="yes" xml:space="preserve">
          <source>The scrollbar is flexible along it's scrolling axis and rigid along the other axis.</source>
          <target state="translated">스크롤바는 스크롤 축을 따라 유연하고 다른 축을 따라 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="382eadecc4f037382eec5e741ad0ea680bcfcb6e" translate="yes" xml:space="preserve">
          <source>The scrollpane's horizontal scrollbar child.</source>
          <target state="translated">스크롤 창의 가로 스크롤바 자식입니다.</target>
        </trans-unit>
        <trans-unit id="1e11140820d076c7d796e1e85149749c745f6fe9" translate="yes" xml:space="preserve">
          <source>The scrollpane's horizontal scrollbar child. Default is a &lt;code&gt;JScrollBar&lt;/code&gt;.</source>
          <target state="translated">스크롤 창의 가로 스크롤바 자식입니다. 기본값은 &lt;code&gt;JScrollBar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c8de2f0f7fbe23e6af5b111099c0e258b48a689" translate="yes" xml:space="preserve">
          <source>The scrollpane's vertical scrollbar child.</source>
          <target state="translated">스크롤 창의 수직 스크롤바 자식입니다.</target>
        </trans-unit>
        <trans-unit id="9ede92af942aaedafaf8414479c489583940b562" translate="yes" xml:space="preserve">
          <source>The scrollpane's vertical scrollbar child. Default is a &lt;code&gt;JScrollBar&lt;/code&gt;.</source>
          <target state="translated">스크롤 창의 수직 스크롤바 자식입니다. 기본값은 &lt;code&gt;JScrollBar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed6800d98f16995f5770b6c60e908abcfe32f1d9" translate="yes" xml:space="preserve">
          <source>The scrollpane's viewport child.</source>
          <target state="translated">scrollpane의 뷰포트 자식입니다.</target>
        </trans-unit>
        <trans-unit id="0e686b1765e2793e43fa880f8aa01f46c51c762b" translate="yes" xml:space="preserve">
          <source>The scrollpane's viewport child. Default is an empty &lt;code&gt;JViewport&lt;/code&gt;.</source>
          <target state="translated">scrollpane의 뷰포트 자식입니다. 기본값은 빈 &lt;code&gt;JViewport&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1adc17dbde6a6617e4245b5f40d3e5c15d6310c1" translate="yes" xml:space="preserve">
          <source>The search is started in the current catalog. If a match is found, no further attempt will be made. Only if there is no match in the current catalog, will alternate catalogs including delegate and next catalogs be considered.</source>
          <target state="translated">현재 카탈로그에서 검색이 시작됩니다. 일치하는 항목이 있으면 더 이상 시도하지 않습니다. 현재 카탈로그에 일치하는 항목이없는 경우에만 대리인 및 다음 카탈로그를 포함한 대체 카탈로그가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="234d2029591ee11c919d4dd5c206f5910e43d339" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="81db3c5442cb31038e49ee8d70757fa89532101d" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;#getSystemResource(java.lang.String)&quot;&gt;&lt;code&gt;getSystemResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;#getSystemResource(java.lang.String)&quot;&gt; &lt;code&gt;getSystemResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5785d6097b7d16726e6bb2855b1f1eebb4a0faba" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;../lang/classloader#getResource(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;../lang/classloader#getResource(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbe5e391a79ef4fb56cc4fe90eb28db84ba088c" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a9f3a688129049dc155e8aa96211ff37a84c5a" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1a2e358f079002238a405e9b7e93cabc439a00" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;classloader#getSystemResource-java.lang.String-&quot;&gt;&lt;code&gt;getSystemResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;classloader#getSystemResource-java.lang.String-&quot;&gt; &lt;code&gt;getSystemResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ee7f2ec763cae105fa5de7897720ebb90d644f" translate="yes" xml:space="preserve">
          <source>The search order of locale sensitive services can be configured by using the &quot;java.locale.providers&quot; system property. This system property declares the user's preferred order for looking up the locale sensitive services separated by a comma. It is only read at the Java runtime startup, so the later call to System.setProperty() won't affect the order.</source>
          <target state="translated">로케일 감지 서비스의 검색 순서는 &quot;java.locale.providers&quot;시스템 특성을 사용하여 구성 할 수 있습니다. 이 시스템 속성은 쉼표로 구분 된 로케일에 민감한 서비스를 조회하기위한 사용자의 선호 순서를 선언합니다. Java 런타임 시작시에만 읽히므로 나중에 System.setProperty ()를 호출해도 순서에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="536221f09c2f4ed88cacc3f1f5304b4667b08f99" translate="yes" xml:space="preserve">
          <source>The search order of locale sensitive services can be configured by using the &lt;code&gt;&lt;span id=&quot;java.locale.providers&quot;&gt;java.locale.providers&lt;/span&gt;&lt;/code&gt; system property. This system property declares the user's preferred order for looking up the locale sensitive services separated by a comma. It is only read at the Java runtime startup, so the later call to System.setProperty() won't affect the order.</source>
          <target state="translated">로케일 감지 서비스의 검색 순서는 &lt;code&gt;&lt;span id=&quot;java.locale.providers&quot;&gt;java.locale.providers&lt;/span&gt;&lt;/code&gt; 시스템 특성 을 사용하여 구성 할 수 있습니다 . 이 시스템 속성은 쉼표로 구분 된 로케일에 민감한 서비스를 조회하기위한 사용자의 선호 순서를 선언합니다. Java 런타임 시작시에만 읽히므로 나중에 System.setProperty ()를 호출해도 순서에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a60b10d749f6decd1a4f3bf2354bd215518658a" translate="yes" xml:space="preserve">
          <source>The search scope of this SearchControls.</source>
          <target state="translated">이 SearchControls의 검색 범위입니다.</target>
        </trans-unit>
        <trans-unit id="8c894820daeb9009f19e3e0e441e8caf2831e1c8" translate="yes" xml:space="preserve">
          <source>The search will not cross naming system boundaries.</source>
          <target state="translated">검색은 이름 지정 시스템 경계를 넘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71dac0f2a283224db1975250180f8302d951ec94" translate="yes" xml:space="preserve">
          <source>The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.</source>
          <target state="translated">검색된 클래스 정의는 현재 실행중인 클래스가 컴파일 될 때 존재하지만 정의를 더 이상 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19f0094b2e54dfb70b25925659062cdceddabfdd" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. A &lt;code&gt;Long&lt;/code&gt; object that represents the value of the second argument is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or null.</source>
          <target state="translated">두 번째 인수는 기본값입니다. &lt;code&gt;Long&lt;/code&gt; 지정된 이름의 속성이없는 경우, 해당 건물이 적절한 수치 형식이 아닌 경우, 또는 지정된 이름이 공백 또는 null의 경우 두 번째 인수의 값을 나타내는 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6fd52e585e241819acf494d6ce4e0623d9e9bbc2" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. An &lt;code&gt;Integer&lt;/code&gt; object that represents the value of the second argument is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 기본값입니다. &lt;code&gt;Integer&lt;/code&gt; 지정된 이름의 속성이없는 경우, 해당 건물이 적절한 수치 형식이 아닌 경우, 또는 지정된 이름이 비어 있거나 경우 두 번째 인수의 값을 나타내는 개체가 반환됩니다 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f48b892ab5983e62a64c20f51aeb4852a6d40d4" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. The default value is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 기본값입니다. 지정된 이름의 속성이 없거나 속성에 올바른 숫자 형식이 없거나 지정된 이름이 비어 있거나 &lt;code&gt;null&lt;/code&gt; 인 경우 기본값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b877a4fee0f652a4de1a3f21e57f77c02aa594f" translate="yes" xml:space="preserve">
          <source>The second argument of the permission required to execute this diagnostic command or null if the permission constructor has only one argument (like the ManagementPermission) or if no permission is required</source>
          <target state="translated">이 진단 명령을 실행하는 데 필요한 권한의 두 번째 인수 또는 권한 생성자에 하나의 인수 (예 : ManagementPermission) 만 있거나 권한이 필요하지 않은 경우 null</target>
        </trans-unit>
        <trans-unit id="303b0b21ef5bd9a39866e8a3b7d318393f6ec28b" translate="yes" xml:space="preserve">
          <source>The second conversion is better than the first one.</source>
          <target state="translated">두 번째 변환이 첫 번째 변환보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="b41fe98f3d794287cf7faede901c217eb147c5f5" translate="yes" xml:space="preserve">
          <source>The second highest justification priority.</source>
          <target state="translated">두 번째로 높은 정당성 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="846dd73201fada82f56344da711130e328206130" translate="yes" xml:space="preserve">
          <source>The second is a completion signal that allows the driver to wait until all workers have completed.</source>
          <target state="translated">두 번째는 운전자가 모든 작업자가 완료 할 때까지 기다릴 수있는 완료 신호입니다.</target>
        </trans-unit>
        <trans-unit id="84e48120fa361c307626734228e297300ca0735a" translate="yes" xml:space="preserve">
          <source>The second lowest justification priority.</source>
          <target state="translated">두 번째로 낮은 정당성 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="9c74ca16e8df45ce54eac3795a7c789ada4f5436" translate="yes" xml:space="preserve">
          <source>The second model is that attributes are associated with a name (typically an atomic name) in a DirContext. In this model, an attribute operation on the named object is roughly equivalent to a lookup on the name of the parent DirContext of the named object, followed by the attribute operation invoked on the parent in which the caller supplies the terminal atomic name. The attributes can be viewed as being stored in the parent DirContext (again, this does not imply that the implementation must do so). Objects that are not DirContexts can have attributes, as long as their parents are DirContexts.</source>
          <target state="translated">두 번째 모델은 속성이 DirContext의 이름 (일반적으로 원자 이름)과 연관되어 있다는 것입니다. 이 모델에서, 명명 된 객체의 속성 연산은 명명 된 객체의 부모 DirContext의 이름을 조회 한 다음 호출자가 터미널 원자 이름을 제공하는 상위에서 호출 된 속성 연산과 거의 같습니다. 속성은 부모 DirContext에 저장된 것으로 볼 수 있습니다 (다시 말해 구현이 그렇게해야 함을 의미하지는 않습니다). DirContext가 아닌 객체는 부모가 DirContext 인 한 속성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08627207b7124af34d47a11be9d4eb35f89c3aa4" translate="yes" xml:space="preserve">
          <source>The second node precedes the reference node.</source>
          <target state="translated">두 번째 노드는 참조 노드 앞에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e114c9855232da640f7bcf88369ff012eb0d38ce" translate="yes" xml:space="preserve">
          <source>The second of minute of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;, from 0 to 59.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 초입니다 . 0부터 59까지입니다.</target>
        </trans-unit>
        <trans-unit id="a1a191dfba3988b37aebbbf772bf95fd6c7c5ef5" translate="yes" xml:space="preserve">
          <source>The second-of-day.</source>
          <target state="translated">둘째 날.</target>
        </trans-unit>
        <trans-unit id="0e870041b0c18ce21d4cc73d1cbae5e1e2aeb07b" translate="yes" xml:space="preserve">
          <source>The second-of-minute.</source>
          <target state="translated">두 번째 분.</target>
        </trans-unit>
        <trans-unit id="f6efcc10b579d40e24ab34cc216d6d80435a8d31" translate="yes" xml:space="preserve">
          <source>The seconds and nanoseconds are extracted from the specified milliseconds.</source>
          <target state="translated">지정된 밀리 초에서 초와 나노초가 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="23a2616566fd816bf2a993165e25281f4a18c7b6" translate="yes" xml:space="preserve">
          <source>The seconds and nanoseconds are extracted from the specified nanoseconds.</source>
          <target state="translated">지정된 나노초에서 초와 나노초가 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="7a0383fffb7779acd5ef652edbc25f76897e0327" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of a day, where each day is 86400 seconds which implies a 24 hour day. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 하루의 표준 정의에 따라 계산되며, 여기서 하루는 86400 초이며 24 시간의 하루를 의미합니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="18dafaf48750adbb9e664a9c182377f5852b8936" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of a minute, where each minute is 60 seconds. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 분의 표준 정의에 따라 계산되며, 각 분은 60 초입니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bdf17cabd8f715fb436e568230500a070a9d89b" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of an hour, where each hour is 3600 seconds. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 시간의 표준 정의에 따라 계산되며, 각 시간은 3600 초입니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a48467f35f4c20748fa3acc00c4bb7c44e6d23fb" translate="yes" xml:space="preserve">
          <source>The secure communications modes include:</source>
          <target state="translated">보안 통신 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb1ed30a436bf227420125540bd43fdab515b945" translate="yes" xml:space="preserve">
          <source>The security consideration is important with respect to internationalization domain name support. For example, English domain names may be</source>
          <target state="translated">국제화 도메인 이름 지원과 관련하여 보안 고려 사항이 중요합니다. 예를 들어 영어 도메인 이름은</target>
        </trans-unit>
        <trans-unit id="8754c4a5e5f52f313c5ec7c42a10eeb348a2de09" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5f541439356895d1a7b18c9420f1d7b1125db20e" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy. Granting the setSecurityManager permission would allow code to change which security manager is used by installing a different, possibly less restrictive security manager, thereby bypassing checks that would have been enforced by the original security manager.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다. setSecurityManager 권한을 부여하면 코드가 덜 제한적인 다른 보안 관리자를 설치하여 사용되는 보안 관리자를 변경하여 원래 보안 관리자가 시행 한 검사를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea632fc690ffe8730861707a2c56b33a9b6867d2" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy. It allows an application to determine, before performing a possibly unsafe or sensitive operation, what the operation is and whether it is being attempted in a security context that allows the operation to be performed. The application can allow or disallow the operation.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다. 응용 프로그램은 안전하지 않거나 민감한 작업을 수행하기 전에 작업이 무엇인지, 작업을 수행 할 수있는 보안 컨텍스트에서 작업이 시도되고 있는지 여부를 확인할 수 있습니다. 응용 프로그램은 작업을 허용하거나 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77cdd2014731846d35b1ae24ee942e1177ba673e" translate="yes" xml:space="preserve">
          <source>The security manager is thereby given an opportunity to prevent completion of the operation by throwing an exception. A security manager routine simply returns if the operation is permitted, but throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not permitted.</source>
          <target state="translated">보안 관리자는 예외를 발생시켜 작업 완료를 방지 할 수 있습니다. 보안 관리자 루틴은 작업이 허용되면 단순히 반환하지만 작업이 허용 되지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 을 throw합니다 .</target>
        </trans-unit>
        <trans-unit id="c0ed1fb6cefbd737d506d963693aa54fe70100ed" translate="yes" xml:space="preserve">
          <source>The security manager is thereby given an opportunity to prevent completion of the operation by throwing an exception. A security manager routine simply returns if the operation is permitted, but throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not permitted. The only exception to this convention is &lt;code&gt;checkTopLevelWindow&lt;/code&gt;, which returns a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">이로써 보안 관리자는 예외를 던져서 작업 완료를 막을 수있는 기회가 주어집니다. 보안 관리자 루틴은 조작이 허용되면 단순히 리턴하지만 조작이 허용 되지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 을 발생시킵니다. 이 규칙에 대한 유일한 예외는 &lt;code&gt;checkTopLevelWindow&lt;/code&gt; 이며 &lt;code&gt;boolean&lt;/code&gt; 값 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a67c38f887b66e32ea2617d5a99442f063242dfe" translate="yes" xml:space="preserve">
          <source>The security provider framework uses this method with some types of services to quickly exclude non-matching implementations for consideration. Applications will typically not need to call it.</source>
          <target state="translated">보안 제공자 프레임 워크는 일부 서비스 유형과 함께이 방법을 사용하여 일치하지 않는 구현을 신속하게 제외시킵니다. 응용 프로그램은 일반적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="741ac520b2873a175ac0092c4d1afb002e856fbf" translate="yes" xml:space="preserve">
          <source>The segment type constant for a point that specifies the end point of a line to be drawn from the most recently specified point.</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 선의 끝점을 지정하는 점에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="3973bcf55ac17cd3ee487605b4f605a51f7088ed" translate="yes" xml:space="preserve">
          <source>The segment type constant for a point that specifies the starting location for a new subpath.</source>
          <target state="translated">새 하위 경로의 시작 위치를 지정하는 지점에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="80aba145fc2824f9bd007706a9f479370c0b4eb2" translate="yes" xml:space="preserve">
          <source>The segment type constant for the pair of points that specify a quadratic parametric curve to be drawn from the most recently specified point.</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 2 차 파라 메트릭 곡선을 지정하는 점 쌍에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="c18a9968e10da3d03ea7eda9a64c42aeb83bb165" translate="yes" xml:space="preserve">
          <source>The segment type constant for the pair of points that specify a quadratic parametric curve to be drawn from the most recently specified point. The curve is interpolated by solving the parametric control equation in the range &lt;code&gt;(t=[0..1])&lt;/code&gt; using the most recently specified (current) point (CP), the first control point (P1), and the final interpolated control point (P2). The parametric control equation for this curve is:</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 2 차 파라 메트릭 곡선을 지정하는 점 쌍에 대한 세그먼트 유형 상수입니다. 곡선은 가장 최근에 지정된 (현재) 점 (CP), 첫 번째 제어점 (P1) 및 최종 보간 된 제어점을 사용하여 범위 &lt;code&gt;(t=[0..1])&lt;/code&gt; 의 매개 변수 제어 방정식을 풀어 보간됩니다. (P2). 이 곡선의 매개 변수 제어 방정식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87af03fe4753c3d0fd37c06a404fc52727178751" translate="yes" xml:space="preserve">
          <source>The segment type constant for the set of 3 points that specify a cubic parametric curve to be drawn from the most recently specified point.</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 3 차 파라 메트릭 곡선을 지정하는 3 개의 점 세트에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="0339b07d46a1df3c557c177f88fe1e9060e280d6" translate="yes" xml:space="preserve">
          <source>The segment type constant for the set of 3 points that specify a cubic parametric curve to be drawn from the most recently specified point. The curve is interpolated by solving the parametric control equation in the range &lt;code&gt;(t=[0..1])&lt;/code&gt; using the most recently specified (current) point (CP), the first control point (P1), the second control point (P2), and the final interpolated control point (P3). The parametric control equation for this curve is:</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 3 차 파라 메트릭 곡선을 지정하는 3 개의 점 세트에 대한 세그먼트 유형 상수입니다. 곡선은 가장 최근에 지정된 (현재) 점 (CP), 첫 번째 제어점 (P1), 두 번째 제어점 (P2 &lt;code&gt;(t=[0..1])&lt;/code&gt; 사용하여 범위 (t = [0..1]) 의 매개 변수 제어 방정식을 풀어 보간됩니다 . ) 및 최종 보간 된 제어점 (P3). 이 곡선의 매개 변수 제어 방정식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb56a94440f8726332fb64d2dd4609e5fa3a2ec8" translate="yes" xml:space="preserve">
          <source>The segment type constant that specifies that the preceding subpath should be closed by appending a line segment back to the point corresponding to the most recent SEG_MOVETO.</source>
          <target state="translated">가장 최근의 SEG_MOVETO에 해당하는 지점에 선 세그먼트를 다시 추가하여 이전 하위 경로를 닫아야 함을 지정하는 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="894b97382dba3f9e20b3cdb2eb76214dc93c0d83" translate="yes" xml:space="preserve">
          <source>The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see &lt;a href=&quot;#ALL_ACCESS&quot;&gt;&lt;code&gt;ALL_ACCESS&lt;/code&gt;&lt;/a&gt;), unless the given buffer is &lt;a href=&quot;../../../../java.base/java/nio/buffer#isReadOnly()&quot;&gt;read-only&lt;/a&gt; in which case the segment will not feature the &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access mode.</source>
          <target state="translated">세그먼트는 모든 &lt;a href=&quot;#access-modes&quot;&gt;액세스 모드를 제공합니다&lt;/a&gt; ( &lt;a href=&quot;#ALL_ACCESS&quot;&gt; &lt;code&gt;ALL_ACCESS&lt;/code&gt; &lt;/a&gt; 참조 ), 지정된 버퍼가 &lt;a href=&quot;../../../../java.base/java/nio/buffer#isReadOnly()&quot;&gt;읽기 전용&lt;/a&gt; 이 아닌 경우 세그먼트가 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스 모드를 제공 하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="7ae4e3fc46f78df27972d9dd0ebb202d4893af1a" translate="yes" xml:space="preserve">
          <source>The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see &lt;a href=&quot;#ALL_ACCESS&quot;&gt;&lt;code&gt;ALL_ACCESS&lt;/code&gt;&lt;/a&gt;), unless the given mapping mode is &lt;a href=&quot;../../../../java.base/java/nio/channels/filechannel.mapmode#READ_ONLY&quot;&gt;READ_ONLY&lt;/a&gt;, in which case the segment will not feature the &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access mode.</source>
          <target state="translated">세그먼트는 지정된 매핑 모드가 &lt;a href=&quot;../../../../java.base/java/nio/channels/filechannel.mapmode#READ_ONLY&quot;&gt;READ_ONLY&lt;/a&gt; 가 아닌 경우 모든 &lt;a href=&quot;#access-modes&quot;&gt;액세스 모드를 제공합니다&lt;/a&gt; ( &lt;a href=&quot;#ALL_ACCESS&quot;&gt; &lt;code&gt;ALL_ACCESS&lt;/code&gt; &lt;/a&gt; 참조 ). 이 경우 세그먼트는 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스 모드를 제공 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb168e08c1a8515aa7a7100cc2b03043e09a9bd1" translate="yes" xml:space="preserve">
          <source>The select element allows the selection of an option.</source>
          <target state="translated">선택 요소를 사용하면 옵션을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60543c3c5021576a51e4fad1230baab48b889f69" translate="yes" xml:space="preserve">
          <source>The select element allows the selection of an option. The contained options can be directly accessed through the select element as a collection. See the SELECT element definition in HTML 4.0.</source>
          <target state="translated">선택 요소를 사용하면 옵션을 선택할 수 있습니다. 포함 된 옵션은 컬렉션으로 선택 요소를 통해 직접 액세스 할 수 있습니다. HTML 4.0의 SELECT 요소 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c41846f7c607b568e2f811d680db13431de42230" translate="yes" xml:space="preserve">
          <source>The selectable channel</source>
          <target state="translated">선택 가능한 채널</target>
        </trans-unit>
        <trans-unit id="f99f7b7b77b1d24238b1a7159cfaaf7109131828" translate="yes" xml:space="preserve">
          <source>The selected item may not necessarily be managed by the underlying &lt;code&gt;ListModel&lt;/code&gt;. This disjoint behavior allows for the temporary storage and retrieval of a selected item in the model.</source>
          <target state="translated">선택된 항목은 기본 &lt;code&gt;ListModel&lt;/code&gt; 에 의해 관리되지 않을 수도 있습니다 . 이 분리 된 동작은 모델에서 선택한 항목의 임시 저장 및 검색을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="72d6ad2310e85fb1d6829a4a5954408f8cdc0c95" translate="yes" xml:space="preserve">
          <source>The selected item or &lt;code&gt;null&lt;/code&gt; if there is no selection</source>
          <target state="translated">선택한 항목 또는 선택 항목 이없는 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="980a17db139f93c4be1dbeca6c1ec98c6a583f36" translate="yes" xml:space="preserve">
          <source>The selected-key set is &lt;a href=&quot;#ksc&quot;&gt;not thread-safe&lt;/a&gt;.</source>
          <target state="translated">선택한 키 세트는 &lt;a href=&quot;#ksc&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf5971d519d788492de5d5d81d0e5637fab2e9f3" translate="yes" xml:space="preserve">
          <source>The selected-key set is &lt;a href=&quot;#sksc&quot;&gt;not thread-safe&lt;/a&gt;.</source>
          <target state="translated">선택된 키 세트는 &lt;a href=&quot;#sksc&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2853e7255aa0a673fced6a6df84b0254f3157771" translate="yes" xml:space="preserve">
          <source>The selection can be discontiguous on lines with mixed-direction text. Only those characters in the logical range between start and limit appear selected. For example, consider the text 'ABCdef' where capital letters indicate right-to-left text, rendered on a right-to-left line, with a logical selection from 0 to 4 ('ABCd'). The text appears as follows, with bold standing in for the selection, and underlining for the extension:</source>
          <target state="translated">선택은 방향이 혼합 된 텍스트가있는 행에서 불연속적일 수 있습니다. 시작과 제한 사이의 논리적 범위에있는 문자 만 선택된 것으로 나타납니다. 예를 들어, 대문자가 오른쪽에서 왼쪽 줄에 렌더링 된 오른쪽에서 왼쪽 텍스트를 나타내는 'ABCdef'텍스트를 생각해보십시오. 논리적 선택은 0에서 4 ( 'ABCd')입니다. 텍스트는 선택 항목에 굵게 표시되고 확장에 밑줄이 표시되어 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ee377636b8b2866aeab5296e00c6c54b19e71ed5" translate="yes" xml:space="preserve">
          <source>The selection criteria are represented by a map. Each map entry represents a selection criterion. A provider is selected iff it satisfies all selection criteria. The key for any entry in such a map must be in one of the following two formats:</source>
          <target state="translated">선택 기준은지도로 표시됩니다. 각 맵 항목은 선택 기준을 나타냅니다. 모든 선택 기준을 충족하면 제공자가 선택됩니다. 이러한 맵에서 항목의 키는 다음 두 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e44ffedc1f376eadaacdab4f99049fa47e9e98b9" translate="yes" xml:space="preserve">
          <source>The selection criterion must be specified in one of the following two formats:</source>
          <target state="translated">선택 기준은 다음 두 형식 중 하나로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="74c7112680921edb20e3d4d4f9eaa109f3c9a083" translate="yes" xml:space="preserve">
          <source>The selection is discontiguous because the selected characters are visually discontiguous. Also note that since the range includes the first logical character (A), the selection is extended to the portion of the &lt;code&gt;bounds&lt;/code&gt; before the start of the layout, which in this case (a right-to-left line) is the right portion of the &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">선택한 문자가 시각적으로 불연속 적이기 때문에 선택이 불 연속적입니다. 또한 범위에 첫 번째 논리 문자 (A)가 포함되어 있으므로 선택은 레이아웃 시작 전 &lt;code&gt;bounds&lt;/code&gt; 부분으로 확장됩니다. 이 경우 (오른쪽에서 왼쪽 줄) &lt;code&gt;bounds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8f3e58fee457f743d90cb3a11b275bb0e5c734" translate="yes" xml:space="preserve">
          <source>The selection model property name.</source>
          <target state="translated">선택 모델 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5b8e52c4dc1170658ac68079e913b9282a57c2c8" translate="yes" xml:space="preserve">
          <source>The selection operations synchronize on the selector itself, on the key set, and on the selected-key set, in that order. They also synchronize on the cancelled-key set during steps (1) and (3) above.</source>
          <target state="translated">선택 작업은 선택기 자체, 키 세트 및 선택한 키 세트에서 순서대로 동기화됩니다. 또한 위의 1 단계와 3 단계에서 취소 된 키 세트를 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="a904ff842ccfcf481664d94ff854e457ba5bfb75" translate="yes" xml:space="preserve">
          <source>The selection operations synchronize on the selector itself, on the selected-key set, in that order. They also synchronize on the cancelled-key set during steps (1) and (3) above.</source>
          <target state="translated">선택 작업은 선택기 자체에서 선택한 키 세트의 순서대로 동기화됩니다. 또한 위의 단계 (1) 및 (3)에서 설정 한 취소 된 키에서 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f0fdc28581457a5d51859c43f5da1f56889794b2" translate="yes" xml:space="preserve">
          <source>The selection state of a &lt;code&gt;JList&lt;/code&gt; is managed by another separate model, an instance of &lt;code&gt;ListSelectionModel&lt;/code&gt;. &lt;code&gt;JList&lt;/code&gt; is initialized with a selection model on construction, and also contains methods to query or set this selection model. Additionally, &lt;code&gt;JList&lt;/code&gt; provides convenient methods for easily managing the selection. These methods, such as &lt;code&gt;setSelectedIndex&lt;/code&gt; and &lt;code&gt;getSelectedValue&lt;/code&gt;, are cover methods that take care of the details of interacting with the selection model. By default, &lt;code&gt;JList&lt;/code&gt;'s selection model is configured to allow any combination of items to be selected at a time; selection mode &lt;code&gt;MULTIPLE_INTERVAL_SELECTION&lt;/code&gt;. The selection mode can be changed on the selection model directly, or via &lt;code&gt;JList&lt;/code&gt;'s cover method. Responsibility for updating the selection model in response to user gestures lies with the list's &lt;code&gt;ListUI&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JList&lt;/code&gt; 의 선택 상태는 다른 별도의 모델 인 &lt;code&gt;ListSelectionModel&lt;/code&gt; 인스턴스에서 관리합니다 . &lt;code&gt;JList&lt;/code&gt; 는 생성시 선택 모델로 초기화 되며이 선택 모델을 쿼리하거나 설정하는 메서드도 포함되어 있습니다. 또한 &lt;code&gt;JList&lt;/code&gt; 는 선택을 쉽게 관리 할 수있는 편리한 방법을 제공합니다. &lt;code&gt;setSelectedIndex&lt;/code&gt; 및 &lt;code&gt;getSelectedValue&lt;/code&gt; 와 같은 이러한 메소드 는 선택 모델과 상호 작용하는 세부 사항을 처리하는 커버 메소드입니다. 기본적으로 &lt;code&gt;JList&lt;/code&gt; 의 선택 모델은 한 번에 모든 항목 조합을 선택할 수 있도록 구성됩니다. 선택 모드 &lt;code&gt;MULTIPLE_INTERVAL_SELECTION&lt;/code&gt; . 선택 모드는 선택 모델에서 직접 변경하거나 &lt;code&gt;JList&lt;/code&gt; 의 커버 방법을 통해 변경할 수 있습니다 . 사용자 제스처에 대한 응답으로 선택 모델을 업데이트하는 책임은 목록의 &lt;code&gt;ListUI&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9f90ca688127c456774524ecd9188f16470783" translate="yes" xml:space="preserve">
          <source>The semantics for when a CSS style should overide visual attributes defined by an element are not well defined. For example, the html &lt;code&gt;&amp;lt;body bgcolor=red&amp;gt;&lt;/code&gt; makes the body have a red background. But if the html file also contains the CSS rule &lt;code&gt;body { background: blue }&lt;/code&gt; it becomes less clear as to what color the background of the body should be. The current implementation gives visual attributes defined in the element the highest precedence, that is they are always checked before any styles. Therefore, in the previous example the background would have a red color as the body element defines the background color to be red.</source>
          <target state="translated">CSS 스타일이 요소에 의해 정의 된 시각적 속성을 재정의해야하는 경우에 대한 의미가 제대로 정의되지 않았습니다. 예를 들어, html &lt;code&gt;&amp;lt;body bgcolor=red&amp;gt;&lt;/code&gt; 는 본문을 빨간색 배경으로 만듭니다. 그러나 html 파일에 CSS 규칙 &lt;code&gt;body { background: blue }&lt;/code&gt; 도 포함되어 있으면 본문 의 배경 색상이 명확하지 않게됩니다. 현재 구현에서는 요소에 정의 된 시각적 속성에 가장 높은 우선 순위를 부여합니다. 즉, 항상 스타일보다 먼저 확인됩니다. 따라서 이전 예제에서 body 요소가 배경색을 빨간색으로 정의하므로 배경이 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7c8755086b4e6b5bb57770b4a79b8f7bdaccf4ae" translate="yes" xml:space="preserve">
          <source>The semantics of how setting values are combined depends on the setting control that is implemented, but all recordings should get at least all the events they request.</source>
          <target state="translated">설정 값이 결합되는 방식의 의미는 구현 된 설정 제어에 따라 다르지만 모든 레코딩은 최소한 요청한 모든 이벤트를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="95202ca438f08b9e0031b9c4bfdeb9b4df852c33" translate="yes" xml:space="preserve">
          <source>The semantics of the List returned by this method become undefined if the backing list (i.e., this List) is</source>
          <target state="translated">지원 목록 (즉,이 목록)이 다음과 같은 경우이 메소드가 리턴 한 목록의 의미가 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="453d2ffd1b3b134c5fd9217f7532df9b822182d8" translate="yes" xml:space="preserve">
          <source>The semantics of the beanName parameter are defined by java.beans.Beans.instantiate.</source>
          <target state="translated">beanName 매개 변수의 의미는 java.beans.Beans.instantiate에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="384632fa38dae55d93e0e907e62e3a2804bb5387" translate="yes" xml:space="preserve">
          <source>The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is</source>
          <target state="translated">지원 목록 (즉,이 목록)이 다음과 같은 경우이 메소드가 리턴 한 목록의 의미가 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="6eb76390f1c14aef2312c3b26cdfb1a9faf1c0d3" translate="yes" xml:space="preserve">
          <source>The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is modified in any way other than via the returned list.</source>
          <target state="translated">지원 목록 (즉,이 목록)이 반환 된 목록을 통하지 않고 다른 방식으로 수정되면이 메소드가 반환 한 목록의 의미가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d20ea275f88276269e77c1a6a3f0a0a12013fb0a" translate="yes" xml:space="preserve">
          <source>The semantics of this method are unspecified if the arguments could not have been produced by an instance of some valid dynamic proxy class containing this invocation handler.</source>
          <target state="translated">이 호출 핸들러를 포함하는 일부 유효한 동적 프록시 클래스의 인스턴스에 의해 인수가 생성 될 수없는 경우이 메소드의 의미는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8513f09b48ac39c6481ad6003d15d1ff8cbf1f1" translate="yes" xml:space="preserve">
          <source>The semantics of this method may differ from those of the other &lt;code&gt;read&lt;/code&gt; methods in several ways. First, any destination image and/or image type set in the &lt;code&gt;ImageReadParam&lt;/code&gt; may be ignored. Second, the usual listener calls are not guaranteed to be made, or to be meaningful if they are. This is because the returned image may not be fully populated with pixel data at the time it is returned, or indeed at any time.</source>
          <target state="translated">이 방법의 의미는 몇 가지면에서 다른 &lt;code&gt;read&lt;/code&gt; 방법 의 의미와 다를 수 있습니다 . 먼저 &lt;code&gt;ImageReadParam&lt;/code&gt; 에 설정된 대상 이미지 및 / 또는 이미지 유형 이 무시 될 수 있습니다. 둘째, 일반적인 청취자 호출이 이루어 지거나 의미가있는 것은 아닙니다. 반환 된 이미지가 반환 될 때나 실제로는 픽셀 데이터로 완전히 채워지지 않을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1cc6107a3ab38aa44b20de1eca06580ad330b25d" translate="yes" xml:space="preserve">
          <source>The sentinel value is chosen so that reflective queries can be made directly against the result value. The sentinel value cannot be confused with a real parameter, since &lt;code&gt;void&lt;/code&gt; is never acceptable as a parameter type. For variable arity invocation modes, the expression &lt;a href=&quot;../class#getComponentType()&quot;&gt;&lt;code&gt;lastParameterType().getComponentType()&lt;/code&gt;&lt;/a&gt; is useful to query the type of the &quot;varargs&quot; parameter.</source>
          <target state="translated">센티넬 값은 결과 값에 대해 직접 반사 쿼리를 만들 수 있도록 선택됩니다. &lt;code&gt;void&lt;/code&gt; 는 매개 변수 유형으로 허용 되지 않으므로 sentinel 값을 실제 매개 변수와 혼동 할 수 없습니다 . 가변 arity 호출 모드의 경우 &lt;a href=&quot;../class#getComponentType()&quot;&gt; &lt;code&gt;lastParameterType().getComponentType()&lt;/code&gt; &lt;/a&gt; 표현식 은 &quot;varargs&quot;매개 변수의 유형을 쿼리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="161693ca410ae026e19d3b93be91d521d736f95e" translate="yes" xml:space="preserve">
          <source>The separator between a keystore name prefix and an entry name. When specified, it applies to all the entries in a domain. Its default value is a space.</source>
          <target state="translated">키 저장소 이름 접 두부와 항목 이름 사이의 구분 기호입니다. 지정하면 도메인의 모든 항목에 적용됩니다. 기본값은 공백입니다.</target>
        </trans-unit>
        <trans-unit id="c33bef4fc18f12b61dd742c406adeaac8d64a82d" translate="yes" xml:space="preserve">
          <source>The sequence may be of arbitrary length but the first four elements are assigned specific meanings, as follows:</source>
          <target state="translated">시퀀스는 임의의 길이 일 수 있지만 처음 4 개 요소에는 다음과 같이 특정 의미가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="fddaff8ebac1c2c5c7b43da5bf7781d174bd01f1" translate="yes" xml:space="preserve">
          <source>The sequence number of the earliest notification still in the buffer.</source>
          <target state="translated">버퍼에 여전히 가장 빠른 알림의 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a4b01bb88787366b6d9e829887a4ae25a588e430" translate="yes" xml:space="preserve">
          <source>The sequence number of the next notification available for querying. This will be the starting sequence number for the next notification query.</source>
          <target state="translated">쿼리에 사용할 수있는 다음 알림의 시퀀스 번호입니다. 다음 알림 쿼리의 시작 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="bf0008ac9d1317707e44c068d027348ed859c00f" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Byte.parseByte&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Byte.parseByte&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="04a5cebfd92c347160af912e87639fade424841a" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Integer.parseInt&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;
 String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음의 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Integer.parseInt&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt; String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f47a3f697e9bed49511091c71b4c3caa8900d5a" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Long.parseLong&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Long.parseLong&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9a8c9c139a21299d680c43bec3c9a7c26de6811f" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Short.parseShort&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;
 String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음의 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Short.parseShort&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt; String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ed0c9428f6e0126963f745de2465f141332a6026" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Byte.parseByte&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 나오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Byte.parseByte&lt;/code&gt; 메서드로 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c063e5411741f160ae6a46bec35b7a73c1e07d1" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Integer.parseInt&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Integer.parseInt&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7ce5c427a4177226515b1b8cfab424168d32e788" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Long.parseLong&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 &lt;code&gt;Long.parseLong&lt;/code&gt; 메소드에 의해 표시된 기수 (10, 16 또는 8 )로 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4974fa4ef44b513af1028ff49c4b453f94609bd" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Short.parseShort&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 뒤에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Short.parseShort&lt;/code&gt; 메소드에 의해 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="405b55aaa46e13a89f534b404603b82ce083cf31" translate="yes" xml:space="preserve">
          <source>The sequence of numerals in a version number is compared to another such sequence in numerical, pointwise fashion; &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;
 10.0.4&lt;/code&gt; is less than &lt;code&gt;10.1.2&lt;/code&gt;. If one sequence is shorter than another then the missing elements of the shorter sequence are considered to be less than the corresponding elements of the longer sequence; &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;10.0.2&lt;/code&gt; is less than &lt;code&gt;10.0.2.1&lt;/code&gt;.</source>
          <target state="translated">버전 번호의 숫자 시퀀스는 숫자, 포인트 방식으로 다른 시퀀스와 비교됩니다. &lt;em&gt;예를 들어&lt;/em&gt; , &lt;code&gt; 10.0.4&lt;/code&gt; 는 미만이다 &lt;code&gt;10.1.2&lt;/code&gt; . 한 시퀀스가 ​​다른 시퀀스보다 짧으면 더 짧은 시퀀스의 누락 된 요소는 긴 시퀀스의 해당 요소보다 작은 것으로 간주됩니다. &lt;em&gt;예를 들어&lt;/em&gt; , &lt;code&gt;10.0.2&lt;/code&gt; 이 적은보다 &lt;code&gt;10.0.2.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b7e641ecc2ddbeb716b792bb33db3785fdea384" translate="yes" xml:space="preserve">
          <source>The sequence of task executions continues indefinitely until one of the following exceptional completions occur:</source>
          <target state="translated">작업 실행 순서는 다음과 같은 예외적 인 완료 중 하나가 발생할 때까지 무기한 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="e434dd3150cc80ca7cae2f8b8eaeb4038c9e904c" translate="yes" xml:space="preserve">
          <source>The sequence of the candidate locales also corresponds to the runtime resource lookup path (also known as the</source>
          <target state="translated">후보 로케일의 순서는 또한 런타임 자원 검색 경로 (</target>
        </trans-unit>
        <trans-unit id="f7e487534567beaaaf886a79c2a34b214dbcb31b" translate="yes" xml:space="preserve">
          <source>The sequence property will be initialized with a new unique value. These sequence values are allocated in increasing order within a VM.</source>
          <target state="translated">시퀀스 속성은 새로운 고유 값으로 초기화됩니다. 이 시퀀스 값은 VM 내에서 순서대로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="a7cd757d66959c5ea95a29c3e377f5ce005f6f9a" translate="yes" xml:space="preserve">
          <source>The sequential group along the horizontal axis is rendered as a solid blue line. Notice the sequential group is the sum of the children elements it contains.</source>
          <target state="translated">수평 축을 따라 순차적 인 그룹이 파란색 실선으로 렌더링됩니다. 순차 그룹은 포함 된 하위 요소의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="c00ff75511a0de0a28d3c3e6f1b65b2b2cd9a528" translate="yes" xml:space="preserve">
          <source>The serial version of the class does not match that of the class descriptor read from the stream</source>
          <target state="translated">클래스의 직렬 버전이 스트림에서 읽은 클래스 디스크립터의 버전과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb17ac47a0c237bc15ecd3f6d7915bd46810b1f" translate="yes" xml:space="preserve">
          <source>The serialization filter is initialized to the value of &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;&lt;code&gt;ObjectInputFilter.Config.getSerialFilter&lt;/code&gt;&lt;/a&gt; when the &lt;code&gt; ObjectInputStream&lt;/code&gt; is constructed and can be set to a custom filter only once.</source>
          <target state="translated">직렬화 필터는 &lt;code&gt; ObjectInputStream&lt;/code&gt; 이 구성 될 때 &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt; &lt;code&gt;ObjectInputFilter.Config.getSerialFilter&lt;/code&gt; &lt;/a&gt; 의 값으로 초기화되며 사용자 정의 필터로 한 번만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201566c3836942d058babbf949a4164803b90149" translate="yes" xml:space="preserve">
          <source>The serialization filter is initialized to the value of &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;&lt;code&gt;ObjectInputFilter.Config.getSerialFilter&lt;/code&gt;&lt;/a&gt; when the &lt;code&gt; ObjectInputStream&lt;/code&gt; is constructed and can be set to a custom filter only once. The filter must be set before reading any objects from the stream; for example, by calling &lt;a href=&quot;#readObject()&quot;&gt;&lt;code&gt;readObject()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#readUnshared()&quot;&gt;&lt;code&gt;readUnshared()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">직렬화 필터는 &lt;code&gt; ObjectInputStream&lt;/code&gt; 이 구성 될 때 &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt; &lt;code&gt;ObjectInputFilter.Config.getSerialFilter&lt;/code&gt; &lt;/a&gt; 의 값으로 초기화되며 사용자 정의 필터로 한 번만 설정할 수 있습니다. 스트림에서 개체를 읽기 전에 필터를 설정해야합니다. 예를 들어 &lt;a href=&quot;#readObject()&quot;&gt; &lt;code&gt;readObject()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#readUnshared()&quot;&gt; &lt;code&gt;readUnshared()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c8b47e4393e9fad0dd6a3358b5377e4c805ad3c8" translate="yes" xml:space="preserve">
          <source>The serialization filter is initialized to the value of &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;the process-wide filter&lt;/a&gt;.</source>
          <target state="translated">직렬화 필터는 &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;프로세스 전체 필터&lt;/a&gt; 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f500ee4e778bcc52718bc32f469d80100beb7550" translate="yes" xml:space="preserve">
          <source>The serialization filter is initialized to the value of &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;the system-wide filter&lt;/a&gt;.</source>
          <target state="translated">직렬화 필터는 &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;시스템 전체 필터&lt;/a&gt; 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d3a14fa4f45c6e41704c2ee36ac6cb02bf7a515" translate="yes" xml:space="preserve">
          <source>The serialization filter, when not &lt;code&gt;null&lt;/code&gt;, is invoked for each object (regular or class) read to reconstruct the root object. See &lt;a href=&quot;#setObjectInputFilter(java.io.ObjectInputFilter)&quot;&gt;&lt;code&gt;setObjectInputFilter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 아닌 경우 직렬화 필터 는 루트 객체를 재구성하기 위해 읽은 각 객체 (일반 또는 클래스)에 대해 호출됩니다. 자세한 내용은 &lt;a href=&quot;#setObjectInputFilter(java.io.ObjectInputFilter)&quot;&gt; &lt;code&gt;setObjectInputFilter&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd73bf37e348582139983df9cefa4606f813c326" translate="yes" xml:space="preserve">
          <source>The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an &lt;a href=&quot;invalidclassexception&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;. A serializable class can declare its own serialVersionUID explicitly by declaring a field named &lt;code&gt;&quot;serialVersionUID&quot;&lt;/code&gt; that must be static, final, and of type &lt;code&gt;long&lt;/code&gt;:</source>
          <target state="translated">직렬화 런타임은 직렬화 가능 오브젝트의 송신자 및 수신자가 직렬화와 호환되는 해당 오브젝트에 대해 클래스를로드했는지 검증하기 위해 직렬화 해제 중에 사용되는 직렬 버전 UID라고하는 버전 번호를 각 직렬화 가능 클래스와 연관시킵니다. 수신자가 해당 송신자의 클래스와 다른 serialVersionUID를 가진 객체에 대한 클래스를로드 한 경우 역 직렬화로 인해 &lt;a href=&quot;invalidclassexception&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; &lt;/a&gt; 이 발생합니다 . 직렬화 가능 클래스는 정적, 최종 및 &lt;code&gt;long&lt;/code&gt; 유형이어야하는 &lt;code&gt;&quot;serialVersionUID&quot;&lt;/code&gt; 라는 필드를 선언하여 고유 한 serialVersionUID를 명시 적으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae097a868679cbc698e55bf19085a91cd00d50c7" translate="yes" xml:space="preserve">
          <source>The serialver tool</source>
          <target state="translated">시리얼 버 도구</target>
        </trans-unit>
        <trans-unit id="72c82fbb03fb7e60a420ba06895a6063d87792bd" translate="yes" xml:space="preserve">
          <source>The server side might use the following variation of this source:</source>
          <target state="translated">서버 측은이 소스의 다음 변형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b7ba8d6780756feb02181d1f3b8e6bc1232ed3" translate="yes" xml:space="preserve">
          <source>The server was able to connect to the output device (or is always connected), but was unable to get a response from the output device.</source>
          <target state="translated">서버가 출력 장치에 연결할 수 있었거나 항상 연결되어 있었지만 출력 장치에서 응답을받을 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="7fc00d2c6bd145d9268cc5b5645d6faef5160f5c" translate="yes" xml:space="preserve">
          <source>The server-side sort control's assigned object identifier is 1.2.840.113556.1.4.473.</source>
          <target state="translated">서버 측 정렬 컨트롤의 할당 된 개체 식별자는 1.2.840.113556.1.4.473입니다.</target>
        </trans-unit>
        <trans-unit id="683960c5bca78c73afa4105fa8def718cb10bbd7" translate="yes" xml:space="preserve">
          <source>The server-side sort response control's assigned object identifier is 1.2.840.113556.1.4.474.</source>
          <target state="translated">서버 측 정렬 응답 제어의 지정된 오브젝트 ID는 1.2.840.113556.1.4.474입니다.</target>
        </trans-unit>
        <trans-unit id="99ea3539e9368c270061c3ac165425c2cc085eda" translate="yes" xml:space="preserve">
          <source>The service class must be one of the service types listed in the class specification. If it is not, &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">서비스 클래스는 클래스 사양에 나열된 서비스 유형 중 하나 여야합니다. 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="339bce1745ff0ddf550af41337f79c273e458f7f" translate="yes" xml:space="preserve">
          <source>The service named has been registered. getService requests for this service may now be made.</source>
          <target state="translated">이름이 지정된 서비스가 등록되었습니다. 이 서비스에 대한 getService 요청이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df31dfe1040963f739d9dbd1f8945217536f695" translate="yes" xml:space="preserve">
          <source>The service named has been revoked. getService requests for this service will no longer be satisfied.</source>
          <target state="translated">이름이 지정된 서비스가 취소되었습니다. 이 서비스에 대한 getService 요청은 더 이상 충족되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2312f997c09c219c1c3cc983985a51f259efd5c0" translate="yes" xml:space="preserve">
          <source>The service principal name is the canonical name of the &lt;code&gt;KerberosPrincipal&lt;/code&gt; supplying the service, that is the KerberosPrincipal represents a Kerberos service principal. This name is treated in a case sensitive manner. An asterisk may appear by itself, to signify any service principal.</source>
          <target state="translated">서비스 주체 이름은 서비스를 제공하는 &lt;code&gt;KerberosPrincipal&lt;/code&gt; 의 정식 이름입니다. 즉, KerberosPrincipal은 Kerberos 서비스 주체를 나타냅니다. 이 이름은 대소 문자를 구분하여 처리됩니다. 서비스 주체를 나타 내기 위해 별표 만 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb5c3ef3ec84e9aaec370cd0ee1bf641ca69144" translate="yes" xml:space="preserve">
          <source>The service provider cannot be loaded.</source>
          <target state="translated">서비스 제공 업체를로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82991bdbc004754a76d1b3ab1788eba153946852" translate="yes" xml:space="preserve">
          <source>The service provider class file has more than one public static no-args method named &quot;&lt;code&gt;provider&lt;/code&gt;&quot;.</source>
          <target state="translated">서비스 공급자 클래스 파일에 &quot; &lt;code&gt;provider&lt;/code&gt; &quot; 라는 공용 정적 인수 없음 메서드가 두 개 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="6747b4a2a337f04bdc6c20288be6a874d897923c" translate="yes" xml:space="preserve">
          <source>The service provider classes are intended to be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code.</source>
          <target state="translated">서비스 제공 업체 클래스는 가볍고 빠르게로드 할 수 있도록 고안되었습니다. 이러한 인터페이스의 구현은 다른 클래스와 기본 코드에 대한 복잡한 종속성을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3138211b8863e1d6bc3cf853dd276be24d5ca1e" translate="yes" xml:space="preserve">
          <source>The service provider classes should be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code. The usual pattern for more complex services is to register a lightweight proxy for the heavyweight service.</source>
          <target state="translated">서비스 공급자 클래스는 가볍고 빠르게로드되어야합니다. 이러한 인터페이스의 구현은 다른 클래스와 네이티브 코드에 대한 복잡한 종속성을 피해야합니다. 더 복잡한 서비스의 일반적인 패턴은 무거운 서비스에 대해 경량 프록시를 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f444b1559da4e9d86d6d648069e2d0a6eeb225b7" translate="yes" xml:space="preserve">
          <source>The service provider classes should be to be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code. The usual pattern for more complex services is to register a lightweight proxy for the heavyweight service.</source>
          <target state="translated">서비스 제공 업체 클래스는 가볍고 빠르게로드되어야합니다. 이러한 인터페이스의 구현은 다른 클래스와 기본 코드에 대한 복잡한 종속성을 피해야합니다. 보다 복잡한 서비스의 일반적인 패턴은 헤비급 서비스를위한 경량 프록시를 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="608ee288ee27216e454b0a3a685e8712eeefa3ae" translate="yes" xml:space="preserve">
          <source>The service provider declares a provider method and it fails by returning &lt;code&gt;null&lt;/code&gt; or throwing an exception.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하고 &lt;code&gt;null&lt;/code&gt; 을 반환 하거나 예외를 throw하여 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="76904639c98eb74089f8e96e6ac7feed61ec1c9f" translate="yes" xml:space="preserve">
          <source>The service provider declares a public static no-args method named &quot;provider&quot; with a return type that is not assignable to the service's interface or class.</source>
          <target state="translated">서비스 공급자는 서비스의 인터페이스 또는 클래스에 할당 할 수없는 반환 유형을 사용하여 &quot;provider&quot;라는 공용 정적 인수 없음 메서드를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="e899262ca235e8c71b29084806db99b3aa3bd13b" translate="yes" xml:space="preserve">
          <source>The service provider does not declare a provider method, and either it is not assignable to the service's interface/class or does not have a provider constructor.</source>
          <target state="translated">서비스 공급자는 공급자 메서드를 선언하지 않으며 서비스의 인터페이스 / 클래스에 할당 할 수 없거나 공급자 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cd0a169a020016b59c9011b24d88a2afce8a08a" translate="yes" xml:space="preserve">
          <source>The service provider does not declare a provider method, and its provider constructor fails by throwing an exception.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하지 않고 공급자 생성자가 예외를 throw하여 실패합니다.</target>
        </trans-unit>
        <trans-unit id="39722a75ad6a5d7f9c535e0c0bae2bb029dadcb9" translate="yes" xml:space="preserve">
          <source>The service provider for &lt;code&gt;ctx&lt;/code&gt; uses a state factory to obtain the state of &lt;code&gt;printer&lt;/code&gt; for binding into its namespace. A state factory for the &lt;code&gt;Printer&lt;/code&gt; type object might return a more compact object for storage in the naming system.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 의 서비스 공급자 는 상태 팩토리를 사용하여 네임 스페이스에 바인딩하기위한 &lt;code&gt;printer&lt;/code&gt; 상태를 얻습니다 . &lt;code&gt;Printer&lt;/code&gt; 유형 개체 의 상태 팩토리 는 이름 지정 시스템에 저장하기 위해 더 컴팩트 한 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2f45b96a8af4cfac898c3be7b94db00df1c82f" translate="yes" xml:space="preserve">
          <source>The service provider instance is chosen as follows:</source>
          <target state="translated">서비스 공급자 인스턴스는 다음과 같이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="38127cd4aa0815400585c455d9b08bc1a04388ab" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageInputStream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageInputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 .</target>
        </trans-unit>
        <trans-unit id="1f43b817f684f623aff5dad130484f2da8b725fa" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageInputStream&lt;/code&gt;s. For more information on service provider interfaces, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageInputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 . 서비스 제공자 인터페이스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a256fe03be1948fb7463bd5c25f91b70d8bb367" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageOutputStream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageOutputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 .</target>
        </trans-unit>
        <trans-unit id="baa871f87fb50e99d06890cf145ed5a968d9d468" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageOutputStream&lt;/code&gt;s. For more information on service provider interfaces, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageOutputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 . 서비스 제공자 인터페이스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="237770f3170d2d602f3c067509f29ea8083b1e81" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageReader&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageReader&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)</target>
        </trans-unit>
        <trans-unit id="45ed743b0330766c9e4bf1587f45b4bca8c763dd" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageReader&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageReader&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI) 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdf130a89b8ecdd0fc56c8841a6256d234f7b1d5" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageTranscoder&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageTranscoder&lt;/code&gt; 의 SPI (Service Provider Interface)입니다 .</target>
        </trans-unit>
        <trans-unit id="4e56bbbc7919ab4d22d10e83ee3380885f3821d8" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageTranscoder&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageTranscoder&lt;/code&gt; 의 SPI (Service Provider Interface)입니다 . 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="967704522c5f16add19f7f3f928885832f2dc066" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageWriter&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageWriter&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)</target>
        </trans-unit>
        <trans-unit id="59d3345b89b02c0a3b5eb368b40b37277fb4680d" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageWriter&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageWriter&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI) 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d312587539e81ed58f42177944ea87bb18494524" translate="yes" xml:space="preserve">
          <source>The service provider package allows different implementations to be plugged in dynamically. These different implementations include those for the &lt;em&gt;initial context&lt;/em&gt;, and implementations for contexts that can be reached from the initial context.</source>
          <target state="translated">서비스 제공자 패키지를 사용하면 다양한 구현을 동적으로 연결할 수 있습니다. 이러한 다른 구현에는 &lt;em&gt;초기 컨텍스트에&lt;/em&gt; 대한 구현과 &lt;em&gt;초기 컨텍스트&lt;/em&gt; 에서 도달 할 수있는 &lt;em&gt;컨텍스트에&lt;/em&gt; 대한 구현이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a98e2ef3c24a3f8bc1edb7be60c8b0ba1c2ff65d" translate="yes" xml:space="preserve">
          <source>The service provider package provides support for implementors of the &lt;code&gt;javax.naming.Context.lookup()&lt;/code&gt; method and related methods to return Java objects that are natural and intuitive for the Java programmer. For example, when looking up a printer name from the directory, it is natural for you to expect to get back a printer object on which to operate.</source>
          <target state="translated">서비스 제공자 패키지는 &lt;code&gt;javax.naming.Context.lookup()&lt;/code&gt; 메소드 의 구현 자 및 관련 메소드를 지원하여 Java 프로그래머에게 자연스럽고 직관적 인 Java 오브젝트를 리턴합니다. 예를 들어, 디렉토리에서 프린터 이름을 검색 할 때 작동 할 프린터 개체를 되 찾을 것으로 예상하는 것은 당연합니다.</target>
        </trans-unit>
        <trans-unit id="81e08ce13e4bc1e787c03d053631be4ab8564f41" translate="yes" xml:space="preserve">
          <source>The service provider.</source>
          <target state="translated">서비스 제공자.</target>
        </trans-unit>
        <trans-unit id="37af36e76b9cf4fce8d917861e80abd5df5d0dad" translate="yes" xml:space="preserve">
          <source>The service type &lt;code&gt;Provider&lt;/code&gt; is reserved for use by the security framework. Services of this type cannot be added, removed, or modified by applications. The following attributes are automatically placed in each Provider object:</source>
          <target state="translated">서비스 유형 &lt;code&gt;Provider&lt;/code&gt; 는 보안 프레임 워크에서 사용하도록 예약되어 있습니다. 이 유형의 서비스는 응용 프로그램에서 추가, 제거 또는 수정할 수 없습니다. 다음 속성은 각 제공자 오브젝트에 자동으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="b78ad8bf21cd550da7623c37d70d45b0515dd961" translate="yes" xml:space="preserve">
          <source>The service type is in a &lt;code&gt;spi&lt;/code&gt; subpackage as it may be packaged in a module separate from the resource bundle providers. For example, the service for a resource bundle named &lt;code&gt;com.example.app.MyResources&lt;/code&gt; must be &lt;code&gt;com.example.app.spi.MyResourcesProvider&lt;/code&gt;:</source>
          <target state="translated">서비스 유형은 리소스 번들 공급자와는 별도의 모듈로 패키지화 될 수 있으므로 &lt;code&gt;spi&lt;/code&gt; 하위 패키지에 있습니다. 예를 들어, 자원 번들의 이름에 대한 서비스 &lt;code&gt;com.example.app.MyResources&lt;/code&gt; 는 해야 &lt;code&gt;com.example.app.spi.MyResourcesProvider&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="462d23cf2b980e00ea9308bfd5172025ae0208b0" translate="yes" xml:space="preserve">
          <source>The service will throw a &lt;code&gt;PrintException&lt;/code&gt; if the cancellation did not succeed. A job which has not yet been submitted for printing should throw this exception. Cancelling an already successfully cancelled Print Job is not considered an error and will always succeed.</source>
          <target state="translated">취소가 성공하지 못한 경우 서비스는 &lt;code&gt;PrintException&lt;/code&gt; 을 발생시킵니다. 아직 인쇄를 위해 제출되지 않은 작업은이 예외를 발생시켜야합니다. 이미 성공적으로 취소 된 인쇄 작업을 취소하는 것은 오류로 간주되지 않으며 항상 성공합니다.</target>
        </trans-unit>
        <trans-unit id="3e064776c20c4d1bdfca5a291b86a1d978043bc3" translate="yes" xml:space="preserve">
          <source>The service will throw a PrintException if the cancellation did not succeed. A job which has not yet been submitted for printing should throw this exception. Cancelling an already successfully cancelled Print Job is not considered an error and will always succeed.</source>
          <target state="translated">취소에 실패하면 서비스에서 PrintException이 발생합니다. 아직 인쇄를 위해 제출되지 않은 작업은이 예외를 발생시켜야합니다. 이미 성공적으로 취소 된 인쇄 작업을 취소하는 것은 오류로 간주되지 않으며 항상 성공합니다.</target>
        </trans-unit>
        <trans-unit id="7d9cc09e14462c6647d9a6c4a38c382e9755d701" translate="yes" xml:space="preserve">
          <source>The session has been locked/unlocked.</source>
          <target state="translated">세션이 잠금 / 잠금 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="00fd623a86061c4531c2be6803ace8d3954aef8e" translate="yes" xml:space="preserve">
          <source>The session was connected/disconnected to the console terminal.</source>
          <target state="translated">세션이 콘솔 터미널에 연결 / 연결 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3cfa1527f162db4e68a86de541d7adab335ef3f" translate="yes" xml:space="preserve">
          <source>The session was connected/disconnected to the remote terminal.</source>
          <target state="translated">세션이 원격 터미널에 연결 / 연결 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="5c8bbfd75efcc20ccff9db728df43aa79026640f" translate="yes" xml:space="preserve">
          <source>The set includes a dependency on &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; when this module is not named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;. If this module is an automatic module then it does not have a dependency on any module other than &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;.</source>
          <target state="translated">이 모듈의 이름이 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 가 아닌 경우 세트에는 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 에 대한 종속성이 포함됩니다 . 이 모듈이 자동 모듈 인 경우 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 이외의 모듈에 대한 종속성이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b64d278b964f5fb0f174b56402a1688783011c63" translate="yes" xml:space="preserve">
          <source>The set is &lt;a href=&quot;#ksc&quot;&gt;safe&lt;/a&gt; for use by multiple concurrent threads.</source>
          <target state="translated">이 집합은 여러 동시 스레드에서 사용하기에 &lt;a href=&quot;#ksc&quot;&gt;안전&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="939369237a0093ae8b76203fbafeae8ecee1df1c" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own &lt;code&gt;remove&lt;/code&gt; operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt;, and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 반복자 자신의 &lt;code&gt;remove&lt;/code&gt; 작업을 제외하고 집합에 대한 반복이 진행되는 동안 맵이 수정되면 반복 결과는 정의되지 않습니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 오퍼레이션을 통해 맵에서 해당 맵핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="08401de134cf52abcaf1f8af2a1683d7c74313a4" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own &lt;code&gt;remove&lt;/code&gt; operation, or through the &lt;code&gt;setValue&lt;/code&gt; operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 반복자 자신의 &lt;code&gt;remove&lt;/code&gt; 작업 또는 반복자가 반환 한 맵 항목 의 &lt;code&gt;setValue&lt;/code&gt; 작업을 제외하고 집합에 대한 반복이 진행되는 동안 맵이 수정되면 반복 결과가 정의되지 않습니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 작업을 통해 맵에서 해당 매핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="852ef9de08250d48c0d0fc367b3fbed7a9bf4099" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 작업을 통해 맵에서 해당 매핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="335b178dce95c35bddb6f9a6dfbb5dbd684f0d11" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt;, and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 오퍼레이션을 통해 맵에서 해당 맵핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6f4f2cfd47ef65402bf2cd171ee3694a2946949e" translate="yes" xml:space="preserve">
          <source>The set is created the first time this method is called, and returned in response to all subsequent calls. No synchronization is performed, so there is a slight chance that multiple calls to this method will not all return the same set.</source>
          <target state="translated">이 메소드는이 메소드가 처음 호출 될 때 작성되며 모든 후속 호출에 대한 응답으로 리턴됩니다. 동기화가 수행되지 않으므로이 메소드에 대한 여러 호출이 모두 동일한 세트를 리턴하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c6dbb0140fcb03f42d68d9b039f3ccf70fab2f5" translate="yes" xml:space="preserve">
          <source>The set of Unicode locale keys, or the empty set if this locale has no Unicode locale keywords.</source>
          <target state="translated">유니 코드 로캘 키 집합이거나이 로캘에 유니 코드 로캘 키워드가없는 경우 빈 집합입니다.</target>
        </trans-unit>
        <trans-unit id="420b44f1196d7d8713b274baff300cd1830c3000" translate="yes" xml:space="preserve">
          <source>The set of access modes that specify how a variable, referenced by a VarHandle, is accessed.</source>
          <target state="translated">VarHandle에서 참조하는 변수에 액세스하는 방법을 지정하는 액세스 모드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="03d9f1bf0b7313c94bfc617aaf5a0c81cfb6185f" translate="yes" xml:space="preserve">
          <source>The set of all legal URI characters consists of the</source>
          <target state="translated">모든 유효한 URI 문자 세트는</target>
        </trans-unit>
        <trans-unit id="6452b41f9aa8aa9467f2200dc381d1cdeab705b6" translate="yes" xml:space="preserve">
          <source>The set of all module references that this finder locates</source>
          <target state="translated">이 파인더가 찾는 모든 모듈 참조 세트</target>
        </trans-unit>
        <trans-unit id="621a29c69b103747e0b5a4f9c4564c47401600b9" translate="yes" xml:space="preserve">
          <source>The set of attributes.</source>
          <target state="translated">속성 세트</target>
        </trans-unit>
        <trans-unit id="3f9639f8c60c46f82dff9817fb5e46940cb7b600" translate="yes" xml:space="preserve">
          <source>The set of available chronologies can be extended by applications. Adding a new calendar system requires the writing of an implementation of &lt;code&gt;Chronology&lt;/code&gt;, &lt;code&gt;ChronoLocalDate&lt;/code&gt; and &lt;code&gt;Era&lt;/code&gt;. The majority of the logic specific to the calendar system will be in the &lt;code&gt;ChronoLocalDate&lt;/code&gt; implementation. The &lt;code&gt;Chronology&lt;/code&gt; implementation acts as a factory.</source>
          <target state="translated">사용 가능한 연대기 세트는 애플리케이션에 의해 확장 될 수 있습니다. 새 달력 시스템을 추가하려면 &lt;code&gt;Chronology&lt;/code&gt; , &lt;code&gt;ChronoLocalDate&lt;/code&gt; 및 &lt;code&gt;Era&lt;/code&gt; 를 구현해야합니다 . 달력 시스템과 관련된 대부분의 논리는 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 구현에 있습니다. &lt;code&gt;Chronology&lt;/code&gt; 구현은 공장 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="cb548aee392f5b54ce790b2cd4397125011cb980" translate="yes" xml:space="preserve">
          <source>The set of available filters is dependent on the event request, some examples of filters are:</source>
          <target state="translated">사용 가능한 필터 세트는 이벤트 요청에 따라 다르며 필터의 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2e9447eb9ee970654c805a676dce29fdcfb735b" translate="yes" xml:space="preserve">
          <source>The set of bindings used to create the keymap is fetched from the UIManager using a key formed by combining the &lt;a href=&quot;#getPropertyPrefix()&quot;&gt;&lt;code&gt;getPropertyPrefix()&lt;/code&gt;&lt;/a&gt; method and the string &lt;code&gt;.keyBindings&lt;/code&gt;. The type is expected to be &lt;code&gt;JTextComponent.KeyBinding[]&lt;/code&gt;.</source>
          <target state="translated">키맵을 만드는 데 사용되는 바인딩 집합은 &lt;a href=&quot;#getPropertyPrefix()&quot;&gt; &lt;code&gt;getPropertyPrefix()&lt;/code&gt; &lt;/a&gt; 메서드와 문자열 &lt;code&gt;.keyBindings&lt;/code&gt; 를 결합하여 형성된 키를 사용하여 UIManager에서 가져옵니다 . 유형은 &lt;code&gt;JTextComponent.KeyBinding[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="681a49f0545cead8f88402e7d9a0b8bf02da8310" translate="yes" xml:space="preserve">
          <source>The set of categories supported by this class is limited to the following standard Image I/O service types:</source>
          <target state="translated">이 클래스에서 지원하는 범주 집합은 다음 표준 이미지 I / O 서비스 유형으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="72c91458b3846bafb66088203a2752b0abccf720" translate="yes" xml:space="preserve">
          <source>The set of class options that specify whether a hidden class created by &lt;a href=&quot;#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt;&lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt;&lt;/a&gt; method is dynamically added as a new member to the nest of a lookup class and/or whether a hidden class has a strong relationship with the class loader marked as its defining loader.</source>
          <target state="translated">&lt;a href=&quot;#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt; &lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성 된 히든 클래스 가 조회 클래스의 중첩에 새 멤버로 동적으로 추가되는지 여부 및 / 또는 히든 클래스가로 표시된 클래스 로더와 강력한 관계를 갖는지 여부를 지정하는 클래스 옵션 세트입니다. 로더 정의.</target>
        </trans-unit>
        <trans-unit id="651fe013855f1c7ef2e80301da1cf9f1fe1b713c" translate="yes" xml:space="preserve">
          <source>The set of class options that specify whether a hidden class created by &lt;a href=&quot;methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt;&lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt;&lt;/a&gt; method is dynamically added as a new member to the nest of a lookup class and/or whether a hidden class has a strong relationship with the class loader marked as its defining loader.</source>
          <target state="translated">&lt;a href=&quot;methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt; &lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성 된 히든 클래스 가 조회 클래스의 중첩에 새 멤버로 동적으로 추가되는지 여부 및 / 또는 히든 클래스가로 표시된 클래스 로더와 강력한 관계를 갖는지 여부를 지정하는 클래스 옵션 세트입니다. 로더 정의.</target>
        </trans-unit>
        <trans-unit id="b989013791c04777bdc8434807fe06cb2e6445b2" translate="yes" xml:space="preserve">
          <source>The set of classes that make up the package may implement a particular specification and if so the specification title, version number, and vendor strings identify that specification. An application can ask if the package is compatible with a particular version, see the &lt;a href=&quot;package#isCompatibleWith-java.lang.String-&quot;&gt;&lt;code&gt;isCompatibleWith&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">패키지를 구성하는 클래스 세트는 특정 사양을 구현할 수 있으므로 사양 제목, 버전 번호 및 공급 업체 문자열이 해당 사양을 식별합니다. 응용 프로그램은 패키지가 특정 버전과 호환되는지 묻습니다 . 자세한 내용은 &lt;a href=&quot;package#isCompatibleWith-java.lang.String-&quot;&gt; &lt;code&gt;isCompatibleWith&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e76b0b3c09cccc2eda6d0f3d42ddad87d8c8d18" translate="yes" xml:space="preserve">
          <source>The set of classes that make up the run-time package may implement a particular specification. The specification title, version, and vendor (indicating the owner/maintainer of the specification) can be provided when the &lt;code&gt;Package&lt;/code&gt; is defined. An application can ask if the &lt;code&gt;Package&lt;/code&gt; is compatible with a particular specification version by using the &lt;a href=&quot;#isCompatibleWith(java.lang.String)&quot;&gt;&lt;code&gt;Package.isCompatibleWith(String)&lt;/code&gt;&lt;/a&gt; method. In addition, information about the actual classes that make up the run-time package can be provided when the Package is defined. This information consists of an implementation title, version, and vendor (indicating the supplier of the classes).</source>
          <target state="translated">런타임 패키지를 구성하는 클래스 집합은 특정 사양을 구현할 수 있습니다. &lt;code&gt;Package&lt;/code&gt; 를 정의 할 때 사양 제목, 버전 및 공급 업체 (사양의 소유자 / 관리자를 나타냄)를 제공 할 수 있습니다 . 애플리케이션은 &lt;a href=&quot;#isCompatibleWith(java.lang.String)&quot;&gt; &lt;code&gt;Package.isCompatibleWith(String)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 &lt;code&gt;Package&lt;/code&gt; 가 특정 사양 버전과 호환되는지 물어볼 수 있습니다 . 또한 패키지 정의시 런타임 패키지를 구성하는 실제 클래스에 대한 정보를 제공 할 수 있습니다. 이 정보는 구현 제목, 버전 및 공급 업체 (클래스 공급자를 나타냄)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd487059260b770e35e4c25b3c8267f64420d5bc" translate="yes" xml:space="preserve">
          <source>The set of defaults a particular look and feel supports is defined and documented by that look and feel. In addition, each look and feel, or &lt;code&gt;ComponentUI&lt;/code&gt; provided by a look and feel, may access the defaults at different times in their life cycle. Some look and feels may aggressively look up defaults, so that changing a default may not have an effect after installing the look and feel. Other look and feels may lazily access defaults so that a change to the defaults may effect an existing look and feel. Finally, other look and feels might not configure themselves from the defaults table in any way. None-the-less it is usually the case that a look and feel expects certain defaults, so that in general a &lt;code&gt;ComponentUI&lt;/code&gt; provided by one look and feel will not work with another look and feel.</source>
          <target state="translated">특정 룩앤필이 지원하는 기본값 세트는 해당 룩앤필에 의해 정의되고 문서화됩니다. 또한 각 룩앤필 또는 룩앤필에서 제공하는 &lt;code&gt;ComponentUI&lt;/code&gt; 는 수명주기의 다른 시간에 기본값에 액세스 할 수 있습니다. 일부 룩앤필은 기본값을 적극적으로 조회 할 수 있으므로 룩앤필을 설치 한 후 기본값을 변경해도 효과가 없을 수 있습니다. 다른 모양과 느낌은 기본값에 느리게 액세스 할 수 있으므로 기본값을 변경하면 기존 모양과 느낌에 영향을 미칠 수 있습니다. 마지막으로, 다른 룩앤필은 어떤 방식 으로든 기본값 테이블에서 자체적으로 구성되지 않을 수 있습니다. 그럼에도 불구하고 일반적으로 룩앤필은 특정 기본값을 예상하므로 일반적 으로 한 룩앤필에서 제공 하는 &lt;code&gt;ComponentUI&lt;/code&gt; 는 다른 룩앤필에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8566d5bad5a6af80ccaae4ebc526f12877ada443" translate="yes" xml:space="preserve">
          <source>The set of delimiters (the characters that separate tokens) may be specified either at creation time or on a per-token basis.</source>
          <target state="translated">구분자 세트 (토큰을 분리하는 문자)는 작성시 또는 토큰별로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cfc5f58aa65a6eb138573039e7e6c8ed576bdaf" translate="yes" xml:space="preserve">
          <source>The set of destination bands to be used, as an array of &lt;code&gt;int&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 의 배열로 사용할 대상 밴드 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="7bdff17e6129a79d93316f1c821db4d8f82ede91" translate="yes" xml:space="preserve">
          <source>The set of destination bands to be used, as an array of &lt;code&gt;int&lt;/code&gt;s. By default, the value is &lt;code&gt;null&lt;/code&gt;, indicating all destination bands should be written in order.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 배열로서 사용되는 목적지 밴드 세트입니다 . 기본적으로 값은 &lt;code&gt;null&lt;/code&gt; 이며 모든 대상 밴드를 순서대로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="86fb7d781b8180b73ea69252e860cc7647d23a17" translate="yes" xml:space="preserve">
          <source>The set of elements specified by the user are considered to be &lt;em&gt;specified elements&lt;/em&gt;. Specified elements provide the starting points for determining the &lt;em&gt;included elements&lt;/em&gt; to be documented.</source>
          <target state="translated">사용자가 지정한 요소 집합은 &lt;em&gt;지정된 요소&lt;/em&gt; 로 간주됩니다 . 지정된 요소는 문서화 할 &lt;em&gt;포함 된 요소&lt;/em&gt; 를 결정하기위한 시작점을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5b084606f5dbb7234dbaaff078b54b1db5148b15" translate="yes" xml:space="preserve">
          <source>The set of elements that can occur inside the element</source>
          <target state="translated">요소 내부에서 발생할 수있는 요소 집합</target>
        </trans-unit>
        <trans-unit id="b6dca056975449aabae25e6f632010d1fc2e0826" translate="yes" xml:space="preserve">
          <source>The set of elements that must not occur inside the element</source>
          <target state="translated">요소 내부에 있으면 안되는 요소 집합</target>
        </trans-unit>
        <trans-unit id="729a1180bc7c2901cd889e8f040bc5045cacfb92" translate="yes" xml:space="preserve">
          <source>The set of events may include additional implementation specific event that are not defined by the enum &lt;a href=&quot;standardwatcheventkinds&quot;&gt;&lt;code&gt;StandardWatchEventKinds&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이벤트 세트에는 열거 형 &lt;a href=&quot;standardwatcheventkinds&quot;&gt; &lt;code&gt;StandardWatchEventKinds&lt;/code&gt; 에&lt;/a&gt; 의해 정의되지 않은 추가 구현 특정 이벤트가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c728dd3ce97aa1a197697a57af717e73be26f0b" translate="yes" xml:space="preserve">
          <source>The set of extension keys, or the empty set if this locale has no extensions.</source>
          <target state="translated">확장 키 세트 또는이 로케일에 확장이없는 경우 비어있는 세트.</target>
        </trans-unit>
        <trans-unit id="1ca105b2eec11893f8655aa15ad8f33d78fa091c" translate="yes" xml:space="preserve">
          <source>The set of formats may differ according to the particular images being read or written; this method should indicate all the additional formats supported by the plug-in under any circumstances.</source>
          <target state="translated">형식 세트는 읽거나 쓰는 특정 이미지에 따라 다를 수 있습니다. 이 방법은 어떤 상황에서도 플러그인이 지원하는 모든 추가 형식을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6298735c68384e5ce50faeb99e64508afa7e2cb" translate="yes" xml:space="preserve">
          <source>The set of icons and colors used by &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; can be configured using the various setter methods. The value for each property is initialized from the defaults table. When the look and feel changes (&lt;code&gt;updateUI&lt;/code&gt; is invoked), any properties that have a value of type &lt;code&gt;UIResource&lt;/code&gt; are refreshed from the defaults table. The following table lists the mapping between &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; property and defaults table key:</source>
          <target state="translated">&lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; 에서 사용하는 아이콘 및 색상 세트 는 다양한 setter 메소드를 사용하여 구성 할 수 있습니다. 각 속성의 값은 기본값 테이블에서 초기화됩니다. 룩앤필이 변경되면 ( &lt;code&gt;updateUI&lt;/code&gt; 가 호출 됨) &lt;code&gt;UIResource&lt;/code&gt; 유형의 값을 가진 모든 특성이 기본값 테이블에서 새로 고쳐집니다. 다음 표에는 &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; 속성과 기본값 테이블 키 간의 매핑이 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3d89520f73d19bfe68e399e47cbe902639a37fe" translate="yes" xml:space="preserve">
          <source>The set of observable modules at both compile-time and run-time is determined by searching several different paths, and also by searching the compiled modules built in to the environment. The search order is as follows:</source>
          <target state="translated">컴파일 타임과 런타임 모두에서 관찰 가능한 모듈 세트는 여러 다른 경로를 검색하고 환경에 내장 된 컴파일 된 모듈을 검색하여 결정됩니다. 검색 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d0d29b95d763e2af0d05f2e532dc0d00a275aa0" translate="yes" xml:space="preserve">
          <source>The set of packages in the module are accumulated by the &lt;code&gt;
 Builder&lt;/code&gt; as the &lt;a href=&quot;#exports(java.lang.String)&quot;&gt;&lt;code&gt;exports&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#opens(java.lang.String)&quot;&gt;&lt;code&gt;opens&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#packages(java.util.Set)&quot;&gt;&lt;code&gt;packages&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#provides(java.lang.String,java.util.List)&quot;&gt;&lt;code&gt;provides&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#mainClass(java.lang.String)&quot;&gt;&lt;code&gt;mainClass&lt;/code&gt;&lt;/a&gt; methods are invoked.</source>
          <target state="translated">모듈의 패키지 세트가 축적된다 &lt;code&gt; Builder&lt;/code&gt; 는 AS &lt;a href=&quot;#exports(java.lang.String)&quot;&gt; &lt;code&gt;exports&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#opens(java.lang.String)&quot;&gt; &lt;code&gt;opens&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#packages(java.util.Set)&quot;&gt; &lt;code&gt;packages&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#provides(java.lang.String,java.util.List)&quot;&gt; &lt;code&gt;provides&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mainClass(java.lang.String)&quot;&gt; &lt;code&gt;mainClass&lt;/code&gt; 의&lt;/a&gt; 방법은 호출된다.</target>
        </trans-unit>
        <trans-unit id="af1c485e3af079d0e0b924f990daf5f80d7e2329" translate="yes" xml:space="preserve">
          <source>The set of packages in the module is derived from the non-directory entries in the JAR file that have names ending in &quot;&lt;code&gt;.class&lt;/code&gt;&quot;. A candidate package name is derived from the name using the characters up to, but not including, the last forward slash. All remaining forward slashes are replaced with dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;). If the resulting string is a legal package name then it is assumed to be a package name. For example, if the JAR file contains the entry &quot;&lt;code&gt;p/q/Foo.class&lt;/code&gt;&quot; then the package name derived is &quot;&lt;code&gt;p.q&lt;/code&gt;&quot;.</source>
          <target state="translated">모듈의 패키지 세트는 이름이 &quot; &lt;code&gt;.class&lt;/code&gt; &quot;로 끝나는 JAR 파일의 비 디렉토리 항목에서 파생됩니다 . 후보 패키지 이름은 마지막 슬래시를 포함하지 않는 문자를 사용하여 이름에서 파생됩니다. 나머지 모든 슬래시는 점 ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; )으로 대체됩니다 . 결과 문자열이 올바른 패키지 이름이면 패키지 이름으로 간주됩니다. 예를 들어, JAR 파일에 &quot; &lt;code&gt;p/q/Foo.class&lt;/code&gt; &quot; 항목이 포함 된 경우 파생 된 패키지 이름은 &quot; &lt;code&gt;p.q&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="bb27f124976a9cb1da8caffebba927a6c5a0a2ee" translate="yes" xml:space="preserve">
          <source>The set of packages includes all exported and open packages, as well as the packages of any service providers, and the package for the main class.</source>
          <target state="translated">패키지 세트에는 모든 내 보낸 패키지와 열려있는 패키지는 물론 서비스 공급자의 패키지와 기본 클래스 용 패키지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="10d94f3aa7e712fbe40291f913b08a2062951f72" translate="yes" xml:space="preserve">
          <source>The set of parameters defined here may not include all aspects of reverberation as specified by some systems. For example, the Midi Manufacturer's Association (MMA) has an Interactive Audio Special Interest Group (IASIG), which has a 3-D Working Group that has defined a Level 2 Spec (I3DL2). I3DL2 supports filtering of reverberation and control of reverb density. These properties are not included in the JavaSound 1.0 definition of a reverb control. In such a case, the implementing system should either extend the defined reverb control to include additional parameters, or else interpret the system's additional capabilities in a way that fits the model described here.</source>
          <target state="translated">여기에 정의 된 파라미터 세트는 일부 시스템에 의해 지정된 잔향의 모든 측면을 포함하지 않을 수 있습니다. 예를 들어 MMA (Midi Manufacturer 's Association)에는 IASL2 (Interactive Audio Special Interest Group)가 있으며,이 그룹에는 I2DL2 (Level 2 Spec)를 정의한 3D 작업 그룹이 있습니다. I3DL2는 잔향 필터링 및 잔향 밀도 제어를 지원합니다. 이러한 속성은 리버브 컨트롤의 JavaSound 1.0 정의에 포함되어 있지 않습니다. 이 경우 구현 시스템은 정의 된 리버브 컨트롤을 확장하여 추가 파라미터를 포함 시키거나 여기에 설명 된 모델에 맞는 방식으로 시스템의 추가 기능을 해석해야합니다.</target>
        </trans-unit>
        <trans-unit id="68d403ff4ac7d3e26edbaf2a349d84bb408ad098" translate="yes" xml:space="preserve">
          <source>The set of permissions evaluated is a function of whether the ProtectionDomain was constructed with a static set of permissions or it was bound to a dynamically mapped set of permissions.</source>
          <target state="translated">평가 된 권한 집합은 ProtectionDomain이 정적 권한 집합으로 구성되었는지 또는 동적으로 매핑 된 권한 집합에 바인딩되었는지 여부의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="0b9b26c8c7dd24de7fa7e0a2e0ee1b1f709f4d4b" translate="yes" xml:space="preserve">
          <source>The set of permissions granted to the principal is then calculated using the simple rule that individual permissions always override the group permissions. That is, the principal's individual negative permission set (specific denial of permissions) overrides the group positive permission set, and the principal's individual positive permission set overrides the group negative permission set.</source>
          <target state="translated">그런 다음 보안 주체에게 부여 된 권한 집합은 개별 권한이 항상 그룹 권한보다 우선한다는 간단한 규칙을 사용하여 계산됩니다. 즉, 주체의 개별 부정적 권한 집합 (특정 권한 거부)이 그룹 긍정적 권한 집합을 재정의하고 주체의 개별 긍정적 인 권한 집합이 그룹 부정적 권한 집합을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="7c5293b4016e691dbff48573988eed608f1e59b6" translate="yes" xml:space="preserve">
          <source>The set of root modules at compile-time is usually the set of modules being compiled. At run-time, the set of root modules is usually the application module specified to the 'java' launcher. When compiling code in the unnamed module, or at run-time when the main application class is loaded from the class path, then the default set of root modules is implementation specific. In the JDK the default set of root modules contains every module that is observable on the upgrade module path or among the system modules, and that exports at least one package without qualification.</source>
          <target state="translated">컴파일 타임에 루트 모듈 세트는 일반적으로 컴파일되는 모듈 세트입니다. 런타임시 루트 모듈 세트는 일반적으로 'java'실행기에 지정된 애플리케이션 모듈입니다. 이름이 지정되지 않은 모듈에서 코드를 컴파일 할 때 또는 기본 애플리케이션 클래스가 클래스 경로에서로드되는 런타임에 루트 모듈의 기본 세트는 구현에 따라 다릅니다. JDK에서 기본 루트 모듈 세트에는 업그레이드 모듈 경로 또는 시스템 모듈 사이에서 관찰 할 수 있고 자격없이 하나 이상의 패키지를 내보내는 모든 모듈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c855c2b33fa2f72b9413d964ffae18f1b08660a6" translate="yes" xml:space="preserve">
          <source>The set of root modules, whose names are the initial input to this algorithm, is determined in an implementation specific manner. The set of root modules may include automatic modules.</source>
          <target state="translated">이름이이 알고리즘에 대한 초기 입력 인 루트 모듈 세트는 구현 특정 방식으로 결정됩니다. 루트 모듈 세트에는 자동 모듈이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5e4eed3c1a6ad50555dc5a120636aac05d2d14" translate="yes" xml:space="preserve">
          <source>The set of source bands to be read and destination bands to be written is determined by calling &lt;code&gt;getSourceBands&lt;/code&gt; and &lt;code&gt;getDestinationBands&lt;/code&gt; on the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;. If the lengths of the arrays returned by these methods differ, the set of source bands contains an index larger that the largest available source index, or the set of destination bands contains an index larger than the largest legal destination index, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">읽을 소스 밴드 세트와 기록 할 대상 밴드 는 제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에서 &lt;code&gt;getSourceBands&lt;/code&gt; 및 &lt;code&gt;getDestinationBands&lt;/code&gt; 를 호출하여 결정됩니다 . 이러한 메소드에 의해 리턴 된 배열의 길이가 다른 경우, 소스 밴드 세트에 사용 가능한 가장 큰 소스 인덱스보다 큰 인덱스가 포함되거나 목적지 밴드 세트가 가장 큰 유효한 대상 인덱스보다 큰 인덱스를 포함하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="867285dfa3b219730bb1492c7d1c6f1144979f5b" translate="yes" xml:space="preserve">
          <source>The set of supported access modes can only be made stricter (by supporting &lt;em&gt;fewer&lt;/em&gt; access modes). This means that restricting the set of access modes supported by a segment before sharing it with other clients is generally a good practice if the creator of the segment wants to retain some control over how the segment is going to be accessed.</source>
          <target state="translated">지원되는 액세스 모드 세트는 &lt;em&gt;더 적은&lt;/em&gt; 액세스 모드 를 지원함으로써 더 엄격하게 만들 수 있습니다. 즉, 다른 클라이언트와 공유하기 전에 세그먼트가 지원하는 액세스 모드 세트를 제한하는 것이 일반적으로 세그먼트 작성자가 세그먼트에 액세스하는 방법에 대한 일부 제어를 유지하려는 경우 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c6c7711952ed69b023e8f9dad86209b75e9faa4e" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; date and time fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 및 시간 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="17f958194f63b45fb85cee1d1ff860e19a4ebff9" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; date fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 필드를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="7b87b275acd5b0bbff5b52b9d09fd971743dbb82" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 필드를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="0cd5b52cb97e9595d03bfd112aa6100ad3af1552" translate="yes" xml:space="preserve">
          <source>The set of supported units is defined by the chronology and normally includes all &lt;code&gt;ChronoUnit&lt;/code&gt; date units except &lt;code&gt;FOREVER&lt;/code&gt;.</source>
          <target state="translated">지원되는 단위 집합은 시간 순서대로 정의되며 일반적으로 &lt;code&gt;FOREVER&lt;/code&gt; 를 제외한 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 날짜 단위를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="cf91e64de9db3a085379dbaade3e6f6c15d84327" translate="yes" xml:space="preserve">
          <source>The set of supported units is defined by the chronology and normally includes all &lt;code&gt;ChronoUnit&lt;/code&gt; units except &lt;code&gt;FOREVER&lt;/code&gt;.</source>
          <target state="translated">지원되는 단위 집합은 시간 순서대로 정의되며 일반적으로 &lt;code&gt;FOREVER&lt;/code&gt; 를 제외한 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 단위를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="bdc888943012a194683232c2ed49f35bebd1e353" translate="yes" xml:space="preserve">
          <source>The set of target module names or for an unqualified &lt;code&gt;Opens&lt;/code&gt;, an empty set</source>
          <target state="translated">대상 모듈 이름 세트 또는 규정되지 않은 &lt;code&gt;Opens&lt;/code&gt; 의 경우 빈 세트</target>
        </trans-unit>
        <trans-unit id="a8ac334c4e2b7db89d71bf277bf47b78996510f3" translate="yes" xml:space="preserve">
          <source>The set of target module names or for an unqualified export, an empty set</source>
          <target state="translated">대상 모듈 이름 세트 또는 규정되지 않은 내보내기의 경우 빈 세트</target>
        </trans-unit>
        <trans-unit id="6411c296dc3589a36374e8f730a51bc836538d36" translate="yes" xml:space="preserve">
          <source>The set of target module names or for an unqualified opens, an empty set</source>
          <target state="translated">대상 모듈 이름 세트 또는 규정되지 않은 열기의 경우 빈 세트</target>
        </trans-unit>
        <trans-unit id="5cec8d2be735850abe92747462139ac2c64dc724" translate="yes" xml:space="preserve">
          <source>The set of terminals supported by a TerminalFactory.</source>
          <target state="translated">TerminalFactory에서 지원하는 터미널 세트입니다.</target>
        </trans-unit>
        <trans-unit id="1eb0b192e307c8d6408074ffabaad779d8fef889" translate="yes" xml:space="preserve">
          <source>The set of terminals supported by a TerminalFactory. This class allows applications to enumerate the available CardTerminals, obtain a specific CardTerminal, or wait for the insertion or removal of cards.</source>
          <target state="translated">TerminalFactory에서 지원하는 터미널 세트입니다. 이 클래스를 사용하면 응용 프로그램이 사용 가능한 CardTerminals를 열거하거나 특정 CardTerminal을 얻거나 카드 삽입 또는 제거를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="921bf8ce163fe63c69e39a66bfba8aae02a1cc6f" translate="yes" xml:space="preserve">
          <source>The set of warnings that are to be suppressed by the compiler in the annotated element.</source>
          <target state="translated">어노테이션이있는 요소에서 컴파일러에 의해 억제 될 경고 세트입니다.</target>
        </trans-unit>
        <trans-unit id="fe5205d619c2546cedc0aae80e2949df5b42d127" translate="yes" xml:space="preserve">
          <source>The set of warnings that are to be suppressed by the compiler in the annotated element. Duplicate names are permitted. The second and successive occurrences of a name are ignored. The presence of unrecognized warning names is</source>
          <target state="translated">어노테이션이있는 요소에서 컴파일러가 억제 할 경고 세트입니다. 중복 된 이름이 허용됩니다. 두 번째로 그리고 연속적으로 나타나는 이름은 무시됩니다. 인식 할 수없는 경고 이름이 있습니다</target>
        </trans-unit>
        <trans-unit id="cf50745559139179ac02ea11a6006ec30ea95b4e" translate="yes" xml:space="preserve">
          <source>The set of zone IDs can increase over time, although in a typical application the set of IDs is fixed. Each call to this method is thread-safe.</source>
          <target state="translated">일반적인 응용 프로그램에서는 ID 집합이 고정되어 있지만 영역 ID 집합은 시간이 지남에 따라 증가 할 수 있습니다. 이 메소드에 대한 각 호출은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b28e0ecb07f1416bf310fc7c1fb31a72ea753196" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order.</source>
          <target state="translated">세트의 반복자는 오름차순 키 순서로 항목을 반환합니다. 세트의 스플리터는 또한 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를보고합니다.&lt;/a&gt; 키 순서를 오름차순으로 만나는 발생 순서와 함께 .</target>
        </trans-unit>
        <trans-unit id="f353985651bff15e75e3ef09bec38c15d74624a5" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order.</source>
          <target state="translated">The set's iterator returns the entries in ascending key order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; with an encounter order that is ascending key order.</target>
        </trans-unit>
        <trans-unit id="499442b22634bbf31c6cc45cc4b266d5e35f872c" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The sets's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order.</source>
          <target state="translated">세트의 반복자는 오름차순 키 순서로 항목을 반환합니다. 세트의 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 이며, 키 순서가 오름차순 인 발생 순서로 &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 를 추가로보고합니다 .</target>
        </trans-unit>
        <trans-unit id="57326adf471d0608ffe63f3c2ada3c27d35abf46" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order.</source>
          <target state="translated">The set's iterator returns the keys in ascending order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt;, with an encounter order that is ascending key order.</target>
        </trans-unit>
        <trans-unit id="4685b0d5732f702ab85c0ed76d92a22ff9945c14" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;../spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the map's comparator (see &lt;a href=&quot;concurrentskiplistmap#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the map's comparator.</source>
          <target state="translated">세트의 반복자는 키를 오름차순으로 반환합니다. 세트의 스플리터는 또한 키 순서를 오름차순으로 만나는 발생 순서와 함께 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를&lt;/a&gt; 보고합니다 . 맵의 비교기 ( &lt;a href=&quot;concurrentskiplistmap#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, 분할기의 비교기 ( &lt;a href=&quot;../spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기가 맵의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="2714c6b13a1764a93e6b5af72f255c2219e07aa4" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree map's comparator (see &lt;a href=&quot;sortedmap#comparator()&quot;&gt;&lt;code&gt;SortedMap.comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator.</source>
          <target state="translated">The set's iterator returns the keys in ascending order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree map's comparator (see &lt;a href=&quot;sortedmap#comparator()&quot;&gt; &lt;code&gt;SortedMap.comparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; . Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator.</target>
        </trans-unit>
        <trans-unit id="46790b7f24e0bc5b45cc4e19d698ecf9c001e4f2" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree map's comparator (see &lt;a href=&quot;treemap#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator.</source>
          <target state="translated">세트의 반복자는 키를 오름차순으로 반환합니다. 세트의 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 이며, 키 순서가 오름차순 인 발생 순서로 &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 를 추가로보고합니다 . 트리 맵의 비교 자 ( &lt;a href=&quot;treemap#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기는 트리 맵의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="a4aff37df53c764fa75784f9af7cc154baaca8cd" translate="yes" xml:space="preserve">
          <source>The setColorModel method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setColorModel method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="669f9b373a4883c6affe2d61f4ab478337d861f6" translate="yes" xml:space="preserve">
          <source>The setDimensions method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setDimensions method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="c2516eb73a401a0d51802b1215cb53ea3fcb29df" translate="yes" xml:space="preserve">
          <source>The setHints method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setHints method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="0a7737011ca3b4f6d30e5001bcd5a5d682f03093" translate="yes" xml:space="preserve">
          <source>The setPixels method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setPixels method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="253bd9282184644a5e60303ce0fbf43d67f6a7dd" translate="yes" xml:space="preserve">
          <source>The setProperties method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setProperties method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="780812be2038ec016303466bdffb453d52a56bf6" translate="yes" xml:space="preserve">
          <source>The sets of bindings and actions may be empty but must be non-&lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">The sets of bindings and actions may be empty but must be non- &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f87c627e8f563bcad46fffe662d14aaf1610d0aa" translate="yes" xml:space="preserve">
          <source>The setting control must have a default constructor that can be invoked when the event is registered.</source>
          <target state="translated">설정 컨트롤에는 이벤트가 등록 될 때 호출 할 수있는 기본 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f060c2185618cf2a6c32ef4425c5bbd1f9463f3a" translate="yes" xml:space="preserve">
          <source>The setup parameters and general request properties are manipulated.</source>
          <target state="translated">설정 매개 변수 및 일반 요청 특성이 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="e45a6b9c2d290d870eaa0f880a9a918246e71542" translate="yes" xml:space="preserve">
          <source>The setup parameters are modified using the following methods:</source>
          <target state="translated">설정 매개 변수는 다음 방법을 사용하여 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd13c7488ba25ddcfcc26fab92f485990ee6b61" translate="yes" xml:space="preserve">
          <source>The seven one-argument public constructors provided by this class ensure that the assertion error returned by the invocation:</source>
          <target state="translated">이 클래스에서 제공하는 7 개의 1 인수 공용 생성자는 호출에서 반환 된 어설 션 오류를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c50586a794dd2d03708cb38eeaec0dfc03ceb15a" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error.</target>
        </trans-unit>
        <trans-unit id="cbfb5b21f94b1f39201ec64311f786525c788517" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error. A &lt;code&gt;SEVERITY_ERROR&lt;/code&gt; may not cause the processing to stop if the error can be recovered, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error. A &lt;code&gt;SEVERITY_ERROR&lt;/code&gt; may not cause the processing to stop if the error can be recovered, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3090b59cda4a3cfaaada15e1b142bdc3aab39edc" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error.</target>
        </trans-unit>
        <trans-unit id="c3466b748260d572fcdcf4e5af7a15d80687e823" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error. A &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt; will cause the normal processing to stop. The return value of &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; is ignored unless the implementation chooses to continue, in which case the behavior becomes undefined.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error. A &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt; will cause the normal processing to stop. The return value of &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; is ignored unless the implementation chooses to continue, in which case the behavior becomes undefined.</target>
        </trans-unit>
        <trans-unit id="4dce1e66e356c13f39b0e1da4baf5b92e91bdf40" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning.</target>
        </trans-unit>
        <trans-unit id="faecc9cb5575ec0247ec8c48b1fbdcc24296de12" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning. A &lt;code&gt;SEVERITY_WARNING&lt;/code&gt; will not cause the processing to stop, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning. A &lt;code&gt;SEVERITY_WARNING&lt;/code&gt; will not cause the processing to stop, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6683228de459fdaf28b8a641613d107e9fd7efe" translate="yes" xml:space="preserve">
          <source>The severity of the error, either &lt;code&gt;SEVERITY_WARNING&lt;/code&gt;, &lt;code&gt;SEVERITY_ERROR&lt;/code&gt;, or &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt;.</source>
          <target state="translated">The severity of the error, either &lt;code&gt;SEVERITY_WARNING&lt;/code&gt; , &lt;code&gt;SEVERITY_ERROR&lt;/code&gt; , or &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1d146216a151be9f0ea1c3654e3497f9a52dbb" translate="yes" xml:space="preserve">
          <source>The severity of this notification. It can be 0 to mean unknown severity or a value from 1 to 6 representing decreasing levels of severity. It can be represented as a decimal string or an &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">이 알림의 심각도 알 수없는 심각도를 나타내는 0 또는 심각도 감소 레벨을 나타내는 1-6의 값일 수 있습니다. 10 진수 문자열 또는 &lt;code&gt;Integer&lt;/code&gt; 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e160a4b6aeb2272b4bceb08e59e88dd16f02efed" translate="yes" xml:space="preserve">
          <source>The shape of the active area.</source>
          <target state="translated">활성 영역의 모양입니다.</target>
        </trans-unit>
        <trans-unit id="6b69b5002f102c1af993d1ab3b6f359d9642e8af" translate="yes" xml:space="preserve">
          <source>The shape of the active area. The coordinates are given by &lt;code&gt;coords&lt;/code&gt; . See the shape attribute definition in HTML 4.0.</source>
          <target state="translated">활성 영역의 모양입니다. 좌표는 &lt;code&gt;coords&lt;/code&gt; 로 제공됩니다 . HTML 4.0의 모양 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0eccb8cc0e921de7917ea0c1ada9687bb891455" translate="yes" xml:space="preserve">
          <source>The shaper assumes EUROPEAN as the starting context, that is, if EUROPEAN digits are encountered before any strong directional text in the string, the context is presumed to be EUROPEAN, and so the digits will not shape.</source>
          <target state="translated">The shaper assumes EUROPEAN as the starting context, that is, if EUROPEAN digits are encountered before any strong directional text in the string, the context is presumed to be EUROPEAN, and so the digits will not shape.</target>
        </trans-unit>
        <trans-unit id="7c0ee07626a06ec319c5fa6dda80e5cd02b895c5" translate="yes" xml:space="preserve">
          <source>The shift modifier.</source>
          <target state="translated">The shift modifier.</target>
        </trans-unit>
        <trans-unit id="71c1d09d15500daa94744a275e60c6c2939bb498" translate="yes" xml:space="preserve">
          <source>The shift modifier. An indicator that the shift key was held down during the event.</source>
          <target state="translated">The shift modifier. An indicator that the shift key was held down during the event.</target>
        </trans-unit>
        <trans-unit id="a66fafeb6fbab36159ed0d7cb6e57d97215745bd" translate="yes" xml:space="preserve">
          <source>The short at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 단락</target>
        </trans-unit>
        <trans-unit id="576f2f40fa40978110faae7dddc7b0f100fba9e6" translate="yes" xml:space="preserve">
          <source>The short at the given index</source>
          <target state="translated">주어진 색인에서 짧은</target>
        </trans-unit>
        <trans-unit id="66f18505d5b42c405be6d263a2a68a91ad1ba54c" translate="yes" xml:space="preserve">
          <source>The short value at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 짧은 값</target>
        </trans-unit>
        <trans-unit id="445cdd9d7081047dd595fe2a9c000aec02dddce0" translate="yes" xml:space="preserve">
          <source>The short value at the given index</source>
          <target state="translated">주어진 인덱스에서 짧은 값</target>
        </trans-unit>
        <trans-unit id="d44b2f7b9945d3e00f503b32d73edd3c18066dda" translate="yes" xml:space="preserve">
          <source>The shorts between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the short at index</source>
          <target state="translated">버퍼의 현재 위치와 한계 사이의 단락 (있는 경우)이 버퍼의 시작 부분에 복사됩니다. 즉, 지수 부족</target>
        </trans-unit>
        <trans-unit id="e6144db94e8f968200473ae365392fcfc5ce0cb6" translate="yes" xml:space="preserve">
          <source>The should be of the format 'BaseOfRange', such as 'MonthOfYear', unless the field has a range of &lt;code&gt;FOREVER&lt;/code&gt;, when only the base unit is mentioned, such as 'Year' or 'Era'.</source>
          <target state="translated">'Year'또는 'Era'와 같이 기본 단위 만 언급 된 경우 필드에 &lt;code&gt;FOREVER&lt;/code&gt; 범위가 없으면 'MonthOfYear'와 같은 'BaseOfRange'형식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3add085de9aaf5d9e08da4a23124aa74c77dac0e" translate="yes" xml:space="preserve">
          <source>The side input tray.</source>
          <target state="translated">측면 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="32380dd36b39ecdac95d6475271f9fd1eac8171d" translate="yes" xml:space="preserve">
          <source>The sign of the hours and minutes components must match. Thus, if the hours is negative, the minutes must be negative or zero. If the hours is zero, the minutes may be positive, negative or zero.</source>
          <target state="translated">시간 및 분 구성 요소의 부호가 일치해야합니다. 따라서 시간이 음수이면 분은 음수이거나 0이어야합니다. 시간이 0이면 분은 양수, 음수 또는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2a7170814ac7bf2d717ef435fa78b42211f6f7" translate="yes" xml:space="preserve">
          <source>The sign of the hours, minutes and seconds components must match. Thus, if the hours is negative, the minutes and seconds must be negative or zero.</source>
          <target state="translated">시간, 분 및 초 구성 요소의 부호가 일치해야합니다. 따라서 시간이 음수이면 분과 초는 음수 또는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee96bcfbe6567e84f1f76ed99e4ecc836a96fca7" translate="yes" xml:space="preserve">
          <source>The sign of the years and months units will be the same after normalization. For example, a period of &quot;1 year and -25 months&quot; will be normalized to &quot;-1 year and -1 month&quot;.</source>
          <target state="translated">연도 및 월 단위의 부호는 정규화 후에 동일합니다. 예를 들어 &quot;1 년 -25 개월&quot;기간은 &quot;-1 년 -1 개월&quot;로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="63a67b56142738f69b16820d1365a14f5a4ee3f6" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-1. The DSA algorithm using the SHA-1 message digest algorithm can be specified as &lt;code&gt;SHA1withDSA&lt;/code&gt;. In the case of RSA, there are multiple choices for the message digest algorithm, so the signing algorithm could be specified as, for example, &lt;code&gt;MD2withRSA&lt;/code&gt;, &lt;code&gt;MD5withRSA&lt;/code&gt;, or &lt;code&gt;SHA1withRSA&lt;/code&gt;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">서명 알고리즘은 특히 DSA 및 SHA-1을 사용하는 NIST 표준 DSA 일 수 있습니다. SHA-1 메시지 요약 알고리즘을 사용하는 DSA 알고리즘은 &lt;code&gt;SHA1withDSA&lt;/code&gt; 로 지정할 수 있습니다 . RSA의 경우 메시지 요약 알고리즘에 대해 여러 가지 선택이 있으므로 서명 알고리즘은 예를 들어 &lt;code&gt;MD2withRSA&lt;/code&gt; , &lt;code&gt;MD5withRSA&lt;/code&gt; 또는 &lt;code&gt;SHA1withRSA&lt;/code&gt; 로 지정할 수 있습니다 . 기본값이 없으므로 알고리즘 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a3f13d175903d19542fafe1776e926f2289f74d" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-1. The algorithm is specified using the same convention as that for signatures. The DSA algorithm using the SHA-1 message digest algorithm can be specified, for example, as &quot;SHA/DSA&quot; or &quot;SHA-1/DSA&quot; (they are equivalent). In the case of RSA, there are multiple choices for the message digest algorithm, so the signing algorithm could be specified as, for example, &quot;MD2/RSA&quot;, &quot;MD5/RSA&quot; or &quot;SHA-1/RSA&quot;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">서명 알고리즘은 특히 DSA 및 SHA-1을 사용하는 NIST 표준 DSA 일 수 있습니다. 알고리즘은 서명과 동일한 규칙을 사용하여 지정됩니다. SHA-1 메시지 요약 알고리즘을 사용하는 DSA 알고리즘은 예를 들어 &quot;SHA / DSA&quot;또는 &quot;SHA-1 / DSA&quot;로 지정할 수 있습니다 (동일 함). RSA의 경우 메시지 다이제스트 알고리즘에 대한 여러 선택이 있으므로 서명 알고리즘은 예를 들어 &quot;MD2 / RSA&quot;, &quot;MD5 / RSA&quot;또는 &quot;SHA-1 / RSA&quot;로 지정할 수 있습니다. 기본값이 없으므로 알고리즘 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4580befbe651a07f41f435d90006b6e04a4a69a" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The DSA algorithm using the SHA-256 message digest algorithm can be specified as &lt;code&gt;SHA256withDSA&lt;/code&gt;. In the case of RSA the signing algorithm could be specified as, for example, &lt;code&gt;SHA256withRSA&lt;/code&gt;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The DSA algorithm using the SHA-256 message digest algorithm can be specified as &lt;code&gt;SHA256withDSA&lt;/code&gt; . In the case of RSA the signing algorithm could be specified as, for example, &lt;code&gt;SHA256withRSA&lt;/code&gt; . The algorithm name must be specified, as there is no default.</target>
        </trans-unit>
        <trans-unit id="b6ff0462ece74d8c29d34b7ea3288f3bf76eb9da" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The algorithm is specified using the same convention as that for signatures. The DSA algorithm using the SHA-256 message digest algorithm can be specified, for example, as &quot;SHA256withDSA&quot;. In the case of RSA the signing algorithm could be specified as, for example, &quot;SHA256withRSA&quot;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The algorithm is specified using the same convention as that for signatures. The DSA algorithm using the SHA-256 message digest algorithm can be specified, for example, as &quot;SHA256withDSA&quot;. In the case of RSA the signing algorithm could be specified as, for example, &quot;SHA256withRSA&quot;. The algorithm name must be specified, as there is no default.</target>
        </trans-unit>
        <trans-unit id="ff39bceb78bb23fcbbe70e1f5873034144eb781f" translate="yes" xml:space="preserve">
          <source>The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See Appendix A in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt; Java Cryptography Architecture API Specification &amp;amp; Reference &lt;/a&gt; for information about standard algorithm names.</source>
          <target state="translated">서명 알고리즘 이름은 표준 Java 보안 이름 (예 : &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;등)이어야합니다. 표준 알고리즘 이름에 대한 정보 는 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt;Java Cryptography Architecture API 스펙 및 참조 서&lt;/a&gt; 의 부록 A를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54dcf510ed19a2b7f8be77cd8487aba2b8f5418c" translate="yes" xml:space="preserve">
          <source>The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for information about standard algorithm names.</source>
          <target state="translated">The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for information about standard algorithm names.</target>
        </trans-unit>
        <trans-unit id="99ba91b212deb5cbd4f03a4ada4aa8a3e35bedeb" translate="yes" xml:space="preserve">
          <source>The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for information about standard algorithm names.</source>
          <target state="translated">서명 알고리즘 이름은 표준 Java 보안 이름 (예 : &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;등)이어야합니다. &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html&quot;&gt;표준 알고리즘 이름에&lt;/a&gt; 대한 정보 는 Java 보안 표준 알고리즘 이름 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abb3f7329a67b3d4fbdda3d73c3b635eb5d93e29" translate="yes" xml:space="preserve">
          <source>The signature implementation is reset to its initial state (the state it was in after a call to one of the &lt;code&gt;engineInitSign&lt;/code&gt; methods) and can be reused to generate further signatures with the same private key. This method should be abstract, but we leave it concrete for binary compatibility. Knowledgeable providers should override this method.</source>
          <target state="translated">서명 구현은 초기 상태 ( &lt;code&gt;engineInitSign&lt;/code&gt; 메소드 중 하나를 호출 한 후의 상태)로 재설정되며 동일한 개인 키로 추가 서명을 생성하기 위해 재사용 할 수 있습니다. 이 방법은 추상적이어야하지만 바이너리 호환성을 위해 구체적으로 남겨둔다. 지식이 풍부한 공급자는이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="045f0d9e22ad722e6aac3627bd8e3b08a1c1d73b" translate="yes" xml:space="preserve">
          <source>The signature is invalid.</source>
          <target state="translated">서명이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42f242a0d237c989ce338fd4a99732b1e016a258" translate="yes" xml:space="preserve">
          <source>The signature of the given element.</source>
          <target state="translated">주어진 요소의 서명.</target>
        </trans-unit>
        <trans-unit id="1ded27c36fe5ab7411d3e61933f2340152846415" translate="yes" xml:space="preserve">
          <source>The signed object is a &quot;deep copy&quot; (in serialized form) of an original object. Once the copy is made, further manipulation of the original object has no side effect on the copy.</source>
          <target state="translated">서명 된 객체는 원본 객체의 &quot;딥 카피&quot;(직렬화 된 형태)입니다. 복사가 완료되면 원본 개체를 추가로 조작해도 복사본에 부작용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0a59c44048f0e255610b14982004df77ebcfed2" translate="yes" xml:space="preserve">
          <source>The simple name of an array is the simple name of the component type with &quot;[]&quot; appended. In particular the simple name of an array whose component type is anonymous is &quot;[]&quot;.</source>
          <target state="translated">배열의 단순 이름은 &quot;[]&quot;가 추가 된 구성 요소 유형의 단순 이름입니다. 특히 구성 요소 유형이 익명 인 배열의 단순 이름은 &quot;[]&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4856758e2bc679598150b5beb9072d5658f18a73" translate="yes" xml:space="preserve">
          <source>The simplest implementation of this interface is just:</source>
          <target state="translated">이 인터페이스의 가장 간단한 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2790b740b20a089db3044ca3bea2a585feabf923" translate="yes" xml:space="preserve">
          <source>The simplest method is XYZ scaling. In this method each device XYZ value is converted to a PCS XYZ value by multiplying it by the ratio of the PCS white point (D50) to the device white point.</source>
          <target state="translated">The simplest method is XYZ scaling. In this method each device XYZ value is converted to a PCS XYZ value by multiplying it by the ratio of the PCS white point (D50) to the device white point.</target>
        </trans-unit>
        <trans-unit id="7601d63e6d779f847c6607714e8ec53d040dbbd9" translate="yes" xml:space="preserve">
          <source>The simplest type of ID is that from &lt;code&gt;ZoneOffset&lt;/code&gt;. This consists of 'Z' and IDs starting with '+' or '-'.</source>
          <target state="translated">가장 간단한 유형의 ID는 &lt;code&gt;ZoneOffset&lt;/code&gt; 의 ID입니다 . 'Z'와 '+'또는 '-'로 시작하는 ID로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4705f5b2ef8f72b3f9ee11b55f079122ada80e7" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is to install a listener that calls a method on the target object with no arguments. In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that invokes the &lt;code&gt;toFront&lt;/code&gt; method on an instance of &lt;code&gt;javax.swing.JFrame&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 의 가장 간단한 사용은 인수없이 대상 오브젝트에서 메소드를 호출하는 리스너를 설치하는 것입니다. 다음 예제에서는 &lt;code&gt;javax.swing.JFrame&lt;/code&gt; 인스턴스 에서 &lt;code&gt;toFront&lt;/code&gt; 메소드 를 호출 하는 &lt;code&gt;ActionListener&lt;/code&gt; 를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ddd983cd346b58b2aaf0f326494e8259d55fa6b4" translate="yes" xml:space="preserve">
          <source>The simulated full-screen mode places and resizes the window to the maximum possible visible area of the screen. However, the native windowing system may modify the requested geometry-related data, so that the &lt;code&gt;Window&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</source>
          <target state="translated">The simulated full-screen mode places and resizes the window to the maximum possible visible area of the screen. However, the native windowing system may modify the requested geometry-related data, so that the &lt;code&gt;Window&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</target>
        </trans-unit>
        <trans-unit id="72ac5c657bc308d65c18c1fea6c9f1bba77d6a25" translate="yes" xml:space="preserve">
          <source>The single instance of &lt;code&gt;EmptySelectionModel&lt;/code&gt;.</source>
          <target state="translated">The single instance of &lt;code&gt;EmptySelectionModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37fb3690360544e839a41fbd8b8e5c5a45340b29" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Heisei' era (1989-01-08 - 2019-04-30) which has the value 2.</source>
          <target state="translated">The singleton instance for the 'Heisei' era (1989-01-08 - 2019-04-30) which has the value 2.</target>
        </trans-unit>
        <trans-unit id="e33d8bb98b0a97976f391846111c47207f038c46" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Heisei' era (1989-01-08 - current) which has the value 2.</source>
          <target state="translated">값이 2 인 'Heisei'시대 (1989-01-08-현재)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="2ad53a43c41fc711e9fc765c7a76f4717f283334" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Meiji' era (1868-01-01 - 1912-07-29) which has the value -1.</source>
          <target state="translated">값이 -1 인 'Meiji'시대 (1868-01-01-1912-07-29)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b9db443e933ddfb77a938341252b1fee77a5a329" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Reiwa' era (2019-05-01 - ) which has the value 3.</source>
          <target state="translated">값이 3 인 'Reiwa'시대 (2019-05-01-)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d4b69eb560816c3df54a738d4e567691842c889c" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Reiwa' era (2019-05-01 - ) which has the value 3. The end date of this era is not specified, unless the Japanese Government defines it.</source>
          <target state="translated">값이 3 인 'Reiwa'시대 (2019-05-01-)의 싱글 톤 인스턴스입니다.이 시대의 종료 날짜는 일본 정부가 정의하지 않는 한 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d90af347fd6251915ffab61ea28205da8ea6f749" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Showa' era (1926-12-25 - 1989-01-07) which has the value 1.</source>
          <target state="translated">값이 1 인 'Showa'시대 (1926-12-25-1989-01-07)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="374b989066c6a8b313cd532f43d4978a478afb4f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Taisho' era (1912-07-30 - 1926-12-24) which has the value 0.</source>
          <target state="translated">값이 0 인 'Taisho'시대 (1912-07-30-1926-12-24)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d1b649d3aca82f1b585114b89db8e7c3dce97afa" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Anno Hegirae', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 단일 인스턴스 인 'Anno Hegirae'는 숫자 값 1을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="33553f68eda534c6d7ec7b5b2097412f8aa169ef" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Buddhist Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 '불교 시대 (Buddhist Era)'에 대한 싱글 톤 인스턴스. 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="18e0a9282dc09dc3f8d780bd88319f70049b3bc8" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Current Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 싱글 톤 인스턴스 인 'Current Era'. 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="a9078c5f2b2fb0c83101cd2aab438d63e4d37967" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Republic of China Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 '중화 민국 시대'의 단일 인스턴스이며 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="37056cb4b1f3c2ee07efbc354ac2f5400ad2df63" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Friday.</source>
          <target state="translated">The singleton instance for the day-of-week of Friday.</target>
        </trans-unit>
        <trans-unit id="831fb5e46d4c1ddc036d82d37411d75aecf60668" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Friday. This has the numeric value of &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">금요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ec9586cccb6a778352e7a8dd8a12d2579e4859d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Monday.</source>
          <target state="translated">The singleton instance for the day-of-week of Monday.</target>
        </trans-unit>
        <trans-unit id="854466f9d7677acbef6b426929908eeaea0c0ac9" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Monday. This has the numeric value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">월요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95b6e13ea6c89b236812e595ea75de12418330ff" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Saturday.</source>
          <target state="translated">The singleton instance for the day-of-week of Saturday.</target>
        </trans-unit>
        <trans-unit id="6eec5084ed707e201918c7bb81e4ef4045f48ec1" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Saturday. This has the numeric value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">토요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="78d35379c7acd7ced1ce07f8a02d53fa46868e5c" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Sunday.</source>
          <target state="translated">The singleton instance for the day-of-week of Sunday.</target>
        </trans-unit>
        <trans-unit id="ec410919ffc74e6ed0841570a165d1ab4f8518b3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Sunday. This has the numeric value of &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">일요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;7&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44f30fc5690e19a76a107f962afc755c430f1fa8" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Thursday.</source>
          <target state="translated">The singleton instance for the day-of-week of Thursday.</target>
        </trans-unit>
        <trans-unit id="1b47f4c269ae66d8d89624e16dab12fae314b4ae" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Thursday. This has the numeric value of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">목요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9f862e8dc4406d39bdc49daea39643bfd67e82cc" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Tuesday.</source>
          <target state="translated">The singleton instance for the day-of-week of Tuesday.</target>
        </trans-unit>
        <trans-unit id="8710ed5941f516f24bb8dc09854d8cbc78a468d6" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Tuesday. This has the numeric value of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">화요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4203c1fdd0478946eb06f1dc84aca7d5d14b634f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Wednesday.</source>
          <target state="translated">The singleton instance for the day-of-week of Wednesday.</target>
        </trans-unit>
        <trans-unit id="74f5d636b9653c07ec4dfb5343c1209f6f45dee7" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Wednesday. This has the numeric value of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">수요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7713ef876ec0d0ff70d52271f9980dec01c333d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Buddhist Era', which has the numeric value 0.</source>
          <target state="translated">숫자 값이 0 인 현재 '불교 전 시대'이전 시대의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b7f42f3144aa34fcb5eacd6614462e8933d9e7c5" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Current Era', which has the numeric value 0.</source>
          <target state="translated">현재 값 이전의 'Before Current Era'이전의 싱글 톤 인스턴스이며 숫자 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4b5ed684b1759647e9750f9a4982ba3a88602d2a" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Republic of China Era', which has the numeric value 0.</source>
          <target state="translated">숫자 값이 0 인 현재 '중국 이전 시대'이전 시대의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="41eacb4f52ecff4535c6e0cd6e7596d3c29916cb" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of April with 30 days.</source>
          <target state="translated">The singleton instance for the month of April with 30 days.</target>
        </trans-unit>
        <trans-unit id="3498e33856b3bc1fa91dfe207455e4d516871a4f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of April with 30 days. This has the numeric value of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 4 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="70bb761c71fbabd2f2c266b82d999a1f7068ff4d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of August with 31 days.</source>
          <target state="translated">The singleton instance for the month of August with 31 days.</target>
        </trans-unit>
        <trans-unit id="a0dc754b17787f96f2b3260ec04194b05222744d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of August with 31 days. This has the numeric value of &lt;code&gt;8&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 8 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d30a73566a6e9dbf9efa2a653e803caa4ad5d73d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of December with 31 days.</source>
          <target state="translated">The singleton instance for the month of December with 31 days.</target>
        </trans-unit>
        <trans-unit id="afeded1a61c1256c947b92fd91be8f38f688ade2" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of December with 31 days. This has the numeric value of &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 12 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;12&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="806b6cb116e04b29f83c29dc9e3bdcb40a592e14" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of February with 28 days, or 29 in a leap year.</source>
          <target state="translated">The singleton instance for the month of February with 28 days, or 29 in a leap year.</target>
        </trans-unit>
        <trans-unit id="58ce16c9d66eb0950d2e8d8a844af1f67a40ea2b" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of February with 28 days, or 29 in a leap year. This has the numeric value of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">28 일 또는 윤년 29 일의 2 월 달의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74e203bb14a07d04b6220cd4725722658def7d5a" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of January with 31 days.</source>
          <target state="translated">The singleton instance for the month of January with 31 days.</target>
        </trans-unit>
        <trans-unit id="dbbaed2d99f6b4a91bd5a263c15920ce26db8422" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of January with 31 days. This has the numeric value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 1 월 달의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84a201e965918b73f6f0a51fb95d40167274284d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of July with 31 days.</source>
          <target state="translated">The singleton instance for the month of July with 31 days.</target>
        </trans-unit>
        <trans-unit id="dbf8150d5e374559752b5a4144a24f8a49cc43d5" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of July with 31 days. This has the numeric value of &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 7 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;7&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d2ece5339a8942535bba2423c8f2d06bdcec0c3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of June with 30 days.</source>
          <target state="translated">The singleton instance for the month of June with 30 days.</target>
        </trans-unit>
        <trans-unit id="171ab07a731170963fee5c54879a243aba461820" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of June with 30 days. This has the numeric value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 6 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b1f2132810b846baf93a7cbba2b98223085cec9" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of March with 31 days.</source>
          <target state="translated">The singleton instance for the month of March with 31 days.</target>
        </trans-unit>
        <trans-unit id="c44b47253f5146f50a56c9c4736034ad855145f6" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of March with 31 days. This has the numeric value of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 3 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e931f22dda40194f4e445071e6bc03593a7d73b9" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of May with 31 days.</source>
          <target state="translated">The singleton instance for the month of May with 31 days.</target>
        </trans-unit>
        <trans-unit id="695b98cf8bd88f36fe7a8d59e7b014104eb39c42" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of May with 31 days. This has the numeric value of &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 5 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="573cb230de428c272b4736649c6a3825e16254bc" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of November with 30 days.</source>
          <target state="translated">The singleton instance for the month of November with 30 days.</target>
        </trans-unit>
        <trans-unit id="5e6f9285c59d2cfa11644efd29aaef36209c76e3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of November with 30 days. This has the numeric value of &lt;code&gt;11&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 11 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;11&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5882f0e70b11a8c3279fc0103861f8c7c5df376" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of October with 31 days.</source>
          <target state="translated">The singleton instance for the month of October with 31 days.</target>
        </trans-unit>
        <trans-unit id="77d17e30353cc1d8703e4ac383dfbcf24f64b2d7" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of October with 31 days. This has the numeric value of &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 10 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="680e4d7736cb5471597da49f9edf29e6acb2f15a" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of September with 30 days.</source>
          <target state="translated">The singleton instance for the month of September with 30 days.</target>
        </trans-unit>
        <trans-unit id="cd70f2cccb7c35228c39eb4016b4bd39aab9ea64" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of September with 30 days. This has the numeric value of &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 9 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;9&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2680158e394a00554706dd97e3706afc22ecd31" translate="yes" xml:space="preserve">
          <source>The size (in bytes) of this memory segment.</source>
          <target state="translated">이 메모리 세그먼트의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="a73fac7de9937b7c2c258ee59ea1bff17d0831e6" translate="yes" xml:space="preserve">
          <source>The size button text property.</source>
          <target state="translated">The size button text property.</target>
        </trans-unit>
        <trans-unit id="6477b3618879a5e84f85a97df286437336401595" translate="yes" xml:space="preserve">
          <source>The size is measured in bytes.</source>
          <target state="translated">크기는 바이트 단위로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a4a376ac4e2c6d17da8f59a9b9910d704858cb8" translate="yes" xml:space="preserve">
          <source>The size is updated when recording buffers are flushed. If the recording is not written to the disk repository the returned size is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">기록 버퍼가 플러시되면 크기가 업데이트됩니다. 기록이 디스크 저장소에 기록되지 않은 경우 반환되는 크기는 항상 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d53c63b615a428bc85b992b7c04eed456185922" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">The size of &lt;code&gt;JOptionPane&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af1f4f7f642c922c1567312119a5e4ad52a0724a" translate="yes" xml:space="preserve">
          <source>The size of a doc is computed based on the print data representation class as specified by the doc's &lt;a href=&quot;../../docflavor&quot;&gt;&lt;code&gt;DocFlavor&lt;/code&gt;&lt;/a&gt;, as shown in the table below.</source>
          <target state="translated">문서의 크기는 아래 표에 표시된 것처럼 문서의 &lt;a href=&quot;../../docflavor&quot;&gt; &lt;code&gt;DocFlavor&lt;/code&gt; 에&lt;/a&gt; 지정된 인쇄 데이터 표현 클래스를 기반으로 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="23d732c5b294224e6c7bc0db0723f73dec9504a9" translate="yes" xml:space="preserve">
          <source>The size of components.</source>
          <target state="translated">The size of components.</target>
        </trans-unit>
        <trans-unit id="2b33100b39966e88e8e151f1b8c55dcbceae0f08" translate="yes" xml:space="preserve">
          <source>The size of each frame, in bytes.</source>
          <target state="translated">각 프레임의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="8f9034f1b6e8e551c9315d1f020fa1ede6c673ba" translate="yes" xml:space="preserve">
          <source>The size of each segment is estimated by counting the size of each input file to be transmitted in the segment, along with the size of its name and other transmitted properties.</source>
          <target state="translated">각 세그먼트의 크기는 이름 및 기타 전송 된 속성의 크기와 함께 세그먼트에서 전송 될 각 입력 파일의 크기를 계산하여 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="6945db6b9aaec59e9a237996f6de7fd4d6e01473" translate="yes" xml:space="preserve">
          <source>The size of the attribute value, in bytes.</source>
          <target state="translated">속성 값의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="d377fbc634cb1fcaa6d6aeebdf8a7126697e9a7f" translate="yes" xml:space="preserve">
          <source>The size of the divider while the dragging session is valid.</source>
          <target state="translated">The size of the divider while the dragging session is valid.</target>
        </trans-unit>
        <trans-unit id="2babd81935a68bc574cf140a8ed25e62a8a4ddfe" translate="yes" xml:space="preserve">
          <source>The size of the frame includes any area designated for the border. The dimensions of the border area may be obtained using the &lt;code&gt;getInsets&lt;/code&gt; method, however, since these dimensions are platform-dependent, a valid insets value cannot be obtained until the frame is made displayable by either calling &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;show&lt;/code&gt;. Since the border area is included in the overall size of the frame, the border effectively obscures a portion of the frame, constraining the area available for rendering and/or displaying subcomponents to the rectangle which has an upper-left corner location of &lt;code&gt;(insets.left, insets.top)&lt;/code&gt;, and has a size of &lt;code&gt;width - (insets.left + insets.right)&lt;/code&gt; by &lt;code&gt;height - (insets.top + insets.bottom)&lt;/code&gt;.</source>
          <target state="translated">The size of the frame includes any area designated for the border. The dimensions of the border area may be obtained using the &lt;code&gt;getInsets&lt;/code&gt; method, however, since these dimensions are platform-dependent, a valid insets value cannot be obtained until the frame is made displayable by either calling &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;show&lt;/code&gt; . Since the border area is included in the overall size of the frame, the border effectively obscures a portion of the frame, constraining the area available for rendering and/or displaying subcomponents to the rectangle which has an upper-left corner location of &lt;code&gt;(insets.left, insets.top)&lt;/code&gt; , and has a size of &lt;code&gt;width - (insets.left + insets.right)&lt;/code&gt; by &lt;code&gt;height - (insets.top + insets.bottom)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aef354301526547b65cbdbff808019ed00981550" translate="yes" xml:space="preserve">
          <source>The size of the locked region</source>
          <target state="translated">잠긴 영역의 크기</target>
        </trans-unit>
        <trans-unit id="62d979f3aaa643816fa9bb9e52650da3be4ad740" translate="yes" xml:space="preserve">
          <source>The size of the smaller file (in bytes) when the files are different sizes and every byte of the smaller file is identical to the corresponding byte of the larger file.</source>
          <target state="translated">파일 크기가 다르고 더 작은 파일의 모든 바이트가 더 큰 파일의 해당 바이트와 동일 할 때 더 작은 파일의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="ffd49f5a54a05c0e211000f48c06808a4e45ab2a" translate="yes" xml:space="preserve">
          <source>The size of the socket receive buffer</source>
          <target state="translated">소켓 수신 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="b93eb1ff5703dad725f268be21bfebee369e1241" translate="yes" xml:space="preserve">
          <source>The size of the socket receive buffer.</source>
          <target state="translated">소켓 수신 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="ac94f9348a7ec8ca8eb5a0577c7a3672cb67beac" translate="yes" xml:space="preserve">
          <source>The size of the socket send buffer</source>
          <target state="translated">소켓 송신 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="afb9a30fb21697b87a94f349ade50c4c64721e5a" translate="yes" xml:space="preserve">
          <source>The size of the socket send buffer.</source>
          <target state="translated">소켓 송신 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f546bdf38de152c096164ced3cb3faeef1188d54" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the partition or &lt;code&gt;0L&lt;/code&gt; if this abstract pathname does not name a partition</source>
          <target state="translated">파티션의 크기 (바이트) 또는 이 추상 경로명이 파티션 이름을 지정하지 않는 경우 &lt;code&gt;0L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ff81126a609e08d4d5e8904a818aea8df3f6adb" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the partition or &lt;code&gt;0L&lt;/code&gt; if this abstract pathname does not name a partition or if the size cannot be obtained</source>
          <target state="translated">이 추상 경로 이름이 파티션의 이름을 지정하지 않거나 크기를 얻을 수없는 경우 파티션 의 크기 (바이트) 또는 &lt;code&gt;0L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77e7580d4eabd26a16573da1f1e6884d637aaaa9" translate="yes" xml:space="preserve">
          <source>The slider can show both major tick marks, and minor tick marks between the major ones. The number of values between the tick marks is controlled with &lt;code&gt;setMajorTickSpacing&lt;/code&gt; and &lt;code&gt;setMinorTickSpacing&lt;/code&gt;. Painting of tick marks is controlled by &lt;code&gt;setPaintTicks&lt;/code&gt;.</source>
          <target state="translated">The slider can show both major tick marks, and minor tick marks between the major ones. The number of values between the tick marks is controlled with &lt;code&gt;setMajorTickSpacing&lt;/code&gt; and &lt;code&gt;setMinorTickSpacing&lt;/code&gt; . Painting of tick marks is controlled by &lt;code&gt;setPaintTicks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6ffd0649eec316588f1e098e996254023ca6c5" translate="yes" xml:space="preserve">
          <source>The smallest acceptable size for the thumb.</source>
          <target state="translated">The smallest acceptable size for the thumb.</target>
        </trans-unit>
        <trans-unit id="608588a6ce7faa309c72f3d591de7b6a527d1475" translate="yes" xml:space="preserve">
          <source>The smallest grid that can be laid out by the grid bag layout.</source>
          <target state="translated">The smallest grid that can be laid out by the grid bag layout.</target>
        </trans-unit>
        <trans-unit id="eccc9011507e2f8d69cd68d30db124741a00ce17" translate="yes" xml:space="preserve">
          <source>The smallest integer in this set-of-integer attribute that is greater than &lt;code&gt;x&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; if no integer in this set-of-integer attribute is greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">보다 큰 정수형 세트의 특성에 작은 정수 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; 정수형 세트의 속성에는 정수를 초과하지 않는 경우 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
