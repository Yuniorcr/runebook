<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="bc33598046176d9eab7bba30e8222147757f2f72" translate="yes" xml:space="preserve">
          <source>ImageWriter.canWriteRasters()</source>
          <target state="translated">ImageWriter.canWriteRasters()</target>
        </trans-unit>
        <trans-unit id="c5136c9bda61ca27c5cd0dae82f2baf85b060c58" translate="yes" xml:space="preserve">
          <source>ImageWriter.canWriteSequence()</source>
          <target state="translated">ImageWriter.canWriteSequence()</target>
        </trans-unit>
        <trans-unit id="8c93b907cf061808747b0600c515e9f003b0e137" translate="yes" xml:space="preserve">
          <source>ImageWriter.clearAbortRequest()</source>
          <target state="translated">ImageWriter.clearAbortRequest()</target>
        </trans-unit>
        <trans-unit id="69c2b9ab433f8e2fd072dfed1da17c92bae04c90" translate="yes" xml:space="preserve">
          <source>ImageWriter.convertImageMetadata()</source>
          <target state="translated">ImageWriter.convertImageMetadata()</target>
        </trans-unit>
        <trans-unit id="495ce4c2c4273e1e46a930a8187c9f45f94c9896" translate="yes" xml:space="preserve">
          <source>ImageWriter.convertStreamMetadata()</source>
          <target state="translated">ImageWriter.convertStreamMetadata()</target>
        </trans-unit>
        <trans-unit id="b6649f60f10be92daf80ffb85853cd4e31d8d80d" translate="yes" xml:space="preserve">
          <source>ImageWriter.dispose()</source>
          <target state="translated">ImageWriter.dispose()</target>
        </trans-unit>
        <trans-unit id="d9a96211e88c46d8122ba717844aa90f2fe59ae5" translate="yes" xml:space="preserve">
          <source>ImageWriter.endInsertEmpty()</source>
          <target state="translated">ImageWriter.endInsertEmpty()</target>
        </trans-unit>
        <trans-unit id="02c53a0a5a5040166dad2ff2b70bf6417932e5a9" translate="yes" xml:space="preserve">
          <source>ImageWriter.endReplacePixels()</source>
          <target state="translated">ImageWriter.endReplacePixels()</target>
        </trans-unit>
        <trans-unit id="243445b4691380bda3e90240c0c25fbf2db5cfa7" translate="yes" xml:space="preserve">
          <source>ImageWriter.endWriteEmpty()</source>
          <target state="translated">ImageWriter.endWriteEmpty()</target>
        </trans-unit>
        <trans-unit id="7f53b9aebaff977beb83d1ab112645f4aac5efe2" translate="yes" xml:space="preserve">
          <source>ImageWriter.endWriteSequence()</source>
          <target state="translated">ImageWriter.endWriteSequence()</target>
        </trans-unit>
        <trans-unit id="048ac4db3ab2569e1a0464b22494fad23e59c667" translate="yes" xml:space="preserve">
          <source>ImageWriter.getAvailableLocales()</source>
          <target state="translated">ImageWriter.getAvailableLocales()</target>
        </trans-unit>
        <trans-unit id="186f09acf93554a35caa650f580388f83fab1b64" translate="yes" xml:space="preserve">
          <source>ImageWriter.getDefaultImageMetadata()</source>
          <target state="translated">ImageWriter.getDefaultImageMetadata()</target>
        </trans-unit>
        <trans-unit id="261e96dca25da3b6ddc2ddf6270898ef54647ebd" translate="yes" xml:space="preserve">
          <source>ImageWriter.getDefaultStreamMetadata()</source>
          <target state="translated">ImageWriter.getDefaultStreamMetadata()</target>
        </trans-unit>
        <trans-unit id="3b0ecc6a3712bede4df8b034146694078aea067c" translate="yes" xml:space="preserve">
          <source>ImageWriter.getDefaultWriteParam()</source>
          <target state="translated">ImageWriter.getDefaultWriteParam()</target>
        </trans-unit>
        <trans-unit id="d27a11604f88d6dd3d5e1dac72049b7318fa68d4" translate="yes" xml:space="preserve">
          <source>ImageWriter.getLocale()</source>
          <target state="translated">ImageWriter.getLocale()</target>
        </trans-unit>
        <trans-unit id="b1dcdc90769debae6b4b53593e7f1b23abaf557d" translate="yes" xml:space="preserve">
          <source>ImageWriter.getNumThumbnailsSupported()</source>
          <target state="translated">ImageWriter.getNumThumbnailsSupported()</target>
        </trans-unit>
        <trans-unit id="70342f647937897e5a8f931d41cfeeffd55e1d58" translate="yes" xml:space="preserve">
          <source>ImageWriter.getOriginatingProvider()</source>
          <target state="translated">ImageWriter.getOriginatingProvider()</target>
        </trans-unit>
        <trans-unit id="2e3dc4746bcf1b64502e6c10b09f75bae504e08f" translate="yes" xml:space="preserve">
          <source>ImageWriter.getOutput()</source>
          <target state="translated">ImageWriter.getOutput()</target>
        </trans-unit>
        <trans-unit id="17b68947f77c2816d5402030aae865b9c6bf49d7" translate="yes" xml:space="preserve">
          <source>ImageWriter.getPreferredThumbnailSizes()</source>
          <target state="translated">ImageWriter.getPreferredThumbnailSizes()</target>
        </trans-unit>
        <trans-unit id="f0996382875ebc3931f8227d1da9d9999c6262f0" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareInsertEmpty()</source>
          <target state="translated">ImageWriter.prepareInsertEmpty()</target>
        </trans-unit>
        <trans-unit id="1600a8485e8aee5eabdb03fa172a540fa208a9ca" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareReplacePixels()</source>
          <target state="translated">ImageWriter.prepareReplacePixels()</target>
        </trans-unit>
        <trans-unit id="35d0acbd7d75f38aa62c22dada23269ac6e692a6" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareWriteEmpty()</source>
          <target state="translated">ImageWriter.prepareWriteEmpty()</target>
        </trans-unit>
        <trans-unit id="77b62910eb17e81d20d2ac6ee3a1451fec8f7b11" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareWriteSequence()</source>
          <target state="translated">ImageWriter.prepareWriteSequence()</target>
        </trans-unit>
        <trans-unit id="264a512aa75f545384e20d5c2a2d44f8cfd28c22" translate="yes" xml:space="preserve">
          <source>ImageWriter.processImageComplete()</source>
          <target state="translated">ImageWriter.processImageComplete()</target>
        </trans-unit>
        <trans-unit id="d899034a5d569f4ed1324d22847e032242084711" translate="yes" xml:space="preserve">
          <source>ImageWriter.processImageProgress()</source>
          <target state="translated">ImageWriter.processImageProgress()</target>
        </trans-unit>
        <trans-unit id="27332d4fb5ca683298f89fcef5f985ee18b1e27d" translate="yes" xml:space="preserve">
          <source>ImageWriter.processImageStarted()</source>
          <target state="translated">ImageWriter.processImageStarted()</target>
        </trans-unit>
        <trans-unit id="ea20b4712a47bc75f276b4adf8231f76d03fb566" translate="yes" xml:space="preserve">
          <source>ImageWriter.processThumbnailComplete()</source>
          <target state="translated">ImageWriter.processThumbnailComplete()</target>
        </trans-unit>
        <trans-unit id="51d80f53b4677d0c618c41e75214b7f17c0cfefb" translate="yes" xml:space="preserve">
          <source>ImageWriter.processThumbnailProgress()</source>
          <target state="translated">ImageWriter.processThumbnailProgress()</target>
        </trans-unit>
        <trans-unit id="e8d245e553e69546053b699570a19cf917b0ff1e" translate="yes" xml:space="preserve">
          <source>ImageWriter.processThumbnailStarted()</source>
          <target state="translated">ImageWriter.processThumbnailStarted()</target>
        </trans-unit>
        <trans-unit id="db5f4715eb940bd70bc26506a945db7ea9b2da98" translate="yes" xml:space="preserve">
          <source>ImageWriter.processWarningOccurred()</source>
          <target state="translated">ImageWriter.processWarningOccurred()</target>
        </trans-unit>
        <trans-unit id="7858acf7ee93b4017b8847e7702c868343598811" translate="yes" xml:space="preserve">
          <source>ImageWriter.processWriteAborted()</source>
          <target state="translated">ImageWriter.processWriteAborted()</target>
        </trans-unit>
        <trans-unit id="03fbfbe0ce8b469a11cc57d3d2f89ca0bcce678a" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeAllIIOWriteProgressListeners()</source>
          <target state="translated">ImageWriter.removeAllIIOWriteProgressListeners()</target>
        </trans-unit>
        <trans-unit id="b83fee8f0c7d4508aa22b6525bb5d98ed0b3322f" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeAllIIOWriteWarningListeners()</source>
          <target state="translated">ImageWriter.removeAllIIOWriteWarningListeners()</target>
        </trans-unit>
        <trans-unit id="cde86c599bcb774b43043a447041773b82450a7d" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeIIOWriteProgressListener()</source>
          <target state="translated">ImageWriter.removeIIOWriteProgressListener()</target>
        </trans-unit>
        <trans-unit id="b9c0bc66df2955815d28d74bdff020a6af20a3d1" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeIIOWriteWarningListener()</source>
          <target state="translated">ImageWriter.removeIIOWriteWarningListener()</target>
        </trans-unit>
        <trans-unit id="31fbb91214d8d39ad428825a48f3fbdb6fa60e2a" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeImage()</source>
          <target state="translated">ImageWriter.removeImage()</target>
        </trans-unit>
        <trans-unit id="4f44e6546a9791fa9ab18d909a79abb19a863b88" translate="yes" xml:space="preserve">
          <source>ImageWriter.replaceImageMetadata()</source>
          <target state="translated">ImageWriter.replaceImageMetadata()</target>
        </trans-unit>
        <trans-unit id="c40e5cfd970633aa96ec6453b5cd39189eec519f" translate="yes" xml:space="preserve">
          <source>ImageWriter.replacePixels()</source>
          <target state="translated">ImageWriter.replacePixels()</target>
        </trans-unit>
        <trans-unit id="74e4c3be0799bbe1f7c421eb7be21b166ff60279" translate="yes" xml:space="preserve">
          <source>ImageWriter.replaceStreamMetadata()</source>
          <target state="translated">ImageWriter.replaceStreamMetadata()</target>
        </trans-unit>
        <trans-unit id="85d06995be275a5540df30d0831143341e3bbff7" translate="yes" xml:space="preserve">
          <source>ImageWriter.reset()</source>
          <target state="translated">ImageWriter.reset()</target>
        </trans-unit>
        <trans-unit id="8fe56500c78199dad9352d8f603280356d3ac6c3" translate="yes" xml:space="preserve">
          <source>ImageWriter.setLocale()</source>
          <target state="translated">ImageWriter.setLocale()</target>
        </trans-unit>
        <trans-unit id="3c39e2913413d8d0162136d0c5d1d8e02851ce04" translate="yes" xml:space="preserve">
          <source>ImageWriter.setOutput()</source>
          <target state="translated">ImageWriter.setOutput()</target>
        </trans-unit>
        <trans-unit id="843ab49be0e6f42a53e35a4061fe467639fa6461" translate="yes" xml:space="preserve">
          <source>ImageWriter.write()</source>
          <target state="translated">ImageWriter.write()</target>
        </trans-unit>
        <trans-unit id="85fea7a2a9c977e351bbbfbd5963fa188c87bdac" translate="yes" xml:space="preserve">
          <source>ImageWriter.writeInsert()</source>
          <target state="translated">ImageWriter.writeInsert()</target>
        </trans-unit>
        <trans-unit id="ff12abc364282e927d5d6556cd4e677d4b326b02" translate="yes" xml:space="preserve">
          <source>ImageWriter.writeToSequence()</source>
          <target state="translated">ImageWriter.writeToSequence()</target>
        </trans-unit>
        <trans-unit id="d4c1cd6c86ba14ace868abe5436b6c3ea6867041" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi</source>
          <target state="translated">ImageWriterSpi</target>
        </trans-unit>
        <trans-unit id="7907c00c50feae52e7cd33381c995a5fe91a5327" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.canEncodeImage()</source>
          <target state="translated">ImageWriterSpi.canEncodeImage()</target>
        </trans-unit>
        <trans-unit id="114df7b0203df03ac058feb677cbc146b5ae8953" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.createWriterInstance()</source>
          <target state="translated">ImageWriterSpi.createWriterInstance()</target>
        </trans-unit>
        <trans-unit id="8c525960abeb10238cfa5bdebd4bafd51d80f9a9" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.getImageReaderSpiNames()</source>
          <target state="translated">ImageWriterSpi.getImageReaderSpiNames()</target>
        </trans-unit>
        <trans-unit id="2576cfdd9438a00c172370eb8ea0ed0dea89009f" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.getOutputTypes()</source>
          <target state="translated">ImageWriterSpi.getOutputTypes()</target>
        </trans-unit>
        <trans-unit id="b8388bf6802a2e78f4d3d0f825bbf4e83e656d96" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.isFormatLossless()</source>
          <target state="translated">ImageWriterSpi.isFormatLossless()</target>
        </trans-unit>
        <trans-unit id="473bc7237ab98736b74f2348995a72361b8fe8de" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.isOwnWriter()</source>
          <target state="translated">ImageWriterSpi.isOwnWriter()</target>
        </trans-unit>
        <trans-unit id="f3bbe23a175ec37e8cc3e09e80fbc7806f08b9b6" translate="yes" xml:space="preserve">
          <source>Images with 2 or 4 bits per pixel may be constructed via the &lt;code&gt;BufferedImage&lt;/code&gt; constructor that takes a &lt;code&gt;ColorModel&lt;/code&gt; argument by supplying a &lt;code&gt;ColorModel&lt;/code&gt; with an appropriate map size.</source>
          <target state="translated">화소 당 2 개 또는 4 비트를 통해 이미지가 구축 될 수있다 &lt;code&gt;BufferedImage&lt;/code&gt; 얻어 생성자 &lt;code&gt;ColorModel&lt;/code&gt; 공급함으로써 인수 &lt;code&gt;ColorModel&lt;/code&gt; 와 적절한지도 크기로한다.</target>
        </trans-unit>
        <trans-unit id="1d0b7a4a289cb642b58d04e1e7fbb91d92814504" translate="yes" xml:space="preserve">
          <source>Images with 8 bits per pixel should use the image types &lt;code&gt;TYPE_BYTE_INDEXED&lt;/code&gt; or &lt;code&gt;TYPE_BYTE_GRAY&lt;/code&gt; depending on their &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">픽셀 당 8 비트의 이미지 는 &lt;code&gt;ColorModel&lt;/code&gt; 에 따라 &lt;code&gt;TYPE_BYTE_INDEXED&lt;/code&gt; 또는 &lt;code&gt;TYPE_BYTE_GRAY&lt;/code&gt; 이미지 유형을 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="63ce1f7ade23f27731d8bef9021d16cca263431a" translate="yes" xml:space="preserve">
          <source>Images with an IndexColorModel cannot be rescaled.</source>
          <target state="translated">IndexColorModel이있는 이미지는 크기를 조정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35f524310930c051d8da9bc51a1b0a045b71ab2c" translate="yes" xml:space="preserve">
          <source>Images with an IndexColorModel cannot be used.</source>
          <target state="translated">IndexColorModel이있는 이미지는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d6b0d05ca581d19b3503a81b578fda4383632307" translate="yes" xml:space="preserve">
          <source>ImagingOpException</source>
          <target state="translated">ImagingOpException</target>
        </trans-unit>
        <trans-unit id="b6a1b86fae938216f357d1624854ea77f4576400" translate="yes" xml:space="preserve">
          <source>Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally.</source>
          <target state="translated">이 작업의 기본 작업을 즉시 수행하고이 메서드에서 반환 할 때이 작업이 정상적으로 완료되었음을 보장하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4211eb9c1fee9874525c7e0858d275f457d53e7d" translate="yes" xml:space="preserve">
          <source>Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally. This method may return false otherwise, to indicate that this task is not necessarily complete (or is not known to be complete), for example in asynchronous actions that require explicit invocations of completion methods. This method may also throw an (unchecked) exception to indicate abnormal exit. This method is designed to support extensions, and should not in general be called otherwise.</source>
          <target state="translated">이 태스크의 기본 조치를 즉시 수행하고이 메소드에서 리턴 할 때이 태스크가 정상적으로 완료되었음을 보장하면 true를 리턴합니다. 이 메소드는 그렇지 않은 경우, 예를 들어 완료 메소드를 명시 적으로 호출해야하는 비동기 조치에서이 태스크가 반드시 완료되지 않았거나 완료되지 않은 것을 나타 내기 위해 false를 리턴 할 수 있습니다. 이 메소드는 비정상 종료를 표시하기 위해 (확인되지 ​​않은) 예외를 발생시킬 수도 있습니다. 이 메소드는 확장을 지원하도록 설계되었으며 일반적으로 다른 방식으로 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="78a6ee9cdbd11937f920f9cf6abd0fcc93bbeeab" translate="yes" xml:space="preserve">
          <source>Immediately removes the current row from this &lt;code&gt;CachedRowSet&lt;/code&gt; object if the row has been inserted, and also notifies listeners that a row has changed.</source>
          <target state="translated">행이 삽입 된 경우이 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체 에서 현재 행을 즉시 제거하고 , 행이 변경되었음을 리스너에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="e3c8282a36b8a47dc4b2f78994ea2dd708f414e0" translate="yes" xml:space="preserve">
          <source>Immediately removes the current row from this &lt;code&gt;CachedRowSet&lt;/code&gt; object if the row has been inserted, and also notifies listeners that a row has changed. This method can be called at any time during the lifetime of a rowset and assuming the current row is within the exception limitations (see below), it cancels the row insertion of the current row.</source>
          <target state="translated">행이 삽입 된 경우이 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체 에서 현재 행을 즉시 제거하고 , 행이 변경되었음을 리스너에게 알립니다. 이 메서드는 행 집합의 수명 동안 언제든지 호출 할 수 있으며 현재 행이 예외 제한 (아래 참조) 내에 있다고 가정하면 현재 행의 행 삽입을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="d58d2e0de365bbfe06df3bd3e214308fc7b4c341" translate="yes" xml:space="preserve">
          <source>Immediately reverses the last update operation if the row has been modified.</source>
          <target state="translated">행이 수정 된 경우 마지막 업데이트 작업을 즉시 취소합니다.</target>
        </trans-unit>
        <trans-unit id="178618a784f41413ed0dba00dd3910328200d108" translate="yes" xml:space="preserve">
          <source>Immediately reverses the last update operation if the row has been modified. This method can be called to reverse updates on all columns until all updates in a row have been rolled back to their state just prior to the last synchronization (&lt;code&gt;acceptChanges&lt;/code&gt;) or population. This method may also be called while performing updates to the insert row.</source>
          <target state="translated">행이 수정 된 경우 마지막 업데이트 작업을 즉시 취소합니다. 이 메서드를 호출하여 행의 모든 ​​업데이트가 마지막 동기화 ( &lt;code&gt;acceptChanges&lt;/code&gt; ) 또는 채우기 직전의 상태로 롤백 될 때까지 모든 열의 업데이트를 되돌릴 수 있습니다 . 이 메서드는 삽입 행을 업데이트하는 동안 호출 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8d36e07cc56e5300256f2a8edfaee0ed2e6146" translate="yes" xml:space="preserve">
          <source>Immediately turns off all sounding notes on this channel, ignoring the state of the Hold Pedal and the internal decay rate of the current &lt;code&gt;Instrument&lt;/code&gt;.</source>
          <target state="translated">홀드 페달의 상태와 현재 &lt;code&gt;Instrument&lt;/code&gt; 의 내부 감쇠율을 무시하고이 채널의 모든 사운드 음을 즉시 끕니다 .</target>
        </trans-unit>
        <trans-unit id="8758ee05b925965fd186ddc64c16d26477e3f464" translate="yes" xml:space="preserve">
          <source>Immutable arbitrary-precision integers.</source>
          <target state="translated">불변의 임의 정밀도 정수.</target>
        </trans-unit>
        <trans-unit id="9dadabf71766048113467cbc9b081255811fb85d" translate="yes" xml:space="preserve">
          <source>Immutable arbitrary-precision integers. All operations behave as if BigIntegers were represented in two's-complement notation (like Java's primitive integer types). BigInteger provides analogues to all of Java's primitive integer operators, and all relevant methods from java.lang.Math. Additionally, BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations.</source>
          <target state="translated">불변의 임의 정밀도 정수. 모든 연산은 BigInteger가 2의 보수 표기법 (예 : Java의 원시 정수 유형)으로 표시되는 것처럼 작동합니다. BigInteger는 모든 Java 기본 정수 연산자 및 java.lang.Math의 모든 관련 메소드에 대한 아날로그를 제공합니다. 또한 BigInteger는 모듈 식 산술, GCD 계산, 원시성 테스트, 프라임 생성, 비트 조작 및 기타 몇 가지 기타 연산을위한 연산을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d3137173d33f7241e713b1cc45e83e35598949c" translate="yes" xml:space="preserve">
          <source>Immutable in-memory representation of grammar.</source>
          <target state="translated">문법의 변경 불가능한 메모리 내 표현.</target>
        </trans-unit>
        <trans-unit id="9135fe2945023ddca478ae564e2500e0944e20a3" translate="yes" xml:space="preserve">
          <source>Immutable objects which encapsulate the context settings which describe certain rules for numerical operators, such as those implemented by the &lt;a href=&quot;bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt; 클래스에 의해 구현되는 것과 같이 수치 연산자에 대한 특정 규칙을 설명하는 컨텍스트 설정을 캡슐화하는 불변 개체 .</target>
        </trans-unit>
        <trans-unit id="3e6d3d9a67ba06c33eaf819b41614751d94fff83" translate="yes" xml:space="preserve">
          <source>Immutable representation of a time span as defined in the W3C XML Schema 1.0 specification.</source>
          <target state="translated">W3C XML Schema 1.0 사양에 정의 된대로 시간 범위의 변경 불가능한 표현입니다.</target>
        </trans-unit>
        <trans-unit id="946d1618638d399656d4c970d5ff50225bc47ca3" translate="yes" xml:space="preserve">
          <source>Immutable, arbitrary-precision signed decimal numbers.</source>
          <target state="translated">불변의 임의 정밀도 부호있는 10 진수</target>
        </trans-unit>
        <trans-unit id="10a4ef5ea8019a3a68a2a4a396691f1d378d5c37" translate="yes" xml:space="preserve">
          <source>Immutable, arbitrary-precision signed decimal numbers. A &lt;code&gt;BigDecimal&lt;/code&gt; consists of an arbitrary precision integer</source>
          <target state="translated">불변의 임의 정밀도 부호있는 10 진수 &lt;code&gt;BigDecimal&lt;/code&gt; 와 임의 정밀도 정수 이루어져</target>
        </trans-unit>
        <trans-unit id="7319e7f2b2dabeaa6c7b27e3568a5f5708e41dfe" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor</source>
          <target state="translated">ImmutableDescriptor</target>
        </trans-unit>
        <trans-unit id="b36cd894ece50e6aeffc14aae55cd0c27226fd98" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.clone()</source>
          <target state="translated">ImmutableDescriptor.clone()</target>
        </trans-unit>
        <trans-unit id="ed62e375f112ad9ccee1fba5b30840d38fa2702b" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.equals()</source>
          <target state="translated">ImmutableDescriptor.equals()</target>
        </trans-unit>
        <trans-unit id="cc2486aaa3fee33eb39977e70168c71e9c152579" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFieldNames()</source>
          <target state="translated">ImmutableDescriptor.getFieldNames()</target>
        </trans-unit>
        <trans-unit id="33c0e00e50294d5765396d16bed5b31e31b33704" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFieldValue()</source>
          <target state="translated">ImmutableDescriptor.getFieldValue()</target>
        </trans-unit>
        <trans-unit id="27f5f695db4a9c871dae6c1af910d2e02e2d8827" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFieldValues()</source>
          <target state="translated">ImmutableDescriptor.getFieldValues()</target>
        </trans-unit>
        <trans-unit id="c74b89a34fa2994f4dc20dbdb82753d62c2f8dba" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFields()</source>
          <target state="translated">ImmutableDescriptor.getFields()</target>
        </trans-unit>
        <trans-unit id="1ef304a4a99d2ee1d85fa6fa5017995b00e2e0d9" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.hashCode()</source>
          <target state="translated">ImmutableDescriptor.hashCode()</target>
        </trans-unit>
        <trans-unit id="1bed3158b55a0ff6dc6cf7eee07c3cb59df5f3ae" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.isValid()</source>
          <target state="translated">ImmutableDescriptor.isValid()</target>
        </trans-unit>
        <trans-unit id="9d20352efe423c7d09b17d5ea975cfa82b08c2a1" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.removeField()</source>
          <target state="translated">ImmutableDescriptor.removeField()</target>
        </trans-unit>
        <trans-unit id="d8f820196ba5acc46b266d1f2d228cf55ed7e0e1" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.setField()</source>
          <target state="translated">ImmutableDescriptor.setField()</target>
        </trans-unit>
        <trans-unit id="b253285758003719de94b91f5f21225436dd43df" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.setFields()</source>
          <target state="translated">ImmutableDescriptor.setFields()</target>
        </trans-unit>
        <trans-unit id="3331b138f3a353ed1554e90d8d377dd39afe2405" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.toString()</source>
          <target state="translated">ImmutableDescriptor.toString()</target>
        </trans-unit>
        <trans-unit id="58bb6a00dee16db192f8a0654a1c5b9c33aee672" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.union()</source>
          <target state="translated">ImmutableDescriptor.union()</target>
        </trans-unit>
        <trans-unit id="53ec8c0efe8d1c9632dd1fa4a2184ba29ffd5a20" translate="yes" xml:space="preserve">
          <source>Impl</source>
          <target state="translated">Impl</target>
        </trans-unit>
        <trans-unit id="f0056cd1979fbe037e426222b348d25fd0689453" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; so that it will be notified of exceptions thrown while attempting to collect information about the events.</source>
          <target state="translated">&lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; 구현 하여 이벤트에 대한 정보를 수집하는 중에 발생하는 예외를 통지합니다.</target>
        </trans-unit>
        <trans-unit id="690dbe719c377561373486aa2f92fb2d6f5e4ff2" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; so that it will be notified of exceptions thrown while attempting to collect unsolicited notification events.</source>
          <target state="translated">요청하지 않은 알림 이벤트를 수집하는 중에 발생하는 예외에 대해 알림을 받도록 &lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="75affea7e53c52cd8fab4edffef65fbf6ddb7308" translate="yes" xml:space="preserve">
          <source>Implement this interface and its method</source>
          <target state="translated">이 인터페이스와 그 방법을 구현</target>
        </trans-unit>
        <trans-unit id="5063beca960838bb432eb32e9373f94a39f1f788" translate="yes" xml:space="preserve">
          <source>Implement this interface and its method (&lt;code&gt;objectChanged()&lt;/code&gt;)</source>
          <target state="translated">이 인터페이스와 그 메소드를 구현합니다 ( &lt;code&gt;objectChanged()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aff6c99e6945c218f388a4965c6177505dfafc44" translate="yes" xml:space="preserve">
          <source>Implement this interface and its methods.</source>
          <target state="translated">이 인터페이스와 해당 메소드를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="2e66b6c0aeb65e7c92f1357992e37901f5147726" translate="yes" xml:space="preserve">
          <source>Implementation Caveats</source>
          <target state="translated">구현주의 사항</target>
        </trans-unit>
        <trans-unit id="1ea8952f50fb61a30b61a3567d5ee3bac1c761f1" translate="yes" xml:space="preserve">
          <source>Implementation Considerations</source>
          <target state="translated">구현 고려 사항</target>
        </trans-unit>
        <trans-unit id="5392a59cf19d936f582c62933f66e98178ed888b" translate="yes" xml:space="preserve">
          <source>Implementation Note:</source>
          <target state="translated">구현 노트 :</target>
        </trans-unit>
        <trans-unit id="35577183da3a83c37a96990c90025cb613ff293d" translate="yes" xml:space="preserve">
          <source>Implementation Notes</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="56bd65881e479e23bf147d909b47f36e4767545c" translate="yes" xml:space="preserve">
          <source>Implementation Requirements:</source>
          <target state="translated">구현 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="c054b6d2d6fae8ccc22414dda4a08abbd6309cb2" translate="yes" xml:space="preserve">
          <source>Implementation classes can implement any number of remote interfaces and can extend other remote implementation classes. RMI provides some convenience classes that remote object implementations can extend which facilitate remote object creation. These classes are &lt;code&gt;java.rmi.server.UnicastRemoteObject&lt;/code&gt; and &lt;code&gt;java.rmi.activation.Activatable&lt;/code&gt;.</source>
          <target state="translated">구현 클래스는 여러 원격 인터페이스를 구현할 수 있으며 다른 원격 구현 클래스를 확장 할 수 있습니다. RMI는 원격 객체 생성을 용이하게하는 원격 객체 구현이 확장 할 수있는 몇 가지 편의 클래스를 제공합니다. 이러한 클래스는 &lt;code&gt;java.rmi.server.UnicastRemoteObject&lt;/code&gt; 및 &lt;code&gt;java.rmi.activation.Activatable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4db05a22307844f1edc4910aee61a1ebef7a63d" translate="yes" xml:space="preserve">
          <source>Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a cipher suite be selected.</source>
          <target state="translated">구현 기본값에서는 서버를 인증하고 기밀성을 제공하는 암호 제품군 만 기본적으로 활성화되어야합니다. 양측이 인증되지 않은 및 / 또는 비 개인 (암호화되지 않은) 통신에 명시 적으로 동의하는 경우에만 그러한 암호 스위트가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="c2f7359e09ff4796735a0de165edbf80e271b48e" translate="yes" xml:space="preserve">
          <source>Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a ciphersuite be selected.</source>
          <target state="translated">구현 기본값에서는 서버를 인증하고 기밀성을 제공하는 암호 제품군 만 기본적으로 활성화되어야합니다. 양측이 인증되지 않은 및 / 또는 개인 (비 암호화) 통신에 명시 적으로 동의하는 경우에만 그러한 암호 그룹이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="89a26f51603685592a55c536acb5f2c479db2b32" translate="yes" xml:space="preserve">
          <source>Implementation dependent*</source>
          <target state="translated">구현에 따라 다름 *</target>
        </trans-unit>
        <trans-unit id="7d8419888cec7209ae96fa638de54f65acbe69d3" translate="yes" xml:space="preserve">
          <source>Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their &lt;a href=&quot;hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; counterparts.</source>
          <target state="translated">구현 참고 사항 : 모든 기본 작업은 일정한 시간에 실행됩니다. 그것들은 &lt;a href=&quot;hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 에&lt;/a&gt; 비해 빠를 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="cf02ce9de07c112e78515bdd74f832a2026eaf4c" translate="yes" xml:space="preserve">
          <source>Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be much faster than their &lt;a href=&quot;hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; counterparts. Even bulk operations execute in constant time if their argument is also an enum set.</source>
          <target state="translated">구현 참고 사항 : 모든 기본 작업은 일정한 시간에 실행됩니다. 그것들은 &lt;a href=&quot;hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; 에&lt;/a&gt; 비해 훨씬 빠를 가능성이 높습니다 . 인수가 열거 세트 인 경우 대량 작업도 일정한 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c78934415a11eef7fc53181c42efe07bfe3abdfc" translate="yes" xml:space="preserve">
          <source>Implementation note: All constructors start a timer thread.</source>
          <target state="translated">구현 참고 사항 : 모든 생성자는 타이머 스레드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9f92508b268a3c37cb005d5f88087365e6264aad" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of n are not used when doing the comparison. They might be in the future.</source>
          <target state="translated">구현 참고 사항 : 현재 비교시 n의 구문 특성이 사용되지 않습니다. 그들은 미래에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="357fbc883df7f4e052dd8544280cd702a44ddce7" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of suffix is not used or checked. They might be in the future.</source>
          <target state="translated">구현 참고 사항 : 현재 접미사의 구문 속성은 사용되거나 확인되지 않습니다. 그들은 미래에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57c22944b726188bf6ae7fd68a8e4603e289bff8" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of the two compound names are not compared for equality. They might be in the future.</source>
          <target state="translated">구현 참고 사항 : 현재 두 복합 이름의 구문 특성이 동일한 지 비교하지 않습니다. 그들은 미래에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17efe67f11fa0904c5508671cc86b1f03383b987" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of the two compound names are not compared when checking order. They might be in the future.</source>
          <target state="translated">구현 참고 사항 : 현재 두 화합물 이름의 구문 속성은 순서를 확인할 때 비교되지 않습니다. 그들은 미래에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fadd3ec1701bf6a8dfbeac94df0eeb78424f23bc" translate="yes" xml:space="preserve">
          <source>Implementation note: In Sun's JRE, the &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation is located as follows:</source>
          <target state="translated">구현 노트 : Sun의 JRE에서 &lt;code&gt;PreferencesFactory&lt;/code&gt; 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32af97f107bce0105a0965130e4994d46e36fe62" translate="yes" xml:space="preserve">
          <source>Implementation note: In Sun's default &lt;code&gt;Preferences&lt;/code&gt; implementations, the user's identity is inherited from the underlying operating system and does not change for the lifetime of the virtual machine. It is recognized that server-side &lt;code&gt;Preferences&lt;/code&gt; implementations may have the user identity change from request to request, implicitly passed to &lt;code&gt;Preferences&lt;/code&gt; methods via the use of a static &lt;a href=&quot;../../../../java.base/java/lang/threadlocal&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; instance. Authors of such implementations are</source>
          <target state="translated">구현 참고 사항 : Sun의 기본 &lt;code&gt;Preferences&lt;/code&gt; 구현에서 사용자의 ID는 기본 운영 체제에서 상속되며 가상 시스템의 수명 동안 변경되지 않습니다. 서버 측 &lt;code&gt;Preferences&lt;/code&gt; 구현은 요청에 따라 사용자 ID가 변경 될 수 있으며 정적 &lt;a href=&quot;../../../../java.base/java/lang/threadlocal&quot;&gt; &lt;code&gt;ThreadLocal&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용 하여 &lt;code&gt;Preferences&lt;/code&gt; 메소드에 암시 적으로 전달 될 수 있습니다. 이러한 구현의 작성자는</target>
        </trans-unit>
        <trans-unit id="e83e39679a9ec5b714b7a869ee88c37537f350ca" translate="yes" xml:space="preserve">
          <source>Implementation note: In Sun's default &lt;code&gt;Preferences&lt;/code&gt; implementations, the user's identity is inherited from the underlying operating system and does not change for the lifetime of the virtual machine. It is recognized that server-side &lt;code&gt;Preferences&lt;/code&gt; implementations may have the user identity change from request to request, implicitly passed to &lt;code&gt;Preferences&lt;/code&gt; methods via the use of a static &lt;a href=&quot;../../lang/threadlocal&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; instance. Authors of such implementations are</source>
          <target state="translated">구현 참고 사항 : Sun의 기본 &lt;code&gt;Preferences&lt;/code&gt; 구현에서 사용자 ID는 기본 운영 체제에서 상속되며 가상 시스템의 수명 동안 변경되지 않습니다. 서버 측 &lt;code&gt;Preferences&lt;/code&gt; 구현은 요청에서 요청으로 사용자 ID가 변경 될 수 있으며 정적 &lt;a href=&quot;../../lang/threadlocal&quot;&gt; &lt;code&gt;ThreadLocal&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용 하여 암시 적으로 &lt;code&gt;Preferences&lt;/code&gt; 메소드로 전달 될 수 있습니다. 그러한 구현의 저자는</target>
        </trans-unit>
        <trans-unit id="f8347a8d9b2c4d7fc6f3f82a020b9be3d04e1235" translate="yes" xml:space="preserve">
          <source>Implementation note: It is a good idea for the returned input stream to be buffered.</source>
          <target state="translated">구현 참고 사항 : 리턴 된 입력 스트림을 버퍼링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e620b36bbd87ef780306fc9678272515771dd91b" translate="yes" xml:space="preserve">
          <source>Implementation note: It is a good idea for the returned output stream to be buffered.</source>
          <target state="translated">구현 참고 사항 : 리턴 된 출력 스트림을 버퍼링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="12c36d0f22c12cc8b408418579ca954e388e69cb" translate="yes" xml:space="preserve">
          <source>Implementation note: Java platform implementers are encouraged to document their implementation's behavior with respect to the &lt;code&gt;stackSize&lt;/code&gt; parameter.</source>
          <target state="translated">구현 참고 사항 : Java 플랫폼 구현자는 &lt;code&gt;stackSize&lt;/code&gt; 매개 변수 와 관련하여 구현 동작을 문서화하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a80652326887f793e45705b34277de3fc6ce115d" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;#highestOneBit(int)&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numberOfTrailingZeros(int)&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">구현 참고 사항 : &quot;bit twiddling&quot;메서드 (예 : &lt;a href=&quot;#highestOneBit(int)&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numberOfTrailingZeros(int)&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; &lt;/a&gt; )의 구현은 Henry S. Warren, Jr.의 자료를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a7085ff44d84babc5ff1f7930ff810b8715a1f05" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;#highestOneBit(long)&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numberOfTrailingZeros(long)&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">구현 참고 사항 : &quot;bit twiddling&quot;메서드 (예 : &lt;a href=&quot;#highestOneBit(long)&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numberOfTrailingZeros(long)&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; &lt;/a&gt; )의 구현은 Henry S. Warren, Jr.의 자료를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="cc3f67c06af9914501ca24f8883a4e8966569d3d" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;integer#highestOneBit-int-&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;integer#numberOfTrailingZeros-int-&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">구현 노트 : &quot;비트 &lt;a href=&quot;integer#highestOneBit-int-&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt; &quot;방법 ( highestOneBit 및 &lt;a href=&quot;integer#numberOfTrailingZeros-int-&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; 등&lt;/a&gt; )의 구현은 Henry S. Warren, Jr.의 자료를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="8a4a16b7058693cbd0304356eead5736843a8092" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;long#highestOneBit-long-&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;long#numberOfTrailingZeros-long-&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">구현 노트 : &quot;비트 &lt;a href=&quot;long#highestOneBit-long-&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt; &quot;방법 ( highestOneBit 및 &lt;a href=&quot;long#numberOfTrailingZeros-long-&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; 등&lt;/a&gt; )의 구현은 Henry S. Warren, Jr.의 자료를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3188db0c530c042cb96da0a5994510f97bfc5cc0" translate="yes" xml:space="preserve">
          <source>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</source>
          <target state="translated">구현 노트 : 정렬 알고리즘은 Vladimir Yaroslavskiy, Jon Bentley 및 Joshua Bloch의 Dual-Pivot Quicksort입니다. 이 알고리즘은 많은 데이터 세트에서 O (n log (n)) 성능을 제공하여 다른 퀵 정렬이 2 차 성능으로 저하되고 일반적으로 기존 (1 피봇) 퀵 정렬 구현보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b1d5721596c5d27ffa016e87f4ba7a7afcdd3a37" translate="yes" xml:space="preserve">
          <source>Implementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem). Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks.</source>
          <target state="translated">구현 참고 사항 :이 클래스는 많은 수의 동시 예약 작업으로 확장됩니다 (수천 개는 문제 없음). 내부적으로 이진 힙을 사용하여 작업 대기열을 나타내므로 작업 예약 비용은 O (log n)이며 여기서 n은 동시에 예약 된 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="8ef20428f4dadec2f47e6e6850bd2a0025279b42" translate="yes" xml:space="preserve">
          <source>Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays.</source>
          <target state="translated">구현 노트 :이 구현은 입력 배열이 부분적으로 정렬 될 때 n lg (n)보다 훨씬 적은 비교를 요구하는 안정적이고 적응적인 반복 병합 소 르트이며, 입력 배열이 무작위로 정렬 될 때 기존의 머지 소트의 성능을 제공합니다. 입력 배열이 거의 정렬 된 경우 구현에는 대략 n 개의 비교가 필요합니다. 임시 저장 요구 사항은 거의 정렬 된 입력 배열에 대한 작은 상수부터 무작위로 정렬 된 입력 배열에 대한 n / 2 객체 참조까지 다양합니다.</target>
        </trans-unit>
        <trans-unit id="eb0470b2fedea042771a02bc0a5cad6afbd16278" translate="yes" xml:space="preserve">
          <source>Implementation note: This implementation maintains markable references by creating internal objects representing &quot;boxed&quot; [reference, boolean] pairs.</source>
          <target state="translated">구현 참고 사항 :이 구현은 &quot;boxed&quot;[reference, boolean] 쌍을 나타내는 내부 객체를 만들어 현저한 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2cff0a7e73f6f3b914b5fc7d60794f6a681ade41" translate="yes" xml:space="preserve">
          <source>Implementation note: This implementation maintains stamped references by creating internal objects representing &quot;boxed&quot; [reference, integer] pairs.</source>
          <target state="translated">구현 참고 사항 :이 구현은 &quot;boxed&quot;[reference, integer] 쌍을 나타내는 내부 객체를 생성하여 스탬핑 된 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="82eefb0670ba392863839d4b7c351ae2f2aec431" translate="yes" xml:space="preserve">
          <source>Implementation note: This is a simple</source>
          <target state="translated">구현 노트 : 이것은 간단하다</target>
        </trans-unit>
        <trans-unit id="0f1b03ffa0afe0f4d925ad6c4cbaf6a53cc3d45c" translate="yes" xml:space="preserve">
          <source>Implementation note: this implementation provides O(log(n)) time for the enqueuing and dequeuing methods (&lt;code&gt;offer&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt;, &lt;code&gt;remove()&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt;); linear time for the &lt;code&gt;remove(Object)&lt;/code&gt; and &lt;code&gt;contains(Object)&lt;/code&gt; methods; and constant time for the retrieval methods (&lt;code&gt;peek&lt;/code&gt;, &lt;code&gt;element&lt;/code&gt;, and &lt;code&gt;size&lt;/code&gt;).</source>
          <target state="translated">구현 참고 사항 :이 구현은 대기열 및 대기열 해제 방법 ( &lt;code&gt;offer&lt;/code&gt; , &lt;code&gt;poll&lt;/code&gt; , &lt;code&gt;remove()&lt;/code&gt; 및 &lt;code&gt;add&lt;/code&gt; )에 O (log (n)) 시간을 제공합니다 . &lt;code&gt;remove(Object)&lt;/code&gt; 및 &lt;code&gt;contains(Object)&lt;/code&gt; 메소드의 선형 시간 ; 그리고 검색 방법에 대한 일정한 시간 ( &lt;code&gt;peek&lt;/code&gt; , &lt;code&gt;element&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="62d6f06657d3359a7c49b4f528b67ee2cdba413a" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getKeyListener().</source>
          <target state="translated">ComboPopup.getKeyListener ()의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="70462c77e4382253855b86e4e7f6f7c7c0723bf8" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getList().</source>
          <target state="translated">ComboPopup.getList ()의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="5788526cf7b5f9f213ed4c51c11bc1a3c88db823" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getMouseListener().</source>
          <target state="translated">ComboPopup.getMouseListener ()의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="dcfea7aadf5f0efc973fd90897934bacf8738909" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getMouseMotionListener().</source>
          <target state="translated">ComboPopup.getMouseMotionListener ()의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="6bbde2392be17daf4b5536ddf29fc67cd5e4611f" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.hide().</source>
          <target state="translated">ComboPopup.hide () 구현.</target>
        </trans-unit>
        <trans-unit id="987207700ef33908715f75cb881ee0043c420d73" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.show().</source>
          <target state="translated">ComboPopup.show () 구현.</target>
        </trans-unit>
        <trans-unit id="fa0fb2c8ec52562d3cc085877c70e27e31dce0d3" translate="yes" xml:space="preserve">
          <source>Implementation of ScrollBarUI for the Basic Look and Feel</source>
          <target state="translated">기본 룩앤필을위한 ScrollBarUI 구현</target>
        </trans-unit>
        <trans-unit id="e4c2e8d390498cc8b74a825e1fe79b2f66af8b30" translate="yes" xml:space="preserve">
          <source>Implementation of ScrollBarUI for the Metal Look and Feel</source>
          <target state="translated">Metal Look &amp;amp; Feel를위한 ScrollBarUI 구현</target>
        </trans-unit>
        <trans-unit id="e5d871d42e339265298961acaedbdd4193e5ecce" translate="yes" xml:space="preserve">
          <source>Implementation of an ActionListener that the JSplitPane UI uses for handling specific key presses.</source>
          <target state="translated">JSplitPane UI가 특정 키 누름을 처리하는 데 사용하는 ActionListener의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="3118ec0d79d222bcd2256d07c590a042e52e16c7" translate="yes" xml:space="preserve">
          <source>Implementation of the &lt;a href=&quot;rmiconnection&quot;&gt;&lt;code&gt;RMIConnection&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;rmiconnection&quot;&gt; &lt;code&gt;RMIConnection&lt;/code&gt; &lt;/a&gt; 인터페이스의 구현</target>
        </trans-unit>
        <trans-unit id="f35fc1148f7585e27e0b304b08634ba0530c650a" translate="yes" xml:space="preserve">
          <source>Implementation of the &lt;a href=&quot;rmiconnection&quot;&gt;&lt;code&gt;RMIConnection&lt;/code&gt;&lt;/a&gt; interface. User code will not usually reference this class.</source>
          <target state="translated">&lt;a href=&quot;rmiconnection&quot;&gt; &lt;code&gt;RMIConnection&lt;/code&gt; &lt;/a&gt; 인터페이스의 구현 사용자 코드는 일반적으로이 클래스를 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7aae3f60380c55bc82937af4ac2577abd3646434" translate="yes" xml:space="preserve">
          <source>Implementation of the FocusListener that the JSplitPane UI uses.</source>
          <target state="translated">JSplitPane UI가 사용하는 FocusListener 구현.</target>
        </trans-unit>
        <trans-unit id="e45222ac40e5e9145fe91fecc0ab9e099a479550" translate="yes" xml:space="preserve">
          <source>Implementation of the PropertyChangeListener that the JSplitPane UI uses.</source>
          <target state="translated">JSplitPane UI가 사용하는 PropertyChangeListener의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="2a530c76800e044b9bf6aafcd3efc974a11ea05e" translate="yes" xml:space="preserve">
          <source>Implementation of this &quot;interface&quot; can be obtained through the &lt;a href=&quot;validatorhandler#getTypeInfoProvider()&quot;&gt;&lt;code&gt;ValidatorHandler.getTypeInfoProvider()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 &quot;인터페이스&quot;의 구현은 &lt;a href=&quot;validatorhandler#getTypeInfoProvider()&quot;&gt; &lt;code&gt;ValidatorHandler.getTypeInfoProvider()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f55d131a2dc1cfdadfdc55ae7393f24e57ed10d" translate="yes" xml:space="preserve">
          <source>Implementation of this compound name. This field is initialized by the constructors and cannot be null. It should be treated as a read-only variable by subclasses.</source>
          <target state="translated">이 복합 명의 구현. 이 필드는 생성자에 의해 초기화되며 null 일 수 없습니다. 서브 클래스에 의해 읽기 전용 변수로 취급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c455488aae5e9f5d4d1f7ba581ef3e990cd0d089" translate="yes" xml:space="preserve">
          <source>Implementation of this method should make sure the returned keys match the latest content of the keytab file. The result is a newly created copy that can be modified by the caller without modifying the keytab object. The caller should &lt;a href=&quot;kerberoskey#destroy()&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; the result keys after they are used.</source>
          <target state="translated">이 메서드의 구현은 반환 된 키가 keytab 파일의 최신 내용과 일치하는지 확인해야합니다. 결과는 keytab 개체를 수정하지 않고 호출자가 수정할 수있는 새로 생성 된 복사본입니다. 호출자 는 사용 된 결과 키를 &lt;a href=&quot;kerberoskey#destroy()&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4588461e3c03d7bc79552363d89b889505499be0" translate="yes" xml:space="preserve">
          <source>Implementation of this method should make sure the returned keys match the latest content of the keytab file. The result is a newly created copy that can be modified by the caller without modifying the keytab object. The caller should &lt;a href=&quot;kerberoskey#destroy--&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; the result keys after they are used.</source>
          <target state="translated">이 방법을 구현하면 반환 된 키가 키탭 파일의 최신 내용과 일치해야합니다. 결과는 keytab 객체를 수정하지 않고 호출자가 수정할 수있는 새로 작성된 사본입니다. 호출자 는 사용 된 결과 키를 &lt;a href=&quot;kerberoskey#destroy--&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="396c510a1fc2ba783df94b6f422e4210a3731d18" translate="yes" xml:space="preserve">
          <source>Implementation specific properties are prefixed with a package name associated with the implementor, beginning with &lt;code&gt;com.&lt;/code&gt; or a similar prefix. All property names beginning with &lt;code&gt;pack.&lt;/code&gt; and &lt;code&gt;unpack.&lt;/code&gt; are reserved for use by this API.</source>
          <target state="translated">구현 특정 속성에는 &lt;code&gt;com.&lt;/code&gt; 시작하는 구현 자와 관련된 패키지 이름이 접두사로 사용됩니다 . 또는 유사한 접두사. &lt;code&gt;pack.&lt;/code&gt; 시작하는 모든 속성 이름 그리고 &lt;code&gt;unpack.&lt;/code&gt; 이 API에서 사용하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b530c2bf8258e2420563a2fcc5823de5071326" translate="yes" xml:space="preserve">
          <source>Implementations are free to flush changes into the persistent store at any time. They do not need to wait for this method to be called.</source>
          <target state="translated">구현은 언제든지 변경 사항을 지속적 저장소로 플러시 할 수 있습니다. 이 메소드가 호출 될 때까지 기다릴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bbef6d428d76eba48a5e342afaf9006175c411f4" translate="yes" xml:space="preserve">
          <source>Implementations are free to ignore the hints completely, but should try to use an implementation algorithm that is as close as possible to the request. If an implementation supports a given algorithm when any value is used for an associated hint key, then minimally it must do so when the value for that key is the exact value that specifies the algorithm.</source>
          <target state="translated">구현은 힌트를 완전히 무시할 수 있지만 가능한 한 요청에 가까운 구현 알고리즘을 사용해야합니다. 연관된 힌트 키에 값이 사용될 때 구현이 주어진 알고리즘을 지원하는 경우 최소한 해당 키의 값이 알고리즘을 지정하는 정확한 값일 때이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="eafb44c538b7aa7794d10b653782aa71d2cf24c8" translate="yes" xml:space="preserve">
          <source>Implementations are free to implement the Cloneable interface.</source>
          <target state="translated">구현은 Cloneable 인터페이스를 자유롭게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d7991836c70f5920ce49a6302cb1849e347963" translate="yes" xml:space="preserve">
          <source>Implementations are free to implement the Cloneable interface. Client applications can test cloneability by attempting cloning and catching the CloneNotSupportedException:</source>
          <target state="translated">구현은 Cloneable 인터페이스를 자유롭게 구현할 수 있습니다. 클라이언트 응용 프로그램은 복제를 시도하고 CloneNotSupportedException을 포착하여 복제 성을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf03efd7cfc8f1ec7309d501f6cf5b8fc2e0cc89" translate="yes" xml:space="preserve">
          <source>Implementations are not required to support the activation mechanism. If activation is not supported by this implementation, several specific activation API methods are all required to throw &lt;code&gt;UnsupportedOperationException&lt;/code&gt;. If activation is supported by this implementation, these methods must never throw &lt;code&gt;
UnsupportedOperationException&lt;/code&gt;. These methods are denoted by the presence of an entry for &lt;code&gt;UnsupportedOperationException&lt;/code&gt; in the &lt;strong&gt;Throws&lt;/strong&gt; section of each method's specification.</source>
          <target state="translated">활성화 메커니즘을 지원하기 위해 구현이 필요하지 않습니다. 이 구현에서 활성화가 지원 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 시키기 위해 몇 가지 특정 활성화 API 메서드가 모두 필요합니다. . 이 구현에서 활성화가 지원되는 경우 이러한 메서드는 &lt;code&gt; UnsupportedOperationException&lt;/code&gt; 을 throw해서는 안됩니다 . 이러한 메서드는 각 메서드 사양 의 &lt;strong&gt;Throws&lt;/strong&gt; 섹션에 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 에 대한 항목이있는 것으로 표시됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3aaeb0d29c017dba3531c1ffc50226364e7eb90c" translate="yes" xml:space="preserve">
          <source>Implementations are not required to support the inter-process transfer of security contexts. Before exporting a context, calling the &lt;a href=&quot;gsscontext#isTransferable()&quot;&gt;&lt;code&gt;GSSContext.isTransferable&lt;/code&gt;&lt;/a&gt; will indicate if the context is transferable. Calling this method in an implementation that does not support it will result in a &lt;code&gt;GSSException&lt;/code&gt; with the error code &lt;a href=&quot;gssexception#UNAVAILABLE&quot;&gt;&lt;code&gt;GSSException.UNAVAILABLE&lt;/code&gt;&lt;/a&gt;. Some mechanism providers might require that the caller be granted permission to initiate or accept a security context. A failed permission check might cause a &lt;a href=&quot;../../../../java.base/java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; to be thrown from this method.</source>
          <target state="translated">보안 컨텍스트의 프로세스 간 전송을 지원하기 위해 구현이 필요하지 않습니다. 컨텍스트를 내보내기 전에 &lt;a href=&quot;gsscontext#isTransferable()&quot;&gt; &lt;code&gt;GSSContext.isTransferable&lt;/code&gt; &lt;/a&gt; 을 호출 하면 컨텍스트를 전송할 수 있는지 여부가 표시됩니다. 지원하지 않는 구현에서이 메소드를 호출 하면 오류 코드와 함께 &lt;code&gt;GSSException&lt;/code&gt; 이 발생합니다.&lt;a href=&quot;gssexception#UNAVAILABLE&quot;&gt; &lt;code&gt;GSSException.UNAVAILABLE&lt;/code&gt; &lt;/a&gt;. 일부 메커니즘 공급자는 호출자에게 보안 컨텍스트를 시작하거나 수락 할 수있는 권한을 요구할 수 있습니다. 권한 검사에 실패하면이 메서드에서&lt;a href=&quot;../../../../java.base/java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 throw 될수 있습니다.</target>
        </trans-unit>
        <trans-unit id="300c1a5202ff7486ff2aa1de97b32a5d09be7717" translate="yes" xml:space="preserve">
          <source>Implementations are not required to support the inter-process transfer of security contexts. Calling the &lt;a href=&quot;#isTransferable()&quot;&gt;&lt;code&gt;isTransferable&lt;/code&gt;&lt;/a&gt; method will indicate if the context object is transferable.</source>
          <target state="translated">보안 컨텍스트의 프로세스 간 전송을 지원하기 위해 구현이 필요하지 않습니다. &lt;a href=&quot;#isTransferable()&quot;&gt; &lt;code&gt;isTransferable&lt;/code&gt; &lt;/a&gt; 메서드를 호출하면 컨텍스트 개체가 전송 가능한지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="279ebb8422b455b13529fc4a3a9cbf3ded65a160" translate="yes" xml:space="preserve">
          <source>Implementations are required to support the encodings &quot;UTF-8&quot;, &quot;UTF-16&quot;, &quot;UTF-16BE&quot;, and &quot;UTF-16LE&quot; to guarantee that data is serializable in all encodings that are required to be supported by all XML parsers. When the encoding is UTF-8, whether or not a byte order mark is serialized, or if the output is big-endian or little-endian, is implementation dependent. When the encoding is UTF-16, whether or not the output is big-endian or little-endian is implementation dependent, but a Byte Order Mark must be generated for non-character outputs, such as &lt;code&gt;LSOutput.byteStream&lt;/code&gt; or &lt;code&gt;LSOutput.systemId&lt;/code&gt;. If the Byte Order Mark is not generated, a &quot;byte-order-mark-needed&quot; warning is reported. When the encoding is UTF-16LE or UTF-16BE, the output is big-endian (UTF-16BE) or little-endian (UTF-16LE) and the Byte Order Mark is not be generated. In all cases, the encoding declaration, if generated, will correspond to the encoding used during the serialization (e.g. &lt;code&gt;encoding=&quot;UTF-16&quot;&lt;/code&gt; will appear if UTF-16 was requested).</source>
          <target state="translated">모든 XML 파서에서 지원해야하는 모든 인코딩에서 데이터를 직렬화 할 수 있도록 &quot;UTF-8&quot;, &quot;UTF-16&quot;, &quot;UTF-16BE&quot;및 &quot;UTF-16LE&quot;인코딩을 지원하는 구현이 필요합니다. . 인코딩이 UTF-8 인 경우 바이트 순서 표시가 직렬화되었는지 여부 또는 출력이 빅 엔디안 또는 리틀 엔디안인지 여부는 구현에 따라 다릅니다. 인코딩이 UTF-16 인 경우 출력이 big-endian인지 little-endian인지 여부는 구현에 따라 다르지만 &lt;code&gt;LSOutput.byteStream&lt;/code&gt; 또는 같은 비 문자 출력에 대해서는 바이트 순서 표시를 생성해야합니다. &lt;code&gt;LSOutput.systemId&lt;/code&gt; . Byte Order Mark가 생성되지 않으면 &quot;byte-order-mark-needed&quot;경고가보고됩니다. 인코딩이 UTF-16LE 또는 UTF-16BE 인 경우 출력은 big-endian (UTF-16BE) 또는 little-endian (UTF-16LE)이며 바이트 순서 표시가 생성되지 않습니다. 모든 경우에서 인코딩 선언은 생성 된 경우 직렬화 중에 사용 된 인코딩에 해당합니다 (예 : &lt;code&gt;encoding=&quot;UTF-16&quot;&lt;/code&gt; UTF-16이 요청 된 경우 encoding = &quot;UTF-16&quot; 이 나타남).</target>
        </trans-unit>
        <trans-unit id="c6210cf47411e0dfdee18058689ad0ba683b6a96" translate="yes" xml:space="preserve">
          <source>Implementations may declare support for units not listed by &lt;a href=&quot;#getUnits()&quot;&gt;&lt;code&gt;getUnits()&lt;/code&gt;&lt;/a&gt;. Typically, the implementation would define additional units as conversions for the convenience of developers.</source>
          <target state="translated">구현시 나열되지 않은 단위에 대한 지원을 선언 할 수 있습니다. &lt;a href=&quot;#getUnits()&quot;&gt; &lt;code&gt;getUnits()&lt;/code&gt; &lt;/a&gt;. 일반적으로 구현시 개발자의 편의를 위해 추가 단위를 변환으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="72941d4649ad680b0f6b254a46807c194c448b61" translate="yes" xml:space="preserve">
          <source>Implementations may declare support for units not listed by &lt;a href=&quot;temporalamount#getUnits--&quot;&gt;&lt;code&gt;getUnits()&lt;/code&gt;&lt;/a&gt;. Typically, the implementation would define additional units as conversions for the convenience of developers.</source>
          <target state="translated">구현시 &lt;a href=&quot;temporalamount#getUnits--&quot;&gt; &lt;code&gt;getUnits()&lt;/code&gt; &lt;/a&gt; 나열되지 않은 유닛에 대한 지원을 선언 할 수 있습니다 . 일반적으로 구현시 개발자 편의를 위해 추가 단위를 변환으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="90019721b0e69908f3a99c86842dc54fd684fc05" translate="yes" xml:space="preserve">
          <source>Implementations may define additional target names, but should use naming conventions such as reverse domain name notation to avoid name clashes.</source>
          <target state="translated">구현시 추가 대상 이름을 정의 할 수 있지만 이름 충돌을 방지하기 위해 역 도메인 이름 표기법과 같은 명명 규칙을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ed96c27054978247c25aafe7cde2ed3d3f6d247" translate="yes" xml:space="preserve">
          <source>Implementations may define implementation-specific keys.</source>
          <target state="translated">구현은 구현 별 키를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d744716af7fd8fb39c04d68e9c8e3b43a019eaf" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the millisecond observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">구현은 성능상의 이유로 캐싱 전략을 사용할 수 있습니다. 따라서이 클록을 통해 관찰 된 밀리 초의 시작이 기본 클록을 통해 직접 관찰 된 것보다 늦을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e57a2e93acdecde99104a5856de790d14178c604" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the minute observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">구현은 성능상의 이유로 캐싱 전략을 사용할 수 있습니다. 따라서이 클럭을 통해 관찰 된 분의 시작이 기본 클럭을 통해 직접 관찰 된 것보다 늦을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04f1ca2276b8a29b06fcbeeba05dd07d9e348abf" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the requested duration observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">구현은 성능상의 이유로 캐싱 전략을 사용할 수 있습니다. 따라서이 클럭을 통해 관찰 된 요청 지속 시간의 시작이 기본 클럭을 통해 직접 관찰 된 지속 시간보다 늦을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="267df03caeacf7ccfb622de33114e48140903168" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the second observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">구현은 성능상의 이유로 캐싱 전략을 사용할 수 있습니다. 따라서이 클럭을 통해 관찰 된 두 번째의 시작이 기본 클럭을 통해 직접 관찰 된 것보다 늦을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a423f39aec87a0b698a181814535acfa0c37d2" translate="yes" xml:space="preserve">
          <source>Implementations may, though they need not, include additional values in the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute to indicate the progress of the job, such as adding the &lt;code&gt;JOB_PRINTING&lt;/code&gt; value to indicate when the output device is actually making marks on paper and/or the &lt;code&gt;PROCESSING_TO_STOP_POINT&lt;/code&gt; value to indicate that the printer is in the process of canceling or aborting the job.</source>
          <target state="translated">구현은 필요하지 않지만 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가 값을 포함하여 출력 장치가 실제로 종이에 표시하는시기를 나타내는 &lt;code&gt;JOB_PRINTING&lt;/code&gt; 값 및 / 또는이 를 나타내는 &lt;code&gt;PROCESSING_TO_STOP_POINT&lt;/code&gt; 값을 추가하는 등 작업의 진행 상황 을 나타낼 수 있습니다. 프린터가 작업을 취소하거나 중단하는 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="72c785333a007e0af3308efdcee58fc2bb59ca70" translate="yes" xml:space="preserve">
          <source>Implementations may, though they need not, include additional values in the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute to indicate the progress of the job, such as adding the JOB_PRINTING value to indicate when the output device is actually making marks on paper and/or the PROCESSING_TO_STOP_POINT value to indicate that the printer is in the process of canceling or aborting the job.</source>
          <target state="translated">구현에 반드시 필요한 것은 아니지만 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 작업의 진행률을 나타내는 추가 값을 포함시킬 수 있습니다 ( 예 : 출력 장치가 실제로 종이에 표시를 표시하는시기 및 / 또는 PROCESSING_TO_STOP_POINT 값을 나타내는 작업을 나타내는 JOB_PRINTING 값 추가) 프린터가 작업을 취소하거나 중단하는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5c2a22452963a67974d8eca84853200d44148ad1" translate="yes" xml:space="preserve">
          <source>Implementations must begin by checking to ensure that the input temporal object is of the same observable type as the implementation. They must then perform the calculation for all instances of &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. An &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown for &lt;code&gt;ChronoUnit&lt;/code&gt; instances that are unsupported.</source>
          <target state="translated">구현은 입력 시간 객체가 구현과 동일한 관찰 가능한 유형인지 확인하여 시작해야합니다. 그런 다음 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 의&lt;/a&gt; 모든 인스턴스에 대해 계산을 수행해야합니다 . &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 은 위해 발생해야 &lt;code&gt;ChronoUnit&lt;/code&gt; 의 지원되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="bdb87811bb31cda5ac17ddd36108afefeabd84e6" translate="yes" xml:space="preserve">
          <source>Implementations must begin by checking to if the two temporals have the same type using &lt;code&gt;getClass()&lt;/code&gt;. If they do not, then the result must be obtained by calling &lt;code&gt;temporal1Inclusive.until(temporal2Exclusive, this)&lt;/code&gt;.</source>
          <target state="translated">구현은 &lt;code&gt;getClass()&lt;/code&gt; 사용하여 두 시간이 동일한 유형을 갖는지 확인하여 시작해야합니다 . 그렇지 않은 경우 &lt;code&gt;temporal1Inclusive.until(temporal2Exclusive, this)&lt;/code&gt; 호출하여 결과를 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="99c64c5755e63efaf236d48da5e987824e3c2112" translate="yes" xml:space="preserve">
          <source>Implementations must behave in a manor equivalent to the default method behavior.</source>
          <target state="translated">구현은 기본 메소드 동작과 동등한 방식으로 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="605da4bf3bfd7a213bfefbf11d71af5029cff3f0" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported and has an &lt;code&gt;int&lt;/code&gt; range, then the value of the field must be returned. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 필드를 확인하고 처리해야합니다 . 필드가 지원되고 범위 가 &lt;code&gt;int&lt;/code&gt; 인 경우 필드 값을 리턴해야합니다. 지원되지 않는 경우 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="326e8afcb79071d12736245c0670a0b22ed327ab" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then the adjustment must be performed. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 필드를 확인하고 처리해야합니다 . 필드가 지원되는 경우 조정을 수행해야합니다. 지원되지 않는 경우 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="24d6daafcab1ab7caec669e141738ff42d7ea11e" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then the range of the field must be returned. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 필드를 확인하고 처리해야합니다 . 필드가 지원되는 경우 필드 범위가 리턴되어야합니다. 지원되지 않는 경우 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d3ca1653868ebecb681dc93b4d875e227530a96" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then the value of the field must be returned. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 필드를 확인하고 처리해야합니다 . 필드가 지원되는 경우 필드 값이 리턴되어야합니다. 지원되지 않는 경우 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="88d058d164cfb523e09f28cd76915ef7323f9f89" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then true must be returned, otherwise false must be returned.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 필드를 확인하고 처리해야합니다 . 필드가 지원되면 true를 리턴하고 그렇지 않으면 false를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bd8473721518ac9344401f3ce0ebff69428b906" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all units defined in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. If the unit is supported, then the addition must be performed. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 장치를 확인하고 처리해야합니다 . 장치가 지원되는 경우 추가를 수행해야합니다. 지원되지 않는 경우 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="54a5a6f5a6257c54b041e51e2f466300a629dac3" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all units defined in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. If the unit is supported, then true must be returned, otherwise false must be returned.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 장치를 확인하고 처리해야합니다 . 장치가 지원되면 true를 리턴하고 그렇지 않으면 false를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="bac724627545efd92aff130adf9ca347e33f9433" translate="yes" xml:space="preserve">
          <source>Implementations must ensure that no observable state is altered when this read-only method is invoked.</source>
          <target state="translated">구현에서는이 읽기 전용 메소드가 호출 될 때 관찰 가능한 상태가 변경되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed106bff8c1e29175cd31f921160a542066c5d66" translate="yes" xml:space="preserve">
          <source>Implementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.</source>
          <target state="translated">구현시이 객체 또는 지정된 시간 객체를 변경해서는 안됩니다. 대신 조정 된 원본을 반환해야합니다. 이것은 불변 및 변경 가능한 구현에 대해 동등한 안전 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cd2cfa4068cda0e805725377df4ada91ed41d4d7" translate="yes" xml:space="preserve">
          <source>Implementations must not alter the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.</source>
          <target state="translated">구현시 지정된 임시 객체를 변경해서는 안됩니다. 대신 조정 된 원본을 반환해야합니다. 이것은 불변 및 변경 가능한 구현에 대해 동등한 안전 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3f230e75f808fadf35c94cfc851888119bcf87f0" translate="yes" xml:space="preserve">
          <source>Implementations must not alter this object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.</source>
          <target state="translated">구현시이 객체를 변경해서는 안됩니다. 대신 조정 된 원본을 반환해야합니다. 이것은 불변 및 변경 가능한 구현에 대해 동등한 안전 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74a6d982447b042f899eb1e8d5f95251242078cc" translate="yes" xml:space="preserve">
          <source>Implementations must provide a result for each valid zone ID, however they do not have to provide a history of rules. Thus the map will always contain one element, and will only contain more than one element if historical rule information is available.</source>
          <target state="translated">구현시 각 유효한 영역 ID에 대한 결과를 제공해야하지만 규칙 기록을 제공 할 필요는 없습니다. 따라서 맵에는 항상 하나의 요소가 포함되며 히스토리 규칙 정보가 사용 가능한 경우 하나 이상의 요소 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="25d23de117447ed754f1b335e41805de9782f446" translate="yes" xml:space="preserve">
          <source>Implementations must provide a result for each valid zone ID, however they do not have to provide a history of rules. Thus the map will contain at least one element, and will only contain more than one element if historical rule information is available.</source>
          <target state="translated">구현시 유효한 각 영역 ID에 대한 결과를 제공해야하지만 규칙 기록을 제공 할 필요는 없습니다. 따라서 맵에는 하나 이상의 요소가 포함되며, 과거 규칙 정보가 사용 가능한 경우 하나 이상의 요소 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c2fcd171ac5ea0d1a6a331955bf015198a85c6ae" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</source>
          <target state="translated">요소를 컬렉션으로 모으거나 다양한 기준에 따라 요소를 요약하는 등 다양한 유용한 축소 작업을 구현하는 &lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="56c583707ceca10be97e7528d97e75c1ef0caad2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;httprequest.bodypublisher&quot;&gt;&lt;code&gt;BodyPublisher&lt;/code&gt;&lt;/a&gt; that implement various useful publishers, such as publishing the request body from a String, or from a file.</source>
          <target state="translated">String 또는 파일에서 요청 본문을 게시하는 것과 같이 다양한 유용한 게시자를 구현하는 &lt;a href=&quot;httprequest.bodypublisher&quot;&gt; &lt;code&gt;BodyPublisher&lt;/code&gt; 의&lt;/a&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="f0e5930142ddaf85b2c690a6452341555a620717" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;&lt;code&gt;BodyHandler&lt;/code&gt;&lt;/a&gt; that implement various useful handlers, such as handling the response body as a String, or streaming the response body to a file.</source>
          <target state="translated">&lt;a href=&quot;httpresponse.bodyhandler&quot;&gt; &lt;code&gt;BodyHandler&lt;/code&gt; 의&lt;/a&gt; 구현응답 본문을 문자열로 처리하거나 응답 본문을 파일로 스트리밍하는 것과 같이 다양한 유용한 처리기를 .</target>
        </trans-unit>
        <trans-unit id="eafe6d74c7776fb65071b9a548e19a8c637730ac" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;&lt;code&gt;BodySubscriber&lt;/code&gt;&lt;/a&gt; that implement various useful subscribers, such as converting the response body bytes into a String, or streaming the bytes to a file.</source>
          <target state="translated">응답 본문 바이트를 문자열로 변환하거나 바이트를 파일로 스트리밍하는 등 다양한 유용한 구독자를 구현하는 &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt; &lt;code&gt;BodySubscriber&lt;/code&gt; 의&lt;/a&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="fda3fc111a7c70a81a169cb2fa4b3f7a1e491639" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;ModuleReader&lt;/code&gt; should take great care when translating an abstract resource name to the location of a resource in a packaged module or on the file system. Implementations are advised to treat resource names with elements such as '&lt;code&gt;.&lt;/code&gt;, '&lt;code&gt;..&lt;/code&gt;', elements containing file separators, or empty elements as &quot;not found&quot;. More generally, if the resource name is not in the stream of elements that the &lt;code&gt;list&lt;/code&gt; method returns then the resource should be treated as &quot;not found&quot; to avoid inconsistencies.</source>
          <target state="translated">&lt;code&gt;ModuleReader&lt;/code&gt; 의 구현은 추상 리소스 이름을 패키지 모듈 또는 파일 시스템의 리소스 위치로 변환 할 때 세심한주의를 기울여야합니다. 구현시 리소스 이름을 ' &lt;code&gt;.&lt;/code&gt; , ' &lt;code&gt;..&lt;/code&gt; ', 파일 구분 기호를 포함하는 요소 또는 &quot;찾을 수 없음&quot;으로 표시된 빈 요소. 보다 일반적으로 리소스 이름이 &lt;code&gt;list&lt;/code&gt; 메서드가 반환 하는 요소의 스트림에 없으면 불일치를 방지하기 위해 리소스를 &quot;찾을 수 없음&quot;으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="d62ca42b5c26ec3f438b17776a6e4557007f5596" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;TreeNode&lt;/code&gt; that override &lt;code&gt;equals&lt;/code&gt; will typically need to override &lt;code&gt;hashCode&lt;/code&gt; as well. Refer to &lt;a href=&quot;treemodel&quot;&gt;&lt;code&gt;TreeModel&lt;/code&gt;&lt;/a&gt; for more information. For further information and examples of using tree nodes, see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Tree Nodes&lt;/a&gt; in &lt;em&gt;The Java Tutorial.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; 를 재정의 하는 &lt;code&gt;TreeNode&lt;/code&gt; 의 구현 은 일반적으로 &lt;code&gt;hashCode&lt;/code&gt; 도 재정의해야합니다 . 자세한 내용은 &lt;a href=&quot;treemodel&quot;&gt; &lt;code&gt;TreeModel&lt;/code&gt; &lt;/a&gt; 을 참조하십시오. 더 자세한 정보와 트리 노드의 사용 예를 참조 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;하는 방법을 사용하여 트리 노드에&lt;/a&gt; 의 &lt;em&gt;자바 튜토리얼.&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993e4aede7d89287621098e82da0b0a8d21ce0b4" translate="yes" xml:space="preserve">
          <source>Implementations of entry-returning methods are expected to return &lt;code&gt;Map.Entry&lt;/code&gt; pairs representing snapshots of mappings at the time they were produced, and thus generally do &lt;em&gt;not&lt;/em&gt; support the optional &lt;code&gt;Entry.setValue&lt;/code&gt; method. Note however that it is possible to change mappings in the associated map using method &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">엔트리 리턴 메소드의 구현은 맵핑시 스냅 샷을 나타내는 &lt;code&gt;Map.Entry&lt;/code&gt; 쌍 을 리턴 할 것으로 예상 되므로 일반적으로 선택적 &lt;code&gt;Entry.setValue&lt;/code&gt; 메소드를 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그러나 &lt;code&gt;put&lt;/code&gt; 메소드를 사용하여 연관된 맵에서 맵핑을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3b30e509d044195699ed5241d1f9e400fe5a8aa" translate="yes" xml:space="preserve">
          <source>Implementations of the DataInput and DataOutput interfaces represent Unicode strings in a format that is a slight modification of UTF-8. (For information regarding the standard UTF-8 format, see section</source>
          <target state="translated">DataInput 및 DataOutput 인터페이스의 구현은 UTF-8을 약간 수정 한 형식으로 유니 코드 문자열을 나타냅니다. 표준 UTF-8 형식에 대한 정보는 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0a34c5a5639e138de40d514fc9cb6812e04cb9ff" translate="yes" xml:space="preserve">
          <source>Implementations of the Java time-scale using the JSR-310 API are not required to provide any clock that is sub-second accurate, or that progresses monotonically or smoothly. Implementations are therefore not required to actually perform the UTC-SLS slew or to otherwise be aware of leap seconds. JSR-310 does, however, require that implementations must document the approach they use when defining a clock representing the current instant. See &lt;a href=&quot;clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; for details on the available clocks.</source>
          <target state="translated">JSR-310 API를 사용한 Java 시간 스케일 구현은 1 초 미만의 정확하거나 단조롭게 또는 매끄럽게 진행되는 클럭을 제공 할 필요가 없습니다. 따라서 실제로 UTC-SLS 회전을 수행하거나 윤초를 인식 할 필요는 없습니다. 그러나 JSR-310은 구현시 현재 순간을 나타내는 시계를 정의 할 때 사용하는 접근 방식을 문서화해야합니다. 사용 가능한 시계에 대한 자세한 내용 은 &lt;a href=&quot;clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ee8c35661e0c08111bc2cda529b33eb9ba4c61e" translate="yes" xml:space="preserve">
          <source>Implementations of these locale sensitive services are packaged using the Java Extension Mechanism as installed extensions. A provider identifies itself with a provider-configuration file in the resource directory META-INF/services, using the fully qualified provider interface class name as the file name. The file should contain a list of fully-qualified concrete provider class names, one per line. A line is terminated by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('#'); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.</source>
          <target state="translated">이러한 로케일 구분 서비스의 구현은 Java 확장 메커니즘을 설치된 확장으로 사용하여 패키지됩니다. 제공자는 정규화 된 제공자 인터페이스 클래스 이름을 파일 이름으로 사용하여 META-INF / services 자원 디렉토리에있는 제공자 구성 파일로 자신을 식별합니다. 파일에는 한 줄에 하나씩 정규화 된 구체적 제공자 클래스 이름 목록이 포함되어야합니다. 줄 바꿈 ( '\ n'), 캐리지 리턴 ( '\ r') 또는 캐리지 리턴 뒤에 줄 바꿈이 있으면 줄이 종료됩니다. 빈 줄뿐만 아니라 각 이름을 둘러싼 공백과 탭 문자는 무시됩니다. 주석 문자는 '#'( '#')입니다. 각 줄에서 첫 번째 주석 문자 다음의 모든 문자는 무시됩니다. 파일은 UTF-8로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="acf4fcd382a74c4dbdd3e6fcf810f002d6e56033" translate="yes" xml:space="preserve">
          <source>Implementations of these locale sensitive services can be made available by adding them to the application's class path. A provider identifies itself with a provider-configuration file in the resource directory META-INF/services, using the fully qualified provider interface class name as the file name. The file should contain a list of fully-qualified concrete provider class names, one per line. A line is terminated by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('#'); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.</source>
          <target state="translated">이러한 로케일에 민감한 서비스의 구현은 애플리케이션의 클래스 경로에 추가하여 사용할 수 있습니다. 공급자는 완전한 공급자 인터페이스 클래스 이름을 파일 이름으로 사용하여 리소스 디렉터리 META-INF / services에있는 공급자 구성 파일로 자신을 식별합니다. 파일에는 한 줄에 하나씩 정규화 된 구체적인 공급자 클래스 이름 목록이 포함되어야합니다. 줄은 줄 바꿈 ( '\ n'), 캐리지 리턴 ( '\ r') 또는 캐리지 리턴 바로 다음에 줄 바꿈으로 끝납니다. 각 이름을 둘러싼 공백 및 탭 문자와 빈 줄은 무시됩니다. 주석 문자는 '#'( '#')입니다. 각 줄에서 첫 번째 주석 문자 다음의 모든 문자는 무시됩니다. 파일은 UTF-8로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9c79b815c8ed87dfe91404db79bb52d71de12170" translate="yes" xml:space="preserve">
          <source>Implementations of this class provide lookup services for print services (typically equivalent to printers) of a particular type.</source>
          <target state="translated">이 클래스의 구현은 특정 유형의 인쇄 서비스 (일반적으로 프린터와 동일)에 대한 조회 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="089a7b88f26f69596bf9828e528be33ab419614f" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationBroadcaster&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">이 인터페이스와 &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 의 구현은 동기화에주의해야합니다. 특히 구현이 리스너를 호출하는 동안 잠금을 유지하는 것은 좋은 생각이 아닙니다. 알림이 발송되는 동안 리스너 목록이 변경 될 수있는 가능성을 처리하려면 이 목록에 &lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f006a559626fb65e046d55aa1f754669269e0a38" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationBroadcaster&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">이 인터페이스와 &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 의 구현은 동기화에주의해야합니다. 특히, 구현이 리스너를 호출하는 동안 잠금을 보유하는 것은 좋지 않습니다. 알림이 발송되는 동안 리스너 목록이 변경 될 수있는 가능성을 처리하려면 이 목록에 &lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9c232244698db00ce36774a2c87375ef2ab6b6f4" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationEmitter&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">이 인터페이스와 &lt;code&gt;NotificationEmitter&lt;/code&gt; 의 구현은 동기화에주의해야합니다. 특히 구현이 리스너를 호출하는 동안 잠금을 유지하는 것은 좋은 생각이 아닙니다. 알림이 발송되는 동안 리스너 목록이 변경 될 수있는 가능성을 처리하려면 이 목록에 &lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="58aa1ab9d54f0bb6c3d1e90d7b35e36a53ae6ddf" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationEmitter&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">이 인터페이스와 &lt;code&gt;NotificationEmitter&lt;/code&gt; 의 구현은 동기화에주의해야합니다. 특히, 구현이 리스너를 호출하는 동안 잠금을 보유하는 것은 좋지 않습니다. 알림이 발송되는 동안 리스너 목록이 변경 될 수있는 가능성을 처리하려면 이 목록에 &lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="94b491a654af895b6d8857d4a56507944db181aa" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are attached to a &lt;a href=&quot;../docprintjob&quot;&gt;&lt;code&gt;DocPrintJob&lt;/code&gt;&lt;/a&gt; to monitor the status of attribute changes associated with the print job.</source>
          <target state="translated">이 인터페이스의 구현은 &lt;a href=&quot;../docprintjob&quot;&gt; &lt;code&gt;DocPrintJob&lt;/code&gt; &lt;/a&gt; 에 첨부되어 인쇄 작업과 관련된 속성 변경 상태를 모니터합니다.</target>
        </trans-unit>
        <trans-unit id="4aa8cb2baf5c284c221df16a7268ff0b1941abb2" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are immutable and safe for use by multiple concurrent threads.</source>
          <target state="translated">이 인터페이스의 구현은 여러 개의 동시 스레드에서 사용하기에 불변이며 안전합니다.</target>
        </trans-unit>
        <trans-unit id="49c062426f85483f883d6e693db7f7fa3fbe1290" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are passed to a &lt;code&gt;CallbackHandler&lt;/code&gt;, allowing underlying security services the ability to interact with a calling application to retrieve specific authentication data such as usernames and passwords, or to display certain information, such as error and warning messages.</source>
          <target state="translated">이 인터페이스의 구현은 &lt;code&gt;CallbackHandler&lt;/code&gt; 로 전달 되어 기본 보안 서비스가 호출 응용 프로그램과 상호 작용하여 사용자 이름 및 암호와 같은 특정 인증 데이터를 검색하거나 오류 및 경고 메시지와 같은 특정 정보를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58261f86ebc3621d1ab8d9da33065adeb7d657d0" translate="yes" xml:space="preserve">
          <source>Implementations of this interface can differ regarding the thread in which the methods of filters and listeners are called.</source>
          <target state="translated">이 인터페이스의 구현은 필터 및 리스너의 메소드가 호출되는 스레드와 관련하여 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027d52c95dd46e88fa1635d12867938271a5588b" translate="yes" xml:space="preserve">
          <source>Implementations of this interface should specify the events they support.</source>
          <target state="translated">이 인터페이스의 구현은 지원하는 이벤트를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6e3891d672494d0423b2340b5ba53445ff48f7f" translate="yes" xml:space="preserve">
          <source>Implementations of this listener interface are attached to a &lt;a href=&quot;../printservice&quot;&gt;&lt;code&gt;PrintService&lt;/code&gt;&lt;/a&gt; to monitor the status of the print service.</source>
          <target state="translated">이 리스너 인터페이스의 구현은 &lt;a href=&quot;../printservice&quot;&gt; &lt;code&gt;PrintService&lt;/code&gt; &lt;/a&gt; 에 접속되어 인쇄 서비스의 상태를 감시합니다.</target>
        </trans-unit>
        <trans-unit id="75c9d5402d09dbbffee2d3bf6c5bc10e82a612cd" translate="yes" xml:space="preserve">
          <source>Implementations of this listener interface should be attached to a &lt;a href=&quot;../docprintjob&quot;&gt;&lt;code&gt;DocPrintJob&lt;/code&gt;&lt;/a&gt; to monitor the status of the printer job.</source>
          <target state="translated">이 리스너 인터페이스의 구현은 &lt;a href=&quot;../docprintjob&quot;&gt; &lt;code&gt;DocPrintJob&lt;/code&gt; &lt;/a&gt; 에 첨부되어 프린터 작업의 상태를 모니터해야합니다.</target>
        </trans-unit>
        <trans-unit id="98cca08688fad60efd0ff1cada2bd3924fcafeb7" translate="yes" xml:space="preserve">
          <source>Implementations of this listener interface should be attached to a &lt;a href=&quot;../docprintjob&quot;&gt;&lt;code&gt;DocPrintJob&lt;/code&gt;&lt;/a&gt; to monitor the status of the printer job. These callback methods may be invoked on the thread processing the print job, or a service created notification thread. In either case the client should not perform lengthy processing in these callbacks.</source>
          <target state="translated">이 리스너 인터페이스의 구현은 &lt;a href=&quot;../docprintjob&quot;&gt; &lt;code&gt;DocPrintJob&lt;/code&gt; &lt;/a&gt; 에 첨부되어 프린터 작업의 상태를 모니터해야합니다. 이러한 콜백 메소드는 인쇄 작업을 처리하는 스레드 또는 서비스 작성 알림 스레드에서 호출 될 수 있습니다. 두 경우 모두 클라이언트는 이러한 콜백에서 긴 처리를 수행하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4402cd1b45417982edba7b2ac6df98c76b27647c" translate="yes" xml:space="preserve">
          <source>Implementations of this method are permitted, but not required, to return the same object from multiple invocations.</source>
          <target state="translated">이 메소드의 구현은, 복수의 호출로부터 같은 객체를 돌려주는 것이 허가됩니다 만, 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a1f0a740fb87b360af2d304f28d804dd997ef4e9" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;List&lt;/code&gt; object for each call. Using this method is likely to have comparable cost to using the like-named field. (Unlike this method, the field does not provide type safety.)</source>
          <target state="translated">이 메소드의 구현은 각 호출에 대해 별도의 &lt;code&gt;List&lt;/code&gt; 객체를 만들 필요는 없습니다 . 이 방법을 사용하면 비슷한 이름의 필드를 사용하는 것과 비슷한 비용이들 것입니다. (이 방법과 달리이 필드는 유형 안전을 제공하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="7d7e4eb6f727ccc34715a0e9ae615998421dde8c" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;Map&lt;/code&gt; object for each call. Using this method is likely to have comparable cost to using the like-named field. (Unlike this method, the field does not provide type safety.)</source>
          <target state="translated">이 메소드의 구현은 각 호출에 대해 별도의 &lt;code&gt;Map&lt;/code&gt; 객체를 만들 필요는 없습니다 . 이 방법을 사용하면 비슷한 이름의 필드를 사용하는 것과 비슷한 비용이들 것입니다. (이 방법과 달리이 필드는 유형 안전을 제공하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="f753f34db48ccb0310777f203dd093fd8129db52" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;NavigableMap&lt;/code&gt; object for each call.</source>
          <target state="translated">이 메소드의 구현은 각 호출에 대해 별도의 &lt;code&gt;NavigableMap&lt;/code&gt; 오브젝트를 작성할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="724af2588f9712c349db1f2980acabcda1643883" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;NavigableSet&lt;/code&gt; object for each call.</source>
          <target state="translated">이 메소드의 구현은 각 호출에 대해 별도의 &lt;code&gt;NavigableSet&lt;/code&gt; 객체를 만들 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8c569f90769c2ffcc16f17ff5ae79fd3729cd607" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;Set&lt;/code&gt; object for each call. Using this method is likely to have comparable cost to using the like-named field. (Unlike this method, the field does not provide type safety.)</source>
          <target state="translated">이 메소드의 구현은 각 호출에 대해 별도의 &lt;code&gt;Set&lt;/code&gt; 객체를 만들 필요는 없습니다 . 이 방법을 사용하면 비슷한 이름의 필드를 사용하는 것과 비슷한 비용이들 것입니다. (이 방법과 달리이 필드는 유형 안전을 제공하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="a6219835d128fc2b015c10dfba2058045935cdb9" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;SortedMap&lt;/code&gt; object for each call.</source>
          <target state="translated">이 메소드의 구현은 각 호출에 대해 별도의 &lt;code&gt;SortedMap&lt;/code&gt; 오브젝트를 작성할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4148397f35d90aa072e66df043b8d5c754ee09b6" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;SortedSet&lt;/code&gt; object for each call.</source>
          <target state="translated">이 메소드의 구현은 각 호출에 대해 별도의 &lt;code&gt;SortedSet&lt;/code&gt; 오브젝트를 작성할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fc865e84a8b192577a99b4d5bdcabe36bdf2a1ba" translate="yes" xml:space="preserve">
          <source>Implementations should combine duplicate TreePaths that are added to the selection. For example, the following code</source>
          <target state="translated">구현은 선택 항목에 추가 된 중복 TreePath를 결합해야합니다. 예를 들어, 다음 코드</target>
        </trans-unit>
        <trans-unit id="e09a8eb7b589680f1982a4e270b31adca911a817" translate="yes" xml:space="preserve">
          <source>Implementations should determine whether they are supported using the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현은 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 필드를 사용하여 지원되는지 여부를 결정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d0dc13ed50551259c51f74f77585ebb3686a0b5" translate="yes" xml:space="preserve">
          <source>Implementations should implement &lt;code&gt;Serializable&lt;/code&gt; wherever possible and must document whether or not they do support serialization.</source>
          <target state="translated">구현은 가능하면 &lt;code&gt;Serializable&lt;/code&gt; 가능을 구현해야하며 직렬화를 지원하는지 여부를 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f20a07b2b8fb2eb7d7481c5c66b280630e90b787" translate="yes" xml:space="preserve">
          <source>Implementations should override the default &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;isDestroyed&lt;/code&gt; methods from the &lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt;&lt;code&gt;Destroyable&lt;/code&gt;&lt;/a&gt; interface to enable sensitive key information to be destroyed, cleared, or in the case where such information is immutable, unreferenced. Finally, since &lt;code&gt;PrivateKey&lt;/code&gt; is &lt;code&gt;Serializable&lt;/code&gt;, implementations should also override &lt;a href=&quot;../io/objectoutputstream#writeObject(java.lang.Object)&quot;&gt;&lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt;&lt;/a&gt; to prevent keys that have been destroyed from being serialized.</source>
          <target state="translated">구현시 &lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt; &lt;code&gt;Destroyable&lt;/code&gt; &lt;/a&gt; 인터페이스 의 기본 &lt;code&gt;destroy&lt;/code&gt; 및 &lt;code&gt;isDestroyed&lt;/code&gt; 메서드를 재정 의하여 민감한 키 정보를 삭제, 삭제하거나 그러한 정보가 변경 불가능하거나 참조되지 않는 경우를 활성화해야합니다. 마지막으로 &lt;code&gt;PrivateKey&lt;/code&gt; 는 &lt;code&gt;Serializable&lt;/code&gt; 이므로 구현시 &lt;a href=&quot;../io/objectoutputstream#writeObject(java.lang.Object)&quot;&gt; &lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 도 재정 의하여 폐기 된 키가 직렬화되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2023f1a7cd65e43dc987df91289f438391353dd" translate="yes" xml:space="preserve">
          <source>Implementations should override the default &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;isDestroyed&lt;/code&gt; methods from the &lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt;&lt;code&gt;Destroyable&lt;/code&gt;&lt;/a&gt; interface to enable sensitive key information to be destroyed, cleared, or in the case where such information is immutable, unreferenced. Finally, since &lt;code&gt;PrivateKey&lt;/code&gt; is &lt;code&gt;Serializable&lt;/code&gt;, implementations should also override &lt;a href=&quot;../io/objectoutputstream#writeObject-java.lang.Object-&quot;&gt;&lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt;&lt;/a&gt; to prevent keys that have been destroyed from being serialized.</source>
          <target state="translated">구현시 &lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt; &lt;code&gt;Destroyable&lt;/code&gt; &lt;/a&gt; 인터페이스 에서 기본 &lt;code&gt;destroy&lt;/code&gt; 및 &lt;code&gt;isDestroyed&lt;/code&gt; 메소드를 대체하여 중요한 키 정보를 파기하거나 지우거나 그러한 정보를 변경할 수없는 경우 참조하지 않아야합니다. 마지막으로 &lt;code&gt;PrivateKey&lt;/code&gt; 는 &lt;code&gt;Serializable&lt;/code&gt; 이기 때문에 구현은 &lt;a href=&quot;../io/objectoutputstream#writeObject-java.lang.Object-&quot;&gt; &lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 를 재정 의하여 파괴 된 키가 직렬화되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f89a141b40f5b504d614a3aa48c27dfceeae9ae" translate="yes" xml:space="preserve">
          <source>Implementations should perform any queries or calculations using the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is not supported an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 필드를 사용하여 쿼리 또는 계산을 수행해야합니다 . 필드가 지원 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 경우 UnsupportedTemporalTypeException 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb7adf8c98b0949039b35e12066594b1afab0446" translate="yes" xml:space="preserve">
          <source>Implementations should perform any queries or calculations using the units available in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; or the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the unit is not supported an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 단위 또는 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 필드를 사용하여 쿼리 또는 계산을 수행해야합니다 . 장치가 지원 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 않으면 UnsupportedTemporalTypeException 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ceb7c1ca9b69ca4554167b37ceed67cb09622fc" translate="yes" xml:space="preserve">
          <source>Implementations should perform any queries or calculations using the units available in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; or the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the unit is not supported an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown. Implementations must not alter the specified temporal objects.</source>
          <target state="translated">구현시 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 단위 또는 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 필드를 사용하여 쿼리 또는 계산을 수행해야합니다 . 장치가 지원 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 않으면 UnsupportedTemporalTypeException 이 발생해야합니다. 구현시 지정된 임시 객체를 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f4c8d5deb5010407f725941d6330fb83e7adf8c4" translate="yes" xml:space="preserve">
          <source>Implementations should raise other exceptions under other circumstances. For example, implementations should raise an implementation-dependent exception if a &lt;code&gt;null&lt;/code&gt; argument is passed when &lt;code&gt;null&lt;/code&gt; was not expected.</source>
          <target state="translated">구현은 다른 상황에서 다른 예외를 발생시켜야합니다. 예를 들어, 구현 의존의 예외를 제기해야 &lt;code&gt;null&lt;/code&gt; 때 인수 전달 &lt;code&gt;null&lt;/code&gt; 예상되지 않았다.</target>
        </trans-unit>
        <trans-unit id="d8fb224f30dd82a4384971b67059784a6d15590c" translate="yes" xml:space="preserve">
          <source>Implementations should transparently handle artifacts of the transmission protocol. For example, when using the T=0 protocol, the following processing should occur as described in ISO/IEC 7816-4:</source>
          <target state="translated">구현은 전송 프로토콜의 아티팩트를 투명하게 처리해야합니다. 예를 들어 T = 0 프로토콜을 사용하는 경우 ISO / IEC 7816-4에 설명 된대로 다음 처리가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="9525ca7fbcb8134eb42edfabd5ffb3edf11a4d7c" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial ACL when creating a file or directory. The initial ACL may be provided to methods such as &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; as an &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value()&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the list of &lt;code&gt;AclEntry&lt;/code&gt; objects.</source>
          <target state="translated">이 속성보기를 지원하는 구현은 파일 또는 디렉토리를 만들 때 초기 ACL 설정을 지원할 수도 있습니다. 초기 ACL은 다음과 같은 방법으로 제공 될 수있다 &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt; 이 AS &lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; 및 &lt;a href=&quot;fileattribute#value()&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt; 들의 목록 &lt;code&gt;AclEntry&lt;/code&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="9265c990fd1a70dc9468d67065e182a75e5b85cc" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial ACL when creating a file or directory. The initial ACL may be provided to methods such as &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; as an &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value--&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the list of &lt;code&gt;AclEntry&lt;/code&gt; objects.</source>
          <target state="translated">이 속성보기를 지원하는 구현은 파일 또는 디렉토리를 작성할 때 초기 ACL 설정을 지원할 수도 있습니다. 초기 ACL은 다음과 같은 방법으로 제공 될 수있다 &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt; 이 AS &lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; 및 &lt;a href=&quot;fileattribute#value--&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt; 들의 목록 &lt;code&gt;AclEntry&lt;/code&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="10dd796e1e9bf0840bd0fadcb7619888855b0e5e" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial permissions when creating a file or directory. The initial permissions are provided to the &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods as a &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value()&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the set of permissions. The following example uses the &lt;a href=&quot;posixfilepermissions#asFileAttribute(java.util.Set)&quot;&gt;&lt;code&gt;asFileAttribute&lt;/code&gt;&lt;/a&gt; method to construct a &lt;code&gt;FileAttribute&lt;/code&gt; when creating a file:</source>
          <target state="translated">이 속성보기를 지원하는 구현은 파일 또는 디렉토리를 만들 때 초기 권한 설정을 지원할 수도 있습니다. 초기 권한이 제공된다 &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt; A와 방법 &lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; 및 &lt;a href=&quot;fileattribute#value()&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt; 권한의 집합이다. 다음 예제에서는 &lt;a href=&quot;posixfilepermissions#asFileAttribute(java.util.Set)&quot;&gt; &lt;code&gt;asFileAttribute&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 파일을 만들 때 &lt;code&gt;FileAttribute&lt;/code&gt; 를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c46af4741218e7b1b97c7da9603c5a880f593947" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial permissions when creating a file or directory. The initial permissions are provided to the &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods as a &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value--&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the set of permissions. The following example uses the &lt;a href=&quot;posixfilepermissions#asFileAttribute-java.util.Set-&quot;&gt;&lt;code&gt;asFileAttribute&lt;/code&gt;&lt;/a&gt; method to construct a &lt;code&gt;FileAttribute&lt;/code&gt; when creating a file:</source>
          <target state="translated">이 속성보기를 지원하는 구현은 파일 또는 디렉토리를 작성할 때 초기 권한 설정을 지원할 수도 있습니다. 초기 권한은 &lt;a href=&quot;fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; 이고 권한 세트 인 &lt;a href=&quot;fileattribute#value--&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt; 을 가진 &lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt; 메소드에 제공됩니다 . 다음 예제는 파일을 작성할 때 &lt;a href=&quot;posixfilepermissions#asFileAttribute-java.util.Set-&quot;&gt; &lt;code&gt;asFileAttribute&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;FileAttribute&lt;/code&gt; 를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="e4f7352bd5189bae4e86402d1ca84f5a70c34ad4" translate="yes" xml:space="preserve">
          <source>Implemented by a service provider, used by the static methods of this class.</source>
          <target state="translated">서비스 프로 바이더가 구현해,이 클래스의 정적 메소드에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d27247adfc98a632446be7b025feb0b66fde48b" translate="yes" xml:space="preserve">
          <source>Implemented by objects that can have a &lt;code&gt;JMXServiceURL&lt;/code&gt; address.</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 주소를 가질 수있는 객체로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="e18ec9389651cc68787839f4398e87d90fd1fb0e" translate="yes" xml:space="preserve">
          <source>Implemented by objects that can have a &lt;code&gt;JMXServiceURL&lt;/code&gt; address. All &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt; objects implement this interface. Depending on the connector implementation, a &lt;a href=&quot;jmxconnector&quot;&gt;&lt;code&gt;JMXConnector&lt;/code&gt;&lt;/a&gt; object may implement this interface too. &lt;code&gt;JMXConnector&lt;/code&gt; objects for the RMI Connector are instances of &lt;a href=&quot;../../../../java.management.rmi/javax/management/remote/rmi/rmiconnector&quot;&gt;&lt;code&gt;RMIConnector&lt;/code&gt;&lt;/a&gt; which implements this interface.</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 주소를 가질 수있는 객체에 의해 구현됩니다 . 모든 &lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt; 객체는이 인터페이스를 구현합니다. 커넥터 구현에 따라 &lt;a href=&quot;jmxconnector&quot;&gt; &lt;code&gt;JMXConnector&lt;/code&gt; &lt;/a&gt; 객체도이 인터페이스를 구현할 수 있습니다. RMI 커넥터 용 &lt;code&gt;JMXConnector&lt;/code&gt; 객체는 이 인터페이스를 구현 하는 &lt;a href=&quot;../../../../java.management.rmi/javax/management/remote/rmi/rmiconnector&quot;&gt; &lt;code&gt;RMIConnector&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="61cd05b213ed2ee1d81c4aee8d8fd0536738b4af" translate="yes" xml:space="preserve">
          <source>Implemented by objects that can have a &lt;code&gt;JMXServiceURL&lt;/code&gt; address. All &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt; objects implement this interface. Depending on the connector implementation, a &lt;a href=&quot;jmxconnector&quot;&gt;&lt;code&gt;JMXConnector&lt;/code&gt;&lt;/a&gt; object may implement this interface too. &lt;code&gt;JMXConnector&lt;/code&gt; objects for the RMI Connector are instances of &lt;a href=&quot;rmi/rmiconnector&quot;&gt;&lt;code&gt;RMIConnector&lt;/code&gt;&lt;/a&gt; which implements this interface.</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 주소를 가질 수있는 객체로 구현됩니다 . 모든 &lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt; 객체는이 인터페이스를 구현합니다. 커넥터 구현에 따라 &lt;a href=&quot;jmxconnector&quot;&gt; &lt;code&gt;JMXConnector&lt;/code&gt; &lt;/a&gt; 객체도이 인터페이스를 구현할 수 있습니다. RMI 커넥터의 &lt;code&gt;JMXConnector&lt;/code&gt; 객체는 이 인터페이스를 구현 하는 &lt;a href=&quot;rmi/rmiconnector&quot;&gt; &lt;code&gt;RMIConnector&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="e3d61810bc73f33e4e00486624813fd3c76d0745" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt; -- does nothing.</source>
          <target state="translated">&lt;code&gt;MenuElement&lt;/code&gt; 로 구현 됨 -아무것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbf96cb764bf289e584a3256d8b7340a013852d9" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt; -- returns the menus in this menu bar.</source>
          <target state="translated">&lt;code&gt;MenuElement&lt;/code&gt; 로 구현 됨 -이 메뉴 모음의 메뉴를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49ed97f064afc431455d8a8d0c9ee34d43d19b3b" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt; -- returns the menus in this menu bar. This is the reason for implementing the &lt;code&gt;MenuElement&lt;/code&gt; interface -- so that the menu bar can be treated the same as other menu elements.</source>
          <target state="translated">&lt;code&gt;MenuElement&lt;/code&gt; 로 구현 됨 -이 메뉴 모음의 메뉴를 반환합니다. 이것이 &lt;code&gt;MenuElement&lt;/code&gt; 인터페이스 를 구현하는 이유 입니다. 메뉴 모음을 다른 메뉴 요소와 동일하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="af39823a4addc01a879447b01511360237f5e522" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MenuElement&lt;/code&gt; 로 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e7203d79e1e510762b33e93ba6a7d51389952311" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt;. Returns this object.</source>
          <target state="translated">&lt;code&gt;MenuElement&lt;/code&gt; 로 구현되었습니다 . 이 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6106e4896a692c93ab85fcb3e444b73ba8fbeee9" translate="yes" xml:space="preserve">
          <source>Implementer's Guide</source>
          <target state="translated">구현 자 가이드</target>
        </trans-unit>
        <trans-unit id="492fa413aa34c053a664565f4e23bc9d32ccaa54" translate="yes" xml:space="preserve">
          <source>Implementers should specify the name of an appropriate class to be instantiated if no other implementation resolution mechanism succeeds.</source>
          <target state="translated">구현자는 다른 구현 확인 메커니즘이 성공하지 못할 경우 인스턴스화 할 적절한 클래스의 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6316c998aaf80f52e21906c45a08ecf6dd94f2cb" translate="yes" xml:space="preserve">
          <source>Implementing the Externalizable interface allows the object to assume complete control over the contents and format of the object's serialized form. The methods of the Externalizable interface, writeExternal and readExternal, are called to save and restore the objects state. When implemented by a class they can write and read their own state using all of the methods of ObjectOutput and ObjectInput. It is the responsibility of the objects to handle any versioning that occurs.</source>
          <target state="translated">Externalizable 인터페이스를 구현하면 객체의 직렬화 된 양식의 내용과 형식을 완전히 제어 할 수 있습니다. Externalizable 인터페이스의 메소드 인 writeExternal 및 readExternal은 오브젝트 상태를 저장하고 복원하기 위해 호출됩니다. 클래스에 의해 구현되면 ObjectOutput 및 ObjectInput의 모든 메소드를 사용하여 자체 상태를 읽고 읽을 수 있습니다. 발생하는 모든 버전 관리를 처리하는 것은 객체의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="85a1b32441e6f8998efff0a593cf96d0554294af" translate="yes" xml:space="preserve">
          <source>Implementing the MemoryPool object works similarly for both Standard MBeans and MXBeans.</source>
          <target state="translated">MemoryPool 객체 구현은 표준 MBean과 MXBean 모두에서 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b27273a4fe2fe56656ab15058c038de342b8f1ba" translate="yes" xml:space="preserve">
          <source>Implementing the Serializable interface allows object serialization to save and restore the entire state of the object and it allows classes to evolve between the time the stream is written and the time it is read. It automatically traverses references between objects, saving and restoring entire graphs.</source>
          <target state="translated">Serializable 인터페이스를 구현하면 객체 직렬화를 통해 객체의 전체 상태를 저장 및 복원 할 수 있으며 스트림이 작성된 시간과 읽은 시간 사이에서 클래스가 발전 할 수 있습니다. 전체 그래프를 저장하고 복원하면서 객체 간의 참조를 자동으로 순회합니다.</target>
        </trans-unit>
        <trans-unit id="c4eba021a9e9d2a95adfd121f50523d25266d18b" translate="yes" xml:space="preserve">
          <source>Implementing this interface allows an object to be the target of the &quot;for-each loop&quot; statement.</source>
          <target state="translated">이 인터페이스를 구현하면 객체가 &quot;for-each loop&quot;문의 대상이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c3a655b63b5ea1f21619a61f5d5ab25bccd7b1" translate="yes" xml:space="preserve">
          <source>Implementing this interface allows an object to be the target of the &quot;for-each loop&quot; statement. See &lt;strong&gt; &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/language/foreach.html&quot;&gt;For-each Loop&lt;/a&gt; &lt;/strong&gt;</source>
          <target state="translated">이 인터페이스를 구현하면 객체가 &quot;for-each loop&quot;문의 대상이 될 수 있습니다. &lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/language/foreach.html&quot;&gt;For-each 루프&lt;/a&gt;&lt;/strong&gt; 참조&lt;strong&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="677667db2207746335237bb2c25d22bd60cea248" translate="yes" xml:space="preserve">
          <source>Implementing this interface allows an object to be the target of the enhanced &lt;code&gt;for&lt;/code&gt; statement (sometimes called the &quot;for-each loop&quot; statement).</source>
          <target state="translated">이 인터페이스를 구현하면 객체가 향상된 &lt;code&gt;for&lt;/code&gt; 문의 대상이 될 수 있습니다 ( &quot;for-each 루프&quot;문이라고도 함).</target>
        </trans-unit>
        <trans-unit id="16b8440feaff663be30e5ff98a6229d156358ad9" translate="yes" xml:space="preserve">
          <source>Implementors and developers should pay particular attention to how the features set on this &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; are processed by this special &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;. In some cases, for example, when the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; and the class actually loading the schema come from different implementations, it may not be possible for &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; features to be inherited automatically. Developers should make sure that features, such as secure processing, are explicitly set in both places.</source>
          <target state="translated">구현 자와 개발자는이 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; 에&lt;/a&gt; 설정된 기능 이이 특수 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; 에&lt;/a&gt; 의해 처리되는 방식에 특히주의해야합니다 . 예를 들어, &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; 와 실제로 스키마를로드하는 클래스가 다른 구현에서 오는 경우 와 같이 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; 기능이 자동으로 상속 되지 않을 수 있습니다 . 개발자는 보안 처리와 같은 기능이 두 위치 모두에 명시 적으로 설정되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="99951e523cfc57b1343f700e7220490f37aa210c" translate="yes" xml:space="preserve">
          <source>Implementors and developers should pay particular attention to how the special &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; object returned by &lt;a href=&quot;#newSchema()&quot;&gt;&lt;code&gt;newSchema()&lt;/code&gt;&lt;/a&gt; is processed. In some cases, for example, when the &lt;code&gt;SchemaFactory&lt;/code&gt; and the class actually loading the schema come from different implementations, it may not be possible for &lt;code&gt;SchemaFactory&lt;/code&gt; features to be inherited automatically. Developers should make sure that features, such as secure processing, are explicitly set in both places.</source>
          <target state="translated">구현 자와 개발자는 &lt;a href=&quot;#newSchema()&quot;&gt; &lt;code&gt;newSchema()&lt;/code&gt; &lt;/a&gt; 반환 된 특수 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; 개체 가 처리 되는 방식에 특히주의해야 합니다. 예를 들어, &lt;code&gt;SchemaFactory&lt;/code&gt; 와 실제로 스키마를로드하는 클래스가 서로 다른 구현에서 오는 경우 와 같이 &lt;code&gt;SchemaFactory&lt;/code&gt; 기능이 자동으로 상속 되지 않을 수 있습니다 . 개발자는 보안 처리와 같은 기능이 두 위치 모두에 명시 적으로 설정되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="8577e7b0e57464789c03fce26dcd7c74511a3795" translate="yes" xml:space="preserve">
          <source>Implementors are free (and encouraged) to invent their own features, using names built on their own URIs.</source>
          <target state="translated">Implementors are free (and encouraged) to invent their own features, using names built on their own URIs.</target>
        </trans-unit>
        <trans-unit id="dc3a77180c30a4d8539025481958848c09be493e" translate="yes" xml:space="preserve">
          <source>Implementors are free (and encouraged) to invent their own properties, using names built on their own URIs.</source>
          <target state="translated">Implementors are free (and encouraged) to invent their own properties, using names built on their own URIs.</target>
        </trans-unit>
        <trans-unit id="ee508ec5b0694cae10b7518c95bffc14abcc25ed" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app becomes the foreground app and when it is no longer the foreground app.</source>
          <target state="translated">Implementors are notified when the app becomes the foreground app and when it is no longer the foreground app.</target>
        </trans-unit>
        <trans-unit id="ba3e9207c3154f7847ddc0b6161132c852925581" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app becomes the foreground app and when it is no longer the foreground app. This notification is useful for hiding and showing transient UI like palette windows which should be hidden when the app is in the background.</source>
          <target state="translated">Implementors are notified when the app becomes the foreground app and when it is no longer the foreground app. This notification is useful for hiding and showing transient UI like palette windows which should be hidden when the app is in the background.</target>
        </trans-unit>
        <trans-unit id="9d37a186316d3ce73428e4b8ed79605fa6ada0ad" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app is hidden or shown by the user.</source>
          <target state="translated">Implementors are notified when the app is hidden or shown by the user.</target>
        </trans-unit>
        <trans-unit id="275d1a155c071e2398e4415f5c0fade0a1bc4c93" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app is hidden or shown by the user. This notification is helpful for discontinuing a costly animation if it's not visible to the user.</source>
          <target state="translated">Implementors are notified when the app is hidden or shown by the user. This notification is helpful for discontinuing a costly animation if it's not visible to the user.</target>
        </trans-unit>
        <trans-unit id="138204779c48d5972dd906bafe8996d60eaece4f" translate="yes" xml:space="preserve">
          <source>Implementors must override the nine abstract service-provider interface (SPI) methods: &lt;a href=&quot;#getSpi(java.lang.String)&quot;&gt;&lt;code&gt;getSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#removeNodeSpi()&quot;&gt;&lt;code&gt;removeNodeSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#keysSpi()&quot;&gt;&lt;code&gt;keysSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#childrenNamesSpi()&quot;&gt;&lt;code&gt;childrenNamesSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#syncSpi()&quot;&gt;&lt;code&gt;syncSpi()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flushSpi()&quot;&gt;&lt;code&gt;flushSpi()&lt;/code&gt;&lt;/a&gt;. All of the concrete methods specify precisely how they are implemented atop these SPI methods. The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance.</source>
          <target state="translated">Implementors must override the nine abstract service-provider interface (SPI) methods: &lt;a href=&quot;#getSpi(java.lang.String)&quot;&gt; &lt;code&gt;getSpi(String)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#removeNodeSpi()&quot;&gt; &lt;code&gt;removeNodeSpi()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#keysSpi()&quot;&gt; &lt;code&gt;keysSpi()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#childrenNamesSpi()&quot;&gt; &lt;code&gt;childrenNamesSpi()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#syncSpi()&quot;&gt; &lt;code&gt;syncSpi()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#flushSpi()&quot;&gt; &lt;code&gt;flushSpi()&lt;/code&gt; &lt;/a&gt;. All of the concrete methods specify precisely how they are implemented atop these SPI methods. The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance.</target>
        </trans-unit>
        <trans-unit id="cfc9c018f8a42ee85a1ab091653d70a1654d6247" translate="yes" xml:space="preserve">
          <source>Implementors must override the nine abstract service-provider interface (SPI) methods: &lt;a href=&quot;abstractpreferences#getSpi-java.lang.String-&quot;&gt;&lt;code&gt;getSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#removeNodeSpi--&quot;&gt;&lt;code&gt;removeNodeSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#keysSpi--&quot;&gt;&lt;code&gt;keysSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#childrenNamesSpi--&quot;&gt;&lt;code&gt;childrenNamesSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#syncSpi--&quot;&gt;&lt;code&gt;syncSpi()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;abstractpreferences#flushSpi--&quot;&gt;&lt;code&gt;flushSpi()&lt;/code&gt;&lt;/a&gt;. All of the concrete methods specify precisely how they are implemented atop these SPI methods. The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance.</source>
          <target state="translated">구현자는 9 개의 추상 서비스 제공자 인터페이스 (SPI) 메소드를 대체해야합니다. &lt;a href=&quot;abstractpreferences#getSpi-java.lang.String-&quot;&gt; &lt;code&gt;getSpi(String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#removeNodeSpi--&quot;&gt; &lt;code&gt;removeNodeSpi()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#keysSpi--&quot;&gt; &lt;code&gt;keysSpi()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#childrenNamesSpi--&quot;&gt; &lt;code&gt;childrenNamesSpi()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#syncSpi--&quot;&gt; &lt;code&gt;syncSpi()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;abstractpreferences#flushSpi--&quot;&gt; &lt;code&gt;flushSpi()&lt;/code&gt; &lt;/a&gt; . 모든 구체적인 방법은 이러한 SPI 방법 위에 어떻게 구현되는지 정확하게 지정합니다. 구현자는 기본 구현이 성능과 같은 어떤 이유로 만족스럽지 않은 경우 재량으로 하나 이상의 구체적인 방법을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aead7400492ac0da3dcc2b29c778531e2a05071f" translate="yes" xml:space="preserve">
          <source>Implementors of serializable lambdas, such as compilers or language runtime libraries, are expected to ensure that instances deserialize properly. One means to do so is to ensure that the &lt;code&gt;writeReplace&lt;/code&gt; method returns an instance of &lt;code&gt;SerializedLambda&lt;/code&gt;, rather than allowing default serialization to proceed.</source>
          <target state="translated">컴파일러 또는 언어 런타임 라이브러리와 같은 직렬화 가능한 람다의 구현자는 인스턴스가 직렬화 해제되도록 보장해야합니다. 그렇게하는 한 가지 방법은 &lt;code&gt;writeReplace&lt;/code&gt; 메소드가 기본 직렬화를 진행하지 않고 &lt;code&gt;SerializedLambda&lt;/code&gt; 인스턴스를 리턴하도록 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="44c88085cccf2d65812bb1fc7a1aca637317273a" translate="yes" xml:space="preserve">
          <source>Implementors of this class which wrap an underlying implementation can consider using the &lt;a href=&quot;../../../org/xml/sax/helpers/parseradapter&quot;&gt;&lt;code&gt;ParserAdapter&lt;/code&gt;&lt;/a&gt; class to initially adapt their SAX1 implementation to work under this revised class.</source>
          <target state="translated">Implementors of this class which wrap an underlying implementation can consider using the &lt;a href=&quot;../../../org/xml/sax/helpers/parseradapter&quot;&gt; &lt;code&gt;ParserAdapter&lt;/code&gt; &lt;/a&gt; class to initially adapt their SAX1 implementation to work under this revised class.</target>
        </trans-unit>
        <trans-unit id="659cd7b74c1d7802de5869ebeaf003d5a53e8f3a" translate="yes" xml:space="preserve">
          <source>Implementors of this interface may find it convenient to extend &lt;a href=&quot;abstractprocessor&quot;&gt;&lt;code&gt;AbstractProcessor&lt;/code&gt;&lt;/a&gt; rather than implementing this interface directly.</source>
          <target state="translated">Implementors of this interface may find it convenient to extend &lt;a href=&quot;abstractprocessor&quot;&gt; &lt;code&gt;AbstractProcessor&lt;/code&gt; &lt;/a&gt; rather than implementing this interface directly.</target>
        </trans-unit>
        <trans-unit id="d68709ed0031e9d20d4e17ec993bab81dd93a700" translate="yes" xml:space="preserve">
          <source>Implementors receive notification as the system is entering sleep, and after the system wakes.</source>
          <target state="translated">Implementors receive notification as the system is entering sleep, and after the system wakes.</target>
        </trans-unit>
        <trans-unit id="7798e91330173822181e6655dadd7e58496cc350" translate="yes" xml:space="preserve">
          <source>Implementors receive notification as the system is entering sleep, and after the system wakes. This notification is useful for disconnecting from network services prior to sleep, or re-establishing a connection if the network configuration has changed during sleep.</source>
          <target state="translated">Implementors receive notification as the system is entering sleep, and after the system wakes. This notification is useful for disconnecting from network services prior to sleep, or re-establishing a connection if the network configuration has changed during sleep.</target>
        </trans-unit>
        <trans-unit id="447da6c7b13c5c1f40bebb620e8d04cab91b424d" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the app has been asked to open again.</source>
          <target state="translated">Implementors receive notification when the app has been asked to open again.</target>
        </trans-unit>
        <trans-unit id="8d4c4b3d7fe642c2f0cbd29a70ec392e711ab9d9" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the app has been asked to open again. This notification is useful for showing a new document when your app has no open windows.</source>
          <target state="translated">Implementors receive notification when the app has been asked to open again. This notification is useful for showing a new document when your app has no open windows.</target>
        </trans-unit>
        <trans-unit id="aa5fd4cfebec19ecb97f8db63b20c59efe6a87de" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the displays attached to the system have entered power save sleep.</source>
          <target state="translated">Implementors receive notification when the displays attached to the system have entered power save sleep.</target>
        </trans-unit>
        <trans-unit id="f3ac142b1424fd9c9ed9c1112ef26559d15b4ba3" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the displays attached to the system have entered power save sleep. This notification is useful for discontinuing a costly animation, or indicating that the user is no longer present on a network service.</source>
          <target state="translated">Implementors receive notification when the displays attached to the system have entered power save sleep. This notification is useful for discontinuing a costly animation, or indicating that the user is no longer present on a network service.</target>
        </trans-unit>
        <trans-unit id="a8b4aaea29398e416216bb5778297092d40e3545" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the user session changes.</source>
          <target state="translated">Implementors receive notification when the user session changes.</target>
        </trans-unit>
        <trans-unit id="4e1a43914199e6b094a085a07ae83622bf99a286" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the user session changes. This notification is useful for discontinuing a costly animation, or indicating that the user is no longer present on a network service. Some systems may provide a reason of the user session change.</source>
          <target state="translated">Implementors receive notification when the user session changes. This notification is useful for discontinuing a costly animation, or indicating that the user is no longer present on a network service. Some systems may provide a reason of the user session change.</target>
        </trans-unit>
        <trans-unit id="aa19933155a45f4e0ac8040534fd17524cd4459a" translate="yes" xml:space="preserve">
          <source>Implementors should assure that the properties set on the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; that created this &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; are also set on the &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; constructed.</source>
          <target state="translated">Implementors should assure that the properties set on the &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; that created this &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; are also set on the &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; constructed.</target>
        </trans-unit>
        <trans-unit id="c34a71d5c363e25ed5c27a45f3f354fa775afff6" translate="yes" xml:space="preserve">
          <source>Implementors should assure that the properties set on the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; that created this &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; are also set on the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; constructed.</source>
          <target state="translated">Implementors should assure that the properties set on the &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; that created this &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; are also set on the &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; constructed.</target>
        </trans-unit>
        <trans-unit id="a6eff8d7cc5d25aa20d533294644c7c1a063c35c" translate="yes" xml:space="preserve">
          <source>Implementors should note that there is also a &lt;code&gt;ContentHandler&lt;/code&gt; class in the &lt;code&gt;java.net&lt;/code&gt; package; that means that it's probably a bad idea to do</source>
          <target state="translated">Implementors should note that there is also a &lt;code&gt;ContentHandler&lt;/code&gt; class in the &lt;code&gt;java.net&lt;/code&gt; package; that means that it's probably a bad idea to do</target>
        </trans-unit>
        <trans-unit id="59e497ae7e63a78a2d82a59d17c0703a451bb786" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a83a690b5e99d54d516b6b75e55e496defe55a9b" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt;. For the purpose of resolving &lt;code&gt;publicId&lt;/code&gt; and &lt;code&gt;systemId&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;. For the purpose of resolving &lt;code&gt;publicId&lt;/code&gt; and &lt;code&gt;systemId&lt;/code&gt; , this method is equivalent to &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="62ff680457fbba2bd8145e76bbc89b6262c6dacf" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="483362f4faeee60c16638b977df7afab8a6d2ef0" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt;. The method searches through the catalog entries in the main and alternative catalogs to attempt to find a match with the specified &lt;code&gt;publicId&lt;/code&gt; or systemId.</source>
          <target state="translated">Implements &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt;. The method searches through the catalog entries in the main and alternative catalogs to attempt to find a match with the specified &lt;code&gt;publicId&lt;/code&gt; or systemId.</target>
        </trans-unit>
        <trans-unit id="f1d270d856595d65238b888f07006bd1a30a5f8c" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../stream/xmlresolver&quot;&gt;&lt;code&gt;XMLResolver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements &lt;a href=&quot;../stream/xmlresolver&quot;&gt; &lt;code&gt;XMLResolver&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ddbd6ccd580e849d089ad33405309e2013332735" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../stream/xmlresolver&quot;&gt;&lt;code&gt;XMLResolver&lt;/code&gt;&lt;/a&gt;. For the purpose of resolving &lt;code&gt;publicId&lt;/code&gt; and &lt;code&gt;systemId&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements &lt;a href=&quot;../stream/xmlresolver&quot;&gt; &lt;code&gt;XMLResolver&lt;/code&gt; &lt;/a&gt;. For the purpose of resolving &lt;code&gt;publicId&lt;/code&gt; and &lt;code&gt;systemId&lt;/code&gt; , this method is equivalent to &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8863098812e88b16cb4e5ec4c94cb23e73164a4a" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.current() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.current ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="38609ff217165cfd288c6a9112395629b53b1ba0" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.first() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.first ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2061a474328a606288949699b4d01ead864c594e" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.getBeginIndex() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.getBeginIndex ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f3e0d313072ecadecf8f42575d03f852e7618f30" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.getEndIndex() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.getEndIndex ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="37d2fcb4f6e906f747d683461fcc4508ccb0e9f3" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.getIndex() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.getIndex ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e6267a8f45083745718daf081f7ae536fff0541e" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.last() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.last ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9ca927fd2f3bfbd655d908c44ae43b9f811f2ea5" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.next() for String.</source>
          <target state="translated">String 용 CharacterIterator.next ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6fa220d3128cac8bac5353ff3943c263da81da91" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.previous() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.previous ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4ad2159627bb0908caad3b333ea29cbd16bf1140" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.setIndex() for String.</source>
          <target state="translated">String에 대해 CharacterIterator.setIndex ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d7d801a17ff9284b9b5a555fad45b98ca0144a28" translate="yes" xml:space="preserve">
          <source>Implements URIResolver.</source>
          <target state="translated">Implements URIResolver.</target>
        </trans-unit>
        <trans-unit id="318cd35cc48f383eeda6d6fd1b9667781c2143fe" translate="yes" xml:space="preserve">
          <source>Implements URIResolver. The method searches through the catalog entries in the main and alternative catalogs to attempt to find a match with the specified &lt;code&gt;href&lt;/code&gt; attribute. The &lt;code&gt;href&lt;/code&gt; attribute will be used literally, with no attempt to be made absolute to the &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Implements URIResolver. The method searches through the catalog entries in the main and alternative catalogs to attempt to find a match with the specified &lt;code&gt;href&lt;/code&gt; attribute. The &lt;code&gt;href&lt;/code&gt; attribute will be used literally, with no attempt to be made absolute to the &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31c4b09be804aaf138edc0afa59e53f472c6e688" translate="yes" xml:space="preserve">
          <source>Implements View interface for a simple multi-line text view that has text in one font and color.</source>
          <target state="translated">Implements View interface for a simple multi-line text view that has text in one font and color.</target>
        </trans-unit>
        <trans-unit id="fb2809aa78c909534686dfa4a5a387ba869c24e6" translate="yes" xml:space="preserve">
          <source>Implements View interface for a simple multi-line text view that has text in one font and color. The view represents each child element as a line of text.</source>
          <target state="translated">Implements View interface for a simple multi-line text view that has text in one font and color. The view represents each child element as a line of text.</target>
        </trans-unit>
        <trans-unit id="bb36a4fb29616c43d77d4ae60696878082fa8f31" translate="yes" xml:space="preserve">
          <source>Implements View interface for a table, that is composed of an element structure where the child elements of the element this view is responsible for represent rows and the child elements of the row elements are cells.</source>
          <target state="translated">Implements View interface for a table, that is composed of an element structure where the child elements of the element this view is responsible for represent rows and the child elements of the row elements are cells.</target>
        </trans-unit>
        <trans-unit id="16821c6318c86c959d397b02a216025ffa6f1bdf" translate="yes" xml:space="preserve">
          <source>Implements View interface for a table, that is composed of an element structure where the child elements of the element this view is responsible for represent rows and the child elements of the row elements are cells. The cell elements can have an arbitrary element structure under them, which will be built with the ViewFactory returned by the getViewFactory method.</source>
          <target state="translated">Implements View interface for a table, that is composed of an element structure where the child elements of the element this view is responsible for represent rows and the child elements of the row elements are cells. The cell elements can have an arbitrary element structure under them, which will be built with the ViewFactory returned by the getViewFactory method.</target>
        </trans-unit>
        <trans-unit id="93d7b85b84f5df6147819e746f11ca13dcd596e9" translate="yes" xml:space="preserve">
          <source>Implements W3C XML Schema Part 2, Section 3.2.7.3 (A).</source>
          <target state="translated">Implements W3C XML Schema Part 2, Section 3.2.7.3 (A).</target>
        </trans-unit>
        <trans-unit id="4ed37c520c0b09ffc1b4b1e2621ae8fa8595db68" translate="yes" xml:space="preserve">
          <source>Implements a View suitable for use in JPasswordField UI implementations.</source>
          <target state="translated">Implements a View suitable for use in JPasswordField UI implementations.</target>
        </trans-unit>
        <trans-unit id="067b74bffa3943fb1bb2edc38d7679a72dfb5897" translate="yes" xml:space="preserve">
          <source>Implements a View suitable for use in JPasswordField UI implementations. This is basically a field ui that renders its contents as the echo character specified in the associated component (if it can narrow the component to a JPasswordField).</source>
          <target state="translated">Implements a View suitable for use in JPasswordField UI implementations. This is basically a field ui that renders its contents as the echo character specified in the associated component (if it can narrow the component to a JPasswordField).</target>
        </trans-unit>
        <trans-unit id="122506fa9d8f19a72b209a6463f3c3f6806b913f" translate="yes" xml:space="preserve">
          <source>Implements a composite element that contains other elements.</source>
          <target state="translated">Implements a composite element that contains other elements.</target>
        </trans-unit>
        <trans-unit id="eb77268cf31c9d1b7065ac4f346f0f4f62633aa5" translate="yes" xml:space="preserve">
          <source>Implements a non-terminal append-and-replace step.</source>
          <target state="translated">비 터미널 추가 및 교체 단계를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8fc7388752bff5a1959372aa839600a88a0d6560" translate="yes" xml:space="preserve">
          <source>Implements a terminal append-and-replace step.</source>
          <target state="translated">터미널 추가 및 교체 단계를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a4195097f3d067f532df1fff9627a92a21d4eb32" translate="yes" xml:space="preserve">
          <source>Implements absolute timed condition wait.</source>
          <target state="translated">절대 시간 조건 대기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="65420a72d88c9de714dd31d95f63cbe8c1653bea" translate="yes" xml:space="preserve">
          <source>Implements an element that directly represents content of some kind.</source>
          <target state="translated">Implements an element that directly represents content of some kind.</target>
        </trans-unit>
        <trans-unit id="37c1e8dcf99a0f703b26aac24a1a89f9d4541abd" translate="yes" xml:space="preserve">
          <source>Implements an input stream filter for compressing data in the &quot;deflate&quot; compression format.</source>
          <target state="translated">&quot;deflate&quot;압축 형식으로 데이터를 압축하기위한 입력 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fb39bbcec1c774b4fba93fc21190a47bc5971af5" translate="yes" xml:space="preserve">
          <source>Implements an output stream filter for uncompressing data stored in the &quot;deflate&quot; compression format.</source>
          <target state="translated">&quot;deflate&quot;압축 형식으로 저장된 압축 해제 데이터에 대한 출력 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9c43b35ae2a5e1c03476a63c25a2b6caa54dc356" translate="yes" xml:space="preserve">
          <source>Implements execution conventions for CountedCompleters.</source>
          <target state="translated">CountedCompleters에 대한 실행 규칙을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="551f1837817dc3b5cc8875eeb3c93a0ab8888206" translate="yes" xml:space="preserve">
          <source>Implements execution conventions for RecursiveActions.</source>
          <target state="translated">RecursiveActions에 대한 실행 규칙을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f0fdfaa1349a464aa045ad325a724296034d0863" translate="yes" xml:space="preserve">
          <source>Implements execution conventions for RecursiveTask.</source>
          <target state="translated">RecursiveTask에 대한 실행 규칙을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4cf0ccace084c50198d2ff61513b820d4b7ab184" translate="yes" xml:space="preserve">
          <source>Implements interruptible condition wait.</source>
          <target state="translated">인터럽트 가능한 조건 대기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5ef5d897a19fb982809f56979cd95dfafbb96664" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;TableCellEditor&lt;/code&gt; interface.</source>
          <target state="translated">Implements the &lt;code&gt;TableCellEditor&lt;/code&gt; interface.</target>
        </trans-unit>
        <trans-unit id="1614df85be305c9188349340b94e25e4e4c33b0d" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;TreeCellEditor&lt;/code&gt; interface.</source>
          <target state="translated">Implements the &lt;code&gt;TreeCellEditor&lt;/code&gt; interface.</target>
        </trans-unit>
        <trans-unit id="5a884e5830e3412fc3cf287954f6b32ab405511f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;absolutePath&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#absolutePath()&quot;&gt;&lt;code&gt;Preferences.absolutePath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;absolutePath&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#absolutePath()&quot;&gt; &lt;code&gt;Preferences.absolutePath()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2303304616ae77f7756f510ceeff5058198c36af" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;absolutePath&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#absolutePath--&quot;&gt;&lt;code&gt;Preferences.absolutePath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#absolutePath--&quot;&gt; &lt;code&gt;Preferences.absolutePath()&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;absolutePath&lt;/code&gt; 메서드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="497711fb7d3b95561f2fd887f3f3cff39b4d70b2" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;children&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#childrenNames()&quot;&gt;&lt;code&gt;Preferences.childrenNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;children&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#childrenNames()&quot;&gt; &lt;code&gt;Preferences.childrenNames()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="034f9deafba508d9af3bcf5b68973bd9dea1bd76" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;children&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#childrenNames--&quot;&gt;&lt;code&gt;Preferences.childrenNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#childrenNames--&quot;&gt; &lt;code&gt;Preferences.childrenNames()&lt;/code&gt; &lt;/a&gt; 의 스펙에 따라 , &lt;code&gt;children&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="059e0498a51dfd4925cfb2b3102695e450c99c62" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;clear&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#clear()&quot;&gt;&lt;code&gt;Preferences.clear()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;clear&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#clear()&quot;&gt; &lt;code&gt;Preferences.clear()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="46cb2a81f204b4143be54da7ee4ce2b43a9f0e15" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;clear&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#clear--&quot;&gt;&lt;code&gt;Preferences.clear()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#clear--&quot;&gt; &lt;code&gt;Preferences.clear()&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;clear&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="27384530e833319c1741f425fdd02affb746be4a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportNode(java.io.OutputStream)&quot;&gt;&lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;exportNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportNode(java.io.OutputStream)&quot;&gt; &lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c5271f0b8def61c25744f1dd1f9a7a0866178042" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportNode-java.io.OutputStream-&quot;&gt;&lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#exportNode-java.io.OutputStream-&quot;&gt; &lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;exportNode&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="98aad1f6a054ecea9742f417fa73cff7c9b09ac3" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportSubtree&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportSubtree(java.io.OutputStream)&quot;&gt;&lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;exportSubtree&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportSubtree(java.io.OutputStream)&quot;&gt; &lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6992328892719c452810c6ca8560c959a91e93f4" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportSubtree&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportSubtree-java.io.OutputStream-&quot;&gt;&lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#exportSubtree-java.io.OutputStream-&quot;&gt; &lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;exportSubtree&lt;/code&gt; 메서드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="f75a22f3a2ce6719749fb126229e20961cecf828" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;flush&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#flush()&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;flush&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#flush()&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0bcf92c331b449f42058427c1857f88ad0cc933d" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;flush&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#flush--&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#flush--&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;flush&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="78015e2cb6a6572466b2f3107eadbeb75649f6f0" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;get&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#get(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;Preferences.get(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;get&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#get(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;Preferences.get(String,String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fd60f453d49bb8d7d210813e6ce68cc6bfb94562" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;get&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#get-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.get(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#get-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.get(String,String)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;get&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ea353e66c1ac86790405e5ed097438b417b79346" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getBoolean(java.lang.String,boolean)&quot;&gt;&lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;getBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getBoolean(java.lang.String,boolean)&quot;&gt; &lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bb5155ae4fbbe6ae18c3ab26004b7eece250eb0f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getBoolean-java.lang.String-boolean-&quot;&gt;&lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#getBoolean-java.lang.String-boolean-&quot;&gt; &lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;getBoolean&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="0b7fc840c8fcf629db0b7313f488ea98f77836eb" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getByteArray(java.lang.String,byte%5B%5D)&quot;&gt;&lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;getByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getByteArray(java.lang.String,byte%5B%5D)&quot;&gt; &lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f0b4007d76b02ecf996288a0c19ed712d960828e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getByteArray-java.lang.String-byte:A-&quot;&gt;&lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#getByteArray-java.lang.String-byte:A-&quot;&gt; &lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt; 의 스펙에 따라 &lt;code&gt;getByteArray&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a44773ab8dcb04f9357998eb6b4f39e88e41394d" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getDouble(java.lang.String,double)&quot;&gt;&lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;getDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getDouble(java.lang.String,double)&quot;&gt; &lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e9e450fbaa690dcceaab8d53b8c3cbedb82f9d78" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getDouble-java.lang.String-double-&quot;&gt;&lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#getDouble-java.lang.String-double-&quot;&gt; &lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;getDouble&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4b1e5f933602798366ed31ec748973cb8f3739c0" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getFloat(java.lang.String,float)&quot;&gt;&lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;getFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getFloat(java.lang.String,float)&quot;&gt; &lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="84b21b049297b5e1b111acffab81a95f30370f84" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getFloat-java.lang.String-float-&quot;&gt;&lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#getFloat-java.lang.String-float-&quot;&gt; &lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;getFloat&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b5f74f30c5422d8d952c57c972e6d8fc8639e2dc" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;getInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c274f814517f4670c893c66cb2bfa98eeab7e4bd" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#getInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;getInt&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="f9716d025f1b0da02dcfcfcafecd8a4dc2e3ab9f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getLong(java.lang.String,long)&quot;&gt;&lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;getLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getLong(java.lang.String,long)&quot;&gt; &lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1da387d0a91dd5384161de4e156bcc24ea6fbf17" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getLong-java.lang.String-long-&quot;&gt;&lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#getLong-java.lang.String-long-&quot;&gt; &lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;getLong&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4eaa95ecc8b1c6d190deea16df5803f9a33f646f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;isUserNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#isUserNode()&quot;&gt;&lt;code&gt;Preferences.isUserNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;isUserNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#isUserNode()&quot;&gt; &lt;code&gt;Preferences.isUserNode()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ea4fec525521819b707dbeac6d4f7ff72f03a4c2" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;isUserNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#isUserNode--&quot;&gt;&lt;code&gt;Preferences.isUserNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#isUserNode--&quot;&gt; &lt;code&gt;Preferences.isUserNode()&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;isUserNode&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e5056bd26346ca8c414eb53534dd9265bec86009" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;keys&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#keys()&quot;&gt;&lt;code&gt;Preferences.keys()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;keys&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#keys()&quot;&gt; &lt;code&gt;Preferences.keys()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dd3d33b98e343258fdc365b452fe2c54c3a57a8c" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;keys&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#keys--&quot;&gt;&lt;code&gt;Preferences.keys()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#keys--&quot;&gt; &lt;code&gt;Preferences.keys()&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;keys&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="f5c94dffc44ba9a6355d9a0ae6ff61d2d2dd03f3" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;name&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#name()&quot;&gt;&lt;code&gt;Preferences.name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;name&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#name()&quot;&gt; &lt;code&gt;Preferences.name()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b8b350943fb40b138fd56f36c6dbef682a6322e1" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;name&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#name--&quot;&gt;&lt;code&gt;Preferences.name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#name--&quot;&gt; &lt;code&gt;Preferences.name()&lt;/code&gt; &lt;/a&gt; 의 스펙에 따라 &lt;code&gt;name&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e852153c5eb8ea699e3354d9551a6e43544dcd03" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;node&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#node(java.lang.String)&quot;&gt;&lt;code&gt;Preferences.node(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;node&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#node(java.lang.String)&quot;&gt; &lt;code&gt;Preferences.node(String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0649c8cc433a5e7005ae22f20906c8b707b86e84" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;node&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#node-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.node(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#node-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.node(String)&lt;/code&gt; &lt;/a&gt; 의 스펙에 따라 &lt;code&gt;node&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="721cd1cca821bc0d961d9aefe3bb96e48fb959bf" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;nodeExists&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#nodeExists(java.lang.String)&quot;&gt;&lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;nodeExists&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#nodeExists(java.lang.String)&quot;&gt; &lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e4aa7ebab34301da1cde7559e5697decfe5af827" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;nodeExists&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#nodeExists-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#nodeExists-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt; &lt;/a&gt; 의 스펙에 &lt;code&gt;nodeExists&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7e8f9fb1d98b5f9d794284d8ed809f6806b7c844" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;parent&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#parent()&quot;&gt;&lt;code&gt;Preferences.parent()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;parent&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#parent()&quot;&gt; &lt;code&gt;Preferences.parent()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f4fe173b9d0a89ea7f1b5eba6be1698ca690f55e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;parent&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#parent--&quot;&gt;&lt;code&gt;Preferences.parent()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#parent--&quot;&gt; &lt;code&gt;Preferences.parent()&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;parent&lt;/code&gt; 메서드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="9d809f3091f242364c316d9f4236b053d68715fb" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;put&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#put(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;Preferences.put(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;put&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#put(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;Preferences.put(String,String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="56c5e61149b3eee9a14a2381738dfc70bccfc389" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;put&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#put-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.put(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#put-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.put(String,String)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;put&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="8f056c5d095a472be619608c64cedd250d13f1d7" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putBoolean(java.lang.String,boolean)&quot;&gt;&lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;putBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putBoolean(java.lang.String,boolean)&quot;&gt; &lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c964cfd9449cfba5f084d6eb883e09669a4711ef" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putBoolean-java.lang.String-boolean-&quot;&gt;&lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#putBoolean-java.lang.String-boolean-&quot;&gt; &lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;putBoolean&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="af75d3c130947f6453fb67efe7a6515eaa2f9eb7" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putByteArray(java.lang.String,byte%5B%5D)&quot;&gt;&lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;putByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putByteArray(java.lang.String,byte%5B%5D)&quot;&gt; &lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6dfb192ca6481e94bbe487fe93ad8e390c6a8ddf" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putByteArray-java.lang.String-byte:A-&quot;&gt;&lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#putByteArray-java.lang.String-byte:A-&quot;&gt; &lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;putByteArray&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="86f038d3dbcc6bf189a5c7d2b8d83b4055d9607e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putDouble(java.lang.String,double)&quot;&gt;&lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;putDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putDouble(java.lang.String,double)&quot;&gt; &lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="700b1f1d7618f6e22ebcf34385a559a63ca591ae" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putDouble-java.lang.String-double-&quot;&gt;&lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#putDouble-java.lang.String-double-&quot;&gt; &lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;putDouble&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d8603d94d3fb23a4921e68448f26bf91b23e2187" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putFloat(java.lang.String,float)&quot;&gt;&lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;putFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putFloat(java.lang.String,float)&quot;&gt; &lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="80192947101c876eaade219b960719ce5fba52be" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putFloat-java.lang.String-float-&quot;&gt;&lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#putFloat-java.lang.String-float-&quot;&gt; &lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;putFloat&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c2a61e9f0bf4527abc6bd4ad38427bfcb330d4db" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;putInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4a885f79dd7082ca994a78ab5b9536740b01678f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#putInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;putInt&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="dfa859440e2acc402f4baa4bb6bfe19c14468b22" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putLong(java.lang.String,long)&quot;&gt;&lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;putLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putLong(java.lang.String,long)&quot;&gt; &lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="95eb710c08c834586c53fc11e79b1b0c9ead4298" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putLong-java.lang.String-long-&quot;&gt;&lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#putLong-java.lang.String-long-&quot;&gt; &lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;putLong&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1145d33fa13a92fc862f33552963cbefaf56a0dd" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;remove(String)&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#remove(java.lang.String)&quot;&gt;&lt;code&gt;Preferences.remove(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;remove(String)&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#remove(java.lang.String)&quot;&gt; &lt;code&gt;Preferences.remove(String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b0b2653970946b64ed4ddaa3ebfdafe0eb71373a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;remove(String)&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#remove-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.remove(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#remove-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.remove(String)&lt;/code&gt; &lt;/a&gt; 의 스펙에 따라 &lt;code&gt;remove(String)&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="f73d465ace07becf08f1ef90ce5d0fc36fd68877" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;removeNode()&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#removeNode()&quot;&gt;&lt;code&gt;Preferences.removeNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;removeNode()&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#removeNode()&quot;&gt; &lt;code&gt;Preferences.removeNode()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a9fc2ab6783e8c0ed4c3c6887838e051d6ead650" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;removeNode()&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#removeNode--&quot;&gt;&lt;code&gt;Preferences.removeNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#removeNode--&quot;&gt; &lt;code&gt;Preferences.removeNode()&lt;/code&gt; &lt;/a&gt; 의 스펙에 따라 &lt;code&gt;removeNode()&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4e514973362c210c6c0a45eabf33779bc4abe69e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;sync&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#sync()&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implements the &lt;code&gt;sync&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#sync()&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0f50cf978662ba1a1c66109922a9ef7df030c0f8" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;sync&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#sync--&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preferences#sync--&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; &lt;/a&gt; 의 사양에 따라 &lt;code&gt;sync&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="8070a9651a28f504d3ee606de0cb54a78c1a449a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OutputStream&lt;/code&gt; 의 &lt;code&gt;write&lt;/code&gt; 메소드를 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="eba7a76fb44749a7dc70c0178e32f86bfaaab0bb" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;Writer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Writer&lt;/code&gt; 의 &lt;code&gt;write&lt;/code&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7345100c6205aaddd53c33150182817376407dd0" translate="yes" xml:space="preserve">
          <source>Implements the Highlighter interfaces.</source>
          <target state="translated">Implements the Highlighter interfaces.</target>
        </trans-unit>
        <trans-unit id="713527e650aa1d514fc11e2fb72846d8adfaba95" translate="yes" xml:space="preserve">
          <source>Implements the Highlighter interfaces. Implements a simple highlight painter that renders in a solid color.</source>
          <target state="translated">Implements the Highlighter interfaces. Implements a simple highlight painter that renders in a solid color.</target>
        </trans-unit>
        <trans-unit id="1df7d1f3a6612a7a78698f998e2369cabdbb3654" translate="yes" xml:space="preserve">
          <source>Implements the abstract &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OutputStream&lt;/code&gt; 의 추상 &lt;code&gt;write&lt;/code&gt; 메소드를 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="e84e5d2d6f3ad30c13bbffe6f10586dcbe14843b" translate="yes" xml:space="preserve">
          <source>Implements the abstract part of an element.</source>
          <target state="translated">Implements the abstract part of an element.</target>
        </trans-unit>
        <trans-unit id="55af899b56f29b0b6a4178b4545eb0b45c43ff18" translate="yes" xml:space="preserve">
          <source>Implements the abstract part of an element. By default elements support attributes by having a field that represents the immutable part of the current attribute set for the element. The element itself implements MutableAttributeSet which can be used to modify the set by fetching a new immutable set. The immutable sets are provided by the AttributeContext associated with the document.</source>
          <target state="translated">Implements the abstract part of an element. By default elements support attributes by having a field that represents the immutable part of the current attribute set for the element. The element itself implements MutableAttributeSet which can be used to modify the set by fetching a new immutable set. The immutable sets are provided by the AttributeContext associated with the document.</target>
        </trans-unit>
        <trans-unit id="ab32001571b15dd2de30bb6329e0837209226884" translate="yes" xml:space="preserve">
          <source>Implements the guard interface for a permission.</source>
          <target state="translated">Implements the guard interface for a permission.</target>
        </trans-unit>
        <trans-unit id="85dcc3ce4240cbda68572ddbcac72a94ce15863a" translate="yes" xml:space="preserve">
          <source>Implements the guard interface for a permission. The &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; method is called, passing this permission object as the permission to check. Returns silently if access is granted. Otherwise, throws a SecurityException.</source>
          <target state="translated">권한에 대한 보호 인터페이스를 구현합니다. &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; 방법을 확인 할 수있는 권한으로이 권한 객체를 전달이라고합니다. 액세스 권한이 부여되면 자동으로 리턴합니다. 그렇지 않으면 SecurityException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c8baefff3346231902a3ebabd8df14c787b0f9b" translate="yes" xml:space="preserve">
          <source>Implements timed condition wait.</source>
          <target state="translated">시간 초과 조건 대기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="97bc4b1502ef7ea7fd18271c7831c9405cc5ea04" translate="yes" xml:space="preserve">
          <source>Implements uninterruptible condition wait.</source>
          <target state="translated">무정전 상태 대기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="dd92548143f247a24fedf6b61a62fa9529e2d435" translate="yes" xml:space="preserve">
          <source>Implicitly images are defined to provide color samples at integer coordinate locations. When images are rendered upright with no scaling onto a destination, the choice of which image pixels map to which device pixels is obvious and the samples at the integer coordinate locations in the image are transferred to the pixels at the corresponding integer locations on the device pixel grid one for one. When images are rendered in a scaled, rotated, or otherwise transformed coordinate system, then the mapping of device pixel coordinates back to the image can raise the question of what color sample to use for the continuous coordinates that lie between the integer locations of the provided image samples. Interpolation algorithms define functions which provide a color sample for any continuous coordinate in an image based on the color samples at the surrounding integer coordinates.</source>
          <target state="translated">Implicitly images are defined to provide color samples at integer coordinate locations. When images are rendered upright with no scaling onto a destination, the choice of which image pixels map to which device pixels is obvious and the samples at the integer coordinate locations in the image are transferred to the pixels at the corresponding integer locations on the device pixel grid one for one. When images are rendered in a scaled, rotated, or otherwise transformed coordinate system, then the mapping of device pixel coordinates back to the image can raise the question of what color sample to use for the continuous coordinates that lie between the integer locations of the provided image samples. Interpolation algorithms define functions which provide a color sample for any continuous coordinate in an image based on the color samples at the surrounding integer coordinates.</target>
        </trans-unit>
        <trans-unit id="b87df961a9a5842e2e0bd58fed3cd0c357e92df5" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node.</source>
          <target state="translated">Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node.</target>
        </trans-unit>
        <trans-unit id="e917c5488e98c0c27be507a69f948d4511aef81e" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node. The returned node has no parent; (&lt;code&gt;parentNode&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node. The returned node has no parent; ( &lt;code&gt;parentNode&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c6ca8c58332c18473e39f6c0dc8388cdd462423" translate="yes" xml:space="preserve">
          <source>Imports a style sheet from &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">Imports a style sheet from &lt;code&gt;url&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4ad0c0cd3e499422f46a1d9968702d23884ac58" translate="yes" xml:space="preserve">
          <source>Imports a style sheet from &lt;code&gt;url&lt;/code&gt;. The resulting rules are directly added to the receiver. If you do not want the rules to become part of the receiver, create a new StyleSheet and use addStyleSheet to link it in.</source>
          <target state="translated">Imports a style sheet from &lt;code&gt;url&lt;/code&gt; . The resulting rules are directly added to the receiver. If you do not want the rules to become part of the receiver, create a new StyleSheet and use addStyleSheet to link it in.</target>
        </trans-unit>
        <trans-unit id="d8049e75e7deb9a5b855f06e7154ee44499587ef" translate="yes" xml:space="preserve">
          <source>Imports all of the preferences represented by the XML document on the specified input stream.</source>
          <target state="translated">Imports all of the preferences represented by the XML document on the specified input stream.</target>
        </trans-unit>
        <trans-unit id="c71923291c8740cc76f9206ce1cdd5cb8964838b" translate="yes" xml:space="preserve">
          <source>Imports all of the preferences represented by the XML document on the specified input stream. The document may represent user preferences or system preferences. If it represents user preferences, the preferences will be imported into the calling user's preference tree (even if they originally came from a different user's preference tree). If any of the preferences described by the document inhabit preference nodes that do not exist, the nodes will be created.</source>
          <target state="translated">지정된 입력 스트림에서 XML 문서로 표시되는 모든 환경 설정을 가져옵니다. 문서는 사용자 선호도 또는 시스템 선호도를 나타낼 수있다. 사용자 기본 설정을 나타내는 경우 기본 설정은 발신 사용자의 기본 설정 트리로 가져옵니다 (원래 다른 사용자의 기본 설정 트리에서 온 경우에도). 문서에 설명 된 환경 설정 중 존재하지 않는 환경 설정 노드가있는 경우 해당 노드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7a226069a9c2b9c733fa93be074ddc8ebc8389b5" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding format.</source>
          <target state="translated">Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding format.</target>
        </trans-unit>
        <trans-unit id="c3b5a559d458b855feabfd942350c4d64812e691" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding format. If &lt;code&gt;format&lt;/code&gt; is null, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for these parameters exists.</source>
          <target state="translated">매개 변수에서 &lt;code&gt;params&lt;/code&gt; 변수를 가져 와서 지정된 디코딩 형식에 따라 디코딩합니다. 경우 &lt;code&gt;format&lt;/code&gt; 널, 파라미터의 일차 디코딩 포맷이 사용된다. 이러한 매개 변수에 대한 ASN.1 사양이 존재하는 경우 기본 디코딩 형식은 ASN.1입니다.</target>
        </trans-unit>
        <trans-unit id="b9528a5169d705e997248664b82ddd257d316162" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding scheme.</source>
          <target state="translated">Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding scheme.</target>
        </trans-unit>
        <trans-unit id="8daf910475ce86194cd83279397f2ce3ae7b465e" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding scheme. If &lt;code&gt;format&lt;/code&gt; is null, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for these parameters exists.</source>
          <target state="translated">매개 변수에서 &lt;code&gt;params&lt;/code&gt; 변수를 가져와 지정된 디코딩 체계에 따라 디코딩합니다. 경우 &lt;code&gt;format&lt;/code&gt; 널, 파라미터의 일차 디코딩 포맷이 사용된다. 이러한 매개 변수에 대한 ASN.1 사양이 존재하는 경우 기본 디코딩 형식은 ASN.1입니다.</target>
        </trans-unit>
        <trans-unit id="22b4275a83eb032a3c18ec6f1903022b54365237" translate="yes" xml:space="preserve">
          <source>Imports the specified parameters and decodes them according to the primary decoding format for parameters.</source>
          <target state="translated">Imports the specified parameters and decodes them according to the primary decoding format for parameters.</target>
        </trans-unit>
        <trans-unit id="9e1a8d9caf50a44dc7557cdf109bddec4a771f9e" translate="yes" xml:space="preserve">
          <source>Imports the specified parameters and decodes them according to the primary decoding format for parameters. The primary decoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.</source>
          <target state="translated">지정된 파라미터를 가져 와서 파라미터의 기본 디코딩 형식에 따라 디코딩합니다. 이 유형의 매개 변수에 대한 ASN.1 스펙이 존재하는 경우 매개 변수의 기본 디코딩 형식은 ASN.1입니다.</target>
        </trans-unit>
        <trans-unit id="5db680fa20839f2707dc803343b2a35951c109b1" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge.</source>
          <target state="translated">Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge.</target>
        </trans-unit>
        <trans-unit id="4d2c0bf8d32601bc858999c087909fdfb54b33dc" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge. This imposition is also known as &quot;duplex&quot; (see &lt;a href=&quot;#DUPLEX&quot;&gt;&lt;code&gt;DUPLEX&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge. This imposition is also known as &quot;duplex&quot; (see &lt;a href=&quot;#DUPLEX&quot;&gt; &lt;code&gt;DUPLEX&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ebb09cb4d38a6b66afe6af78e3d1ad2ebf60b9fe" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge. This imposition is also known as &quot;duplex&quot; (see &lt;a href=&quot;sides#DUPLEX&quot;&gt;&lt;code&gt;DUPLEX&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">매체의 각 인쇄 스트림 페이지 쌍의 방향이 긴 가장자리에 바인딩하는 것처럼 판독기에 적합하도록 연속 용지 시트의 앞면과 뒷면에 각 연속 인쇄 스트림 페이지 쌍을 부과합니다. 이 터 잡기는 &quot;듀플렉스&quot;라고도 &lt;a href=&quot;sides#DUPLEX&quot;&gt; &lt;code&gt;DUPLEX&lt;/code&gt; &lt;/a&gt; ( DUPLEX 참조 ).</target>
        </trans-unit>
        <trans-unit id="1f05e8edf660348d6f25a6c7698a3fed9d42d663" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge.</source>
          <target state="translated">Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge.</target>
        </trans-unit>
        <trans-unit id="1aef01edddd4b2d9c074f505881ac04fe92598e9" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge. This imposition is also known as &quot;tumble&quot; (see &lt;a href=&quot;#TUMBLE&quot;&gt;&lt;code&gt;TUMBLE&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge. This imposition is also known as &quot;tumble&quot; (see &lt;a href=&quot;#TUMBLE&quot;&gt; &lt;code&gt;TUMBLE&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="54db18fccd287c2e1b6e20e055a1cdacd0a5564b" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge. This imposition is also known as &quot;tumble&quot; (see &lt;a href=&quot;sides#TUMBLE&quot;&gt;&lt;code&gt;TUMBLE&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">매체의 각 인쇄 스트림 페이지 쌍의 방향이 짧은 가장자리에 바인딩하는 것처럼 판독기에 적합하도록 연속 미디어 시트의 앞면과 뒷면에 각 연속 인쇄 스트림 페이지 쌍을 부과합니다. 이 부과는 &quot;전락&quot;이라고도합니다 ( &lt;a href=&quot;sides#TUMBLE&quot;&gt; &lt;code&gt;TUMBLE&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d2be57fb742356053fcc2d4484541e57728aa6dd" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive print-stream page upon the same side of consecutive media sheets.</source>
          <target state="translated">연속 인쇄 매체 페이지를 연속 용지의 같은면에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="cecfaf1a15b7081e3c047943c8dccba7e77b2633" translate="yes" xml:space="preserve">
          <source>In 2008, time-zone offsets around the world extended from -12:00 to +14:00. To prevent any problems with that range being extended, yet still provide validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.</source>
          <target state="translated">2008 년 전 세계 시간대 오프셋은 -12 : 00에서 +14 : 00로 확장되었습니다. 해당 범위의 문제점을 확장하면서도 여전히 유효성 검증을 제공하기 위해 오프셋 범위는 -18 : 00-18:00로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="86389704bee7bc2f2d5910700581356c0e5689e9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, only the week-based-year is validated against the range of valid values. If the day-of-week is outside the range 1 to 7, then the resulting date is adjusted by a suitable number of weeks to reduce the day-of-week to the range 1 to 7. If the week-of-week-based-year value is outside the range 1 to 52, then any excess weeks are added or subtracted from the resulting date.</source>
          <target state="translated">&lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;무의식 모드&lt;/a&gt; 에서는 주 단위 연도 만 유효한 값 범위에 대해 유효성이 검사됩니다. 요일이 1-7 범위를 벗어나는 경우 결과 날짜는 적절한 요일로 조정되어 요일을 1-7 범위로 줄입니다. 기준 연도 값이 1-52 범위를 벗어난 경우 결과 날짜에서 초과 주가 더하거나 뺍니다.</target>
        </trans-unit>
        <trans-unit id="f9e4a79de23768eb149fc2303c479b95439f491c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, only the year is validated against the range of valid values. The resulting date is calculated equivalent to the following three stage approach. First, create a date on the first of January in the requested year. Then take the quarter-of-year, subtract one, and add the amount in quarters to the date. Finally, take the day-of-quarter, subtract one, and add the amount in days to the date.</source>
          <target state="translated">&lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;무의미한 모드&lt;/a&gt; 에서는 연도 만 유효한 값 범위에 대해 유효성이 검사됩니다. 결과 날짜는 다음 3 단계 접근법과 동일하게 계산됩니다. 먼저 요청 된 연도의 1 월 1 일에 날짜를 만드십시오. 그런 다음 연도를 취하고 1을 뺀 다음 날짜에 분기 단위로 금액을 더하십시오. 마지막으로, 분기를 빼고 1을 빼고 날짜에 날짜를 더하십시오.</target>
        </trans-unit>
        <trans-unit id="cd6ec172c1edc269b53c0583f46c3f095ab84cae" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, the year and day-of-week are validated against the range of valid values. The resulting date is calculated equivalent to the following four stage approach. First, create a date on the first day of the first week of January in the requested year. Then take the month-of-year, subtract one, and add the amount in months to the date. Then take the week-of-month, subtract one, and add the amount in weeks to the date. Finally, adjust to the correct day-of-week within the localized week.</source>
          <target state="translated">에 &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;관대 모드&lt;/a&gt; , 연도와 요일이 유효한 값의 범위에 대해 검증한다. 결과 날짜는 다음 4 단계 접근법과 동일하게 계산됩니다. 먼저 요청 된 연도의 1 월 첫째 주 첫째 날에 날짜를 작성하십시오. 그런 다음 한 달을 가져 와서 1을 빼고 날짜에 월 단위로 금액을 더하십시오. 그런 다음 한 달의 주를 빼고 1을 빼고 날짜에 주 단위로 금액을 더하십시오. 마지막으로 현지화 된 주 내에서 올바른 요일로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="4e3729f6e6efd6616dbdd65aa7497b7c86a2f948" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, the year and day-of-week are validated against the range of valid values. The resulting date is calculated equivalent to the following three stage approach. First, create a date on the first day of the first week in the requested week-based-year. Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date. Finally, adjust to the correct day-of-week within the localized week.</source>
          <target state="translated">에 &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;관대 모드&lt;/a&gt; , 연도와 요일이 유효한 값의 범위에 대해 검증한다. 결과 날짜는 다음 3 단계 접근법과 동일하게 계산됩니다. 먼저 요청한 주별 연도의 첫 주 첫 날에 날짜를 만듭니다. 그런 다음 주별 기준 연도를 빼고 1을 빼고 날짜에 주 단위로 금액을 추가하십시오. 마지막으로 현지화 된 주 내에서 올바른 요일로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="59cdf6f2f16e3f4bbc8085642ff9ed4c512d12dd" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, the year and day-of-week are validated against the range of valid values. The resulting date is calculated equivalent to the following three stage approach. First, create a date on the first day of the first week in the requested year. Then take the week-of-year, subtract one, and add the amount in weeks to the date. Finally, adjust to the correct day-of-week within the localized week.</source>
          <target state="translated">에 &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;관대 모드&lt;/a&gt; , 연도와 요일이 유효한 값의 범위에 대해 검증한다. 결과 날짜는 다음 3 단계 접근법과 동일하게 계산됩니다. 먼저 요청한 해의 첫 주 첫 날에 날짜를 만드십시오. 그런 다음 일주일을 빼고 1을 빼고 날짜에 주 단위로 금액을 더하십시오. 마지막으로 현지화 된 주 내에서 올바른 요일로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="0fb07a317c3eaba0aff1f9dde717867e0b71ef5e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all four fields are validated against their range of valid values. The week-of-month field is validated from 0 to 6, meaning that the resulting date can be in a different month to that specified.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; , 네 개의 필드는 유효한 값들의 범위에 대해 검증한다. 월별 필드의 유효성은 0에서 6까지이며 결과 날짜는 지정된 날짜와 다른 달에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e475c8cf450e0722c0f73724f68b49888b78026" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The day-of-quarter field is validated between 1 and 92, ignoring the actual range based on the year and quarter. If the day-of-quarter exceeds the actual range by one day, then the resulting date is one day later. If the day-of-quarter exceeds the actual range by two days, then the resulting date is two days later.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 분기 필드는 연도와 분기를 기준으로 한 실제 범위를 무시하고 1과 92 사이에서 검증됩니다. 분기가 실제 범위를 하루 초과하면 결과 날짜는 하루가 지납니다. 분기가 실제 범위를 2 일 초과하면 결과 날짜는 2 일 후입니다.</target>
        </trans-unit>
        <trans-unit id="48298e99d0fc04b4dade93a7fa8a98aa3f5d9136" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-week-based-year field is validated between 1 and 53, ignoring the week-based-year. If the week-of-week-based-year is 53, but the week-based-year only has 52 weeks, then the resulting date is in week 1 of the following week-based-year.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 주별 연도 필드는 주별 연도를 무시하고 1에서 53 사이의 유효성을 검사합니다. 주별 연도가 53이지만 주별 연도가 52 주인 경우 결과 날짜는 다음 주 기반 연도의 1 주차입니다.</target>
        </trans-unit>
        <trans-unit id="78349302167faa6d7a2aed1df47448ca5048b25d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-week-based-year field is validated from 1 to 53, meaning that the resulting date can be in the following week-based-year to that specified.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 주별 연도 필드는 1에서 53까지로 유효성이 검사되므로 결과 날짜는 다음 주별 연도에 지정된 날짜로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f232305a5c1e15ea107e37a90c2ece7913724549" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-year field is validated from 0 to 54, meaning that the resulting date can be in a different year to that specified.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 연도 필드는 0에서 54 사이로 유효성이 검사되므로 결과 날짜가 지정된 날짜와 다른 연도에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92aff29473ae74aa918cfecc94d38303412532e6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all four fields are validated against their range of valid values. The week-of-month field is validated to ensure that the resulting month is the month requested.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; , 네 개의 필드는 유효한 값들의 범위에 대해 검증한다. 매월 필드는 결과 월이 요청 된 월인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0f0e202932cebbe8a155bd934de772f0860489c8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The day-of-quarter field is validated from 1 to 90, 91 or 92 depending on the year and quarter.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 분기 필드는 연도 및 분기에 따라 1에서 90, 91 또는 92로 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="61038d4b8c7da66e5b7168e9d72153f9f95dd9b8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-week-based-year field is validated from 1 to 52 or 53 depending on the week-based-year.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 주별 연도 필드는 주별 연도에 따라 1에서 52 또는 53까지 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="6c209b717e4718fb111069dea4a3876d7d3d886e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-year field is validated to ensure that the resulting week-based-year is the week-based-year requested.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 주별 필드는 결과 주별 연도가 요청 된 주별 연도를 보장하도록 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="0e3442bcb8b50ab377f46533d2cb10831695feee" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-year field is validated to ensure that the resulting year is the year requested.</source>
          <target state="translated">에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; , 세 개의 필드는 유효한 값들의 범위에 대해 검증한다. 연도 필드는 결과 연도가 요청 된 연도인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="94d0612798926c7af8d39f4a4589255d75a064c6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;threadpoolexecutor.callerrunspolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.CallerRunsPolicy&lt;/code&gt;&lt;/a&gt;, the thread that invokes &lt;code&gt;execute&lt;/code&gt; itself runs the task. This provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted.</source>
          <target state="translated">에서 &lt;a href=&quot;threadpoolexecutor.callerrunspolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.CallerRunsPolicy&lt;/code&gt; &lt;/a&gt; 호출합니다 그 스레드 &lt;code&gt;execute&lt;/code&gt; 자체가 작업을 실행합니다. 이는 새로운 작업이 제출되는 속도를 늦추는 간단한 피드백 제어 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cb2aef34e8541d620db480296296a5005b0d8ebb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;threadpoolexecutor.discardoldestpolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.DiscardOldestPolicy&lt;/code&gt;&lt;/a&gt;, if the executor is not shut down, the task at the head of the work queue is dropped, and then execution is retried (which can fail again, causing this to be repeated.)</source>
          <target state="translated">에서 &lt;a href=&quot;threadpoolexecutor.discardoldestpolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.DiscardOldestPolicy&lt;/code&gt; &lt;/a&gt; 집행자가 종료되지 않은 경우, 작업 큐의 선두에있는 태스크가 삭제되어 실행이 시도됩니다 (이 반복되는 원인이 다시 실패 할 수있다.)</target>
        </trans-unit>
        <trans-unit id="c8f191d695cda03baf1111a2194130a680c23105" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;threadpoolexecutor.discardpolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.DiscardPolicy&lt;/code&gt;&lt;/a&gt;, a task that cannot be executed is simply dropped.</source>
          <target state="translated">에서 &lt;a href=&quot;threadpoolexecutor.discardpolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.DiscardPolicy&lt;/code&gt; &lt;/a&gt; , 실행할 수없는 작업은 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6a15117b6493b903456265f081034d8302acd07d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;HORIZONTAL_WRAP&lt;/code&gt; and &lt;code&gt;VERTICAL_WRAP&lt;/code&gt; orientations:</source>
          <target state="translated">In &lt;code&gt;HORIZONTAL_WRAP&lt;/code&gt; and &lt;code&gt;VERTICAL_WRAP&lt;/code&gt; orientations:</target>
        </trans-unit>
        <trans-unit id="657094c86ed548da67d27b0e04ccf6a2d6ee6e00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;PrintMode.NORMAL&lt;/code&gt; when a column is too wide to fit in the printable area -- print the center portion of the column and leave the left and right borders off the table.</source>
          <target state="translated">In &lt;code&gt;PrintMode.NORMAL&lt;/code&gt; when a column is too wide to fit in the printable area -- print the center portion of the column and leave the left and right borders off the table.</target>
        </trans-unit>
        <trans-unit id="77ab4acd6e3939d9de1d113380fbf9c5a2f82c8c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, if the removal would produce two disjoint selections, the removal is extended through the greater end of the selection. For example, if the selection is &lt;code&gt;0-10&lt;/code&gt; and you supply indices &lt;code&gt;5,6&lt;/code&gt; (in any order) the resulting selection is &lt;code&gt;0-4&lt;/code&gt;.</source>
          <target state="translated">In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, if the removal would produce two disjoint selections, the removal is extended through the greater end of the selection. For example, if the selection is &lt;code&gt;0-10&lt;/code&gt; and you supply indices &lt;code&gt;5,6&lt;/code&gt; (in any order) the resulting selection is &lt;code&gt;0-4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aece51993e01377983c7d1ade636af0247e43c89" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, only the second index is used.</source>
          <target state="translated">In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, only the second index is used.</target>
        </trans-unit>
        <trans-unit id="d06087fed3dfc62f5a68adee13608ed1d4cf33b1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, this is equivalent to calling &lt;code&gt;setSelectionInterval&lt;/code&gt;, and only the second index is used. In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, this method behaves like &lt;code&gt;setSelectionInterval&lt;/code&gt;, unless the given interval is immediately adjacent to or overlaps the existing selection, and can therefore be used to grow it.</source>
          <target state="translated">In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, this is equivalent to calling &lt;code&gt;setSelectionInterval&lt;/code&gt; , and only the second index is used. In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, this method behaves like &lt;code&gt;setSelectionInterval&lt;/code&gt; , unless the given interval is immediately adjacent to or overlaps the existing selection, and can therefore be used to grow it.</target>
        </trans-unit>
        <trans-unit id="df3c016e449ce26f1586e36d7017736782ea197d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, this is equivalent to calling &lt;code&gt;setSelectionInterval&lt;/code&gt;, and only the second index is used. In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, this method behaves like &lt;code&gt;setSelectionInterval&lt;/code&gt;, unless the given interval is immediately adjacent to or overlaps the existing selection, and can therefore be used to grow the selection.</source>
          <target state="translated">In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, this is equivalent to calling &lt;code&gt;setSelectionInterval&lt;/code&gt; , and only the second index is used. In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, this method behaves like &lt;code&gt;setSelectionInterval&lt;/code&gt; , unless the given interval is immediately adjacent to or overlaps the existing selection, and can therefore be used to grow the selection.</target>
        </trans-unit>
        <trans-unit id="a254052d2946ad1ebd808cc9b17d1d7fc3e2c385" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;VERTICAL&lt;/code&gt; orientation:</source>
          <target state="translated">In &lt;code&gt;VERTICAL&lt;/code&gt; orientation:</target>
        </trans-unit>
        <trans-unit id="0564ee6a70dbf13f614fae05c50df5afc450037f" translate="yes" xml:space="preserve">
          <source>In Beans 1.0 the given name can indicate either a serialized object or a class. Other mechanisms may be added in the future. In beans 1.0 we first try to treat the beanName as a serialized object name then as a class name.</source>
          <target state="translated">Beans 1.0에서 제공된 이름은 직렬화 된 객체 또는 클래스를 나타낼 수 있습니다. 향후 다른 메커니즘이 추가 될 수 있습니다. bean 1.0에서는 먼저 beanName을 직렬화 된 객체 이름으로 처리 한 다음 클래스 이름으로 처리하려고합니다.</target>
        </trans-unit>
        <trans-unit id="042c75bc8038a7bfe93454be2f4ccc7544315dc7" translate="yes" xml:space="preserve">
          <source>In InetAddress and Inet6Address, it is used for internal representation; it has no functional role. Java will never return an IPv4-mapped address. These classes can take an IPv4-mapped address as input, both in byte array and text representation. However, it will be converted into an IPv4 address.</source>
          <target state="translated">InetAddress 및 Inet6Address에서는 내부 표현에 사용됩니다. 기능적인 역할이 없습니다. Java는 IPv4 매핑 주소를 반환하지 않습니다. 이 클래스는 바이트 배열과 텍스트 표현 모두에서 IPv4로 매핑 된 주소를 입력으로 사용할 수 있습니다. 그러나 IPv4 주소로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="014f1fa7c567eb71497930106403f0d11979f4bc" translate="yes" xml:space="preserve">
          <source>In JNDI, all naming and directory operations are performed relative to a context. There are no absolute roots. Therefore JNDI defines an &lt;em&gt;initial context&lt;/em&gt;, &lt;code&gt;InitialContext&lt;/code&gt;, which provides a starting point for naming and directory operations. Once you have an initial context, you can use it to look up other contexts and objects.</source>
          <target state="translated">JNDI에서 모든 이름 지정 및 디렉토리 조작은 컨텍스트와 관련하여 수행됩니다. 절대 뿌리가 없습니다. 따라서 JNDI는 정의 &lt;em&gt;, 초기 문맥&lt;/em&gt; , &lt;code&gt;InitialContext&lt;/code&gt; 를 이름 지정 및 디렉토리 작업을위한 시작 지점을 제공합니다. 초기 컨텍스트가 있으면이를 사용하여 다른 컨텍스트와 개체를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79426411ad6360c359271abac5b6331b8b48b7e0" translate="yes" xml:space="preserve">
          <source>In Java Sound, &lt;code&gt;MidiEvent&lt;/code&gt; objects are typically contained in a &lt;a href=&quot;track&quot;&gt;&lt;code&gt;Track&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Tracks&lt;/code&gt; are likewise contained in a &lt;code&gt;Sequence&lt;/code&gt;.</source>
          <target state="translated">In Java Sound, &lt;code&gt;MidiEvent&lt;/code&gt; objects are typically contained in a &lt;a href=&quot;track&quot;&gt; &lt;code&gt;Track&lt;/code&gt; &lt;/a&gt;, and &lt;code&gt;Tracks&lt;/code&gt; are likewise contained in a &lt;code&gt;Sequence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13209128b680b3afe374b6116423184d3647e46c" translate="yes" xml:space="preserve">
          <source>In Java Sound, &lt;code&gt;MidiEvent&lt;/code&gt; objects are typically contained in a &lt;code&gt;&lt;a href=&quot;track&quot;&gt;&lt;code&gt;Track&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;Tracks&lt;/code&gt; are likewise contained in a &lt;code&gt;Sequence&lt;/code&gt;.</source>
          <target state="translated">자바 사운드에서 &lt;code&gt;MidiEvent&lt;/code&gt; 를의 객체는 일반적으로에 포함되어 &lt;code&gt;&lt;a href=&quot;track&quot;&gt;&lt;code&gt;Track&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Tracks&lt;/code&gt; 마찬가지로에 포함되어 &lt;code&gt;Sequence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5a504b5bd5d313a777bae81479bb507e440e57" translate="yes" xml:space="preserve">
          <source>In Java Sound, however, a &lt;code&gt;Synthesizer&lt;/code&gt; class can expose the contents of its voices through its &lt;a href=&quot;synthesizer#getVoiceStatus()&quot;&gt;&lt;code&gt;getVoiceStatus()&lt;/code&gt;&lt;/a&gt; method. This behavior is recommended but optional; synthesizers that don't expose their voice allocation simply return a zero-length array. A &lt;code&gt;Synthesizer&lt;/code&gt; that does report its voice status should maintain this information at all times for all of its voices, whether they are currently sounding or not. In other words, a given type of &lt;code&gt;Synthesizer&lt;/code&gt; always has a fixed number of voices, equal to the maximum number of simultaneous notes it is capable of sounding.</source>
          <target state="translated">In Java Sound, however, a &lt;code&gt;Synthesizer&lt;/code&gt; class can expose the contents of its voices through its &lt;a href=&quot;synthesizer#getVoiceStatus()&quot;&gt; &lt;code&gt;getVoiceStatus()&lt;/code&gt; &lt;/a&gt; method. This behavior is recommended but optional; synthesizers that don't expose their voice allocation simply return a zero-length array. A &lt;code&gt;Synthesizer&lt;/code&gt; that does report its voice status should maintain this information at all times for all of its voices, whether they are currently sounding or not. In other words, a given type of &lt;code&gt;Synthesizer&lt;/code&gt; always has a fixed number of voices, equal to the maximum number of simultaneous notes it is capable of sounding.</target>
        </trans-unit>
        <trans-unit id="98331511b3ce4c496aa8e2ac58efd2c1a6a50995" translate="yes" xml:space="preserve">
          <source>In Java Sound, however, a &lt;code&gt;Synthesizer&lt;/code&gt; class can expose the contents of its voices through its &lt;a href=&quot;synthesizer#getVoiceStatus--&quot;&gt;&lt;code&gt;getVoiceStatus()&lt;/code&gt;&lt;/a&gt; method. This behavior is recommended but optional; synthesizers that don't expose their voice allocation simply return a zero-length array. A &lt;code&gt;Synthesizer&lt;/code&gt; that does report its voice status should maintain this information at all times for all of its voices, whether they are currently sounding or not. In other words, a given type of &lt;code&gt;Synthesizer&lt;/code&gt; always has a fixed number of voices, equal to the maximum number of simultaneous notes it is capable of sounding.</source>
          <target state="translated">그러나 Java Sound에서 &lt;code&gt;Synthesizer&lt;/code&gt; 클래스는 &lt;a href=&quot;synthesizer#getVoiceStatus--&quot;&gt; &lt;code&gt;getVoiceStatus()&lt;/code&gt; &lt;/a&gt; 메소드를 통해 음성 컨텐츠를 노출 할 수 있습니다 . 이 동작은 권장되지만 선택 사항입니다. 음성 할당을 공개하지 않는 신시사이저는 단순히 길이가 0 인 배열을 반환합니다. 음성 상태를보고 하는 &lt;code&gt;Synthesizer&lt;/code&gt; 는 현재 소리 여부에 관계없이 모든 음성에 대해이 정보를 항상 유지해야합니다. 다시 말해, 주어진 형식의 &lt;code&gt;Synthesizer&lt;/code&gt; 항상 소리를 낼 수있는 최대 동시 음 수와 같은 고정 된 수의 음색을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7717ad4c43dc4f90b8dc37532fbf48149788e4e0" translate="yes" xml:space="preserve">
          <source>In June of 1996, the basic X.509 v3 format was completed by ISO/IEC and ANSI X9, which is described below in ASN.1:</source>
          <target state="translated">1996 년 6 월, 기본 X.509 v3 형식은 ISO / IEC 및 ANSI X9에 의해 완성되었으며 아래 ASN.1에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd04fce7fa942ea18d8a8670f1b727e68adbc514" translate="yes" xml:space="preserve">
          <source>In Open MBeans, attributes and parameters can have default values and/or constraints associated with them in the &lt;code&gt;
      OpenMBeanAttributeInfo&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt;. There are two ways to specify these constraints. Either the values are directly specified as parameters to one of the constructors of &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt;, for example &lt;a href=&quot;openmbeanparameterinfosupport#%3Cinit%3E(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,T,T%5B%5D)&quot;&gt;&lt;code&gt;OpenMBeanParameterInfoSupport(
      String, String, OpenType, Object, Object[])&lt;/code&gt;&lt;/a&gt;; or the values are specified in a &lt;a href=&quot;../descriptor&quot;&gt;&lt;code&gt;Descriptor&lt;/code&gt;&lt;/a&gt; given as a parameter to one of the constructors.</source>
          <target state="translated">In Open MBeans, attributes and parameters can have default values and/or constraints associated with them in the &lt;code&gt; OpenMBeanAttributeInfo&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt; . There are two ways to specify these constraints. Either the values are directly specified as parameters to one of the constructors of &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; , for example &lt;a href=&quot;openmbeanparameterinfosupport#%3Cinit%3E(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,T,T%5B%5D)&quot;&gt; &lt;code&gt;OpenMBeanParameterInfoSupport( String, String, OpenType, Object, Object[])&lt;/code&gt; &lt;/a&gt;; or the values are specified in a &lt;a href=&quot;../descriptor&quot;&gt; &lt;code&gt;Descriptor&lt;/code&gt; &lt;/a&gt; given as a parameter to one of the constructors.</target>
        </trans-unit>
        <trans-unit id="0cd5532b3248e413385cbfc9fc717eba269294fb" translate="yes" xml:space="preserve">
          <source>In Open MBeans, attributes and parameters can have default values and/or constraints associated with them in the &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt;. There are two ways to specify these constraints. Either the values are directly specified as parameters to one of the constructors of &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt;, for example &lt;a href=&quot;openmbeanparameterinfosupport#OpenMBeanParameterInfoSupport-java.lang.String-java.lang.String-javax.management.openmbean.OpenType-T-T:A-&quot;&gt;&lt;code&gt;OpenMBeanParameterInfoSupport.OpenMBeanParameterInfoSupport(
      String, String, OpenType, Object, Object[])&lt;/code&gt;&lt;/a&gt;; or the values are specified in a &lt;a href=&quot;../descriptor&quot;&gt;&lt;code&gt;Descriptor&lt;/code&gt;&lt;/a&gt; given as a parameter to one of the constructors.</source>
          <target state="translated">Open MBean에서 속성 및 매개 변수는 &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 또는 &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt; 에서 기본값 및 / 또는 제한 조건을 가질 수 있습니다 . 이러한 제약 조건을 지정하는 두 가지 방법이 있습니다. 값은 &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 또는 &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 의 생성자 중 하나에 매개 변수로 직접 지정됩니다 ( 예 :&lt;a href=&quot;openmbeanparameterinfosupport#OpenMBeanParameterInfoSupport-java.lang.String-java.lang.String-javax.management.openmbean.OpenType-T-T:A-&quot;&gt; &lt;code&gt;OpenMBeanParameterInfoSupport.OpenMBeanParameterInfoSupport( String, String, OpenType, Object, Object[])&lt;/code&gt; &lt;/a&gt; ; 또는 값은생성자 중 하나에 매개 변수로 제공되는&lt;a href=&quot;../descriptor&quot;&gt; &lt;code&gt;Descriptor&lt;/code&gt; &lt;/a&gt; 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="57742fea34c047c7946636e9200af85a7134f451" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as back references; a backslash-escaped number greater than &lt;code&gt;9&lt;/code&gt; is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape. In this class octal escapes must always begin with a zero. In this class, &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit.</source>
          <target state="translated">Perl에서 &lt;code&gt;\1&lt;/code&gt; 에서 &lt;code&gt;\9&lt;/code&gt; 는 항상 역 참조로 해석됩니다. &lt;code&gt;9&lt;/code&gt; 보다 큰 백 슬래시 이스케이프 된 숫자 는 최소한 많은 하위 표현식이 존재하는 경우 역 참조로 취급되며, 그렇지 않으면 가능한 경우 8 진 이스케이프로 해석됩니다. 이 클래스에서 8 진 이스케이프는 항상 0으로 시작해야합니다. 이 클래스에서 &lt;code&gt;\1&lt;/code&gt; ~ &lt;code&gt;\9&lt;/code&gt; 는 항상 역 참조로 해석되며, 정규식의 해당 지점에 최소한 많은 하위 표현식이있는 경우 더 큰 숫자가 역 참조로 허용됩니다. 그렇지 않으면 파서는 숫자까지 숫자를 삭제합니다. 기존 그룹 수보다 작거나 같거나 한 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="4d1565310b4b37e62e7a911cfa4fcf890fef7d66" translate="yes" xml:space="preserve">
          <source>In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl.</source>
          <target state="translated">Perl에서 표현식의 최상위 레벨에 포함 된 플래그는 전체 표현식에 영향을줍니다. 이 클래스에서 임베디드 플래그는 최상위 레벨이든 그룹 내이든 항상 표시되는 지점에서 적용됩니다. 후자의 경우, 플래그는 Perl에서와 같이 그룹의 끝에 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="45254eb83c7215694144dea45c11035bc6d7f671" translate="yes" xml:space="preserve">
          <source>In SQL, a result table is retrieved through a cursor that is named. The current row of a result set can be updated or deleted using a positioned update/delete statement that references the cursor name. To insure that the cursor has the proper isolation level to support update, the cursor's &lt;code&gt;SELECT&lt;/code&gt; statement should be of the form &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is omitted, the positioned updates may fail.</source>
          <target state="translated">In SQL, a result table is retrieved through a cursor that is named. The current row of a result set can be updated or deleted using a positioned update/delete statement that references the cursor name. To insure that the cursor has the proper isolation level to support update, the cursor's &lt;code&gt;SELECT&lt;/code&gt; statement should be of the form &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; . If &lt;code&gt;FOR UPDATE&lt;/code&gt; is omitted, the positioned updates may fail.</target>
        </trans-unit>
        <trans-unit id="3b570462cd79d760be3948904adcdedf1d492b06" translate="yes" xml:space="preserve">
          <source>In SSL, sessions are used to describe an ongoing relationship between two entities.</source>
          <target state="translated">SSL에서 세션은 두 엔티티 간의 지속적인 관계를 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff794ab8aeeb7f642a324d3b35b851cc6c68096" translate="yes" xml:space="preserve">
          <source>In SSL, sessions are used to describe an ongoing relationship between two entities. Each SSL connection involves one session at a time, but that session may be used on many connections between those entities, simultaneously or sequentially. The session used on a connection may also be replaced by a different session. Sessions are created, or rejoined, as part of the SSL handshaking protocol. Sessions may be invalidated due to policies affecting security or resource usage, or by an application explicitly calling &lt;code&gt;invalidate&lt;/code&gt;. Session management policies are typically used to tune performance.</source>
          <target state="translated">SSL에서 세션은 두 엔티티 간의 지속적인 관계를 설명하는 데 사용됩니다. 각 SSL 연결에는 한 번에 하나의 세션이 포함되지만 해당 세션은 해당 엔티티 간의 여러 연결에서 동시에 또는 순차적으로 사용될 수 있습니다. 연결에 사용 된 세션은 다른 세션으로 대체 될 수도 있습니다. 세션은 SSL 핸드 쉐이킹 프로토콜의 일부로 생성되거나 재결합됩니다. 보안 또는 자원 사용에 영향을주는 정책으로 인해 또는 명시 적으로 &lt;code&gt;invalidate&lt;/code&gt; 를 호출하는 애플리케이션으로 인해 세션이 무효화 될 수 있습니다 . 세션 관리 정책은 일반적으로 성능을 조정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dacc622167500cd916a0808c821aecd15f9adae6" translate="yes" xml:space="preserve">
          <source>In XML, this is described by the &lt;code&gt;modifyRow&lt;/code&gt; tag. Both the original and new values are contained within the tag for original row tracking purposes.</source>
          <target state="translated">In XML, this is described by the &lt;code&gt;modifyRow&lt;/code&gt; tag. Both the original and new values are contained within the tag for original row tracking purposes.</target>
        </trans-unit>
        <trans-unit id="4d1efbff85d860f1baeae7205b1916956c1776cb" translate="yes" xml:space="preserve">
          <source>In XML, where the value of an attribute can contain entity references, the child nodes of the &lt;code&gt;Attr&lt;/code&gt; node may be either &lt;code&gt;Text&lt;/code&gt; or &lt;code&gt;EntityReference&lt;/code&gt; nodes (when these are in use; see the description of &lt;code&gt;EntityReference&lt;/code&gt; for discussion).</source>
          <target state="translated">In XML, where the value of an attribute can contain entity references, the child nodes of the &lt;code&gt;Attr&lt;/code&gt; node may be either &lt;code&gt;Text&lt;/code&gt; or &lt;code&gt;EntityReference&lt;/code&gt; nodes (when these are in use; see the description of &lt;code&gt;EntityReference&lt;/code&gt; for discussion).</target>
        </trans-unit>
        <trans-unit id="89a3d9e997a1741012b57bb389e6d0d560cfaf98" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SpringLayout&lt;/code&gt;, the position of each edge is dependent on the position of just one other edge. If a constraint is subsequently added to create a new binding for an edge, the previous binding is discarded and the edge remains dependent on a single edge. Springs should only be attached between edges of the container and its immediate children; the behavior of the &lt;code&gt;SpringLayout&lt;/code&gt; when presented with constraints linking the edges of components from different containers (either internal or external) is undefined.</source>
          <target state="translated">In a &lt;code&gt;SpringLayout&lt;/code&gt; , the position of each edge is dependent on the position of just one other edge. If a constraint is subsequently added to create a new binding for an edge, the previous binding is discarded and the edge remains dependent on a single edge. Springs should only be attached between edges of the container and its immediate children; the behavior of the &lt;code&gt;SpringLayout&lt;/code&gt; when presented with constraints linking the edges of components from different containers (either internal or external) is undefined.</target>
        </trans-unit>
        <trans-unit id="26f05bf5ad6ab1df97bc4c4688975872f5e533e1" translate="yes" xml:space="preserve">
          <source>In a comma-separated list of actions, spaces are allowed before and after each action.</source>
          <target state="translated">쉼표로 구분 된 조치 목록에서 각 조치 전후에 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b27c3d7f721836425a197858414f76de2981f3" translate="yes" xml:space="preserve">
          <source>In a directory, named objects can have associated with them attributes. The &lt;code&gt;Attribute&lt;/code&gt; interface represents an attribute associated with a named object. An attribute contains 0 or more, possibly null, values. The attribute values can be ordered or unordered (see &lt;code&gt;isOrdered()&lt;/code&gt;). If the values are unordered, no duplicates are allowed. If the values are ordered, duplicates are allowed.</source>
          <target state="translated">디렉토리에서 이름 지정된 오브젝트는 해당 속성과 연관 될 수 있습니다. &lt;code&gt;Attribute&lt;/code&gt; 인터페이스는 지정된 객체와 연관된 속성을 나타낸다. 속성에는 0 개 이상의 값이 포함될 수 있습니다. 속성 값은 정렬되거나 정렬되지 않을 수 있습니다 ( &lt;code&gt;isOrdered()&lt;/code&gt; 참조 ) ). 값이 정렬되지 않으면 중복이 허용되지 않습니다. 값을 주문하면 중복이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d814ed6a72f0f727435c36a8f8920d7394fc6592" translate="yes" xml:space="preserve">
          <source>In a directory, named objects can have associated with them attributes. The Attributes interface represents a collection of attributes. For example, you can request from the directory the attributes associated with an object. Those attributes are returned in an object that implements the Attributes interface.</source>
          <target state="translated">디렉토리에서 이름 지정된 오브젝트는 해당 속성과 연관 될 수 있습니다. 속성 인터페이스는 속성 모음을 나타냅니다. 예를 들어, 디렉토리에서 오브젝트와 연관된 속성을 요청할 수 있습니다. 이러한 속성은 속성 인터페이스를 구현하는 객체에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef39a078f24c6cadc5267973ce916397b861c70d" translate="yes" xml:space="preserve">
          <source>In a federated naming system, a context from one naming system may be bound to a name in another. One can subsequently look up and perform operations on the foreign context using a composite name. However, an attempt destroy the context using this composite name will fail with &lt;code&gt;NotContextException&lt;/code&gt;, because the foreign context is not a &quot;subcontext&quot; of the context in which it is bound. Instead, use &lt;code&gt;unbind()&lt;/code&gt; to remove the binding of the foreign context. Destroying the foreign context requires that the &lt;code&gt;destroySubcontext()&lt;/code&gt; be performed on a context from the foreign context's &quot;native&quot; naming system.</source>
          <target state="translated">연합 이름 지정 시스템에서 한 이름 지정 시스템의 컨텍스트가 다른 이름 지정 시스템의 이름에 바인드 될 수 있습니다. 결과적으로 컴포지트 이름을 사용하여 외부 컨텍스트에서 조작을 검색하고 수행 할 수 있습니다. 그러나 외부 컨텍스트가 바인딩 된 컨텍스트의 &quot;하위 컨텍스트&quot;가 &lt;code&gt;NotContextException&lt;/code&gt; 때문에이 복합 이름을 사용하여 컨텍스트를 삭제하려는 시도는 NotContextException으로 실패 합니다 . 대신 &lt;code&gt;unbind()&lt;/code&gt; 를 사용 하여 외부 컨텍스트의 바인딩을 제거하십시오. 외부 컨텍스트를 파기하려면 &lt;code&gt;destroySubcontext()&lt;/code&gt; 외부 컨텍스트의 &quot;네이티브&quot;네이밍 시스템의 컨텍스트에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="114c0d7797271a679147f3a27754dcc0dd68dfa2" translate="yes" xml:space="preserve">
          <source>In a given instance any particular component is either</source>
          <target state="translated">주어진 인스턴스에서 특정 구성 요소는</target>
        </trans-unit>
        <trans-unit id="5a88cd9c503e0a1686f90cc15c6ea972d48245fb" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment with a virtual device, the location is specified in the corresponding virtual coordinate system. If the cursor location is outside the bounds of the virtual device the reported coordinates are clipped to fit within the bounds of the virtual device.</source>
          <target state="translated">가상 장치가있는 다중 화면 환경에서 위치는 해당 가상 좌표계에 지정됩니다. 커서 위치가 가상 장치의 경계를 벗어나면보고 된 좌표가 가상 장치의 경계 내에 맞도록 잘립니다.</target>
        </trans-unit>
        <trans-unit id="beec8e3caa686180234f4b8afe0fdcd9210ef4f5" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment with a virtual device:</source>
          <target state="translated">가상 장치가있는 다중 화면 환경에서 :</target>
        </trans-unit>
        <trans-unit id="2234900dfb150b5e384fa3f5f81373e10b3301c9" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment without a virtual device, the cursor location is specified in the coordinate system of the</source>
          <target state="translated">가상 장치가없는 다중 화면 환경에서 커서 위치는 컴퓨터의 좌표계로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6404a0209e09710c9372e3d7d693cc85df5520" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment without a virtual device:</source>
          <target state="translated">가상 장치가없는 다중 화면 환경에서 :</target>
        </trans-unit>
        <trans-unit id="f1a97eb3ece37ddd086b40af97826bcd430f5f23" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects can be used to render components on multiple screens. The following code sample demonstrates how to create a &lt;code&gt;JFrame&lt;/code&gt; object for each &lt;code&gt;GraphicsConfiguration&lt;/code&gt; on each screen device in the &lt;code&gt;GraphicsEnvironment&lt;/code&gt;:</source>
          <target state="translated">다중 화면 환경에서 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 개체를 사용하여 여러 화면에서 구성 요소를 렌더링 할 수 있습니다. 다음 코드 샘플은 만드는 방법을 보여줍니다 &lt;code&gt;JFrame&lt;/code&gt; 의의 각 개체 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 에서 각 화면 장치 &lt;code&gt;GraphicsEnvironment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b320df9cfdd61b94d5da4cf0c882fd741be52ee" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;Dialog&lt;/code&gt; on a different screen device than its owner. See &lt;a href=&quot;frame&quot;&gt;&lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">다중 화면 환경에서는 소유자가 아닌 다른 화면 장치 에서 &lt;code&gt;Dialog&lt;/code&gt; 를 만들 수 있습니다 . 자세한 내용은 &lt;a href=&quot;frame&quot;&gt; &lt;code&gt;Frame&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d07ce735bcf4902c8204f1f63d8f440d8bc34c23" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;Frame&lt;/code&gt; on a different screen device by constructing the &lt;code&gt;Frame&lt;/code&gt; with &lt;a href=&quot;#%3Cinit%3E(java.awt.GraphicsConfiguration)&quot;&gt;&lt;code&gt;Frame(GraphicsConfiguration)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.awt.GraphicsConfiguration)&quot;&gt;&lt;code&gt;Frame(String title, GraphicsConfiguration)&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object is one of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects of the target screen device.</source>
          <target state="translated">멀티 스크린 환경에서는, 당신은 만들 수 있습니다 &lt;code&gt;Frame&lt;/code&gt; 구축해 다른 스크린 디바이스 상을 &lt;code&gt;Frame&lt;/code&gt; 과 &lt;a href=&quot;#%3Cinit%3E(java.awt.GraphicsConfiguration)&quot;&gt; &lt;code&gt;Frame(GraphicsConfiguration)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.awt.GraphicsConfiguration)&quot;&gt; &lt;code&gt;Frame(String title, GraphicsConfiguration)&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 객체의 하나 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 대상 스크린 장치의 개체.</target>
        </trans-unit>
        <trans-unit id="e9512c06f1bf7d4fe185f8414ab76dfe1eb4fa74" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;JDialog&lt;/code&gt; on a different screen device than its owner. See &lt;a href=&quot;../../java/awt/frame&quot;&gt;&lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">다중 화면 환경에서 소유자와 다른 화면 장치 에서 &lt;code&gt;JDialog&lt;/code&gt; 를 만들 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../../java/awt/frame&quot;&gt; &lt;code&gt;Frame&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc171c3b95f3c60739318307a09709f0df11ea58" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;JFrame&lt;/code&gt; on a different screen device. See &lt;a href=&quot;../../java/awt/frame&quot;&gt;&lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">다중 화면 환경에서 다른 화면 장치에 &lt;code&gt;JFrame&lt;/code&gt; 을 만들 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../../java/awt/frame&quot;&gt; &lt;code&gt;Frame&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58e515a085d497dcf291b45c8fdb16f2cb60b541" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;JWindow&lt;/code&gt; on a different screen device. See &lt;a href=&quot;../../java/awt/window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">다중 화면 환경에서는 다른 화면 장치에 &lt;code&gt;JWindow&lt;/code&gt; 를 만들 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../../java/awt/window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ffadd88ef62e8dc7d903ba85453cda0c5774bb0" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;Window&lt;/code&gt; on a different screen device by constructing the &lt;code&gt;Window&lt;/code&gt; with &lt;a href=&quot;#%3Cinit%3E(java.awt.Window,java.awt.GraphicsConfiguration)&quot;&gt;&lt;code&gt;Window(Window, GraphicsConfiguration)&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object is one of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects of the target screen device.</source>
          <target state="translated">멀티 스크린 환경에서는, 당신은 만들 수 있습니다 &lt;code&gt;Window&lt;/code&gt; 구축해 다른 스크린 디바이스 상을 &lt;code&gt;Window&lt;/code&gt; 와 &lt;a href=&quot;#%3Cinit%3E(java.awt.Window,java.awt.GraphicsConfiguration)&quot;&gt; &lt;code&gt;Window(Window, GraphicsConfiguration)&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 객체의 하나 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 대상 스크린 장치의 개체.</target>
        </trans-unit>
        <trans-unit id="cbb6f1b2109695564847c69426e7cd2b5d348cd9" translate="yes" xml:space="preserve">
          <source>In a multithreaded application, &lt;a href=&quot;keyeventdispatcher&quot;&gt;&lt;code&gt;KeyEventDispatcher&lt;/code&gt;&lt;/a&gt; behaves the same as other AWT listeners. See &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT Threading Issues&lt;/a&gt; for more details.</source>
          <target state="translated">다중 스레드 애플리케이션에서 &lt;a href=&quot;keyeventdispatcher&quot;&gt; &lt;code&gt;KeyEventDispatcher&lt;/code&gt; &lt;/a&gt; 는 다른 AWT 리스너와 동일하게 작동합니다. 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT 스레딩 문제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25abd890f9d831cb21b6f248256eaa8ffdec0eec" translate="yes" xml:space="preserve">
          <source>In a multithreaded application, &lt;a href=&quot;keyeventpostprocessor&quot;&gt;&lt;code&gt;KeyEventPostProcessor&lt;/code&gt;&lt;/a&gt; behaves the same as other AWT listeners. See &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT Threading Issues&lt;/a&gt; for more details.</source>
          <target state="translated">다중 스레드 애플리케이션에서 &lt;a href=&quot;keyeventpostprocessor&quot;&gt; &lt;code&gt;KeyEventPostProcessor&lt;/code&gt; &lt;/a&gt; 는 다른 AWT 리스너와 동일하게 작동합니다. 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT 스레딩 문제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="efe47ac7935506f54f1c9824300c5228ddba832f" translate="yes" xml:space="preserve">
          <source>In a provider-configuration file, any mention of a service provider that is deployed in a named module is ignored. This is to avoid duplicates that would otherwise arise when a named module has both a</source>
          <target state="translated">공급자 구성 파일에서 명명 된 모듈에 배포 된 서비스 공급자에 대한 언급은 무시됩니다. 이것은 명명 된 모듈에 두 가지가 모두있을 때 발생하는 중복을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f34c121362e6825cfb7979d461f740a49f541c2" translate="yes" xml:space="preserve">
          <source>In a similar manner, this method can be used to ignore secondary fields that would otherwise be cross-checked. For example, if the formatter consists of year, month, day-of-month and day-of-week, then there is only one way to resolve a date, but the parsed value for day-of-week will be cross-checked against the resolved date. Calling this method with the arguments &lt;a href=&quot;../temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronofield#DAY_OF_MONTH&quot;&gt;&lt;code&gt;DAY_OF_MONTH&lt;/code&gt;&lt;/a&gt; will ensure that the date is resolved correctly, but without any cross-check for the day-of-week.</source>
          <target state="translated">비슷한 방식으로이 방법을 사용하여 교차 검사 할 보조 필드를 무시할 수 있습니다. 예를 들어, 포맷터가 연도, 월, 일 및 요일로 구성된 경우 날짜를 해결하는 방법은 하나 뿐이지 만 요일에 대한 구문 분석 된 값은 교차 점검됩니다. 해결 날짜에 대해. 인수 &lt;a href=&quot;../temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronofield#DAY_OF_MONTH&quot;&gt; &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; &lt;/a&gt; 를 사용 하여이 메소드를 호출 하면 날짜가 올바르게 확인되지만 요일에 대한 교차 점검이 없습니다.</target>
        </trans-unit>
        <trans-unit id="90329937fe209cdc5c56c8a7860e7f3ea7544235" translate="yes" xml:space="preserve">
          <source>In a string without quotes or escapes, any instance of the separator delimits two atomic names. Each atomic name is referred to as a &lt;em&gt;component&lt;/em&gt;.</source>
          <target state="translated">따옴표 나 이스케이프가없는 문자열에서 구분 기호의 인스턴스는 두 개의 원자 이름으로 구분됩니다. 각 원자 이름을 &lt;em&gt;구성 요소&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="0ed539e402cf385b4dd9e80abdc848541c1447f9" translate="yes" xml:space="preserve">
          <source>In a text processing application that can cache intermediate representations of text, creation and subsequent caching of a &lt;code&gt;GlyphVector&lt;/code&gt; for use during rendering is the fastest method to present the visual representation of characters to a user.</source>
          <target state="translated">텍스트의 중간 표현을 캐시 할 수있는 텍스트 처리 응용 프로그램 에서 렌더링 중에 사용할 &lt;code&gt;GlyphVector&lt;/code&gt; 의 생성 및 후속 캐싱은 사용자에게 문자의 시각적 표현을 제공하는 가장 빠른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ed263b2f5c9c11d52878d6f815cf7ac22d9692aa" translate="yes" xml:space="preserve">
          <source>In a tree of tiered phasers, registration and deregistration of child phasers with their parent are managed automatically. Whenever the number of registered parties of a child phaser becomes non-zero (as established in the &lt;a href=&quot;#%3Cinit%3E(java.util.concurrent.Phaser,int)&quot;&gt;&lt;code&gt;Phaser(Phaser,int)&lt;/code&gt;&lt;/a&gt; constructor, &lt;a href=&quot;#register()&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#bulkRegister(int)&quot;&gt;&lt;code&gt;bulkRegister(int)&lt;/code&gt;&lt;/a&gt;), the child phaser is registered with its parent. Whenever the number of registered parties becomes zero as the result of an invocation of &lt;a href=&quot;#arriveAndDeregister()&quot;&gt;&lt;code&gt;arriveAndDeregister()&lt;/code&gt;&lt;/a&gt;, the child phaser is deregistered from its parent.</source>
          <target state="translated">계층 형 페이저 트리에서 부모와 자식 페이저의 등록 및 등록 취소는 자동으로 관리됩니다. &lt;a href=&quot;#%3Cinit%3E(java.util.concurrent.Phaser,int)&quot;&gt; &lt;code&gt;Phaser(Phaser,int)&lt;/code&gt; &lt;/a&gt; 생성자에 설정된대로 자식 Phaser의 등록 된 당사자 수가 0이 아닐 때마다&lt;a href=&quot;#register()&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;#bulkRegister(int)&quot;&gt; &lt;code&gt;bulkRegister(int)&lt;/code&gt; &lt;/a&gt; ), 하위 Phaser는 부모에 등록됩니다.&lt;a href=&quot;#arriveAndDeregister()&quot;&gt; &lt;code&gt;arriveAndDeregister()&lt;/code&gt; &lt;/a&gt; 호출의 결과로 등록 된 당사자 수가 0이 될 때마다자식 페이저는 부모에서 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="85fe56db10a3c0d908e17d31e5b4da75440bafdf" translate="yes" xml:space="preserve">
          <source>In a tree of tiered phasers, registration and deregistration of child phasers with their parent are managed automatically. Whenever the number of registered parties of a child phaser becomes non-zero (as established in the &lt;a href=&quot;phaser#Phaser-java.util.concurrent.Phaser-int-&quot;&gt;&lt;code&gt;Phaser(Phaser,int)&lt;/code&gt;&lt;/a&gt; constructor, &lt;a href=&quot;phaser#register--&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;phaser#bulkRegister-int-&quot;&gt;&lt;code&gt;bulkRegister(int)&lt;/code&gt;&lt;/a&gt;), the child phaser is registered with its parent. Whenever the number of registered parties becomes zero as the result of an invocation of &lt;a href=&quot;phaser#arriveAndDeregister--&quot;&gt;&lt;code&gt;arriveAndDeregister()&lt;/code&gt;&lt;/a&gt;, the child phaser is deregistered from its parent.</source>
          <target state="translated">계층 적 페이저 트리에서는 부모와 함께 자식 페이저의 등록 및 등록 취소가 자동으로 관리됩니다. &lt;a href=&quot;phaser#Phaser-java.util.concurrent.Phaser-int-&quot;&gt; &lt;code&gt;Phaser(Phaser,int)&lt;/code&gt; &lt;/a&gt; 생성자, &lt;a href=&quot;phaser#register--&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;phaser#bulkRegister-int-&quot;&gt; &lt;code&gt;bulkRegister(int)&lt;/code&gt; &lt;/a&gt; 설정된 하위 페이저의 등록 된 당사자 수가 0이 아닌 경우 하위 페이저는 해당 상위에 등록됩니다. &lt;a href=&quot;phaser#arriveAndDeregister--&quot;&gt; &lt;code&gt;arriveAndDeregister()&lt;/code&gt; &lt;/a&gt; 호출하여 등록 된 당사자 수가 0이 될 때마다 하위 페이저가 상위에서 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="6842084fd313a8aff5259cff4e2ee349f7ffc691" translate="yes" xml:space="preserve">
          <source>In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of all configurations are relative to the virtual device coordinate system. The origin of the virtual-coordinate system is at the upper left-hand corner of the primary physical screen. Depending on the location of the primary screen in the virtual device, negative coordinates are possible, as shown in the following figure.</source>
          <target state="translated">데스크톱 영역이 여러 물리적 화면 장치에 걸쳐있을 수있는 가상 장치 다중 화면 환경에서 모든 구성의 경계는 가상 장치 좌표계를 기준으로합니다. 가상 좌표계의 원점은 기본 물리적 화면의 왼쪽 상단 모서리에 있습니다. 가상 장치의 기본 화면 위치에 따라 다음 그림과 같이 음의 좌표가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cf00b9b973d8c83ad9d8253cbb4fa615258d8038" translate="yes" xml:space="preserve">
          <source>In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of all configurations are relative to the virtual-coordinate system. The origin of the virtual-coordinate system is at the upper left-hand corner of the primary physical screen. Depending on the location of the primary screen in the virtual device, negative coordinates are possible, as shown in the following figure.</source>
          <target state="translated">데스크톱 영역이 여러 물리적 화면 장치에 걸쳐있을 수있는 가상 장치 다중 화면 환경에서 모든 구성의 경계는 가상 좌표 시스템에 상대적입니다. 가상 좌표계의 원점은 기본 물리적 화면의 왼쪽 상단 모서리에 있습니다. 가상 장치의 기본 화면 위치에 따라 다음 그림과 같이 음의 좌표가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="37042eb4e42e068b312195920663ac63249d62d0" translate="yes" xml:space="preserve">
          <source>In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects are relative to the virtual coordinate system. When setting the location of a component, use &lt;a href=&quot;#getBounds()&quot;&gt;&lt;code&gt;getBounds&lt;/code&gt;&lt;/a&gt; to get the bounds of the desired &lt;code&gt;GraphicsConfiguration&lt;/code&gt; and offset the location with the coordinates of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt;, as the following code sample illustrates:</source>
          <target state="translated">데스크톱 영역이 여러 물리적 화면 장치에 걸쳐있을 수있는 가상 장치 다중 화면 환경에서 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 개체 의 경계 는 가상 좌표계에 상대적입니다. 구성 요소의 위치를 ​​설정할 때 &lt;a href=&quot;#getBounds()&quot;&gt; &lt;code&gt;getBounds&lt;/code&gt; &lt;/a&gt; 를 사용 하여 원하는 경계를 가져옵니다. &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 오고 다음 코드 샘플과 같이 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 의 좌표로 위치를 오프셋합니다 .</target>
        </trans-unit>
        <trans-unit id="4de1fa88647ce453435c8841d38d13382e76babc" translate="yes" xml:space="preserve">
          <source>In a weighted list, each language range is given a weight value. The weight value is identical to the &quot;quality value&quot; in &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, and it expresses how much the user prefers the language. A weight value is specified after a corresponding language range followed by &lt;code&gt;&quot;;q=&quot;&lt;/code&gt;, and the default weight value is &lt;code&gt;MAX_WEIGHT&lt;/code&gt; when it is omitted.</source>
          <target state="translated">가중치 목록에서 각 언어 범위에는 가중치가 부여됩니다. 가중치는 &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 의 &quot;품질 값&quot;과 동일 하며 사용자가 언어를 얼마나 선호 하는지를 나타냅니다. 가중치는 해당 언어 범위 뒤에 &lt;code&gt;&quot;;q=&quot;&lt;/code&gt; 뒤에 지정 되며 생략시 기본 가중치는 &lt;code&gt;MAX_WEIGHT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db07c01b971410649ed0adc273a6cbcf93d8159c" translate="yes" xml:space="preserve">
          <source>In addition it provides an extension mechanism so that arbitrary attribute/value pairs can be associated with a design feature.</source>
          <target state="translated">또한 임의의 속성 / 값 쌍이 디자인 기능과 연관 될 수 있도록 확장 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aee5260cc3f43d7a4d3d6be25379877f1d070d35" translate="yes" xml:space="preserve">
          <source>In addition there is a level OFF that can be used to turn off logging, and a level ALL that can be used to enable logging of all messages.</source>
          <target state="translated">또한 로깅을 해제하는 데 사용할 수있는 수준 OFF와 모든 메시지를 기록하는 데 사용할 수있는 수준 ALL이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25aa82e21834a941721fb6024ff6ae38ee5c486b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt;, the following options may be present:</source>
          <target state="translated">&lt;code&gt;READ&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 외에도 다음과 같은 옵션이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a77e8c6c29cfcb07a58299b7f377977a6631ab29" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Stream&lt;/code&gt;, which is a stream of object references, there are primitive specializations for &lt;a href=&quot;intstream&quot;&gt;&lt;code&gt;IntStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;longstream&quot;&gt;&lt;code&gt;LongStream&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;doublestream&quot;&gt;&lt;code&gt;DoubleStream&lt;/code&gt;&lt;/a&gt;, all of which are referred to as &quot;streams&quot; and conform to the characteristics and restrictions described here.</source>
          <target state="translated">객체 참조 스트림 인 &lt;code&gt;Stream&lt;/code&gt; 외에도 &lt;a href=&quot;intstream&quot;&gt; &lt;code&gt;IntStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;longstream&quot;&gt; &lt;code&gt;LongStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;doublestream&quot;&gt; &lt;code&gt;DoubleStream&lt;/code&gt; 에&lt;/a&gt; 대한 기본 전문화가 있습니다 모두 &quot;스트림&quot;이라고하며 여기에 설명 된 특성과 제한 사항을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f7053d093b3d7495ffccb4caf96bc92474aae362" translate="yes" xml:space="preserve">
          <source>In addition to JAR files, an implementation may also support modules that are packaged in other implementation specific module formats. If an element in the array specified to this method is a path to a directory of modules then entries in the directory that not recognized as modules are ignored. If an element in the array is a path to a packaged module that is not recognized then a &lt;code&gt;FindException&lt;/code&gt; is thrown when the file is encountered. Paths to files that do not exist are always ignored.</source>
          <target state="translated">JAR 파일 외에도 구현은 다른 구현 특정 모듈 형식으로 패키지 된 모듈을 지원할 수도 있습니다. 이 메소드에 지정된 배열의 요소가 모듈 디렉토리의 경로 인 경우 모듈로 인식되지 않는 디렉토리의 항목은 무시됩니다. 배열의 요소가 인식되지 않는 패키징 된 모듈의 경로 인 경우 파일이 발견되면 &lt;code&gt;FindException&lt;/code&gt; 이 발생합니다. 존재하지 않는 파일 경로는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="863160dc390b3ec933c01afa4c507995a466826d" translate="yes" xml:space="preserve">
          <source>In addition to a message string, a reference to another &lt;code&gt;Throwable&lt;/code&gt; (&lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;Exception&lt;/code&gt;) is maintained. This reference, if non-&lt;code&gt;null&lt;/code&gt;, refers to the event that caused this exception to occur. For example, an &lt;code&gt;IOException&lt;/code&gt; while reading from a &lt;code&gt;File&lt;/code&gt; would be stored there.</source>
          <target state="translated">메시지 문자열 외에도 다른 &lt;code&gt;Throwable&lt;/code&gt; ( &lt;code&gt;Error&lt;/code&gt; 또는 &lt;code&gt;Exception&lt;/code&gt; )에 대한 참조 가 유지됩니다. &lt;code&gt;null&lt;/code&gt; 이외의 경우,이 참조 는이 예외를 발생시킨 이벤트를 참조합니다. 예를 들어, &lt;code&gt;File&lt;/code&gt; 에서 읽는 동안 &lt;code&gt;IOException&lt;/code&gt; 이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7cae3428a9414e77995a69af58d38c2d85c371b2" translate="yes" xml:space="preserve">
          <source>In addition to accessing the components of a path, a &lt;code&gt;Path&lt;/code&gt; also defines the &lt;a href=&quot;#resolve(java.nio.file.Path)&quot;&gt;&lt;code&gt;resolve&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#resolveSibling(java.nio.file.Path)&quot;&gt;&lt;code&gt;resolveSibling&lt;/code&gt;&lt;/a&gt; methods to combine paths. The &lt;a href=&quot;#relativize(java.nio.file.Path)&quot;&gt;&lt;code&gt;relativize&lt;/code&gt;&lt;/a&gt; method that can be used to construct a relative path between two paths. Paths can be &lt;a href=&quot;#compareTo(java.nio.file.Path)&quot;&gt;&lt;code&gt;compared&lt;/code&gt;&lt;/a&gt;, and tested against each other using the &lt;a href=&quot;#startsWith(java.nio.file.Path)&quot;&gt;&lt;code&gt;startsWith&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#endsWith(java.nio.file.Path)&quot;&gt;&lt;code&gt;endsWith&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">경로의 구성 요소에 액세스하는 것 외에도 &lt;code&gt;Path&lt;/code&gt; 는 경로를 결합 하는 &lt;a href=&quot;#resolve(java.nio.file.Path)&quot;&gt; &lt;code&gt;resolve&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#resolveSibling(java.nio.file.Path)&quot;&gt; &lt;code&gt;resolveSibling&lt;/code&gt; &lt;/a&gt; 메서드를 정의합니다 . &lt;a href=&quot;#relativize(java.nio.file.Path)&quot;&gt; &lt;code&gt;relativize&lt;/code&gt; &lt;/a&gt; 두 개의 경로 사이의 상대 경로를 구성하는 데 사용할 수있는 방법. 경로가 될 수있다 &lt;a href=&quot;#compareTo(java.nio.file.Path)&quot;&gt; &lt;code&gt;compared&lt;/code&gt; &lt;/a&gt; 하고 사용하여 서로에 대해 테스트 &lt;a href=&quot;#startsWith(java.nio.file.Path)&quot;&gt; &lt;code&gt;startsWith&lt;/code&gt; 을&lt;/a&gt; 하고&lt;a href=&quot;#endsWith(java.nio.file.Path)&quot;&gt; &lt;code&gt;endsWith&lt;/code&gt; &lt;/a&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="2ad396eb168616040e6ae0797aa5e8deb8ca87b3" translate="yes" xml:space="preserve">
          <source>In addition to accessing the components of a path, a &lt;code&gt;Path&lt;/code&gt; also defines the &lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt;&lt;code&gt;resolve&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;path#resolveSibling-java.nio.file.Path-&quot;&gt;&lt;code&gt;resolveSibling&lt;/code&gt;&lt;/a&gt; methods to combine paths. The &lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt;&lt;code&gt;relativize&lt;/code&gt;&lt;/a&gt; method that can be used to construct a relative path between two paths. Paths can be &lt;a href=&quot;path#compareTo-java.nio.file.Path-&quot;&gt;&lt;code&gt;compared&lt;/code&gt;&lt;/a&gt;, and tested against each other using the &lt;a href=&quot;path#startsWith-java.nio.file.Path-&quot;&gt;&lt;code&gt;startsWith&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;path#endsWith-java.nio.file.Path-&quot;&gt;&lt;code&gt;endsWith&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">경로의 구성 요소에 접근하는 또한, &lt;code&gt;Path&lt;/code&gt; 도 정의 &lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt; &lt;code&gt;resolve&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;path#resolveSibling-java.nio.file.Path-&quot;&gt; &lt;code&gt;resolveSibling&lt;/code&gt; &lt;/a&gt; 경로를 결합하는 방법을. &lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt; &lt;code&gt;relativize&lt;/code&gt; &lt;/a&gt; 두 개의 경로 사이의 상대 경로를 구성하는 데 사용할 수있는 방법. &lt;a href=&quot;path#startsWith-java.nio.file.Path-&quot;&gt; &lt;code&gt;startsWith&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;path#endsWith-java.nio.file.Path-&quot;&gt; &lt;code&gt;endsWith&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 경로를 &lt;a href=&quot;path#compareTo-java.nio.file.Path-&quot;&gt; &lt;code&gt;compared&lt;/code&gt; &lt;/a&gt; 하고 서로에 대해 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b69db6d9c887a09c80baed2338b0466acc408a2c" translate="yes" xml:space="preserve">
          <source>In addition to adjusting a date-time, an interface is provided to enable querying via &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;. The most common implementations of the query interface are method references. The &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; methods on major classes can all be used, such as &lt;code&gt;LocalDate::from&lt;/code&gt; or &lt;code&gt;Month::from&lt;/code&gt;. Further implementations are provided in &lt;a href=&quot;temporalqueries&quot;&gt;&lt;code&gt;TemporalQueries&lt;/code&gt;&lt;/a&gt; as static methods. Applications can also define queries by implementing &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">날짜 시간을 조정하는 것 외에도 &lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 를 통한 쿼리를 가능하게하는 인터페이스가 제공됩니다 . 쿼리 인터페이스의 가장 일반적인 구현은 메소드 참조입니다. &lt;code&gt;LocalDate::from&lt;/code&gt; 또는 &lt;code&gt;Month::from&lt;/code&gt; 과 같은 주요 클래스 의 &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; 메소드를 모두 사용할 수 있습니다 . 추가 구현은 &lt;a href=&quot;temporalqueries&quot;&gt; &lt;code&gt;TemporalQueries&lt;/code&gt; &lt;/a&gt; 에서 정적 메소드로 제공됩니다 . 응용 프로그램은 &lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 를 구현하여 쿼리를 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b19c15dcc38f6284d861a9041b2c5b74bc056854" translate="yes" xml:space="preserve">
          <source>In addition to any and all default formats text returned by the system Clipboard's &lt;code&gt;getTransferData()&lt;/code&gt; method is available in the following flavors:</source>
          <target state="translated">시스템 클립 보드의 &lt;code&gt;getTransferData()&lt;/code&gt; 메서드에 의해 반환 된 모든 기본 형식 텍스트 외에도 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="18dd49d60299a8c8c9308c9ee36eeeae82c291e1" translate="yes" xml:space="preserve">
          <source>In addition to any notification specified by the application, a ModelMBean may always send also two additional notifications:</source>
          <target state="translated">응용 프로그램에서 지정한 알림 외에도 ModelMBean은 항상 두 개의 추가 알림을 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4c0aa78ed39e161d449ed162b18522a30f07ac8" translate="yes" xml:space="preserve">
          <source>In addition to attribute views, this package also defines classes and interfaces that are used when accessing attributes:</source>
          <target state="translated">이 패키지는 속성보기 외에도 속성에 액세스 할 때 사용되는 클래스와 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bc50128c00af4b489ab96e5629b96a88aadeb5af" translate="yes" xml:space="preserve">
          <source>In addition to classes representing single values and arrays, this package contains &lt;em&gt;Updater&lt;/em&gt; classes that can be used to obtain &lt;code&gt;compareAndSet&lt;/code&gt; and related operations on any selected &lt;code&gt;volatile&lt;/code&gt; field of any selected class. These classes predate the introduction of &lt;a href=&quot;../../../lang/invoke/varhandle&quot;&gt;&lt;code&gt;VarHandle&lt;/code&gt;&lt;/a&gt;, and are of more limited use. &lt;a href=&quot;atomicreferencefieldupdater&quot;&gt;&lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomicintegerfieldupdater&quot;&gt;&lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;atomiclongfieldupdater&quot;&gt;&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;&lt;/a&gt; are reflection-based utilities that provide access to the associated field types. These are mainly of use in atomic data structures in which several &lt;code&gt;volatile&lt;/code&gt; fields of the same node (for example, the links of a tree node) are independently subject to atomic updates. These classes enable greater flexibility in how and when to use atomic updates, at the expense of more awkward reflection-based setup, less convenient usage, and weaker guarantees.</source>
          <target state="translated">단일 값 및 배열을 나타내는 클래스 &lt;em&gt;외에도이&lt;/em&gt; 패키지에는 선택한 클래스의 선택된 &lt;code&gt;volatile&lt;/code&gt; 필드 에 대한 &lt;code&gt;compareAndSet&lt;/code&gt; 및 관련 작업 을 가져 오는 데 사용할 수있는 &lt;em&gt;Updater&lt;/em&gt; 클래스가 포함되어 있습니다 . 이러한 클래스는 &lt;a href=&quot;../../../lang/invoke/varhandle&quot;&gt; &lt;code&gt;VarHandle&lt;/code&gt; &lt;/a&gt; 도입보다 이전 이며 더 제한적으로 사용됩니다. &lt;a href=&quot;atomicreferencefieldupdater&quot;&gt; &lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomicintegerfieldupdater&quot;&gt; &lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;atomiclongfieldupdater&quot;&gt; &lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt; &lt;/a&gt; 는 관련 필드 유형에 대한 액세스를 제공하는 리플렉션 기반 유틸리티입니다. 이들은 주로 여러 &lt;code&gt;volatile&lt;/code&gt; 있는 원자 데이터 구조에서 사용됩니다.동일한 노드의 필드 (예 : 트리 노드의 링크)는 독립적으로 원자 적 업데이트를받습니다. 이러한 클래스는 어색한 리플렉션 기반 설정, 덜 편리한 사용 및 약한 보증을 희생하면서 원자 업데이트를 사용하는 방법과시기에 더 큰 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="27cf5bf5dd1546b6480b43a44092643f35de07f9" translate="yes" xml:space="preserve">
          <source>In addition to classes representing single values, this package contains &lt;em&gt;Updater&lt;/em&gt; classes that can be used to obtain &lt;code&gt;compareAndSet&lt;/code&gt; operations on any selected &lt;code&gt;volatile&lt;/code&gt; field of any selected class. &lt;a href=&quot;atomicreferencefieldupdater&quot;&gt;&lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomicintegerfieldupdater&quot;&gt;&lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;atomiclongfieldupdater&quot;&gt;&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;&lt;/a&gt; are reflection-based utilities that provide access to the associated field types. These are mainly of use in atomic data structures in which several &lt;code&gt;volatile&lt;/code&gt; fields of the same node (for example, the links of a tree node) are independently subject to atomic updates. These classes enable greater flexibility in how and when to use atomic updates, at the expense of more awkward reflection-based setup, less convenient usage, and weaker guarantees.</source>
          <target state="translated">이 패키지에는 단일 값을 나타내는 클래스 외에도 선택한 클래스의 선택된 &lt;code&gt;volatile&lt;/code&gt; 필드 에서 &lt;code&gt;compareAndSet&lt;/code&gt; 작업 을 얻는 데 사용할 수있는 &lt;em&gt;Updater&lt;/em&gt; 클래스가 포함되어 있습니다 . &lt;a href=&quot;atomicreferencefieldupdater&quot;&gt; &lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomicintegerfieldupdater&quot;&gt; &lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;atomiclongfieldupdater&quot;&gt; &lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt; &lt;/a&gt; 는 관련 필드 유형에 대한 액세스를 제공하는 리플렉션 기반 유틸리티입니다. 이들은 주로 &lt;code&gt;volatile&lt;/code&gt; 이 많은 원자 데이터 구조에서 사용됩니다.동일한 노드의 필드 (예 : 트리 노드의 링크)는 독립적으로 원자 업데이트됩니다. 이러한 클래스는보다 어색한 리플렉션 기반 설정, 덜 편리한 사용 및 약한 보증을 희생하면서 원자 업데이트를 사용하는 방법과시기에 더 큰 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86cfc1a551a2b499d9426296495d7d86d23960f2" translate="yes" xml:space="preserve">
          <source>In addition to element nodes, XPath location paths may also address attribute nodes, text nodes, comment nodes, and processing instruction nodes. The following table gives examples of location paths for each of these node types:</source>
          <target state="translated">요소 노드 외에도 XPath 위치 경로는 속성 노드, 텍스트 노드, 주석 노드 및 처리 명령 노드를 지정할 수 있습니다. 다음 표는 이러한 각 노드 유형에 대한 위치 경로의 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a910912e92276c4c5b3275eff73b6ba6d758828" translate="yes" xml:space="preserve">
          <source>In addition to execution and lifecycle control methods, this class provides status check methods (for example &lt;a href=&quot;#getStealCount()&quot;&gt;&lt;code&gt;getStealCount()&lt;/code&gt;&lt;/a&gt;) that are intended to aid in developing, tuning, and monitoring fork/join applications. Also, method &lt;a href=&quot;#toString()&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; returns indications of pool state in a convenient form for informal monitoring.</source>
          <target state="translated">실행 및 수명주기 제어 메서드 &lt;a href=&quot;#getStealCount()&quot;&gt; &lt;code&gt;getStealCount()&lt;/code&gt; &lt;/a&gt; 클래스는 포크 / 조인 애플리케이션을 개발, 조정 및 모니터링하는 데 도움이되는 상태 확인 메서드 (예 : getStealCount () )를 제공합니다. 또한 &lt;a href=&quot;#toString()&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드 는 비공식 모니터링을 위해 편리한 형식으로 풀 상태 표시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c07668fb78a3e8b44ef261341e115a92aefc5157" translate="yes" xml:space="preserve">
          <source>In addition to execution and lifecycle control methods, this class provides status check methods (for example &lt;a href=&quot;forkjoinpool#getStealCount--&quot;&gt;&lt;code&gt;getStealCount()&lt;/code&gt;&lt;/a&gt;) that are intended to aid in developing, tuning, and monitoring fork/join applications. Also, method &lt;a href=&quot;forkjoinpool#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; returns indications of pool state in a convenient form for informal monitoring.</source>
          <target state="translated">실행 및 라이프 사이클 제어 메소드 &lt;a href=&quot;forkjoinpool#getStealCount--&quot;&gt; &lt;code&gt;getStealCount()&lt;/code&gt; &lt;/a&gt; 클래스는 포크 / 조인 애플리케이션의 개발, 조정 및 모니터링을 지원 하는 상태 확인 메소드 (예 : getStealCount () )를 제공합니다. 또한 &lt;a href=&quot;forkjoinpool#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드 는 비공식 모니터링을위한 편리한 형식으로 풀 상태 표시를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c14f1da366289ef8301d035cb42e8fc05d0b3be6" translate="yes" xml:space="preserve">
          <source>In addition to groups created explicitly, the Java virtual machine maintains a system-wide &lt;em&gt;default group&lt;/em&gt; that is constructed automatically. Asynchronous channels that do not specify a group at construction time are bound to the default group. The default group has an associated thread pool that creates new threads as needed. The default group may be configured by means of system properties defined in the table below. Where the &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/a&gt; for the default group is not configured then the pooled threads of the default group are &lt;a href=&quot;../../lang/thread#isDaemon()&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; threads.</source>
          <target state="translated">명시 적으로 생성 된 그룹 외에도 JVM (Java Virtual Machine) 은 자동으로 생성 되는 시스템 전체의 &lt;em&gt;기본 그룹&lt;/em&gt; 을 유지합니다 . 구성시 그룹을 지정하지 않는 비동기 채널은 기본 그룹에 바인딩됩니다. 기본 그룹에는 필요에 따라 새 스레드를 만드는 관련 스레드 풀이 있습니다. 기본 그룹은 아래 표에 정의 된 시스템 속성을 통해 구성 할 수 있습니다. 를 Where &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt; &lt;code&gt;ThreadFactory&lt;/code&gt; 를&lt;/a&gt; 기본 그룹에 대한 다음 구성되지 않은 기본 그룹의 풀링 스레드는 &lt;a href=&quot;../../lang/thread#isDaemon()&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt; 스레드.</target>
        </trans-unit>
        <trans-unit id="249af950c1dd714f44dfbec5cb9ac53d258e1718" translate="yes" xml:space="preserve">
          <source>In addition to groups created explicitly, the Java virtual machine maintains a system-wide &lt;em&gt;default group&lt;/em&gt; that is constructed automatically. Asynchronous channels that do not specify a group at construction time are bound to the default group. The default group has an associated thread pool that creates new threads as needed. The default group may be configured by means of system properties defined in the table below. Where the &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/a&gt; for the default group is not configured then the pooled threads of the default group are &lt;a href=&quot;../../lang/thread#isDaemon--&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; threads.</source>
          <target state="translated">명시 적으로 작성된 그룹 외에도 Java 가상 머신 은 자동으로 구성된 시스템 전체 &lt;em&gt;기본 그룹&lt;/em&gt; 을 유지 보수합니다 . 생성시 그룹을 지정하지 않은 비동기 채널은 기본 그룹에 바인딩됩니다. 기본 그룹에는 필요에 따라 새 스레드를 작성하는 연관된 스레드 풀이 있습니다. 기본 그룹은 아래 표에 정의 된 시스템 속성으로 구성 할 수 있습니다. 기본 그룹 의 &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt; &lt;code&gt;ThreadFactory&lt;/code&gt; &lt;/a&gt; 가 구성되지 않은 경우 기본 그룹의 풀링 된 스레드는 &lt;a href=&quot;../../lang/thread#isDaemon--&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt; 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="e10fc02d16ef570a75e8db5a40d2d23818a250fc" translate="yes" xml:space="preserve">
          <source>In addition to implementing the &lt;a href=&quot;lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; interface, this class defines a number of &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; methods for inspecting the state of the lock. Some of these methods are only useful for instrumentation and monitoring.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현할뿐만 아니라 잠금 상태를 검사하기위한 많은 &lt;code&gt;public&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 메소드를 정의합니다 . 이러한 방법 중 일부는 계측 및 모니터링에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="91e7be4c0bd9afd5d0219e0805abd80ce1a6ae2d" translate="yes" xml:space="preserve">
          <source>In addition to loading classes, a class loader is also responsible for locating resources. A resource is some data (a &quot;&lt;code&gt;.class&lt;/code&gt;&quot; file, configuration data, or an image for example) that is identified with an abstract '/'-separated path name. Resources are typically packaged with an application or library so that they can be located by code in the application or library. In some cases, the resources are included so that they can be located by other libraries.</source>
          <target state="translated">클래스를로드하는 것 외에도 클래스 로더는 리소스를 찾습니다. 리소스는 추상적 인 '/'로 구분 된 경로 이름으로 식별되는 일부 데이터 (예 : &quot; &lt;code&gt;.class&lt;/code&gt; &quot;파일, 구성 데이터 또는 이미지)입니다. 리소스는 일반적으로 애플리케이션 또는 라이브러리와 함께 패키지화되어 애플리케이션 또는 라이브러리의 코드로 찾을 수 있습니다. 경우에 따라 다른 라이브러리에서 찾을 수 있도록 리소스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ec4b220124539fad132ce531bce148656eb3511a" translate="yes" xml:space="preserve">
          <source>In addition to methods for accessing the position, limit, and capacity values and for marking and resetting, this class also defines the following operations upon buffers:</source>
          <target state="translated">위치, 한계 및 용량 값에 액세스하고 표시 및 재설정을위한 방법 외에도이 클래스는 버퍼에 대해 다음 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c9c67790b6c91037224cb0e43f334ace4be9115f" translate="yes" xml:space="preserve">
          <source>In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...) and so on.</source>
          <target state="translated">정의 된 오류 및 경고를 발생시키는 것 외에도 구현은 IO 오류 (파일을 찾을 수 없음, 권한 거부 됨 등) 등과 같은 기타 오류 및 경고 사례에 대한 구현 관련 오류 및 경고를 발생시킬 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="fd52079bbe205b3bcd374f203efffc0470e1745b" translate="yes" xml:space="preserve">
          <source>In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...), XML well-formedness errors, and so on.</source>
          <target state="translated">정의 된 오류 및 경고를 제기하는 것 외에도 구현시 IO 오류 (파일을 찾을 수 없음, 권한이 거부 됨, ...), XML 형식 오류, 기타 오류 및 경고 사례에 대한 구현 관련 오류 및 경고가 발생할 것으로 예상됩니다. 등등.</target>
        </trans-unit>
        <trans-unit id="4afd3c157bbfa30f1d336e095cfe8fd7e7490d3a" translate="yes" xml:space="preserve">
          <source>In addition to read and write operations, this class defines the following operations:</source>
          <target state="translated">읽기 및 쓰기 작업 외에도이 클래스는 다음 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bec83f051a9027148e6a86a6c722b1724d907132" translate="yes" xml:space="preserve">
          <source>In addition to reading bytes from the input buffer and writing characters to the output buffer, this method returns a &lt;a href=&quot;coderresult&quot;&gt;&lt;code&gt;CoderResult&lt;/code&gt;&lt;/a&gt; object to describe its reason for termination:</source>
          <target state="translated">입력 버퍼에서 바이트를 읽고 출력 버퍼에 문자를 쓰는 것 &lt;a href=&quot;coderresult&quot;&gt; &lt;code&gt;CoderResult&lt;/code&gt; &lt;/a&gt; 메소드는 종료 이유를 설명하기 위해 CoderResult 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6511f7091630bdef1a1d4d49b93dfe3aaad905c0" translate="yes" xml:space="preserve">
          <source>In addition to reading characters from the input buffer and writing bytes to the output buffer, this method returns a &lt;a href=&quot;coderresult&quot;&gt;&lt;code&gt;CoderResult&lt;/code&gt;&lt;/a&gt; object to describe its reason for termination:</source>
          <target state="translated">입력 버퍼에서 문자를 읽고 출력 버퍼에 바이트를 쓰는 것 &lt;a href=&quot;coderresult&quot;&gt; &lt;code&gt;CoderResult&lt;/code&gt; &lt;/a&gt; 메소드는 종료 이유를 설명하기 위해 CoderResult 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="426c21be8d23fc549653794732dd4ec11d9e7056" translate="yes" xml:space="preserve">
          <source>In addition to serving as a standalone class, this class provides &lt;code&gt;protected&lt;/code&gt; functionality that may be useful when creating customized task classes.</source>
          <target state="translated">이 클래스는 독립형 클래스로 제공 될뿐만 아니라 사용자 정의 된 태스크 클래스를 작성할 때 유용한 &lt;code&gt;protected&lt;/code&gt; 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="de03a6972c04d5b1cdbf9debef3b7b16ba094ed9" translate="yes" xml:space="preserve">
          <source>In addition to serving as the base class for other component-related events (InputEvent, FocusEvent, WindowEvent, ContainerEvent), this class defines the events that indicate changes in a component's size, position, or visibility.</source>
          <target state="translated">이 클래스는 다른 구성 요소 관련 이벤트 (InputEvent, FocusEvent, WindowEvent, ContainerEvent)에 대한 기본 클래스 역할을 할뿐만 아니라 구성 요소의 크기, 위치 또는 가시성의 변경을 나타내는 이벤트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="67587c18b575b6663ae372b4e32c91ccb2a965bf" translate="yes" xml:space="preserve">
          <source>In addition to sorting &lt;code&gt;TableRowSorter&lt;/code&gt; provides the ability to filter. A filter is specified using the &lt;code&gt;setFilter&lt;/code&gt; method. The following example will only show rows containing the string &quot;foo&quot;:</source>
          <target state="translated">정렬 외에도 &lt;code&gt;TableRowSorter&lt;/code&gt; 는 필터링 기능을 제공합니다. 필터는 &lt;code&gt;setFilter&lt;/code&gt; 메소드를 사용하여 지정됩니다 . 다음 예제는 문자열 &quot;foo&quot;를 포함하는 행만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ab8996f20e697a6d14a3748b6ff488d071e6087b" translate="yes" xml:space="preserve">
          <source>In addition to sorting, &lt;code&gt;DefaultRowSorter&lt;/code&gt; provides the ability to filter rows. Filtering is done by way of a &lt;code&gt;RowFilter&lt;/code&gt; that is specified using the &lt;code&gt;setRowFilter&lt;/code&gt; method. If no filter has been specified all rows are included.</source>
          <target state="translated">정렬 외에도 &lt;code&gt;DefaultRowSorter&lt;/code&gt; 는 행을 필터링하는 기능을 제공합니다. 필터링은 &lt;code&gt;setRowFilter&lt;/code&gt; 메소드를 사용하여 지정된 &lt;code&gt;RowFilter&lt;/code&gt; 를 통해 수행됩니다 . 필터가 지정되지 않은 경우 모든 행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="70d7ce344f3e3d1092fd258a0707f75b56a6ae69" translate="yes" xml:space="preserve">
          <source>In addition to supporting</source>
          <target state="translated">지원 이외에</target>
        </trans-unit>
        <trans-unit id="8c7f0496437b99dd6707c416172fdab3ba96b9f6" translate="yes" xml:space="preserve">
          <source>In addition to supporting access to variables under various access modes, a set of static methods, referred to as memory fence methods, is also provided for fine-grained control of memory ordering. The Java Language Specification permits other threads to observe operations as if they were executed in orders different than are apparent in program source code, subject to constraints arising, for example, from the use of locks, &lt;code&gt;volatile&lt;/code&gt; fields or VarHandles. The static methods, &lt;a href=&quot;#fullFence()&quot;&gt;&lt;code&gt;fullFence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#acquireFence()&quot;&gt;&lt;code&gt;acquireFence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#releaseFence()&quot;&gt;&lt;code&gt;releaseFence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#loadLoadFence()&quot;&gt;&lt;code&gt;loadLoadFence&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#storeStoreFence()&quot;&gt;&lt;code&gt;storeStoreFence&lt;/code&gt;&lt;/a&gt;, can also be used to impose constraints. Their specifications, as is the case for certain access modes, are phrased in terms of the lack of &quot;reorderings&quot; -- observable ordering effects that might otherwise occur if the fence was not present. More precise phrasing of the specification of access mode methods and memory fence methods may accompany future updates of the Java Language Specification.</source>
          <target state="translated">다양한 액세스 모드에서 변수에 대한 액세스를 지원하는 것 외에도 메모리 정렬 방법을 세밀하게 제어하기 위해 메모리 펜스 방법이라고하는 정적 방법 세트도 제공됩니다. Java 언어 사양은 다른 스레드가 잠금, &lt;code&gt;volatile&lt;/code&gt; 필드 또는 VarHandles 의 사용으로 인해 발생하는 제약 조건에 따라 프로그램 소스 코드에서 명백한 순서와 다른 순서로 실행 된 것처럼 작업을 관찰 할 수 있도록합니다 . 정적 메서드, &lt;a href=&quot;#fullFence()&quot;&gt; &lt;code&gt;fullFence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#acquireFence()&quot;&gt; &lt;code&gt;acquireFence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#releaseFence()&quot;&gt; &lt;code&gt;releaseFence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#loadLoadFence()&quot;&gt; &lt;code&gt;loadLoadFence&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#storeStoreFence()&quot;&gt; &lt;code&gt;storeStoreFence&lt;/code&gt; &lt;/a&gt;, 제약 조건을 적용하는 데 사용할 수도 있습니다. 특정 액세스 모드의 경우와 마찬가지로 이들의 사양은 &quot;재정렬&quot;(펜스가없는 경우 발생할 수있는 관찰 가능한 순서 효과)의 부족으로 표현됩니다. 접근 모드 방법 및 메모리 차단 방법의 사양에 대한보다 정확한 구문은 Java 언어 사양의 향후 업데이트와 함께 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1859092e8b0634ddf24a8ae6a3d0f5a50355a662" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;actionPerformed&lt;/code&gt; method defined by the &lt;code&gt;ActionListener&lt;/code&gt; interface, this interface allows the application to define, in a single place:</source>
          <target state="translated">또한받는 &lt;code&gt;actionPerformed&lt;/code&gt; 의해 정의 된 방법 &lt;code&gt;ActionListener&lt;/code&gt; 인터페이스,이 인터페이스는 응용 프로그램이 한 곳에서 정의 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="dc3b5860862c2beb6fcb5c470df7d2a1f92ba9de" translate="yes" xml:space="preserve">
          <source>In addition to the QName types, the XPath API supports the use of Class types through the &lt;code&gt;XPathExpression.evaluteExpression(...)&lt;/code&gt; or &lt;code&gt;XPath.evaluateExpression(...)&lt;/code&gt; methods. The XPath data types are mapped to Class types as follows:</source>
          <target state="translated">QName 유형 외에도 XPath API는 &lt;code&gt;XPathExpression.evaluteExpression(...)&lt;/code&gt; 또는 &lt;code&gt;XPath.evaluateExpression(...)&lt;/code&gt; 메소드를 통해 클래스 유형 사용을 지원합니다 . XPath 데이터 유형은 다음과 같이 클래스 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="1db36d86361d1b95831e09d49fbfd3fd4e22ef41" translate="yes" xml:space="preserve">
          <source>In addition to the above entry types, a catalog may define nextCatalog entries to add additional catalog entry files.</source>
          <target state="translated">위 항목 유형 외에도 카탈로그는 추가 카탈로그 항목 파일을 추가하기 위해 nextCatalog 항목을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c728a111c8455b1f773c9317d47ab5f17511c4" translate="yes" xml:space="preserve">
          <source>In addition to the abstract methods of &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;, subclasses of &lt;code&gt;CompositeView&lt;/code&gt; will need to override:</source>
          <target state="translated">&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 의 추상 메서드 외에도 &lt;code&gt;CompositeView&lt;/code&gt; 의 하위 클래스는 다음을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce31b60794642f2f5ac852c05072694e4e7f3686" translate="yes" xml:space="preserve">
          <source>In addition to the actions performed by the &lt;a href=&quot;#shutdown()&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method, this method invokes the &lt;a href=&quot;asynchronouschannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method on all open channels in the group. This method does not attempt to stop or interrupt threads that are executing completion handlers. The group terminates when all actively executing completion handlers have run to completion and all resources have been released. This method may be invoked at any time. If some other thread has already invoked it, then another invocation will block until the first invocation is complete, after which it will return without effect.</source>
          <target state="translated">&lt;a href=&quot;#shutdown()&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; 메서드에 의해 수행되는 작업 외에도이 메서드 는 그룹의 모든 열린 채널에서 &lt;a href=&quot;asynchronouschannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메서드를 호출합니다 . 이 메소드는 완료 핸들러를 실행중인 스레드를 중지하거나 인터럽트하지 않습니다. 활성 실행중인 모든 완료 핸들러가 완료되고 모든 리소스가 해제되면 그룹이 종료됩니다. 이 메서드는 언제든지 호출 할 수 있습니다. 다른 스레드가 이미 호출 한 경우 첫 번째 호출이 완료 될 때까지 다른 호출이 차단 된 후 효과없이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c50e8ec4869b062e7983b8307d360d622f72d425" translate="yes" xml:space="preserve">
          <source>In addition to the actions performed by the &lt;a href=&quot;asynchronouschannelgroup#shutdown--&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method, this method invokes the &lt;a href=&quot;asynchronouschannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method on all open channels in the group. This method does not attempt to stop or interrupt threads that are executing completion handlers. The group terminates when all actively executing completion handlers have run to completion and all resources have been released. This method may be invoked at any time. If some other thread has already invoked it, then another invocation will block until the first invocation is complete, after which it will return without effect.</source>
          <target state="translated">&lt;a href=&quot;asynchronouschannelgroup#shutdown--&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; 메소드에 의해 수행 된 조치 외에도이 메소드 는 그룹의 모든 열린 채널에서 &lt;a href=&quot;asynchronouschannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 . 이 메소드는 완료 핸들러를 실행중인 스레드를 중지하거나 중단하려고 시도하지 않습니다. 모든 활성 실행 완료 핸들러가 완료되어 실행되고 모든 자원이 해제되면 그룹이 종료됩니다. 이 메소드는 언제든지 호출 할 수 있습니다. 다른 스레드가 이미 호출 한 경우 첫 번째 호출이 완료 될 때까지 다른 호출이 차단되고 그 후에는 아무런 효과없이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db5536f8eff9177c520068c301225ff17b585888" translate="yes" xml:space="preserve">
          <source>In addition to the available calendar types returned by the &lt;a href=&quot;calendar#getAvailableCalendarTypes()&quot;&gt;&lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; and &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; as aliases of &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; can be used with this method.</source>
          <target state="translated">&lt;a href=&quot;calendar#getAvailableCalendarTypes()&quot;&gt; &lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 사용 가능한 달력 유형 외에도 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 의 별칭으로 &quot; &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 을이 메서드와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f37e8f3f69aa56facb878f44fda7bd5bd3c674" translate="yes" xml:space="preserve">
          <source>In addition to the available calendar types returned by the &lt;a href=&quot;calendar#getAvailableCalendarTypes--&quot;&gt;&lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; and &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; as aliases of &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; can be used with this method.</source>
          <target state="translated">&lt;a href=&quot;calendar#getAvailableCalendarTypes--&quot;&gt; &lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt; &lt;/a&gt; 메소드에서 리턴 한 사용 가능한 캘린더 유형 외에도 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 의 별명으로 &quot; &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 을이 메소드와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd12ac6606823d59289f6ff193c3f677e411d491" translate="yes" xml:space="preserve">
          <source>In addition to the callback methods, the &lt;a href=&quot;#toBundleName(java.lang.String,java.util.Locale)&quot;&gt;&lt;code&gt;toBundleName&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#toResourceName(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;toResourceName&lt;/code&gt;&lt;/a&gt; methods are defined primarily for convenience in implementing the callback methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be overridden to provide different conventions in the organization and packaging of localized resources. The &lt;code&gt;toResourceName&lt;/code&gt; method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class name separators.</source>
          <target state="translated">콜백 메서드 외에도 &lt;a href=&quot;#toBundleName(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;toBundleName&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#toResourceName(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;toResourceName&lt;/code&gt; &lt;/a&gt; 메서드는 주로 콜백 메서드 구현의 편의를 위해 정의됩니다. 그러나 &lt;code&gt;toBundleName&lt;/code&gt; 메서드는 지역화 된 리소스의 구성 및 패키징에서 다른 규칙을 제공하기 위해 재정의 될 수 있습니다. &lt;code&gt;toResourceName&lt;/code&gt; 의 방법은 &lt;code&gt;final&lt;/code&gt; 잘못된 자원 및 클래스 이름 분리기의 피하기 용도에 관한 것이다.</target>
        </trans-unit>
        <trans-unit id="e0a216003ee5984925855b502c7955bbfbb35501" translate="yes" xml:space="preserve">
          <source>In addition to the callback methods, the &lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;toBundleName&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;resourcebundle.control#toResourceName-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;toResourceName&lt;/code&gt;&lt;/a&gt; methods are defined primarily for convenience in implementing the callback methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be overridden to provide different conventions in the organization and packaging of localized resources. The &lt;code&gt;toResourceName&lt;/code&gt; method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class name separators.</source>
          <target state="translated">콜백 메소드 외에도 &lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;toBundleName&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;resourcebundle.control#toResourceName-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;toResourceName&lt;/code&gt; &lt;/a&gt; 메소드는 주로 콜백 메소드를 구현할 때 편의상 정의됩니다. 그러나 현지화 된 자원의 구성 및 패키징에 다른 규칙을 제공하기 위해 &lt;code&gt;toBundleName&lt;/code&gt; 메소드를 대체 할 수 있습니다. &lt;code&gt;toResourceName&lt;/code&gt; 의 방법은 &lt;code&gt;final&lt;/code&gt; 잘못된 자원 및 클래스 이름 분리기의 피하기 용도에 관한 것이다.</target>
        </trans-unit>
        <trans-unit id="491aa20d021002d74c407245ae5546393cb48e59" translate="yes" xml:space="preserve">
          <source>In addition to the date-time parameters, the &lt;a href=&quot;#setLocale(java.util.Locale)&quot;&gt;locale&lt;/a&gt;, &lt;a href=&quot;#setTimeZone(java.util.TimeZone)&quot;&gt;time zone&lt;/a&gt;, &lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt;week definition&lt;/a&gt;, and &lt;a href=&quot;#setLenient(boolean)&quot;&gt;leniency mode&lt;/a&gt; parameters can be set.</source>
          <target state="translated">날짜-시간 매개 변수 외에도 &lt;a href=&quot;#setLocale(java.util.Locale)&quot;&gt;locale&lt;/a&gt; , &lt;a href=&quot;#setTimeZone(java.util.TimeZone)&quot;&gt;time zone&lt;/a&gt; , &lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt;week definition&lt;/a&gt; 및 &lt;a href=&quot;#setLenient(boolean)&quot;&gt;leniency mode&lt;/a&gt; 매개 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc19ac6ac647d4ae06152ad3a7c4c90d5c62ae5" translate="yes" xml:space="preserve">
          <source>In addition to the date-time parameters, the &lt;a href=&quot;calendar.builder#setLocale-java.util.Locale-&quot;&gt;locale&lt;/a&gt;, &lt;a href=&quot;calendar.builder#setTimeZone-java.util.TimeZone-&quot;&gt;time zone&lt;/a&gt;, &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;week definition&lt;/a&gt;, and &lt;a href=&quot;calendar.builder#setLenient-boolean-&quot;&gt;leniency mode&lt;/a&gt; parameters can be set.</source>
          <target state="translated">날짜-시간 매개 변수 외에도 &lt;a href=&quot;calendar.builder#setLocale-java.util.Locale-&quot;&gt;로케일&lt;/a&gt; , &lt;a href=&quot;calendar.builder#setTimeZone-java.util.TimeZone-&quot;&gt;시간대&lt;/a&gt; , &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;주 정의&lt;/a&gt; 및 &lt;a href=&quot;calendar.builder#setLenient-boolean-&quot;&gt;leniency 모드&lt;/a&gt; 매개 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7614b1698980716dbcbacae739451584fa463381" translate="yes" xml:space="preserve">
          <source>In addition to the encoding, the audio format includes other properties that further specify the exact arrangement of the data. These include the number of channels, sample rate, sample size, byte order, frame rate, and frame size. Sounds may have different numbers of audio channels: one for mono, two for stereo. The sample rate measures how many &quot;snapshots&quot; (samples) of the sound pressure are taken per second, per channel. (If the sound is stereo rather than mono, two samples are actually measured at each instant of time: one for the left channel, and another for the right channel; however, the sample rate still measures the number per channel, so the rate is the same regardless of the number of channels. This is the standard use of the term.) The sample size indicates how many bits are used to store each snapshot; 8 and 16 are typical values. For 16-bit samples (or any other sample size larger than a byte), byte order is important; the bytes in each sample are arranged in either the &quot;little-endian&quot; or &quot;big-endian&quot; style. For encodings like PCM, a frame consists of the set of samples for all channels at a given point in time, and so the size of a frame (in bytes) is always equal to the size of a sample (in bytes) times the number of channels. However, with some other sorts of encodings a frame can contain a bundle of compressed data for a whole series of samples, as well as additional, non-sample data. For such encodings, the sample rate and sample size refer to the data after it is decoded into PCM, and so they are completely different from the frame rate and frame size.</source>
          <target state="translated">인코딩 외에도 오디오 형식에는 정확한 데이터 배열을 지정하는 다른 속성이 포함됩니다. 여기에는 채널 수, 샘플 속도, 샘플 크기, 바이트 순서, 프레임 속도 및 프레임 크기가 포함됩니다. 사운드는 다른 수의 오디오 채널을 가질 수 있습니다. 하나는 모노, 하나는 스테레오입니다. 샘플 속도는 채널당 초당 음압의 &quot;스냅 샷&quot;(샘플) 수를 측정합니다. (사운드가 모노가 아닌 스테레오 인 경우 두 개의 샘플이 실제로 각 순간에 측정됩니다. 하나는 왼쪽 채널에 대한 것이고 다른 하나는 오른쪽 채널에 대한 것입니다. 그러나 샘플 속도는 여전히 채널당 수를 측정하므로 속도는 채널 수에 관계없이 동일합니다.이 용어는 표준 사용입니다.) 샘플 크기는 각 스냅 샷을 저장하는 데 사용되는 비트 수를 나타냅니다.8과 16이 일반적인 값입니다. 16 비트 샘플 (또는 바이트보다 큰 다른 샘플 크기)의 경우 바이트 순서가 중요합니다. 각 샘플의 바이트는 &quot;little-endian&quot;또는 &quot;big-endian&quot;스타일로 배열됩니다. PCM과 같은 인코딩의 경우, 프레임은 주어진 시점에 모든 채널에 대한 샘플 세트로 구성되므로 프레임 크기 (바이트)는 항상 샘플 크기 (바이트)에 숫자를 곱한 값과 같습니다 채널. 그러나 다른 종류의 인코딩을 사용하면 프레임에 일련의 전체 샘플에 대한 압축 데이터 번들과 추가 비 샘플 데이터가 포함될 수 있습니다. 이러한 인코딩의 경우, 샘플 속도 및 샘플 크기는 PCM으로 디코딩 된 후의 데이터를 참조하므로 프레임 속도 및 프레임 크기와 완전히 다릅니다.16 비트 샘플 (또는 바이트보다 큰 다른 샘플 크기)의 경우 바이트 순서가 중요합니다. 각 샘플의 바이트는 &quot;little-endian&quot;또는 &quot;big-endian&quot;스타일로 배열됩니다. PCM과 같은 인코딩의 경우, 프레임은 주어진 시점에 모든 채널에 대한 샘플 세트로 구성되므로 프레임 크기 (바이트)는 항상 샘플 크기 (바이트)에 숫자를 곱한 값과 같습니다 채널. 그러나 다른 종류의 인코딩을 사용하면 프레임에 일련의 전체 샘플에 대한 압축 데이터 번들과 추가 비 샘플 데이터가 포함될 수 있습니다. 이러한 인코딩의 경우, 샘플 속도 및 샘플 크기는 PCM으로 디코딩 된 후의 데이터를 참조하므로 프레임 속도 및 프레임 크기와 완전히 다릅니다.16 비트 샘플 (또는 바이트보다 큰 다른 샘플 크기)의 경우 바이트 순서가 중요합니다. 각 샘플의 바이트는 &quot;little-endian&quot;또는 &quot;big-endian&quot;스타일로 배열됩니다. PCM과 같은 인코딩의 경우, 프레임은 주어진 시점에 모든 채널에 대한 샘플 세트로 구성되므로 프레임 크기 (바이트)는 항상 샘플 크기 (바이트)에 숫자를 곱한 값과 같습니다 채널. 그러나 다른 종류의 인코딩을 사용하면 프레임에 일련의 전체 샘플에 대한 압축 데이터 번들과 추가 비 샘플 데이터가 포함될 수 있습니다. 이러한 인코딩의 경우, 샘플 속도 및 샘플 크기는 PCM으로 디코딩 된 후의 데이터를 참조하므로 프레임 속도 및 프레임 크기와 완전히 다릅니다.little-endian &quot;또는&quot;big-endian &quot;스타일. PCM과 같은 인코딩의 경우 프레임은 주어진 시점에 모든 채널의 샘플 세트로 구성되므로 프레임 크기 (바이트)는 항상 같습니다. 샘플 크기 (바이트)에 채널 수를 곱한 값이 있지만 다른 종류의 인코딩을 사용하면 프레임에 일련의 전체 샘플에 대한 압축 데이터 번들과 샘플이 아닌 추가 데이터가 포함될 수 있습니다. 이러한 인코딩, 샘플 레이트 및 샘플 크기는 PCM으로 디코딩 된 후의 데이터를 참조하므로 프레임 레이트 및 프레임 크기와 완전히 다릅니다.little-endian &quot;또는&quot;big-endian &quot;스타일. PCM과 같은 인코딩의 경우 프레임은 주어진 시점에 모든 채널의 샘플 세트로 구성되므로 프레임 크기 (바이트)는 항상 같습니다. 샘플 크기 (바이트)에 채널 수를 곱한 값이 있지만 다른 종류의 인코딩을 사용하면 프레임에 일련의 전체 샘플에 대한 압축 데이터 번들과 샘플이 아닌 추가 데이터가 포함될 수 있습니다. 이러한 인코딩, 샘플 레이트 및 샘플 크기는 PCM으로 디코딩 된 후의 데이터를 참조하므로 프레임 레이트 및 프레임 크기와 완전히 다릅니다.따라서 프레임 크기 (바이트)는 항상 샘플 수 (바이트)에 채널 수를 곱한 값과 같습니다. 그러나 다른 종류의 인코딩을 사용하면 프레임에 일련의 전체 샘플에 대한 압축 데이터 번들과 추가 비 샘플 데이터가 포함될 수 있습니다. 이러한 인코딩의 경우, 샘플 속도 및 샘플 크기는 PCM으로 디코딩 된 후의 데이터를 참조하므로 프레임 속도 및 프레임 크기와 완전히 다릅니다.따라서 프레임 크기 (바이트)는 항상 샘플 수 (바이트)에 채널 수를 곱한 값과 같습니다. 그러나 다른 종류의 인코딩을 사용하면 프레임에 일련의 전체 샘플에 대한 압축 데이터 번들과 추가 비 샘플 데이터가 포함될 수 있습니다. 이러한 인코딩의 경우, 샘플 속도 및 샘플 크기는 PCM으로 디코딩 된 후의 데이터를 참조하므로 프레임 속도 및 프레임 크기와 완전히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d6a83c2e73788cf89b876bfa744823e9380a8ac0" translate="yes" xml:space="preserve">
          <source>In addition to the familiar read, write, and close operations of byte channels, this class defines the following file-specific operations:</source>
          <target state="translated">이 클래스는 익숙한 바이트 채널의 읽기, 쓰기 및 닫기 작업 외에도 다음과 같은 파일 별 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4f1190da5af20b63b0a7ea53b9dcbc33953d6769" translate="yes" xml:space="preserve">
          <source>In addition to the format, formatters can be created with desired Locale, Chronology, ZoneId, and DecimalStyle.</source>
          <target state="translated">형식 외에도 원하는 로캘, 연표, ZoneId 및 DecimalStyle을 사용하여 포맷터를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e059e38a779b1f301213b52de153cb2600a26b3" translate="yes" xml:space="preserve">
          <source>In addition to the method area, a Java virtual machine implementation may require memory for internal processing or optimization which also belongs to non-heap memory. For example, the JIT compiler requires memory for storing the native machine code translated from the Java virtual machine code for high performance.</source>
          <target state="translated">메소드 영역 외에도 Java 가상 머신 구현에는 힙이 아닌 메모리에 속하는 내부 처리 또는 최적화를위한 메모리가 필요할 수 있습니다. 예를 들어, JIT 컴파일러는 고성능을 위해 Java 가상 머신 코드에서 변환 된 기본 머신 코드를 저장하기위한 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ee283b61b3d9459d225d145542e24d6b57b4d6d2" translate="yes" xml:space="preserve">
          <source>In addition to the methods defined by this class, a file store may support one or more &lt;a href=&quot;attribute/filestoreattributeview&quot;&gt;&lt;code&gt;FileStoreAttributeView&lt;/code&gt;&lt;/a&gt; classes that provide a read-only or updatable view of a set of file store attributes.</source>
          <target state="translated">이 클래스에서 정의한 메소드 외에도 파일 저장소는 파일 저장소 속성 세트의 읽기 전용 또는 업데이트 가능한보기를 제공하는 하나 이상의 &lt;a href=&quot;attribute/filestoreattributeview&quot;&gt; &lt;code&gt;FileStoreAttributeView&lt;/code&gt; &lt;/a&gt; 클래스를 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2986e636ae207892e9dac39e23fe9879168cb86f" translate="yes" xml:space="preserve">
          <source>In addition to the methods provided by Document and StyledDocument for mutating an HTMLDocument, HTMLDocument provides a number of convenience methods. The following methods can be used to insert HTML content into an existing document.</source>
          <target state="translated">HTMLDocument를 변경하기 위해 Document 및 StyledDocument에서 제공하는 메서드 외에도 HTMLDocument는 여러 가지 편리한 메서드를 제공합니다. 다음 방법을 사용하여 기존 문서에 HTML 내용을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432330f85a6a85defb1d0daea6e69ee9342c7288" translate="yes" xml:space="preserve">
          <source>In addition to the network-oriented channels described in &lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel()&quot;&gt;&lt;code&gt;inheritedChannel&lt;/code&gt;&lt;/a&gt;, this method may return other kinds of channels in the future.</source>
          <target state="translated">&lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel()&quot;&gt; &lt;code&gt;inheritedChannel&lt;/code&gt; 에&lt;/a&gt; 설명 된 네트워크 지향 채널 외에도이 메서드는 향후 다른 종류의 채널을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b02ab5a714cd80e6567da7665467edf7fd5e8ed" translate="yes" xml:space="preserve">
          <source>In addition to the network-oriented channels described in &lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel--&quot;&gt;&lt;code&gt;inheritedChannel&lt;/code&gt;&lt;/a&gt;, this method may return other kinds of channels in the future.</source>
          <target state="translated">&lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel--&quot;&gt; &lt;code&gt;inheritedChannel&lt;/code&gt; 에&lt;/a&gt; 설명 된 네트워크 지향 채널 외에도이 메소드는 나중에 다른 종류의 채널을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33bc2b0c620d7bc4fb0799e179286bb4b725634" translate="yes" xml:space="preserve">
          <source>In addition to the network-oriented channels described, this method may return other kinds of channels in the future.</source>
          <target state="translated">설명 된 네트워크 지향 채널 외에도이 방법은 향후 다른 종류의 채널을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a905ba3369b4a4f562d01a3f87216887f67f158a" translate="yes" xml:space="preserve">
          <source>In addition to the parameters described here, other GCM inputs/output (Additional Authenticated Data (AAD), Keys, block ciphers, plain/ciphertext and authentication tags) are handled in the &lt;code&gt;
 Cipher&lt;/code&gt; class.</source>
          <target state="translated">여기에 설명 된 매개 변수 외에도 다른 GCM 입력 / 출력 (AAD (Additional Authenticated Data), 키, 블록 암호, 일반 / 암호문 및 인증 태그)이 &lt;code&gt; Cipher&lt;/code&gt; 클래스 에서 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ed6b95a08d3c44af62e52f25de87e487d831331" translate="yes" xml:space="preserve">
          <source>In addition to the parameters described here, other GCM inputs/output (Additional Authenticated Data (AAD), Keys, block ciphers, plain/ciphertext and authentication tags) are handled in the &lt;code&gt;Cipher&lt;/code&gt; class.</source>
          <target state="translated">여기에 설명 된 매개 변수 외에도 다른 GCM 입력 / 출력 (AAD (Additional Authenticated Data), 키, 블록 암호, 일반 / 암호 텍스트 및 인증 태그)이 &lt;code&gt;Cipher&lt;/code&gt; 클래스 에서 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="2068645f319b6e731f1184b3eeafec498fde158b" translate="yes" xml:space="preserve">
          <source>In addition to the parameters recognized by the &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; interface defined in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt;] , the &lt;code&gt;DOMConfiguration&lt;/code&gt; objects for &lt;code&gt;LSSerializer&lt;/code&gt; adds, or modifies, the following parameters:</source>
          <target state="translated">[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt; ]에 정의 된 &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; 인터페이스에서 인식하는 매개 변수 외에도 &lt;code&gt;LSSerializer&lt;/code&gt; 용 &lt;code&gt;DOMConfiguration&lt;/code&gt; 객체 는 다음 매개 변수를 추가하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="48faa16800a54ef7adf79ec21201779ba48c231e" translate="yes" xml:space="preserve">
          <source>In addition to the parameters recognized in on the &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; interface defined in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt;] , the &lt;code&gt;DOMConfiguration&lt;/code&gt; objects for &lt;code&gt;LSParser&lt;/code&gt; add or modify the following parameters:</source>
          <target state="translated">[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt; ]에 정의 된 &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; 인터페이스 에서 인식되는 매개 변수 외에도 &lt;code&gt;LSParser&lt;/code&gt; 용 &lt;code&gt;DOMConfiguration&lt;/code&gt; 객체 는 다음 매개 변수를 추가하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="6f624142e4495c5af474cb0a78db2e72fbaa8b70" translate="yes" xml:space="preserve">
          <source>In addition to the predefined implementations in &lt;a href=&quot;collectors&quot;&gt;&lt;code&gt;Collectors&lt;/code&gt;&lt;/a&gt;, the static factory methods &lt;a href=&quot;#of(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BinaryOperator,java.util.stream.Collector.Characteristics...)&quot;&gt;&lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt;&lt;/a&gt; can be used to construct collectors. For example, you could create a collector that accumulates widgets into a &lt;code&gt;TreeSet&lt;/code&gt; with:</source>
          <target state="translated">&lt;a href=&quot;collectors&quot;&gt; &lt;code&gt;Collectors&lt;/code&gt; &lt;/a&gt; 의 사전 정의 된 구현 외에도 &lt;a href=&quot;#of(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BinaryOperator,java.util.stream.Collector.Characteristics...)&quot;&gt; &lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt; &lt;/a&gt; 의 정적 팩토리 메서드 를 사용하여 수집기를 구성 할 수 있습니다. 예를 들어 다음을 사용하여 위젯을 &lt;code&gt;TreeSet&lt;/code&gt; 에 누적하는 수집기를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df0afba264acde97691ac7208acbd4a41b35b800" translate="yes" xml:space="preserve">
          <source>In addition to the predefined implementations in &lt;a href=&quot;collectors&quot;&gt;&lt;code&gt;Collectors&lt;/code&gt;&lt;/a&gt;, the static factory methods &lt;a href=&quot;collector#of-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BinaryOperator-java.util.stream.Collector.Characteristics...-&quot;&gt;&lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt;&lt;/a&gt; can be used to construct collectors. For example, you could create a collector that accumulates widgets into a &lt;code&gt;TreeSet&lt;/code&gt; with:</source>
          <target state="translated">&lt;a href=&quot;collectors&quot;&gt; &lt;code&gt;Collectors&lt;/code&gt; &lt;/a&gt; 에서 사전 정의 된 구현 외에도 &lt;a href=&quot;collector#of-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BinaryOperator-java.util.stream.Collector.Characteristics...-&quot;&gt; &lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt; &lt;/a&gt; 의 정적 팩토리 메소드 를 사용하여 콜렉터를 구성 할 수 있습니다. 예를 들어, 다음을 사용하여 위젯을 &lt;code&gt;TreeSet&lt;/code&gt; 에 누적하는 콜렉터를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adf89d4fe796fb988f7407950dd9eefb826761d9" translate="yes" xml:space="preserve">
          <source>In addition to the properties of the super class, the &lt;code&gt;Expression&lt;/code&gt; object provides a &lt;em&gt;value&lt;/em&gt; which is the object returned when this expression is evaluated. The return value is typically not provided by the caller and is instead computed by dynamically finding the method and invoking it when the first call to &lt;code&gt;getValue&lt;/code&gt; is made.</source>
          <target state="translated">수퍼 클래스의 속성 외에도 &lt;code&gt;Expression&lt;/code&gt; 객체는 이 표현식이 평가 될 때 반환되는 객체 인 &lt;em&gt;값&lt;/em&gt; 을 제공합니다 . 리턴 값은 일반적으로 호출자가 제공하지 않으며 대신 &lt;code&gt;getValue&lt;/code&gt; 에 대한 첫 번째 호출이 수행 될 때 메소드를 동적으로 찾아 호출하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="d2394c9520c75ba71dccb27ec850e0d98f0290f5" translate="yes" xml:space="preserve">
          <source>In addition to the restrictions on characters spelt out above, no part of an ObjectName may contain a newline character (&lt;code&gt;'\n'&lt;/code&gt;), whether the domain, a key, or a value, whether quoted or unquoted. The newline character can be represented in a quoted value with the sequence &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">위에서 언급 한 문자에 대한 제한 외에도 ObjectName의 어느 부분도 도메인, 키 또는 값, 인용 또는 인용 부호와 상관없이 개행 문자 ( &lt;code&gt;'\n'&lt;/code&gt; )를 포함 할 수 없습니다 . 개행 문자는 &lt;code&gt;\n&lt;/code&gt; 시퀀스를 사용하여 따옴표로 묶은 값으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c33e9e8d1cb86388922d67f15e1b30f1c2d89d24" translate="yes" xml:space="preserve">
          <source>In addition to the scroll bars and viewport, a &lt;code&gt;JScrollPane&lt;/code&gt; can have a column header and a row header. Each of these is a &lt;code&gt;JViewport&lt;/code&gt; object that you specify with &lt;code&gt;setRowHeaderView&lt;/code&gt;, and &lt;code&gt;setColumnHeaderView&lt;/code&gt;. The column header viewport automatically scrolls left and right, tracking the left-right scrolling of the main viewport. (It never scrolls vertically, however.) The row header acts in a similar fashion.</source>
          <target state="translated">스크롤 막대 및 뷰포트 외에도 &lt;code&gt;JScrollPane&lt;/code&gt; 에는 열 머리글과 행 머리글이있을 수 있습니다. 이들 각각은 &lt;code&gt;setRowHeaderView&lt;/code&gt; 및 &lt;code&gt;setColumnHeaderView&lt;/code&gt; 로 지정 하는 &lt;code&gt;JViewport&lt;/code&gt; 객체입니다 . 열 머리글 뷰포트는 자동으로 왼쪽과 오른쪽으로 스크롤하여 주 뷰포트의 왼쪽에서 오른쪽 스크롤을 추적합니다. (그러나 수직으로 스크롤되지는 않습니다.) 행 머리글은 비슷한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b2c1ff8172f1e7aba63f37e75d386a7d225ec94c" translate="yes" xml:space="preserve">
          <source>In addition to the standard session attributes, SSL sessions expose these read-only attributes:</source>
          <target state="translated">표준 세션 속성 외에도 SSL 세션은 다음과 같은 읽기 전용 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9f4f266b17adc8e2aeb86a93d5446474a986f525" translate="yes" xml:space="preserve">
          <source>In addition to the standard system properties, the system properties may include the following keys:</source>
          <target state="translated">표준 시스템 속성 외에도 시스템 속성에는 다음 키가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83938c315c82af2806ebd155f43016814eda7fb4" translate="yes" xml:space="preserve">
          <source>In addition to the textual enum name, each day-of-week has an &lt;code&gt;int&lt;/code&gt; value. The &lt;code&gt;int&lt;/code&gt; value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday). It is recommended that applications use the enum rather than the &lt;code&gt;int&lt;/code&gt; value to ensure code clarity.</source>
          <target state="translated">텍스트 열거 형 이름 외에도 각 요일에는 &lt;code&gt;int&lt;/code&gt; 값이 있습니다. &lt;code&gt;int&lt;/code&gt; 값은 7 일 (일요일)에 대한 ISO-8601 표준, 1 일 (월)에 따른다. 응용 프로그램은 코드 선명도를 보장하기 위해 &lt;code&gt;int&lt;/code&gt; 값 대신 열거 형을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2d4d3851f8f7049f215ed834737db941515f6412" translate="yes" xml:space="preserve">
          <source>In addition to the textual enum name, each month-of-year has an &lt;code&gt;int&lt;/code&gt; value. The &lt;code&gt;int&lt;/code&gt; value follows normal usage and the ISO-8601 standard, from 1 (January) to 12 (December). It is recommended that applications use the enum rather than the &lt;code&gt;int&lt;/code&gt; value to ensure code clarity.</source>
          <target state="translated">텍스트 열거 형 이름 외에도 각 월의 값 은 &lt;code&gt;int&lt;/code&gt; 입니다. &lt;code&gt;int&lt;/code&gt; 값은 1 (년 1 월)에서 12 (12 월)에 정상적인 사용 및 ISO-8601 표준을 따른다. 응용 프로그램은 코드 선명도를 보장하기 위해 &lt;code&gt;int&lt;/code&gt; 값 대신 열거 형을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="dbbe182566bca48d0fbeb7cd780b3e1c5f49a252" translate="yes" xml:space="preserve">
          <source>In addition to the usage restrictions imposed by its &lt;a href=&quot;annotation/target&quot;&gt;&lt;code&gt;@Target&lt;/code&gt;&lt;/a&gt; meta-annotation, compilers are required to implement additional usage restrictions on this annotation type; it is a compile-time error if a method or constructor declaration is annotated with a &lt;code&gt;@SafeVarargs&lt;/code&gt; annotation, and either:</source>
          <target state="translated">&lt;a href=&quot;annotation/target&quot;&gt; &lt;code&gt;@Target&lt;/code&gt; &lt;/a&gt; 메타 주석 에 의해 부과 된 사용 제한 외에도 컴파일러는이 주석 유형에 대한 추가 사용 제한을 구현해야합니다. 메소드 또는 생성자 선언에 &lt;code&gt;@SafeVarargs&lt;/code&gt; 주석 이 주석 처리 된 경우 컴파일 타임 오류 이며 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="48906b2213eda76c1ef9cb3120b0f8752c37d2ea" translate="yes" xml:space="preserve">
          <source>In addition to these and related methods for directly manipulating status and results, CompletableFuture implements interface &lt;a href=&quot;completionstage&quot;&gt;&lt;code&gt;CompletionStage&lt;/code&gt;&lt;/a&gt; with the following policies:</source>
          <target state="translated">상태 및 결과를 직접 조작하기위한 이러한 방법 및 관련 방법 외에도 CompletableFuture 는 다음 정책을 사용하여 &lt;a href=&quot;completionstage&quot;&gt; &lt;code&gt;CompletionStage&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="53919e02325aec34ba4ab39d138ab42852e587c0" translate="yes" xml:space="preserve">
          <source>In addition to using a delegation model, this persistence scheme differs from traditional serialization schemes in requiring an analog of the &lt;code&gt;writeObject&lt;/code&gt; method without a corresponding &lt;code&gt;readObject&lt;/code&gt; method. The &lt;code&gt;writeObject&lt;/code&gt; analog encodes each instance in terms of its public API and there is no need to define a &lt;code&gt;readObject&lt;/code&gt; analog since the procedure for reading the serialized form is defined by the semantics of method invocation as laid out in the Java Language Specification. Breaking the dependency between &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; implementations, which may change from version to version, is the key factor in making the archives produced by this technique immune to changes in the private implementations of the classes to which they refer.</source>
          <target state="translated">위임 모델을 사용하는 것 외에도,이 지속성 체계는 해당하는 &lt;code&gt;readObject&lt;/code&gt; 메소드 없이 &lt;code&gt;writeObject&lt;/code&gt; 메소드 의 아날로그를 요구한다는 점에서 기존 직렬화 체계와 다릅니다 . &lt;code&gt;writeObject&lt;/code&gt; 아날로그는 공개 API의 측면에서 각 인스턴스를 인코딩하고 정의 할 필요가 없습니다 &lt;code&gt;readObject&lt;/code&gt; 직렬화 된 형식을 읽기위한 절차 이후 아날로그 Java 언어 사양에 규정되어있는대로 메소드 호출의 의미에 의해 정의된다. 간의 종속성 속보 &lt;code&gt;writeObject&lt;/code&gt; 및 &lt;code&gt;readObject&lt;/code&gt; 버전마다 변경 될 수있는 구현은이 기술에 의해 생성 된 아카이브가 참조하는 클래스의 개인 구현의 변경에 영향을받지 않도록하는 핵심 요소입니다.</target>
        </trans-unit>
        <trans-unit id="af9d69a85de071c5503c968b6878570e7a051f81" translate="yes" xml:space="preserve">
          <source>In addition,</source>
          <target state="translated">게다가,</target>
        </trans-unit>
        <trans-unit id="d13d4f13ec02cd9aaa9c26800becfd83ad1806e2" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;BorderLayout&lt;/code&gt; supports the relative positioning constants, &lt;code&gt;PAGE_START&lt;/code&gt;, &lt;code&gt;PAGE_END&lt;/code&gt;, &lt;code&gt;LINE_START&lt;/code&gt;, and &lt;code&gt;LINE_END&lt;/code&gt;. In a container whose &lt;code&gt;ComponentOrientation&lt;/code&gt; is set to &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt;, these constants map to &lt;code&gt;NORTH&lt;/code&gt;, &lt;code&gt;SOUTH&lt;/code&gt;, &lt;code&gt;WEST&lt;/code&gt;, and &lt;code&gt;EAST&lt;/code&gt;, respectively.</source>
          <target state="translated">또한 &lt;code&gt;BorderLayout&lt;/code&gt; 은 상대 위치 지정 상수 인 &lt;code&gt;PAGE_START&lt;/code&gt; , &lt;code&gt;PAGE_END&lt;/code&gt; , &lt;code&gt;LINE_START&lt;/code&gt; 및 &lt;code&gt;LINE_END&lt;/code&gt; 를 지원 합니다. 그 용기에 &lt;code&gt;ComponentOrientation&lt;/code&gt; 가 설정된다 &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt; , 이러한 정수 매핑 &lt;code&gt;NORTH&lt;/code&gt; , &lt;code&gt;SOUTH&lt;/code&gt; , &lt;code&gt;WEST&lt;/code&gt; , 및 &lt;code&gt;EAST&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="f1f23c6ebcae32c016f175cd630762e9b2b7d49f" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;Runnable&lt;/code&gt; provides the means for a class to be active while not subclassing &lt;code&gt;Thread&lt;/code&gt;. A class that implements &lt;code&gt;Runnable&lt;/code&gt; can run without subclassing &lt;code&gt;Thread&lt;/code&gt; by instantiating a &lt;code&gt;Thread&lt;/code&gt; instance and passing itself in as the target. In most cases, the &lt;code&gt;Runnable&lt;/code&gt; interface should be used if you are only planning to override the &lt;code&gt;run()&lt;/code&gt; method and no other &lt;code&gt;Thread&lt;/code&gt; methods. This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.</source>
          <target state="translated">또한 &lt;code&gt;Runnable&lt;/code&gt; 은 &lt;code&gt;Thread&lt;/code&gt; 를 서브 클래 싱하지 않고 클래스가 활성화 될 수있는 수단을 제공합니다 . 구현하는 클래스 &lt;code&gt;Runnable&lt;/code&gt; 서브 클래스없이 실행할 수있는 &lt;code&gt;Thread&lt;/code&gt; 인스턴스화하여 &lt;code&gt;Thread&lt;/code&gt; 인스턴스를 대상으로 자체를 전달합니다. 대부분의 경우 &lt;code&gt;run()&lt;/code&gt; 메서드 만 재정의하고 다른 &lt;code&gt;Thread&lt;/code&gt; 메서드 는 무시하려는 경우 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스를 사용해야합니다 . 프로그래머가 클래스의 기본 동작을 수정하거나 향상시키려는 경우가 아니라면 클래스를 서브 클래스 화해서는 안되므로 이것은 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d0ffa912abbac66bc23c7cc4eb525a47987acde5" translate="yes" xml:space="preserve">
          <source>In addition, BCP 47 imposes syntax restrictions that are not imposed by Locale's constructors. This means that conversions between some Locales and BCP 47 language tags cannot be made without losing information. Thus &lt;code&gt;toLanguageTag&lt;/code&gt; cannot represent the state of locales whose language, country, or variant do not conform to BCP 47.</source>
          <target state="translated">또한 BCP 47은 로캘의 생성자가 적용하지 않는 구문 제한을 적용합니다. 즉, 일부 로케일과 BCP 47 언어 태그 간의 변환은 정보 손실없이 이루어질 수 없습니다. 따라서 &lt;code&gt;toLanguageTag&lt;/code&gt; 는 언어, 국가 또는 변형이 BCP 47을 준수하지 않는 로캘의 상태를 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="90c28b724a8b29cd571cc3e38dd5717b9002649b" translate="yes" xml:space="preserve">
          <source>In addition, NimbusStyle handles ColorTypes slightly differently from Synth.</source>
          <target state="translated">또한 NimbusStyle은 Synth와 약간 다르게 ColorType을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="579421e1e85ce32e6e5ea22308534b8f6511e547" translate="yes" xml:space="preserve">
          <source>In addition, a layer cannot be created if the configuration contains a module named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;, a configuration contains a module with a package named &quot;&lt;code&gt;java&lt;/code&gt;&quot; or a package name starting with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, or the function to map a module name to a class loader returns &lt;code&gt;null&lt;/code&gt; or the &lt;a href=&quot;classloader#getPlatformClassLoader()&quot;&gt;platform class loader&lt;/a&gt;.</source>
          <target state="translated">또한 구성에 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 라는 모듈이 포함되어 있거나 구성에 &quot; &lt;code&gt;java&lt;/code&gt; &quot; 라는 패키지가있는 모듈이 포함되어 있거나 &quot; &lt;code&gt;java.&lt;/code&gt; &quot;로 시작하는 패키지 이름이 포함 된 경우 계층을 생성 할 수 없습니다 . 클래스 로더에 대한 모듈 이름은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;a href=&quot;classloader#getPlatformClassLoader()&quot;&gt;플랫폼 클래스 로더를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6bbe447b352cd3c67e1d9564f1a4f7893ccf3bb5" translate="yes" xml:space="preserve">
          <source>In addition, a layer cannot be created if the configuration contains a module named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;, or a module contains a package named &quot;&lt;code&gt;java&lt;/code&gt;&quot; or a package with a name starting with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;.</source>
          <target state="translated">또한 구성에 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 라는 모듈이 포함되어 있거나 모듈에 &quot; &lt;code&gt;java&lt;/code&gt; &quot; 라는 이름 의 패키지 또는 &quot; &lt;code&gt;java.&lt;/code&gt; &quot;로 시작하는 이름의 패키지가 포함 된 경우 계층을 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0dca754d6c2d6b8518fc03f50d1c276e3093b30c" translate="yes" xml:space="preserve">
          <source>In addition, an application can use the &lt;code&gt;SyncProvider&lt;/code&gt; object returned by this method to call methods that return information about the &lt;code&gt;SyncProvider&lt;/code&gt; object, including information about the vendor, version, provider identification, synchronization grade, and locks it currently has set.</source>
          <target state="translated">또한 응용 프로그램은 이 메서드에서 반환 된 &lt;code&gt;SyncProvider&lt;/code&gt; 개체를 사용하여 공급 업체, 버전, 공급자 식별, 동기화 등급 및 현재 설정된 잠금에 대한 정보를 포함 하여 &lt;code&gt;SyncProvider&lt;/code&gt; 개체 에 대한 정보를 반환하는 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe92cfe39db7917857638c730c6e8a9d72af5f4" translate="yes" xml:space="preserve">
          <source>In addition, an application must specify constraints on the target certificate that the &lt;code&gt;CertPathBuilder&lt;/code&gt; will attempt to build a path to. The constraints are specified as a &lt;code&gt;CertSelector&lt;/code&gt; object. These constraints should provide the &lt;code&gt;CertPathBuilder&lt;/code&gt; with enough search criteria to find the target certificate. Minimal criteria for an &lt;code&gt;X509Certificate&lt;/code&gt; usually include the subject name and/or one or more subject alternative names. If enough criteria is not specified, the &lt;code&gt;CertPathBuilder&lt;/code&gt; may throw a &lt;code&gt;CertPathBuilderException&lt;/code&gt;.</source>
          <target state="translated">또한 응용 프로그램은 &lt;code&gt;CertPathBuilder&lt;/code&gt; 가 경로를 만들려고 하는 대상 인증서에 대한 제약 조건을 지정해야합니다 . 제약은 &lt;code&gt;CertSelector&lt;/code&gt; 객체 로서 지정됩니다 . 이러한 제약 조건은 &lt;code&gt;CertPathBuilder&lt;/code&gt; 에 대상 인증서를 찾을 수있는 충분한 검색 기준을 제공해야합니다 . &lt;code&gt;X509Certificate&lt;/code&gt; 의 최소 기준 에는 일반적으로 주체 이름 및 / 또는 하나 이상의 주체 대체 이름이 포함됩니다. 충분한 기준이 지정되지 않는 경우, &lt;code&gt;CertPathBuilder&lt;/code&gt; 에이 던져 수 &lt;code&gt;CertPathBuilderException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e610984b972d7e5beb58e119cffbd2ab22c70f" translate="yes" xml:space="preserve">
          <source>In addition, an instance has four flags. These flags indicate:</source>
          <target state="translated">또한 인스턴스에는 4 개의 플래그가 있습니다. 이 플래그는 다음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="870e411531c039af2dbdb3bb6e5d628c5975e9bb" translate="yes" xml:space="preserve">
          <source>In addition, an offset mechanism enables particular counting intervals to be detected. If the offset value is not zero, whenever the threshold is triggered by the counter value reaching a comparison level, that comparison level is incremented by the offset value. This is regarded as taking place instantaneously, that is, before the count is incremented. Thus, for each level, the threshold triggers an event notification every time the count increases by an interval equal to the offset value.</source>
          <target state="translated">또한 오프셋 메커니즘을 통해 특정 카운팅 간격을 감지 할 수 있습니다. 오프셋 값이 0이 아닌 경우 카운터 값이 비교 수준에 도달하여 임계 값이 트리거 될 때마다 해당 비교 수준이 오프셋 값만큼 증가합니다. 이는 즉시, 즉 카운트가 증가하기 전에 발생하는 것으로 간주됩니다. 따라서 각 수준에 대해 임계 값은 카운트가 오프셋 값과 동일한 간격으로 증가 할 때마다 이벤트 알림을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="a450ba34174b50c1a21d59970e5437dc6cb80f12" translate="yes" xml:space="preserve">
          <source>In addition, any &lt;code&gt;RowSet&lt;/code&gt; object created by this method will have the same properties as this &lt;code&gt;CachedRowSet&lt;/code&gt; object. For example, if this &lt;code&gt;CachedRowSet&lt;/code&gt; object is read-only, all of its duplicates will also be read-only. If it is changed to be updatable, the duplicates also become updatable.</source>
          <target state="translated">또한 이 메서드에 의해 생성 된 &lt;code&gt;RowSet&lt;/code&gt; 객체는이 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체 와 동일한 속성을 갖습니다 . 예를 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체가 읽기 전용이면 모든 중복 개체도 읽기 전용이됩니다. 업데이트 가능하도록 변경되면 중복도 업데이트 가능하게됩니다.</target>
        </trans-unit>
        <trans-unit id="53b8d630d402819b1f760ea377f44b6a16712937" translate="yes" xml:space="preserve">
          <source>In addition, any of the elements may be decorated by padding, either with spaces or any other character.</source>
          <target state="translated">또한, 임의의 요소는 공백 또는 임의의 다른 문자로 패딩에 의해 장식 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5b0ddda2d0f82cf4aed49fad8ad8b055e9a723d9" translate="yes" xml:space="preserve">
          <source>In addition, every character in a font has an</source>
          <target state="translated">또한 글꼴의 모든 문자에는</target>
        </trans-unit>
        <trans-unit id="fe6d4ce281cc41c2d663795cad62610decb0511e" translate="yes" xml:space="preserve">
          <source>In addition, if a &lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt; attribute of &lt;a href=&quot;finishings#STAPLE&quot;&gt;&lt;code&gt;STAPLE&lt;/code&gt;&lt;/a&gt; is specified, then:</source>
          <target state="translated">또한 &lt;a href=&quot;finishings#STAPLE&quot;&gt; &lt;code&gt;STAPLE&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; 속성 이 지정되면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1fa3f127cf7a63d846e423fccda6af2e43a26b4b" translate="yes" xml:space="preserve">
          <source>In addition, if a &lt;code&gt;Map&lt;/code&gt; object is passed to one of the constructors or to the method &lt;code&gt;getAttributes&lt;/code&gt;, the structured type is custom mapped according to the mapping specified in the &lt;code&gt;Map&lt;/code&gt; object.</source>
          <target state="translated">또한 &lt;code&gt;Map&lt;/code&gt; 객체가 생성자 중 하나 또는 &lt;code&gt;getAttributes&lt;/code&gt; 메서드에 전달되는 경우 구조화 된 유형은 &lt;code&gt;Map&lt;/code&gt; 객체에 지정된 매핑에 따라 사용자 지정 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c71d449e4a597019a72691ecc234388e0f7fdd8" translate="yes" xml:space="preserve">
          <source>In addition, if the class loader is not the bootstrap or &lt;a href=&quot;../lang/classloader#getPlatformClassLoader()&quot;&gt;platform class loader&lt;/a&gt;, then service providers may be located in the named modules of other class loaders. Specifically, if the class loader, or any class loader reachable via parent delegation, has a module in a &lt;a href=&quot;../lang/modulelayer&quot;&gt;module layer&lt;/a&gt;, then service providers in all modules in the module layer are located.</source>
          <target state="translated">또한 클래스 로더가 부트 스트랩 또는 &lt;a href=&quot;../lang/classloader#getPlatformClassLoader()&quot;&gt;플랫폼&lt;/a&gt; 클래스 로더가 아닌 경우 서비스 공급자는 다른 클래스 로더의 명명 된 모듈에있을 수 있습니다. 특히, 클래스 로더 또는 상위 위임을 통해 도달 할 수있는 모든 클래스 로더가 &lt;a href=&quot;../lang/modulelayer&quot;&gt;모듈 계층에&lt;/a&gt; 모듈을 가지고있는 경우 모듈 계층의 모든 모듈에있는 서비스 공급자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6693592d77694b84bdf498092215f9da7f914aab" translate="yes" xml:space="preserve">
          <source>In addition, if there are known attributes with default values, &lt;code&gt;Attr&lt;/code&gt; nodes representing them are automatically created and attached to the element.</source>
          <target state="translated">또한 기본값이있는 알려진 속성이있는 경우 이를 나타내는 &lt;code&gt;Attr&lt;/code&gt; 노드가 자동으로 생성되어 요소에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3719d936e29998d0689eb9e0adf828047d1a0f6c" translate="yes" xml:space="preserve">
          <source>In addition, its &lt;code&gt;checkPermission&lt;/code&gt; method is invoked with the &lt;code&gt;RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)&lt;/code&gt; permission when invoked directly or indirectly by the constructor of a subclass which overrides the &lt;code&gt;getContextClassLoader&lt;/code&gt; or &lt;code&gt;setContextClassLoader&lt;/code&gt; methods.</source>
          <target state="translated">또한 &lt;code&gt;checkPermission&lt;/code&gt; 메소드는 &lt;code&gt;getContextClassLoader&lt;/code&gt; 또는 &lt;code&gt;setContextClassLoader&lt;/code&gt; 메소드 를 대체하는 서브 클래스의 생성자가 직접 또는 간접적으로 호출 할 때 &lt;code&gt;RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="de54fb02014412ecd1787d4096721b6bd9a09795" translate="yes" xml:space="preserve">
          <source>In addition, multiple cancellations of row deletions can be made by adjusting the position of the cursor using any of the cursor position control methods such as:</source>
          <target state="translated">또한 다음과 같은 커서 위치 제어 방법을 사용하여 커서의 위치를 ​​조정하여 행 삭제를 여러 번 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a982507e35bcbb8afa02271b7a356830dfdca5b" translate="yes" xml:space="preserve">
          <source>In addition, multiple cancellations of row insertions can be made by adjusting the position of the cursor using any of the cursor position control methods such as:</source>
          <target state="translated">또한 다음과 같은 커서 위치 제어 방법을 사용하여 커서의 위치를 ​​조정하여 행 삽입을 여러 번 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0be37ef9695b65cf9e9180a2ae0ea88d1cdf6af" translate="yes" xml:space="preserve">
          <source>In addition, some operations, such as Arabic shaping, require context, so that the characters at the start and limit can have the proper shapes. Sometimes the data in the buffer outside the provided range does not have valid data. The values LAYOUT_NO_START_CONTEXT and LAYOUT_NO_LIMIT_CONTEXT can be added to the flags parameter to indicate that the text before start, or after limit, respectively, should not be examined for context.</source>
          <target state="translated">또한 아랍어 모양과 같은 일부 작업에는 컨텍스트가 필요하므로 시작 및 제한의 문자가 적절한 모양을 가질 수 있습니다. 때때로 제공된 범위를 벗어난 버퍼의 데이터에 유효한 데이터가 없습니다. LAYOUT_NO_START_CONTEXT 및 LAYOUT_NO_LIMIT_CONTEXT 값을 flags 매개 변수에 추가하여 시작 전 또는 제한 후 각각 텍스트에서 컨텍스트를 검사하지 않아야 함을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb227b57999fd7e909da8da1d2a7fde11cad3089" translate="yes" xml:space="preserve">
          <source>In addition, some subclasses may also implement other &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt; methods for getting specialized number formatters.</source>
          <target state="translated">또한 일부 서브 클래스는 보다 전문적인 제어를 위해 다른 &lt;code&gt;getXxxxInstance&lt;/code&gt; 메소드를 구현할 수도 있습니다 . 예를 들어, &lt;code&gt;NumberFormat&lt;/code&gt; 클래스는 &lt;code&gt;getPercentInstance&lt;/code&gt; 숫자 포맷터를 가져 오기위한 getPercentInstance 및 &lt;code&gt;getCurrencyInstance&lt;/code&gt; 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8521432ca817c76647f2d846f1bef6c88792da85" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at least attributes indicating where text was generated from an argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the argument from which the text was generated.</source>
          <target state="translated">또한 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 에는 &lt;code&gt;arguments&lt;/code&gt; 배열 의 인수에서 텍스트가 생성 된 위치를 나타내는 속성 이 최소한 포함되어 있습니다 . 이러한 속성의 키는 &lt;code&gt;MessageFormat.Field&lt;/code&gt; 유형 이며 값은 텍스트가 생성 된 인수 의 &lt;code&gt;arguments&lt;/code&gt; 배열 에서 색인을 나타내는 &lt;code&gt;Integer&lt;/code&gt; 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="a6e2e314534ac045cf69b2d41f6340feecc19940" translate="yes" xml:space="preserve">
          <source>In addition, the PrincipalClass/PrincipalName pairing may be repeated:</source>
          <target state="translated">또한 PrincipalClass / PrincipalName 쌍이 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059ef3ffe1e79dfc5ca9021949523c0f33a49b34" translate="yes" xml:space="preserve">
          <source>In addition, the class defines methods that are used to maintain a current &lt;em&gt;selection&lt;/em&gt; from the text. The text selection, a substring of the component's text, is the target of editing operations. It is also referred to as the &lt;em&gt;selected text&lt;/em&gt;.</source>
          <target state="translated">또한 클래스는 텍스트에서 현재 &lt;em&gt;선택&lt;/em&gt; 을 유지하는 데 사용되는 메서드를 정의 합니다. 구성 요소 텍스트의 하위 문자열 인 텍스트 선택은 편집 작업의 대상입니다. &lt;em&gt;선택한 텍스트&lt;/em&gt; 라고도 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2386bcd0be6584acdb144b841b15f4c960e9dd" translate="yes" xml:space="preserve">
          <source>In addition, the following operations are supported, either directly, or indirectly through objects that the &lt;code&gt;Sequencer&lt;/code&gt; has access to:</source>
          <target state="translated">또한 &lt;code&gt;Sequencer&lt;/code&gt; 가 액세스 할 수 있는 객체를 통해 직접 또는 간접적으로 다음 작업이 지원 됩니다.</target>
        </trans-unit>
        <trans-unit id="b49601d6aae95f2a139f03510edca3cb80c87127" translate="yes" xml:space="preserve">
          <source>In addition, the horizontal and vertical gaps are set to the specified values. Horizontal gaps are placed between each of the columns. Vertical gaps are placed between each of the rows.</source>
          <target state="translated">또한 수평 및 수직 간격이 지정된 값으로 설정됩니다. 각 기둥 사이에 수평 간격이 있습니다. 각 행 사이에 수직 간격이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e95a48cd4b0c0c77f9a895c979e24d8c600e0c7e" translate="yes" xml:space="preserve">
          <source>In addition, the structured type is custom mapped to a class in the Java programming language if there is such a mapping, as are its attributes, if appropriate.</source>
          <target state="translated">또한 구조화 된 유형은 해당하는 경우 속성과 같이 맵핑이있는 경우 Java 프로그래밍 언어의 클래스에 사용자 정의 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="4847332e5f9a256254c2b8f86ee3aff2ec216774" translate="yes" xml:space="preserve">
          <source>In addition, this class provides a large number of static methods for determining a character's category (lowercase letter, digit, etc.) and for converting characters from uppercase to lowercase and vice versa.</source>
          <target state="translated">또한이 클래스는 문자의 범주 (소문자, 숫자 등)를 결정하고 문자를 대문자에서 소문자로 또는 그 반대로 변환하기위한 많은 정적 메서드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c0f1f85aac1e1e7e02b8f9ea172b9f1824281377" translate="yes" xml:space="preserve">
          <source>In addition, this class provides many methods for converting a &lt;code&gt;boolean&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;boolean&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환하기위한 많은 방법을 제공 &lt;code&gt;boolean&lt;/code&gt; A와 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt;boolean&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 메소드를 &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86218e012109407362f27dd46c0b2b37d9a404bc" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;byte&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;
 byte&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환하기위한 여러 가지 방법을 제공합니다 &lt;code&gt;byte&lt;/code&gt; A와 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt; byte&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 메소드를 &lt;code&gt;byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ffeb51b3224523ef436b1d1938bf920a43bfc60" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;byte&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;byte&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환하기위한 여러 가지 방법을 제공합니다 &lt;code&gt;byte&lt;/code&gt; A와 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt;byte&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 메소드를 &lt;code&gt;byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e85c3617c388e7fe3a9752600be2c78c296128c0" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환하기위한 여러 가지 방법을 제공합니다 &lt;code&gt;double&lt;/code&gt; A를 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt;double&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 메소드를 &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68a2ece26a8ec24ff52bdb5b8ffee400c05c5514" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;float&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환하기위한 여러 가지 방법을 제공합니다 &lt;code&gt;float&lt;/code&gt; A와 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt;float&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 방법을 &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d7a80682c0aaad3c6f64e1cc3e7a4dd1f8f891d" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;
 long&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환을위한 여러 가지 방법을 제공합니다 &lt;code&gt;long&lt;/code&gt; A를 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt; long&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 방법을 &lt;code&gt;long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3209e7895f5274dda2c59c01800db0e7f1a6cb9" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;long&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환을위한 여러 가지 방법을 제공합니다 &lt;code&gt;long&lt;/code&gt; A를 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt;long&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 방법을 &lt;code&gt;long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bceab1896f5431f9616536d2c3debec95c7baf0d" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;short&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;short&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환하기위한 여러 가지 방법을 제공합니다 &lt;code&gt;short&lt;/code&gt; A와 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; A와 &lt;code&gt;short&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 방법을 &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77411ccbd611f6cf25185bc001e7ca50aa01649a" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to an &lt;code&gt;int&lt;/code&gt;, as well as other constants and methods useful when dealing with an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">또한,이 클래스는 변환하기위한 여러 가지 방법을 제공 &lt;code&gt;int&lt;/code&gt; A와 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;String&lt;/code&gt; 에 &lt;code&gt;int&lt;/code&gt; 처리시에 도움이뿐만 아니라 다른 상수와 메소드를 &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c06dbee76a5636d9963ea08f8ff95d58d1e068" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for determining a character's category (lowercase letter, digit, etc.) and for converting characters from uppercase to lowercase and vice versa.</source>
          <target state="translated">또한이 클래스는 문자 범주 (소문자, 숫자 등)를 결정하고 문자를 대문자에서 소문자로 또는 그 반대로 변환하기위한 여러 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e292b452247845d9e091ce216510934fc5ca8378" translate="yes" xml:space="preserve">
          <source>In addition, unlike &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt; forces an immediate recomputation of the calendar's milliseconds and all fields.</source>
          <target state="translated">또한, 달리 &lt;code&gt;set()&lt;/code&gt; , &lt;code&gt;add()&lt;/code&gt; 병력 달력의 밀리 세컨드 및 모든 필드가 즉시 재 계산.</target>
        </trans-unit>
        <trans-unit id="4885f27aaffdd79828e0a037c13dc416292803f1" translate="yes" xml:space="preserve">
          <source>In addition, when a security manager is present, loggers provided to system classes should not be directly configurable through the logging backend without requiring permissions.</source>
          <target state="translated">또한 보안 관리자가있는 경우 시스템 클래스에 제공되는 로거는 권한없이 로깅 백엔드를 통해 직접 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9dfe816f9d7068cb163a587c8942b7b0c372c47" translate="yes" xml:space="preserve">
          <source>In all cases, &lt;code&gt;pos&lt;/code&gt; must be greater than or equal to zero, and &lt;code&gt;pos&lt;/code&gt; must also be less than or equal to the target's arity.</source>
          <target state="translated">모든 경우에 &lt;code&gt;pos&lt;/code&gt; 는 0보다 크거나 같아야하며 &lt;code&gt;pos&lt;/code&gt; 는 대상의 arity보다 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="09e47909f30bd0dae2adcaf9dec3e17da3c754a0" translate="yes" xml:space="preserve">
          <source>In all cases, arguments given to methods for these purposes need not fall within the indicated ranges; for example, a date may be specified as January 32 and is interpreted as meaning February 1.</source>
          <target state="translated">모든 경우에, 이러한 목적을 위해 방법에 주어진 주장은 지시 된 범위에 속할 필요는 없다. 예를 들어, 날짜는 1 월 32 일로 지정 될 수 있으며 2 월 1 일을 의미하는 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="710a1058addac3a4778571f2e89fe86199a733c7" translate="yes" xml:space="preserve">
          <source>In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is &lt;em&gt;guaranteed&lt;/em&gt; to hold this lock.</source>
          <target state="translated">모든 경우에이 메소드가 리턴하기 전에 현재 스레드가이 조건과 연관된 잠금을 다시 확보해야합니다. 스레드가 돌아 오면됩니다 &lt;em&gt;보장&lt;/em&gt; 이 잠금을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26a8f8af04f382db67be9b5de3a26f6c349c6b6b" translate="yes" xml:space="preserve">
          <source>In all cases, calculations that use this method to calculate results along one axis will not fail because of anomalies in calculations along the other axis. When the cell is not valid the &lt;code&gt;includeSpacing&lt;/code&gt; parameter is ignored.</source>
          <target state="translated">모든 경우에이 방법을 사용하여 한 축을 따라 결과를 계산하는 계산은 다른 축을 따라 계산의 이상으로 인해 실패하지 않습니다. 셀이 유효하지 않으면 &lt;code&gt;includeSpacing&lt;/code&gt; 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="89452fe59efb654a902cd41128a35da921fe424a" translate="yes" xml:space="preserve">
          <source>In all cases, if the new value is outside the valid range of values for the field then a &lt;code&gt;DateTimeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">모든 경우에 새 값이 필드의 유효한 값 범위를 벗어나면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81081b4ee2ad6edc756e2675593e859604468b70" translate="yes" xml:space="preserve">
          <source>In all cases, it is legal to return a more capable metadata object than strictly necessary. The format name and node names are merely hints that may be used to reduce the reader's workload.</source>
          <target state="translated">모든 경우에 반드시 필요한 것보다 더 유능한 메타 데이터 개체를 반환하는 것이 합법적입니다. 형식 이름과 노드 이름은 독자의 작업량을 줄이는 데 사용될 수있는 힌트 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="a8642fd07de10ab15e255b32922459adaf42a0c8" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;#longBitsToDouble(long)&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToLongBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;#longBitsToDouble(long)&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt; 메서드에 제공 될 때 &lt;code&gt;doubleToLongBits&lt;/code&gt; 에 대한 인수와 동일한 부동 소수점 값을 생성 하는 &lt;code&gt;long&lt;/code&gt; 정수입니다 (모든 NaN 값이 단일 &quot;표준&quot;NaN으로 축소되는 경우 제외). 값).</target>
        </trans-unit>
        <trans-unit id="8837bb6be2c5fdd23d8a48631d7aee2f241759eb" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;#longBitsToDouble(long)&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToRawLongBits&lt;/code&gt;.</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;#longBitsToDouble(long)&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt; 메서드에 제공 될 때 &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 에 대한 인수와 동일한 부동 소수점 값을 생성하는 &lt;code&gt;long&lt;/code&gt; 정수입니다 .</target>
        </trans-unit>
        <trans-unit id="3e386c1014f9389cd75e4097f8ba05b0eb55648f" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToLongBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt; 메소드에 지정된 경우 &lt;code&gt;doubleToLongBits&lt;/code&gt; 의 인수와 동일한 부동 소수점 값을 생성 하는 &lt;code&gt;long&lt;/code&gt; 정수입니다 (모든 NaN 값이 단일 &quot;정식&quot;NaN으로 축소되는 경우는 제외) 값).</target>
        </trans-unit>
        <trans-unit id="94e816d46d03eaaedcfd4333b2b790c79aab00a5" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToRawLongBits&lt;/code&gt;.</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt; 메소드에 지정된 경우 &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 의 인수와 동일한 부동 소수점 값을 생성하는 &lt;code&gt;long&lt;/code&gt; 정수입니다 .</target>
        </trans-unit>
        <trans-unit id="1fd6b3425097c0e30a0d9da2eb4d3433636ea847" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;#intBitsToFloat(int)&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToIntBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;#intBitsToFloat(int)&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt; 메서드에 제공 될 때 &lt;code&gt;floatToIntBits&lt;/code&gt; 에 대한 인수와 동일한 부동 소수점 값을 생성하는 정수입니다 (모든 NaN 값이 단일 &quot;표준&quot;NaN 값으로 축소되는 경우 제외) ).</target>
        </trans-unit>
        <trans-unit id="84c117b508f6a4eab4d75f1234503941d79ab2fb" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;#intBitsToFloat(int)&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToRawIntBits&lt;/code&gt;.</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;#intBitsToFloat(int)&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt; 메서드에 제공 될 때 &lt;code&gt;floatToRawIntBits&lt;/code&gt; 에 대한 인수와 동일한 부동 소수점 값을 생성하는 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="8fa2f7b6b965b0569cfce25d70b8a9ac24c40131" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToIntBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt; 메소드에 제공 될 때 &lt;code&gt;floatToIntBits&lt;/code&gt; 의 인수와 동일한 부동 소수점 값을 생성하는 정수입니다 (모든 NaN 값이 단일 &quot;정식&quot;NaN 값으로 축소되는 경우는 제외) ).</target>
        </trans-unit>
        <trans-unit id="f8ae1992023cdf3fa87efe9d9a4061db37810e06" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToRawIntBits&lt;/code&gt;.</source>
          <target state="translated">모든 경우에 결과는 &lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt; 메소드에 제공 될 때 &lt;code&gt;floatToRawIntBits&lt;/code&gt; 의 인수와 동일한 부동 소수점 값을 생성하는 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="d3f55b4dbef121f94603171922b50a3691948cf6" translate="yes" xml:space="preserve">
          <source>In all cases, this method returns &lt;code&gt;true&lt;/code&gt;, since DefaultKeyboardFocusManager is designed so that neither &lt;code&gt;dispatchEvent&lt;/code&gt;, nor the AWT event dispatcher, should take further action on the event in any situation.</source>
          <target state="translated">모든 경우에,이 메소드는 반환 &lt;code&gt;true&lt;/code&gt; DefaultKeyboardFocusManager는 어느 정도로 설계되어 있기 때문에, &lt;code&gt;dispatchEvent&lt;/code&gt; 에 , 나 AWT 이벤트 디스패처가, 어떤 상황에서 이벤트에 추가 조치를 취해야한다.</target>
        </trans-unit>
        <trans-unit id="d859740a340aab2ef2df184897feb73868229deb" translate="yes" xml:space="preserve">
          <source>In all cases, what the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">모든 경우에, 대상이 결국 리턴하는 것은 어댑터에 의해 변경되지 않은 상태로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3f9e867ee25c16d7f93432110c660aa7dfa2f352" translate="yes" xml:space="preserve">
          <source>In all methods of class &lt;code&gt;Date&lt;/code&gt; that accept or return year, month, date, hours, minutes, and seconds values, the following representations are used:</source>
          <target state="translated">연도, 월, 일,시, 분 및 초 값을 승인하거나 리턴하는 &lt;code&gt;Date&lt;/code&gt; 클래스의 모든 메소드 에서 다음 표시가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13fb9ca977fc45a075a964a2af1e52f78784083b" translate="yes" xml:space="preserve">
          <source>In all other cases the default persistence delegate is returned. The default persistence delegate assumes the type is a &lt;em&gt;JavaBean&lt;/em&gt;, implying that it has a default constructor and that its state may be characterized by the matching pairs of &quot;setter&quot; and &quot;getter&quot; methods returned by the &lt;a href=&quot;introspector&quot;&gt;&lt;code&gt;Introspector&lt;/code&gt;&lt;/a&gt; class. The default constructor is the constructor with the greatest number of parameters that has the &lt;a href=&quot;constructorproperties&quot;&gt;&lt;code&gt;ConstructorProperties&lt;/code&gt;&lt;/a&gt; annotation. If none of the constructors has the &lt;code&gt;ConstructorProperties&lt;/code&gt; annotation, then the nullary constructor (constructor with no parameters) will be used. For example, in the following code fragment, the nullary constructor for the &lt;code&gt;Foo&lt;/code&gt; class will be used, while the two-parameter constructor for the &lt;code&gt;Bar&lt;/code&gt; class will be used.</source>
          <target state="translated">다른 모든 경우에는 기본 지속성 대리자가 반환됩니다. 기본 지속성 대리자는 형식이 &lt;em&gt;JavaBean&lt;/em&gt; 이라고 가정하며 , 기본 생성자가 있고 해당 상태가 &lt;a href=&quot;introspector&quot;&gt; &lt;code&gt;Introspector&lt;/code&gt; &lt;/a&gt; 클래스에서 반환 된 &quot;setter&quot;및 &quot;getter&quot;메서드의 일치하는 쌍으로 특성화 될 수 있음을 나타냅니다 . 기본 생성자는 &lt;a href=&quot;constructorproperties&quot;&gt; &lt;code&gt;ConstructorProperties&lt;/code&gt; &lt;/a&gt; 주석 이있는 매개 변수가 가장 많은 생성자 입니다. 생성자의 어느 것도이없는 경우 &lt;code&gt;ConstructorProperties&lt;/code&gt; 의 주석, 다음 인수 없음의 생성자 (매개 변수가없는 생성자)이 사용됩니다. 예를 들어, 다음 코드 조각에서 &lt;code&gt;Foo&lt;/code&gt; 의 null 생성자클래스가 사용되는 반면, &lt;code&gt;Bar&lt;/code&gt; 클래스에 대한 2 개의 매개 변수 생성자 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f080e0ee2b15b4c102aa7079a0aa7b6d0e55888" translate="yes" xml:space="preserve">
          <source>In all other cases, let</source>
          <target state="translated">다른 모든 경우에는</target>
        </trans-unit>
        <trans-unit id="a11fe3cb468743e49daade63ee6734a831ca51f6" translate="yes" xml:space="preserve">
          <source>In all other respects, this method does the same thing as the method &lt;a href=&quot;object#wait-long-&quot;&gt;&lt;code&gt;wait(long)&lt;/code&gt;&lt;/a&gt; of one argument. In particular, &lt;code&gt;wait(0, 0)&lt;/code&gt; means the same thing as &lt;code&gt;wait(0)&lt;/code&gt;.</source>
          <target state="translated">다른 모든 측면에서이 메소드는 한 인수의 &lt;a href=&quot;object#wait-long-&quot;&gt; &lt;code&gt;wait(long)&lt;/code&gt; &lt;/a&gt; 메소드와 동일한 기능을 수행합니다 . 특히 &lt;code&gt;wait(0, 0)&lt;/code&gt; 은 &lt;code&gt;wait(0)&lt;/code&gt; 과 동일한 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d2a52a46fb3d14d37051820f4fdc8a542f211e8c" translate="yes" xml:space="preserve">
          <source>In all respects, this method behaves as if &lt;code&gt;wait(0L, 0)&lt;/code&gt; had been called. See the specification of the &lt;a href=&quot;#wait(long,int)&quot;&gt;&lt;code&gt;wait(long, int)&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">모든 측면에서이 메서드는 &lt;code&gt;wait(0L, 0)&lt;/code&gt; 이 호출 된 것처럼 동작 합니다. 자세한 내용은 &lt;a href=&quot;#wait(long,int)&quot;&gt; &lt;code&gt;wait(long, int)&lt;/code&gt; &lt;/a&gt; 메서드 의 사양을 참조 하세요.</target>
        </trans-unit>
        <trans-unit id="876c5fadd4e670707e8da62775562984c13c2478" translate="yes" xml:space="preserve">
          <source>In all respects, this method behaves as if &lt;code&gt;wait(timeoutMillis, 0)&lt;/code&gt; had been called. See the specification of the &lt;a href=&quot;#wait(long,int)&quot;&gt;&lt;code&gt;wait(long, int)&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">모든 측면에서이 메서드는 &lt;code&gt;wait(timeoutMillis, 0)&lt;/code&gt; 이 호출 된 것처럼 작동 합니다. 자세한 내용은 &lt;a href=&quot;#wait(long,int)&quot;&gt; &lt;code&gt;wait(long, int)&lt;/code&gt; &lt;/a&gt; 메서드 의 사양을 참조 하세요.</target>
        </trans-unit>
        <trans-unit id="5881c9128a5b4634af69fc3e5e6bf8a1e1d2fddf" translate="yes" xml:space="preserve">
          <source>In an application which requires &lt;code&gt;invokedynamic&lt;/code&gt; instructions with individually mutable behaviors, their bootstrap methods should produce distinct &lt;a href=&quot;callsite&quot;&gt;&lt;code&gt;CallSite&lt;/code&gt;&lt;/a&gt; objects, one for each linkage request. Alternatively, an application can link a single &lt;code&gt;CallSite&lt;/code&gt; object to several &lt;code&gt;invokedynamic&lt;/code&gt; instructions, in which case a change to the target method will become visible at each of the instructions.</source>
          <target state="translated">개별적으로 변경 가능한 동작 이있는 &lt;code&gt;invokedynamic&lt;/code&gt; 명령 이 필요한 애플리케이션 에서 부트 스트랩 메서드는 각 연결 요청에 대해 하나씩 고유 한 &lt;a href=&quot;callsite&quot;&gt; &lt;code&gt;CallSite&lt;/code&gt; &lt;/a&gt; 개체를 생성해야합니다 . 또는 응용 프로그램에서 단일 &lt;code&gt;CallSite&lt;/code&gt; 개체를 여러 &lt;code&gt;invokedynamic&lt;/code&gt; 명령어에 연결할 수 있습니다 .이 경우 대상 메서드에 대한 변경 사항이 각 명령어에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="effcf63c91f615a32cf1d9dcd223b04f78c7e609" translate="yes" xml:space="preserve">
          <source>In an application which requires dynamic call sites with individually mutable behaviors, their bootstrap methods should produce distinct &lt;a href=&quot;callsite&quot;&gt;&lt;code&gt;CallSite&lt;/code&gt;&lt;/a&gt; objects, one for each linkage request. Alternatively, an application can link a single &lt;code&gt;CallSite&lt;/code&gt; object to several &lt;code&gt;invokedynamic&lt;/code&gt; instructions, in which case a change to the target method will become visible at each of the instructions.</source>
          <target state="translated">개별적으로 변경 가능한 동작이있는 동적 호출 사이트가 필요한 응용 프로그램에서 부트 스트랩 메소드는 각 링크 요청마다 하나씩 고유 한 &lt;a href=&quot;callsite&quot;&gt; &lt;code&gt;CallSite&lt;/code&gt; &lt;/a&gt; 객체를 생성해야합니다 . 또는 응용 프로그램이 단일 &lt;code&gt;CallSite&lt;/code&gt; 객체를 여러 &lt;code&gt;invokedynamic&lt;/code&gt; 명령어에 연결할 수 있으며 ,이 경우 대상 메서드에 대한 변경 사항이 각 명령어에서 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a6322785784db32ea230804c456ea63d59ad58e8" translate="yes" xml:space="preserve">
          <source>In an element representing a method named &quot;get&quot; taking one integer argument, the &quot;method&quot; attribute is replaced with an &quot;index&quot; attribute whose value the value of the first argument.</source>
          <target state="translated">하나의 정수 인수를 취하는 &quot;get&quot;이라는 메소드를 나타내는 요소에서 &quot;method&quot;속성은 첫 번째 인수의 값을 갖는 &quot;index&quot;속성으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c3d66182f526cc1c3711397e1bc8a88caa07d70f" translate="yes" xml:space="preserve">
          <source>In an element representing a method named &quot;set&quot; taking two arguments, the first of which is an integer, the &quot;method&quot; attribute is replaced with an &quot;index&quot; attribute whose value the value of the first argument.</source>
          <target state="translated">첫 번째가 정수인 두 개의 인수를 취하는 &quot;set&quot;이라는 메소드를 나타내는 요소에서 &quot;method&quot;속성은 첫 번째 인수의 값을 갖는 &quot;index&quot;속성으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3defc8fdafc7a95d821ad6a2e72f02a3b02b057c" translate="yes" xml:space="preserve">
          <source>In an element representing a monadic method whose name starts with &quot;set&quot;, the &quot;method&quot; attribute is replaced with a &quot;property&quot; attribute whose value is given by removing the &quot;set&quot; prefix and decapitalizing the result.</source>
          <target state="translated">이름이 &quot;set&quot;로 시작하는 모나드 메서드를 나타내는 요소에서 &quot;method&quot;속성은 &quot;set&quot;접두사를 제거하고 결과를 decapitalizing하여 값이 지정된 &quot;property&quot;속성으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c9402abdb3bb2eff2c83147b78c26d50aa2578b7" translate="yes" xml:space="preserve">
          <source>In an element representing a nullary method whose name starts with &quot;get&quot;, the &quot;method&quot; attribute is replaced with a &quot;property&quot; attribute whose value is given by removing the &quot;get&quot; prefix and decapitalizing the result.</source>
          <target state="translated">이름이 &quot;get&quot;으로 시작하는 nullary 메서드를 나타내는 요소에서 &quot;method&quot;속성은 &quot;get&quot;접두사를 제거하고 결과를 decapitalizing하여 값이 지정된 &quot;property&quot;속성으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f680341ae630eeaec6f425095320e0e5baed727c" translate="yes" xml:space="preserve">
          <source>In another example, if a search() method was invoked with a specified size limit of 'n'. If the answer consists of more than 'n' results, search() would first return a NamingEnumeration. When the n'th result has been returned by invoking next() on the NamingEnumeration, a SizeLimitExceedException would then thrown when hasMore() is invoked.</source>
          <target state="translated">다른 예에서, 지정된 크기 제한 'n'으로 search () 메소드가 호출 된 경우. 대답이 'n'개 이상의 결과로 구성된 경우 search ()는 먼저 NamingEnumeration을 반환합니다. NamingEnumeration에서 next ()를 호출하여 n 번째 결과가 반환되면 hasMore ()가 호출 될 때 SizeLimitExceedException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="63473c669373298ff8b126a800c3c9be701d8f25" translate="yes" xml:space="preserve">
          <source>In any case, byte order marks occurring after the first element of an input sequence are not omitted since the same code is used to represent &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;.</source>
          <target state="translated">어쨌든, 입력 시퀀스의 첫 번째 요소 다음에 발생하는 바이트 순서 마크는 동일한 코드가 &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt; 를 나타내는 데 사용되므로 생략되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ec213efaa5103b31dfaf4a45519f35d0934bea15" translate="yes" xml:space="preserve">
          <source>In any case, if this method is to be reinvoked in the same decoding operation then care should be taken to preserve any bytes remaining in the input buffer so that they are available to the next invocation.</source>
          <target state="translated">어쨌든,이 방법을 동일한 디코딩 작업에서 다시 호출하려면 다음 호출에서 사용할 수 있도록 입력 버퍼에 남아있는 바이트를 보존하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="de7b4cedf7b1b3605cbb4d5e220c17ec91cfeb27" translate="yes" xml:space="preserve">
          <source>In any case, if this method is to be reinvoked in the same encoding operation then care should be taken to preserve any characters remaining in the input buffer so that they are available to the next invocation.</source>
          <target state="translated">어쨌든,이 메소드가 동일한 인코딩 조작으로 다시 호출되는 경우, 다음 호출에서 사용 가능하도록 입력 버퍼에 남아있는 문자를 보존하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d361555e6e7f2aefd6719812880d76caffb268" translate="yes" xml:space="preserve">
          <source>In any mode, when a row is too tall to fit in the printable area -- print the upper-most portion of the row and paint no lower border on the table.</source>
          <target state="translated">어떤 모드에서든 행이 너무 길어서 인쇄 가능 영역에 맞지 않을 때 행의 가장 위쪽 부분을 인쇄하고 테이블의 아래쪽 테두리를 칠하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42c371089599906ae5216970a156c82451cbcf79" translate="yes" xml:space="preserve">
          <source>In any mode, when the header or footer text is too wide to fit completely in the printable area -- print as much of the text as possible starting from the beginning, as determined by the table's &lt;code&gt;ComponentOrientation&lt;/code&gt;.</source>
          <target state="translated">어떤 모드에서든 머리글 또는 바닥 글 텍스트가 너무 넓어서 인쇄 가능 영역에 완전히 맞지 않는 경우-테이블의 &lt;code&gt;ComponentOrientation&lt;/code&gt; 에 의해 결정된대로 처음부터 가능한 한 많은 텍스트를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="b7c25745d87214e8c648f8952d20a0f3e9a240b8" translate="yes" xml:space="preserve">
          <source>In any other part of the system, where a date must be manipulated in a calendar system other than ISO, the use case will generally specify the calendar system to use. For example, an application may need to calculate the next Islamic or Hebrew holiday which may require manipulating the date. This kind of use case can be handled as follows:</source>
          <target state="translated">ISO 이외의 달력 시스템에서 날짜를 조작해야하는 시스템의 다른 부분에서는 유스 케이스가 일반적으로 사용할 달력 시스템을 지정합니다. 예를 들어, 응용 프로그램은 날짜를 조작해야하는 다음 이슬람 또는 히브리 휴일을 계산해야 할 수 있습니다. 이러한 종류의 사용 사례는 다음과 같이 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6bfb37bc0f12d7bd938335d6fa2308caf29415db" translate="yes" xml:space="preserve">
          <source>In attribute subclassing, attributes are defined in a class hierarchy. In some directories, for example, the &quot;name&quot; attribute might be the superclass of all name-related attributes, including &quot;commonName&quot; and &quot;surName&quot;. Asking for the &quot;name&quot; attribute might return both the &quot;commonName&quot; and &quot;surName&quot; attributes.</source>
          <target state="translated">속성 서브 클래 싱에서 속성은 클래스 계층 구조로 정의됩니다. 예를 들어, 일부 디렉토리에서 &quot;name&quot;속성은 &quot;commonName&quot;및 &quot;surName&quot;을 포함한 모든 이름 관련 속성의 수퍼 클래스 일 수 있습니다. &quot;name&quot;속성을 요청하면 &quot;commonName&quot;및 &quot;surName&quot;속성이 모두 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db07d9eddd1469a03a0d4523aef982ea0329c470" translate="yes" xml:space="preserve">
          <source>In both cases, if a complete &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; or &lt;code&gt;Instant&lt;/code&gt; is parsed, then the excess days are added to the date part. As a result, this query will return a zero period.</source>
          <target state="translated">두 경우 모두 완전한 &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; 또는 &lt;code&gt;Instant&lt;/code&gt; 가 구문 분석되면 초과 날짜가 날짜 부분에 추가됩니다. 결과적으로이 쿼리는 제로 기간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91a4a245b640227d3d4414ba8ce731f1a8ba5d28" translate="yes" xml:space="preserve">
          <source>In both string form and array form, each successive integer group gives a range of integers to be included in the set. The first integer in each group gives the lower bound of the range; the second integer in each group gives the upper bound of the range; if there is only one integer in the group, the upper bound is the same as the lower bound. If the upper bound is less than the lower bound, it denotes a &lt;code&gt;null&lt;/code&gt; range (no values). If the upper bound is equal to the lower bound, it denotes a range consisting of a single value. If the upper bound is greater than the lower bound, it denotes a range consisting of more than one value. The ranges may appear in any order and are allowed to overlap. The union of all the ranges gives the set's contents. Once a &lt;code&gt;SetOfIntegerSyntax&lt;/code&gt; instance is constructed, its value is immutable.</source>
          <target state="translated">문자열 형식과 배열 형식 모두에서 각 연속 정수 그룹은 집합에 포함될 정수 범위를 제공합니다. 각 그룹의 첫 번째 정수는 범위의 하한을 제공합니다. 각 그룹의 두 번째 정수는 범위의 상한을 제공합니다. 그룹에 정수가 하나만있는 경우 상한은 하한과 동일합니다. 상한이 하한보다 작 으면 &lt;code&gt;null&lt;/code&gt; 범위 (값 없음)를 나타냅니다 . 상한이 하한과 같으면 단일 값으로 구성된 범위를 나타냅니다. 상한이 하한보다 크면 둘 이상의 값으로 구성된 범위를 나타냅니다. 범위는 임의의 순서로 나타날 수 있으며 겹칠 수 있습니다. 모든 범위의 합집합은 세트의 내용을 제공합니다. 한 번 &lt;code&gt;SetOfIntegerSyntax&lt;/code&gt; 인스턴스가 생성되면 그 값은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f636f886ea66f4a3a9afd96f753e53de19a4e47" translate="yes" xml:space="preserve">
          <source>In both string form and array form, each successive integer group gives a range of integers to be included in the set. The first integer in each group gives the lower bound of the range; the second integer in each group gives the upper bound of the range; if there is only one integer in the group, the upper bound is the same as the lower bound. If the upper bound is less than the lower bound, it denotes a null range (no values). If the upper bound is equal to the lower bound, it denotes a range consisting of a single value. If the upper bound is greater than the lower bound, it denotes a range consisting of more than one value. The ranges may appear in any order and are allowed to overlap. The union of all the ranges gives the set's contents. Once a SetOfIntegerSyntax instance is constructed, its value is immutable.</source>
          <target state="translated">문자열 형식과 배열 형식에서 각각의 연속 정수 그룹은 세트에 포함될 정수 범위를 제공합니다. 각 그룹의 첫 번째 정수는 범위의 하한을 제공합니다. 각 그룹의 두 번째 정수는 범위의 상한을 제공합니다. 그룹에 정수가 하나만 있으면 상한과 하한이 같습니다. 상한이 하한보다 작 으면 널 범위 (값 없음)를 나타냅니다. 상한이 하한과 같으면 단일 값으로 구성된 범위를 나타냅니다. 상한이 하한보다 큰 경우 둘 이상의 값으로 구성된 범위를 나타냅니다. 범위는 임의의 순서로 나타날 수 있으며 겹칠 수 있습니다. 모든 범위의 합집합은 세트의 내용을 제공합니다. SetOfIntegerSyntax 인스턴스가 생성되면 값을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d2d378458c146562d67eef1a8ddb1eb555f8996" translate="yes" xml:space="preserve">
          <source>In case of &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt;&lt;code&gt;ServiceConfigurationError&lt;/code&gt;&lt;/a&gt; a &lt;a href=&quot;schemafactoryconfigurationerror&quot;&gt;&lt;code&gt;SchemaFactoryConfigurationError&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">의 경우 &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt; &lt;code&gt;ServiceConfigurationError&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;schemafactoryconfigurationerror&quot;&gt; &lt;code&gt;SchemaFactoryConfigurationError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d8151180e8b90a1132b0cccb8774fce54d1a54c" translate="yes" xml:space="preserve">
          <source>In case of &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt;&lt;code&gt;ServiceConfigurationError&lt;/code&gt;&lt;/a&gt; an &lt;a href=&quot;xpathfactoryconfigurationexception&quot;&gt;&lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">의 경우 &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt; &lt;code&gt;ServiceConfigurationError&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;xpathfactoryconfigurationexception&quot;&gt; &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ab38b391c63c43cfa86dbd08744e0705f58ee43" translate="yes" xml:space="preserve">
          <source>In case of &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt;&lt;code&gt;service
     configuration error&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;datatypeconfigurationexception&quot;&gt;&lt;code&gt;DatatypeConfigurationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">의 경우 &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt; &lt;code&gt;service configuration error&lt;/code&gt; &lt;/a&gt; 하는 &lt;a href=&quot;datatypeconfigurationexception&quot;&gt; &lt;code&gt;DatatypeConfigurationException&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ad8b6db0e5041707a878e8f2137cb2dc1e748f6" translate="yes" xml:space="preserve">
          <source>In case of error while checking the byte or character stream, the method will return false to allow the XML processor to handle the error.</source>
          <target state="translated">바이트 또는 문자 스트림을 확인하는 동안 오류가 발생하면 메서드는 XML 프로세서가 오류를 처리 할 수 ​​있도록 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="beaa91ad6c8eaa4dea63cdc3004dcaca25742485" translate="yes" xml:space="preserve">
          <source>In case of exceptional completion with a CompletionException, methods &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#get(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;get(long, TimeUnit)&lt;/code&gt;&lt;/a&gt; throw an &lt;a href=&quot;executionexception&quot;&gt;&lt;code&gt;ExecutionException&lt;/code&gt;&lt;/a&gt; with the same cause as held in the corresponding CompletionException. To simplify usage in most contexts, this class also defines methods &lt;a href=&quot;#join()&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getNow(T)&quot;&gt;&lt;code&gt;getNow(T)&lt;/code&gt;&lt;/a&gt; that instead throw the CompletionException directly in these cases.</source>
          <target state="translated">CompletionException으로 예외적으로 완료되는 경우 &lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#get(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;get(long, TimeUnit)&lt;/code&gt; &lt;/a&gt; 메서드 는 해당 CompletionException에 보관 된 것과 동일한 원인으로 &lt;a href=&quot;executionexception&quot;&gt; &lt;code&gt;ExecutionException&lt;/code&gt; &lt;/a&gt; 을 throw합니다 . 대부분의 컨텍스트에서 사용을 단순화하기 위해이 클래스는 이러한 경우에 직접 CompletionException을 발생 시키는 &lt;a href=&quot;#join()&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#getNow(T)&quot;&gt; &lt;code&gt;getNow(T)&lt;/code&gt; &lt;/a&gt; 메서드도 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a484bdc7d644636e56b6e425fca8f967f78e3d13" translate="yes" xml:space="preserve">
          <source>In case of exceptional completion with a CompletionException, methods &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;completablefuture#get-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;get(long, TimeUnit)&lt;/code&gt;&lt;/a&gt; throw an &lt;a href=&quot;executionexception&quot;&gt;&lt;code&gt;ExecutionException&lt;/code&gt;&lt;/a&gt; with the same cause as held in the corresponding CompletionException. To simplify usage in most contexts, this class also defines methods &lt;a href=&quot;completablefuture#join--&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;completablefuture#getNow-T-&quot;&gt;&lt;code&gt;getNow(T)&lt;/code&gt;&lt;/a&gt; that instead throw the CompletionException directly in these cases.</source>
          <target state="translated">CompletionException 탁월한 완료시, 방법 &lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;completablefuture#get-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;get(long, TimeUnit)&lt;/code&gt; &lt;/a&gt; 던져 &lt;a href=&quot;executionexception&quot;&gt; &lt;code&gt;ExecutionException&lt;/code&gt; 를&lt;/a&gt; 대응 CompletionException 유지 같은 원인으로. 대부분의 컨텍스트에서 사용을 단순화하기 위해이 클래스는 대신 이러한 경우 CompletionException을 직접 발생 시키는 &lt;a href=&quot;completablefuture#join--&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;completablefuture#getNow-T-&quot;&gt; &lt;code&gt;getNow(T)&lt;/code&gt; &lt;/a&gt; 메소드를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="02e1bf0c0b871bf4e85899ff41b22e62b5894d0a" translate="yes" xml:space="preserve">
          <source>In case of local transfer a serialized copy of the object returned by the encapsulated transferable is provided when the data is requested in application/x-java-serialized-object data flavor.</source>
          <target state="translated">로컬 전송의 경우, 데이터가 application / x-java-serialized-object 데이터 플레이버에서 요청 될 때 캡슐화 된 전송 가능 객체에서 반환 된 객체의 직렬화 된 복사본이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6b30498fac7ace93c84b231cbf2811b4209e3742" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;engineInit&lt;/code&gt; method), each provider must supply (and document) a default initialization. For example, the Sun provider uses a default modulus prime size of 1024 bits for the generation of DSA parameters.</source>
          <target state="translated">클라이언트가 AlgorithmParameterGenerator를 명시 적으로 초기화하지 않은 경우 ( &lt;code&gt;engineInit&lt;/code&gt; 메소드 호출을 통해 ) 각 제공자는 기본 초기화를 제공 (및 문서화)해야합니다. 예를 들어, Sun 공급자는 DSA 매개 변수 생성에 기본 계수 1024 비트의 기본 계수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68e407b5b13916cde2cd11c5f37eb5f842e4f9a5" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;engineInit&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the AlgorithmParameterGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the AlgorithmParameterGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">클라이언트가 ( &lt;code&gt;engineInit&lt;/code&gt; 메서드에 대한 호출을 통해) AlgorithmParameterGenerator를 명시 적으로 초기화하지 않는 경우 각 공급자는 기본 초기화를 제공하고 문서화해야합니다. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK 공급자가&lt;/a&gt; 사용하는 AlgorithmParameterGenerator 기본값에 대한 정보 는 JDK 공급자 문서 의 키 크기 제한 섹션을 참조하십시오 . 그러나 기본값은 제공 업체마다 다를 수 있습니다. 또한 공급자의 기본값은 향후 버전에서 변경 될 수 있습니다. 따라서 공급자 별 기본값에 의존하는 대신 AlgorithmParameterGenerator를 명시 적으로 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a37d2611d020aa41b4751a0d8cd1144f2acda07a" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. For example, the Sun provider uses a default modulus prime size of 1024 bits for the generation of DSA parameters.</source>
          <target state="translated">클라이언트가 &lt;code&gt;init&lt;/code&gt; 메소드에 대한 호출을 통해 AlgorithmParameterGenerator를 명시 적으로 초기화하지 않은 경우 각 제공자는 기본 초기화를 제공 (및 문서화)해야합니다. 예를 들어, Sun 공급자는 DSA 매개 변수 생성에 기본 계수 1024 비트의 기본 계수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="618f13f618647d566b20d8751205271f6da0fde1" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the AlgorithmParameterGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the AlgorithmParameterGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">클라이언트가 ( &lt;code&gt;init&lt;/code&gt; 메서드 호출을 통해) AlgorithmParameterGenerator를 명시 적으로 초기화하지 않는 경우 각 공급자는 기본 초기화를 제공 (및 문서화)해야합니다. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK 공급자가&lt;/a&gt; 사용하는 AlgorithmParameterGenerator 기본값에 대한 정보 는 JDK 공급자 문서 의 키 크기 제한 섹션을 참조하십시오 . 그러나 기본값은 제공 업체마다 다를 수 있습니다. 또한 공급자의 기본값은 향후 버전에서 변경 될 수 있습니다. 따라서 공급자 별 기본값에 의존하는 대신 AlgorithmParameterGenerator를 명시 적으로 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5eb2b1a734ed185b35dd6d539f47ccd18d6fa259" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization.</source>
          <target state="translated">클라이언트가 &lt;code&gt;init&lt;/code&gt; 메소드 호출을 통해 KeyGenerator를 명시 적으로 초기화하지 않은 경우 각 제공자는 기본 초기화를 제공 (및 문서화)해야합니다.</target>
        </trans-unit>
        <trans-unit id="850cecd70d52ca77c6e849b65f63f33d0551283d" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the KeyGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the KeyGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">클라이언트가 ( &lt;code&gt;init&lt;/code&gt; 메서드에 대한 호출을 통해) KeyGenerator를 명시 적으로 초기화하지 않는 경우 각 공급자는 기본 초기화를 제공 (및 문서화)해야합니다. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK 공급자가&lt;/a&gt; 사용하는 KeyGenerator 기본값에 대한 정보 는 JDK 공급자 문서 의 Keysize Restriction 섹션을 참조하십시오 . 그러나 기본값은 제공 업체마다 다를 수 있습니다. 또한 공급자의 기본값은 향후 버전에서 변경 될 수 있습니다. 따라서 공급자 별 기본값에 의존하는 대신 KeyGenerator를 명시 적으로 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="debfe51230845fafd7d09cad852623660ca1f4b3" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyPairGenerator (via a call to an &lt;code&gt;initialize&lt;/code&gt; method), each provider must supply (and document) a default initialization. For example, the</source>
          <target state="translated">클라이언트가 &lt;code&gt;initialize&lt;/code&gt; 메소드 호출을 통해 KeyPairGenerator를 명시 적으로 초기화하지 않은 경우 각 제공자는 기본 초기화를 제공 (및 문서화)해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="204488c07139beb503a6394353ed2128445b7fb4" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyPairGenerator (via a call to an &lt;code&gt;initialize&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the KeyPairGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the KeyPairGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">클라이언트가 ( &lt;code&gt;initialize&lt;/code&gt; 메서드 호출을 통해) KeyPairGenerator를 명시 적으로 초기화하지 않는 경우 각 공급자는 기본 초기화를 제공 (및 문서화)해야합니다. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK 공급자가&lt;/a&gt; 사용하는 KeyPairGenerator 기본값에 대한 정보 는 JDK 공급자 문서 의 Keysize Restriction 섹션을 참조하십시오 . 그러나 기본값은 제공 업체마다 다를 수 있습니다. 또한 공급자의 기본값은 향후 버전에서 변경 될 수 있습니다. 따라서 공급자 별 기본값에 의존하는 대신 KeyPairGenerator를 명시 적으로 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="74c4c704743eaa4c51b305733ce161d1198c7af9" translate="yes" xml:space="preserve">
          <source>In cases where the given member is of variable arity (i.e., a method or constructor) the returned method handle will also be of &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt;. In all other cases, the returned method handle will be of fixed arity.</source>
          <target state="translated">주어진 멤버가 변수 arity (즉, 메서드 또는 생성자) 인 경우 반환 된 메서드 핸들도 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;변수 arity가&lt;/a&gt; 됩니다. 다른 모든 경우에 반환 된 메서드 핸들은 고정 된 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="9941fbe4a1552d799e92803cbaeb391d95bf7051" translate="yes" xml:space="preserve">
          <source>In cases where the given member is of variable arity (i.e., a method or constructor) the returned method handle will also be of &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt;. In all other cases, the returned method handle will be of fixed arity.</source>
          <target state="translated">주어진 멤버가 가변 arity 인 경우 (즉, 메소드 또는 생성자) 리턴 된 메소드 핸들도 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;가변 arity&lt;/a&gt; 입니다. 다른 모든 경우에, 리턴 된 메소드 핸들은 고정 된 arity입니다.</target>
        </trans-unit>
        <trans-unit id="b23a675004466dd2b4cbce7eda7eaf631095a71f" translate="yes" xml:space="preserve">
          <source>In cases where the inherited channel represents a network socket then the &lt;a href=&quot;../channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; type returned by this method is determined as follows:</source>
          <target state="translated">상속 된 채널이 네트워크 소켓을 나타내는 경우이 메소드가 리턴 한 &lt;a href=&quot;../channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 유형은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f6aa2646aaa3d5e37e2c5cce3a7678a57dd20872" translate="yes" xml:space="preserve">
          <source>In cases where the lookup object is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt;&lt;code&gt;publicLookup()&lt;/code&gt;&lt;/a&gt;, or some other lookup object without &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;, the lookup class is disregarded. In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">조회 객체가 &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt; &lt;code&gt;publicLookup()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;개인 액세스가&lt;/a&gt; 없는 다른 조회 객체 인 경우 조회 클래스는 무시됩니다. 이러한 경우 호출자에 민감한 메서드 핸들을 만들 수없고 액세스가 금지되며 &lt;code&gt;IllegalAccessException&lt;/code&gt; 으로 조회가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="e96745c8c1f08936c49bcea65ee1327783f9c9d0" translate="yes" xml:space="preserve">
          <source>In cases where the lookup object is &lt;a href=&quot;methodhandles#publicLookup--&quot;&gt;&lt;code&gt;publicLookup()&lt;/code&gt;&lt;/a&gt;, or some other lookup object without &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;, the lookup class is disregarded. In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">조회 객체가 &lt;a href=&quot;methodhandles#publicLookup--&quot;&gt; &lt;code&gt;publicLookup()&lt;/code&gt; &lt;/a&gt; 이거나 &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;개인 액세스 권한이&lt;/a&gt; 없는 다른 조회 객체 인 경우 조회 클래스는 무시됩니다. 이러한 경우 호출자 구분 메소드 핸들을 작성할 수없고 액세스가 금지되며 &lt;code&gt;IllegalAccessException&lt;/code&gt; 으로 조회가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="610432ed467c71937577f34e5257a28d540e06ac" translate="yes" xml:space="preserve">
          <source>In cases where the stream implementation is able to optimize away the production of some or all the elements (such as with short-circuiting operations like &lt;code&gt;findFirst&lt;/code&gt;, or in the example described in &lt;a href=&quot;#count()&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt;), the action will not be invoked for those elements.</source>
          <target state="translated">스트림 구현이 일부 또는 모든 요소의 생성을 최적화 할 수있는 경우 (예 : &lt;code&gt;findFirst&lt;/code&gt; 와 같은 단락 연산 또는 &lt;a href=&quot;#count()&quot;&gt; &lt;code&gt;count()&lt;/code&gt; &lt;/a&gt; 설명 된 예제에서 ) 해당 요소에 대해 작업이 호출되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="77f68deaa108cb1537a1eec87f3fc8ea57159538" translate="yes" xml:space="preserve">
          <source>In client mode, unless the return &lt;a href=&quot;../../../java/util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; is empty, the client should use the requested server names to guide its endpoint identification of the peer's identity, and/or other aspects of security policy.</source>
          <target state="translated">클라이언트 모드에서 리턴 &lt;a href=&quot;../../../java/util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 이 비어 있지 않으면 클라이언트는 요청 된 서버 이름을 사용하여 피어의 ID 및 / 또는 보안 정책의 다른 측면에 대한 엔드 포인트 식별을 안내해야합니다.</target>
        </trans-unit>
        <trans-unit id="766cdb2ff65ab81907f3f51a9b0d20746cd713e5" translate="yes" xml:space="preserve">
          <source>In conforming implementations of Element Traversal, all objects that implement &lt;a href=&quot;element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; must also implement the &lt;code&gt;ElementTraversal&lt;/code&gt; interface. Four of the methods, &lt;a href=&quot;#getFirstElementChild()&quot;&gt;&lt;code&gt;getFirstElementChild()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getLastElementChild()&quot;&gt;&lt;code&gt;getLastElementChild()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getPreviousElementSibling()&quot;&gt;&lt;code&gt;getPreviousElementSibling()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#getNextElementSibling()&quot;&gt;&lt;code&gt;getNextElementSibling()&lt;/code&gt;&lt;/a&gt;, each provides a live reference to another element with the defined relationship to the current element, if the related element exists. The fifth method, &lt;a href=&quot;#getChildElementCount()&quot;&gt;&lt;code&gt;getChildElementCount()&lt;/code&gt;&lt;/a&gt;, exposes the number of child elements of an element, for preprocessing before navigation.</source>
          <target state="translated">요소 순회의 구현, 구현하는 모든 객체 준수에 &lt;a href=&quot;element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 도 구현해야 &lt;code&gt;ElementTraversal&lt;/code&gt; 의 인터페이스를. 네 가지 메서드 인 &lt;a href=&quot;#getFirstElementChild()&quot;&gt; &lt;code&gt;getFirstElementChild()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#getLastElementChild()&quot;&gt; &lt;code&gt;getLastElementChild()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#getPreviousElementSibling()&quot;&gt; &lt;code&gt;getPreviousElementSibling()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#getNextElementSibling()&quot;&gt; &lt;code&gt;getNextElementSibling()&lt;/code&gt; &lt;/a&gt; 은 각각 관련 요소가있는 경우 현재 요소와 정의 된 관계가있는 다른 요소에 대한 라이브 참조를 제공합니다. 다섯 번째 메서드 인 &lt;a href=&quot;#getChildElementCount()&quot;&gt; &lt;code&gt;getChildElementCount()&lt;/code&gt; &lt;/a&gt; 는 탐색 전 사전 처리를 위해 요소의 자식 요소 수를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="79b29a8711f23dff025211e81b749f6713301187" translate="yes" xml:space="preserve">
          <source>In contrast, the &lt;a href=&quot;printermoreinfo&quot;&gt;&lt;code&gt;PrinterMoreInfo&lt;/code&gt;&lt;/a&gt; attribute is used to find out more information about this specific printer rather than this general kind of printer.</source>
          <target state="translated">반대로 &lt;a href=&quot;printermoreinfo&quot;&gt; &lt;code&gt;PrinterMoreInfo&lt;/code&gt; &lt;/a&gt; 속성은이 일반적인 종류의 프린터가 아닌이 특정 프린터에 대한 자세한 정보를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9caffca4032e0bb867acc7983198b345a565191b" translate="yes" xml:space="preserve">
          <source>In contrast, the &lt;a href=&quot;printermoreinfomanufacturer&quot;&gt;&lt;code&gt;PrinterMoreInfoManufacturer&lt;/code&gt;&lt;/a&gt; attribute is used to find out more information about this general kind of printer rather than this specific printer.</source>
          <target state="translated">반대로 &lt;a href=&quot;printermoreinfomanufacturer&quot;&gt; &lt;code&gt;PrinterMoreInfoManufacturer&lt;/code&gt; &lt;/a&gt; 속성은이 특정 프린터가 아닌이 일반적인 종류의 프린터에 대한 자세한 정보를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bed3edf217562c5e1423cbcacb264e83e97f8ab1" translate="yes" xml:space="preserve">
          <source>In details, the state model for buttons works as follows when used with the keyboard:</source>
          <target state="translated">세부적으로 버튼의 상태 모델은 키보드와 함께 사용할 때 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4062e12a39d4486940201fa830bbde974cf851ea" translate="yes" xml:space="preserve">
          <source>In details, the state model for buttons works as follows when used with the mouse:</source>
          <target state="translated">세부적으로 버튼의 상태 모델은 마우스와 함께 사용할 때 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ee40bba43e6448bd8f50c5059985279d975f96e9" translate="yes" xml:space="preserve">
          <source>In doing so, a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; may modify the events, for example by adding defaulted attributes.</source>
          <target state="translated">이렇게하면 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; 는 예를 들어 기본 속성을 추가하여 이벤트를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060627d2546f44e2eb02a70e34bf6f73812e4991" translate="yes" xml:space="preserve">
          <source>In dotall mode, the expression &lt;code&gt;.&lt;/code&gt; matches any character, including a line terminator. By default this expression does not match line terminators.</source>
          <target state="translated">dotall 모드에서 &lt;code&gt;.&lt;/code&gt; 줄 종결자를 포함하여 모든 문자와 일치합니다. 기본적으로이 표현식은 줄 종결 자와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56eb79ce8d988bd4f7d4412f2ff9d697e4ca2aec" translate="yes" xml:space="preserve">
          <source>In each iteration, the iteration variables are passed to an invocation of the &lt;code&gt;body&lt;/code&gt; handle. A non-&lt;code&gt;void&lt;/code&gt; value returned from the body (of type &lt;code&gt;V&lt;/code&gt;) updates the leading iteration variable. The result of the loop handle execution will be the final &lt;code&gt;V&lt;/code&gt; value of that variable (or &lt;code&gt;void&lt;/code&gt; if there is no &lt;code&gt;V&lt;/code&gt; variable).</source>
          <target state="translated">각 반복에서 반복 변수는 &lt;code&gt;body&lt;/code&gt; 핸들 의 호출로 전달됩니다 . 본문에서 반환 된 &lt;code&gt;void&lt;/code&gt; 가 아닌 값 (유형 &lt;code&gt;V&lt;/code&gt; ) 은 선행 반복 변수를 업데이트합니다. 루프 핸들 실행의 결과는 해당 변수 의 최종 &lt;code&gt;V&lt;/code&gt; 값이됩니다 (또는 &lt;code&gt;V&lt;/code&gt; 변수 가 없으면 &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d88997d2890c678dab9000d415f1fe8afb3e8043" translate="yes" xml:space="preserve">
          <source>In either case, if the host was specified using the &lt;code&gt;[...]&lt;/code&gt; syntax for numeric IPv6 addresses, the square brackets are not included in the return value here.</source>
          <target state="translated">두 경우 모두 숫자 IPv6 주소에 &lt;code&gt;[...]&lt;/code&gt; 구문을 사용하여 호스트를 지정한 경우 여기에 대괄호가 반환 값에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f9f1eeccbc325e134332f21c771ad94fb506cd0" translate="yes" xml:space="preserve">
          <source>In either case, language ranges are sorted in descending order in the Language Priority List based on priority or weight. If a language range appears in the given &lt;code&gt;ranges&lt;/code&gt; more than once, only the first one is included on the Language Priority List.</source>
          <target state="translated">두 경우 모두 언어 범위는 우선 순위 또는 가중치에 따라 언어 우선 순위 목록에서 내림차순으로 정렬됩니다. 지정된 &lt;code&gt;ranges&lt;/code&gt; 에 언어 범위가 두 번 이상 나타나면 언어 우선 순위 목록에 첫 번째 언어 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="769252c126293283cc7c83a2b1bd6109e998defc" translate="yes" xml:space="preserve">
          <source>In either case, the &quot;*&quot; or &quot;-&quot; character at the end of a wildcard &lt;code&gt;path&lt;/code&gt; is removed before canonicalization or normalization. It is stored in a separate wildcard flag field.</source>
          <target state="translated">두 경우 모두 와일드 카드 &lt;code&gt;path&lt;/code&gt; 끝에있는 &quot;*&quot;또는 &quot;-&quot;문자는 정규화 또는 정규화 전에 제거됩니다. 별도의 와일드 카드 플래그 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="55b6c09f46927e3b4d92afe1b61f0c38ea762b03" translate="yes" xml:space="preserve">
          <source>In either case, the class</source>
          <target state="translated">두 경우 모두</target>
        </trans-unit>
        <trans-unit id="236fdad6a9437be057f2da47354343f51080d4cd" translate="yes" xml:space="preserve">
          <source>In either case, the code that instantiates an X.509 certificate consults the value of the &lt;code&gt;cert.provider.x509v1&lt;/code&gt; security property to locate the actual implementation or instantiates a default implementation.</source>
          <target state="translated">두 경우 모두 X.509 인증서를 인스턴스화하는 코드는 &lt;code&gt;cert.provider.x509v1&lt;/code&gt; 보안 특성 의 값을 참조 하여 실제 구현을 찾거나 기본 구현을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="45f7d360a66191e21bd373f5aba227e8c0490155" translate="yes" xml:space="preserve">
          <source>In either case, the quality setting in an &lt;code&gt;ImageWriteParam&lt;/code&gt; has the same meaning as for the underlying library: 1.00 means a quantization table of all 1's, 0.75 means the &quot;standard&quot;, visually lossless quantization table, and 0.00 means aquantization table of all 255's.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;ImageWriteParam&lt;/code&gt; 의 품질 설정 은 기본 라이브러리와 동일한 의미를 갖습니다. 1.00은 모든 1의 양자화 테이블을 의미하고, 0.75는 &quot;표준&quot;, 시각적으로 무손실 양자화 테이블을, 0.00은 모든 255의 양자화 테이블을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eb55847a08d18a4afa181d4462c2342b7398dcea" translate="yes" xml:space="preserve">
          <source>In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see &lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">위임 모델이 엄격하게 계층 적이 지 않은 환경에서는 클래스 로더가 병렬 가능해야합니다. 그렇지 않으면 클래스로드 프로세스 중에 로더 잠금이 유지되므로 클래스로드로 인해 교착 상태가 발생할 수 있습니다 ( &lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드 참조 ).</target>
        </trans-unit>
        <trans-unit id="c22bcef59b65807b22a81446aa681e17a7f9b7cf" translate="yes" xml:space="preserve">
          <source>In essence, a menu is a button with an associated &lt;code&gt;JPopupMenu&lt;/code&gt;. When the &quot;button&quot; is pressed, the &lt;code&gt;JPopupMenu&lt;/code&gt; appears. If the &quot;button&quot; is on the &lt;code&gt;JMenuBar&lt;/code&gt;, the menu is a top-level window. If the &quot;button&quot; is another menu item, then the &lt;code&gt;JPopupMenu&lt;/code&gt; is &quot;pull-right&quot; menu.</source>
          <target state="translated">본질적으로 메뉴는 연관된 &lt;code&gt;JPopupMenu&lt;/code&gt; 가있는 버튼입니다 . &quot;버튼&quot;을 누르면 &lt;code&gt;JPopupMenu&lt;/code&gt; 가 나타납니다. &quot;버튼&quot;이 &lt;code&gt;JMenuBar&lt;/code&gt; 에있는 경우 메뉴는 최상위 창입니다. &quot;버튼&quot;이 다른 메뉴 항목이면 &lt;code&gt;JPopupMenu&lt;/code&gt; 는 &quot;오른쪽 당김&quot;메뉴입니다.</target>
        </trans-unit>
        <trans-unit id="76b01c569fddbef2fd279870bf0626c68e22edb7" translate="yes" xml:space="preserve">
          <source>In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</source>
          <target state="translated">모든 경우에 요소 &lt;code&gt;b[0]&lt;/code&gt; ~ &lt;code&gt;b[off]&lt;/code&gt; 및 요소 &lt;code&gt;b[off+len]&lt;/code&gt; ~ &lt;code&gt;b[b.length-1]&lt;/code&gt; 은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="801d9d22e0c396affe549d48580efe1c12d56b6f" translate="yes" xml:space="preserve">
          <source>In every other case, an &lt;code&gt;OpenType&lt;/code&gt; is assignable from another &lt;code&gt;OpenType&lt;/code&gt; only if they are equal.</source>
          <target state="translated">다른 모든 경우에 &lt;code&gt;OpenType&lt;/code&gt; 은 동일한 경우에만 다른 &lt;code&gt;OpenType&lt;/code&gt; 에서 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2542cc96f3c5e1b57effa4d62600ff590801b978" translate="yes" xml:space="preserve">
          <source>In fact, &quot;import ...*&quot; is usually a sign of sloppy programming anyway, so the user should consider this a feature rather than a bug.</source>
          <target state="translated">사실, &quot;import ... *&quot;는 일반적으로 어쨌거나 엉성한 프로그래밍의 신호이므로 사용자는이를 버그가 아닌 기능으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="7180b2cd8aff78dc10263ca1b56b42ba5afd94b5" translate="yes" xml:space="preserve">
          <source>In fixed-delay execution, each execution is scheduled relative to the actual execution time of the previous execution. If an execution is delayed for any reason (such as garbage collection or other background activity), subsequent executions will be delayed as well. In the long run, the frequency of execution will generally be slightly lower than the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate).</source>
          <target state="translated">고정 지연 실행에서 각 실행은 이전 실행의 실제 실행 시간을 기준으로 예약됩니다. 가비지 수집 또는 기타 백그라운드 활동과 같은 이유로 실행이 지연되면 후속 실행도 지연됩니다. 장기적으로 실행 빈도는 일반적으로 지정된 기간의 역수보다 약간 낮습니다 ( &lt;code&gt;Object.wait(long)&lt;/code&gt; 기본 시스템 시계 가 정확 하다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="06dd4ce58b291cfcd7c050a8ac56352c9904d7d1" translate="yes" xml:space="preserve">
          <source>In fixed-delay execution, each execution is scheduled relative to the actual execution time of the previous execution. If an execution is delayed for any reason (such as garbage collection or other background activity), subsequent executions will be delayed as well. In the long run, the frequency of execution will generally be slightly lower than the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate). As a consequence of the above, if the scheduled first time is in the past, it is scheduled for immediate execution.</source>
          <target state="translated">고정 지연 실행에서 각 실행은 이전 실행의 실제 실행 시간을 기준으로 예약됩니다. 가비지 수집 또는 기타 백그라운드 활동과 같은 이유로 실행이 지연되면 후속 실행도 지연됩니다. 장기적으로 실행 빈도는 일반적으로 지정된 기간의 역수보다 약간 낮습니다 ( &lt;code&gt;Object.wait(long)&lt;/code&gt; 기본 시스템 시계 가 정확 하다고 가정 ). 위의 결과로, 스케줄 된 처음 시간이 과거 인 경우 즉시 실행되도록 스케줄됩니다.</target>
        </trans-unit>
        <trans-unit id="38f4d1c31bc026707af439dd64fd16f577250fa5" translate="yes" xml:space="preserve">
          <source>In fixed-rate execution, each execution is scheduled relative to the scheduled execution time of the initial execution. If an execution is delayed for any reason (such as garbage collection or other background activity), two or more executions will occur in rapid succession to &quot;catch up.&quot; In the long run, the frequency of execution will be exactly the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate).</source>
          <target state="translated">고정 속도 실행에서 각 실행은 초기 실행의 예약 된 실행 시간을 기준으로 예약됩니다. 어떤 이유로 든 (가비지 수집 또는 기타 백그라운드 활동과 같은) 실행이 지연되면 &quot;캐치 업&quot;에 빠르게 두 개 이상의 실행이 발생합니다. 장기적으로 실행 빈도는 지정된 기간의 역수입니다 ( &lt;code&gt;Object.wait(long)&lt;/code&gt; 기본 시스템 시계 가 정확 하다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="6c5dab1a04b2f64b424e450784bf531fabb4f1ec" translate="yes" xml:space="preserve">
          <source>In fixed-rate execution, each execution is scheduled relative to the scheduled execution time of the initial execution. If an execution is delayed for any reason (such as garbage collection or other background activity), two or more executions will occur in rapid succession to &quot;catch up.&quot; In the long run, the frequency of execution will be exactly the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate). As a consequence of the above, if the scheduled first time is in the past, then any &quot;missed&quot; executions will be scheduled for immediate &quot;catch up&quot; execution.</source>
          <target state="translated">고정 속도 실행에서 각 실행은 초기 실행의 예약 된 실행 시간을 기준으로 예약됩니다. 어떤 이유로 든 (가비지 수집 또는 기타 백그라운드 활동과 같은) 실행이 지연되면 &quot;캐치 업&quot;에 빠르게 두 개 이상의 실행이 발생합니다. 장기적으로 실행 빈도는 지정된 기간의 역수입니다 ( &lt;code&gt;Object.wait(long)&lt;/code&gt; 기본 시스템 시계 가 정확 하다고 가정 ). 위의 결과로, 처음 예약 된 시간이 지난 경우 &quot;누락 된&quot;실행은 즉시 &quot;캐치 업&quot;실행되도록 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="377721e57496fed42d1cae3373a6f0668f7794a9" translate="yes" xml:space="preserve">
          <source>In general SEVERE messages should describe events that are of considerable importance and which will prevent normal program execution. They should be reasonably intelligible to end users and to system administrators. This level is initialized to &lt;code&gt;1000&lt;/code&gt;.</source>
          <target state="translated">일반적으로 SEVERE 메시지는 상당히 중요하고 정상적인 프로그램 실행을 방해하는 이벤트를 설명해야합니다. 최종 사용자와 시스템 관리자는 이해할 수 있어야합니다. 이 수준은 &lt;code&gt;1000&lt;/code&gt; 으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="61cf99ed5ef8da1599e976e4159b4d46eb5f6234" translate="yes" xml:space="preserve">
          <source>In general Swing is not thread safe. All Swing components and related classes, unless otherwise documented, must be accessed on the event dispatching thread.</source>
          <target state="translated">일반적으로 Swing은 스레드로부터 안전하지 않습니다. 달리 문서화되지 않는 한 모든 Swing 구성 요소 및 관련 클래스는 이벤트 디스패치 스레드에서 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca89517b7bed3fbab9bcbe3cd835aaae375b5494" translate="yes" xml:space="preserve">
          <source>In general WARNING messages should describe events that will be of interest to end users or system managers, or which indicate potential problems. This level is initialized to &lt;code&gt;900&lt;/code&gt;.</source>
          <target state="translated">일반적으로 경고 메시지는 최종 사용자 나 시스템 관리자가 관심을 갖거나 잠재적 인 문제를 나타내는 이벤트를 설명해야합니다. 이 수준은 &lt;code&gt;900&lt;/code&gt; 으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="52ab12fc5c3f521826991557e9ca1a023d1a3454" translate="yes" xml:space="preserve">
          <source>In general the FINE level should be used for information that will be broadly interesting to developers who do not have a specialized interest in the specific subsystem.</source>
          <target state="translated">일반적으로 FINE 레벨은 특정 서브 시스템에 특별한 관심이없는 개발자에게 널리 흥미로운 정보에 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fc5cc8c0864383c85fb2bed4626443c7e7721dce" translate="yes" xml:space="preserve">
          <source>In general the rounding modes and precision setting determine how operations return results with a limited number of digits when the exact result has more digits (perhaps infinitely many in the case of division and square root) than the number of digits returned. First, the total number of digits to return is specified by the &lt;code&gt;MathContext&lt;/code&gt;'s &lt;code&gt;precision&lt;/code&gt; setting; this determines the result's</source>
          <target state="translated">일반적으로 반올림 모드 및 정밀도 설정은 정확한 결과에 반환 된 자릿수보다 더 많은 자릿수 (나눗셈 및 제곱근의 경우 무한히 많음)가있을 때 제한된 자릿수로 결과를 반환하는 방법을 결정합니다. 첫째, 반환 할 총 자릿수는 &lt;code&gt;MathContext&lt;/code&gt; 의 &lt;code&gt;precision&lt;/code&gt; 설정에 의해 지정됩니다 . 이것은 결과의</target>
        </trans-unit>
        <trans-unit id="1963e8a87e697420d77d12336068a0b78ee8491b" translate="yes" xml:space="preserve">
          <source>In general the rounding modes and precision setting determine how operations return results with a limited number of digits when the exact result has more digits (perhaps infinitely many in the case of division) than the number of digits returned. First, the total number of digits to return is specified by the &lt;code&gt;MathContext&lt;/code&gt;'s &lt;code&gt;precision&lt;/code&gt; setting; this determines the result's</source>
          <target state="translated">일반적으로 반올림 모드와 정밀도 설정은 정확한 결과에 반환 된 자릿수보다 더 많은 자릿수가있을 경우 (작은 경우에는 무한히 많은 숫자) 연산이 제한된 자릿수로 결과를 반환하는 방법을 결정합니다. 먼저 반환 할 총 자릿수는 &lt;code&gt;MathContext&lt;/code&gt; 의 &lt;code&gt;precision&lt;/code&gt; 설정에 의해 지정됩니다 . 이것은 결과를 결정합니다</target>
        </trans-unit>
        <trans-unit id="efb1ad58a65f9bea2add8227af1103b53b3080cd" translate="yes" xml:space="preserve">
          <source>In general this approach is much faster. Compared to the backing store approach this avoids the overhead of maintaining an offscreen buffer and having to do two &lt;code&gt;copyArea&lt;/code&gt;s. Compared to the non backing store case this approach will greatly reduce the painted region.</source>
          <target state="translated">일반적으로이 방법은 훨씬 빠릅니다. 백업 저장소 접근 방식과 비교할 때 이것은 오프 스크린 버퍼를 유지하고 두 개의 &lt;code&gt;copyArea&lt;/code&gt; 를 수행해야하는 오버 헤드를 방지합니다 . 비 백업 저장소의 경우와 비교하여이 접근 방식은 페인트 영역을 크게 줄입니다.</target>
        </trans-unit>
        <trans-unit id="c0e94901874b2ae22cda0cfde069060cc90a5196" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toLowerCase()&quot;&gt;&lt;code&gt;String.toLowerCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to lowercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;string#toLowerCase()&quot;&gt; &lt;code&gt;String.toLowerCase()&lt;/code&gt; &lt;/a&gt; 를 사용하여 문자를 소문자로 매핑해야합니다. &lt;code&gt;String&lt;/code&gt; 대소 문자 매핑 방법은 &lt;code&gt;Character&lt;/code&gt; 대소 문자 매핑 방법에 비해 몇 가지 이점이 있습니다. &lt;code&gt;String&lt;/code&gt; 대소 문자 매핑 방법은 로케일 구분 매핑, 문맥 인식 매핑 및 1 : M 문자 매핑을 수행 할 수 있지만 &lt;code&gt;Character&lt;/code&gt; 대소 문자 매핑 방법은 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7903ecabcfca49b9b51c9a6417d726476aff19c9" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toLowerCase--&quot;&gt;&lt;code&gt;String.toLowerCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to lowercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;string#toLowerCase--&quot;&gt; &lt;code&gt;String.toLowerCase()&lt;/code&gt; &lt;/a&gt; 를 사용하여 문자를 소문자로 매핑해야합니다. &lt;code&gt;String&lt;/code&gt; 소문자 매핑 방법은 &lt;code&gt;Character&lt;/code&gt; 소문자 매핑 방법에 비해 몇 가지 이점이 있습니다. &lt;code&gt;String&lt;/code&gt; 소문자 매핑 방법은 로캘 구분 매핑, 상황 별 매핑 및 1 : M 문자 매핑을 수행 할 수 있지만 &lt;code&gt;Character&lt;/code&gt; 소문자 매핑 방법은 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fcb952ce2751f84d52d12ddb4b53912b10d6c4f4" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toUpperCase()&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to uppercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;string#toUpperCase()&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 를 사용하여 문자를 대문자로 매핑해야합니다. &lt;code&gt;String&lt;/code&gt; 대소 문자 매핑 방법은 &lt;code&gt;Character&lt;/code&gt; 대소 문자 매핑 방법에 비해 몇 가지 이점이 있습니다. &lt;code&gt;String&lt;/code&gt; 대소 문자 매핑 방법은 로케일 구분 매핑, 문맥 인식 매핑 및 1 : M 문자 매핑을 수행 할 수 있지만 &lt;code&gt;Character&lt;/code&gt; 대소 문자 매핑 방법은 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e84c348879217d2774b2e6f52daa41be1dbd7647" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to uppercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 를 사용하여 문자를 대문자로 매핑해야합니다. &lt;code&gt;String&lt;/code&gt; 소문자 매핑 방법은 &lt;code&gt;Character&lt;/code&gt; 소문자 매핑 방법에 비해 몇 가지 이점이 있습니다. &lt;code&gt;String&lt;/code&gt; 소문자 매핑 방법은 로캘 구분 매핑, 상황 별 매핑 및 1 : M 문자 매핑을 수행 할 수 있지만 &lt;code&gt;Character&lt;/code&gt; 소문자 매핑 방법은 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d7e17baf4657b727413c0aba5c861df347a6bdea" translate="yes" xml:space="preserve">
          <source>In general, a URL can be broken into several parts. Consider the following example:</source>
          <target state="translated">일반적으로 URL은 여러 부분으로 나눌 수 있습니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bdd376741f3d8082da9a304e1c250753cd486c5b" translate="yes" xml:space="preserve">
          <source>In general, a Writer sends its output immediately to the underlying character or byte stream. Unless prompt output is required, it is advisable to wrap a BufferedWriter around any Writer whose write() operations may be costly, such as FileWriters and OutputStreamWriters. For example,</source>
          <target state="translated">일반적으로 Writer는 출력을 기본 문자 또는 바이트 스트림으로 즉시 보냅니다. 프롬프트 출력이 필요하지 않은 경우, FileWriters 및 OutputStreamWriters와 같이 write () 작업에 비용이 많이 드는 모든 Writer를 BufferedWriter로 감싸는 것이 좋습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="639aff6278df151aefd56fe9abfe51c6c6546a60" translate="yes" xml:space="preserve">
          <source>In general, asynchronous tasks execute in either the thread invoking the operation, e.g. &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;sending&lt;/a&gt; an HTTP request, or by the threads supplied by the client's &lt;a href=&quot;httpclient#executor()&quot;&gt;&lt;code&gt;executor&lt;/code&gt;&lt;/a&gt;. Dependent tasks, those that are triggered by returned CompletionStages or CompletableFutures, that do not explicitly specify an executor, execute in the same &lt;a href=&quot;../../../../java.base/java/util/concurrent/completablefuture#defaultExecutor()&quot;&gt;&lt;code&gt;default executor&lt;/code&gt;&lt;/a&gt; as that of &lt;code&gt;
 CompletableFuture&lt;/code&gt;, or the invoking thread if the operation completes before the dependent task is registered.</source>
          <target state="translated">일반적으로 비동기 작업은 작업을 호출하는 스레드 (예 : HTTP 요청 &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;전송&lt;/a&gt; ) 또는 클라이언트의 &lt;a href=&quot;httpclient#executor()&quot;&gt; &lt;code&gt;executor&lt;/code&gt; &lt;/a&gt; 제공하는 스레드에서 실행 됩니다. 종속 작업, 명시 적으로 동일한에서 실행 집행자를 지정하지 않는 반환 CompletionStages 또는 CompletableFutures에 의해 트리거되는 것과, &lt;a href=&quot;../../../../java.base/java/util/concurrent/completablefuture#defaultExecutor()&quot;&gt; &lt;code&gt;default executor&lt;/code&gt; &lt;/a&gt; 의 그것과 &lt;code&gt; CompletableFuture&lt;/code&gt; 종속 작업 전에 작업이 완료가 등록되어있는 경우, 또는 호출 스레드.</target>
        </trans-unit>
        <trans-unit id="b8c3a1d31a2b60ee471be38513d574e12d32af96" translate="yes" xml:space="preserve">
          <source>In general, creating a connection to a URL is a multistep process:</source>
          <target state="translated">일반적으로 URL에 대한 연결을 만드는 작업은 여러 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="bfd8112757a14085d8d97c9f9777d5d3cd54f34f" translate="yes" xml:space="preserve">
          <source>In general, developers should use the &lt;code&gt;UIDefaults&lt;/code&gt; returned from &lt;code&gt;getDefaults()&lt;/code&gt;. As the current look and feel may expect certain values to exist, altering the &lt;code&gt;UIDefaults&lt;/code&gt; returned from this method could have unexpected results.</source>
          <target state="translated">일반적으로 개발자는 &lt;code&gt;getDefaults()&lt;/code&gt; 에서 반환 된 &lt;code&gt;UIDefaults&lt;/code&gt; 를 사용해야합니다 . 현재 룩앤필에서 특정 값이있을 것으로 예상 할 수 &lt;code&gt;UIDefaults&lt;/code&gt; 메서드에서 반환 된 UIDefaults를 변경하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2098f901fe353218eb3766afcbda6c9dd9a40b32" translate="yes" xml:space="preserve">
          <source>In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,</source>
          <target state="translated">일반적으로 Reader로 작성된 각 읽기 요청은 해당 읽기 요청이 기본 문자 또는 바이트 스트림으로 이루어 지도록합니다. 따라서 FileReader 및 InputStreamReader와 같이 read () 작업에 비용이 많이 드는 모든 Reader 주위에 BufferedReader를 랩핑하는 것이 좋습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3316f354198c51080a3833552e7b39608bce991e" translate="yes" xml:space="preserve">
          <source>In general, if sb refers to an instance of a &lt;code&gt;StringBuffer&lt;/code&gt;, then &lt;code&gt;sb.append(x)&lt;/code&gt; has the same effect as &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt;.</source>
          <target state="translated">SB는 인스턴스를 참조하는 경우 일반적 &lt;code&gt;StringBuffer&lt;/code&gt; 에 이어서, &lt;code&gt;sb.append(x)&lt;/code&gt; 와 동일한 효과를 갖는다 &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="915babbb9e40489175934fdd5d39ee98d92d2ac1" translate="yes" xml:space="preserve">
          <source>In general, if sb refers to an instance of a &lt;code&gt;StringBuilder&lt;/code&gt;, then &lt;code&gt;sb.append(x)&lt;/code&gt; has the same effect as &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt;.</source>
          <target state="translated">SB는 인스턴스를 참조하는 경우 일반적으로 &lt;code&gt;StringBuilder&lt;/code&gt; 다음 &lt;code&gt;sb.append(x)&lt;/code&gt; 와 동일한 효과를 갖는다 &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42ad5e48d6d5adf2f12d6cf9f61d8fa7a84aac0c" translate="yes" xml:space="preserve">
          <source>In general, if the text used to construct the &lt;code&gt;LineBreakMeasurer&lt;/code&gt; changes, a new &lt;code&gt;LineBreakMeasurer&lt;/code&gt; must be constructed to reflect the change. (The old &lt;code&gt;LineBreakMeasurer&lt;/code&gt; continues to function properly, but it won't be aware of the text change.) Nevertheless, if the text change is the insertion or deletion of a single character, an existing &lt;code&gt;LineBreakMeasurer&lt;/code&gt; can be 'updated' by calling &lt;code&gt;insertChar&lt;/code&gt; or &lt;code&gt;deleteChar&lt;/code&gt;. Updating an existing &lt;code&gt;LineBreakMeasurer&lt;/code&gt; is much faster than creating a new one. Clients who modify text based on user typing should take advantage of these methods.</source>
          <target state="translated">일반적으로 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 를 구성하는 데 사용 된 텍스트가 변경되면 변경 사항 을 반영하도록 새 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 를 구성해야합니다. (이전 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 는 계속 제대로 작동하지만 텍스트 변경은 인식하지 못합니다.) 그럼에도 불구하고 텍스트 변경이 단일 문자의 삽입 또는 삭제 인 경우 기존 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 는 &lt;code&gt;insertChar&lt;/code&gt; 또는 &lt;code&gt;deleteChar&lt;/code&gt; . 기존 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 를 업데이트하는 것이 새로 만드는 것보다 훨씬 빠릅니다. 사용자 입력에 따라 텍스트를 수정하는 클라이언트는 이러한 방법을 활용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bd60088580eccde556a63506e5f80dae1b4ac3c" translate="yes" xml:space="preserve">
          <source>In general, it is preferable to use a &lt;code&gt;FileCacheImageInputStream&lt;/code&gt; when reading from a regular &lt;code&gt;InputStream&lt;/code&gt;. This class is provided for cases where it is not possible to create a writable temporary file.</source>
          <target state="translated">일반적으로 일반 &lt;code&gt;InputStream&lt;/code&gt; 에서 읽을 때 &lt;code&gt;FileCacheImageInputStream&lt;/code&gt; 을 사용하는 것이 좋습니다 . 이 클래스는 쓰기 가능한 임시 파일을 만들 수없는 경우에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="21e5e3c075e0b11cb1e347193c00ff4d2551bbce" translate="yes" xml:space="preserve">
          <source>In general, manipulating a date, and even querying a date, is wide open to bugs when the calendar system is unknown at development time. This is why it is essential that code using this interface is subjected to additional code reviews. It is also why an architectural decision to avoid this interface type is usually the correct one.</source>
          <target state="translated">일반적으로 개발시 달력 시스템을 알 수없는 경우 날짜를 조작하고 날짜를 쿼리하는 경우에도 버그가 발생하기 쉽습니다. 따라서이 인터페이스를 사용하는 코드는 추가 코드 검토를 받아야합니다. 또한이 인터페이스 유형을 피하려는 아키텍처 결정이 일반적으로 올바른 이유이기도합니다.</target>
        </trans-unit>
        <trans-unit id="39aaaeecd067c9c412df4df520158abdb4239fe8" translate="yes" xml:space="preserve">
          <source>In general, parameter values remain in force for repeated use in this &lt;code&gt;RowSet&lt;/code&gt; object's command. Setting a parameter value with the setter methods automatically clears the value of the designated parameter and replaces it with the new specified value.</source>
          <target state="translated">일반적으로 매개 변수 값은이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에서 반복적으로 사용하기 위해 적용됩니다 . setter 메소드로 매개 변수 값을 설정하면 지정된 매개 변수의 값이 자동으로 지워지고 새로 지정된 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="71c31f7c17038994ad8645a2526545f703559d4a" translate="yes" xml:space="preserve">
          <source>In general, parameter values remain in force for repeated use of a &lt;code&gt;RowSet&lt;/code&gt; object. Setting a parameter value automatically clears its previous value. However, in some cases it is useful to immediately release the resources used by the current parameter values, which can be done by calling the method &lt;code&gt;clearParameters&lt;/code&gt;.</source>
          <target state="translated">일반적으로 매개 변수 값은 &lt;code&gt;RowSet&lt;/code&gt; 개체 를 반복적으로 사용하기 위해 적용 됩니다. 매개 변수 값을 설정하면 이전 값이 자동으로 지워집니다. 그러나 경우에 따라 현재 매개 변수 값에서 사용하는 리소스를 즉시 해제하는 것이 유용하며, 이는 &lt;code&gt;clearParameters&lt;/code&gt; 메서드를 호출하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5618fd2f8fa2eb38f62b620d4f37d70fac329de9" translate="yes" xml:space="preserve">
          <source>In general, parameter values remain in force for repeated use of a statement. Setting a parameter value automatically clears its previous value. However, in some cases it is useful to immediately release the resources used by the current parameter values; this can be done by calling the method &lt;code&gt;clearParameters&lt;/code&gt;.</source>
          <target state="translated">일반적으로 매개 변수 값은 명령문을 반복적으로 사용할 때 적용됩니다. 매개 변수 값을 설정하면 이전 값이 자동으로 지워집니다. 그러나 경우에 따라 현재 매개 변수 값에서 사용하는 리소스를 즉시 해제하는 것이 유용합니다. 이것은 &lt;code&gt;clearParameters&lt;/code&gt; 메소드를 호출하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3191d89aec4e6dd8c1fe52f14c52757a8cac353" translate="yes" xml:space="preserve">
          <source>In general, preformatted PDL print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt;, &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">일반적으로 미리 포맷 된 PDL 인쇄 데이터는 바이트 지향 표현 클래스 (바이트 배열, &lt;code&gt;InputStream&lt;/code&gt; , &lt;code&gt;URL&lt;/code&gt; )로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fde684fe3ce7e630fddfb34fcb022e3e0a8c906d" translate="yes" xml:space="preserve">
          <source>In general, preformatted PDL print data is provided in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">일반적으로 사전 형식화 된 PDL 인쇄 데이터는 바이트 지향 표현 클래스 (바이트 배열, InputStream, URL)로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1105749eb220cc12502bb7cf78e0bd9681ecb820" translate="yes" xml:space="preserve">
          <source>In general, preformatted image print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt;, &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">일반적으로 미리 포맷 된 이미지 인쇄 데이터는 바이트 지향 표현 클래스 (바이트 배열, &lt;code&gt;InputStream&lt;/code&gt; , &lt;code&gt;URL&lt;/code&gt; )로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a70f78ea99c155d3ce2eddde22908dd11fa016" translate="yes" xml:space="preserve">
          <source>In general, preformatted image print data is provided in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">일반적으로, 미리 포맷 된 이미지 인쇄 데이터는 바이트 지향 표현 클래스 (바이트 배열, InputStream, URL)로 제공된다.</target>
        </trans-unit>
        <trans-unit id="8f59090f50a6fbd17d3d80f0442b0770cb6823af" translate="yes" xml:space="preserve">
          <source>In general, preformatted text print data is provided either in a character oriented representation class (character array, String, Reader) or in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">일반적으로 사전 형식화 된 텍스트 인쇄 데이터는 문자 지향 표현 클래스 (문자 배열, 문자열, 리더) 또는 바이트 지향 표현 클래스 (바이트 배열, InputStream, URL)로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1acfd551ae424b2b0f0cdb837009a958059593" translate="yes" xml:space="preserve">
          <source>In general, processors must not knowingly attempt to overwrite existing files that were not generated by some processor. A &lt;code&gt;
 Filer&lt;/code&gt; may reject attempts to open a file corresponding to an existing type, like &lt;code&gt;java.lang.Object&lt;/code&gt;. Likewise, the invoker of the annotation processing tool must not knowingly configure the tool such that the discovered processors will attempt to overwrite existing files that were not generated.</source>
          <target state="translated">일반적으로 프로세서는 일부 프로세서에서 생성하지 않은 기존 파일을 의도적으로 덮어 쓰지 않아야합니다. &lt;code&gt; Filer&lt;/code&gt; 같은 기존 유형에 해당하는 파일을 열려고 거부 할 수 &lt;code&gt;java.lang.Object&lt;/code&gt; 상위를 . 마찬가지로, 주석 처리 도구의 호출자는 발견 된 프로세서가 생성되지 않은 기존 파일을 겹쳐 쓰도록 도구를 의도적으로 구성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e174721fc57e1470b14637e03eed9bd9757b2c64" translate="yes" xml:space="preserve">
          <source>In general, processors must not knowingly attempt to overwrite existing files that were not generated by some processor. A &lt;code&gt;Filer&lt;/code&gt; may reject attempts to open a file corresponding to an existing type, like &lt;code&gt;java.lang.Object&lt;/code&gt;. Likewise, the invoker of the annotation processing tool must not knowingly configure the tool such that the discovered processors will attempt to overwrite existing files that were not generated.</source>
          <target state="translated">일반적으로 프로세서는 일부 프로세서에서 생성하지 않은 기존 파일을 덮어 쓰려고 시도해서는 안됩니다. &lt;code&gt;Filer&lt;/code&gt; 같은 기존 유형에 해당하는 파일을 열려고 거부 할 수 &lt;code&gt;java.lang.Object&lt;/code&gt; 상위를 . 마찬가지로 주석 처리 도구의 호출자는 감지 된 프로세서가 생성되지 않은 기존 파일을 겹쳐 쓰도록 도구를 의도적으로 구성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="431a353f97c38c8d198b7fc7b29758a7a00dead2" translate="yes" xml:space="preserve">
          <source>In general, the best results will be achieved when format-specific metadata objects can be created to encapsulate as much information about the image and its associated metadata as possible, in terms that are understood by the specific &lt;code&gt;ImageWriter&lt;/code&gt; used to perform the encoding.</source>
          <target state="translated">일반적으로 인코딩을 수행하는 데 사용 된 특정 &lt;code&gt;ImageWriter&lt;/code&gt; 가 이해하는 용어로 이미지 및 관련 메타 데이터에 대한 정보를 최대한 많이 캡슐화하기 위해 형식 별 메타 데이터 개체를 만들 수있는 경우 최상의 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53eade6b2898bdabeab389a3447d258d06173156" translate="yes" xml:space="preserve">
          <source>In general, the conditions under which a method handle may be looked up for a method &lt;code&gt;M&lt;/code&gt; are no more restrictive than the conditions under which the lookup class could have compiled, verified, and resolved a call to &lt;code&gt;M&lt;/code&gt;. Where the JVM would raise exceptions like &lt;code&gt;NoSuchMethodError&lt;/code&gt;, a method handle lookup will generally raise a corresponding checked exception, such as &lt;code&gt;NoSuchMethodException&lt;/code&gt;. And the effect of invoking the method handle resulting from the lookup is &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;exactly equivalent&lt;/a&gt; to executing the compiled, verified, and resolved call to &lt;code&gt;M&lt;/code&gt;. The same point is true of fields and constructors.</source>
          <target state="translated">일반적으로, 메소드 핸들이 메소드 &lt;code&gt;M&lt;/code&gt; 에 대해 조회 될 수있는 조건은 조회 클래스가 &lt;code&gt;M&lt;/code&gt; 에 대한 호출을 컴파일, 확인 및 해결할 수있는 조건보다 더 제한적이지 않습니다 . JVM이 &lt;code&gt;NoSuchMethodError&lt;/code&gt; 와 같은 예외를 발생 시키는 경우 , 메소드 핸들 조회는 일반적으로 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 과 같은 해당 검사 예외를 발생 시킵니다. 그리고 조회로 인한 메소드 핸들 호출의 효과 는 컴파일되고, 검증되고, 해결 된 &lt;code&gt;M&lt;/code&gt; 에 대한 호출을 실행하는 &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;것과 정확히 같습니다&lt;/a&gt; . 필드와 생성자도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="fc8aa2bd1828abadaa5eb8121e1cdc0acddb6b87" translate="yes" xml:space="preserve">
          <source>In general, this method does not need to be overridden by subclasses. All Look and Feel rendering code should reside in the &lt;code&gt;paint&lt;/code&gt; method.</source>
          <target state="translated">일반적으로이 메서드는 하위 클래스로 재정의 할 필요가 없습니다. 모든 Look and Feel 렌더링 코드는 &lt;code&gt;paint&lt;/code&gt; 메소드 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e29aefc51ddd907e426422b3411bda4d27c9e92" translate="yes" xml:space="preserve">
          <source>In general, this method is a lightweight operation for getting an approximate memory usage. For some memory pools, for example, when objects are not packed contiguously, this method may be an expensive operation that requires some computation to determine the current memory usage. An implementation should document when this is the case.</source>
          <target state="translated">일반적으로이 방법은 대략적인 메모리 사용량을 얻기위한 간단한 작업입니다. 예를 들어, 객체가 연속적으로 패킹되지 않는 일부 메모리 풀의 경우,이 방법은 현재 메모리 사용량을 결정하기 위해 약간의 계산이 필요한 고가의 작업 일 수 있습니다. 이 경우 구현시 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec36e3e2d136d0a7304c8a66d67a23e51eac0920" translate="yes" xml:space="preserve">
          <source>In general, unless otherwise noted in the javadoc, methods and constructors will throw NullPointerException if passed a null argument. The one broad exception to this rule is that the logging convenience methods in the Logger class (the config, entering, exiting, fine, finer, finest, log, logp, logrb, severe, throwing, and warning methods) will accept null values for all arguments except for the initial Level argument (if any).</source>
          <target state="translated">일반적으로 javadoc에 달리 언급되지 않는 한, 메소드 및 생성자는 널 인수를 전달하면 NullPointerException을 발생시킵니다. 이 규칙에 대한 한 가지 예외는 Logger 클래스의 로깅 편의 메소드 (구성, 입력, 종료, 양호, 미세, 최고, 로그, logp, logrb, 심각, 던지기 및 경고 메소드)가 Null 값을 허용한다는 것입니다. 초기 레벨 인수 (있는 경우)를 제외한 모든 인수</target>
        </trans-unit>
        <trans-unit id="7192acbc6c0b02d808beb4e0437459650d042c65" translate="yes" xml:space="preserve">
          <source>In general, user-written adjusters should be static constants:</source>
          <target state="translated">일반적으로 사용자 작성 조정자는 정적 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9d5425a3de90c437c3b6df07d4a422e34dce646a" translate="yes" xml:space="preserve">
          <source>In implementation terms, this method behaves as follows. The result of the parsing phase can be considered to be a map of field to value. The behavior of this method is to cause that map to be filtered between phase 1 and 2, removing all fields other than those specified as arguments to this method.</source>
          <target state="translated">구현 측면에서이 방법은 다음과 같이 작동합니다. 구문 분석 단계의 결과는 필드 대 값의 맵으로 간주 될 수 있습니다. 이 메소드의 동작은 1 단계와 2 단계 사이에서 해당 맵을 필터링하여이 메소드의 인수로 지정된 필드 이외의 모든 필드를 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1352cdc6280239b4d087354bb36004ed465fd5c1" translate="yes" xml:space="preserve">
          <source>In its more general form, a &lt;code&gt;reduce&lt;/code&gt; operation on elements of type &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; yielding a result of type &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; requires three parameters:</source>
          <target state="translated">보다 일반적인 형태로, &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 요소에 대한 &lt;code&gt;reduce&lt;/code&gt; 조작은 &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 유형의 결과를 생성하는 데 세 개의 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="43dfe4436becbfa9f6b5de81d5020076fec9ff35" translate="yes" xml:space="preserve">
          <source>In its typical usage, a &lt;code&gt;Registry&lt;/code&gt; enables RMI client bootstrapping: it provides a simple means for a client to obtain an initial reference to a remote object. Therefore, a registry's remote object implementation is typically exported with a well-known address, such as with a well-known &lt;a href=&quot;../server/objid#REGISTRY_ID&quot;&gt;&lt;code&gt;ObjID&lt;/code&gt;&lt;/a&gt; and TCP port number (default is &lt;a href=&quot;#REGISTRY_PORT&quot;&gt;&lt;code&gt;1099&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">일반적인 사용법에서 &lt;code&gt;Registry&lt;/code&gt; 는 RMI 클라이언트 부트 스트랩을 가능하게합니다. 이것은 클라이언트가 원격 객체에 대한 초기 참조를 얻을 수있는 간단한 수단을 제공합니다. 따라서 레지스트리의 원격 개체 구현은 일반적으로 잘 알려진 &lt;a href=&quot;../server/objid#REGISTRY_ID&quot;&gt; &lt;code&gt;ObjID&lt;/code&gt; &lt;/a&gt; 및 TCP 포트 번호 (기본값은 &lt;a href=&quot;#REGISTRY_PORT&quot;&gt; &lt;code&gt;1099&lt;/code&gt; &lt;/a&gt; ) 와 같이 잘 알려진 주소와 함께 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="77aca6d6bcab1192b1be419302b328975bd20263" translate="yes" xml:space="preserve">
          <source>In lazy implementations then an &lt;code&gt;IOException&lt;/code&gt; may be thrown when using the stream to list the module contents. If this occurs then the &lt;code&gt;IOException&lt;/code&gt; will be wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; and thrown from the method that caused the access to be attempted. &lt;code&gt;SecurityException&lt;/code&gt; may also be thrown when using the stream to list the module contents and access is denied by the security manager.</source>
          <target state="translated">지연 구현에서는 스트림을 사용하여 모듈 내용을 나열 할 때 &lt;code&gt;IOException&lt;/code&gt; 이 발생할 수 있습니다. 이것이 발생하면 &lt;code&gt;IOException&lt;/code&gt; 은 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 에&lt;/a&gt; 래핑되고 액세스를 시도한 메서드에서 throw됩니다. 모듈 내용을 나열하기 위해 스트림을 사용하고 보안 관리자가 액세스를 거부 할 때 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e886fad24b40d123f8ce1e5b68aaa4e75e75121" translate="yes" xml:space="preserve">
          <source>In many cases, it will be more efficient to look up the name once and use the index query methods rather than using the name query methods repeatedly.</source>
          <target state="translated">대부분의 경우 이름 쿼리 메서드를 반복적으로 사용하는 것보다 이름을 한 번 조회하고 인덱스 쿼리 메서드를 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d236b645a588e6e29bda92b7b1d5fa7a8b31381c" translate="yes" xml:space="preserve">
          <source>In many common situations, for example when working URIs that are known to be either URNs or URLs, the hierarchical URIs being used will always be server-based. They therefore must either be parsed as such or treated as an error. In these cases a statement such as</source>
          <target state="translated">예를 들어 URN 또는 URL로 알려진 작업 URI와 같은 많은 일반적인 상황에서 사용되는 계층 적 URI는 항상 서버 기반입니다. 따라서 그것들은 그대로 해석되거나 에러로 취급되어야합니다. 이 경우 다음과 같은 진술</target>
        </trans-unit>
        <trans-unit id="ec1d65c264699522caa10138b97ab127e6edf2aa" translate="yes" xml:space="preserve">
          <source>In more formal terms, assume these two type lists:</source>
          <target state="translated">보다 공식적인 용어로 다음 두 가지 유형 목록을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0e2934043ae8a161cfa924a72c9b0eec317155f8" translate="yes" xml:space="preserve">
          <source>In most cases, an instance of a &lt;code&gt;URLStreamHandler&lt;/code&gt; subclass is not created directly by an application. Rather, the first time a protocol name is encountered when constructing a &lt;code&gt;URL&lt;/code&gt;, the appropriate stream protocol handler is automatically loaded.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;URLStreamHandler&lt;/code&gt; 서브 클래스 의 인스턴스 는 애플리케이션에 의해 직접 작성되지 않습니다. 오히려, &lt;code&gt;URL&lt;/code&gt; 을 구성 할 때 프로토콜 이름이 처음 발견 될 때 적절한 스트림 프로토콜 핸들러가 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="39e51666ca03ae4454c2806c86a9f15ed69b1513" translate="yes" xml:space="preserve">
          <source>In most cases, applications should use &lt;a href=&quot;#zone()&quot;&gt;&lt;code&gt;zone()&lt;/code&gt;&lt;/a&gt; as this query is too strict.</source>
          <target state="translated">대부분의 경우 응용 프로그램은 이 쿼리가 너무 엄격하므로 &lt;a href=&quot;#zone()&quot;&gt; &lt;code&gt;zone()&lt;/code&gt; &lt;/a&gt; 을 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="f03c583c4f9a187f67c9d5064698de3c6ba9e5f8" translate="yes" xml:space="preserve">
          <source>In most cases, applications should use &lt;a href=&quot;temporalqueries#zone--&quot;&gt;&lt;code&gt;zone()&lt;/code&gt;&lt;/a&gt; as this query is too strict.</source>
          <target state="translated">대부분의 경우이 쿼리는 너무 엄격하므로 응용 프로그램은 &lt;a href=&quot;temporalqueries#zone--&quot;&gt; &lt;code&gt;zone()&lt;/code&gt; &lt;/a&gt; 을 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="d8bced82c06bec9c190b301d0f390306ca5fd209" translate="yes" xml:space="preserve">
          <source>In most cases, applications should use this query rather than &lt;code&gt;#zoneId()&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 응용 프로그램은 &lt;code&gt;#zoneId()&lt;/code&gt; 대신이 쿼리를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff9326ee0d49e5994ec528af6a841b42fa62eb09" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 반전하는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="05534aa8b63ec4048eccf7a07834ab90e9df5565" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 되 돌리는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="1a03a50d10f16d909a9a2f2d2612f04f2547de58" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 반전하는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="5ca0f70a9b9175c2c2fe451007859b67358fa814" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 바꾸는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="e78619b09a6dd4ed26333f4a9efd4ae771d133b4" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 반전하는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="4cc6b9a301072df7f4a3865fb76f7c4481348a1a" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 바꾸는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="3c5ecb0a687c7d88d6e9b87e2938edab6b659f7a" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 반전하는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="8187c2e6793a987f620d69a1063da034bcf390bd" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 되 돌리는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="eb51aa028ce5cd74c12a4c145f287af28b12ae51" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 반전하는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="0561b8f397e2afe69a4c02418cf7771d9bd7c4a0" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 바꾸는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="99db46c681c29fba900cb5c04104ad2c95eeb307" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 반전하는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="56f3a9f6060c00fbd937e2e83c6bfc005f30256c" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 사용하여 호출 패턴을 바꾸는 것이 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="4dc8fca0cd4dde7b02954c863b88c3a8c6cd211a" translate="yes" xml:space="preserve">
          <source>In most cases, the exact pages to be printed will be generated by a device driver and this attribute would not be required. However, when printing an archived document which has already been formatted, the end user may elect to print just a subset of the pages contained in the document. In this case, if a page range of &lt;code&gt;&quot;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;m&lt;/i&gt;&quot;&lt;/code&gt; is specified, the first page to be printed will be page</source>
          <target state="translated">대부분의 경우 인쇄 될 정확한 페이지는 장치 드라이버에 의해 생성되며이 속성은 필요하지 않습니다. 그러나 이미 포맷 된 보관 문서를 인쇄 할 때 최종 사용자는 문서에 포함 된 페이지의 일부만 인쇄하도록 선택할 수 있습니다. 이 경우 &lt;code&gt;&quot;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;m&lt;/i&gt;&quot;&lt;/code&gt; 의 페이지 범위를 지정하면 인쇄 할 첫 페이지가 페이지가됩니다.</target>
        </trans-unit>
        <trans-unit id="228fae619d417827abbff2695d0e3ef18a476bdf" translate="yes" xml:space="preserve">
          <source>In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.</source>
          <target state="translated">대부분의 경우 여기에 정의 된 메소드는 관련 파일 시스템 제공자에게 파일 조작을 수행하도록 위임합니다.</target>
        </trans-unit>
        <trans-unit id="400b1753d04b7af8e5783d26598d8e066c54a2d8" translate="yes" xml:space="preserve">
          <source>In most cases, the transition duration is one hour, however this is not always the case. The duration will be positive for a gap and negative for an overlap. Time-zones are second-based, so the nanosecond part of the duration will be zero.</source>
          <target state="translated">대부분의 경우 전환 지속 시간은 1 시간이지만 항상 그런 것은 아닙니다. 지속 시간은 차이에 대해 양수이고 겹치기에 대해서는 음수입니다. 시간대는 초 단위이므로 기간의 나노초 부분은 0입니다.</target>
        </trans-unit>
        <trans-unit id="e7ed0da15e8a41892d662dc53e44bec661e54f79" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, there are two valid offsets, and the earlier one is used, corresponding to the first occurrence of midnight on the date. In the case of a gap, the zoned date-time will represent the instant just after the gap.</source>
          <target state="translated">대부분의 경우 현지 날짜-시간에 대해 유효한 오프셋이 하나만 있습니다. 겹치는 경우 두 개의 유효한 오프셋이 있으며 날짜의 첫 자정에 해당하는 이전 오프셋이 사용됩니다. 간격이있는 경우 영역 날짜-시간은 간격 직후의 순간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="625ac3988fae19a7227d921594f35e99f65364f8" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, when clocks are set back, there are two valid offsets. This method uses the earlier offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">대부분의 경우 현지 날짜-시간에 대해 유효한 오프셋이 하나만 있습니다. 오버랩의 경우 클럭이 다시 설정되면 두 개의 유효한 오프셋이 있습니다. 이 방법은 일반적으로 &quot;여름&quot;에 해당하는 이전 오프셋을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c2b939591e64208fc1e25691b062275e7929457a" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, where clocks are set back, there are two valid offsets. If the preferred offset is one of the valid offsets then it is used. Otherwise the earlier valid offset is used, typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">대부분의 경우 현지 날짜-시간에 대해 유효한 오프셋이 하나만 있습니다. 클럭이 다시 설정되는 오버랩의 경우 두 개의 유효한 오프셋이 있습니다. 선호하는 오프셋이 유효한 오프셋 중 하나 인 경우 사용됩니다. 그렇지 않으면 일반적으로 &quot;여름&quot;에 해당하는 이전의 유효한 오프셋이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd9baba77f7578454bd94a07cc240ce1b5e694d3" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, where clocks are set back, there are two valid offsets. This method uses the earlier offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">대부분의 경우 현지 날짜-시간에 대해 유효한 오프셋이 하나만 있습니다. 클럭이 다시 설정되는 오버랩의 경우 두 개의 유효한 오프셋이 있습니다. 이 방법은 일반적으로 &quot;여름&quot;에 해당하는 이전 오프셋을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="127050ddf27677df3d01d5dadb8b80d81f1bb8d8" translate="yes" xml:space="preserve">
          <source>In most instances, &lt;code&gt;key&lt;/code&gt; will be &lt;code&gt;action.getValue(NAME)&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;key&lt;/code&gt; 는 &lt;code&gt;action.getValue(NAME)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ba29f0eb3427ba3bc8f620c7fd7795c4d04cb6f" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence. By default these expressions only match at the beginning and the end of the entire input sequence.</source>
          <target state="translated">여러 줄 모드에서 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 식은 각각 줄 종결 자 또는 입력 시퀀스의 끝 바로 앞 또는 바로 앞과 일치합니다. 기본적으로 이러한 표현식은 전체 입력 시퀀스의 시작과 끝에서만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8cd3059f796b099e853c5ec37ef7ff133f0e47a7" translate="yes" xml:space="preserve">
          <source>In naming systems for which the notion of full name does not apply to this binding an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is thrown. This exception is also thrown when a service provider written before the introduction of the method is in use.</source>
          <target state="translated">이름 바인딩 개념이이 바인딩에 적용되지 않는 이름 지정 시스템에서는 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다. 이 예외는 메소드 도입 전에 작성된 서비스 제공자가 사용 중일 때도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2a34c892345a3ff0220626c939a8b01b18ac6ead" translate="yes" xml:space="preserve">
          <source>In negative patterns, the minimum and maximum counts are ignored; these are presumed to be set in the positive pattern.</source>
          <target state="translated">음수 패턴에서는 최소 및 최대 카운트가 무시됩니다. 이것들은 양의 패턴으로 설정되는 것으로 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="31e73ad7a9634e0be529544b2d80db294c151284" translate="yes" xml:space="preserve">
          <source>In older versions of JDK a frame state could only be NORMAL or ICONIFIED. Since JDK 1.4 set of supported frame states is expanded and frame state is represented as a bitwise mask.</source>
          <target state="translated">이전 버전의 JDK에서 프레임 상태는 NORMAL 또는 ICONIFIED 일 수 있습니다. JDK 1.4 이후 지원되는 프레임 상태 세트가 확장되고 프레임 상태가 비트 마스크로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="59d8176c2778d52eb9144cafca492c89026c206d" translate="yes" xml:space="preserve">
          <source>In order for Views to store less state and therefore be more lightweight, the StyleSheet can act as a factory for painters that handle some of the rendering tasks. This allows implementations to determine what they want to cache and have the sharing potentially at the level that a selector is common to multiple views. Since the StyleSheet may be used by views over multiple documents and typically the HTML attributes don't effect the selector being used, the potential for sharing is significant.</source>
          <target state="translated">뷰가 더 적은 상태를 저장하여 더 가벼워 지도록 StyleSheet는 일부 렌더링 작업을 처리하는 화가를위한 팩토리 역할을 할 수 있습니다. 이를 통해 구현은 캐시 할 항목을 결정하고 선택기가 여러 뷰에 공통되는 수준에서 잠재적으로 공유 할 수 있습니다. StyleSheet는 여러 문서에 대한보기에서 사용할 수 있으며 일반적으로 HTML 속성은 사용중인 선택기에 영향을주지 않으므로 공유 가능성이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c005fc9511ccd0821d902a0c463f0c8001a2d950" translate="yes" xml:space="preserve">
          <source>In order for activation to be successful, one of the following requirements must be met, otherwise &lt;a href=&quot;activationexception&quot;&gt;&lt;code&gt;ActivationException&lt;/code&gt;&lt;/a&gt; is thrown:</source>
          <target state="translated">활성화가 성공하려면 다음 요구 사항 중 하나가 충족되어야합니다. 그렇지 않으면 &lt;a href=&quot;activationexception&quot;&gt; &lt;code&gt;ActivationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="77231df36a359866f2786c79f888114ce42dbf6e" translate="yes" xml:space="preserve">
          <source>In order for major ticks to be painted, &lt;code&gt;setPaintTicks&lt;/code&gt; must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">주 눈금을 그리 려면 &lt;code&gt;setPaintTicks&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="90b0d441ed8104d5d1d6520953b3feb27d631b33" translate="yes" xml:space="preserve">
          <source>In order for minor ticks to be painted, &lt;code&gt;setPaintTicks&lt;/code&gt; must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">작은 눈금을 그리 려면 &lt;code&gt;setPaintTicks&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="027f5f7c874f0b05685665c2baaf2e4a0856aaaa" translate="yes" xml:space="preserve">
          <source>In order for persistence mechanisms to function properly on BeanContextChild instances across a broad variety of scenarios, implementing classes of this interface are required to define as transient, any or all fields, or instance variables, that may contain, or represent, references to the nesting BeanContext instance or other resources obtained from the BeanContext via any unspecified mechanisms.</source>
          <target state="translated">광범위한 시나리오에서 BeanContextChild 인스턴스에서 지속성 메커니즘이 제대로 작동하려면 중첩에 대한 참조를 포함하거나 나타낼 수있는 임시, 모든 필드 또는 인스턴스 변수로 정의하려면이 인터페이스의 클래스를 구현해야합니다. BeanContext 인스턴스 또는 지정되지 않은 메커니즘을 통해 BeanContext에서 얻은 기타 자원.</target>
        </trans-unit>
        <trans-unit id="ca3336b46c543839bf0e83bd249246ba9ceac2c3" translate="yes" xml:space="preserve">
          <source>In order to align a &lt;code&gt;SequentialGroup&lt;/code&gt; along the baseline of a baseline aligned &lt;code&gt;ParallelGroup&lt;/code&gt; you need to specify which of the elements of the &lt;code&gt;SequentialGroup&lt;/code&gt; is used to determine the baseline. The element used to calculate the baseline is specified using one of the &lt;code&gt;add&lt;/code&gt; methods that take a &lt;code&gt;boolean&lt;/code&gt;. The last element added with a value of &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;useAsBaseline&lt;/code&gt; is used to calculate the baseline.</source>
          <target state="translated">기준선 정렬 &lt;code&gt;ParallelGroup&lt;/code&gt; 의 기준선을 따라 &lt;code&gt;SequentialGroup&lt;/code&gt; 을 정렬 하려면 기준선 을 결정하는 데 사용되는 &lt;code&gt;SequentialGroup&lt;/code&gt; 의 요소를 지정해야합니다 . 기준선을 계산하는 데 사용되는 요소 는 &lt;code&gt;boolean&lt;/code&gt; 을 사용하는 &lt;code&gt;add&lt;/code&gt; 메서드 중 하나를 사용하여 지정됩니다 . &lt;code&gt;useAsBaseline&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 값으로 추가 된 마지막 요소 는 기준선을 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eff19433d04180ca81ab86aab4794962f4daa886" translate="yes" xml:space="preserve">
          <source>In order to allow changes to be persisted back to the datasource to the originating tables, the &lt;code&gt;acceptChanges&lt;/code&gt; method should be used and called on a JoinRowSet object instance. Implementations can leverage the internal data and update tracking in their implementations to interact with the SyncProvider to persist any changes.</source>
          <target state="translated">변경 사항이 원래 테이블의 데이터 소스에 다시 유지되도록하려면 &lt;code&gt;acceptChanges&lt;/code&gt; 메서드를 사용하고 JoinRowSet 개체 인스턴스에서 호출해야합니다. 구현은 내부 데이터와 업데이트 추적을 활용하여 SyncProvider와 상호 작용하여 변경 사항을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a71a13ccef17116df35b112242d16e8495db897" translate="yes" xml:space="preserve">
          <source>In order to be able to populate itself with data from a database, a rowset needs to set a command property. This property is a query that is a &lt;code&gt;PreparedStatement&lt;/code&gt; object, which allows the query to have parameter placeholders that are set at run time, as opposed to design time. To set these placeholder parameters with values, a rowset provides setter methods for setting values of each data type, similar to the setter methods provided by the &lt;code&gt;PreparedStatement&lt;/code&gt; interface.</source>
          <target state="translated">데이터베이스의 데이터로 자신을 채울 수 있으려면 행 집합이 명령 속성을 설정해야합니다. 이 속성은 &lt;code&gt;PreparedStatement&lt;/code&gt; 개체 인 쿼리로, 디자인 타임이 아닌 런타임에 설정된 매개 변수 자리 표시자를 쿼리에 포함 할 수 있습니다. 이러한 자리 표시 자 매개 변수를 값으로 설정하기 위해 행 집합은 &lt;code&gt;PreparedStatement&lt;/code&gt; 인터페이스에서 제공하는 setter 메서드와 유사하게 각 데이터 형식의 값을 설정하는 setter 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0ba893cd9f06a3e56a7d28781c82514ba4b91f11" translate="yes" xml:space="preserve">
          <source>In order to be used with a selector, an instance of this class must first be</source>
          <target state="translated">선택자와 함께 사용하려면이 클래스의 인스턴스가 먼저</target>
        </trans-unit>
        <trans-unit id="b98e8db6ce4d9f52c1ffa4b7dff7087581ce0c75" translate="yes" xml:space="preserve">
          <source>In order to create a Cipher object, the application calls the Cipher's &lt;code&gt;getInstance&lt;/code&gt; method, and passes the name of the requested</source>
          <target state="translated">Cipher 객체를 작성하기 위해 애플리케이션은 Cipher의 &lt;code&gt;getInstance&lt;/code&gt; 메소드를 호출 하고 요청 된 이름을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="956aaf85b665f70ca7103583817b288193842ddf" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which collects a predetermined number of arguments, and whose type reflects this predetermined number, use &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;&lt;code&gt;asCollector&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">미리 결정된 수의 인수를 수집하고 유형이이 미리 결정된 수를 반영하는 수집 어댑터를 만들려면 &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt; &lt;code&gt;asCollector&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31c0dc79be70085d164b878d4cb4d45a32f8f726" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which collects a predetermined number of arguments, and whose type reflects this predetermined number, use &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;&lt;code&gt;asCollector&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">미리 결정된 수의 인수를 수집하고이 미리 결정된 수를 반영하는 유형의 수집 어댑터를 작성하려면 대신 &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt; &lt;code&gt;asCollector&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68bca81ab917de25475d73141757208db5018151" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which is not restricted to a particular number of collected arguments, use &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#withVarargs(boolean)&quot;&gt;&lt;code&gt;withVarargs&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">특정 수의 수집 된 인수로 제한되지 않는 수집 어댑터를 만들려면 &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#withVarargs(boolean)&quot;&gt; &lt;code&gt;withVarargs&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53922bd99347421945f987d026bbbefad691f64a" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which is not restricted to a particular number of collected arguments, use &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">특정 수의 수집 된 인수로 제한되지 않는 수집 어댑터를 작성하려면 대신 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d50236bff40706c4ebaf917ac3e33937a82d5dd3" translate="yes" xml:space="preserve">
          <source>In order to create an empty keystore, or if the keystore cannot be initialized from a stream, pass &lt;code&gt;null&lt;/code&gt; as the &lt;code&gt;stream&lt;/code&gt; argument.</source>
          <target state="translated">빈 키 저장소를 작성하거나 키 저장소를 스트림에서 초기화 할 수없는 경우 &lt;code&gt;stream&lt;/code&gt; 인수 로 &lt;code&gt;null&lt;/code&gt; 을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="4caf267f8fd9df9e41675d8b26bc879093570dba" translate="yes" xml:space="preserve">
          <source>In order to create an instance of &lt;code&gt;Cipher&lt;/code&gt;, which encapsulates an instance of this &lt;code&gt;CipherSpi&lt;/code&gt; class, an application calls one of the &lt;a href=&quot;cipher#getInstance(java.lang.String)&quot;&gt;&lt;code&gt;getInstance&lt;/code&gt;&lt;/a&gt; factory methods of the &lt;a href=&quot;cipher&quot;&gt;&lt;code&gt;Cipher&lt;/code&gt;&lt;/a&gt; engine class and specifies the requested</source>
          <target state="translated">이 &lt;code&gt;CipherSpi&lt;/code&gt; 클래스 의 인스턴스를 캡슐화하는 &lt;code&gt;Cipher&lt;/code&gt; 의 인스턴스를 생성하기 위해 애플리케이션 은 &lt;a href=&quot;cipher&quot;&gt; &lt;code&gt;Cipher&lt;/code&gt; &lt;/a&gt; 엔진 클래스 의 &lt;a href=&quot;cipher#getInstance(java.lang.String)&quot;&gt; &lt;code&gt;getInstance&lt;/code&gt; &lt;/a&gt; 팩토리 메소드 중 하나를 호출 하고 요청 된</target>
        </trans-unit>
        <trans-unit id="7b607b82a2b60c884e3dbe9e1575c5d5d265ec4d" translate="yes" xml:space="preserve">
          <source>In order to create an instance of &lt;code&gt;Cipher&lt;/code&gt;, which encapsulates an instance of this &lt;code&gt;CipherSpi&lt;/code&gt; class, an application calls one of the &lt;a href=&quot;cipher#getInstance-java.lang.String-&quot;&gt;&lt;code&gt;getInstance&lt;/code&gt;&lt;/a&gt; factory methods of the &lt;a href=&quot;cipher&quot;&gt;&lt;code&gt;Cipher&lt;/code&gt;&lt;/a&gt; engine class and specifies the requested</source>
          <target state="translated">&lt;code&gt;CipherSpi&lt;/code&gt; 클래스 의 인스턴스를 캡슐화하는 &lt;code&gt;Cipher&lt;/code&gt; 인스턴스를 작성하기 위해 애플리케이션 은 &lt;a href=&quot;cipher&quot;&gt; &lt;code&gt;Cipher&lt;/code&gt; &lt;/a&gt; 엔진 클래스 의 &lt;a href=&quot;cipher#getInstance-java.lang.String-&quot;&gt; &lt;code&gt;getInstance&lt;/code&gt; &lt;/a&gt; 팩토리 메소드 중 하나를 호출 하고 요청 된 요청을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="64007bb6dc6fcb0629d5ca08ad2441e78ed9b545" translate="yes" xml:space="preserve">
          <source>In order to do matching a user's preferred locales to a set of language tags, &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup. &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale. Matching is done case-insensitively. These matching mechanisms are described in the following sections.</source>
          <target state="translated">사용자가 선호하는 로캘을 언어 태그 집합과 일치시키기 위해 &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 언어 태그 일치는&lt;/a&gt; 필터링과 조회라는 두 가지 메커니즘을 정의합니다. &lt;em&gt;필터링&lt;/em&gt; 은 일치하는 모든 로캘을 가져 오는 데 사용되는 반면 &lt;em&gt;조회&lt;/em&gt; 는 가장 일치하는 로캘을 선택하는 것입니다. 대소 문자를 구분하지 않고 일치시킵니다. 이러한 일치 메커니즘은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f843ab19b8395ea6dc81b7d0ba4b053d8211f31d" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.postDeregister()&lt;/code&gt; in its own &lt;code&gt;postDeregister&lt;/code&gt; implementation.</source>
          <target state="translated">RequireModelMBean의 적절한 런타임 시맨틱을 보장하기 위해,이 메소드를 오버로드하거나 대체하는 RequiredModelMBean의 서브 클래스 는 자체 &lt;code&gt;postDeregister&lt;/code&gt; 구현 에서 &lt;code&gt;super.postDeregister()&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b37a3f7800e5557d0d455028524d0c955aed3436" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.postRegister(registrationDone)&lt;/code&gt; in its own &lt;code&gt;postRegister&lt;/code&gt; implementation.</source>
          <target state="translated">RequireModelMBean의 적절한 런타임 시맨틱을 보장하기 위해이 메소드를 오버로드하거나 대체하는 RequiredModelMBean의 서브 클래스 는 자체 &lt;code&gt;postRegister&lt;/code&gt; 구현 에서 &lt;code&gt;super.postRegister(registrationDone)&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e25f9de51dfcb2d1f611315c4d8da31e3829630" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.preDeregister()&lt;/code&gt; in its own &lt;code&gt;preDeregister&lt;/code&gt; implementation.</source>
          <target state="translated">RequireModelMBean의 적절한 런타임 시맨틱을 보장하기 위해,이 메소드를 오버로드하거나 대체하는 RequiredModelMBean의 서브 클래스 는 자체의 사전 등록 &lt;code&gt;preDeregister&lt;/code&gt; 구현 에서 &lt;code&gt;super.preDeregister()&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8be29ac641af15071548526b32a215df98b96343" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.preRegister(server, name)&lt;/code&gt; in its own &lt;code&gt;preRegister&lt;/code&gt; implementation.</source>
          <target state="translated">RequireModelMBean가 적절한 런타임 의미를 보장하기 위해,하는 RequiredModelMBean의 서브 클래스는 과부하 또는 호출 할 필요가이 메소드를 오버라이드 (override) &lt;code&gt;super.preRegister(server, name)&lt;/code&gt; 자체에서 &lt;code&gt;preRegister&lt;/code&gt; 구현입니다.</target>
        </trans-unit>
        <trans-unit id="1d55e2199f2b3cc24d9c9bff8ece9cf2b2665ec8" translate="yes" xml:space="preserve">
          <source>In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The &lt;code&gt;get&lt;/code&gt; method of a phantom reference always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">교정 가능 오브젝트가 그대로 유지되도록하기 위해 팬텀 참조의 참조는 검색되지 않을 수 있습니다. 팬텀 참조의 &lt;code&gt;get&lt;/code&gt; 메소드는 항상 &lt;code&gt;null&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a8da3317d1bcb4070918ebd341897147e3ca33b9" translate="yes" xml:space="preserve">
          <source>In order to explain the interaction between &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; calls, we must model the state transitions of a class value to take into account the alternation between uninitialized and initialized states. To do this, number these states sequentially from zero, and note that uninitialized (or removed) states are numbered with even numbers, while initialized (or re-initialized) states have odd numbers.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 과 &lt;code&gt;remove&lt;/code&gt; 호출 사이의 상호 작용을 설명하기 위해 초기화되지 않은 상태와 초기화 된 상태 사이의 교대를 고려하여 클래스 값의 상태 전이를 모델링해야합니다. 이렇게하려면 이러한 상태에 0부터 순차적으로 번호를 매기고 초기화되지 않은 (또는 제거 된) 상태에는 짝수로 번호가 매겨지며 초기화 된 (또는 다시 초기화 된) 상태에는 홀수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b805d69ab19ad3f3d3727f4943dc0a7712be9ed2" translate="yes" xml:space="preserve">
          <source>In order to maintain backward compatibility, the pack file's version is set to accommodate the class files present in the input JAR file. In other words, the pack file version will be the latest, if the class files are the latest and conversely the pack file version will be the oldest if the class file versions are also the oldest. For intermediate class file versions the corresponding pack file version will be used. For example: If the input JAR-files are solely comprised of 1.5 (or lesser) class files, a 1.5 compatible pack file is produced. This will also be the case for archives that have no class files. If the input JAR-files contains a 1.6 class file, then the pack file version will be set to 1.6.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해 팩 파일 버전은 입력 JAR 파일에있는 클래스 파일을 수용하도록 설정됩니다. 즉, 클래스 파일이 최신 버전 인 경우 팩 파일 버전이 최신 버전이되고 반대로 클래스 파일 버전도 최신 버전 인 경우 팩 파일 버전이 최신 버전이됩니다. 중간 클래스 파일 버전의 경우 해당 팩 파일 버전이 사용됩니다. 예를 들어, 입력 JAR 파일이 1.5 (또는 그 이하) 클래스 파일로만 구성된 경우 1.5 호환 팩 파일이 생성됩니다. 클래스 파일이없는 아카이브의 경우에도 마찬가지입니다. 입력 JAR 파일에 1.6 클래스 파일이 포함되어 있으면 팩 파일 버전이 1.6으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="40ebdaa097d4b8db005e51e585c4da7a094004d1" translate="yes" xml:space="preserve">
          <source>In order to maintain backward-compatibility, specifying a null String, or a String which is formatted incorrectly, returns null.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해 null String 또는 잘못된 형식의 String을 지정하면 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d65dfde4a90052c0dc072e889d8e093b67722e" translate="yes" xml:space="preserve">
          <source>In order to maintain compatibility with existing usage, Locale's constructors retain their behavior prior to the Java Runtime Environment version 1.7. The same is largely true for the &lt;code&gt;toString&lt;/code&gt; method. Thus Locale objects can continue to be used as they were. In particular, clients who parse the output of toString into language, country, and variant fields can continue to do so (although this is strongly discouraged), although the variant field will have additional information in it if script or extensions are present.</source>
          <target state="translated">기존 사용법과의 호환성을 유지하기 위해 로케일의 생성자는 Java Runtime Environment 버전 1.7 이전에 동작을 유지합니다. &lt;code&gt;toString&lt;/code&gt; 메소드도 마찬가지입니다 . 따라서 로케일 객체는 그대로 사용할 수 있습니다. 특히 toString의 출력을 언어, 국가 및 변형 필드로 구문 분석하는 클라이언트는 스크립트 또는 확장이 존재하는 경우 변형 필드에 추가 정보가 있지만 계속 그렇게 할 수 있습니다 (권장하지는 않지만).</target>
        </trans-unit>
        <trans-unit id="d246a53a5685a8f3eb185469887766737b2fe2fa" translate="yes" xml:space="preserve">
          <source>In order to obtain an invoker method for a particular access mode type, use &lt;a href=&quot;methodhandles#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;Lookup.findVirtual&lt;/code&gt;&lt;/a&gt; API is also able to return a method handle to call an access mode method for any specified access mode type and is equivalent in behaviour to &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">특정 액세스 모드 유형에 대한 호출자 메소드를 얻으려면 &lt;a href=&quot;methodhandles#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;Lookup.findVirtual&lt;/code&gt; &lt;/a&gt; API는 지정된 모든 액세스 모드 유형에 대한 액세스 모드 메서드를 호출하는 방법 핸들을 반환 할 수 있으며,에 행동에 해당합니다 &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce4ef230fb80e9e871692b3856524d75987acf48" translate="yes" xml:space="preserve">
          <source>In order to obtain an invoker method for a particular type descriptor, use &lt;a href=&quot;methodhandles#exactInvoker(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methodhandles#invoker(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.invoker&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;Lookup.findVirtual&lt;/code&gt;&lt;/a&gt; API is also able to return a method handle to call &lt;code&gt;invokeExact&lt;/code&gt; or plain &lt;code&gt;invoke&lt;/code&gt;, for any specified type descriptor .</source>
          <target state="translated">특정 유형 설명자에 대한 호출자 메소드를 얻으려면 &lt;a href=&quot;methodhandles#exactInvoker(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methodhandles#invoker(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.invoker&lt;/code&gt; 를 사용하십시오&lt;/a&gt; . &lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;Lookup.findVirtual&lt;/code&gt; &lt;/a&gt; API는 호출하는 방법 핸들을 반환 할 수있을 &lt;code&gt;invokeExact&lt;/code&gt; 또는 일반 &lt;code&gt;invoke&lt;/code&gt; 지정된 모든 유형의 설명을 위해.</target>
        </trans-unit>
        <trans-unit id="8c341ab99b93cd08ae1cd8fe6f9e4f20ad47ad03" translate="yes" xml:space="preserve">
          <source>In order to obtain an invoker method for a particular type descriptor, use &lt;a href=&quot;methodhandles#exactInvoker-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methodhandles#invoker-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;MethodHandles.invoker&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;methodhandles.lookup#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;Lookup.findVirtual&lt;/code&gt;&lt;/a&gt; API is also able to return a method handle to call &lt;code&gt;invokeExact&lt;/code&gt; or plain &lt;code&gt;invoke&lt;/code&gt;, for any specified type descriptor .</source>
          <target state="translated">특정 형식 설명 자의 호출자 메서드를 얻으려면 &lt;a href=&quot;methodhandles#exactInvoker-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methodhandles#invoker-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;MethodHandles.invoker&lt;/code&gt; 를 사용하십시오&lt;/a&gt; . &lt;a href=&quot;methodhandles.lookup#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;Lookup.findVirtual&lt;/code&gt; &lt;/a&gt; API는 호출하는 방법 핸들을 반환 할 수있을 &lt;code&gt;invokeExact&lt;/code&gt; 또는 일반 &lt;code&gt;invoke&lt;/code&gt; 지정된 모든 유형의 설명을 위해.</target>
        </trans-unit>
        <trans-unit id="810bead2e372dd39834a34f84480e291cf7bbae9" translate="yes" xml:space="preserve">
          <source>In order to pass a live link to a Remote object via a Drag and Drop &lt;code&gt;ACTION_LINK&lt;/code&gt; operation a Mime Content Type of application/x-java-remote-object should be used, where the representation class of the &lt;code&gt;DataFlavor&lt;/code&gt; represents the type of the &lt;code&gt;Remote&lt;/code&gt; interface to be transferred.</source>
          <target state="translated">드래그 앤 드롭 &lt;code&gt;ACTION_LINK&lt;/code&gt; 작업을 통해 원격 개체에 대한 라이브 링크를 전달하려면 Application / x-java-remote-object의 Mime 콘텐츠 유형을 사용해야합니다. 여기서 &lt;code&gt;DataFlavor&lt;/code&gt; 의 표현 클래스 는 &lt;code&gt;Remote&lt;/code&gt; 인터페이스 의 유형을 나타냅니다. 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="7caad4369bff00659280f907da0a4b977bd41341" translate="yes" xml:space="preserve">
          <source>In order to pass namespaced values to transformations, for instance when setting a property or a parameter on a &lt;a href=&quot;transformer&quot;&gt;&lt;code&gt;Transformer&lt;/code&gt;&lt;/a&gt; object, this specification defines that a String &quot;qname&quot; object parameter be passed as two-part string, the namespace URI enclosed in curly braces ({}), followed by the local name. If the qname has a null URI, then the String object only contains the local name. An application can safely check for a non-null URI by testing to see if the first character of the name is a '{' character.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;transformer&quot;&gt; &lt;code&gt;Transformer&lt;/code&gt; &lt;/a&gt; 객체 의 속성 또는 매개 변수를 설정할 때 네임 스페이스 값을 변환에 전달하기 위해이 사양에서는 String &quot;qname&quot;객체 매개 변수가 두 부분으로 된 문자열, 중괄호 ( {}), 로컬 이름이옵니다. qname에 널 URI가있는 경우 String 객체에는 로컬 이름 만 포함됩니다. 애플리케이션은 이름의 첫 번째 문자가 '{'문자인지 테스트하여 널이 아닌 URI를 안전하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ce62073d8b8243aff397ab4c4bebe1848f0dc18" translate="yes" xml:space="preserve">
          <source>In order to return the version number in a double, when there are more than two components (separated by '.' as defined above), only the first two components are retained. The resulting string is then passed to &lt;a href=&quot;../lang/double#valueOf(java.lang.String)&quot;&gt;&lt;code&gt;Double.valueOf(String)&lt;/code&gt;&lt;/a&gt; to generate version number, i.e. &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 개 이상의 구성 요소 (위에 정의 된대로 '.'로 구분)가있는 경우 버전 번호를 이중으로 반환하기 위해 처음 두 구성 요소 만 유지됩니다. 그런 다음 결과 문자열이 &lt;a href=&quot;../lang/double#valueOf(java.lang.String)&quot;&gt; &lt;code&gt;Double.valueOf(String)&lt;/code&gt; &lt;/a&gt; 에 전달되어 버전 번호, 즉 &lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="264efb423c60280550c1587a3402f655e3fa2c21" translate="yes" xml:space="preserve">
          <source>In order to supply a predicate for the &lt;code&gt;FilteredRowSet&lt;/code&gt;. this interface must be implemented. At this time, the JDBC RowSet Implementations (JSR-114) does not specify any standard filters definitions. By specifying a standard means and mechanism for a range of filters to be defined and deployed with both the reference and vendor implementations of the &lt;code&gt;FilteredRowSet&lt;/code&gt; interface, this allows for a flexible and application motivated implementations of &lt;code&gt;Predicate&lt;/code&gt; to emerge.</source>
          <target state="translated">&lt;code&gt;FilteredRowSet&lt;/code&gt; 에 대한 술어를 제공하기 위해 . 이 인터페이스를 구현해야합니다. 현재 JDBC RowSet 구현 (JSR-114)은 표준 필터 정의를 지정하지 않습니다. &lt;code&gt;FilteredRowSet&lt;/code&gt; 인터페이스 의 참조 및 공급 업체 구현과 함께 정의 및 배포 할 필터 범위에 대한 표준 수단과 메커니즘을 지정함으로써 유연하고 응용 프로그램에 의해 동기 부여 된 &lt;code&gt;Predicate&lt;/code&gt; 구현이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21171aa5fee1cb0c9ac069787ce53f4fb32d4b2d" translate="yes" xml:space="preserve">
          <source>In order to supply localized descriptions of elements and attributes, a &lt;code&gt;ResourceBundle&lt;/code&gt; with a base name of &lt;code&gt;this.getClass().getName() + &quot;Resources&quot;&lt;/code&gt; should be supplied via the usual mechanism used by &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;. Briefly, the subclasser supplies one or more additional classes according to a naming convention (by default, the fully-qualified name of the subclass extending &lt;code&gt;IIMetadataFormatImpl&lt;/code&gt;, plus the string &quot;Resources&quot;, plus the country, language, and variant codes separated by underscores). At run time, calls to &lt;code&gt;getElementDescription&lt;/code&gt; or &lt;code&gt;getAttributeDescription&lt;/code&gt; will attempt to load such classes dynamically according to the supplied locale, and will use either the element name, or the element name followed by a '/' character followed by the attribute name as a key. This key will be supplied to the &lt;code&gt;ResourceBundle&lt;/code&gt;'s &lt;code&gt;getString&lt;/code&gt; method, and the resulting localized description of the node or attribute is returned.</source>
          <target state="translated">요소와 속성 (A)의 국소 안내 공급하기 위해 &lt;code&gt;ResourceBundle&lt;/code&gt; 의베이스 이름 &lt;code&gt;this.getClass().getName() + &quot;Resources&quot;&lt;/code&gt; 에서 사용하는 통상의 메커니즘을 통해 공급되어야 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 의 . 간략하게, 서브 클래스는 명명 규칙에 따라 하나 이상의 추가 클래스를 제공합니다 (기본적으로 &lt;code&gt;IIMetadataFormatImpl&lt;/code&gt; 을 확장하는 서브 클래스의 완전한 이름 , 문자열 &quot;Resources&quot;및 밑줄로 구분 된 국가, 언어 및 변형 코드). . 런타임시 &lt;code&gt;getElementDescription&lt;/code&gt; 또는 &lt;code&gt;getAttributeDescription&lt;/code&gt; 을 호출합니다.제공된 로케일에 따라 이러한 클래스를 동적으로로드하려고 시도하고 요소 이름 또는 요소 이름 다음에 '/'문자 다음에 속성 이름을 키로 사용합니다. 이 키는 &lt;code&gt;ResourceBundle&lt;/code&gt; 의 &lt;code&gt;getString&lt;/code&gt; 메소드에 제공되어 결과적으로 지역화 된 노드 또는 속성에 대한 설명이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="014683c12502c542584ab5d18031c8c4346b0831" translate="yes" xml:space="preserve">
          <source>In order to support the platform-independent handling of action keys, the Java platform uses a few additional virtual key constants for functions that would otherwise have to be recognized by interpreting virtual key codes and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES is returned instead of VK_CONVERT with the ALT modifier.</source>
          <target state="translated">플랫폼 독립적 인 조치 키 처리를 지원하기 위해 Java 플랫폼은 가상 키 코드 및 수정자를 해석하여 인식해야하는 기능에 대해 몇 가지 추가 가상 키 상수를 사용합니다. 예를 들어 일본어 Windows 키보드의 경우 ALT 수정자가있는 VK_CONVERT 대신 VK_ALL_CANDIDATES가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b948f84b10418ce16ffc2d20202029b8cb2b47a0" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized CRL format supported by this certificate factory, each element in the returned collection view can be typecast to the corresponding CRL class. For example, if this certificate factory implements X.509 CRLs, the elements in the returned collection can be typecast to the &lt;code&gt;X509CRL&lt;/code&gt; class.</source>
          <target state="translated">이 인증서 팩토리가 지원하는 특수한 CRL 형식을 이용하기 위해 리턴 된 콜렉션보기의 각 요소는 해당 CRL 클래스로 유형 캐스트 ​​될 수 있습니다. 예를 들어이 인증서 팩토리가 X.509 CRL을 구현하면 반환 된 컬렉션의 요소를 &lt;code&gt;X509CRL&lt;/code&gt; 클래스 로 형식 캐스팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80e182cdf13fd4175ed2ea3f937aa79716e1a63a" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized CRL format supported by this certificate factory, the returned CRL object can be typecast to the corresponding CRL class. For example, if this certificate factory implements X.509 CRLs, the returned CRL object can be typecast to the &lt;code&gt;X509CRL&lt;/code&gt; class.</source>
          <target state="translated">이 증명서 팩토리가 지원하는 특수한 CRL 형식을 이용하기 위해서, 돌려 주어진 CRL 객체는 대응하는 CRL 클래스에 형태 캐스트 할 수 있습니다. 예를 들어이 인증서 팩토리가 X.509 CRL을 구현하면 반환 된 CRL 개체를 &lt;code&gt;X509CRL&lt;/code&gt; 클래스에 형식 캐스팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01401a15feb01ba8cb6b8c41aeda0f7926741999" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized certificate format supported by this certificate factory, each element in the returned collection view can be typecast to the corresponding certificate class. For example, if this certificate factory implements X.509 certificates, the elements in the returned collection can be typecast to the &lt;code&gt;X509Certificate&lt;/code&gt; class.</source>
          <target state="translated">이 인증서 팩토리가 지원하는 특수한 인증서 형식을 이용하기 위해 리턴 된 콜렉션보기의 각 요소를 해당 인증서 클래스로 유형 캐스트 ​​할 수 있습니다. 예를 들어이 인증서 팩토리가 X.509 인증서를 구현하면 반환 된 컬렉션의 요소를 &lt;code&gt;X509Certificate&lt;/code&gt; 클래스에 형식 캐스팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbcefe87046aa2f225b01d92aac3ff3e9e108c45" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized certificate format supported by this certificate factory, the returned certificate object can be typecast to the corresponding certificate class. For example, if this certificate factory implements X.509 certificates, the returned certificate object can be typecast to the &lt;code&gt;X509Certificate&lt;/code&gt; class.</source>
          <target state="translated">이 증명서 팩토리가 지원하는 특수한 증명서 형식을 이용하기 위해서, 돌려 주어진 증명서 오브젝트를 대응하는 증명서 클래스에 형태 캐스트 할 수 있습니다. 예를 들어이 인증서 팩토리가 X.509 인증서를 구현하면 반환 된 인증서 개체를 &lt;code&gt;X509Certificate&lt;/code&gt; 클래스에 형식 캐스팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4526bf5772005a098203e20083dabc3115a81c2b" translate="yes" xml:space="preserve">
          <source>In order to use the optimistic concurrency control routine, the &lt;code&gt;RIOptimisticProvider&lt;/code&gt; maintains both its current value and its original value (the value it had immediately preceding the current value). Note that if no changes have been made to the data in a &lt;code&gt;RowSet&lt;/code&gt; object, its current values and its original values are the same, both being the values with which the &lt;code&gt;RowSet&lt;/code&gt; object was initially populated. However, once any values in the &lt;code&gt;RowSet&lt;/code&gt; object have been changed, the current values and the original values will be different, though at this stage, the original values are still the initial values. With any subsequent changes to data in a &lt;code&gt;RowSet&lt;/code&gt; object, its original values and current values will still differ, but its original values will be the values that were previously the current values.</source>
          <target state="translated">낙관적 동시성 제어 루틴을 사용하기 위해 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 는 현재 값과 원래 값 (현재 값 바로 앞에 있던 값)을 모두 유지합니다. &lt;code&gt;RowSet&lt;/code&gt; 객체 의 데이터에 변경 사항이없는 경우 현재 값과 원래 값은 동일하며 둘 다 &lt;code&gt;RowSet&lt;/code&gt; 객체가 처음에 채워진 값입니다 . 그러나 &lt;code&gt;RowSet&lt;/code&gt; 개체의 값 이 변경되면 현재 값과 원래 값이 달라 지지만이 단계에서는 원래 값이 여전히 초기 값입니다. &lt;code&gt;RowSet&lt;/code&gt; 의 데이터에 대한 후속 변경 사항 개체의 원래 값과 현재 값은 여전히 ​​다르지만 원래 값은 이전에 현재 값이었던 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="9662b58c0cd62c1e89334c9b72a6441f78201246" translate="yes" xml:space="preserve">
          <source>In other respects, a &lt;code&gt;VolatileCallSite&lt;/code&gt; is interchangeable with &lt;code&gt;MutableCallSite&lt;/code&gt;.</source>
          <target state="translated">다른 측면에서 &lt;code&gt;VolatileCallSite&lt;/code&gt; 는 &lt;code&gt;MutableCallSite&lt;/code&gt; 와 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d25898f69afb15ff5dda349d53baa06f69e822e2" translate="yes" xml:space="preserve">
          <source>In other words for the best results use an LCD display with a digital display connector and specify the appropriate sub-pixel configuration.</source>
          <target state="translated">즉, 최상의 결과를 얻으려면 디지털 디스플레이 커넥터가있는 LCD 디스플레이를 사용하고 적절한 하위 픽셀 구성을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="460f5295687a3c368d02873df1172a34752df226" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method has exactly the same effect as invoking &lt;code&gt;new String(encode(src), StandardCharsets.ISO_8859_1)&lt;/code&gt;.</source>
          <target state="translated">다시 말해서,이 메소드의 호출은 &lt;code&gt;new String(encode(src), StandardCharsets.ISO_8859_1)&lt;/code&gt; 을 호출하는 것과 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="61a5057b103f32156f27c9e72a6cd22cf425b56f" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">즉, &lt;code&gt;dst.put(src)&lt;/code&gt; 형식의이 메소드를 호출 하면 루프와 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4a97cb7c262be521a458a66846dc006d3685b23d" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src, off, len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">즉, &lt;code&gt;dst.put(src, off, len)&lt;/code&gt; 형식의이 메소드를 호출 하면 루프와 정확히 동일한 효과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="12ad70fe4669e051fdd06980e62705cee95c894a" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src, start, end)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">즉, &lt;code&gt;dst.put(src, start, end)&lt;/code&gt; 형식의이 메소드를 호출 하면 루프와 정확히 동일한 효과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4ac9d9eff73538c3cdb11833e85cd96968621454" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">즉, &lt;code&gt;dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; 형식의이 메소드 호출은 루프와 정확히 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="356e5407810f1577f49a325b3dc66beaf9ce52a3" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src,&amp;nbsp;start,&amp;nbsp;end)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">즉, &lt;code&gt;dst.put(src,&amp;nbsp;start,&amp;nbsp;end)&lt;/code&gt; 형식의이 메서드 호출은 루프와 정확히 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1a3bcb813c7ffe2873d728a358d0e842e6cd293f" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;src.get(dst, off, len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">즉, &lt;code&gt;src.get(dst, off, len)&lt;/code&gt; 형식의이 메소드를 호출 하면 루프와 정확히 동일한 효과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f5e54dab6d94048e7a8977a11929efc013de3da6" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">즉, &lt;code&gt;src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; 형식의이 메서드 호출은 루프와 정확히 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="aea96e5b08f931cbd38dfab20fcd644c9067f3df" translate="yes" xml:space="preserve">
          <source>In other words, it does not follow symbolic links, and visits all levels of the file tree.</source>
          <target state="translated">즉, 기호 링크를 따르지 않고 모든 레벨의 파일 트리를 방문합니다.</target>
        </trans-unit>
        <trans-unit id="c6ec43bec0b5d5c5060ec2f33c0616c173c9f676" translate="yes" xml:space="preserve">
          <source>In other words, it visits all levels of the file tree.</source>
          <target state="translated">즉, 모든 레벨의 파일 트리를 방문합니다.</target>
        </trans-unit>
        <trans-unit id="1c26574665b279451ba4a488577fb7d302c5b7eb" translate="yes" xml:space="preserve">
          <source>In other words, the result is the same as the value of the expression:</source>
          <target state="translated">즉, 결과는 표현식의 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="505244a8ed297e57506cfc02395be44d1d47281d" translate="yes" xml:space="preserve">
          <source>In other words, this method returns a &lt;code&gt;Byte&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">즉,이 메소드는 다음 값과 동일한 &lt;code&gt;Byte&lt;/code&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1369f9d282c98b0db1a38a7bb381cd40063821b2" translate="yes" xml:space="preserve">
          <source>In other words, this method returns a &lt;code&gt;Long&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">즉,이 메소드는 다음 값과 동일한 &lt;code&gt;Long&lt;/code&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ba6028b1e1ba371422242dcd6a746ef6b3d2d511" translate="yes" xml:space="preserve">
          <source>In other words, this method returns a &lt;code&gt;Short&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">즉,이 메서드는 다음 값과 같은 &lt;code&gt;Short&lt;/code&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a00355912a405656ac89583daae0b5f9ae8b495" translate="yes" xml:space="preserve">
          <source>In other words, this method returns an &lt;code&gt;Integer&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">즉,이 메소드는 다음 값과 동일한 &lt;code&gt;Integer&lt;/code&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="97ff7fb7f0f6bafc2c9433156da41b6f41305d24" translate="yes" xml:space="preserve">
          <source>In particular this class implements certain required semantics of the &lt;code&gt;Doc&lt;/code&gt; specification as follows:</source>
          <target state="translated">특히이 클래스 는 다음과 같이 &lt;code&gt;Doc&lt;/code&gt; 사양 의 특정 필수 의미를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="41833e830e1de28bbdb99be4725e3eef06b2861c" translate="yes" xml:space="preserve">
          <source>In particular this class implements certain required semantics of the Doc specification as follows:</source>
          <target state="translated">특히이 클래스는 다음과 같이 Doc 스펙의 특정 필수 의미를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a948b83113ae7326141669ba70d964072cd3a296" translate="yes" xml:space="preserve">
          <source>In particular, for a mouse with one, two, or three buttons this method may return the following values:</source>
          <target state="translated">특히 버튼이 1 개, 2 개 또는 3 개인 마우스의 경우이 메서드는 다음 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81bb4c56da829ee7121302c977f07bc6625c5153" translate="yes" xml:space="preserve">
          <source>In particular, if the two ObjectName instances have different domains then their order is the lexicographical order of the domains. The ordering of the key property list remains unspecified.</source>
          <target state="translated">특히, 두 ObjectName 인스턴스의 도메인이 다른 경우 순서는 도메인의 사전 순서입니다. 키 속성 목록의 순서는 지정되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5894ea611cab3c030c00283ed49599698fcfcfad" translate="yes" xml:space="preserve">
          <source>In particular, operations on collection-views do</source>
          <target state="translated">특히 컬렉션 뷰에 대한 작업은</target>
        </trans-unit>
        <trans-unit id="8661f32f8775daadf95377f956a10599c2e08e36" translate="yes" xml:space="preserve">
          <source>In particular, the current thread is required to issue a fresh read of the target from memory, and must not fail to see a recent update to the target by another thread.</source>
          <target state="translated">특히, 현재 스레드는 메모리에서 대상을 새로 읽도록 요구되며 다른 스레드가 대상에 대한 최근 업데이트를 보지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="005c3ba59a8712aeaee68de4ef1f56b993202750" translate="yes" xml:space="preserve">
          <source>In particular, the current thread may choose to reuse the result of a previous read of the target from memory, and may fail to see a recent update to the target by another thread.</source>
          <target state="translated">특히, 현재 스레드는 메모리에서 대상을 이전에 읽은 결과를 재사용하도록 선택할 수 있으며 다른 스레드가 대상에 대한 최근 업데이트를 보지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0c491100aaf4dd16c8cf6cf2c75893b008214b" translate="yes" xml:space="preserve">
          <source>In particular, the model makes a distinction between static language constructs, like the &lt;a href=&quot;element/package-summary&quot;&gt;element&lt;/a&gt; representing &lt;code&gt;java.util.Set&lt;/code&gt;, and the family of &lt;a href=&quot;type/package-summary&quot;&gt;types&lt;/a&gt; that may be associated with an element, like the raw type &lt;code&gt;java.util.Set&lt;/code&gt;, &lt;code&gt;
 java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt;, and &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">특히,이 모델은 &lt;code&gt;java.util.Set&lt;/code&gt; 을 나타내는 &lt;a href=&quot;element/package-summary&quot;&gt;요소&lt;/a&gt; 와 같은 정적 언어 구조 와&lt;a href=&quot;type/package-summary&quot;&gt;&lt;/a&gt; 원시 유형 &lt;code&gt;java.util.Set&lt;/code&gt; , &lt;code&gt; java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt; 과 같이 요소와 연관 될 수있는 유형 합니다 . Set &amp;lt;String&amp;gt; 및 &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="397ea1619f838bf6759858af4a9e7980654e1c14" translate="yes" xml:space="preserve">
          <source>In particular, the model makes a distinction between static language constructs, like the &lt;a href=&quot;element/package-summary&quot;&gt;element&lt;/a&gt; representing &lt;code&gt;java.util.Set&lt;/code&gt;, and the family of &lt;a href=&quot;type/package-summary&quot;&gt;types&lt;/a&gt; that may be associated with an element, like the raw type &lt;code&gt;java.util.Set&lt;/code&gt;, &lt;code&gt;java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt;, and &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">특히이 모델은 &lt;code&gt;java.util.Set&lt;/code&gt; 을 나타내는 &lt;a href=&quot;element/package-summary&quot;&gt;요소&lt;/a&gt; 와 같은 정적 언어 구조 와 원시 유형 &lt;code&gt;java.util.Set&lt;/code&gt; , &lt;code&gt;java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt; 과 같이 요소와 연관 될 수있는 &lt;a href=&quot;type/package-summary&quot;&gt;유형&lt;/a&gt; 의 패밀리를 구별 합니다. &amp;lt;&amp;lt;&amp;gt; 및 &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f662f0574d9aac457b04052d9413b3d9616ae3c4" translate="yes" xml:space="preserve">
          <source>In particular, the resolver is only called for functions in an another namespace (functions with an explicit prefix). This means that you cannot use the &lt;code&gt;XPathFunctionResolver&lt;/code&gt; to implement specifications like &lt;a href=&quot;http://www.w3.org/TR/xmldsig-core/&quot;&gt;XML-Signature Syntax and Processing&lt;/a&gt; which extend the function library of XPath 1.0 in the same namespace. This is a consequence of the design of the resolver.</source>
          <target state="translated">특히 리졸버는 다른 네임 스페이스의 함수 (명시적인 접두사가있는 함수)에 대해서만 호출됩니다. 즉 , 동일한 네임 스페이스에서 XPath 1.0의 함수 라이브러리를 확장하는 &lt;a href=&quot;http://www.w3.org/TR/xmldsig-core/&quot;&gt;XML 서명 구문 및 처리와&lt;/a&gt; 같은 사양을 구현 하는 데 &lt;code&gt;XPathFunctionResolver&lt;/code&gt; 를 사용할 수 없습니다 . 이것은 리졸버 설계의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="6d59d813a2d2c234fbceea2f8ac2972003697777" translate="yes" xml:space="preserve">
          <source>In particular, this class handles most or all of the details of byte order interpretation, buffering, mark/reset, discarding, closing, and disposing.</source>
          <target state="translated">특히이 클래스는 바이트 순서 해석, 버퍼링, 마크 / 리셋, 버림, 닫기 및 처리에 대한 대부분 또는 모든 세부 사항을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9e3426680847347aed69bf7f9bd9aa973db72a2e" translate="yes" xml:space="preserve">
          <source>In particular, this interface is intended to be a common abstraction for constructs that have different formats but important common uses. For example, different types of certificates, such as X.509 certificates and PGP certificates, share general certificate functionality (the need to encode and decode certificates) and some types of information, such as a public key, the principal whose key it is, and the guarantor guaranteeing that the public key is that of the specified principal. So an implementation of X.509 certificates and an implementation of PGP certificates can both utilize the Certificate interface, even though their formats and additional types and amounts of information stored are different.</source>
          <target state="translated">특히,이 인터페이스는 형식은 다르지만 중요한 공통 용도로 사용되는 구성에 대한 공통 추상화입니다. 예를 들어, X.509 인증서 및 PGP 인증서와 같은 다른 유형의 인증서는 일반 인증서 기능 (인증서를 인코딩 및 디코딩해야 함)과 공개 키와 같은 일부 유형의 정보를 공유합니다. 보증인은 공개 키가 지정된 보안 주체의 키임을 보증합니다. 따라서 X.509 인증서 구현과 PGP 인증서 구현은 형식과 추가 된 유형 및 저장된 정보량이 다르더라도 인증서 인터페이스를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e10efdd6b0f7e97bb954a45d7a40fb01f574c42" translate="yes" xml:space="preserve">
          <source>In particular, unrelated threads may fail to see the updated target until they perform a read from memory. Stronger guarantees can be created by putting appropriate operations into the bootstrap method and/or the target methods used at any given call site.</source>
          <target state="translated">특히 관련없는 스레드는 메모리에서 읽기를 수행 할 때까지 업데이트 된 대상을 보지 못할 수 있습니다. 주어진 호출 사이트에서 사용되는 부트 스트랩 방법 및 / 또는 대상 방법에 적절한 작업을 수행함으로써보다 강력한 보증을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8f69fa80998eb9c6dbcb7b318ca2c3c6434c7cd" translate="yes" xml:space="preserve">
          <source>In passing these statements to the output stream, where they will be executed, side effects are made to the &lt;code&gt;newInstance&lt;/code&gt;. In most cases this allows the problem of properties whose values depend on each other to actually help the serialization process by making the number of statements that need to be written to the output smaller. In general, the problem of handling interdependent properties is reduced to that of finding an order for the properties in a class such that no property value depends on the value of a subsequent property.</source>
          <target state="translated">이러한 명령문을 출력 스트림으로 전달하면 실행 스트림에서 &lt;code&gt;newInstance&lt;/code&gt; 에 부작용이 발생합니다 . 대부분의 경우 이는 서로 다른 값을 갖는 속성의 문제로 인해 출력에 기록해야하는 명령문 수를 더 작게하여 직렬화 프로세스를 실제로 도울 수 있습니다. 일반적으로, 상호 의존적 속성을 다루는 문제는 클래스의 속성에 대한 순서를 찾는 문제로 감소되어 속성 값이 후속 속성의 값에 의존하지 않도록한다.</target>
        </trans-unit>
        <trans-unit id="4594727a51da542b6483bfc22c69e4100582700e" translate="yes" xml:space="preserve">
          <source>In performing an operation on a name that spans multiple namespaces, a context from one naming system may need to pass the operation on to the next naming system. The context implementation does this by first constructing a &lt;code&gt;CannotProceedException&lt;/code&gt; containing information pinpointing how far it has proceeded. It then obtains a continuation context from JNDI by calling &lt;code&gt;getContinuationContext&lt;/code&gt;. The context implementation should then resume the context operation by invoking the same operation on the continuation context, using the remainder of the name that has not yet been resolved.</source>
          <target state="translated">여러 네임 스페이스에 걸쳐있는 이름에서 작업을 수행 할 때 한 명명 시스템의 컨텍스트가 작업을 다음 명명 시스템으로 전달해야 할 수 있습니다. 컨텍스트 구현은 먼저 진행 거리를 나타내는 정보를 포함 하는 &lt;code&gt;CannotProceedException&lt;/code&gt; 을 구성하여 이를 수행합니다. 그런 다음 &lt;code&gt;getContinuationContext&lt;/code&gt; 를 호출하여 JNDI로부터 연속 컨텍스트를 얻습니다 . 그런 다음 컨텍스트 구현은 아직 해결되지 않은 나머지 이름을 사용하여 연속 컨텍스트에서 동일한 조작을 호출하여 컨텍스트 조작을 재개해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f56d490a4b579758b87f7072b8c010487f0805a" translate="yes" xml:space="preserve">
          <source>In practical terms, the &lt;code&gt;Chronology&lt;/code&gt; instance also acts as a factory. The &lt;a href=&quot;#of(java.lang.String)&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt; method allows an instance to be looked up by identifier, while the &lt;a href=&quot;#ofLocale(java.util.Locale)&quot;&gt;&lt;code&gt;ofLocale(Locale)&lt;/code&gt;&lt;/a&gt; method allows lookup by locale.</source>
          <target state="translated">실제적으로 &lt;code&gt;Chronology&lt;/code&gt; 인스턴스는 공장 역할도합니다. 그만큼&lt;a href=&quot;#of(java.lang.String)&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt; 방법은 동시에 인스턴스가 식별자에 의해 조회 될 수 있도록&lt;a href=&quot;#ofLocale(java.util.Locale)&quot;&gt; &lt;code&gt;ofLocale(Locale)&lt;/code&gt; &lt;/a&gt; 방법 로케일 조회 수있다.</target>
        </trans-unit>
        <trans-unit id="12abb72312e94f1909297d8e075f5705219a1c91" translate="yes" xml:space="preserve">
          <source>In practical terms, the &lt;code&gt;Chronology&lt;/code&gt; instance also acts as a factory. The &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt; method allows an instance to be looked up by identifier, while the &lt;a href=&quot;chronology#ofLocale-java.util.Locale-&quot;&gt;&lt;code&gt;ofLocale(Locale)&lt;/code&gt;&lt;/a&gt; method allows lookup by locale.</source>
          <target state="translated">실질적으로 &lt;code&gt;Chronology&lt;/code&gt; 인스턴스도 팩토리 역할을합니다. &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt; 방법은 동시에 인스턴스가 식별자에 의해 조회 될 수 있도록 &lt;a href=&quot;chronology#ofLocale-java.util.Locale-&quot;&gt; &lt;code&gt;ofLocale(Locale)&lt;/code&gt; &lt;/a&gt; 방법 로케일 조회 수있다.</target>
        </trans-unit>
        <trans-unit id="44b3d89c096779e08fc6e85e71fb403f5510a848" translate="yes" xml:space="preserve">
          <source>In practice, &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;nextSibling&lt;/code&gt; should be a &lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; node, a &lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt;&lt;code&gt;DocumentFragment&lt;/code&gt;&lt;/a&gt; node, or a &lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; node. In other words, a node that accepts children.</source>
          <target state="translated">실제로 &lt;code&gt;node&lt;/code&gt; 와 &lt;code&gt;nextSibling&lt;/code&gt; 은 &lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 노드 여야합니다 .&lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt; &lt;code&gt;DocumentFragment&lt;/code&gt; &lt;/a&gt; 노드 또는&lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 노드합니다. 즉, 자식을 받아들이는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="e66b20b0561cf0c6243ea2c6668f24f53e4932e9" translate="yes" xml:space="preserve">
          <source>In practice, the difference between a plain &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;
      Integer&lt;/code&gt;, etc, does not show up because operations in the JMX API are always on Java objects, not primitives. However, the difference &lt;em&gt;does&lt;/em&gt; show up with arrays.</source>
          <target state="translated">실제로 일반 &lt;code&gt;int&lt;/code&gt; 의 차이점 JMX API의 작업은 기본이 아닌 Java 객체에 항상 있기 때문에 및 &lt;code&gt; Integer&lt;/code&gt; 등 나타나지 않습니다. 그러나 차이점 &lt;em&gt;은&lt;/em&gt; 배열에서 나타납니다.</target>
        </trans-unit>
        <trans-unit id="796f045d0c1c5aaebd129b5c1ce4d6bab163576c" translate="yes" xml:space="preserve">
          <source>In practice, the difference between a plain &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;Integer&lt;/code&gt;, etc, does not show up because operations in the JMX API are always on Java objects, not primitives. However, the difference &lt;em&gt;does&lt;/em&gt; show up with arrays.</source>
          <target state="translated">실제로, JMX API의 조작은 항상 기본 요소가 아닌 Java 오브젝트에 있기 때문에 일반 &lt;code&gt;int&lt;/code&gt; 및 &lt;code&gt;Integer&lt;/code&gt; 등 의 차이는 표시되지 않습니다. 그러나 차이점 &lt;em&gt;은&lt;/em&gt; 배열과 함께 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3ec9d5278256fac554e36e5f309da0d6e49663e6" translate="yes" xml:space="preserve">
          <source>In practice, the node should be a &lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; node, a &lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt;&lt;code&gt;DocumentFragment&lt;/code&gt;&lt;/a&gt; node, or a &lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; node. In other words, a node that accepts children.</source>
          <target state="translated">실제로 노드는 &lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 노드 여야합니다 .&lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt; &lt;code&gt;DocumentFragment&lt;/code&gt; &lt;/a&gt; 노드 또는&lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 노드합니다. 즉, 자식을 받아들이는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="8ae5216b4c4be405db42d2e5ded9009a76bacd15" translate="yes" xml:space="preserve">
          <source>In rare cases, TCP servers need to act in the SSL client mode on newly accepted connections. For example, FTP clients acquire server sockets and listen there for reverse connections from the server. An FTP client would use an SSLServerSocket in &quot;client&quot; mode to accept the reverse connection while the FTP server uses an SSLSocket with &quot;client&quot; mode disabled to initiate the connection. During the resulting handshake, existing SSL sessions may be reused.</source>
          <target state="translated">드문 경우이지만 TCP 서버는 새로 수락 된 연결에서 SSL 클라이언트 모드로 작동해야합니다. 예를 들어, FTP 클라이언트는 서버 소켓을 확보하고 서버에서 역방향 연결을 수신합니다. FTP 클라이언트는 &quot;클라이언트&quot;모드에서 SSLServerSocket을 사용하여 역방향 연결을 수락하지만 FTP 서버는 &quot;클라이언트&quot;모드가 비활성화 된 SSLSocket을 사용하여 연결을 시작합니다. 결과 핸드 셰이크 중에 기존 SSL 세션이 재사용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7834b390e944da71c10ffa54e9f786537a580ef7" translate="yes" xml:space="preserve">
          <source>In rare circumstances the virtual machine may</source>
          <target state="translated">드문 경우지만 가상 머신이</target>
        </trans-unit>
        <trans-unit id="f2bf8cc36315c630d7cdf208f95ef8dbe558b95e" translate="yes" xml:space="preserve">
          <source>In release 1.4, the focus subsystem was rearchitected. For more information, see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt; How to Use the Focus Subsystem&lt;/a&gt;, a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</source>
          <target state="translated">릴리스 1.4에서는 포커스 하위 시스템이 재 설계되었습니다. 자세한 내용은&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;&lt;/a&gt; 은 &lt;em&gt;The Java Tutorial&lt;/em&gt; 의 섹션 인 How to Use the Focus Subsystem을 .</target>
        </trans-unit>
        <trans-unit id="177a25f922fe44253f5e5b34f55196c5dbfa3006" translate="yes" xml:space="preserve">
          <source>In server mode, unless the return &lt;a href=&quot;../../../java/util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; is empty, the server should use the requested server names to guide its selection of an appropriate authentication certificate, and/or other aspects of security policy.</source>
          <target state="translated">서버 모드에서 리턴 &lt;a href=&quot;../../../java/util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 이 비어 있지 않으면 서버는 요청 된 서버 이름을 사용하여 적절한 인증 인증서 및 / 또는 보안 정책의 다른 측면을 선택하도록 안내해야합니다.</target>
        </trans-unit>
        <trans-unit id="acaf40d027afc81cab351c04ea9fa2f4414092e5" translate="yes" xml:space="preserve">
          <source>In simple terms, pressing and releasing the mouse over a regular button triggers the button and causes and &lt;code&gt;ActionEvent&lt;/code&gt; to be fired. The same behavior can be produced via a keyboard key defined by the look and feel of the button (typically the SPACE BAR). Pressing and releasing this key while the button has focus will give the same results. For check boxes and radio buttons, the mouse or keyboard equivalent sequence just described causes the button to become selected.</source>
          <target state="translated">간단히 말해서 일반 버튼 위에 마우스를 눌렀다 놓으면 버튼이 트리거되고 &lt;code&gt;ActionEvent&lt;/code&gt; 가 시작 됩니다. 버튼의 모양과 느낌 (일반적으로 스페이스 바)으로 정의 된 키보드 키를 통해 동일한 동작을 생성 할 수 있습니다. 버튼에 포커스가있는 동안이 키를 눌렀다 놓으면 동일한 결과가 나타납니다. 확인란 및 라디오 단추의 경우 방금 설명한 마우스 또는 키보드에 해당하는 시퀀스로 인해 단추가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7a5c60686b7505cac148f61afec24255ceeab119" translate="yes" xml:space="preserve">
          <source>In some (uncommon) situations, a single SQL statement may return multiple result sets and/or update counts. Normally you can ignore this unless you are (1) executing a stored procedure that you know may return multiple results or (2) you are dynamically executing an unknown SQL string.</source>
          <target state="translated">일부 (흔하지 않은) 상황에서는 단일 SQL 문이 여러 결과 집합 및 / 또는 업데이트 수를 반환 할 수 있습니다. 일반적으로 (1) 여러 결과를 반환 할 수있는 저장 프로 시저를 실행하거나 (2) 알 수없는 SQL 문자열을 동적으로 실행하지 않는 한 이것을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b3839dadf4c5e906a621c1be0df22a48774d481" translate="yes" xml:space="preserve">
          <source>In some cases use of this permission may affect other applications because manipulation of a mixer affects the audio for all lines using that mixer. This permission can enable an applet or application to eavesdrop on a user.</source>
          <target state="translated">믹서를 조작하면 해당 믹서를 사용하는 모든 회선의 오디오에 영향을 미치기 때문에이 권한을 사용하면 다른 응용 프로그램에 영향을 줄 수 있습니다. 이 권한으로 애플릿 또는 응용 프로그램이 사용자를 도청 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a848177f0354f031651d0cc5a0c1339e1883a198" translate="yes" xml:space="preserve">
          <source>In some cases use of this permission may affect other applications because the audio from one line may be mixed with other audio being played on the system, or because manipulation of a mixer affects the audio for all lines using that mixer.</source>
          <target state="translated">경우에 따라이 권한을 사용하면 한 라인의 오디오가 시스템에서 재생중인 다른 오디오와 혼합 될 수 있거나 믹서를 조작하면 해당 믹서를 사용하는 모든 라인의 오디오에 영향을 미치기 때문에 다른 응용 프로그램에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5afcd4bc923f5719f106155a0a4d4e2a58c6b53a" translate="yes" xml:space="preserve">
          <source>In some cases, a non-blocking read (or skip) may appear to be blocked when it is merely slow, for example when reading large files over slow networks.</source>
          <target state="translated">경우에 따라 비 차단 읽기 (또는 건너 뛰기)는 속도가 느릴 때 (예 : 느린 네트워크에서 큰 파일을 읽는 경우) 차단 된 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3fa68306b77ec8a7b03a1c5eb53b2702e05a9e8" translate="yes" xml:space="preserve">
          <source>In some cases, access between nested classes is obtained by the Java compiler by creating an wrapper method to access a private method of another class in the same top-level declaration. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C.D.E&lt;/code&gt;, or &lt;code&gt;C.B&lt;/code&gt;, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to those private members. A workaround for this limitation is the &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</source>
          <target state="translated">경우에 따라 중첩 클래스 간의 액세스는 동일한 최상위 레벨 선언에서 다른 클래스의 개인용 메소드에 액세스하기위한 랩퍼 메소드를 작성하여 Java 컴파일러에 의해 확보됩니다. 예를 들어, 중첩 클래스 &lt;code&gt;C.D&lt;/code&gt; 는 &lt;code&gt;C&lt;/code&gt; , &lt;code&gt;C.D.E&lt;/code&gt; 또는 &lt;code&gt;C.B&lt;/code&gt; 와 같은 다른 관련 클래스 내의 개인 멤버에 액세스 할 수 있지만 Java 컴파일러는 해당 관련 클래스에서 랩퍼 메소드를 생성해야합니다. 이러한 경우 &lt;code&gt;C.E&lt;/code&gt; 의 &lt;code&gt;Lookup&lt;/code&gt; 오브젝트는 해당 개인 구성원이 할 수 없습니다. 이 제한에 대한 해결 방법은 &lt;code&gt;C.E&lt;/code&gt; 의 조회를 특별한 권한 상승없이 다른 클래스 중 하나로 변환 할 수 있는 &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt; 메서드 입니다.</target>
        </trans-unit>
        <trans-unit id="d5cbaf96fc9f77ef0b3f4f97b798f3b481096d3a" translate="yes" xml:space="preserve">
          <source>In some cases, adding the amount can cause the resulting date to become invalid. For example, adding one month to 31st January would result in 31st February. In cases like this, the unit is responsible for resolving the date. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">경우에 따라 금액을 추가하면 결과 날짜가 유효하지 않을 수 있습니다. 예를 들어 1 월 31 일에 1 개월을 추가하면 2 월 31 일이됩니다. 이와 같은 경우, 장치는 날짜 해결을 담당합니다. 일반적으로이 예에서는 이전 유효 날짜를 선택합니다.이 날짜는 2 월의 마지막 유효 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="79dbde154ada935a1511e0a5ad056015e1ce81bb" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then adding one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">경우에 따라 필드 변경이 완전히 정의되지 않은 경우가 있습니다. 예를 들어, 대상 객체가 1 월 31 일을 나타내는 날짜 인 경우 1 개월을 추가하는 것은 명확하지 않습니다. 이와 같은 경우, 해당 필드는 결과를 해결해야합니다. 일반적으로이 예에서는 이전 유효 날짜를 선택합니다.이 날짜는 2 월의 마지막 유효 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="bd10444116ccb781851e313beb7e47d91bc0acac" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then changing the month to February would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">경우에 따라 필드 변경이 완전히 정의되지 않은 경우가 있습니다. 예를 들어 대상 객체가 1 월 31 일을 나타내는 날짜 인 경우 월을 2 월로 변경하는 것은 명확하지 않습니다. 이와 같은 경우, 해당 필드는 결과를 해결해야합니다. 일반적으로이 예에서는 이전 유효 날짜를 선택합니다.이 날짜는 2 월의 마지막 유효 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="d624716cd77a5fbae34ea08ee2b7ffe4d4819511" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then changing the month to February would be unclear. In cases like this, the implementation is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">경우에 따라 필드 변경이 완전히 정의되지 않은 경우가 있습니다. 예를 들어 대상 객체가 1 월 31 일을 나타내는 날짜 인 경우 월을 2 월로 변경하는 것은 명확하지 않습니다. 이와 같은 경우 구현은 결과 해결을 담당합니다. 일반적으로이 예에서는 이전 유효 날짜를 선택합니다.이 날짜는 2 월의 마지막 유효 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="c3b9cc17b785ff40a460004eb2e4df03a0601252" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st March, then subtracting one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">경우에 따라 필드 변경이 완전히 정의되지 않은 경우가 있습니다. 예를 들어, 대상 객체가 3 월 31 일을 나타내는 날짜 인 경우 한 달 빼는 것은 명확하지 않습니다. 이와 같은 경우, 해당 필드는 결과를 해결해야합니다. 일반적으로이 예에서는 이전 유효 날짜를 선택합니다.이 날짜는 2 월의 마지막 유효 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="9633ad6bd00dc94ae7a6b39be76eec4e5fff7990" translate="yes" xml:space="preserve">
          <source>In some cases, changing the specified field can cause the resulting date to become invalid, such as changing the month from 31st January to February would make the day-of-month invalid. In cases like this, the field is responsible for resolving the date. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">경우에 따라 지정된 필드를 변경하면 결과 날짜가 유효하지 않게 될 수 있습니다. 예를 들어 1 월 31 일에서 2 월로 월을 변경하면 월이 유효하지 않게됩니다. 이와 같은 경우, 해당 날짜를 해결할 책임이 필드에 있습니다. 일반적으로이 예에서는 이전 유효 날짜를 선택합니다.이 날짜는 2 월의 마지막 유효 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="463fb2df4e64e20bb07cdf986fe873e31fa41b06" translate="yes" xml:space="preserve">
          <source>In some cases, changing the specified field can cause the resulting date-time to become invalid, such as changing the month from 31st January to February would make the day-of-month invalid. In cases like this, the field is responsible for resolving the date. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">경우에 따라 지정된 필드를 변경하면 결과 날짜 시간이 유효하지 않게 될 수 있습니다. 예를 들어 월을 1 월 31 일에서 2 월로 변경하면 월이 유효하지 않게됩니다. 이와 같은 경우, 해당 날짜를 해결할 책임이 필드에 있습니다. 일반적으로이 예에서는 이전 유효 날짜를 선택합니다.이 날짜는 2 월의 마지막 유효 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="76ad22f41ac4d331fd71edfa827b6a2c78d142d0" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than a keystore and password may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; as defined by the provider. The provider can then call the specified methods in the &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; implementation to obtain the needed information.</source>
          <target state="translated">경우에 따라 공급자가 키 저장소 및 비밀번호 이외의 초기화 매개 변수가 필요할 수 있습니다. 특정 제공자의 사용자는 제공자가 정의한 적절한 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 의 구현을 전달해야합니다 . 그런 다음 공급자는 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 구현 에서 지정된 메소드를 호출 하여 필요한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec5bdcecc9af12d3c9fc36893ac4dcc77cab3ee" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than a keystore and password may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; as defined by the provider. The provider can then call the specified methods in the ManagerFactoryParameters implementation to obtain the needed information.</source>
          <target state="translated">경우에 따라 공급자가 키 저장소 및 비밀번호 이외의 초기화 매개 변수가 필요할 수 있습니다. 특정 제공자의 사용자는 제공자가 정의한 적절한 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 의 구현을 전달해야합니다 . 그런 다음 공급자는 ManagerFactoryParameters 구현에서 지정된 메소드를 호출하여 필요한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee40fd23ac237d6d567e29c474e7a44c66c598d" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than a keystore may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; as defined by the provider. The provider can then call the specified methods in the &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; implementation to obtain the needed information.</source>
          <target state="translated">키 스토어 이외의 초기화 파라미터가 프로 바이더에 의해 필요한 경우가 있습니다. 특정 제공자의 사용자는 제공자가 정의한 적절한 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 의 구현을 전달해야합니다 . 그런 다음 공급자는 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 구현 에서 지정된 메소드를 호출 하여 필요한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3943e5fcf21e0c58931ef360cbd3da2eb118dd9f" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than keystores may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate sub-interface of this class as defined by the provider. The provider can then call the specified methods in the &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; implementation to obtain the needed information.</source>
          <target state="translated">키 스토어 이외의 초기화 파라미터는 프로 바이더가 필요로하는 경우가 있습니다. 특정 제공자의 사용자는 제공자가 정의한대로이 클래스의 적절한 하위 인터페이스 구현을 전달해야합니다. 그런 다음 공급자는 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 구현 에서 지정된 메소드를 호출 하여 필요한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="908a46abad9690abd6da29405c9fa1fb549231ef" translate="yes" xml:space="preserve">
          <source>In some contexts, an attribute set is read-only, which means that the client is only allowed to examine an attribute set's contents but not change them. In other contexts, the attribute set is read-write, which means that the client is allowed both to examine and to change an attribute set's contents. For a read-only attribute set, calling a mutating operation throws an &lt;code&gt;UnmodifiableSetException&lt;/code&gt;.</source>
          <target state="translated">일부 컨텍스트에서 속성 세트는 읽기 전용이므로 클라이언트는 속성 세트의 내용 만 검사 할 수는 있지만 변경할 수는 없습니다. 다른 컨텍스트에서 속성 세트는 읽기 / 쓰기이므로 클라이언트가 속성 세트의 내용을 검사하고 변경할 수 있습니다. 읽기 전용 속성 세트의 경우 변경 작업을 호출하면 &lt;code&gt;UnmodifiableSetException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="cac15a18bb25793bfe2d1768e0c7a9131fa203a2" translate="yes" xml:space="preserve">
          <source>In some contexts, the client is only allowed to examine an attribute set's contents but not change them (the set is read-only). In other places, the client is allowed both to examine and to change an attribute set's contents (the set is read-write). For a read-only attribute set, calling a mutating operation throws an &lt;code&gt;UnmodifiableSetException&lt;/code&gt;.</source>
          <target state="translated">일부 컨텍스트에서 클라이언트는 속성 세트의 내용을 검사 할 수만 있고 변경할 수는 없습니다 (세트는 읽기 전용 임). 다른 곳에서는 클라이언트가 속성 세트의 내용을 검사하고 변경할 수 있습니다 (세트는 읽기-쓰기 임). 읽기 전용 속성 집합의 경우 변경 작업을 호출하면 &lt;code&gt;UnmodifiableSetException&lt;/code&gt; 이 발생합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="ce412aedb62ca8d47d285d3295efb33f716cb96d" translate="yes" xml:space="preserve">
          <source>In some contexts, the client is only allowed to examine an attribute set's contents but not change them (the set is read-only). In other places, the client is allowed both to examine and to change an attribute set's contents (the set is read-write). For a read-only attribute set, calling a mutating operation throws an UnmodifiableSetException.</source>
          <target state="translated">일부 컨텍스트에서 클라이언트는 속성 세트의 내용 만 검사 할 수 있지만 변경하지는 않습니다 (세트는 읽기 전용입니다). 다른 곳에서 클라이언트는 속성 세트의 내용을 검사하고 변경할 수 있습니다 (세트는 읽기 / 쓰기). 읽기 전용 특성 집합의 경우 변경 작업을 호출하면 UnmodifiableSetException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb551e97ee529776d55d9be5a6002c26fcb54fe2" translate="yes" xml:space="preserve">
          <source>In some operating systems, this property can be ignored by the underlying controls.</source>
          <target state="translated">일부 운영 체제에서는 기본 컨트롤이이 속성을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f6acaf9d833b5998133b034cac67f51895d1578" translate="yes" xml:space="preserve">
          <source>In some variations of the &lt;code&gt;rotate&lt;/code&gt; methods in the &lt;code&gt;AffineTransform&lt;/code&gt; class, a double-precision argument specifies the angle of rotation in radians. These methods have special handling for rotations of approximately 90 degrees (including multiples such as 180, 270, and 360 degrees), so that the common case of quadrant rotation is handled more efficiently. This special handling can cause angles very close to multiples of 90 degrees to be treated as if they were exact multiples of 90 degrees. For small multiples of 90 degrees the range of angles treated as a quadrant rotation is approximately 0.00000121 degrees wide. This section explains why such special care is needed and how it is implemented.</source>
          <target state="translated">&lt;code&gt;AffineTransform&lt;/code&gt; 의 &lt;code&gt;rotate&lt;/code&gt; 방법 의 일부 변형 에서 클래스 배정 밀도 인수는 라디안으로 회전 각도를 지정합니다. 이러한 메서드는 약 90 도의 회전 (180, 270 및 360도 등의 배수 포함)에 대한 특수 처리 기능을 사용하여 일반적인 사분면 회전 사례를보다 효율적으로 처리합니다. 이 특수 처리로 인해 90 도의 배수에 매우 가까운 각도가 90 도의 정확한 배수 인 것처럼 처리 될 수 있습니다. 90 도의 작은 배수의 경우 사분면 회전으로 처리되는 각도 범위는 약 0.00000121 도입니다. 이 섹션에서는 이러한 특별한주의가 필요한 이유와 실행 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="885ee299391385d6ba4dabda1e81289629f68f72" translate="yes" xml:space="preserve">
          <source>In source code, a call to a signature polymorphic method will compile, regardless of the requested symbolic type descriptor. As usual, the Java compiler emits an &lt;code&gt;invokevirtual&lt;/code&gt; instruction with the given symbolic type descriptor against the named method. The unusual part is that the symbolic type descriptor is derived from the actual argument and return types, not from the method declaration.</source>
          <target state="translated">소스 코드에서 요청 된 기호 유형 설명자에 관계없이 서명 다형성 메소드에 대한 호출이 컴파일됩니다. 평소와 같이 Java 컴파일러 는 지정된 메소드에 대해 주어진 기호 유형 설명자를 사용 하여 &lt;code&gt;invokevirtual&lt;/code&gt; 명령어를 생성합니다. 특이한 부분은 기호 유형 설명자가 메소드 선언이 아니라 실제 인수 및 리턴 유형에서 파생된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b915bf0ccf792776f6e76bfd8e1c08e30939ddb" translate="yes" xml:space="preserve">
          <source>In strict parsing mode, the minimum number of parsed digits is &lt;code&gt;minWidth&lt;/code&gt; and the maximum is &lt;code&gt;maxWidth&lt;/code&gt;. In lenient parsing mode, the minimum number of parsed digits is one and the maximum is 19 (except as limited by adjacent value parsing).</source>
          <target state="translated">엄격한 구문 분석 모드에서 구문 분석 된 최소 자릿수는 &lt;code&gt;minWidth&lt;/code&gt; 이고 최대 값은 &lt;code&gt;maxWidth&lt;/code&gt; 입니다. 관용적 인 구문 분석 모드에서 구문 분석 된 최소 자릿수는 1이고 최대 값은 19입니다 (인접한 값 구문 분석에 의해 제한되지 않음).</target>
        </trans-unit>
        <trans-unit id="e32a1c5a51d2f15051e0db94aa6b8b5a7875526d" translate="yes" xml:space="preserve">
          <source>In strict parsing, any sign will be rejected. In lenient parsing, any sign will be accepted unless the width is fixed.</source>
          <target state="translated">엄격한 구문 분석에서는 모든 부호가 거부됩니다. 관대 한 구문 분석에서 너비가 고정되어 있지 않으면 모든 부호가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b74dc38e8b9a0ecab2c681d95be38243e38c6415" translate="yes" xml:space="preserve">
          <source>In strict parsing, the absence of a sign will be rejected. In lenient parsing, any sign will be accepted, with the absence of a sign treated as a positive number.</source>
          <target state="translated">엄격한 구문 분석에서 부호가 없으면 거부됩니다. 관대 한 구문 분석에서 양수로 취급되는 부호가 없으면 모든 부호가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c8071a6cb7a80c6d715aae673f0d54a56ce4046" translate="yes" xml:space="preserve">
          <source>In strict parsing, the negative sign will be accepted and the positive sign rejected. In lenient parsing, any sign will be accepted.</source>
          <target state="translated">엄격한 구문 분석에서는 음수 부호가 허용되고 양수 부호가 거부됩니다. 관대 한 구문 분석에서는 모든 부호가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="67fe828640d1605e5d14133978083d2888d9dcd4" translate="yes" xml:space="preserve">
          <source>In strict parsing, the sign will be rejected unless the pad width is exceeded. In lenient parsing, any sign will be accepted, with the absence of a sign treated as a positive number.</source>
          <target state="translated">엄격한 구문 분석에서 패드 너비를 초과하지 않으면 부호가 거부됩니다. 관대 한 구문 분석에서 양수로 취급되는 부호가 없으면 모든 부호가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="32f38d097aca41b5fd2eca03a22d2ba7f888ee6d" translate="yes" xml:space="preserve">
          <source>In styled text, the baselines for each such run are aligned one after the other to potentially create a non-linear baseline for the entire run of text. For more information, see &lt;a href=&quot;textlayout#getLayoutPath()&quot;&gt;&lt;code&gt;TextLayout.getLayoutPath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스타일이 지정된 텍스트에서는 이러한 각 실행의 기준선이 차례로 정렬되어 전체 텍스트 실행에 대한 비선형 기준선을 만들 수 있습니다. 자세한 내용은 &lt;a href=&quot;textlayout#getLayoutPath()&quot;&gt; &lt;code&gt;TextLayout.getLayoutPath()&lt;/code&gt; &lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="14e6d10be963a858682493890b1c1e45150c4841" translate="yes" xml:space="preserve">
          <source>In such an environment, when calling &lt;code&gt;setLocation&lt;/code&gt;, you must pass a virtual coordinate to this method. Similarly, calling &lt;code&gt;getLocationOnScreen&lt;/code&gt; on a &lt;code&gt;Frame&lt;/code&gt; returns virtual device coordinates. Call the &lt;code&gt;getBounds&lt;/code&gt; method of a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; to find its origin in the virtual coordinate system.</source>
          <target state="translated">이러한 환경에서 &lt;code&gt;setLocation&lt;/code&gt; 을 호출 할 때이 메서드에 가상 좌표를 전달해야합니다. 마찬가지로 &lt;code&gt;Frame&lt;/code&gt; &lt;code&gt;getLocationOnScreen&lt;/code&gt; 을 호출 하면 가상 장치 좌표가 반환됩니다. &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 의 &lt;code&gt;getBounds&lt;/code&gt; 메서드를 호출하여 가상 좌표계에서 원점을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="430fe4c1fa3678008389acec40576ab47a3e8f92" translate="yes" xml:space="preserve">
          <source>In such an environment, when calling &lt;code&gt;setLocation&lt;/code&gt;, you must pass a virtual coordinate to this method. Similarly, calling &lt;code&gt;getLocationOnScreen&lt;/code&gt; on a &lt;code&gt;Window&lt;/code&gt; returns virtual device coordinates. Call the &lt;code&gt;getBounds&lt;/code&gt; method of a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; to find its origin in the virtual coordinate system.</source>
          <target state="translated">이러한 환경에서 &lt;code&gt;setLocation&lt;/code&gt; 을 호출 할 때이 메서드에 가상 좌표를 전달해야합니다. 마찬가지로 &lt;code&gt;Window&lt;/code&gt; 에서 &lt;code&gt;getLocationOnScreen&lt;/code&gt; 을 호출 하면 가상 장치 좌표가 반환됩니다. &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 의 &lt;code&gt;getBounds&lt;/code&gt; 메서드를 호출합니다. 가상 좌표계에서 원점을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="214ba9516aa4a0067c4a338c78f5324a4ab75fa7" translate="yes" xml:space="preserve">
          <source>In such cases an exception will be thrown. The exact nature of the exception is system-dependent, but it will always be a subclass of &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 경우 예외가 발생합니다. 예외의 정확한 특성은 시스템에 따라 다르지만 항상 &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 의 서브 클래스가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c326a999ddfe2daddd2659ccac12ca5a92c10aa" translate="yes" xml:space="preserve">
          <source>In such situations it is desirable that the GUI control detect this and institute a scroll operation in order to make obscured region(s) visible to the user. This feature is known as autoscrolling.</source>
          <target state="translated">이러한 상황에서 GUI 컨트롤은이를 감지하고 사용자에게 가려진 영역 (들)을 표시하기 위해 스크롤 작업을 수행하는 것이 바람직합니다. 이 기능을 자동 스크롤이라고합니다.</target>
        </trans-unit>
        <trans-unit id="882463d8c19c07511a6474e0e79380cb4537f977" translate="yes" xml:space="preserve">
          <source>In summary, a &lt;code&gt;CachedRowSet&lt;/code&gt; object can be thought of as simply a disconnected set of rows that are being cached outside of a data source. Being thin and serializable, it can easily be sent across a wire, and it is well suited to sending data to a thin client. However, a &lt;code&gt;CachedRowSet&lt;/code&gt; object does have a limitation: It is limited in size by the amount of data it can store in memory at one time.</source>
          <target state="translated">요약하면 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체는 데이터 소스 외부에서 캐시되는 연결이 끊긴 행 집합으로 간주 될 수 있습니다. 얇고 직렬화 가능하기 때문에 유선을 통해 쉽게 전송할 수 있으며 씬 클라이언트로 데이터를 전송하는 데 적합합니다. 그러나 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체에는 제한이 있습니다. 한 번에 메모리에 저장할 수있는 데이터의 양에 따라 크기가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8067decfb6c0c5c43694b67ad35b84389b8af373" translate="yes" xml:space="preserve">
          <source>In summary, implementations must behave in a manner equivalent to this pseudo-code:</source>
          <target state="translated">요약하면 구현은이 의사 코드와 동등한 방식으로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed941580cb00e2437d3c9ed1b978822bc3ddf2fb" translate="yes" xml:space="preserve">
          <source>In terms of design, this class should be viewed primarily as the combination of a &lt;code&gt;LocalDateTime&lt;/code&gt; and a &lt;code&gt;ZoneId&lt;/code&gt;. The &lt;code&gt;ZoneOffset&lt;/code&gt; is a vital, but secondary, piece of information, used to ensure that the class represents an instant, especially during a daylight savings overlap.</source>
          <target state="translated">디자인 측면에서이 클래스는 주로 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 &lt;code&gt;ZoneId&lt;/code&gt; 의 조합으로 간주되어야합니다 . &lt;code&gt;ZoneOffset&lt;/code&gt; 특히 비용 절감이 중복 일광 동안, 클래스 인스턴트를 나타낸다는 것을 확인하기 위해 사용되는 정보의 중요한하지만, 차, 조각입니다.</target>
        </trans-unit>
        <trans-unit id="76eb19d7c964e4c05ae134c3d7adb2c9eb092b77" translate="yes" xml:space="preserve">
          <source>In terms of the Java Memory Model, this operation performs a synchronization action which is comparable in effect to the writing of a volatile variable by the current thread, and an eventual volatile read by every other thread that may access one of the affected call sites.</source>
          <target state="translated">Java 메모리 모델과 관련하여이 작업은 현재 스레드에 의한 휘발성 변수 쓰기와 영향을받는 호출 사이트 중 하나에 액세스 할 수있는 다른 모든 스레드에 의한 최종 휘발성 읽기와 비슷한 동기화 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="835cfd0b944daf64dbddb89f8c199c78f037cfd7" translate="yes" xml:space="preserve">
          <source>In that case it is up to the user to call it to maintain the consistency of the relations. To be kept in mind that if an MBean is unregistered and the purge not done immediately, if the ObjectName is reused and assigned to another MBean referenced in a relation, calling manually this purgeRelations() method will cause trouble, as will consider the ObjectName as corresponding to the unregistered MBean, not seeing the new one.</source>
          <target state="translated">이 경우 관계의 일관성을 유지하기 위해 호출하는 것은 사용자의 책임입니다. MBean이 등록 해제되고 제거가 즉시 완료되지 않은 경우 ObjectName을 재사용하여 관계에서 참조되는 다른 MBean에 지정하면 수동으로이 purgeRelations () 메소드를 호출하면 ObjectName을 다음과 같이 고려할 때 문제가 발생합니다. 등록되지 않은 MBean에 해당하며 새 MBean은 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bef1807ddf0304b74d57e74ae70d10d603d4b799" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../nio/channels/package-summary&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt; package, the &lt;a href=&quot;../nio/channels/networkchannel&quot;&gt;&lt;code&gt;NetworkChannel&lt;/code&gt;&lt;/a&gt; interface defines the &lt;a href=&quot;../nio/channels/networkchannel#setOption(java.net.SocketOption,T)&quot;&gt;&lt;code&gt;setOption&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../nio/channels/networkchannel#getOption(java.net.SocketOption)&quot;&gt;&lt;code&gt;getOption&lt;/code&gt;&lt;/a&gt; methods to set and query the channel's socket options.</source>
          <target state="translated">에서 &lt;a href=&quot;../nio/channels/package-summary&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt; 패키지의 &lt;a href=&quot;../nio/channels/networkchannel&quot;&gt; &lt;code&gt;NetworkChannel&lt;/code&gt; 의&lt;/a&gt; 인터페이스는 정의 &lt;a href=&quot;../nio/channels/networkchannel#setOption(java.net.SocketOption,T)&quot;&gt; &lt;code&gt;setOption&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../nio/channels/networkchannel#getOption(java.net.SocketOption)&quot;&gt; &lt;code&gt;getOption&lt;/code&gt; &lt;/a&gt; 세트 방법 및 쿼리 채널의 소켓 옵션을.</target>
        </trans-unit>
        <trans-unit id="8ebc8aa5c940b2b5ec99046211ecd0bca8ea5a52" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../nio/channels/package-summary&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt; package, the &lt;a href=&quot;../nio/channels/networkchannel&quot;&gt;&lt;code&gt;NetworkChannel&lt;/code&gt;&lt;/a&gt; interface defines the &lt;a href=&quot;../nio/channels/networkchannel#setOption-java.net.SocketOption-T-&quot;&gt;&lt;code&gt;setOption&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../nio/channels/networkchannel#getOption-java.net.SocketOption-&quot;&gt;&lt;code&gt;getOption&lt;/code&gt;&lt;/a&gt; methods to set and query the channel's socket options.</source>
          <target state="translated">에서 &lt;a href=&quot;../nio/channels/package-summary&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt; 패키지의 &lt;a href=&quot;../nio/channels/networkchannel&quot;&gt; &lt;code&gt;NetworkChannel&lt;/code&gt; 의&lt;/a&gt; 인터페이스는 정의 &lt;a href=&quot;../nio/channels/networkchannel#setOption-java.net.SocketOption-T-&quot;&gt; &lt;code&gt;setOption&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../nio/channels/networkchannel#getOption-java.net.SocketOption-&quot;&gt; &lt;code&gt;getOption&lt;/code&gt; &lt;/a&gt; 세트 방법 및 쿼리 채널의 소켓 옵션을.</target>
        </trans-unit>
        <trans-unit id="b62cb44c2b6302f47dd64bfc710a64f101a0b462" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;getAttributes()&lt;/code&gt; and &lt;code&gt;search()&lt;/code&gt; methods, you can specify that all attributes associated with the requested objects be returned by supply &lt;code&gt;null&lt;/code&gt; as the list of attributes to return. The attributes returned do &lt;em&gt;not&lt;/em&gt; include operational attributes. In order to retrieve operational attributes, you must name them explicitly.</source>
          <target state="translated">에서 &lt;code&gt;getAttributes()&lt;/code&gt; 및 &lt;code&gt;search()&lt;/code&gt; 메소드는, 모든이 요청 된 객체가 공급에 의해 반환과 관련된 속성을 지정할 수 있습니다 &lt;code&gt;null&lt;/code&gt; 을 반환 할 속성의 목록으로. 리턴 된 속성 에는 운영 속성이 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; . 운영 속성을 검색하려면 명시 적으로 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="65574745feadc55e1e05a1c122606bd23b2ae9c4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;getAttributes()&lt;/code&gt; and &lt;code&gt;search()&lt;/code&gt; methods, you can supply the attributes to return by supplying a list of attribute names (strings). The attributes that you get back might not have the same names as the attribute names you have specified. This is because some directories support features that cause them to return other attributes. Such features include attribute subclassing, attribute name synonyms, and attribute language codes.</source>
          <target state="translated">에서 &lt;code&gt;getAttributes()&lt;/code&gt; 및 &lt;code&gt;search()&lt;/code&gt; 메소드는, 당신은 속성 이름 (문자열)의 목록을 제공하여 반환하는 속성을 제공 할 수 있습니다. 되 돌리는 속성은 지정한 속성 이름과 동일하지 않을 수 있습니다. 일부 디렉토리는 다른 속성을 리턴하는 기능을 지원하기 때문입니다. 이러한 기능에는 속성 서브 클래 싱, 속성 이름 동의어 및 속성 언어 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="87d152e8e73df7131decd25ad1ce40aac0f21673" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;JNDI form&lt;/em&gt;, the URL indicates &lt;em&gt;where to find an RMI stub for the connector&lt;/em&gt;. This RMI stub is a Java object of type &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt; that gives remote access to the connector server. With this address form, the RMI stub is obtained from an external directory entry included in the URL. An external directory is any directory recognized by &lt;a href=&quot;../../../../../java.naming/javax/naming/package-summary&quot;&gt;&lt;code&gt;JNDI&lt;/code&gt;&lt;/a&gt;, typically the RMI registry, LDAP, or COS Naming.</source>
          <target state="translated">에서 &lt;em&gt;JNDI 양식&lt;/em&gt; , URL이 표시 &lt;em&gt;커넥터에 대한 RMI 스텁을 어디서 찾을 수 있는지&lt;/em&gt; . 이 RMI 스텁은 커넥터 서버에 대한 원격 액세스를 제공하는 &lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt; 유형의 Java 오브젝트입니다 . 이 주소 양식을 사용하면 URL에 포함 된 외부 디렉토리 항목에서 RMI 스텁을 가져옵니다. 외부 디렉토리는 일반적으로 RMI 레지스트리, LDAP 또는 COS 이름 지정과 같이 &lt;a href=&quot;../../../../../java.naming/javax/naming/package-summary&quot;&gt; &lt;code&gt;JNDI&lt;/code&gt; 가&lt;/a&gt; 인식하는 디렉토리 입니다.</target>
        </trans-unit>
        <trans-unit id="bbbf3a71704058ced1b5b8411ec253780bd68226" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;JNDI form&lt;/em&gt;, the URL indicates &lt;em&gt;where to find an RMI stub for the connector&lt;/em&gt;. This RMI stub is a Java object of type &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt; that gives remote access to the connector server. With this address form, the RMI stub is obtained from an external directory entry included in the URL. An external directory is any directory recognized by &lt;a href=&quot;../../../naming/package-summary&quot;&gt;&lt;code&gt;JNDI&lt;/code&gt;&lt;/a&gt;, typically the RMI registry, LDAP, or COS Naming.</source>
          <target state="translated">에서 &lt;em&gt;JNDI 양식&lt;/em&gt; , URL이 표시 &lt;em&gt;커넥터에 대한 RMI 스텁을 어디서 찾을 수 있는지&lt;/em&gt; . 이 RMI 스텁은 커넥터 서버에 대한 원격 액세스를 제공하는 &lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt; 유형의 Java 오브젝트입니다 . 이 주소 양식을 사용하면 RMI 스텁은 URL에 포함 된 외부 디렉토리 항목에서 가져옵니다. 외부 디렉토리는 &lt;a href=&quot;../../../naming/package-summary&quot;&gt; &lt;code&gt;JNDI&lt;/code&gt; 가&lt;/a&gt; 인식하는 디렉토리 ( 일반적으로 RMI 레지스트리, LDAP 또는 COS 이름 지정)입니다.</target>
        </trans-unit>
        <trans-unit id="fd216e1fa9eb5f8e146da12b5c1bfee5cf25ef08" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;encoded form&lt;/em&gt;, the URL directly includes the information needed to connect to the connector server. When using RMI/JRMP, the encoded form is the serialized RMI stub for the server object, encoded using BASE64 without embedded newlines.</source>
          <target state="translated">에서 &lt;em&gt;인코딩 된 형태로&lt;/em&gt; 상기 URL 직접 연결 서버에 연결하는데 필요한 정보를 포함한다. RMI / JRMP를 사용할 때 인코딩 된 형식은 삽입 된 줄 바꿈없이 BASE64를 사용하여 인코딩 된 서버 개체에 대한 직렬화 된 RMI 스텁입니다.</target>
        </trans-unit>
        <trans-unit id="da195228b955a3ad9cf4e29226a227ba11eca748" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;encoded form&lt;/em&gt;, the URL directly includes the information needed to connect to the connector server. When using RMI/JRMP, the encoded form is the serialized RMI stub for the server object, encoded using BASE64 without embedded newlines. When using RMI/IIOP, the encoded form is the CORBA IOR for the server object.</source>
          <target state="translated">에서 &lt;em&gt;인코딩 된 형태로&lt;/em&gt; 상기 URL 직접 연결 서버에 연결하는데 필요한 정보를 포함한다. RMI / JRMP를 사용하는 경우, 인코딩 된 양식은 서버 오브젝트의 직렬화 된 RMI 스텁이며, 개행이 포함되지 않은 BASE64를 사용하여 인코딩됩니다. RMI / IIOP를 사용할 때 인코딩 된 양식은 서버 오브젝트의 CORBA IOR입니다.</target>
        </trans-unit>
        <trans-unit id="86f6b7e5dc81391222de88d79367433c554f6d3d" translate="yes" xml:space="preserve">
          <source>In the JDBC 2.0 API, the behavior of the method &lt;code&gt;getObject&lt;/code&gt; is extended to materialize data of SQL user-defined types. When a column contains a structured or distinct value, the behavior of this method is as if it were a call to: &lt;code&gt;getObject(columnIndex,
 this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.</source>
          <target state="translated">JDBC 2.0 API에서 &lt;code&gt;getObject&lt;/code&gt; 메소드의 동작 이 확장되어 SQL 사용자 정의 유형의 데이터를 구체화합니다. 열에 구조화되거나 고유 한 값이 포함 된 경우이 메서드의 동작은 &lt;code&gt;getObject(columnIndex, this.getStatement().getConnection().getTypeMap())&lt;/code&gt; 대한 호출과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5e6e492afa18abccbc15a09e9c9801f7982bd748" translate="yes" xml:space="preserve">
          <source>In the Java 1.0 event model, an event contains an &lt;a href=&quot;#id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; field that indicates what type of event it is and which other &lt;code&gt;Event&lt;/code&gt; variables are relevant for the event.</source>
          <target state="translated">Java 1.0 이벤트 모델에서 이벤트에는 이벤트 유형 및 이벤트와 관련된 기타 &lt;code&gt;Event&lt;/code&gt; 변수 를 나타내는 &lt;a href=&quot;#id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; 필드가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a77ab9d4544f54d35b2613f822310c541fff6180" translate="yes" xml:space="preserve">
          <source>In the Java Print Service API, an attribute category is represented by a Java class implementing the &lt;a href=&quot;attribute&quot;&gt;Attribute&lt;/a&gt; interface. Attribute values are instances of such a class or one of its subclasses. For example, to specify the number of copies, an application constructs an instance of the &lt;a href=&quot;standard/copies&quot;&gt;Copies&lt;/a&gt; class with the number of desired copies and uses the &lt;code&gt;Copies&lt;/code&gt; instance as part of the print request. In this case, the &lt;code&gt;Copies&lt;/code&gt; class represents the attribute category, and the &lt;code&gt;Copies&lt;/code&gt; instance represents the attribute value.</source>
          <target state="translated">Java Print Service API에서 속성 범주는 &lt;a href=&quot;attribute&quot;&gt;Attribute&lt;/a&gt; 인터페이스를 구현하는 Java 클래스로 표시 됩니다. 속성 값은 이러한 클래스 또는 해당 서브 클래스 중 하나의 인스턴스입니다. 예를 들어, 사본 수를 지정하기 위해 응용 프로그램 은 원하는 사본 수로 &lt;a href=&quot;standard/copies&quot;&gt;Copies&lt;/a&gt; 클래스의 인스턴스를 구성하고 인쇄 요청의 일부로 &lt;code&gt;Copies&lt;/code&gt; 인스턴스를 사용합니다 . 이 경우 &lt;code&gt;Copies&lt;/code&gt; 클래스는 속성 범주 를 나타내고 &lt;code&gt;Copies&lt;/code&gt; 인스턴스는 속성 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="67a8902a6ba14e2b0903baaddb1578c58648db1e" translate="yes" xml:space="preserve">
          <source>In the Java SE API documentation, &lt;em&gt;Unicode code point&lt;/em&gt; is used for character values in the range between U+0000 and U+10FFFF, and &lt;em&gt;Unicode code unit&lt;/em&gt; is used for 16-bit &lt;code&gt;char&lt;/code&gt; values that are code units of the &lt;em&gt;UTF-16&lt;/em&gt; encoding. For more information on Unicode terminology, refer to the &lt;a href=&quot;http://www.unicode.org/glossary/&quot;&gt;Unicode Glossary&lt;/a&gt;.</source>
          <target state="translated">Java SE API 문서에서 &lt;em&gt;유니 코드 코드 포인트&lt;/em&gt; 는 U + 0000에서 U + 10FFFF 사이의 문자 값에 사용되고 &lt;em&gt;유니 코드 코드 단위&lt;/em&gt; 는 &lt;em&gt;UTF-16&lt;/em&gt; 인코딩 의 코드 단위 인 16 비트 &lt;code&gt;char&lt;/code&gt; 값에 사용됩니다 . 유니 코드 용어에 대한 자세한 내용은 유니 &lt;a href=&quot;http://www.unicode.org/glossary/&quot;&gt;코드 용어집을&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bc8709b34a011f36b043d3971d48950764a1f4c" translate="yes" xml:space="preserve">
          <source>In the Swing component set, borders supercede Insets as the mechanism for creating a (decorated or plain) area around the edge of a component.</source>
          <target state="translated">Swing 구성 요소 집합에서 테두리는 구성 요소 가장자리 주위에 (장식 또는 일반) 영역을 만드는 메커니즘으로 인세 트를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="890cc57ecf9bbe3ff59180e50104a57930b04712" translate="yes" xml:space="preserve">
          <source>In the above cases, the type of the expected results are known. In case where the result type is unknown or any type, the &lt;a href=&quot;xpathevaluationresult&quot;&gt;&lt;code&gt;XPathEvaluationResult&lt;/code&gt;&lt;/a&gt; may be used to determine the return type. The following code demonstrates the usage:</source>
          <target state="translated">위의 경우 예상 결과의 유형이 알려져 있습니다. 결과 유형을 알 수 없거나 임의 유형 인 경우 &lt;a href=&quot;xpathevaluationresult&quot;&gt; &lt;code&gt;XPathEvaluationResult&lt;/code&gt; &lt;/a&gt; 를 사용하여 반환 유형을 결정할 수 있습니다. 다음 코드는 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b7235ee23269ea4f01cc38b0aac3b8a2cb7f2edf" translate="yes" xml:space="preserve">
          <source>In the above example, the XML file is read into a DOM Document before being passed to the XPath API. The following code demonstrates the use of InputSource to leave it to the XPath implementation to process it:</source>
          <target state="translated">위의 예에서 XML 파일은 XPath API로 전달되기 전에 DOM 문서로 읽혀집니다. 다음 코드는 InputSource를 사용하여 XPath 구현에 남겨 두어 처리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6463be53e9fdab868fcd86a08889119e4172ad7b" translate="yes" xml:space="preserve">
          <source>In the above examples, the return type is always &lt;code&gt;CallSite&lt;/code&gt;, but that is not a necessary feature of bootstrap methods. In the case of a dynamically-computed call site, the only requirement is that the return type of the bootstrap method must be convertible (using the &lt;code&gt;asType&lt;/code&gt; conversions) to &lt;code&gt;CallSite&lt;/code&gt;, which means the bootstrap method return type might be &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;ConstantCallSite&lt;/code&gt;. In the case of a dynamically-resolved constant, the return type of the bootstrap method must be convertible to the type of the constant, as represented by its field type descriptor. For example, if the dynamic constant has a field type descriptor of &lt;code&gt;&quot;C&quot;&lt;/code&gt; (&lt;code&gt;char&lt;/code&gt;) then the bootstrap method return type could be &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;, but not &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 반환 유형은 항상 &lt;code&gt;CallSite&lt;/code&gt; 이지만 부트 스트랩 메서드의 필수 기능은 아닙니다. 동적으로 계산 된 호출 사이트의 경우 유일한 요구 사항은 부트 스트랩 메서드의 반환 유형이 &lt;code&gt;CallSite&lt;/code&gt; 로 변환 가능해야한다는 것입니다 ( &lt;code&gt;asType&lt;/code&gt; 변환 사용). 즉, 부트 스트랩 메서드 반환 유형은 &lt;code&gt;Object&lt;/code&gt; 또는 &lt;code&gt;ConstantCallSite&lt;/code&gt; 일 수 있습니다 . 동적으로 해결되는 상수의 경우 부트 스트랩 메서드의 반환 유형은 필드 유형 설명 자로 표시되는 상수 유형으로 변환 할 수 있어야합니다. 예를 들어, 동적 상수에 &lt;code&gt;&quot;C&quot;&lt;/code&gt; ( &lt;code&gt;char&lt;/code&gt; ) 그런 다음 부트 스트랩 메서드 반환 유형은 &lt;code&gt;Object&lt;/code&gt; , &lt;code&gt;Character&lt;/code&gt; 또는 &lt;code&gt;char&lt;/code&gt; 일 수 있지만 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;Integer&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b2e436a63fb82b00c3480e918656abba05842f97" translate="yes" xml:space="preserve">
          <source>In the above, the &lt;em&gt;package name&lt;/em&gt; for a resource is derived from the subsequence of characters that precedes the last &lt;code&gt;'/'&lt;/code&gt; in the name and then replacing each &lt;code&gt;'/'&lt;/code&gt; character in the subsequence with &lt;code&gt;'.'&lt;/code&gt;. A leading slash is ignored when deriving the package name. As an example, the package name derived for a resource named &quot;&lt;code&gt;a/b/c/foo.properties&lt;/code&gt;&quot; is &quot;&lt;code&gt;a.b.c&lt;/code&gt;&quot;. A resource name with the name &quot;&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;&quot; is never encapsulated because &quot;&lt;code&gt;META-INF&lt;/code&gt;&quot; is not a legal package name.</source>
          <target state="translated">위에서 리소스 의 &lt;em&gt;패키지 이름&lt;/em&gt; 은 &lt;em&gt;이름&lt;/em&gt; 의 마지막 &lt;code&gt;'/'&lt;/code&gt; 앞에 오는 문자의 하위 시퀀스에서 파생 된 다음 하위 시퀀스의 각 &lt;code&gt;'/'&lt;/code&gt; 문자를 &lt;code&gt;'.'&lt;/code&gt; 로 바꿉니다 . . 패키지 이름을 파생 할 때 선행 슬래시는 무시됩니다. 예를 들어 &quot; &lt;code&gt;a/b/c/foo.properties&lt;/code&gt; &quot; 라는 리소스에 대해 파생 된 패키지 이름 은 &quot; &lt;code&gt;a.b.c&lt;/code&gt; &quot;입니다. 이름이 &quot; &lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt; &quot;인 자원 이름 은 &quot; &lt;code&gt;META-INF&lt;/code&gt; &quot;가 합법적 인 패키지 이름이 아니기 때문에 캡슐화 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60b93c27d35d4ef73db7b1a5de3b9ca5e3bbc362" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;remove&lt;/code&gt; calls, a class value has a simple state diagram: uninitialized and initialized. When &lt;code&gt;remove&lt;/code&gt; calls are made, the rules for value observation are more complex. See the documentation for &lt;a href=&quot;#remove(java.lang.Class)&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; 호출 이없는 경우 클래스 값에는 간단한 상태 다이어그램 (초기화되지 않음 및 초기화 됨)이 있습니다. 때 &lt;code&gt;remove&lt;/code&gt; 호출이 만들어진 가치 관찰에 대한 규칙은 더 복잡하다. 자세한 내용은 &lt;a href=&quot;#remove(java.lang.Class)&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d6c6f9ca13ab5451799666ab96c66ed377dbd22" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;remove&lt;/code&gt; calls, a class value has a simple state diagram: uninitialized and initialized. When &lt;code&gt;remove&lt;/code&gt; calls are made, the rules for value observation are more complex. See the documentation for &lt;a href=&quot;classvalue#remove-java.lang.Class-&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; 호출 이 없으면 클래스 값에는 간단한 상태 다이어그램이 있습니다 : 초기화되지 않은 상태 및 초기화 된 상태. 때 &lt;code&gt;remove&lt;/code&gt; 호출이 만들어진 가치 관찰에 대한 규칙은 더 복잡하다. 자세한 내용은 &lt;a href=&quot;classvalue#remove-java.lang.Class-&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a254ee0af676fe77ed6ba824317943df316a8c7a" translate="yes" xml:space="preserve">
          <source>In the absence of other alternatives, the method may throw an unchecked &lt;a href=&quot;rejectedexecutionexception&quot;&gt;&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/a&gt;, which will be propagated to the caller of &lt;code&gt;execute&lt;/code&gt;.</source>
          <target state="translated">다른 대안이없는 경우, 메소드는 검사되지 않은 &lt;a href=&quot;rejectedexecutionexception&quot;&gt; &lt;code&gt;RejectedExecutionException&lt;/code&gt; &lt;/a&gt; 을 발생시킬 수 있으며, 이는 &lt;code&gt;execute&lt;/code&gt; 호출자에게 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0fcd323662ee68a5bf74deb7c77fe408fd53411" translate="yes" xml:space="preserve">
          <source>In the addition to &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt;, the following options may be present:</source>
          <target state="translated">&lt;code&gt;READ&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 외에도 다음과 같은 옵션이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e177711c2e7ebd76cba6572a163ac3437710fb82" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;#FULL_FLUSH&quot;&gt;&lt;code&gt;FULL_FLUSH&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#SYNC_FLUSH&quot;&gt;&lt;code&gt;SYNC_FLUSH&lt;/code&gt;&lt;/a&gt;, if the return value is &lt;code&gt;len&lt;/code&gt;, the space available in output buffer &lt;code&gt;b&lt;/code&gt;, this method should be invoked again with the same &lt;code&gt;flush&lt;/code&gt; parameter and more output space. Make sure that &lt;code&gt;len&lt;/code&gt; is greater than 6 to avoid flush marker (5 bytes) being repeatedly output to the output buffer every time this method is invoked.</source>
          <target state="translated">의 경우 &lt;a href=&quot;#FULL_FLUSH&quot;&gt; &lt;code&gt;FULL_FLUSH&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#SYNC_FLUSH&quot;&gt; &lt;code&gt;SYNC_FLUSH&lt;/code&gt; &lt;/a&gt; 리턴 값이되면, &lt;code&gt;len&lt;/code&gt; , 출력 버퍼에서 이용 가능한 공간 &lt;code&gt;b&lt;/code&gt; ,이 방법은 동일한 다시 호출되어야 &lt;code&gt;flush&lt;/code&gt; 파라미터보다 출력 공간. 이 메서드가 호출 될 때마다 출력 버퍼에 플러시 마커 (5 바이트)가 반복적으로 출력되지 않도록 &lt;code&gt;len&lt;/code&gt; 이 6보다 큰지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd96ad5a66fc2285518bf3ab8cbec8fd8e9d5c66" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;#FULL_FLUSH&quot;&gt;&lt;code&gt;FULL_FLUSH&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#SYNC_FLUSH&quot;&gt;&lt;code&gt;SYNC_FLUSH&lt;/code&gt;&lt;/a&gt;, if the return value is equal to the &lt;a href=&quot;../../nio/buffer#remaining()&quot;&gt;remaining space&lt;/a&gt; of the buffer, this method should be invoked again with the same &lt;code&gt;flush&lt;/code&gt; parameter and more output space. Make sure that the buffer has at least 6 bytes of remaining space to avoid the flush marker (5 bytes) being repeatedly output to the output buffer every time this method is invoked.</source>
          <target state="translated">의 경우 &lt;a href=&quot;#FULL_FLUSH&quot;&gt; &lt;code&gt;FULL_FLUSH&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#SYNC_FLUSH&quot;&gt; &lt;code&gt;SYNC_FLUSH&lt;/code&gt; &lt;/a&gt; 반환 값이 동일한 경우, &lt;a href=&quot;../../nio/buffer#remaining()&quot;&gt;남은 공간&lt;/a&gt; 버퍼,이 방법은 동일한 다시 호출되어야 &lt;code&gt;flush&lt;/code&gt; 파라미터보다 출력 공간. 이 메서드가 호출 될 때마다 플러시 마커 (5 바이트)가 반복적으로 출력 버퍼에 출력되지 않도록 버퍼에 최소 6 바이트의 남은 공간이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="82201373a2610441e998008c462731da12155c0d" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;deflater#FULL_FLUSH&quot;&gt;&lt;code&gt;FULL_FLUSH&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;deflater#SYNC_FLUSH&quot;&gt;&lt;code&gt;SYNC_FLUSH&lt;/code&gt;&lt;/a&gt;, if the return value is &lt;code&gt;len&lt;/code&gt;, the space available in output buffer &lt;code&gt;b&lt;/code&gt;, this method should be invoked again with the same &lt;code&gt;flush&lt;/code&gt; parameter and more output space.</source>
          <target state="translated">의 경우 &lt;a href=&quot;deflater#FULL_FLUSH&quot;&gt; &lt;code&gt;FULL_FLUSH&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;deflater#SYNC_FLUSH&quot;&gt; &lt;code&gt;SYNC_FLUSH&lt;/code&gt; &lt;/a&gt; 리턴 값이되면, &lt;code&gt;len&lt;/code&gt; , 출력 버퍼에서 이용 가능한 공간 &lt;code&gt;b&lt;/code&gt; ,이 방법은 동일한 다시 호출되어야 &lt;code&gt;flush&lt;/code&gt; 파라미터보다 출력 공간.</target>
        </trans-unit>
        <trans-unit id="b7bc1d11380671a0651c6a64eb86fb652cb256f0" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt;&lt;code&gt;ENTRY_CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt;&lt;code&gt;ENTRY_DELETE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt;&lt;code&gt;ENTRY_MODIFY&lt;/code&gt;&lt;/a&gt; events the context is a &lt;code&gt;Path&lt;/code&gt; that is the &lt;a href=&quot;path#relativize(java.nio.file.Path)&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; path between the directory registered with the watch service, and the entry that is created, deleted, or modified.</source>
          <target state="translated">의 경우 &lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt; &lt;code&gt;ENTRY_CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt; &lt;code&gt;ENTRY_DELETE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt; &lt;code&gt;ENTRY_MODIFY&lt;/code&gt; 의&lt;/a&gt; 이벤트 컨텍스트 A는 &lt;code&gt;Path&lt;/code&gt; 는 IS &lt;a href=&quot;path#relativize(java.nio.file.Path)&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt; 시계 서비스에 등록 된 디렉토리 및 생성, 삭제 또는 수정 된 항목 사이의 경로.</target>
        </trans-unit>
        <trans-unit id="08a4a6b6701bb5e9bce132b1aa14d72ca141be81" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt;&lt;code&gt;ENTRY_CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt;&lt;code&gt;ENTRY_DELETE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt;&lt;code&gt;ENTRY_MODIFY&lt;/code&gt;&lt;/a&gt; events the context is a &lt;code&gt;Path&lt;/code&gt; that is the &lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; path between the directory registered with the watch service, and the entry that is created, deleted, or modified.</source>
          <target state="translated">의 경우 &lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt; &lt;code&gt;ENTRY_CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt; &lt;code&gt;ENTRY_DELETE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt; &lt;code&gt;ENTRY_MODIFY&lt;/code&gt; 의&lt;/a&gt; 이벤트 컨텍스트 A는 &lt;code&gt;Path&lt;/code&gt; 는 IS &lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt; 시계 서비스에 등록 된 디렉토리 및 생성, 삭제 또는 수정 된 항목 사이의 경로.</target>
        </trans-unit>
        <trans-unit id="44bf9479e2baf7bea92c9e7d1d3e49e131a1ef7b" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;invokeExact&lt;/code&gt;, the type descriptor of the invocation (after resolving symbolic type names) must exactly match the method type of the receiving method handle. In the case of plain, inexact &lt;code&gt;invoke&lt;/code&gt;, the resolved type descriptor must be a valid argument to the receiver's &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; method. Thus, plain &lt;code&gt;invoke&lt;/code&gt; is more permissive than &lt;code&gt;invokeExact&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 의 경우 호출의 형식 설명자 (기호 형식 이름을 확인한 후)는 수신 메서드 핸들의 메서드 형식과 정확히 일치해야합니다. 단순하고 정확하지 않은 &lt;code&gt;invoke&lt;/code&gt; 의 경우 확인 된 유형 설명자는 수신자의 &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 메소드에 대한 유효한 인수 여야합니다 . 따라서 일반 &lt;code&gt;invoke&lt;/code&gt; 은 &lt;code&gt;invokeExact&lt;/code&gt; 보다 더 관대 합니다.</target>
        </trans-unit>
        <trans-unit id="0141b656cd010a95045e183f56a7350cc6b6fbd6" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;invokeExact&lt;/code&gt;, the type descriptor of the invocation (after resolving symbolic type names) must exactly match the method type of the receiving method handle. In the case of plain, inexact &lt;code&gt;invoke&lt;/code&gt;, the resolved type descriptor must be a valid argument to the receiver's &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; method. Thus, plain &lt;code&gt;invoke&lt;/code&gt; is more permissive than &lt;code&gt;invokeExact&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 의 경우 , 호출의 유형 디스크립터 (심볼 유형 이름을 해석 한 후)는 수신 메소드 핸들의 메소드 유형과 정확히 일치해야합니다. 정확하고 정확하지 않은 &lt;code&gt;invoke&lt;/code&gt; 의 경우, 해석 된 유형 설명자는 수신자의 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 메소드에 유효한 인수 여야합니다 . 따라서 일반 &lt;code&gt;invoke&lt;/code&gt; 은 &lt;code&gt;invokeExact&lt;/code&gt; 보다 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab2ee1acf84658ca3734ba1e3885215a35ed71a6" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 CRLs, &lt;code&gt;inStream&lt;/code&gt; may contain a sequence of DER-encoded CRLs. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 CRL set. This is a PKCS#7</source>
          <target state="translated">X.509 CRL을위한 인증서 팩토리의 경우, &lt;code&gt;inStream&lt;/code&gt; 은 일련의 DER 인코딩 CRL을 포함 할 수 있습니다. 또한 &lt;code&gt;inStream&lt;/code&gt; 은 PKCS # 7 CRL 세트를 포함 할 수 있습니다. 이것은 PKCS # 7입니다</target>
        </trans-unit>
        <trans-unit id="08ac21be0ad130188c9cac95e7929ab7e554db46" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 CRLs, &lt;code&gt;inStream&lt;/code&gt; may contain a single DER-encoded CRL. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 CRL set. This is a PKCS#7</source>
          <target state="translated">X.509 CRL을위한 인증서 팩토리의 경우, &lt;code&gt;inStream&lt;/code&gt; 은 단일 DER로 인코딩 된 CRL을 포함 할 수 있습니다. 또한 &lt;code&gt;inStream&lt;/code&gt; 은 PKCS # 7 CRL 세트를 포함 할 수 있습니다. 이것은 PKCS # 7입니다</target>
        </trans-unit>
        <trans-unit id="08442fbda5448829acda7334681c1abf6040c3e1" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a sequence of DER-encoded certificates in the formats described for &lt;a href=&quot;#generateCertificate(java.io.InputStream)&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">X.509 인증서 용 인증서 팩토리의 경우 &lt;code&gt;inStream&lt;/code&gt; 은 &lt;a href=&quot;#generateCertificate(java.io.InputStream)&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; 에&lt;/a&gt; 대해 설명 된 형식의 DER 인코딩 인증서 시퀀스를 포함 할 수 있습니다 . 또한 &lt;code&gt;inStream&lt;/code&gt; 에는 PKCS # 7 인증서 체인이 포함될 수 있습니다. 이것은 PKCS # 7입니다</target>
        </trans-unit>
        <trans-unit id="1fc2160b4adf857b1556e09bd5dd1ba9ce62d01b" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a sequence of DER-encoded certificates in the formats described for &lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">X.509 인증서를위한 인증서 팩토리의 경우, &lt;code&gt;inStream&lt;/code&gt; 은 &lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; 에&lt;/a&gt; 대해 설명 된 형식으로 일련의 DER 인코딩 된 인증서를 포함 할 수 있습니다 . 또한 인스 &lt;code&gt;inStream&lt;/code&gt; 에는 PKCS # 7 인증서 체인이 포함될 수 있습니다. 이것은 PKCS # 7입니다</target>
        </trans-unit>
        <trans-unit id="1280b4cb57ef8893db4d47767dab95ce080e8f83" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a single DER-encoded certificate in the formats described for &lt;a href=&quot;certificatefactory#generateCertificate(java.io.InputStream)&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">X.509 인증서에 대한 인증서 팩토리의 경우 &lt;code&gt;inStream&lt;/code&gt; 은 &lt;a href=&quot;certificatefactory#generateCertificate(java.io.InputStream)&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; 에&lt;/a&gt; 대해 설명 된 형식의 단일 DER 인코딩 인증서를 포함 할 수 있습니다 . 또한 &lt;code&gt;inStream&lt;/code&gt; 에는 PKCS # 7 인증서 체인이 포함될 수 있습니다. 이것은 PKCS # 7입니다</target>
        </trans-unit>
        <trans-unit id="9dc29d2259ad105e7403a0727eb82c65459584a5" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a single DER-encoded certificate in the formats described for &lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">X.509 인증서를위한 인증서 팩토리의 경우, &lt;code&gt;inStream&lt;/code&gt; 은 &lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; 에&lt;/a&gt; 대해 설명 된 형식으로 단일 DER 인코딩 된 인증서를 포함 할 수 있습니다 . 또한 인스 &lt;code&gt;inStream&lt;/code&gt; 에는 PKCS # 7 인증서 체인이 포함될 수 있습니다. 이것은 PKCS # 7입니다</target>
        </trans-unit>
        <trans-unit id="50da2fff261ef006a8b616c0bf4d45a215566afb" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, the certificate provided in &lt;code&gt;inStream&lt;/code&gt; must be DER-encoded and may be supplied in binary or printable (Base64) encoding. If the certificate is provided in Base64 encoding, it must be bounded at the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at the end by -----END CERTIFICATE-----.</source>
          <target state="translated">X.509 인증서 용 인증서 팩토리의 경우 &lt;code&gt;inStream&lt;/code&gt; 에서 제공되는 인증서는 DER로 인코딩되어야하며 바이너리 또는 인쇄 가능 (Base64) 인코딩으로 제공 될 수 있습니다. 인증서가 Base64 인코딩으로 제공되는 경우 시작시 ----- BEGIN CERTIFICATE -----로 묶어야하고 끝에 ----- END CERTIFICATE -----로 묶어야합니다. .</target>
        </trans-unit>
        <trans-unit id="1d5701b6b4b744bfc6a3efcf6ae43a047cc32ed3" translate="yes" xml:space="preserve">
          <source>In the case of a channel to an &lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket, the underlying operating system optionally supports &lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt; &lt;i&gt;RFC 2236: Internet Group Management Protocol, Version 2 (IGMPv2)&lt;/i&gt;&lt;/a&gt;. When IGMPv2 is supported then the operating system may additionally support source filtering as specified by &lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt; &lt;i&gt;RFC 3376: Internet Group Management Protocol, Version 3 (IGMPv3)&lt;/i&gt;&lt;/a&gt;. For channels to an &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket, the equivalent standards are &lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt; &lt;i&gt;RFC 2710: Multicast Listener Discovery (MLD) for IPv6&lt;/i&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt; &lt;i&gt;RFC 3810: Multicast Listener Discovery Version 2 (MLDv2) for IPv6&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 소켓 에 대한 채널의 경우 기본 운영 체제는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt;&lt;i&gt;RFC 2236 : IGMPv2 (Internet Group Management Protocol, Version 2)를&lt;/i&gt;&lt;/a&gt; 선택적으로 지원합니다 . IGMPv2가 지원되면 운영 체제는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt;&lt;i&gt;RFC 3376 : IGMPv3 (Internet Group Management Protocol, Version 3)에&lt;/i&gt;&lt;/a&gt; 지정된대로 소스 필터링을 추가로 지원할 수 있습니다 . 에 채널 &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 소켓에 해당하는 표준은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt;&lt;i&gt;IPv6에 대한 멀티 캐스트 수신기 검색 (MLD) : RFC 2710&lt;/i&gt;&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt;&lt;i&gt;RFC 3810 : IPv6에 대한 멀티 캐스트 수신기 검색 버전 2 (MLDv2 특정)을&lt;/i&gt;&lt;/a&gt; . &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="19a2051fd0e5e72f45a371eb872d31545b4adfc3" translate="yes" xml:space="preserve">
          <source>In the case of a channel to an &lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket, the underlying operating system supports &lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt; &lt;i&gt;RFC 2236: Internet Group Management Protocol, Version 2 (IGMPv2)&lt;/i&gt;&lt;/a&gt;. It may optionally support source filtering as specified by &lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt; &lt;i&gt;RFC 3376: Internet Group Management Protocol, Version 3 (IGMPv3)&lt;/i&gt;&lt;/a&gt;. For channels to an &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket, the equivalent standards are &lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt; &lt;i&gt;RFC 2710: Multicast Listener Discovery (MLD) for IPv6&lt;/i&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt; &lt;i&gt;RFC 3810: Multicast Listener Discovery Version 2 (MLDv2) for IPv6&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 소켓 에 대한 채널의 경우 기본 운영 체제는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt;&lt;i&gt;RFC 2236 : IGMPv2 (Internet Group Management Protocol, Version 2)를 지원&lt;/i&gt;&lt;/a&gt; 합니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt;&lt;i&gt;RFC 3376 : IGMPv3 (Internet Group Management Protocol, Version 3)에&lt;/i&gt;&lt;/a&gt; 지정된 소스 필터링을 선택적으로 지원할 수 있습니다 . &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 소켓에 대한 채널의 경우 동등한 표준은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt;&lt;i&gt;RFC 2710 : IPv6 용 MLD (Multicast Listener Discovery)&lt;/i&gt;&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt;&lt;i&gt;RFC 3810 : IPv6 용 MLDv2 (Multicast Listener Discovery Version 2)입니다&lt;/i&gt;&lt;/a&gt; . &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="e531c3c2e234b2ee1973c771c135218a06466ad9" translate="yes" xml:space="preserve">
          <source>In the case of a gap, when clocks jump forward, there is no valid offset. Instead, the local date-time is adjusted to be later by the length of the gap. For a typical one hour daylight savings change, the local date-time will be moved one hour later into the offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">간격이있는 경우 클럭이 앞으로 점프 할 때 유효한 오프셋이 없습니다. 대신, 현지 날짜-시간은 간격의 길이만큼 나중에 조정됩니다. 전형적인 1 시간 일광 절약 시간제 변경의 경우, 현지 날짜-시간은 1 시간 후에 일반적으로 &quot;여름&quot;에 해당하는 오프셋으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9fb01ead713905f1c81d4e6999c70b57340a9655" translate="yes" xml:space="preserve">
          <source>In the case of a gap, where clocks jump forward, there is no valid offset. Instead, the local date-time is adjusted to be later by the length of the gap. For a typical one hour daylight savings change, the local date-time will be moved one hour later into the offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">클럭이 앞으로 이동하는 간격의 경우 유효한 오프셋이 없습니다. 대신, 현지 날짜-시간은 간격의 길이만큼 나중에 조정됩니다. 전형적인 1 시간 일광 절약 시간제 변경의 경우, 현지 날짜-시간은 1 시간 후에 일반적으로 &quot;여름&quot;에 해당하는 오프셋으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b86e31d3309c9966888d1ce571949f78da06b9f0" translate="yes" xml:space="preserve">
          <source>In the case of a periodic notification, the value of parameter</source>
          <target state="translated">주기적 알림의 경우 매개 변수 값</target>
        </trans-unit>
        <trans-unit id="96af2556cfa1cd3f7eb8b73ee624b6aaa0970cfe" translate="yes" xml:space="preserve">
          <source>In the case of a periodic notification, uses a</source>
          <target state="translated">정기적 인 알림의 경우</target>
        </trans-unit>
        <trans-unit id="c9d56fa1d686e2f987ac2bf8aff1d4833e84b98f" translate="yes" xml:space="preserve">
          <source>In the case of a stored entry, the compressed size will be the same as the uncompressed size of the entry.</source>
          <target state="translated">저장된 항목의 경우 압축 된 크기는 압축되지 않은 항목의 크기와 같습니다.</target>
        </trans-unit>
        <trans-unit id="79f5f7cb66c356485e0341ec28ed935ec708859f" translate="yes" xml:space="preserve">
          <source>In the case of an error event, the &lt;code&gt;SQLException&lt;/code&gt; about to be thrown to the application</source>
          <target state="translated">오류 이벤트의 경우 애플리케이션에 던져 질 &lt;code&gt;SQLException&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db9e1ca64bffdeb509e25f717c03ee7e37e961d7" translate="yes" xml:space="preserve">
          <source>In the case of jar: and file: URLs, it also closes any files that were opened by it. If another thread is loading a class when the &lt;code&gt;close&lt;/code&gt; method is invoked, then the result of that load is undefined.</source>
          <target state="translated">jar : 및 file : URL의 경우이 파일에서 연 파일도 닫습니다. &lt;code&gt;close&lt;/code&gt; 메소드가 호출 될 때 다른 스레드가 클래스를로드하는 경우 해당로드의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d29bc847b83395a5115bf2af88720192d26de17" translate="yes" xml:space="preserve">
          <source>In the case of nested elements mouse events are always targeted at the most deeply nested element. Ancestors of the targeted element may use bubbling to obtain notification of mouse events which occur within its descendent elements.</source>
          <target state="translated">중첩 된 요소의 경우 마우스 이벤트는 항상 가장 깊이 중첩 된 요소를 대상으로합니다. 대상 요소의 조상은 버블 링을 사용하여 하위 요소 내에서 발생하는 마우스 이벤트 알림을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4807dcb176adbdc605239808fd2a7d991465460a" translate="yes" xml:space="preserve">
          <source>In the case of stream-oriented sockets and the TCP/IP protocol, the size of the socket receive buffer may be used when advertising the size of the TCP receive window to the remote peer.</source>
          <target state="translated">스트림 지향 소켓 및 TCP / IP 프로토콜의 경우, 소켓 수신 버퍼의 크기는 TCP 수신 창의 크기를 원격 피어에 알릴 때 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf471b822472cd913bb8281589b6b04dc469c7d2" translate="yes" xml:space="preserve">
          <source>In the case of stream-oriented sockets, this socket option usually allows multiple listening sockets to be bound to both same address and same port.</source>
          <target state="translated">스트림 지향 소켓의 경우이 소켓 옵션을 사용하면 일반적으로 여러 청취 소켓을 동일한 주소와 동일한 포트에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1564f388d1bc3d2b047f3cec6463a2aca746fb14" translate="yes" xml:space="preserve">
          <source>In the case of stream-oriented sockets, this socket option will usually determine whether the socket can be bound to a socket address when a previous connection involving that socket address is in the &lt;em&gt;TIME_WAIT&lt;/em&gt; state. On implementations where the semantics differ, and the socket option is not required to be enabled in order to bind the socket when a previous connection is in this state, then the implementation may choose to ignore this option.</source>
          <target state="translated">스트림 지향 소켓의 경우,이 소켓 옵션은 일반적으로 해당 소켓 주소와 관련된 이전 연결이 &lt;em&gt;TIME_WAIT&lt;/em&gt; 상태에 있을 때 소켓이 소켓 주소에 바인드 될 수 있는지 여부를 판별합니다 . 시맨틱이 다르고 이전 연결이이 상태에있을 때 소켓을 바인드하기 위해 소켓 옵션을 사용할 필요가없는 구현에서는 구현시이 옵션을 무시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbce8b76773e0924f547ca32e02c138abec61f0c" translate="yes" xml:space="preserve">
          <source>In the case of the default &lt;a href=&quot;spi/filesystemprovider&quot;&gt;&lt;code&gt;provider&lt;/code&gt;&lt;/a&gt;, and a security manager is set, then the permission checks are performed using the path obtained by resolving the given relative path against the</source>
          <target state="translated">기본 &lt;a href=&quot;spi/filesystemprovider&quot;&gt; &lt;code&gt;provider&lt;/code&gt; &lt;/a&gt; 의 경우 , 보안 관리자가 설정된 경우 권한 검사는 지정된 상대 경로를 해결하여 얻은 경로를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5968dc2de2ab512d950a835df9b47f509611629e" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, and a security manager is installed, the security manager is invoked to check &lt;a href=&quot;../../lang/runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt;. If denied, then no file stores are returned by the iterator. In addition, the security manager's &lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to the file store's &lt;em&gt;top-most&lt;/em&gt; directory. If denied, the file store is not returned by the iterator. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">기본 공급자의 경우 보안 관리자가 설치된 경우 보안 관리자가 호출되어 &lt;a href=&quot;../../lang/runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt; 을 확인 합니다. 거부되면 반복기에 의해 파일 저장소가 반환되지 않습니다. 또한 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt; 메서드가 호출되어 파일 저장소의 &lt;em&gt;최상위&lt;/em&gt; 디렉터리에 대한 읽기 액세스 권한을 확인 합니다. 거부 된 경우 파일 저장소는 반복기에 의해 반환되지 않습니다. 반복기가 확보 될 때 또는 반복 중에 권한 검사가 수행되는지 여부는 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9d2512a124feacc9023efa7b4655feac56aa98d5" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, and a security manager is installed, the security manager is invoked to check &lt;a href=&quot;../../lang/runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt;. If denied, then no file stores are returned by the iterator. In addition, the security manager's &lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to the file store's &lt;em&gt;top-most&lt;/em&gt; directory. If denied, the file store is not returned by the iterator. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">기본 제공자의 경우 보안 관리자가 설치되어 있으면 &lt;a href=&quot;../../lang/runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt; 을 확인하기 위해 보안 관리자가 호출됩니다 . 거부되면, 반복자가 파일 저장소를 리턴하지 않습니다. 또한 파일 관리자 의 &lt;em&gt;최상위&lt;/em&gt; 디렉토리에 대한 읽기 액세스를 확인하기 위해 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다 . 거부되면, 반복자가 파일 저장소를 리턴하지 않습니다. 반복기가 확보 될 때 또는 반복 중에 권한 점검이 수행되는지 여부는 시스템에 따라 다릅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea663ac7ab663b6f6b3fe5151c0ca401f469a636" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, identified by the URI scheme &quot;file&quot;, the given URI has a non-empty path component, and undefined query and fragment components. Whether the authority component may be present is platform specific. The returned &lt;code&gt;Path&lt;/code&gt; is associated with the &lt;a href=&quot;filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system.</source>
          <target state="translated">URI 체계 &quot;파일&quot;로 식별되는 기본 공급자의 경우 지정된 URI에는 비어 있지 않은 경로 구성 요소와 정의되지 않은 쿼리 및 조각 구성 요소가 있습니다. 권한 구성 요소의 존재 여부는 플랫폼에 따라 다릅니다. 반환 된 &lt;code&gt;Path&lt;/code&gt; 는 &lt;a href=&quot;filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 과 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4b5c76d8aaed40c475f832a5a54a3692fea75a4" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, identified by the URI scheme &quot;file&quot;, the given URI has a non-empty path component, and undefined query and fragment components. Whether the authority component may be present is platform specific. The returned &lt;code&gt;Path&lt;/code&gt; is associated with the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system.</source>
          <target state="translated">URI 체계 &quot;file&quot;로 식별되는 기본 제공자의 경우, 제공된 URI에는 비어 있지 않은 경로 구성 요소와 정의되지 않은 조회 및 단편 구성 요소가 있습니다. 권한 구성 요소가 존재하는지 여부는 플랫폼마다 다릅니다. 리턴 된 &lt;code&gt;Path&lt;/code&gt; 는 &lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 과 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="99df03667bc9a4291eea54f38aa6ac17e53c146f" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, path strings are parsed based on the definition of paths at the platform or virtual file system level. For example, an operating system may not allow specific characters to be present in a file name, but a specific underlying file store may impose different or additional restrictions on the set of legal characters.</source>
          <target state="translated">기본 제공자의 경우 플랫폼 또는 가상 파일 시스템 레벨에서 경로 정의에 따라 경로 문자열이 구문 분석됩니다. 예를 들어, 운영 체제는 파일 이름에 특정 문자를 허용하지 않을 수 있지만 특정 기본 파일 저장소는 유효한 문자 세트에 서로 다른 또는 추가 제한 사항을 부과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e677b2f41e86e85d7c1fa6979a637c642297d74" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, the URI is hierarchical with a &lt;a href=&quot;../../net/uri#getPath()&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt; component that is absolute. The query and fragment components are undefined. Whether the authority component is defined or not is implementation dependent. There is no guarantee that the &lt;code&gt;URI&lt;/code&gt; may be used to construct a &lt;a href=&quot;../../io/file&quot;&gt;&lt;code&gt;java.io.File&lt;/code&gt;&lt;/a&gt;. In particular, if this path represents a Universal Naming Convention (UNC) path, then the UNC server name may be encoded in the authority component of the resulting URI. In the case of the default provider, and the file exists, and it can be determined that the file is a directory, then the resulting &lt;code&gt;URI&lt;/code&gt; will end with a slash.</source>
          <target state="translated">기본 공급자의 경우 URI 는 절대 &lt;a href=&quot;../../net/uri#getPath()&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 구성 요소를 사용하여 계층 적입니다 . 쿼리 및 조각 구성 요소가 정의되지 않았습니다. 권한 구성 요소가 정의되었는지 여부는 구현에 따라 다릅니다. &lt;code&gt;URI&lt;/code&gt; 가 &lt;a href=&quot;../../io/file&quot;&gt; &lt;code&gt;java.io.File&lt;/code&gt; &lt;/a&gt; 구성에 사용될 수 있다는 보장은 없습니다 . 특히이 경로가 UNC (Universal Naming Convention) 경로를 나타내는 경우 UNC 서버 이름은 결과 URI의 기관 구성 요소에 인코딩 될 수 있습니다. 기본 공급자의 경우 파일이 있고 파일이 디렉토리임을 확인할 수 있으며 결과 &lt;code&gt;URI&lt;/code&gt; 는 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="a898e5309a9ca4566bd5a4562ddfa9fccc431258" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, the URI is hierarchical with a &lt;a href=&quot;../../net/uri#getPath--&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt; component that is absolute. The query and fragment components are undefined. Whether the authority component is defined or not is implementation dependent. There is no guarantee that the &lt;code&gt;URI&lt;/code&gt; may be used to construct a &lt;a href=&quot;../../io/file&quot;&gt;&lt;code&gt;java.io.File&lt;/code&gt;&lt;/a&gt;. In particular, if this path represents a Universal Naming Convention (UNC) path, then the UNC server name may be encoded in the authority component of the resulting URI. In the case of the default provider, and the file exists, and it can be determined that the file is a directory, then the resulting &lt;code&gt;URI&lt;/code&gt; will end with a slash.</source>
          <target state="translated">기본 제공자의 경우, &lt;a href=&quot;../../net/uri#getPath--&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 구성 요소가 절대 경로 인 URI는 계층 적입니다 . 쿼리 및 조각 구성 요소는 정의되어 있지 않습니다. 권한 구성 요소의 정의 여부는 구현에 따라 다릅니다. &lt;code&gt;URI&lt;/code&gt; 가 &lt;a href=&quot;../../io/file&quot;&gt; &lt;code&gt;java.io.File&lt;/code&gt; &lt;/a&gt; 을 구성하는 데 사용될 수 있다는 보장은 없습니다 . 특히,이 경로가 UNC (Universal Naming Convention) 경로를 나타내는 경우, UNC 서버 이름은 결과 URI의 권한 구성 요소로 인코딩 될 수 있습니다. 기본 제공자의 경우 파일이 존재하고 파일이 디렉토리임을 판별 할 수 있으며 결과 &lt;code&gt;URI&lt;/code&gt; 는 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="4e1f93856d74c7fdd21e5edb4105cb0eea03c3e1" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, the returned seekable byte channel is a &lt;a href=&quot;../channels/filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 공급자의 경우 반환 된 검색 가능한 바이트 채널은 &lt;a href=&quot;../channels/filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e6297028bcf457506860f8e5340cbccdf1009eaa" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, this method returns the same separator as &lt;a href=&quot;../../io/file#separator&quot;&gt;&lt;code&gt;File.separator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 공급자의 경우이 메서드는 &lt;a href=&quot;../../io/file#separator&quot;&gt; &lt;code&gt;File.separator&lt;/code&gt; &lt;/a&gt; 와 동일한 구분 기호를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3d33ebb7e876e61c518f2ef8d424778898f27226" translate="yes" xml:space="preserve">
          <source>In the case that the variant contains one or more underscores ('_'), a sequence of bundle names generated by truncating the last underscore and the part following it is inserted after a candidate bundle name with the original variant. For example, for a locale with language &quot;en&quot;, script &quot;Latn, country &quot;US&quot; and variant &quot;WINDOWS_VISTA&quot;, and bundle base name &quot;MyResource&quot;, the list of candidate bundle names below is generated:</source>
          <target state="translated">변형에 하나 이상의 밑줄 ( '_')이 포함 된 경우 마지막 밑줄과 그 뒤에 오는 부분을 잘라서 생성 된 일련의 번들 이름은 원래 변형이있는 후보 번들 이름 뒤에 삽입됩니다. 예를 들어, 언어 &quot;en&quot;, 스크립트 &quot;Latn, 국가&quot;US &quot;및 변형&quot;WINDOWS_VISTA &quot;및 번들 기본 이름&quot;MyResource &quot;가있는 로케일의 경우 아래 후보 번들 이름 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="97ac944d7ca320a7d3a94df81af470a08f017bde" translate="yes" xml:space="preserve">
          <source>In the case where ProcessHandles cannot be supported then the factory methods must consistently throw &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;. The methods of this class throw &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; if the operating system does not allow access to query or kill a process.</source>
          <target state="translated">ProcessHandles를 지원할 수없는 경우 팩토리 메서드는 일관되게 &lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을&lt;/a&gt; throw해야합니다 . 운영 체제가 쿼리에 대한 액세스를 허용하지 않거나 프로세스를 종료 할 수없는 경우이 클래스의 메서드는 &lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을&lt;/a&gt; throw 합니다.</target>
        </trans-unit>
        <trans-unit id="fa5051ebc5f7be9551f7d184b62acf3110ac4cef" translate="yes" xml:space="preserve">
          <source>In the case where a new connection needs to be established, if the connection cannot be established within the given &lt;code&gt;
 duration&lt;/code&gt;, then &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;&lt;code&gt;HttpClient::send&lt;/code&gt;&lt;/a&gt; throws an &lt;a href=&quot;httpconnecttimeoutexception&quot;&gt;&lt;code&gt;HttpConnectTimeoutException&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;httpclient#sendAsync(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;&lt;code&gt;HttpClient::sendAsync&lt;/code&gt;&lt;/a&gt; completes exceptionally with an &lt;code&gt;HttpConnectTimeoutException&lt;/code&gt;. If a new connection does not need to be established, for example if a connection can be reused from a previous request, then this timeout duration has no effect.</source>
          <target state="translated">새 연결이 연결이 주어진 내에 설립 할 수없는 경우, 설립 할 필요가있는 경우에는 &lt;code&gt; duration&lt;/code&gt; 후, &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt; &lt;code&gt;HttpClient::send&lt;/code&gt; &lt;/a&gt; 발생 &lt;a href=&quot;httpconnecttimeoutexception&quot;&gt; &lt;code&gt;HttpConnectTimeoutException&lt;/code&gt; 을&lt;/a&gt; , 또는 &lt;a href=&quot;httpclient#sendAsync(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt; &lt;code&gt;HttpClient::sendAsync&lt;/code&gt; &lt;/a&gt; 와 매우 완료 &lt;code&gt;HttpConnectTimeoutException&lt;/code&gt; . 예를 들어 이전 요청에서 연결을 다시 사용할 수있는 경우와 같이 새 연결을 설정할 필요가없는 경우이 제한 시간이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52c38dad2c1d9a6ad351c582c8369d290f1b4496" translate="yes" xml:space="preserve">
          <source>In the case where end of stream is reached before &lt;code&gt;len&lt;/code&gt; bytes have been read, then the actual number of bytes read will be returned. When this stream reaches end of stream, further invocations of this method will return zero.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 바이트를 읽기 전에 스트림의 끝에 도달 하면 읽은 실제 바이트 수가 반환됩니다. 이 스트림이 스트림 끝에 도달하면이 메서드를 추가로 호출하면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7b93472fb0fb86fea81d8d8443ed8bdc46acd42" translate="yes" xml:space="preserve">
          <source>In the case where multiple LoginModules fail, this method propagates the exception raised by the first &lt;code&gt;LoginModule&lt;/code&gt; which failed.</source>
          <target state="translated">여러 LoginModule이 실패한 경우이 메소드는 실패한 첫 번째 &lt;code&gt;LoginModule&lt;/code&gt; 에서 발생한 예외를 전파합니다 .</target>
        </trans-unit>
        <trans-unit id="a70c45e6aeb095e66dfd74054e5938ceea08a232" translate="yes" xml:space="preserve">
          <source>In the common case, all of the pre-connection parameters and general request properties can be ignored: the pre-connection parameters and request properties default to sensible values. For most clients of this interface, there are only two interesting methods: &lt;code&gt;getInputStream&lt;/code&gt; and &lt;code&gt;getContent&lt;/code&gt;, which are mirrored in the &lt;code&gt;URL&lt;/code&gt; class by convenience methods.</source>
          <target state="translated">일반적인 경우, 모든 사전 연결 매개 변수 및 일반 요청 특성을 무시할 수 있습니다. 사전 연결 매개 변수 및 요청 특성의 기본값은 적절한 값입니다. 이 인터페이스의 대부분의 클라이언트에는 편리한 메소드에 의해 &lt;code&gt;URL&lt;/code&gt; 클래스에 미러링되는 &lt;code&gt;getInputStream&lt;/code&gt; 및 &lt;code&gt;getContent&lt;/code&gt; 의 두 가지 흥미로운 메소드 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc4e72373a72929421b52e76471660916eb25cad" translate="yes" xml:space="preserve">
          <source>In the context of &lt;a href=&quot;../../../annotation/processing/processingenvironment&quot;&gt;annotation processing&lt;/a&gt;, the guarantees for &quot;the same&quot; implementation must include contexts where the &lt;a href=&quot;../../../annotation/processing/package-summary&quot;&gt;API mediated&lt;/a&gt; side effects of &lt;a href=&quot;../../../annotation/processing/processor&quot;&gt;processors&lt;/a&gt; could be visible to each other, including successive annotation processing &lt;a href=&quot;../../../annotation/processing/roundenvironment&quot;&gt;rounds&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../annotation/processing/processingenvironment&quot;&gt;주석 처리&lt;/a&gt; 의 맥락에서 , &quot;동일한&quot;구현에 대한 보장은 연속적인 주석 처리 &lt;a href=&quot;../../../annotation/processing/roundenvironment&quot;&gt;라운드를&lt;/a&gt; 포함하여 &lt;a href=&quot;../../../annotation/processing/processor&quot;&gt;프로세서&lt;/a&gt; 의 &lt;a href=&quot;../../../annotation/processing/package-summary&quot;&gt;API 매개&lt;/a&gt; 부작용 이 서로에게 보일 수있는 컨텍스트를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="47f91444a15f2bda2fa6d35d205ab3bb0e17ca5f" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXResult&lt;/code&gt;, it is not appropriate to explicitly set the system identifier.</source>
          <target state="translated">&lt;code&gt;StAXResult&lt;/code&gt; 컨텍스트 에서 시스템 식별자를 명시 적으로 설정하는 것은 적절하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf720f95058f2decf42fefd32a1e2515dafa3d6f" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXResult&lt;/code&gt;, it is not appropriate to explicitly set the system identifier. The &lt;code&gt;XMLEventWriter&lt;/code&gt; or &lt;code&gt;XMLStreamWriter&lt;/code&gt; used to construct this &lt;code&gt;StAXResult&lt;/code&gt; determines the system identifier of the XML result.</source>
          <target state="translated">&lt;code&gt;StAXResult&lt;/code&gt; 컨텍스트 에서 시스템 식별자를 명시 적으로 설정하는 것은 적절하지 않습니다. &lt;code&gt;XMLEventWriter&lt;/code&gt; 또는 &lt;code&gt;XMLStreamWriter&lt;/code&gt; 에은 이 구성하는데 사용 &lt;code&gt;StAXResult&lt;/code&gt; 을 하는 XML 결과의 시스템 식별자를 결정한다.</target>
        </trans-unit>
        <trans-unit id="d34a9a5234275a7027509815264f773e5a1e5697" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXSource&lt;/code&gt;, it is not appropriate to explicitly set the system identifier.</source>
          <target state="translated">&lt;code&gt;StAXSource&lt;/code&gt; 의 컨텍스트 에서 시스템 식별자를 명시 적으로 설정하는 것은 적절하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a373946bb662d5a2a82c9ba24e1f7f6ecff6794" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXSource&lt;/code&gt;, it is not appropriate to explicitly set the system identifier. The &lt;code&gt;XMLStreamReader&lt;/code&gt; or &lt;code&gt;XMLEventReader&lt;/code&gt; used to construct this &lt;code&gt;StAXSource&lt;/code&gt; determines the system identifier of the XML source.</source>
          <target state="translated">&lt;code&gt;StAXSource&lt;/code&gt; 의 컨텍스트 에서 시스템 식별자를 명시 적으로 설정하는 것은 적절하지 않습니다. &lt;code&gt;XMLStreamReader&lt;/code&gt; 또는 &lt;code&gt;XMLEventReader&lt;/code&gt; 의 이 구성하는데 사용 &lt;code&gt;StAXSource&lt;/code&gt; 의은 XML 소스의 시스템 식별자를 결정한다.</target>
        </trans-unit>
        <trans-unit id="b0fc226575948bc5d8749aeade7f2700d90dccef" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;threadpoolexecutor.abortpolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt;&lt;/a&gt;, the handler throws a runtime &lt;a href=&quot;rejectedexecutionexception&quot;&gt;&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/a&gt; upon rejection.</source>
          <target state="translated">기본 &lt;a href=&quot;threadpoolexecutor.abortpolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt; &lt;/a&gt; 에서 핸들러는 &lt;a href=&quot;rejectedexecutionexception&quot;&gt; &lt;code&gt;RejectedExecutionException&lt;/code&gt; &lt;/a&gt; 시 런타임 RejectedExecutionException 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="48bb0c8e4f3b335269acf6c1e788fce51afc4c47" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, June 2012 would have the value &lt;code&gt;(2012 * 12 + 6 - 1)&lt;/code&gt;. This field is primarily for internal use.</source>
          <target state="translated">기본 ISO 캘린더 시스템에서 2012 년 6 월의 값은 &lt;code&gt;(2012 * 12 + 6 - 1)&lt;/code&gt; 입니다. 이 필드는 주로 내부 용입니다.</target>
        </trans-unit>
        <trans-unit id="e85a59438f2ed3bcea699be96233c620667aa495" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value. The era 'BCE' is the previous era, and the year-of-era runs backwards.</source>
          <target state="translated">기본 ISO 캘린더 시스템에는 'BCE'와 'CE'의 두 가지 기간이 정의되어 있습니다. 'CE'는 현재 사용되고있는 연도이며 1 년에서 최대 값까지 연도입니다. 시대 'BCE'는 이전 시대이며, 연도는 거꾸로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0553d6dc2b136e33c3dc86748155cb284b375b0b" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value. The era 'BCE' is the previous era, and the year-of-era runs backwards. See &lt;a href=&quot;#YEAR_OF_ERA&quot;&gt;&lt;code&gt;YEAR_OF_ERA&lt;/code&gt;&lt;/a&gt; for a full example.</source>
          <target state="translated">기본 ISO 달력 시스템에는 'BCE'와 'CE'라는 두 가지 시대가 정의되어 있습니다. 'CE'시대는 현재 사용 중이며 시대는 1에서 최대 값까지 실행됩니다. 'BCE'시대는 이전 시대이고 시대는 거꾸로갑니다. 전체 예는 &lt;a href=&quot;#YEAR_OF_ERA&quot;&gt; &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2989432ae07e543d739ca5a5f8fcc5927ec8aa7" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value. The era 'BCE' is the previous era, and the year-of-era runs backwards. See &lt;a href=&quot;chronofield#YEAR_OF_ERA&quot;&gt;&lt;code&gt;YEAR_OF_ERA&lt;/code&gt;&lt;/a&gt; for a full example.</source>
          <target state="translated">기본 ISO 캘린더 시스템에는 'BCE'와 'CE'의 두 가지 기간이 정의되어 있습니다. 'CE'는 현재 사용되고있는 연도이며 1 년에서 최대 값까지 연도입니다. 시대 'BCE'는 이전 시대이며, 연도는 거꾸로 실행됩니다. 전체 예는 &lt;a href=&quot;chronofield#YEAR_OF_ERA&quot;&gt; &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd780fa87d177f6d0024f4d49192abdd1c6c63cd" translate="yes" xml:space="preserve">
          <source>In the definitions below, an annotation</source>
          <target state="translated">아래 정의에서 주석</target>
        </trans-unit>
        <trans-unit id="09bc6c63a67020bf7c2978262bc3265e74344acb" translate="yes" xml:space="preserve">
          <source>In the detailed explanations below, if &quot;&lt;code&gt;a&lt;/code&gt;&quot; represents an instance of document data, then the result of processing the data in document &quot;&lt;code&gt;a&lt;/code&gt;&quot; is a sequence of media sheets represented by &quot;&lt;code&gt;a(*)&lt;/code&gt;&quot;.</source>
          <target state="translated">이하의 상세한 설명에서, &quot; &lt;code&gt;a&lt;/code&gt; &quot;가 문서 데이터의 인스턴스를 나타내는 경우, 문서 &quot; &lt;code&gt;a&lt;/code&gt; &quot; 의 데이터를 처리 한 결과는 &quot; &lt;code&gt;a(*)&lt;/code&gt; &quot;로 표시되는 일련의 미디어 시트 이다.</target>
        </trans-unit>
        <trans-unit id="b0f79dec8b3ab7b6c24fbe11e1ac1e7891ecced8" translate="yes" xml:space="preserve">
          <source>In the event that multiple package defaults apply to a given class, the package default pertaining to the most specific package takes precedence over the others. For example, if &lt;code&gt;javax.lang&lt;/code&gt; and &lt;code&gt;javax.lang.reflect&lt;/code&gt; both have package defaults associated with them, the latter package default applies to classes in &lt;code&gt;javax.lang.reflect&lt;/code&gt;.</source>
          <target state="translated">여러 패키지 기본값이 지정된 클래스에 적용되는 경우 가장 구체적인 패키지와 관련된 패키지 기본값이 다른 패키지보다 우선합니다. 예를 들어, &lt;code&gt;javax.lang&lt;/code&gt; 및 &lt;code&gt;javax.lang.reflect&lt;/code&gt; 에 패키지 기본값이 모두 연관된 경우 후자의 패키지 기본값은 &lt;code&gt;javax.lang.reflect&lt;/code&gt; 의 클래스에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e8bb46a346e88375edb24d85374a9154807145b" translate="yes" xml:space="preserve">
          <source>In the event that the plugin is provided as part of a named module, that module must export the package containing the implementation class to the</source>
          <target state="translated">플러그인이 명명 된 모듈의 일부로 제공되는 경우 해당 모듈은 구현 클래스를 포함하는 패키지를</target>
        </trans-unit>
        <trans-unit id="be93f24cde87a11bdd29fa572b15cfd5ab339a32" translate="yes" xml:space="preserve">
          <source>In the event that the user does not set the first keyframe value equal to 0 and/or the last keyframe value equal to 1, keyframes will be created at these positions and the first and last colors will be replicated there. So, if a user specifies the following arrays to construct a gradient:</source>
          <target state="translated">사용자가 첫 번째 키 프레임 값을 0 및 / 또는 마지막 키 프레임 값을 1로 설정하지 않은 경우 이러한 위치에 키 프레임이 생성되고 첫 번째 및 마지막 색상이 여기에 복제됩니다. 따라서 사용자가 그라디언트를 구성하기 위해 다음 배열을 지정하면 :</target>
        </trans-unit>
        <trans-unit id="00fd509d5a993973e1038d029ec2399af029eb1f" translate="yes" xml:space="preserve">
          <source>In the example above, we initialize a &lt;code&gt;Range&lt;/code&gt; object which implements the &lt;code&gt;Predicate&lt;/code&gt; interface. This object expresses the following constraints: All rows outputted or modified from this &lt;code&gt;FilteredRowSet&lt;/code&gt; object must fall between the values 'Alpha' and 'Bravo' both values inclusive, in the column 'columnName'. If a filter is applied to a &lt;code&gt;FilteredRowSet&lt;/code&gt; object that contains no data that falls within the range of the filter, no rows are returned.</source>
          <target state="translated">위의 예에서는 &lt;code&gt;Predicate&lt;/code&gt; 인터페이스 를 구현 하는 &lt;code&gt;Range&lt;/code&gt; 개체를 초기화합니다 . 이 개체는 다음 제약 조건을 표현합니다.이 &lt;code&gt;FilteredRowSet&lt;/code&gt; 개체 에서 출력되거나 수정 된 모든 행 은 'columnName'열에서 값 'Alpha'및 'Bravo'값 (둘 다 포함) 사이에 있어야합니다. 필터 범위에 속하는 데이터가없는 &lt;code&gt;FilteredRowSet&lt;/code&gt; 개체에 필터를 적용하면 행이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1500759c4854f4c300acd35e9ef7742f5686f96" translate="yes" xml:space="preserve">
          <source>In the example below, the reference &lt;code&gt;CachedRowSetImpl&lt;/code&gt; implementation reconfigures its current &lt;code&gt;SyncProvider&lt;/code&gt; object by calling the &lt;code&gt;setSyncProvider&lt;/code&gt; method.</source>
          <target state="translated">아래 예에서 참조 &lt;code&gt;CachedRowSetImpl&lt;/code&gt; 구현 은 &lt;code&gt;setSyncProvider&lt;/code&gt; 메소드 를 호출하여 현재 &lt;code&gt;SyncProvider&lt;/code&gt; 객체를 재구성합니다 .</target>
        </trans-unit>
        <trans-unit id="05277234739d6763969157714d95b5b473c13a38" translate="yes" xml:space="preserve">
          <source>In the example, if the content of a document is the sequence &quot;The quick brown fox,&quot; as shown in the preceding diagram, the location just before the word &quot;The&quot; is 0, and the location after the word &quot;The&quot; and before the whitespace that follows it is 3. The entire sequence of characters in the sequence &quot;The&quot; is called a &lt;em&gt;range&lt;/em&gt;.</source>
          <target state="translated">예에서 문서의 내용이 앞의 다이어그램에 표시된대로 &quot;The quick brown fox&quot;시퀀스 인 경우 &quot;The&quot;단어 바로 앞의 위치는 0이고 &quot;The&quot;단어 뒤의 위치는 그 뒤에 오는 공백은 3입니다. &quot;The&quot;시퀀스의 전체 문자 시퀀스를 &lt;em&gt;범위&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="b8e11d48b9526227594c6c159985f8ef09465796" translate="yes" xml:space="preserve">
          <source>In the figure, the first index (0) corresponds to the first column, the second index (1) to the second column, and so on. The first column's position starts at 0, and the column occupies &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; pixels, where &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; is the value returned by &lt;code&gt;getSize(0)&lt;/code&gt;. Thus, the first column ends at &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; - 1. The second column then begins at the position &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; and occupies &lt;em&gt;size&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; (&lt;code&gt;getSize(1)&lt;/code&gt;) pixels.</source>
          <target state="translated">그림에서 첫 번째 인덱스 (0)는 첫 번째 열에 해당하고 두 번째 인덱스 (1)는 두 번째 열에 해당하는 식입니다. 첫 번째 열의 위치는 0에서 시작하고 열은 &lt;em&gt;크기 &lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; 픽셀을 차지 &lt;em&gt;합니다&lt;/em&gt; . 여기서 &lt;em&gt;크기 &lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; 은 &lt;code&gt;getSize(0)&lt;/code&gt; 반환 된 값 입니다. 따라서,의 첫 번째 열이 종료 &lt;em&gt;크기 &lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; - 1 번째 열은 그 위치에서 시작하여 &lt;em&gt;크기가 &lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; 과 차지하는 &lt;em&gt;크기 &lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; ( &lt;code&gt;getSize(1)&lt;/code&gt; ) 픽셀.</target>
        </trans-unit>
        <trans-unit id="497f116b21347428eb7a6e8312ca399ca290624a" translate="yes" xml:space="preserve">
          <source>In the final case, it is exactly as if the target method handle were temporarily adapted with a &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;fixed arity collector&lt;/a&gt; to the arity required by the caller type. (As with &lt;code&gt;asCollector&lt;/code&gt;, if the array length is zero, a shared constant may be used instead of a new array. If the implied call to &lt;code&gt;asCollector&lt;/code&gt; would throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; or &lt;code&gt;WrongMethodTypeException&lt;/code&gt;, the call to the variable arity adapter must throw &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.)</source>
          <target state="translated">마지막 경우에는 대상 메서드 핸들이 호출자 유형에 필요한 &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;arity&lt;/a&gt; 에 고정 된 arity 수집기 를 사용하여 일시적으로 조정 된 것과 같습니다 . ( &lt;code&gt;asCollector&lt;/code&gt; 와 마찬가지로 배열 길이가 0이면 새 배열 대신 공유 상수를 사용할 수 있습니다. &lt;code&gt;asCollector&lt;/code&gt; 에 대한 암시 적 호출이 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 또는 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; 을 throw하는 경우 변수 arity 어댑터에 대한 호출은 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; 을 throw해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="6debf46fe39f4012b9544dd84da9e6f547b36977" translate="yes" xml:space="preserve">
          <source>In the final case, it is exactly as if the target method handle were temporarily adapted with a &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;fixed arity collector&lt;/a&gt; to the arity required by the caller type. (As with &lt;code&gt;asCollector&lt;/code&gt;, if the array length is zero, a shared constant may be used instead of a new array. If the implied call to &lt;code&gt;asCollector&lt;/code&gt; would throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; or &lt;code&gt;WrongMethodTypeException&lt;/code&gt;, the call to the variable arity adapter must throw &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.)</source>
          <target state="translated">마지막 경우, 대상 메소드 핸들이 호출자 유형에 필요한 &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;arity&lt;/a&gt; 에 고정 된 arity 콜렉터 로 임시로 조정 된 것과 같습니다 . ( &lt;code&gt;asCollector&lt;/code&gt; 와 마찬가지로 배열 길이가 0 인 경우, 공유 상수는 새로운 배열 대신 사용할 수있다.에 대한 묵시적 호출하면 &lt;code&gt;asCollector&lt;/code&gt; 이 던질 것이라고 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 또는 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; , 슬로우 할 필요가 변수 인수에 대응 어댑터에 전화 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; 를 .)</target>
        </trans-unit>
        <trans-unit id="0b39f33db050daf5a8b13214fd8a45e5e32089c0" translate="yes" xml:space="preserve">
          <source>In the first case the global color table in the stream metadata is used, in the second the local color table in the image metadata is used, and in the third a global color table is created from the ColorModel or SampleModel of the (first) image.</source>
          <target state="translated">첫 번째 경우에는 스트림 메타 데이터의 전체 색상 표가 사용되고 두 번째 경우 이미지 메타 데이터의 로컬 색상 표가 사용되고 세 번째 경우 (첫 번째) 이미지의 ColorModel 또는 SampleModel에서 전체 색상 표가 생성됩니다. .</target>
        </trans-unit>
        <trans-unit id="13e8476783a96421ed140a44cbc492ba23ff9c6b" translate="yes" xml:space="preserve">
          <source>In the first form, the methods defined by the &lt;a href=&quot;../../util/concurrent/future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; interface may be used to check if the operation has completed, wait for its completion, and to retrieve the result. In the second form, a &lt;a href=&quot;completionhandler&quot;&gt;&lt;code&gt;CompletionHandler&lt;/code&gt;&lt;/a&gt; is invoked to consume the result of the I/O operation when it completes or fails.</source>
          <target state="translated">첫 번째 형태에서 &lt;a href=&quot;../../util/concurrent/future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 인터페이스에는 조작이 완료되었는지 확인하고 완료를 기다린 후 결과를 검색하는 데 사용될 수 있습니다. 두 번째 양식에서는&lt;a href=&quot;completionhandler&quot;&gt; &lt;code&gt;CompletionHandler&lt;/code&gt; &lt;/a&gt; 가 호출되어 I / O 조작의 완료 또는 실패시 결과를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="3f3a74e19b90c7de60244c50e295be122becdcae" translate="yes" xml:space="preserve">
          <source>In the following code fragment, the table &lt;code&gt;EMPLOYEES&lt;/code&gt;, whose match column is set to the first column (&lt;code&gt;EMP_ID&lt;/code&gt;), is added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object</source>
          <target state="translated">다음 코드 조각에서 일치 열이 첫 번째 열 ( &lt;code&gt;EMP_ID&lt;/code&gt; ) 로 설정된 &lt;code&gt;EMPLOYEES&lt;/code&gt; 테이블 이 &lt;code&gt;JoinRowSet&lt;/code&gt; 개체에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ae14c7e2717e4399f35c3ed2c4bc1bb7e0a3378a" translate="yes" xml:space="preserve">
          <source>In the following example of setting a parameter, &lt;code&gt;con&lt;/code&gt; represents an active connection:</source>
          <target state="translated">다음 매개 변수 설정 예에서 &lt;code&gt;con&lt;/code&gt; 은 활성 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8831d20c4571848af5234f8bd06f8194e229c8bb" translate="yes" xml:space="preserve">
          <source>In the following sample:</source>
          <target state="translated">다음 샘플에서 :</target>
        </trans-unit>
        <trans-unit id="d4cbe4ad6c13a6890ddfa89884e27c69d70708df" translate="yes" xml:space="preserve">
          <source>In the foregoing description, the notation &lt;code&gt;sgn(&lt;/code&gt;</source>
          <target state="translated">전술 한 설명에서, 표기법 &lt;code&gt;sgn(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="956b372c4bfd9617b01cec8388ef9cee7031a6e7" translate="yes" xml:space="preserve">
          <source>In the implementation then observability of modules may depend on referential integrity or other checks that ensure different builds of tightly coupled modules or modules for specific operating systems or architectures are not combined in the same configuration.</source>
          <target state="translated">구현에서 모듈의 관찰 가능성은 참조 무결성 또는 밀접하게 결합 된 모듈의 다른 빌드 또는 특정 운영 체제 또는 아키텍처에 대한 모듈이 동일한 구성에서 결합되지 않도록하는 기타 검사에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c882c4c59e8bbed8641ffa48e67f786f75689b9" translate="yes" xml:space="preserve">
          <source>In the map, a key represents a language range whereas a value is a list of equivalents of it. &lt;code&gt;'*'&lt;/code&gt; cannot be used in the map. Each equivalent language range has the same weight value as its original language range.</source>
          <target state="translated">지도에서 키는 언어 범위를 나타내며 값은 이에 해당하는 목록입니다. 지도에서 &lt;code&gt;'*'&lt;/code&gt; 를 사용할 수 없습니다. 각 동등한 언어 범위는 원래 언어 범위와 동일한 가중치를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c8ff356c3bba211a0f9b734c9401b44d64508002" translate="yes" xml:space="preserve">
          <source>In the most typical usages, a fork-join pair act like a call (fork) and return (join) from a parallel recursive function. As is the case with other forms of recursive calls, returns (joins) should be performed innermost-first. For example, &lt;code&gt;a.fork();
 b.fork(); b.join(); a.join();&lt;/code&gt; is likely to be substantially more efficient than joining &lt;code&gt;a&lt;/code&gt; before &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">가장 일반적인 사용법에서 포크 조인 쌍은 병렬 재귀 함수에서 호출 (포크) 및 리턴 (조인)처럼 작동합니다. 다른 형태의 재귀 호출의 경우와 마찬가지로 반환 (결합)이 가장 먼저 수행되어야합니다. 예를 들어, &lt;code&gt;a.fork(); b.fork(); b.join(); a.join();&lt;/code&gt; 가입보다 실질적으로 더 효율적일 것입니다 &lt;code&gt;a&lt;/code&gt; 이전 &lt;code&gt;b&lt;/code&gt; 에 하는 .</target>
        </trans-unit>
        <trans-unit id="45803657c4f2b399c96bbb895ea5fcbc0d9cb2b3" translate="yes" xml:space="preserve">
          <source>In the picture, &lt;code&gt;&quot;Green&quot;&lt;/code&gt; is the current choice. Pushing the mouse button down on the object causes a menu to appear with the current choice highlighted.</source>
          <target state="translated">그림에서 &lt;code&gt;&quot;Green&quot;&lt;/code&gt; 이 현재 선택입니다. 개체에서 마우스 버튼을 아래로 누르면 현재 선택 항목이 강조 표시된 메뉴가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f8c3f78d62dea2ab9ca93523050a46d412fcf7d2" translate="yes" xml:space="preserve">
          <source>In the preceding line of code, the column name designates the column in the &lt;code&gt;RowSet&lt;/code&gt; object that is to be set with the given value. The column number can also be used to designate the column.</source>
          <target state="translated">앞의 코드 줄에서 열 이름 은 주어진 값으로 설정 될 &lt;code&gt;RowSet&lt;/code&gt; 개체 의 열을 지정합니다 . 열 번호를 사용하여 열을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="772b0f71c73902deebe22dad6acf14257c43a016" translate="yes" xml:space="preserve">
          <source>In the previous example,</source>
          <target state="translated">이전 예에서</target>
        </trans-unit>
        <trans-unit id="4b33ded736c76e6c5dfdda5c7c3b03fb8e08b842" translate="yes" xml:space="preserve">
          <source>In the reference implementation an &lt;code&gt;
 IntersectionType&lt;/code&gt; is used to model the explicit target type of a cast expression.</source>
          <target state="translated">참조 구현에서 &lt;code&gt; IntersectionType&lt;/code&gt; 은 캐스트 표현식의 명시 적 대상 유형을 모델링하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce91faf03879cc9864f989165091644d68a0db7f" translate="yes" xml:space="preserve">
          <source>In the reference implementation, BigInteger constructors and operations throw &lt;code&gt;ArithmeticException&lt;/code&gt; when the result is out of the supported range of -2&lt;sup&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/sup&gt; (exclusive) to +2&lt;sup&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/sup&gt; (exclusive).</source>
          <target state="translated">참조 구현에서 BigInteger 생성자 및 연산 은 결과가 지원되는 범위 인 -2 &lt;sup&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/sup&gt; (제외)에서 +2 &lt;sup&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/sup&gt; (제외) 까지의 범위를 벗어나면 &lt;code&gt;ArithmeticException&lt;/code&gt; 을 발생시킵니다 .&lt;sup&gt;&lt;/sup&gt;&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="06d1b85cb56fa3378ec39849f8809455d856b825" translate="yes" xml:space="preserve">
          <source>In the reference implementation, if the annotation processing tool is processing a single module</source>
          <target state="translated">참조 구현에서 주석 처리 도구가 단일 모듈을 처리하는 경우</target>
        </trans-unit>
        <trans-unit id="4124b8dc169b038e575762eafe60863f09ee476b" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a Julian Day field. In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt; and &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt; the Julian Day value is validated against the range of valid values. In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt; no validation occurs.</source>
          <target state="translated">구문 분석 단계에서는 율리우스 일 필드에서 날짜를 작성할 수 있습니다. 에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; 와 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; 율리우스 일 값이 유효 값의 범위에 대해 검증된다. 에 &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;관대 모드&lt;/a&gt; 유효성 확인이 발생하지 않는다.</target>
        </trans-unit>
        <trans-unit id="a2a922c0ee008a9be6c940866c2a10fbd2cdf2cd" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a Modified Julian Day field. In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt; and &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt; the Modified Julian Day value is validated against the range of valid values. In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt; no validation occurs.</source>
          <target state="translated">구문 분석 단계에서는 수정 된 율리우스 일 필드에서 날짜를 작성할 수 있습니다. 에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; 와 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; 수정 된 율리우스 일 값이 유효 값의 범위에 대해 검증된다. 에 &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;관대 모드&lt;/a&gt; 유효성 확인이 발생하지 않는다.</target>
        </trans-unit>
        <trans-unit id="f6f852fbde5cc2ca88d160cde722d602e256ed36" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a Rata Die field. In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt; and &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt; the Rata Die value is validated against the range of valid values. In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt; no validation occurs.</source>
          <target state="translated">구문 분석 단계에서는 Rata Die 필드에서 날짜를 만들 수 있습니다. 에서 &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;엄격 모드&lt;/a&gt; 와 &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;스마트 모드&lt;/a&gt; 라타 다이 값이 유효 값의 범위에 대해 검증된다. 에 &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;관대 모드&lt;/a&gt; 유효성 확인이 발생하지 않는다.</target>
        </trans-unit>
        <trans-unit id="5b20abaab49f8da86e12af6dbc29b49308c16819" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a week-based-year, week-of-week-based-year and day-of-week.</source>
          <target state="translated">구문 분석 단계에서는 주별, 주별 및 주중에서 날짜를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f88712c44d91044e35e47c8369d89d13d50c4551" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a week-based-year, week-of-week-based-year and day-of-week. See &lt;a href=&quot;#WEEK_OF_WEEK_BASED_YEAR&quot;&gt;&lt;code&gt;WEEK_OF_WEEK_BASED_YEAR&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">구문 분석의 해결 단계에서는 주 단위 연도, 주 단위 연도 및 요일로 날짜를 만들 수 있습니다. 자세한 내용은 &lt;a href=&quot;#WEEK_OF_WEEK_BASED_YEAR&quot;&gt; &lt;code&gt;WEEK_OF_WEEK_BASED_YEAR&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bdf7403d000aaea210215adeeb6a46be01f8d76f" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a week-based-year, week-of-week-based-year and day-of-week. See &lt;a href=&quot;isofields#WEEK_OF_WEEK_BASED_YEAR&quot;&gt;&lt;code&gt;WEEK_OF_WEEK_BASED_YEAR&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">구문 분석 단계에서는 주별, 주별 및 주중에서 날짜를 작성할 수 있습니다. &lt;a href=&quot;isofields#WEEK_OF_WEEK_BASED_YEAR&quot;&gt; &lt;code&gt;WEEK_OF_WEEK_BASED_YEAR&lt;/code&gt; &lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="84410ab58516150fbc8db498e561458f97766283" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a week-based-year, week-of-year and day-of-week.</source>
          <target state="translated">구문 분석의 해결 단계에서 주별, 주별 및 요일로 날짜를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b39a2e6ee173bfc886b3404b2577117e26d1cf6d" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a year, quarter-of-year and day-of-quarter.</source>
          <target state="translated">구문 분석 단계에서는 날짜, 연도 및 분기를 기준으로 날짜를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b70403fa838291aec2345c0de44ebd60b6595b8" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a year, quarter-of-year and day-of-quarter. See &lt;a href=&quot;#DAY_OF_QUARTER&quot;&gt;&lt;code&gt;DAY_OF_QUARTER&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">구문 분석의 해결 단계에서는 1 년, 4 분기 및 4 분기의 날짜로 날짜를 만들 수 있습니다. 자세한 내용은 &lt;a href=&quot;#DAY_OF_QUARTER&quot;&gt; &lt;code&gt;DAY_OF_QUARTER&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9211a4f83ceedceb836e18a497bc19b7625f3563" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a year, quarter-of-year and day-of-quarter. See &lt;a href=&quot;isofields#DAY_OF_QUARTER&quot;&gt;&lt;code&gt;DAY_OF_QUARTER&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">구문 분석 단계에서는 날짜, 연도 및 분기를 기준으로 날짜를 만들 수 있습니다. &lt;a href=&quot;isofields#DAY_OF_QUARTER&quot;&gt; &lt;code&gt;DAY_OF_QUARTER&lt;/code&gt; &lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e5f25d0d54f0550fbf9d2e181359a8968474730" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a year, week-of-month, month-of-year and day-of-week.</source>
          <target state="translated">구문 분석의 해결 단계에서 연도, 월, 월 및 요일로 날짜를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75940fac89a1739add9ac1cc303e4379ce1aa35b" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a date can be created from a year, week-of-year and day-of-week.</source>
          <target state="translated">구문 분석의 해결 단계에서 연도, 주 및 요일로 날짜를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d796a10d2d6aedb2663bb96172f9692e2b93290a" translate="yes" xml:space="preserve">
          <source>In the resolving phase of parsing, a localized day-of-week will be converted to a standardized &lt;code&gt;ChronoField&lt;/code&gt; day-of-week. The day-of-week must be in the valid range 1 to 7. Other fields in this class build dates using the standardized day-of-week.</source>
          <target state="translated">구문 분석의 해결 단계에서 현지화 된 요일이 표준화 된 것으로 변환됩니다. &lt;code&gt;ChronoField&lt;/code&gt; 요일로 . 요일의 유효 범위는 1-7이어야합니다.이 클래스의 다른 필드는 표준화 된 요일을 사용하여 날짜를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="390685e2818a0e35011dcc474219688cf97611cb" translate="yes" xml:space="preserve">
          <source>In the retransform and redefine cases, the transformer must support the redefinition semantics: if a class that the transformer changed during initial definition is later retransformed or redefined, the transformer must insure that the second class output class file is a legal redefinition of the first output class file.</source>
          <target state="translated">재 변환 및 재정의의 경우, 변환기는 재정의 시맨틱을 지원해야합니다. 초기 정의 중에 변압기가 변경된 클래스가 나중에 재 변환 또는 재정의되는 경우, 변환기는 두 번째 클래스 출력 클래스 파일이 첫 번째 출력의 법적 재정의인지 확인해야합니다. 클래스 파일.</target>
        </trans-unit>
        <trans-unit id="99e95997b1b0be07d0f19e0a7444a7772f6d9830" translate="yes" xml:space="preserve">
          <source>In the same order as they are enqueued.</source>
          <target state="translated">대기열에 포함 된 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5e4545213a608c25290bf3b4b840211fb6076c19" translate="yes" xml:space="preserve">
          <source>In the second example, the function returns a different subscriber depending on the status code.</source>
          <target state="translated">두 번째 예에서 함수는 상태 코드에 따라 다른 구독자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db383673567be7d2ec797e169698a7aca3ed907b" translate="yes" xml:space="preserve">
          <source>In the second phase, if the LoginContext's overall authentication succeeded (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules succeeded), then the &lt;code&gt;commit&lt;/code&gt; method for the &lt;code&gt;LoginModule&lt;/code&gt; gets invoked. The &lt;code&gt;commit&lt;/code&gt; method for a &lt;code&gt;LoginModule&lt;/code&gt; checks its privately saved state to see if its own authentication succeeded. If the overall &lt;code&gt;LoginContext&lt;/code&gt; authentication succeeded and the LoginModule's own authentication succeeded, then the &lt;code&gt;commit&lt;/code&gt; method associates the relevant Principals (authenticated identities) and Credentials (authentication data such as cryptographic keys) with the &lt;code&gt;Subject&lt;/code&gt; located within the &lt;code&gt;LoginModule&lt;/code&gt;.</source>
          <target state="translated">LoginContext의 인증 전체가 성공했을 경우 두 번째 단계에서, 다음은 (해당 REQUIRED는 REQUISITE는 충분한 OPTIONAL LoginModule이 성공) &lt;code&gt;commit&lt;/code&gt; 위한 방법 &lt;code&gt;LoginModule&lt;/code&gt; 호출 얻는다. &lt;code&gt;LoginModule&lt;/code&gt; 의 &lt;code&gt;commit&lt;/code&gt; 메소드 는 비공개로 저장된 상태를 점검하여 자체 인증에 성공했는지 확인합니다. 전체 &lt;code&gt;LoginContext&lt;/code&gt; 인증에 성공하고 LoginModule 자체 인증에 성공한 경우, &lt;code&gt;commit&lt;/code&gt; 메소드는 관련 프린시 펄 (인증 된 ID) 및 신임 정보 (암호화 키와 같은 인증 데이터)를 &lt;code&gt;LoginModule&lt;/code&gt; 내에있는 &lt;code&gt;Subject&lt;/code&gt; 와 연관시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ff4de39ad98bfbe48859fb2eccbe9cf7995269de" translate="yes" xml:space="preserve">
          <source>In the simplest and most typical usage, the value of the &lt;code&gt;type&lt;/code&gt; parameter will simply be the class or interface directly enclosing &lt;code&gt;overrider&lt;/code&gt; (the possibly-overriding method). For example, suppose &lt;code&gt;m1&lt;/code&gt; represents the method &lt;code&gt;String.hashCode&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; represents &lt;code&gt;
 Object.hashCode&lt;/code&gt;. We can then ask whether &lt;code&gt;m1&lt;/code&gt; overrides &lt;code&gt;m2&lt;/code&gt; within the class &lt;code&gt;String&lt;/code&gt; (it does):</source>
          <target state="translated">가장 간단하고 가장 일반적인 사용에서 &lt;code&gt;type&lt;/code&gt; 매개 변수 의 값 은 단순히 &lt;code&gt;overrider&lt;/code&gt; 의자를 직접 포함하는 클래스 또는 인터페이스 (무시할 수있는 메서드)입니다. 예를 들어, 가정하자 &lt;code&gt;m1&lt;/code&gt; 메소드 나타낸다 &lt;code&gt;String.hashCode&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 는 대표 &lt;code&gt; Object.hashCode&lt;/code&gt; . 그런 다음 &lt;code&gt;m1&lt;/code&gt; 이 &lt;code&gt;String&lt;/code&gt; 클래스 내에서 &lt;code&gt;m2&lt;/code&gt; 를 재정의 하는지 여부를 물어볼 수 있습니다 ( 그렇습니다 ).</target>
        </trans-unit>
        <trans-unit id="57d427b7244122df77daa4831775224b6dd479a3" translate="yes" xml:space="preserve">
          <source>In the simplest and most typical usage, the value of the &lt;code&gt;type&lt;/code&gt; parameter will simply be the class or interface directly enclosing &lt;code&gt;overrider&lt;/code&gt; (the possibly-overriding method). For example, suppose &lt;code&gt;m1&lt;/code&gt; represents the method &lt;code&gt;String.hashCode&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; represents &lt;code&gt;Object.hashCode&lt;/code&gt;. We can then ask whether &lt;code&gt;m1&lt;/code&gt; overrides &lt;code&gt;m2&lt;/code&gt; within the class &lt;code&gt;String&lt;/code&gt; (it does):</source>
          <target state="translated">가장 단순하고 가장 일반적인 사용법에서 &lt;code&gt;type&lt;/code&gt; 매개 변수 의 값 은 단순히 &lt;code&gt;overrider&lt;/code&gt; 직접 둘러싸는 클래스 또는 인터페이스입니다 ( 재정 의 가능한 메서드). 예를 들어, 가정하자 &lt;code&gt;m1&lt;/code&gt; 메소드 나타낸다 &lt;code&gt;String.hashCode&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 는 대표 &lt;code&gt;Object.hashCode&lt;/code&gt; . 그런 다음 &lt;code&gt;m1&lt;/code&gt; 이 클래스 &lt;code&gt;String&lt;/code&gt; 내에서 &lt;code&gt;m2&lt;/code&gt; 를 재정의 하는지 여부를 묻습니다 .</target>
        </trans-unit>
        <trans-unit id="d7df6bb5179547c80d776dc0aafd98bdd8b5e175" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only one descriptor and the returned &lt;code&gt;ImmutableDescriptor&lt;/code&gt; is a copy of its fields at the time this method is called:</source>
          <target state="translated">가장 간단한 경우에는 설명자가 하나만 &lt;code&gt;ImmutableDescriptor&lt;/code&gt; 메서드가 호출 될 때 반환 된 ImmutableDescriptor 는 해당 필드의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="93fc6f6665bc8e14ad256aa3e40fbe2fc160ba10" translate="yes" xml:space="preserve">
          <source>In the standard usage of the JMX API, MBeans are implemented as Java objects. However, as explained below, these objects are not usually referenced directly.</source>
          <target state="translated">JMX API의 표준 사용법에서 MBean은 Java 객체로 구현됩니다. 그러나 아래 설명 된대로 이러한 개체는 일반적으로 직접 참조되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0650024393de036d57e5eb1c4c3b2983aded5a1a" translate="yes" xml:space="preserve">
          <source>In the unnormalized form, each component is an unsigned integral value between 0 and 2&lt;sup&gt;n&lt;/sup&gt; - 1, where n is the number of significant bits for a particular component. If pixel values for a particular &lt;code&gt;ColorModel&lt;/code&gt; represent color samples premultiplied by the alpha sample, unnormalized color component values are also premultiplied. The unnormalized form is used only with instances of &lt;code&gt;ColorModel&lt;/code&gt; whose &lt;code&gt;ColorSpace&lt;/code&gt; has minimum component values of 0.0 for all components and maximum values of 1.0 for all components. The unnormalized form for color and alpha components can be a convenient representation for &lt;code&gt;ColorModels&lt;/code&gt; whose normalized component values all lie between 0.0 and 1.0. In such cases the integral value 0 maps to 0.0 and the value 2&lt;sup&gt;n&lt;/sup&gt; - 1 maps to 1.0. In other cases, such as when the normalized component values can be either negative or positive, the unnormalized form is not convenient. Such &lt;code&gt;ColorModel&lt;/code&gt; objects throw an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; when methods involving an unnormalized argument are called. Subclasses of &lt;code&gt;ColorModel&lt;/code&gt; must specify the conditions under which this occurs.</source>
          <target state="translated">비정규 화 형식에서 각 구성 요소는 0과 2 &lt;sup&gt;n&lt;/sup&gt; -1 사이의 부호없는 정수 값입니다 . 여기서 n은 특정 구성 요소에 대한 유효 비트 수입니다. 특정 &lt;code&gt;ColorModel&lt;/code&gt; 에 대한 픽셀 값 이 알파 샘플로 미리 곱해진 색상 샘플을 나타내는 경우 정규화되지 않은 색상 구성 요소 값도 미리 곱해집니다. 정규화 되지 않은 형식은 정규화 된 구성 요소 값이 모두 0.0에서 1.0 사이 에 있는 인스턴스에만 사용됩니다 . 이러한 경우 정수 값 0은 0.0에 매핑되고 값 &lt;sup&gt;2n&lt;/sup&gt; -1은 1.0에 매핑됩니다. 정규화 된 구성 요소 값이 음수 또는 양수일 수있는 경우와 같은 다른 경우에는 정규화되지 않은 형식이 편리하지 않습니다. 이러한 &lt;code&gt;ColorModel&lt;/code&gt; 객체는 &lt;code&gt;ColorModel&lt;/code&gt; &lt;code&gt;ColorSpace&lt;/code&gt; 의 모든 성분의 최대 값 1.0 0.0의 최소 성분 값을 갖는다. 색상 및 알파 구성 요소의 정규화되지 않은 형식은 &lt;code&gt;ColorModels&lt;/code&gt; 에 대한 편리한 표현이 될 수 있습니다.&lt;sup&gt;&lt;/sup&gt;&lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 는 정규화되지 않은 인수를 포함하는 메서드가 호출 될 때 발생시킵니다. &lt;code&gt;ColorModel&lt;/code&gt; 의 서브 클래스는 이것이 발생하는 조건을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fb02047e34ddf08451892b3ff429e03dda69b67" translate="yes" xml:space="preserve">
          <source>In theory, it is possible for there to be more than two valid offsets. This would happen if clocks to be put back more than once in quick succession. This has never happened in the history of time-zones and thus has no special handling. However, if it were to happen, then the list would return more than 2 entries.</source>
          <target state="translated">이론적으로 유효한 오프셋이 두 개 이상있을 수 있습니다. 시계를 연속해서 빠르게 두 번 이상 다시 넣으면 이런 일이 발생합니다. 이것은 시간대의 역사에서 결코 일어나지 않았으므로 특별한 처리가 없습니다. 그러나 이런 상황이 발생하면 목록은 두 개 이상의 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f0557f2e43744a697a7ec3609cc994bb84fbaf06" translate="yes" xml:space="preserve">
          <source>In these examples, the host name &lt;code&gt;ignoredhost&lt;/code&gt; is not used by the connector server or its clients. It can be omitted, for example:</source>
          <target state="translated">이 예제에서 호스트 이름 &lt;code&gt;ignoredhost&lt;/code&gt; 는 커넥터 서버 또는 해당 클라이언트에서 사용되지 않습니다. 예를 들어 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a96cc0da1bc8d97002fb7d683d8490c870b59b2b" translate="yes" xml:space="preserve">
          <source>In this &lt;code&gt;JMXServiceURL&lt;/code&gt;, the first &lt;code&gt;rmi:&lt;/code&gt; specifies the RMI connector, while the second &lt;code&gt;rmi:&lt;/code&gt; specifies the RMI registry into which the RMI connector server has stored its stub.</source>
          <target state="translated">이 &lt;code&gt;JMXServiceURL&lt;/code&gt; 에서 첫 번째 &lt;code&gt;rmi:&lt;/code&gt; 는 RMI 커넥터를 지정하고 두 번째 &lt;code&gt;rmi:&lt;/code&gt; 는 RMI 커넥터 서버가 스텁을 저장 한 RMI 레지스트리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7200a056d70dbcee507cbef0f2945debea8015ef" translate="yes" xml:space="preserve">
          <source>In this &lt;code&gt;JMXServiceURL&lt;/code&gt;, the first &lt;code&gt;rmi:&lt;/code&gt; specifies the RMI connector, while the second &lt;code&gt;rmi:&lt;/code&gt; specifies the RMI registry.</source>
          <target state="translated">이 &lt;code&gt;JMXServiceURL&lt;/code&gt; 에서 첫 번째 &lt;code&gt;rmi:&lt;/code&gt; 는 RMI 커넥터를 지정하고 두 번째 &lt;code&gt;rmi:&lt;/code&gt; 는 RMI 레지스트리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="dfe617178689a36792645af523da4c25dc32fea7" translate="yes" xml:space="preserve">
          <source>In this approach, the &lt;code&gt;getObject&lt;/code&gt; method creates a cipher object for the appropriate decryption algorithm and initializes it with the given decryption key and the algorithm parameters (if any) that were stored in the sealed object.</source>
          <target state="translated">이 접근법에서, &lt;code&gt;getObject&lt;/code&gt; 메소드는 적절한 복호화 알고리즘에 대한 암호 오브젝트를 작성하고 지정된 복호화 키와 봉인 된 오브젝트에 저장된 알고리즘 매개 변수 (있는 경우)를 사용하여 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="22b6afa9d4a78bd74a00edb5ff917990a506228d" translate="yes" xml:space="preserve">
          <source>In this case, I could then register properties for this component with UIDefaults in the following manner:</source>
          <target state="translated">이 경우 다음과 같은 방식으로 UIDefaults를 사용하여이 구성 요소의 속성을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6348e3c77ca44896104904d8e87da80a3b45af65" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;serviceURL&lt;/code&gt; has one of these two forms:</source>
          <target state="translated">이 경우 &lt;code&gt;serviceURL&lt;/code&gt; 에는 다음 두 가지 형식 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e3338181665fd261d123eabba249b5dd31149f" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;serviceURL&lt;/code&gt; has the following form:</source>
          <target state="translated">이 경우 &lt;code&gt;serviceURL&lt;/code&gt; 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63799a8eba10e14aeec10316307fbff6ccabb3aa" translate="yes" xml:space="preserve">
          <source>In this case, the service provider itself need not be assignable to the service's interface or class.</source>
          <target state="translated">이 경우 서비스 공급자 자체를 서비스의 인터페이스 또는 클래스에 할당 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="63f42d08b127520793be019e80489c215cf4a70f" translate="yes" xml:space="preserve">
          <source>In this case, the service provider must be assignable to the service's interface or class</source>
          <target state="translated">이 경우 서비스 공급자는 서비스의 인터페이스 또는 클래스에 할당 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="720c350da9963fee529988e5b52df9757023ef03" translate="yes" xml:space="preserve">
          <source>In this class, the format of &quot;&amp;lt;name type&amp;gt;&quot; is &quot;[LITERAL] (INTEGER)&quot;, where the optional &quot;LITERAL&quot; is the literal name, and INTEGER is the integer value of the name type. The format of &quot;&amp;lt;name value&amp;gt;&quot; is &quot;XX:...:XX&quot;, where &quot;XX&quot; is the hexadecimal digit representation of a byte value. For example, a returned value of an pseudo server name may look like:</source>
          <target state="translated">이 클래스에서 &quot;&amp;lt;name type&amp;gt;&quot;의 형식은 &quot;[LITERAL] (INTEGER)&quot;입니다. 여기서 선택적 &quot;LITERAL&quot;은 리터럴 이름이고 INTEGER는 이름 유형의 정수 값입니다. &quot;&amp;lt;name value&amp;gt;&quot;의 형식은 &quot;XX : ... : XX&quot;입니다. 여기서 &quot;XX&quot;는 바이트 값의 16 진수 숫자 표현입니다. 예를 들어, 의사 서버 이름의 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cdeb7f788b6607f967210833bc2420e849ecc59" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;widgets&lt;/code&gt; is a &lt;code&gt;Collection&amp;lt;Widget&amp;gt;&lt;/code&gt;. We create a stream of &lt;code&gt;Widget&lt;/code&gt; objects via &lt;a href=&quot;../collection#stream()&quot;&gt;&lt;code&gt;Collection.stream()&lt;/code&gt;&lt;/a&gt;, filter it to produce a stream containing only the red widgets, and then transform it into a stream of &lt;code&gt;int&lt;/code&gt; values representing the weight of each red widget. Then this stream is summed to produce a total weight.</source>
          <target state="translated">이 예제에서 &lt;code&gt;widgets&lt;/code&gt; 은 &lt;code&gt;Collection&amp;lt;Widget&amp;gt;&lt;/code&gt; 입니다. &lt;a href=&quot;../collection#stream()&quot;&gt; &lt;code&gt;Collection.stream()&lt;/code&gt; &lt;/a&gt; 통해 &lt;code&gt;Widget&lt;/code&gt; 객체 스트림을 생성하고 ,이를 필터링하여 빨간색 위젯 만 포함하는 스트림을 생성 한 다음 &lt;code&gt;int&lt;/code&gt; 스트림으로 변환합니다. 각 빨간색 위젯의 가중치를 나타내는 값 . 그런 다음이 스트림을 합하여 총 가중치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e193ba75e02e845c525d4e0f2f9ef5c3a18416dc" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;widgets&lt;/code&gt; is a &lt;code&gt;Collection&amp;lt;Widget&amp;gt;&lt;/code&gt;. We create a stream of &lt;code&gt;Widget&lt;/code&gt; objects via &lt;a href=&quot;../collection#stream--&quot;&gt;&lt;code&gt;Collection.stream()&lt;/code&gt;&lt;/a&gt;, filter it to produce a stream containing only the red widgets, and then transform it into a stream of &lt;code&gt;int&lt;/code&gt; values representing the weight of each red widget. Then this stream is summed to produce a total weight.</source>
          <target state="translated">이 예제에서 &lt;code&gt;widgets&lt;/code&gt; 은 &lt;code&gt;Collection&amp;lt;Widget&amp;gt;&lt;/code&gt; 입니다. 우리의 스트림 생성 &lt;code&gt;Widget&lt;/code&gt; 을 통해 개체 &lt;a href=&quot;../collection#stream--&quot;&gt; &lt;code&gt;Collection.stream()&lt;/code&gt; &lt;/a&gt; 필터는 단지 적색 위젯을 포함하는 스트림을 생성하고, 다음의 스트림으로 변환하는 &lt;code&gt;int&lt;/code&gt; 각각 빨강 위젯의 중량을 나타내는 값. 그런 다음이 흐름을 합하여 총 무게를 산출합니다.</target>
        </trans-unit>
        <trans-unit id="39bf3f1e82dd624353302de76e51fb88b074c58a" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;WebRowSet&lt;/code&gt; object is created and populated with a simple 2 column, 5 row table from a data source. Having the 5 rows in a &lt;code&gt;WebRowSet&lt;/code&gt; object makes it possible to describe them in XML. The metadata describing the various standard JavaBeans properties as defined in the RowSet interface plus the standard properties defined in the &lt;code&gt;CachedRowSet&lt;/code&gt;&amp;trade; interface provide key details that describe WebRowSet properties. Outputting the WebRowSet object to XML using the standard &lt;code&gt;writeXml&lt;/code&gt; methods describes the internal properties as follows:</source>
          <target state="translated">이 예제에서는 &lt;code&gt;WebRowSet&lt;/code&gt; 개체가 생성되고 데이터 소스의 간단한 2 개 열, 5 개 행 테이블로 채워집니다. &lt;code&gt;WebRowSet&lt;/code&gt; 객체 에 5 개의 행이 있으면이 를 XML로 설명 할 수 있습니다. RowSet 인터페이스에 정의 된 다양한 표준 JavaBeans 속성과 &lt;code&gt;CachedRowSet&lt;/code&gt; &amp;trade; 인터페이스에 정의 된 표준 속성을 설명하는 메타 데이터 는 WebRowSet 속성을 설명하는 주요 세부 정보를 제공합니다. 표준 &lt;code&gt;writeXml&lt;/code&gt; 을 사용하여 WebRowSet 객체를 XML로 출력 메서드를 내부 속성이 다음과 같이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="1a75831521f54124961b4fc66a51028571265186" translate="yes" xml:space="preserve">
          <source>In this example, as well as others in which tasks have no other effects except to &lt;code&gt;compareAndSet&lt;/code&gt; a common result, the trailing unconditional invocation of &lt;code&gt;tryComplete&lt;/code&gt; could be made conditional (&lt;code&gt;if (result.get() == null) tryComplete();&lt;/code&gt;) because no further bookkeeping is required to manage completions once the root task completes.</source>
          <target state="translated">이 예에서는 작업이 &lt;code&gt;compareAndSet&lt;/code&gt; 공통 결과를 제외하고는 다른 효과가없는 다른 경우 와 &lt;code&gt;tryComplete&lt;/code&gt; 의 후행 무조건 호출을 조건부 로 만들 수 있습니다 ( &lt;code&gt;if (result.get() == null) tryComplete();&lt;/code&gt; ) 루트 작업이 완료되면 완료를 관리하기 위해 더 이상 부기가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42c7030ce66b22acc98ef41e2d30078538ce049c" translate="yes" xml:space="preserve">
          <source>In this example, as well as others in which tasks have no other effects except to compareAndSet a common result, the trailing unconditional invocation of &lt;code&gt;tryComplete&lt;/code&gt; could be made conditional (&lt;code&gt;if (result.get() == null) tryComplete();&lt;/code&gt;) because no further bookkeeping is required to manage completions once the root task completes.</source>
          <target state="translated">이 예제와 &lt;code&gt;tryComplete&lt;/code&gt; 때 공통적 인 결과를 비교하는 것 외에는 다른 효과가없는 다른 작업뿐만 아니라 tryComplete 의 후행 무조건 호출을 조건부 로 만들 수 있습니다 ( &lt;code&gt;if (result.get() == null) tryComplete();&lt;/code&gt; ) 루트 작업이 완료되면 완료를 관리하기 위해 더 이상 부기가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cbdee6a070a799225581b53a39e8fe83cce6d75" translate="yes" xml:space="preserve">
          <source>In this example, serializing &lt;code&gt;aButton&lt;/code&gt; by itself will cause &lt;code&gt;MyApp&lt;/code&gt; and everything it refers to to be serialized as well. The problem is that the listener is serializable by coincidence, not by design. To separate the decisions about &lt;code&gt;MyApp&lt;/code&gt; and the &lt;code&gt;ActionListener&lt;/code&gt; being serializable one can use a nested class, as in the following example:</source>
          <target state="translated">이 예제에서 &lt;code&gt;aButton&lt;/code&gt; 자체를 직렬화 하면 &lt;code&gt;MyApp&lt;/code&gt; 및 참조하는 모든 항목도 직렬화됩니다. 문제는 청취자가 디자인이 아니라 우연히 직렬화 될 수 있다는 것입니다. &lt;code&gt;MyApp&lt;/code&gt; 및 &lt;code&gt;ActionListener&lt;/code&gt; 에 대한 결정을 분리하려면 가 직렬화 다음 예제와 같이 중첩 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee5b5ec1422e55461ae970d2b50a5715dd52b4c" translate="yes" xml:space="preserve">
          <source>In this example, suppose you were in the Enabled+Selected state and searched for &quot;foreground&quot;. In this case, we first check for Button.Enabled+Selected.foreground, but no such color exists. We then fall back to the next valid state, in this case, Button.Enabled.foreground, and have a match. So we return it.</source>
          <target state="translated">이 예에서는 Enabled + Selected 상태에 있고 &quot;foreground&quot;를 검색했다고 가정합니다. 이 경우 먼저 Button.Enabled + Selected.foreground를 확인하지만 이러한 색상은 존재하지 않습니다. 그런 다음 다음 유효한 상태 (이 경우 Button.Enabled.foreground)로 돌아가서 일치 항목이 있습니다. 그래서 우리는 그것을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="409136081c66f45095c7d409508b34b5db16e59f" translate="yes" xml:space="preserve">
          <source>In this example, the loop handle parameters &lt;code&gt;(A...)&lt;/code&gt; were derived from the step functions, which is natural if most of the loop computation happens in the steps. For some loops, the burden of computation might be heaviest in the pred functions, and so the pred functions might need to accept the loop parameter values. For loops with complex exit logic, the fini functions might need to accept loop parameters, and likewise for loops with complex entry logic, where the init functions will need the extra parameters. For such reasons, the rules for determining these parameters are as symmetric as possible, across all clause parts. In general, the loop parameters function as common invariant values across the whole loop, while the iteration variables function as common variant values, or (if there is no step function) as internal loop invariant temporaries.</source>
          <target state="translated">이 예에서 루프 핸들 매개 변수 &lt;code&gt;(A...)&lt;/code&gt; 대부분의 루프 계산이 단계에서 발생하는 경우 자연스러운 단계 함수에서 파생되었습니다. 일부 루프의 경우 pred 함수에서 계산 부담이 가장 클 수 있으므로 pred 함수는 루프 매개 변수 값을 허용해야 할 수 있습니다. 복잡한 종료 로직이있는 루프의 경우 fini 함수는 루프 매개 변수를 허용해야 할 수 있으며, 마찬가지로 init 함수에 추가 매개 변수가 필요한 복잡한 입력 로직이있는 for 루프가 필요할 수 있습니다. 이러한 이유로 이러한 매개 변수를 결정하는 규칙은 모든 조항 부분에서 가능한 한 대칭 적입니다. 일반적으로 루프 매개 변수는 전체 루프에서 공통 불변 값으로 작동하는 반면 반복 변수는 공통 변형 값으로 작동하거나 (단계 함수가없는 경우) 내부 루프 불변 임시로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aed2963fd6dbb4a4e6fa201a311664290c5e4832" translate="yes" xml:space="preserve">
          <source>In this example, the values for &lt;code&gt;CREDIT_LIMIT&lt;/code&gt; and &lt;code&gt;REGION&lt;/code&gt; are placeholder parameters, which are indicated with a question mark (?). The first question mark is placeholder parameter number &lt;code&gt;1&lt;/code&gt;, the second question mark is placeholder parameter number &lt;code&gt;2&lt;/code&gt;, and so on. Any placeholder parameters must be set with values before the query can be executed. To set these placeholder parameters, the &lt;code&gt;BaseRowSet&lt;/code&gt; class provides a set of setter methods, similar to those provided by the &lt;code&gt;PreparedStatement&lt;/code&gt; interface, for setting values of each data type. A &lt;code&gt;RowSet&lt;/code&gt; object stores the parameter values internally, and its &lt;code&gt;execute&lt;/code&gt; method uses them internally to set values for the placeholder parameters before it sends the command to the DBMS to be executed.</source>
          <target state="translated">이 예에서 &lt;code&gt;CREDIT_LIMIT&lt;/code&gt; 및 &lt;code&gt;REGION&lt;/code&gt; 의 값은 물음표 (?)로 표시되는 자리 표시 자 매개 변수입니다. 첫 번째 물음표는 자리 표시 자 매개 변수 번호 &lt;code&gt;1&lt;/code&gt; 이고 두 번째 물음표는 자리 표시 자 매개 변수 번호 &lt;code&gt;2&lt;/code&gt; 입니다. 모든 자리 표시 자 매개 변수는 쿼리를 실행하기 전에 값으로 설정해야합니다. 이러한 자리 표시 자 매개 변수를 설정하기 위해 &lt;code&gt;BaseRowSet&lt;/code&gt; 클래스는 각 데이터 유형의 값을 설정하기 위해 &lt;code&gt;PreparedStatement&lt;/code&gt; 인터페이스에서 제공하는 것과 유사한 setter 메소드 세트를 제공 합니다. &lt;code&gt;RowSet&lt;/code&gt; 오브젝트 기억 파라미터 내부적 값 및 그 &lt;code&gt;execute&lt;/code&gt; 메서드는 실행할 DBMS에 명령을 보내기 전에 자리 표시 자 매개 변수에 대한 값을 설정하기 위해 내부적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93dc5b821ae68dc6ebfeda9a85cb67c0bd4d6187" translate="yes" xml:space="preserve">
          <source>In this implementation of the &lt;code&gt;MutableNode&lt;/code&gt; interface, this operation is very inefficient. In order to determine the next node, this method first performs a linear search in the parent's child-list in order to find the current node.</source>
          <target state="translated">이 &lt;code&gt;MutableNode&lt;/code&gt; 인터페이스 구현 에서이 작업은 매우 비효율적입니다. 다음 노드를 결정하기 위해이 메소드는 현재 노드를 찾기 위해 먼저 부모의 자식 목록에서 선형 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="39a62c2317ac735babb1eb562a47c5533b21792e" translate="yes" xml:space="preserve">
          <source>In this implementation of the &lt;code&gt;MutableNode&lt;/code&gt; interface, this operation is very inefficient. In order to determine the previous node, this method first performs a linear search in the parent's child-list in order to find the current node.</source>
          <target state="translated">이 &lt;code&gt;MutableNode&lt;/code&gt; 인터페이스 구현 에서이 작업은 매우 비효율적입니다. 이전 노드를 결정하기 위해이 방법은 현재 노드를 찾기 위해 먼저 부모의 자식 목록에서 선형 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2ed4d9d662cc61c638b4d92ccc9834b600d7f5a3" translate="yes" xml:space="preserve">
          <source>In this implementation only &quot;ObjectReference&quot; is supported.</source>
          <target state="translated">이 구현에서는 &quot;ObjectReference&quot;만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8ac51afe4aa630110440e2c63eec26125f1f704d" translate="yes" xml:space="preserve">
          <source>In this implementation, all field values will be created as Strings. If the field values are not Strings, the programmer will have to reset or convert these fields correctly.</source>
          <target state="translated">이 구현에서는 모든 필드 값이 문자열로 작성됩니다. 필드 값이 문자열이 아닌 경우 프로그래머는 이러한 필드를 올바르게 재설정하거나 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="21158219378c10a796461357849e0275a40caa35" translate="yes" xml:space="preserve">
          <source>In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock, and over reporting the elapse of the waiting time.</source>
          <target state="translated">이 구현에서,이 방법은 명백한 중단 점이므로, 잠금의 정상 또는 재진입 획득에 대한 인터럽트에 응답하고 대기 시간의 경과를보고하는 것이 선호된다.</target>
        </trans-unit>
        <trans-unit id="c5302763fc0d8960fc55215843ee5ec52f822951" translate="yes" xml:space="preserve">
          <source>In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock.</source>
          <target state="translated">이 구현에서,이 방법은 명백한 중단 점이므로, 잠금의 정상 또는 재진입 획득보다 인터럽트에 응답하는 것이 바람직하다.</target>
        </trans-unit>
        <trans-unit id="612b61e7520baf5be9280167c708d75c2a29f2da" translate="yes" xml:space="preserve">
          <source>In this implementation, in every case where the getMethod needs to be called, because the method is invoked through the standard &quot;invoke&quot; method and thus needs operationInfo, an operation must be specified for that getMethod so that the invocation works correctly.</source>
          <target state="translated">이 구현에서, getMethod를 호출해야하는 모든 경우에, 메소드는 표준 &quot;invoke&quot;메소드를 통해 호출되므로 operationInfo가 필요하므로 호출이 올바르게 작동하도록 getMethod에 대해 조작을 지정해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
