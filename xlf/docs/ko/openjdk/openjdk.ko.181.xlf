<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="431790292384e64efc177cdca9b3ed328240fae3" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same Permission object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">Java 애플리케이션을 실행하는 동안 동일한 Permission 오브젝트에서 두 번 이상 호출 될 때마다 &lt;code&gt;hashCode&lt;/code&gt; 메소드는 동일한 정수를 일관되게 리턴해야합니다. 이 정수는 응용 프로그램의 한 실행에서 동일한 응용 프로그램의 다른 실행까지 일관성을 유지하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="588f7fe1bed2c7e664ebaf61ee198d0177166e9e" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">Java 어플리케이션의 실행 중에 같은 객체에서 호출 될 때마다 &lt;code&gt;hashCode&lt;/code&gt; 방법은 지속적으로 같은 정수를 반환해야합니다에 사용 된 정보가 제공되지 &lt;code&gt;equals&lt;/code&gt; 객체가 수정에 비교. 이 정수는 응용 프로그램의 한 실행에서 동일한 응용 프로그램의 다른 실행까지 일관성을 유지하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc62db80b67ec0b4098632184a3dc10efde0cdb" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">성공할 때마다 이전에 인스턴스화 된 리소스 번들의 &lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt; 메서드를 새 리소스 번들과 함께 호출합니다 . 이것은 이름 목록이 소진되거나 현재 번들에 이미 널이 아닌 상위가있을 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="e5ded5fcd7a735ce98c847740a18c44d83d66cc2" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">성공할 때마다 이전에 인스턴스화 된 자원 번들의 &lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt; 메소드를 새 자원 번들과 함께 호출합니다 . 이름 목록이 소진되거나 현재 번들에 널이 아닌 상위가 이미있을 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="57eb7967ad7144cde59c41a7d4448d0900ba0c25" translate="yes" xml:space="preserve">
          <source>Where 'name' is the &lt;code&gt;ExecutionControlProvider&lt;/code&gt;&lt;a href=&quot;executioncontrolprovider#name()&quot;&gt;name&lt;/a&gt;. Where 'param' is a Map key from &lt;a href=&quot;executioncontrolprovider#defaultParameters()&quot;&gt;&lt;code&gt;ExecutionControlProvider.defaultParameters()&lt;/code&gt;&lt;/a&gt; and the parenthesized value; See, for example, &lt;a href=&quot;../execution/jdiexecutioncontrolprovider&quot;&gt;&lt;code&gt;JdiExecutionControlProvider&lt;/code&gt;&lt;/a&gt;. Where 'identifier' is a sequence of &lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt;Java identifier part characters&lt;/a&gt; from the Basic Multilingual Plane.</source>
          <target state="translated">여기서 'name'은 &lt;code&gt;ExecutionControlProvider&lt;/code&gt; &lt;a href=&quot;executioncontrolprovider#name()&quot;&gt;이름&lt;/a&gt; 입니다. 여기서 'param'은 &lt;a href=&quot;executioncontrolprovider#defaultParameters()&quot;&gt; &lt;code&gt;ExecutionControlProvider.defaultParameters()&lt;/code&gt; &lt;/a&gt; 의 맵 키 와 괄호 안의 값입니다. 예를 들어, &lt;a href=&quot;../execution/jdiexecutioncontrolprovider&quot;&gt; &lt;code&gt;JdiExecutionControlProvider&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 여기서 '식별자'는 기본 다국어 평면 의 &lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt;Java 식별자 부분 문자&lt;/a&gt; 시퀀스입니다 .</target>
        </trans-unit>
        <trans-unit id="f6905fb07fa47d960a6cc1c5c35a7ad900455a52" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;foo&lt;/code&gt; becomes a wrapper for the actual native method with the appended prefix &quot;wrapped_&quot;. Note that &quot;wrapped_&quot; would be a poor choice of prefix since it might conceivably form the name of an existing method thus something like &quot;$$$MyAgentWrapped$$$_&quot; would be better but would make these examples less readable.</source>
          <target state="translated">여기서 &lt;code&gt;foo&lt;/code&gt; 는 접두사가 &quot;wrapped_&quot;인 실제 원시 메소드의 랩퍼가됩니다. &quot;wrapped_&quot;는 기존 메소드의 이름을 형성 할 수 있으므로 &quot;$$$ MyAgentWrapped $$$ _&quot;와 같은 것이 더 좋지만이 예제를 읽기 어렵게하기 때문에 접두어를 선택하는 것이 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fff88ed5ff71cb64ca036661748f73a8e3a0800" translate="yes" xml:space="preserve">
          <source>Where a file is registered with a watch service by means of a symbolic link then it is implementation specific if the watch continues to depend on the existence of the symbolic link after it is registered.</source>
          <target state="translated">파일이 심볼릭 링크를 통해 감시 서비스에 등록 된 경우, 파일이 등록 된 후 심볼릭 링크의 존재 여부에 따라 계속 시계가 의존하는지 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d790f6a28291e56f379a271ae7232a655fb1d865" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">멤버십 키가 소스에 한정되지 않고 기본 운영 체제가 소스 필터링을 지원하는 경우 &lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 특정 소스 주소에서 멀티 캐스트 데이터 그램을 차단하거나 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4eef4e93d3c18e96b9b78253a20017e48bb542d" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">멤버쉽 키가 소스별로 다르고 기본 운영 시스템이 소스 필터링을 지원하는 경우 &lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 특정 소스 주소에서 멀티 캐스트 데이터 그램을 차단하거나 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0ae8bbc1659706ac95235ca1ce689fe57f64b3" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">I / O 작업이 즉시 완료되고 시작 스레드가 그룹의 풀링 된 스레드 중 하나 인 경우 완료 핸들러는 시작 스레드에 의해 직접 호출 될 수 있습니다. 스택 오버플로를 방지하기 위해 구현시 스레드 스택의 활성화 수에 제한을 부과 할 수 있습니다. 일부 I / O 작업은 시작 스레드가 직접 완료 핸들러를 호출하는 것을 금지 할 수 있습니다 ( &lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8898ed0b51f593284e7f77a4f867cd2fc2e666cb" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">I / O 조작이 즉시 완료되고 시작 스레드가 그룹의 풀링 된 스레드 중 하나 인 경우 완료 스레드는 시작 스레드에 의해 직접 호출 될 수 있습니다. 스택 오버플로를 피하기 위해 구현시 스레드 스택의 활성화 수에 제한이있을 수 있습니다. 일부 I / O 조작은 시작 스레드가 완료 핸들러를 직접 호출하지 못하게 할 수 있습니다 ( &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="66ce7e87d0492095ddc6703b1b7f0c7420f96474" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현이 그룹 개념을 지원하지 않는 경우이 메서드는 항상 &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; 을&lt;/a&gt; throw 합니다. 사용자 계정 및 그룹의 네임 스페이스가 동일한 경우이 메서드는 &lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f2bcdaf392a0bc8b6a2ade4e800476f90476c33e" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현이 그룹의 개념을 지원하지 않는 경우,이 메소드는 항상 &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 사용자 계정 및 그룹의 네임 스페이스가 동일한 경우이 메소드는 &lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="cb723c111014ba92d8f87833b389ec9ea6719988" translate="yes" xml:space="preserve">
          <source>Where an implementation provides a means to start agents from the command-line interface, an agent is started by adding the following option to the command-line:</source>
          <target state="translated">구현이 명령 줄 인터페이스에서 에이전트를 시작하는 수단을 제공하는 경우 에이전트는 명령 줄에 다음 옵션을 추가하여 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f90c3240707b3d864205080111e67313bf0eee" translate="yes" xml:space="preserve">
          <source>Where an implementation supports an ACL model that differs from the NFSv4 defined ACL model then setting the initial ACL when creating the file must translate the ACL to the model supported by the file system. Methods that create a file should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to create a file that would be less secure as a result of the translation.</source>
          <target state="translated">구현이 NFSv4 정의 ACL 모델과 다른 ACL 모델을 지원하는 경우 파일을 작성할 때 초기 ACL을 설정하면 ACL을 파일 시스템이 지원하는 모델로 변환해야합니다. 파일을 작성하는 메소드 는 변환의 결과로 덜 안전한 파일을 작성하려는 시도를 &lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 거부해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b05be389f68d5924db16624428d14d236ca56aa" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; process I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">원하는 경우 &lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt; 클래스의 메서드를 사용하여 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;프로세스 I / O를 리디렉션 할 수도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3907849eb829645989d02022a9256583b35ccf13" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; subprocess I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">원하는 경우 &lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt; 클래스의 메서드를 사용하여 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;하위 프로세스 I / O를 리디렉션 할 수도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8cf0baa75731ca6a5102a9d1799ad35f096def7" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우 &lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 속성 값을 읽을 수 있습니다. 속성 값은 바이트 배열 (byte [])로 반환됩니다. &lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 방법 (것처럼 호출하여 버퍼로부터의 사용자 정의 속성의 값을 기록하는데 이용 될 수있다 &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 방법), 또는 바이트 배열 (byte []).</target>
        </trans-unit>
        <trans-unit id="0fbeca4a7ecd10802c77529dde8b082e44d0dd19" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우 &lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 속성 값을 읽을 수 있습니다. 속성 값은 바이트 배열 (byte [])로 반환됩니다. &lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 방법 (것처럼 호출하여 버퍼로부터의 사용자 정의 속성의 값을 기록하는데 이용 될 수있다 &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 방법), 또는 바이트 배열 (byte []).</target>
        </trans-unit>
        <trans-unit id="ebb78ae3ef6ed103a9eb1696cdee777cab788dee" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;a href=&quot;basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fileownerattributeview&quot;&gt;&lt;code&gt;FileOwnerAttributeView&lt;/code&gt;&lt;/a&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성은 &lt;a href=&quot;basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fileownerattributeview&quot;&gt; &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된대로 다음 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4e8ebe996cadf7a3b2a8cb30caf8f69a0b7ddda3" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;
 BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원하는 속성은 &lt;code&gt; BasicFileAttributeView&lt;/code&gt; 에 정의 된대로 이며 추가로 다음 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="277ea500a19bef26e680e53fb1654aac09fa83bc" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성은 &lt;code&gt;BasicFileAttributeView&lt;/code&gt; 에 의해 정의 된대로 다음 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cf674cc8cdf6492af75c97ec90cc9a040aea0c29" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as follows:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d820fbab2fe6e4127e50646c4e71b92a8792a22" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view have the following names and types:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성의 이름 및 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a3a8b24e5fea76a61408fffd2a003c38a23b39a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 반환 되는 경우와 I / O 예외를 구분해야 하거나 같은 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43d91b56e88fa1a42f8c6d2adc7c084514e56e79" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 리턴 되는 경우와 동일한 I / O 예외를 구별해야 하거나 동일한 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7de0392e6d47b4862228ebe6d2a818b846d1aedb" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O 예외를 파일이 디렉토리가 아닌 경우와 &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 경우 readAttributes 메서드 및 &lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt; 메서드로 테스트 된 파일 유형으로 파일 속성을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="005cb3d94ffb0d26668ec1404f37b73b1ba29dc4" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일이 디렉토리가 아닌 경우와 I / O 예외를 구별해야하는 경우, 파일 속성은 &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 메소드 로 읽고 파일 유형은 &lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt; 메소드로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="007567199ff26eceed4a5f4b5e1dc57ccb4d5705" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 디렉토리가 아닌 경우와 I / O 예외를 구분해야하거나 동일한 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bbbcba21c28c4d8c2c4924803def9e4ddb35ba8" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 디렉토리가 아닌 경우 또는 동일한 파일의 여러 속성이 동시에 필요한 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b9eef79be9b70ff82dc87b633ac874427f7ef1" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 일반 파일이 아닌 경우와 I / O 예외를 구분해야하거나 동일한 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="298b25c773a1934ae542e41dcabec7d24973199b" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 일반 파일이 아닌 경우 또는 동일한 파일의 여러 속성이 동시에 필요한 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21258737e247b6c14994cdb209414cffbf2cb58c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O 예외를 파일이 일반 파일이 아닌 경우와 &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 경우 readAttributes 메서드 및 &lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt; 메서드로 테스트 된 파일 유형으로 파일 속성을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02f695b12ef8bb76e6aea55a25eeab17ff1669ac" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일이 일반 파일이 아닌 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 메소드로 파일 속성을 읽고 &lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt; 메소드로 파일 유형을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b73ecca6efa6b0c0122ee193aadbfbbac0725868" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O 예외를 파일이 심볼릭 링크가 아닌 경우와 &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 경우 readAttributes 메서드 및 &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt; 메서드로 테스트 된 파일 유형으로 파일 속성을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b99909cf143f334a41da20c3faff5347727a01c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일이 기호 링크가 아닌 경우와 I / O 예외를 구별해야하는 경우, 파일 속성은 &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 메소드 로 읽고 파일 유형은 &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt; 메소드로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a3da2048af042507ba49cb66f0ec70eb628b60c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used. If however only the time of last modification is required, then the &lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.getLastModifiedTime&lt;/code&gt;&lt;/a&gt; method may be used instead.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 반환 되는 경우와 I / O 예외를 구분해야하는 경우 또는 동일한 파일의 여러 속성이 동시에 필요한 경우 또는 마지막 액세스 시간 또는 생성 시간이 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다. 그러나 마지막 수정 시간 만 필요한 경우 대신 &lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.getLastModifiedTime&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acaa3530ad31cc461c41f4ed0c962b27b0124c2a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 리턴되거나 동일한 파일의 여러 속성이 동시에 필요하거나 마지막 액세스 시간 또는 작성 시간이 필요한 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15c805f474acebca2530400cb8d6a021d50edd5e" translate="yes" xml:space="preserve">
          <source>Where possible, a newly constructed &lt;code&gt;DatagramSocket&lt;/code&gt; has the &lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt;&lt;code&gt;SO_BROADCAST&lt;/code&gt;&lt;/a&gt; socket option enabled so as to allow the transmission of broadcast datagrams. In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address. In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address.</source>
          <target state="translated">가능한 경우 새로 구성된 &lt;code&gt;DatagramSocket&lt;/code&gt; 에는 브로드 캐스트 데이터 그램의 전송을 허용하기 위해 &lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt; &lt;code&gt;SO_BROADCAST&lt;/code&gt; &lt;/a&gt; 소켓 옵션이 활성화되어 있습니다. 브로드 캐스트 패킷을 수신하려면 DatagramSocket을 와일드 카드 주소에 바인딩해야합니다. 일부 구현들에서, 브로드 캐스트 패킷들은 또한 DatagramSocket이보다 특정한 주소에 바인딩 될 때 수신 될 수있다.</target>
        </trans-unit>
        <trans-unit id="75db673482e4c428800f7f45f472cc74cb1cd427" translate="yes" xml:space="preserve">
          <source>Where possible, a newly constructed &lt;code&gt;DatagramSocket&lt;/code&gt; has the &lt;a href=&quot;standardsocketoptions#SO_BROADCAST&quot;&gt;&lt;code&gt;SO_BROADCAST&lt;/code&gt;&lt;/a&gt; socket option enabled so as to allow the transmission of broadcast datagrams. In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address. In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address.</source>
          <target state="translated">가능하면 새로 구성된 &lt;code&gt;DatagramSocket&lt;/code&gt; 에는 브로드 캐스트 데이터 그램의 전송을 허용하기 위해 &lt;a href=&quot;standardsocketoptions#SO_BROADCAST&quot;&gt; &lt;code&gt;SO_BROADCAST&lt;/code&gt; &lt;/a&gt; 소켓 옵션이 활성화되어 있습니다. 브로드 캐스트 패킷을 수신하려면 DatagramSocket을 와일드 카드 주소에 바인딩해야합니다. 일부 구현에서, 브로드 캐스트 패킷은 또한 DatagramSocket이보다 특정한 주소에 바인딩 될 때 수신 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae2251eb2bdde2077099e46a23fa2296253a4452" translate="yes" xml:space="preserve">
          <source>Where possible, applications should use &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;LocalDateTime&lt;/code&gt; to better model the domain. For example, a birthday should be stored in a code &lt;code&gt;LocalDate&lt;/code&gt;. Bear in mind that any use of a &lt;a href=&quot;zoneid&quot;&gt;time-zone&lt;/a&gt;, such as 'Europe/Paris', adds considerable complexity to a calculation. Many applications can be written only using &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;Instant&lt;/code&gt;, with the time-zone added at the user interface (UI) layer.</source>
          <target state="translated">가능한 경우 응용 프로그램은 &lt;code&gt;LocalDate&lt;/code&gt; , &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;LocalDateTime&lt;/code&gt; 을 사용 하여 도메인을 더 잘 모델링해야합니다. 예를 들어 생일은 코드 &lt;code&gt;LocalDate&lt;/code&gt; 에 저장해야합니다 . 곰은 마음에 어떤 사용하는 &lt;a href=&quot;zoneid&quot;&gt;시간대&lt;/a&gt; 등 '유럽 / 파리'등은 계산에 상당한 복잡성을 추가합니다. 많은 응용 프로그램은 사용자 인터페이스 (UI) 레이어에 시간대가 추가 된 &lt;code&gt;LocalDate&lt;/code&gt; , &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;Instant&lt;/code&gt; 만 사용하여 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91b2e2e10f69ab09824cf8a20764fb8ed9c2bb88" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the Enumeration's &lt;code&gt;nextElement&lt;/code&gt; method is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">여러 모듈이 동일한 클래스 로더에 정의되고 둘 이상의 모듈에 주어진 이름의 리소스가 포함 된 경우 순서가 지정되지 않고 예측할 수 없을 수 있습니다. 이 메서드를 재정의 할 때 구현시 모든 위임이 &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 메서드 와 일치하는지 확인하는 것이 좋습니다 . 이렇게하면 Enumeration의 &lt;code&gt;nextElement&lt;/code&gt; 메서드에 의해 반환 된 첫 번째 요소 가 &lt;code&gt;getResource(String)&lt;/code&gt; 메서드가 반환 하는 것과 동일한 리소스가 됩니다.</target>
        </trans-unit>
        <trans-unit id="30feb1a1deb63d86d797b59fc10ebf6c8ef8b081" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering that modules are searched is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResources(java.lang.String)&quot;&gt;&lt;code&gt;getResources(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">여러 모듈이 동일한 클래스 로더에 정의되고 두 개 이상의 모듈에 주어진 이름의 리소스가 포함 된 경우 모듈 검색 순서가 지정되지 않고 예측할 수 없을 수 있습니다. 이 메서드를 재정의 할 때 구현시 모든 위임이 &lt;a href=&quot;#getResources(java.lang.String)&quot;&gt; &lt;code&gt;getResources(String)&lt;/code&gt; &lt;/a&gt; 메서드 와 일치하는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="87e0bb7fc901d05afac4326d164f35bed3f81996" translate="yes" xml:space="preserve">
          <source>Where symbolic links are supported, but the underlying &lt;a href=&quot;filestore&quot;&gt;&lt;code&gt;FileStore&lt;/code&gt;&lt;/a&gt; does not support symbolic links, then this may fail with an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;. Additionally, some operating systems may require that the Java virtual machine be started with implementation specific privileges to create symbolic links, in which case this method may throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">기호 링크가 지원되지만 기본 &lt;a href=&quot;filestore&quot;&gt; &lt;code&gt;FileStore&lt;/code&gt; &lt;/a&gt; 가 기호 링크를 지원하지 않는 경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 과 함께 실패 할 수 있습니다 . 또한 일부 운영 체제에서는 기호 링크를 작성하기 위해 구현 별 권한으로 Java 가상 머신을 시작해야 할 수 있습니다 . 이 경우이 메소드는 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aff3ccdb832b941a77362ca0a3153b1ed7d1a9da" translate="yes" xml:space="preserve">
          <source>Where syntactically malformed entries are encountered, the entry is ignored and the remainder of entries in file are processed. For instances where duplicate country code entries exist, the behavior of the Currency information for that &lt;code&gt;Currency&lt;/code&gt; is undefined and the remainder of entries in file are processed.</source>
          <target state="translated">구문이 잘못된 항목이 발견되면 해당 항목이 무시되고 파일의 나머지 항목이 처리됩니다. 중복 된 국가 코드 항목이 존재하는 인스턴스의 경우, 그의 통화 정보의 동작 &lt;code&gt;Currency&lt;/code&gt; 정의하고 파일에있는 항목의 나머지 부분이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="645bad2c04254cc2a6d121dc714e9825c14fd591" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;
 mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(가) 어디 &lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; 방법은 호출된다 &lt;code&gt; mayInterruptIfRunning&lt;/code&gt; 의 에 파라미터 세트 &lt;code&gt;true&lt;/code&gt; 다음 I / O 작업이 채널을 닫아 중단 될 수 있습니다. 이 경우 I / O 작업의 결과를 기다리는 모든 스레드는 &lt;code&gt;CancellationException&lt;/code&gt; 을 throw 하고 채널에서 처리되지 않은 다른 I / O 작업은 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 예외로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0bfb8c567532e837621aeea501dc3f1ddcd12e2" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(가) 어디 &lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; 방법은 호출된다 &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; 의 에 파라미터 세트 &lt;code&gt;true&lt;/code&gt; 다음 I / O 작업이 채널을 닫아 중단 될 수 있습니다. 이 경우 I / O 조작의 결과로 대기중인 모든 스레드는 &lt;code&gt;CancellationException&lt;/code&gt; 및 채널에서 처리중인 다른 I / O 조작이 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 예외로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6c5daf70ef6f15c107a25281f6a04621e811b36" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;cancel&lt;/code&gt; method is invoked to cancel read or write operations then it is recommended that all buffers used in the I/O operations be discarded or care taken to ensure that the buffers are not accessed while the channel remains open.</source>
          <target state="translated">읽기 또는 쓰기 조작을 취소하기 위해 &lt;code&gt;cancel&lt;/code&gt; 메소드가 호출되는 경우, I / O 조작에 사용 된 모든 버퍼는 버려지거나 채널이 열려있는 동안 버퍼에 액세스하지 않도록주의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9d8305902030508a453b89974c5e0784154948cf" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;modified_package_name&lt;/code&gt; is the package name of this object with &lt;code&gt;'/'&lt;/code&gt; substituted for &lt;code&gt;'.'&lt;/code&gt; (&lt;code&gt;'\u002e'&lt;/code&gt;).</source>
          <target state="translated">여기서 &lt;code&gt;modified_package_name&lt;/code&gt; 은 &lt;code&gt;'/'&lt;/code&gt; 가 &lt;code&gt;'.'&lt;/code&gt; 로 대체 된 이 객체의 패키지 이름입니다 . ( &lt;code&gt;'\u002e'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="20aa13f386a65b9aa665ab0dd65397813225275a" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 인터넷 프로토콜 소켓 주소에 &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 경우이 메서드의 반환 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4b1d4e9876a115d289cc3d3d89044c6ff716cd4b" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 인터넷 프로토콜 소켓 주소에 &lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 경우이 메서드의 반환 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5776a8c2e2eb012135f9b2f791b325011a696da1" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 인터넷 프로토콜 소켓 주소에 &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 경우이 메소드의 리턴 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="2b5a252c98def07c02e37f2ec2055c98d16f0a55" translate="yes" xml:space="preserve">
          <source>Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 바인드되어 인터넷 프로토콜 소켓 주소에 연결된 경우이 메소드의 리턴 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f3d56641ee7619e7defb7d614564f85e1460565f" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">디렉토리가 성공적으로 열리면 디렉토리의 항목과 해당 &lt;em&gt;하위&lt;/em&gt; 항목을 방문합니다. 모든 항목을 방문했거나 디렉토리 반복 중에 I / O 오류가 발생하면 디렉토리가 닫히고 방문자의 &lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 그런 다음 파일 트리 워크는 기본적으로 디렉토리 의 다음 &lt;em&gt;형제&lt;/em&gt; 에서 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddadcdbdf7fecb97856976200f59b9dff77b97ca" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">디렉토리가 성공적으로 열리면 디렉토리의 항목 및 해당 &lt;em&gt;하위 항목&lt;/em&gt; 이 방문됩니다. 모든 항목을 방문했거나 디렉토리를 반복하는 동안 I / O 오류가 발생하면 디렉토리가 닫히고 방문자의 &lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 그런 다음 기본적으로 파일 트리 워크 는 디렉토리 의 다음 &lt;em&gt;형제&lt;/em&gt; 에서 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="f20fbb77d5a28e0705439af43dcf961b9abb6e04" translate="yes" xml:space="preserve">
          <source>Where the file is a directory, and the directory could not be opened, then the &lt;code&gt;visitFileFailed&lt;/code&gt; method is invoked with the I/O exception, after which, the file tree walk continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">파일이 디렉토리이고 디렉토리를 열 수없는 경우 &lt;code&gt;visitFileFailed&lt;/code&gt; 메소드는 I / O 예외와 함께 호출되며, 그 후에 는 디렉토리 의 다음 &lt;em&gt;형제&lt;/em&gt; 에서 기본적으로 파일 트리 워크가 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="813178800981aaf7228102a5aacbe600959c9826" translate="yes" xml:space="preserve">
          <source>Where the file system supports Access Control Lists, and it uses an ACL model that differs from the NFSv4 defined ACL model, then this method must translate the ACL to the model supported by the file system. This method should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to write an ACL that would appear to make the file more secure than would be the case if the ACL were updated. Where an implementation does not support a mapping of &lt;a href=&quot;aclentrytype#AUDIT&quot;&gt;&lt;code&gt;AclEntryType.AUDIT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;aclentrytype#ALARM&quot;&gt;&lt;code&gt;AclEntryType.ALARM&lt;/code&gt;&lt;/a&gt; entries, then this method ignores these entries when writing the ACL.</source>
          <target state="translated">파일 시스템이 액세스 제어 목록을 지원하고 NFSv4 정의 ACL 모델과 다른 ACL 모델을 사용하는 경우이 방법은 ACL을 파일 시스템이 지원하는 모델로 변환해야합니다. 이 메소드는 ACL이 업데이트 된 경우보다 파일을 더 안전하게 만드는 것으로 보이는 ACL을 작성하려는 시도를 &lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 거부해야합니다 . 구현이 &lt;a href=&quot;aclentrytype#AUDIT&quot;&gt; &lt;code&gt;AclEntryType.AUDIT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;aclentrytype#ALARM&quot;&gt; &lt;code&gt;AclEntryType.ALARM&lt;/code&gt; &lt;/a&gt; 항목 의 맵핑을 지원하지 않는 경우이 메소드는 ACL을 작성할 때 이러한 항목을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1bf3aa721e02b8abb961e05d45c9ccdfa7286d66" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next()&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;
 IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;
 next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">포착되지 않은 오류 또는 런타임 예외로 인해 필터가 종료되는 경우 &lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../util/iterator#next()&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메소드로 전파됩니다 . 경우 &lt;code&gt; IOException&lt;/code&gt; 이가 발생합니다, 그것은 결과 &lt;code&gt;hasNext&lt;/code&gt; 또는 &lt;code&gt; next&lt;/code&gt; 던지는 방법 &lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 을&lt;/a&gt; 과 &lt;code&gt;IOException&lt;/code&gt; 이 원인으로.</target>
        </trans-unit>
        <trans-unit id="8251e33247a11466c53d88af669cedf9a7c9b244" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next--&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">포착되지 않은 오류 또는 런타임 예외로 인해 필터가 종료되는 경우 &lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../util/iterator#next--&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메소드로 전파됩니다 . 경우 &lt;code&gt;IOException&lt;/code&gt; 이가 발생합니다, 그것은 결과 &lt;code&gt;hasNext&lt;/code&gt; 또는 &lt;code&gt;next&lt;/code&gt; 던지는 방법 &lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 을&lt;/a&gt; 과 &lt;code&gt;IOException&lt;/code&gt; 이 원인으로.</target>
        </trans-unit>
        <trans-unit id="6af0ee5404f0be6ffe44935c032e92267f7c81e1" translate="yes" xml:space="preserve">
          <source>Where the impact lies, however, is in constructing and showing a Swing application. Calls to an application's &lt;code&gt;main&lt;/code&gt; method, or methods in &lt;code&gt;Applet&lt;/code&gt;, are not invoked on the event dispatching thread. As such, care must be taken to transfer control to the event dispatching thread when constructing and showing an application or applet. The preferred way to transfer control and begin working with Swing is to use &lt;code&gt;invokeLater&lt;/code&gt;. The &lt;code&gt;invokeLater&lt;/code&gt; method schedules a &lt;code&gt;Runnable&lt;/code&gt; to be processed on the event dispatching thread. The following two examples work equally well for transferring control and starting up a Swing application:</source>
          <target state="translated">그러나 영향이있는 곳은 Swing 애플리케이션을 구축하고 보여주는 것입니다. 애플리케이션의 &lt;code&gt;main&lt;/code&gt; 메소드 또는 &lt;code&gt;Applet&lt;/code&gt; 의 메소드 에 대한 호출은 이벤트 디스패치 스레드에서 호출되지 않습니다. 따라서 응용 프로그램이나 애플릿을 구성하고 표시 할 때 제어를 이벤트 디스패치 스레드로 전송하는 데주의를 기울여야합니다. 제어를 전송하고 Swing 작업을 시작하는 가장 좋은 방법은 &lt;code&gt;invokeLater&lt;/code&gt; 를 사용하는 것 입니다. &lt;code&gt;invokeLater&lt;/code&gt; 에 있어서 일정 &lt;code&gt;Runnable&lt;/code&gt; 이벤트 디스 패칭 스레드에 처리한다. 다음 두 가지 예제는 제어권을 전송하고 Swing 애플리케이션을 시작하는 데 동일하게 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c51f5961597e3abbd7cbd8e36154eb7f8ad2d5be" translate="yes" xml:space="preserve">
          <source>Where the nodes to be removed are read-only descendants of an &lt;code&gt;EntityReference&lt;/code&gt;, the &lt;code&gt;EntityReference&lt;/code&gt; must be removed instead of the read-only nodes. If any &lt;code&gt;EntityReference&lt;/code&gt; to be removed has descendants that are not &lt;code&gt;EntityReference&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, or &lt;code&gt;CDATASection&lt;/code&gt; nodes, the &lt;code&gt;replaceWholeText&lt;/code&gt; method must fail before performing any modification of the document, raising a &lt;code&gt;DOMException&lt;/code&gt; with the code &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt;.</source>
          <target state="translated">노드가 읽기 전용의 후손 제거 할 경우 &lt;code&gt;EntityReference&lt;/code&gt; 의 &lt;code&gt;EntityReference&lt;/code&gt; 대신 읽기 전용 노드를 제거해야합니다. 제거 할 &lt;code&gt;EntityReference&lt;/code&gt; 에 &lt;code&gt;EntityReference&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; 또는 &lt;code&gt;CDATASection&lt;/code&gt; 노드 가 아닌 하위 항목이있는 경우 문서 수정을 수행하기 전에 &lt;code&gt;replaceWholeText&lt;/code&gt; 메서드가 실패해야 하며 코드 &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt; 과 함께 &lt;code&gt;DOMException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e9e95719d37b90a01bb50bb0f34cef6a4524dc4a" translate="yes" xml:space="preserve">
          <source>Where the tabs are placed.</source>
          <target state="translated">탭이있는 위치.</target>
        </trans-unit>
        <trans-unit id="312f35b21c5541d25fef137d0c9ff3c37934f56a" translate="yes" xml:space="preserve">
          <source>Where there is insufficient space to store the attribute, or the attribute name or value exceed an implementation specific maximum size then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">속성을 저장할 공간이 충분하지 않거나 속성 이름 또는 값이 구현 특정 최대 크기를 초과하면 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="78177395926d156536f0c1ac9740391b9dc6422e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 관련 스레드 풀도 &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3596c9771db04fbff45896ebd877c1d02f0912e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 , 관련의 thread pool도 &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7c18078eeeb8440182461deea920927988a9b5" translate="yes" xml:space="preserve">
          <source>Where two scroll bars meet, the row header meets the column header, or a scroll bar meets one of the headers, both components stop short of the corner, leaving a rectangular space which is, by default, empty. These spaces can potentially exist in any number of the four corners. In the previous diagram, the top right space is present and identified by the label &quot;corner component&quot;.</source>
          <target state="translated">두 개의 스크롤 막대가 만나는 곳에서 행 머리글이 열 머리글과 만나거나 스크롤 막대가 머리글 중 하나와 만나면 두 구성 요소가 모두 모서리에서 멈추고 기본적으로 빈 사각형 공간이 남습니다. 이러한 공간은 잠재적으로 네 모서리에 존재할 수 있습니다. 이전 다이어그램에서 오른쪽 상단 공간은 &quot;코너 구성 요소&quot;라는 레이블로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="f85fba4d6258a50067fbdc6fb4924687e3519a29" translate="yes" xml:space="preserve">
          <source>Where value limitations are given, any value outside of that set is reserved for future use; the value will be treated as the default.</source>
          <target state="translated">값 제한이 제공되는 경우 해당 세트를 벗어난 모든 값은 향후 사용을 위해 예약됩니다. 값은 기본값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b93b49aca4151b6c139adc0aa283a778340da4f0" translate="yes" xml:space="preserve">
          <source>Where, in this case, the method handle is bound to the VarHandle instance.</source>
          <target state="translated">이 경우 메서드 핸들은 VarHandle 인스턴스에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="70c9d617c105e0ab6aed38dbb10fa98dbb5056d6" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a &lt;code&gt;null&lt;/code&gt; print stream to create a queryable service. It is not valid to create a &lt;code&gt;PrintJob&lt;/code&gt; for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is &lt;code&gt;non-null&lt;/code&gt;.</source>
          <target state="translated">반면 &lt;code&gt;PrintService&lt;/code&gt; 의 물리적 접속 프린터가 재사용 될 수있다하는 &lt;code&gt;StreamPrintService&lt;/code&gt; 에는이 스트림에 접속 불가능. 기본 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 &lt;code&gt;DocPrintJob&lt;/code&gt; 의 &lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환하기 전에 &lt;a href=&quot;streamprintservice#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 인쇄 시스템에 의해 삭제되어 인쇄 시스템 이이 프린터를 더 이상 사용할 수 없음을 알 수 있습니다. 이는 물리적 프린터가 영구적으로 오프라인 상태가되는 것과 같습니다. 응용 프로그램은 쿼리 가능한 서비스를 만들기 위해 &lt;code&gt;null&lt;/code&gt; 인쇄 스트림을 제공 할 수 있습니다. &lt;code&gt;PrintJob&lt;/code&gt; 을 만드는 것은 유효하지 않습니다.그런 스트림을 위해. 구성에 리소스를 할당하는 구현은 스트림을 검사해야하며 스트림이 &lt;code&gt;non-null&lt;/code&gt; 이 아닌 경우에만 리소스를 할당하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b6a9723c6d2f9343f85c6d8af60801d7b7682ec" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose--&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a null print stream to create a queryable service. It is not valid to create a PrintJob for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is non-null.</source>
          <target state="translated">실제 프린터에 연결된 &lt;code&gt;PrintService&lt;/code&gt; 를 재사용 할 수있는 반면 스트림에 연결된 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 재사용 할 수 없습니다. 기본 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 인쇄 시스템이이 프린터를 더 이상 사용할 수 없음을 알 수 있도록 &lt;code&gt;DocPrintJob&lt;/code&gt; 의 &lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 메소드 에서 돌아 오기 전에 &lt;a href=&quot;streamprintservice#dispose--&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 인쇄 시스템에 의해 처리 될 수 있습니다 . 이것은 실제 프린터가 오프라인 상태가되는 것과 같습니다. 응용 프로그램은 쿼리 가능한 서비스를 만들기 위해 null 인쇄 스트림을 제공 할 수 있습니다. 이러한 스트림에 대해 PrintJob을 작성하는 것은 유효하지 않습니다. 구성시 자원을 할당하는 구현은 스트림을 검사해야하며 스트림이 널이 아닌 경우에만 자원을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68dfcf4573839943af330771499a40761c894968" translate="yes" xml:space="preserve">
          <source>Whereas these are not (reason in parentheses):</source>
          <target state="translated">이것들이 아닌 반면 (괄호 안의 이유) :</target>
        </trans-unit>
        <trans-unit id="034389c570341c477b986ed7aab5d2ac27118931" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;waitForIdle&lt;/code&gt; is automatically called</source>
          <target state="translated">&lt;code&gt;waitForIdle&lt;/code&gt; 이 자동으로 호출 되는지 여부</target>
        </trans-unit>
        <trans-unit id="0787c7934fdfd663c379d9463c168a4a31331bbd" translate="yes" xml:space="preserve">
          <source>Whether C++-style comments are to be recognized and skipped.</source>
          <target state="translated">C ++ 스타일 주석을 인식하고 건너 뛸지 여부</target>
        </trans-unit>
        <trans-unit id="e0848da24388d28c1afb73d61f7a7588fee7e498" translate="yes" xml:space="preserve">
          <source>Whether C-style comments are to be recognized and skipped.</source>
          <target state="translated">C 스타일 주석을 인식하고 건너 뛸지 여부</target>
        </trans-unit>
        <trans-unit id="3ce96c4b92120512de6ee705be9cc10faccd0e37" translate="yes" xml:space="preserve">
          <source>Whether a &lt;a href=&quot;tifftag&quot;&gt;&lt;code&gt;TIFFTag&lt;/code&gt;&lt;/a&gt; with tag number equal to &lt;code&gt;tagNumber&lt;/code&gt; is present in this &lt;code&gt;TIFFDirectory&lt;/code&gt;.</source>
          <target state="translated">되든지 관계없이 &lt;a href=&quot;tifftag&quot;&gt; &lt;code&gt;TIFFTag&lt;/code&gt; &lt;/a&gt; 태그 번호와 같 &lt;code&gt;tagNumber&lt;/code&gt; 이에 존재 &lt;code&gt;TIFFDirectory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368fda18947ddfae823fba3ad12c0006e725b91a" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;#isDirect()&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">바이트 버퍼가 직접 또는 비 직접인지 여부는 &lt;a href=&quot;#isDirect()&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 결정할 수 있습니다 . 이 방법은 성능이 중요한 코드에서 명시 적 버퍼 관리를 수행 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="51a1385dc9a39d4da44928c4400ff21a87209713" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;bytebuffer#isDirect--&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">바이트 버퍼가 직접인지 아닌지 여부는 &lt;a href=&quot;bytebuffer#isDirect--&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt; 를 호출하여 확인할 수 있습니다. 메소드 . 이 방법은 성능에 중요한 코드에서 명시 적 버퍼 관리를 수행 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="76ac3d7ca9570e219636389efe4d99114c39fbb9" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;#isShared()&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">잠금이 독점인지 공유인지는 &lt;a href=&quot;#isShared()&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 판별 할 수 있습니다 . 일부 플랫폼은 공유 잠금을 지원하지 않습니다.이 경우 공유 잠금 요청이 배타적 잠금 요청으로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="059d74aa74a1f70698c412f2b1b1fb68c363877d" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;filelock#isShared--&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">잠금이 배타적인지 공유인지는 &lt;a href=&quot;filelock#isShared--&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt; 를 호출하여 확인할 수 있습니다. 메소드 . 일부 플랫폼은 공유 잠금을 지원하지 않습니다.이 경우 공유 잠금 요청은 독점 잠금 요청으로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6533c544c3a0529e57beea5f901c658d036545" translate="yes" xml:space="preserve">
          <source>Whether a particular component is or is not defined in an instance depends upon the type of the URI being represented. An absolute URI has a scheme component. An opaque URI has a scheme, a scheme-specific part, and possibly a fragment, but has no other components. A hierarchical URI always has a path (though it may be empty) and a scheme-specific-part (which at least contains the path), and may have any of the other components. If the authority component is present and is server-based then the host component will be defined and the user-information and port components may be defined.</source>
          <target state="translated">특정 컴포넌트가 인스턴스에 정의되어 있는지 여부는 표시되는 URI의 유형에 따라 다릅니다. 절대 URI에는 체계 구성 요소가 있습니다. 불투명 한 URI에는 체계, 체계 별 부분 및 조각이 있지만 다른 구성 요소는 없습니다. 계층 적 URI는 항상 경로 (비어있을 수 있음)와 구성표 특정 부분 (적어도 경로를 포함)을 가지며 다른 구성 요소를 가질 수 있습니다. 권한 구성 요소가 존재하고 서버 기반 인 경우 호스트 구성 요소가 정의되고 사용자 정보 및 포트 구성 요소가 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7b45add21d97d6f92bb3c58b9dd4adb30ed79cd" translate="yes" xml:space="preserve">
          <source>Whether a thread is a daemon thread</source>
          <target state="translated">스레드가 데몬 스레드인지 여부</target>
        </trans-unit>
        <trans-unit id="d404f71e4894750c15b6981c1f6ed118e11a813d" translate="yes" xml:space="preserve">
          <source>Whether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked. If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched. If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.</source>
          <target state="translated">가상 머신에 콘솔이 있는지 여부는 기본 플랫폼 및 가상 머신이 호출되는 방식에 따라 다릅니다. 표준 입력 및 출력 스트림을 경로 재지 정하지 않고 대화식 명령 행에서 가상 머신을 시작하면 해당 콘솔이 존재하며 일반적으로 가상 머신이 시작된 키보드 및 디스플레이에 연결됩니다. 백그라운드 작업 스케줄러와 같은 가상 머신이 자동으로 시작되면 일반적으로 콘솔이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b2f8d65d541d32da6ac4db35fde558abe5bba9b" translate="yes" xml:space="preserve">
          <source>Whether aliases are case sensitive is implementation dependent. In order to avoid problems, it is recommended not to use aliases in a KeyStore that only differ in case.</source>
          <target state="translated">별칭이 대소 문자를 구분하는지 여부는 구현에 따라 다릅니다. 문제점을 피하기 위해 경우에 따라 다른 키 저장소에서 별명을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e459ddcf8add7fb4f45be0659b059f816d4f3a8a" translate="yes" xml:space="preserve">
          <source>Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here. This allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys. Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats).</source>
          <target state="translated">키 저장소가 지속적인지 여부와 키 저장소가 지속적이면 키 저장소가 사용하는 메커니즘은 여기에 지정되어 있지 않습니다. 이를 통해 민감한 (예 : 개인 또는 비밀) 키를 보호하기위한 다양한 기술을 사용할 수 있습니다. 스마트 카드 또는 기타 통합 암호화 엔진 (SafeKeyper)은 하나의 옵션이며 파일과 같은 간단한 메커니즘을 다양한 형식으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="839575dd0da2dbc62283eccad2a293850044e605" translate="yes" xml:space="preserve">
          <source>Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens.</source>
          <target state="translated">행 종결자가 토큰으로 리턴되는지 또는 단순히 토큰을 분리하는 공백으로 처리되는지 여부</target>
        </trans-unit>
        <trans-unit id="64009d2c9b3c4d0e007e474d4b10457e969ea24e" translate="yes" xml:space="preserve">
          <source>Whether new values can be written to the attribute.</source>
          <target state="translated">새 값을 속성에 쓸 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="b03220d01de6d75c311d805bed01816711949222" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;#isRegistered()&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">채널이 하나 이상의 선택 자로 등록되었는지 여부는 &lt;a href=&quot;#isRegistered()&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed0c61cf2fb7a55d68d476b3cbe4799a77c242a1" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">채널이 하나 이상의 선택기에 등록되어 있는지 여부는 &lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d4e0c74b1ca2cffb49ee764de91039c786dd2b9" translate="yes" xml:space="preserve">
          <source>Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one &lt;code&gt;FileWriter&lt;/code&gt; (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.</source>
          <target state="translated">파일의 사용 가능 여부는 기본 플랫폼에 따라 다릅니다. 특히 일부 플랫폼에서는 한 번에 하나의 &lt;code&gt;FileWriter&lt;/code&gt; (또는 다른 파일 쓰기 객체) 만 쓰기 위해 파일을 열 수 있습니다 . 이러한 상황에서 관련된 파일이 이미 열려 있으면이 클래스의 생성자가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ea35fdbb197a6d4bef3ff403fa57d76ec3b52a58" translate="yes" xml:space="preserve">
          <source>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely</source>
          <target state="translated">잠금이 실제로 다른 프로그램이 잠긴 영역의 내용에 액세스하지 못하게하는지 여부는 시스템에 따라 다르므로 지정되지 않습니다. 일부 시스템의 기본 파일 잠금 기능은</target>
        </trans-unit>
        <trans-unit id="5484541c29643b9a5f36af7eafe3c332aef64933" translate="yes" xml:space="preserve">
          <source>Whether or not a read-write lock will improve performance over the use of a mutual exclusion lock depends on the frequency that the data is read compared to being modified, the duration of the read and write operations, and the contention for the data - that is, the number of threads that will try to read or write the data at the same time. For example, a collection that is initially populated with data and thereafter infrequently modified, while being frequently searched (such as a directory of some kind) is an ideal candidate for the use of a read-write lock. However, if updates become frequent then the data spends most of its time being exclusively locked and there is little, if any increase in concurrency. Further, if the read operations are too short the overhead of the read-write lock implementation (which is inherently more complex than a mutual exclusion lock) can dominate the execution cost, particularly as many read-write lock implementations still serialize all threads through a small section of code. Ultimately, only profiling and measurement will establish whether the use of a read-write lock is suitable for your application.</source>
          <target state="translated">읽기 / 쓰기 잠금이 상호 배제 잠금을 사용하여 성능을 향상 시킬지 여부는 데이터를 수정하는 것과 비교 한 빈도, 읽기 및 쓰기 작업 기간 및 데이터 경합에 따라 다릅니다. 데이터를 동시에 읽거나 쓰려고하는 스레드 수입니다. 예를 들어, 처음에 데이터로 채워지고 그 후에 자주 검색되는 동안 (일부 디렉토리와 같은) 컬렉션은 읽기-쓰기 잠금을 사용하기에 이상적인 후보입니다. 그러나 업데이트가 자주 발생하면 대부분의 시간을 독점적으로 잠그는 데 소요되며 동시성 증가가 거의 발생하지 않습니다. 더욱이,읽기 작업이 너무 짧은 경우 읽기-쓰기 잠금 구현의 오버 헤드 (상호 배제 잠금보다 본질적으로 더 복잡함), 특히 많은 읽기-쓰기 잠금 구현이 여전히 작은 섹션을 통해 모든 스레드를 직렬화함에 따라 실행 비용을 지배 할 수 있습니다. 코드 궁극적으로 프로파일 링 및 측정만으로 읽기-쓰기 잠금 사용이 애플리케이션에 적합한 지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ab8f019130320385026e5dab14b4180991ab8cbe" translate="yes" xml:space="preserve">
          <source>Whether or not a selection operation blocks to wait for one or more channels to become ready, and if so for how long, is the only essential difference between the three selection methods.</source>
          <target state="translated">선택 조작이 하나 이상의 채널이 준비 될 때까지 대기하는지 여부와 시간이 얼마나 걸리는지는 세 가지 선택 방법 간의 유일한 필수 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="41ee46a746e75b2c44835c6bb604f840669e2531" translate="yes" xml:space="preserve">
          <source>Whether or not a thread writing bytes to a pipe will block until another thread reads those bytes, or some previously-written bytes, from the pipe is system-dependent and therefore unspecified. Many pipe implementations will buffer up to a certain number of bytes between the sink and source channels, but such buffering should not be assumed.</source>
          <target state="translated">파이프에 바이트를 쓰는 스레드가 다른 스레드가 파이프에서 해당 바이트 또는 일부 이전에 쓴 바이트를 읽을 때까지 차단되는지 여부는 시스템에 따라 다르므로 지정되지 않습니다. 많은 파이프 구현은 싱크와 소스 채널 사이의 특정 바이트 수까지 버퍼링하지만 이러한 버퍼링을 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f1753321a954e7b513350ab852758250afb77bcc" translate="yes" xml:space="preserve">
          <source>Whether or not the border has rounded corners.</source>
          <target state="translated">테두리에 둥근 모서리가 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="fefaa51af10ff6b34610a73fe360a147bd71b1e4" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer has been recently restored from a lost state.</source>
          <target state="translated">드로잉 버퍼가 최근 손실 된 상태에서 복원되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4d74f9e48a7c981d657e06b3f4e62aa762abfdf7" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was lost since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getDrawGraphics&lt;/code&gt; 에 대한 마지막 호출 이후 드로잉 버퍼가 손실되었는지 여부 .</target>
        </trans-unit>
        <trans-unit id="b46af6682380966e3f1a4318992d86f116b4966b" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was restored since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getDrawGraphics&lt;/code&gt; 에 대한 마지막 호출 이후 드로잉 버퍼가 복원되었는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="dfcdb3967632f01437df753633766fd60adb3757" translate="yes" xml:space="preserve">
          <source>Whether or not the lead anchor notification is enabled.</source>
          <target state="translated">리드 앵커 알림 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b67aae029276f7596e2d6a2c6bdefef7f78062c8" translate="yes" xml:space="preserve">
          <source>Whether or not the returned key is trusted and the mechanisms used to determine that is implementation-specific.</source>
          <target state="translated">반환 된 키가 신뢰할 수 있는지 여부와이를 결정하는 데 사용되는 메커니즘이 구현별로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="882147ddaf8db0c13715bcfc2446b83df5e1174d" translate="yes" xml:space="preserve">
          <source>Whether or not the root component of this path starts with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not start with the given path.</source>
          <target state="translated">이 경로의 루트 구성 요소가 주어진 경로의 루트 구성 요소로 시작하는지의 여부는 파일 시스템에 따라 다릅니다. 이 경로에 루트 구성 요소가없고 지정된 경로에 루트 구성 요소가 있으면이 경로는 지정된 경로로 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5561b885c61970439f8e8ab1f7452ebbd54f6012" translate="yes" xml:space="preserve">
          <source>Whether or not the views are continuously redisplayed while resizing.</source>
          <target state="translated">크기를 조정하는 동안 뷰가 계속 다시 표시되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8d8dadabe9f784b22272f65c7af34baa4ecf3fe7" translate="yes" xml:space="preserve">
          <source>Whether or not this is equal to the argument.</source>
          <target state="translated">이것이 인수와 같은지의 여부.</target>
        </trans-unit>
        <trans-unit id="2c8782dc43c139a892cf9eca05fb5d76826e3adf" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">두 경로가 같은지 여부는 파일 시스템 구현에 따라 다릅니다. 어떤 경우에는 경로가 대소 문자를 구분하지 않고 비교되고 다른 경로는 대소 문자를 구분합니다. 이 방법은 파일 시스템에 액세스하지 않으며 파일이 존재하지 않아도됩니다. 필요한 경우 &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 두 경로가 동일한 파일을 찾는 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8370dbb2c98105665a87fe7a4451e4d08277efed" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">두 경로가 같은지 여부는 파일 시스템 구현에 따라 다릅니다. 어떤 경우에는 경로가 대소 문자와 상관없이 비교되고 다른 경우는 대소 문자를 구분합니다. 이 방법은 파일 시스템에 액세스하지 않으며 파일이 필요하지 않습니다. 필요한 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 두 경로가 동일한 파일을 찾는 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8284d3a1a8d812ad6669b46283821c095c0da402" translate="yes" xml:space="preserve">
          <source>Whether the characters of identifiers are converted to lowercase.</source>
          <target state="translated">식별자의 문자가 소문자로 변환되는지 여부</target>
        </trans-unit>
        <trans-unit id="8cb35ed334e6abf3cc5d46cfafbdff505f970f2b" translate="yes" xml:space="preserve">
          <source>Whether the checks for Java language access control can be suppressed (and thus, whether access can be enabled) depends on whether the reflected object corresponds to a member in an exported or open package (see &lt;a href=&quot;#setAccessible(boolean)&quot;&gt;&lt;code&gt;setAccessible(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Java 언어 액세스 제어에 대한 검사를 억제 할 수 있는지 (따라서 액세스를 사용할 수 있는지 여부)는 반영된 객체가 내 보낸 패키지 또는 열린 패키지의 멤버에 해당하는지 여부에 따라 다릅니다 ( &lt;a href=&quot;#setAccessible(boolean)&quot;&gt; &lt;code&gt;setAccessible(boolean)&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="abed7ebf656d855109885e2ad219cda0e430ff8f" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not.</source>
          <target state="translated">디렉토리를 순회 할 수 있는지 여부.</target>
        </trans-unit>
        <trans-unit id="9f7b655899be35706a060ba063ac17985c822863" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not. This might be useful, for example, if you want a directory to represent a compound document and don't want the user to descend into it.</source>
          <target state="translated">디렉토리를 순회 할 수 있는지 여부. 예를 들어 디렉토리가 복합 문서를 나타내도록하고 사용자가 그 문서로 내려 가지 않도록하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72bdf44965cf1882a7b82e577ba831bb4aa3aad8" translate="yes" xml:space="preserve">
          <source>Whether the effect of sheet collation is achieved by placing copies of a document in multiple output bins or in the same output bin with implementation defined document separation is implementation dependent. Also whether it is achieved by making multiple passes over the job or by using an output sorter is implementation dependent.</source>
          <target state="translated">문서 사본을 여러 출력 용지함에 배치하거나 구현 정의 문서 분리가있는 동일한 출력 용지함에 배치하여 시트 데이터 정렬의 효과를 달성하는지 여부는 구현에 따라 다릅니다. 또한 작업을 여러 번 통과하거나 출력 분류기를 사용하여 달성하는지 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="80415a2402a1eeb4d1614afdc0790cc2cd751eb2" translate="yes" xml:space="preserve">
          <source>Whether the field type is integral.</source>
          <target state="translated">필드 유형이 필수인지 여부.</target>
        </trans-unit>
        <trans-unit id="0d0d9b917bd4457293707b233fdfaf38f800ca2f" translate="yes" xml:space="preserve">
          <source>Whether the given file is accepted by this filter.</source>
          <target state="translated">주어진 파일이이 필터에 의해 허용되는지 여부.</target>
        </trans-unit>
        <trans-unit id="0b221a5fcef637ecf18d19b895618107e0ec7d34" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical.</source>
          <target state="translated">진행률 표시 줄이 수평인지 수직인지 여부.</target>
        </trans-unit>
        <trans-unit id="a6d6a865c13d64eec6f0217eba676663f0999299" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical. The default is &lt;code&gt;HORIZONTAL&lt;/code&gt;.</source>
          <target state="translated">진행률 표시 줄이 수평인지 수직인지 여부. 기본값은 &lt;code&gt;HORIZONTAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d07e8763f02114da7e0c71037a504961880c1abb" translate="yes" xml:space="preserve">
          <source>Whether the slider is horizontal or vertical The default is horizontal.</source>
          <target state="translated">슬라이더가 수평인지 수직인지 여부 기본값은 수평입니다.</target>
        </trans-unit>
        <trans-unit id="b500b42f712219c24a8bd54914f1fa1b4e445284" translate="yes" xml:space="preserve">
          <source>Whether the value of the attribute can be read.</source>
          <target state="translated">속성 값을 읽을 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="d7db98311d27050f8bbb866412a5ea00983c801f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar.</source>
          <target state="translated">진행률 표시 줄 주위에 테두리를 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0d7eb02de3d8787df6eadd74e0b934899bf8467f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">진행률 표시 줄 주위에 테두리를 표시할지 여부입니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7bb449420de50b1f70b9cf8aa6735bcb426d5e7f" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar.</source>
          <target state="translated">진행률 표시 줄에 텍스트 문자열을 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6ce38cd557d077996b81c259fa55fc8d873bb920" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar. The default is &lt;code&gt;false&lt;/code&gt;. Setting this to &lt;code&gt;true&lt;/code&gt; causes a textual display of the progress to be rendered on the progress bar. If the &lt;code&gt;progressString&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the percentage of completion is displayed on the progress bar. Otherwise, the &lt;code&gt;progressString&lt;/code&gt; is rendered on the progress bar.</source>
          <target state="translated">진행률 표시 줄에 텍스트 문자열을 표시할지 여부입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이 값을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 진행률 표시 줄에 진행률의 텍스트 표시가 렌더링됩니다. 경우 &lt;code&gt;progressString&lt;/code&gt; 이가 있다 &lt;code&gt;null&lt;/code&gt; , 완료의 비율은 진행 표시 줄에 표시됩니다. 그렇지 않으면 &lt;code&gt;progressString&lt;/code&gt; 이 진행률 표시 줄에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="49449561f235eb64ebabd8dfba321eb0bf01fd39" translate="yes" xml:space="preserve">
          <source>Whether to read fields of unrecognized tags</source>
          <target state="translated">인식 할 수없는 태그 필드를 읽을 지 여부</target>
        </trans-unit>
        <trans-unit id="610c7400d727b3d0294243a02c10a7e75f931042" translate="yes" xml:space="preserve">
          <source>Which is equivalent to:</source>
          <target state="translated">다음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b31b01303e594ceee1ff860c123b19192ba02c04" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../java.base/java/lang/invoke/package-summary&quot;&gt;&lt;code&gt;java.lang.invoke&lt;/code&gt;&lt;/a&gt; provides a low level API for dynamic linking of &lt;code&gt;invokedynamic&lt;/code&gt; call sites, it does not provide a way to express higher level operations on objects, nor methods that implement them. These operations are the usual ones in object-oriented environments: property access, access of elements of collections, invocation of methods and constructors (potentially with multiple dispatch, e.g. link- and run-time equivalents of Java overloaded method resolution). These are all functions that are normally desired in a language on the JVM. If a language is statically typed and its type system matches that of the JVM, it can accomplish this with use of the usual invocation, field access, etc. instructions (e.g. &lt;code&gt;invokevirtual&lt;/code&gt;, &lt;code&gt;getfield&lt;/code&gt;). However, if the language is dynamic (hence, types of some expressions are not known until evaluated at run time), or its object model or type system don't match closely that of the JVM, then it should use &lt;code&gt;invokedynamic&lt;/code&gt; call sites instead and let Dynalink manage them.</source>
          <target state="translated">&lt;a href=&quot;../java.base/java/lang/invoke/package-summary&quot;&gt; &lt;code&gt;java.lang.invoke&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;invokedynamic&lt;/code&gt; 호출 사이트 의 동적 링크를위한 낮은 수준의 API를 제공 하지만 개체에 대한 높은 수준의 작업을 표현하는 방법이나이를 구현하는 메서드를 제공하지 않습니다. 이러한 작업은 객체 지향 환경에서 일반적인 작업입니다. 속성 액세스, 컬렉션 요소 액세스, 메서드 및 생성자 호출 (잠재적으로 Java 오버로드 된 메서드 확인의 링크 및 런타임 등가물과 같은 다중 디스패치 사용). 이들은 JVM의 언어에서 일반적으로 원하는 모든 기능입니다. 언어가 정적으로 유형화되고 유형 시스템이 JVM의 유형 시스템과 일치하면 일반적인 호출, 필드 액세스 등의 명령 (예 : &lt;code&gt;invokevirtual&lt;/code&gt; , &lt;code&gt;getfield&lt;/code&gt; ) 을 사용하여이를 수행 할 수 있습니다.). 그러나 언어가 동적이거나 (따라서 일부 표현식의 유형은 런타임에 평가 될 때까지 알 수 없음) 또는 해당 개체 모델 또는 유형 시스템이 JVM의 것과 거의 일치하지 않는 경우 대신 &lt;code&gt;invokedynamic&lt;/code&gt; 호출 사이트를 사용해야합니다. Dynalink에서 관리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="2f2f17106f12b2db4361609c9dfa05eb46f32c85" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CompositeView&lt;/code&gt; does not impose a layout policy on its child &lt;code&gt;View&lt;/code&gt;s, it does allow for inseting the child &lt;code&gt;View&lt;/code&gt;s it will contain. The insets can be set by either &lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt;&lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt;&lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동안 &lt;code&gt;CompositeView&lt;/code&gt; 자식에 레이아웃 정책을 부과하지 않는 &lt;code&gt;View&lt;/code&gt; 의, 그것은 아이 inseting 허용 않는 &lt;code&gt;View&lt;/code&gt; 가 포함됩니다들. 인세 &lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt; &lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt; &lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt; &lt;/a&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c42976582ea88cec97c24e4c0d10841777ac466" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;Deque&lt;/code&gt; implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any &lt;code&gt;Deque&lt;/code&gt; implementations that do allow null elements are strongly encouraged</source>
          <target state="translated">하지만 &lt;code&gt;Deque&lt;/code&gt; 와 구현이 엄격하게는 null 요소의 삽입을 금지 할 필요가 없습니다, 그들은 강력하게 그렇게하는 것이 좋습니다. null 요소를 허용 하는 &lt;code&gt;Deque&lt;/code&gt; 구현 사용자 는 강력히 권장됩니다</target>
        </trans-unit>
        <trans-unit id="fb58b702756ba42a1d313a2e0f860c7578277589" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;NamedOperation&lt;/code&gt; can be constructed directly, it is often convenient to use the &lt;a href=&quot;operation#named(java.lang.Object)&quot;&gt;&lt;code&gt;Operation.named(Object)&lt;/code&gt;&lt;/a&gt; factory method instead, e.g.:</source>
          <target state="translated">&lt;code&gt;NamedOperation&lt;/code&gt; 을 직접 구성 할 수 있지만 대신 &lt;a href=&quot;operation#named(java.lang.Object)&quot;&gt; &lt;code&gt;Operation.named(Object)&lt;/code&gt; &lt;/a&gt; 팩토리 메서드 를 사용하는 것이 편리합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="a5eb5618aa0f45c146e1471d0e208b60c8075087" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;NamespaceOperation&lt;/code&gt; can be constructed directly, it is often convenient to use the &lt;a href=&quot;operation#withNamespace(jdk.dynalink.Namespace)&quot;&gt;&lt;code&gt;Operation.withNamespace(Namespace)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;operation#withNamespaces(jdk.dynalink.Namespace...)&quot;&gt;&lt;code&gt;Operation.withNamespaces(Namespace...)&lt;/code&gt;&lt;/a&gt; factory methods instead, e.g.:</source>
          <target state="translated">&lt;code&gt;NamespaceOperation&lt;/code&gt; 을 직접 구성 할 수 있지만 , 대신 &lt;a href=&quot;operation#withNamespace(jdk.dynalink.Namespace)&quot;&gt; &lt;code&gt;Operation.withNamespace(Namespace)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;operation#withNamespaces(jdk.dynalink.Namespace...)&quot;&gt; &lt;code&gt;Operation.withNamespaces(Namespace...)&lt;/code&gt; &lt;/a&gt; 팩토리 메서드 를 사용하는 것이 편리합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="3d6ef8f821513dcce4a530375fb519e3029c0687" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TreePath&lt;/code&gt; is serializable, a &lt;code&gt;
 NotSerializableException&lt;/code&gt; is thrown if any elements of the path are not serializable.</source>
          <target state="translated">&lt;code&gt;TreePath&lt;/code&gt; 는 직렬화 가능 하지만 경로의 요소가 직렬화 가능하지 않으면 &lt;code&gt; NotSerializableException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="51c173ac8703a05aa36fea05d64c73f4930ea483" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd08eb3b81d66f20546d1029c826ea0fbe16bd34" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a60decffcb60cd8818f4e94cb70dfd3ab19008" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a29b609ce06935cf71396d9bc3de52f946081d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8bebbe990bf762b2089ef58b873ffcb3559acbd" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 정렬 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae011e82778ef6bc326d638878e4e4eb7c86dc3" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52357540a609522f143b04a6d7f5344f0cb8965b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 정렬 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5292e16f7d0f56673e81e44acea4610d6162687f" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c116ddf414b394a7666553a5a6b566a1451776ab" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 순서 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다상황의 의미가 허용되는 경우 병렬 파이프 라인에서. 만남의 순서에 일관성이 필요합니다, 당신은 가난한 성능이나 메모리 사용률이 발생하는 경우 &lt;code&gt;limit()&lt;/code&gt; 에 순차 실행 전환 병렬 파이프 라인에서 &lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="07ed1f5d7e24e0c78296347da906a9d60feefd38" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;limit()&lt;/code&gt; 에 순차 실행 전환 병렬 파이프 라인에서 &lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="50f1dd72f901eaef160af7e84d23600d1ebf7971" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 속도가 크게 향상 될 수 있습니다 &lt;code&gt;limit()&lt;/code&gt; 상황의 의미가 허용되는 경우 병렬 파이프 라인에서. 만남의 순서에 일관성이 필요합니다, 당신은 가난한 성능이나 메모리 사용률이 발생하는 경우 &lt;code&gt;limit()&lt;/code&gt; 에 순차 실행 전환 병렬 파이프 라인에서 &lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="e7b022b1174615a655ebcf28b81dbf48a9f1556b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 순서가없는 스트림 소스 (예 : &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 순서 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다상황의 의미가 허용되는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능 또는 메모리 사용률이 저하 된 경우 &lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차적 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b87dc7fad8d14aab16d4ddc4f41ded925891b0e" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd851600c5d344782f73398b78b6e28503994a09" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33a9aba4905d83925c9ee06f4fa960c35c02c78" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0b2ed9d6a481a9b272dda6c65ea3e9ae7c5297" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d731aa21902009fd224b6c3c7d21287ffacde8" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 어떤 이동하도록 구속되는 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예로서 사용하여 &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; ) 또는 함께 오더링 제약 제거 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 의 경우 상당한 성능 향상을 기대할 수있다 &lt;code&gt;skip()&lt;/code&gt; 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 하여 순차 실행 전환 병렬 파이프 라인으로 &lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="8b6aed4201bbc532174a6b1ac759cb47bf878a52" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;skip()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;n&lt;/code&gt; 있기 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 어떤 이동하도록 구속되는 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 하여 순차 실행 전환 병렬 파이프 라인으로 &lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="08e49b292a5f6675c12e6e8084622cb9a1123c41" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;skip()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;n&lt;/code&gt; 있기 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 그냥하지 건너 뛰도록 제한된다&lt;em&gt; n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 하여 순차 실행 전환 병렬 파이프 라인으로 &lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="e1b922a638d8b7b0bf464d0b07da3f9937acce8a" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 어떤 이동하도록 구속되는 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인의 skip () 에서 &lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차적 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f11e1ce2eaeeb9a61aafb14bbaaa04b134c253c4" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536720f4d6e048e3bfc2daf23b8be0d5f28b62ff" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996949649b893c1211f1e5529c0828c15fa967ef" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e8939e26489616f38385fb9a8f6b0914d6faecc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f44ebb750484feed7acd90b248717e6c6a220783" translate="yes" xml:space="preserve">
          <source>While DefaultMutableTreeNode implements the MutableTreeNode interface and will allow you to add in any implementation of MutableTreeNode not all of the methods in DefaultMutableTreeNode will be applicable to all MutableTreeNodes implementations. Especially with some of the enumerations that are provided, using some of these methods assumes the DefaultMutableTreeNode contains only DefaultMutableNode instances. All of the TreeNode/MutableTreeNode methods will behave as defined no matter what implementations are added.</source>
          <target state="translated">DefaultMutableTreeNode가 MutableTreeNode 인터페이스를 구현하고 MutableTreeNode의 모든 구현에 추가 할 수 있도록 허용하지만 DefaultMutableTreeNode의 모든 메소드가 모든 MutableTreeNodes 구현에 적용되는 것은 아닙니다. 특히 제공되는 일부 열거의 경우 이러한 메서드 중 일부를 사용하면 DefaultMutableTreeNode에 DefaultMutableNode 인스턴스 만 포함되어 있다고 가정합니다. 모든 TreeNode / MutableTreeNode 메서드는 추가 된 구현에 관계없이 정의 된대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4167a99521bae55a855564642cb10cb92285c449" translate="yes" xml:space="preserve">
          <source>While JAXP supports validation as a feature of an XML parser, represented by either a &lt;a href=&quot;../parsers/saxparser&quot;&gt;&lt;code&gt;SAXParser&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../parsers/documentbuilder&quot;&gt;&lt;code&gt;DocumentBuilder&lt;/code&gt;&lt;/a&gt; instance, the &lt;code&gt;Validation&lt;/code&gt; API is preferred.</source>
          <target state="translated">JAXP는 &lt;a href=&quot;../parsers/saxparser&quot;&gt; &lt;code&gt;SAXParser&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../parsers/documentbuilder&quot;&gt; &lt;code&gt;DocumentBuilder&lt;/code&gt; &lt;/a&gt; 인스턴스로 표시되는 XML 파서의 기능으로 유효성 검사를 지원하지만 &lt;code&gt;Validation&lt;/code&gt; API가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="a21ea13fd41327eba1978d9dc59ed4e742694b36" translate="yes" xml:space="preserve">
          <source>While XPath expressions select nodes in the XML document, the XPath API allows the selected nodes to be coalesced into one of the following data types:</source>
          <target state="translated">XPath 표현식은 XML 문서에서 노드를 선택하지만 XPath API를 사용하면 선택한 노드를 다음 데이터 유형 중 하나로 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c1d5877bbdead7eaf0421be72e2ef20db6441f" translate="yes" xml:space="preserve">
          <source>While a &lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">&lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; 가 클래스 또는 인터페이스를 나타내는 동안</target>
        </trans-unit>
        <trans-unit id="9231d9bdcc9f4e1959e5ee9d3a56a9d2a170bb99" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;CachedRowSet&lt;/code&gt; object is disconnected, it can be much leaner than a &lt;code&gt;ResultSet&lt;/code&gt; object with the same data. As a result, it can be especially suitable for sending data to a thin client such as a PDA, where it would be inappropriate to use a JDBC driver due to resource limitations or security considerations. Thus, a &lt;code&gt;CachedRowSet&lt;/code&gt; object provides a means to &quot;get rows in&quot; without the need to implement the full JDBC API.</source>
          <target state="translated">&lt;code&gt;CachedRowSet&lt;/code&gt; 객체가 연결이 끊어진 동안 동일한 데이터를 가진 &lt;code&gt;ResultSet&lt;/code&gt; 객체 보다 훨씬 더 가늘어 질 수 있습니다 . 따라서 리소스 제한이나 보안 고려 사항으로 인해 JDBC 드라이버를 사용하는 것이 부적절 할 수있는 PDA와 같은 씬 클라이언트로 데이터를 보내는 데 특히 적합 할 수 있습니다. 따라서 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체는 전체 JDBC API를 구현할 필요없이 &quot;행을 가져 오는&quot;수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30e4f165db1002fe6fbf12ff195d30f7e4cff77b" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;Chronology&lt;/code&gt; object typically uses &lt;code&gt;ChronoField&lt;/code&gt; and is based on an era, year-of-era, month-of-year, day-of-month model of a date, this is not required. A &lt;code&gt;Chronology&lt;/code&gt; instance may represent a totally different kind of calendar system, such as the Mayan.</source>
          <target state="translated">잠시 &lt;code&gt;Chronology&lt;/code&gt; 객체는 일반적으로 사용 &lt;code&gt;ChronoField&lt;/code&gt; 을 시대와 기반으로, 올해의 시대, 달의 년, 날짜의 하루의 달 모델이 필요하지 않습니다. &lt;code&gt;Chronology&lt;/code&gt; 인스턴스는 마야로 캘린더 시스템의 완전히 다른 종류를 나타낼 수있다.</target>
        </trans-unit>
        <trans-unit id="9784eeccfaf1f4a4f0da131846253a9ef6b0027f" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">&lt;code&gt;TypeElement&lt;/code&gt; 가 클래스 또는 인터페이스를 나타내는 동안</target>
        </trans-unit>
        <trans-unit id="b1518d4c45f16c46674f0f206ccd4613201a8ad4" translate="yes" xml:space="preserve">
          <source>While all three of the &lt;code&gt;prototypeCellValue&lt;/code&gt;, &lt;code&gt;fixedCellHeight&lt;/code&gt;, and &lt;code&gt;fixedCellWidth&lt;/code&gt; properties may be modified by this method, &lt;code&gt;PropertyChangeEvent&lt;/code&gt; notifications are only sent when the &lt;code&gt;prototypeCellValue&lt;/code&gt; property changes.</source>
          <target state="translated">세 가지 &lt;code&gt;prototypeCellValue&lt;/code&gt; , &lt;code&gt;fixedCellHeight&lt;/code&gt; 및 &lt;code&gt;fixedCellWidth&lt;/code&gt; 속성은 모두이 메서드로 수정할 수 있지만 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 알림은 &lt;code&gt;prototypeCellValue&lt;/code&gt; 속성이 변경 될 때만 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="19ace92ef3bab3caea4c0ffa2acf86708693deef" translate="yes" xml:space="preserve">
          <source>While an implementation may not recognize all CSS properties within a CSS declaration block, it is expected to provide access to all specified properties in the style sheet through the &lt;code&gt;CSSStyleDeclaration&lt;/code&gt; interface. Furthermore, implementations that support a specific level of CSS should correctly handle CSS shorthand properties for that level. For a further discussion of shorthand properties, see the &lt;code&gt;CSS2Properties&lt;/code&gt; interface.</source>
          <target state="translated">구현시 CSS 선언 블록 내의 모든 CSS 속성을 인식하지 못할 수 있지만 &lt;code&gt;CSSStyleDeclaration&lt;/code&gt; 인터페이스를 통해 스타일 시트의 지정된 모든 속성에 대한 액세스를 제공해야합니다 . 또한 특정 수준의 CSS를 지원하는 구현은 해당 수준의 CSS 속기 속성을 올바르게 처리해야합니다. 속기 속성에 대한 자세한 내용은 &lt;code&gt;CSS2Properties&lt;/code&gt; 인터페이스를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="3b017d1c42ec1554655bf855dc44af27a7a96ca5" translate="yes" xml:space="preserve">
          <source>While applications write to the &lt;code&gt;LoginContext&lt;/code&gt; API, authentication technology providers implement the &lt;code&gt;LoginModule&lt;/code&gt; interface. A &lt;code&gt;Configuration&lt;/code&gt; specifies the LoginModule(s) to be used with a particular login application. Therefore different LoginModules can be plugged in under the application without requiring any modifications to the application itself.</source>
          <target state="translated">응용 프로그램이 &lt;code&gt;LoginContext&lt;/code&gt; API에 쓰는 동안 인증 기술 공급자는 &lt;code&gt;LoginModule&lt;/code&gt; 인터페이스를 . &lt;code&gt;Configuration&lt;/code&gt; 특정한 로그인 응용에 사용되는 LoginModule를 지정한다. 따라서 응용 프로그램 자체를 수정하지 않고도 응용 프로그램에서 다른 LoginModule을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2406ab2abac29e951c9626f9ef877429a290fa9c" translate="yes" xml:space="preserve">
          <source>While building the MBeanInfo, this method calls the customization hooks that make it possible for subclasses to supply their custom descriptions, parameter names, etc...</source>
          <target state="translated">MBeanInfo를 빌드하는 동안이 메소드는 서브 클래스가 사용자 정의 설명, 매개 변수 이름 등을 제공 할 수있게하는 사용자 정의 후크를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="73b5f4ac2141a2818394c1e963ca8d4434b78746" translate="yes" xml:space="preserve">
          <source>While callers may invoke &lt;code&gt;login&lt;/code&gt; directly, the provider may also invoke &lt;code&gt;login&lt;/code&gt; on behalf of callers if it determines that a login must be performed prior to certain operations.</source>
          <target state="translated">발신자가 &lt;code&gt;login&lt;/code&gt; 직접 호출 할 수도 있지만 공급자는 호출 할 수도 있습니다. &lt;code&gt;login&lt;/code&gt; 특정 조작 전에 로그인을 수행해야한다고 결정한 경우 발신자를 대신하여 로그인 을 있습니다.</target>
        </trans-unit>
        <trans-unit id="498a5c4d7f0598c6bbc42679f4696f06bbc47c30" translate="yes" xml:space="preserve">
          <source>While for case 2, it defines 4 URI Entries:</source>
          <target state="translated">사례 2의 경우 4 개의 URI 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="868ad264cb55aef3c8dd9f1593aca303b1f31c60" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if a security manager is installed and the caller does not have a &lt;a href=&quot;privatecredentialpermission&quot;&gt;&lt;code&gt;PrivateCredentialPermission&lt;/code&gt;&lt;/a&gt; to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to the next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">관통 반복하면서 &lt;code&gt;Set&lt;/code&gt; 하는 &lt;code&gt;SecurityException&lt;/code&gt; 가이 보안 관리자가 설치되어있는 경우 발생합니다 호출자가없는 &lt;a href=&quot;privatecredentialpermission&quot;&gt; &lt;code&gt;PrivateCredentialPermission&lt;/code&gt; 의&lt;/a&gt; 액세스 특정 자격 증명을합니다. &lt;code&gt;Iterator&lt;/code&gt; 에서 다음 요소로 그럼에도 불구하고 진보 된 &lt;code&gt;Set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6354a2a3180a9378c7eb02538eb193186e5effba" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if the caller does not have permission to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">관통 반복하면서 &lt;code&gt;Set&lt;/code&gt; 하는 &lt;code&gt;SecurityException&lt;/code&gt; 가이 호출자 액세스 특정 자격 증명에 권한이없는 경우 발생합니다. &lt;code&gt;Iterator&lt;/code&gt; 그럼에도 불구하고 다음의 요소에 처리를 진행시킵니다 &lt;code&gt;Set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fa2ee2232311c188a194a08d7481eaf402f451e" translate="yes" xml:space="preserve">
          <source>While parsing an input source, errors are reported to the application through the error handler (&lt;code&gt;LSParser.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors that can occur while parsing XML, or any other markup, but some common error cases are defined. The types (&lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">입력 소스를 구문 분석하는 동안 오류 핸들러 ( &lt;code&gt;LSParser.domConfig&lt;/code&gt; 의 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt; &quot;매개 변수)를 통해 애플리케이션에 오류가보고됩니다 . 이 사양은 XML 또는 기타 마크 업을 구문 분석하는 동안 발생할 수있는 모든 가능한 오류를 정의하려고하지 않지만 몇 가지 일반적인 오류 사례가 정의되어 있습니다. 이 사양에 정의 된 오류 및 경고 유형 ( &lt;code&gt;DOMError.type&lt;/code&gt; )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86165e5f29fc9b9137f2a5569a7128b787a2ddbb" translate="yes" xml:space="preserve">
          <source>While serializing a document, the parameter &quot;discard-default-content&quot; controls whether or not non-specified data is serialized.</source>
          <target state="translated">문서를 직렬화하는 동안 &quot;discard-default-content&quot;매개 변수는 지정되지 않은 데이터가 직렬화되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="cf4536abd5f3f04b1e2ed476be040c60ab02acb7" translate="yes" xml:space="preserve">
          <source>While serializing, errors and warnings are reported to the application through the error handler (&lt;code&gt;LSSerializer.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors and warnings that can occur while serializing a DOM node, but some common error and warning cases are defined. The types ( &lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">직렬화하는 동안 오류 및 경고는 오류 처리기 ( &lt;code&gt;LSSerializer.domConfig&lt;/code&gt; 의 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt; &quot;매개 변수)를 통해 응용 프로그램에보고됩니다 . 이 사양은 DOM 노드를 직렬화하는 동안 발생할 수있는 모든 가능한 오류 및 경고를 정의하려고하지 않지만 몇 가지 일반적인 오류 및 경고 사례가 정의되어 있습니다. 이 사양에 정의 된 오류 및 경고 유형 ( &lt;code&gt;DOMError.type&lt;/code&gt; )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddbca553bfbbeff28515b4164ea76df1af2bbd56" translate="yes" xml:space="preserve">
          <source>While some programs will choose to dedicate a thread to removing reference objects from one or more queues and processing them, this is by no means necessary. A tactic that often works well is to examine a reference queue in the course of performing some other fairly-frequent action. For example, a hashtable that uses weak references to implement weak keys could poll its reference queue each time the table is accessed. This is how the &lt;a href=&quot;../../util/weakhashmap&quot;&gt;&lt;code&gt;WeakHashMap&lt;/code&gt;&lt;/a&gt; class works. Because the &lt;a href=&quot;referencequeue#poll()&quot;&gt;&lt;code&gt;ReferenceQueue.poll&lt;/code&gt;&lt;/a&gt; method simply checks an internal data structure, this check will add little overhead to the hashtable access methods.</source>
          <target state="translated">일부 프로그램은 하나 이상의 대기열에서 참조 객체를 제거하고 처리하는 데 전용 스레드를 선택하지만, 이것이 반드시 필요한 것은 아닙니다. 종종 잘 작동하는 전술은 다른 상당히 빈번한 작업을 수행하는 과정에서 참조 대기열을 검사하는 것입니다. 예를 들어 약한 참조를 사용하여 약한 키를 구현하는 해시 테이블은 테이블에 액세스 할 때마다 참조 대기열을 폴링 할 수 있습니다. 이것이 &lt;a href=&quot;../../util/weakhashmap&quot;&gt; &lt;code&gt;WeakHashMap&lt;/code&gt; &lt;/a&gt; 클래스가 작동하는 방식입니다. 때문에 &lt;a href=&quot;referencequeue#poll()&quot;&gt; &lt;code&gt;ReferenceQueue.poll&lt;/code&gt; 의&lt;/a&gt; 방법은 단순히 내부 데이터 구조를 확인하여,이 검사는 해시 테이블 액세스 방법에 약간의 오버 헤드 추가한다.</target>
        </trans-unit>
        <trans-unit id="c239e1b59a3047897d29f5e117079370e9edd962" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often obtained by first reading another abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code. If no tables are specified either in the stream or in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt;, then the stream is presumed to use the &quot;standard&quot; visually lossless tables. See &lt;a href=&quot;jpegqtable&quot;&gt;&lt;code&gt;JPEGQTable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jpeghuffmantable&quot;&gt;&lt;code&gt;JPEGHuffmanTable&lt;/code&gt;&lt;/a&gt; for more information on the default tables.</source>
          <target state="translated">축약 된 스트림에 대한 테이블은 종종 테이블 만 포함하는 다른 축약 된 스트림을 먼저 읽음으로써 얻을 수 있지만 일부 응용 프로그램에서는 테이블이 미리 고정되어 있습니다. 이 클래스는 클라이언트 코드에서 직접 테이블을 지정할 수 있습니다. 스트림 또는 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 테이블이 지정되어 있지 않은 경우 , 스트림은 &quot;표준&quot;시각적 무손실 테이블을 사용하는 것으로 간주됩니다. 참조 &lt;a href=&quot;jpegqtable&quot;&gt; &lt;code&gt;JPEGQTable&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;jpeghuffmantable&quot;&gt; &lt;code&gt;JPEGHuffmanTable&lt;/code&gt; &lt;/a&gt;기본 테이블에 대한 자세한 내용 JPEGHuffmanTable 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b216501bc1079107fcb46b023f11ebfbbaf13fc" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often specified by first writing an abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code.</source>
          <target state="translated">축약 된 스트림에 대한 테이블은 종종 테이블 만 포함 된 축약 된 스트림을 먼저 작성하여 지정되지만 일부 응용 프로그램에서는 테이블이 미리 고정되어 있습니다. 이 클래스는 클라이언트 코드에서 직접 테이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55e7baa234a92f09d11651aeeb34c78f17b723e" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;Collection&lt;/code&gt; interface adds no stipulations to the general contract for the &lt;code&gt;Object.equals&lt;/code&gt;, programmers who implement the &lt;code&gt;Collection&lt;/code&gt; interface &quot;directly&quot; (in other words, create a class that is a &lt;code&gt;Collection&lt;/code&gt; but is not a &lt;code&gt;Set&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;) must exercise care if they choose to override the &lt;code&gt;Object.equals&lt;/code&gt;. It is not necessary to do so, and the simplest course of action is to rely on &lt;code&gt;Object&lt;/code&gt;'s implementation, but the implementor may wish to implement a &quot;value comparison&quot; in place of the default &quot;reference comparison.&quot; (The &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; interfaces mandate such value comparisons.)</source>
          <target state="translated">그동안 &lt;code&gt;Collection&lt;/code&gt; 인터페이스가의 일반 규약에 조항을 추가하지 &lt;code&gt;Object.equals&lt;/code&gt; , 프로그래머는 누가 구현하는 &lt;code&gt;Collection&lt;/code&gt; (A 클래스 인 클래스 생성, 즉 인터페이스 &quot;직접&quot; &lt;code&gt;Collection&lt;/code&gt; 하지만없는 &lt;code&gt;Set&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 주의를 기울여야해야합니다) 그들이 &lt;code&gt;Object.equals&lt;/code&gt; 를 재정의하기로 선택한 경우 . 그렇게 할 필요는 없으며 가장 간단한 조치는 &lt;code&gt;Object&lt;/code&gt; 구현 에 의존하는 것이지만 구현자는 기본 &quot;참조 비교&quot;대신 &quot;값 비교&quot;를 구현할 수 있습니다. ( &lt;code&gt;List&lt;/code&gt; 과 &lt;code&gt;Set&lt;/code&gt; 인터페이스는 이러한 값 비교를 요구합니다.)</target>
        </trans-unit>
        <trans-unit id="f5d22b4fafaee2e3b5d5f3ee0154553c12123ed3" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;Externalizable&lt;/code&gt; interface extends &lt;code&gt;
 Serializable&lt;/code&gt;, the three methods and one field above are &lt;em&gt;not&lt;/em&gt; used for externalizable classes.</source>
          <target state="translated">&lt;code&gt;Externalizable&lt;/code&gt; 인터페이스는 &lt;code&gt; Serializable&lt;/code&gt; 을 확장 하지만 위의 세 가지 메서드와 하나의 필드는 외부화 가능한 클래스에 사용 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b34ed17b895b7570e58dbe128c1061764f2836" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;JOptionPane&lt;/code&gt; class may appear complex because of the large number of methods, almost all uses of this class are one-line calls to one of the static &lt;code&gt;showXxxDialog&lt;/code&gt; methods shown below:</source>
          <target state="translated">&lt;code&gt;JOptionPane&lt;/code&gt; 클래스는 많은 수의 메서드로 인해 복잡해 보일 수 있지만 이 클래스의 거의 모든 용도는 아래 표시된 정적 &lt;code&gt;showXxxDialog&lt;/code&gt; 메서드 중 하나에 대한 한 줄 호출입니다 .</target>
        </trans-unit>
        <trans-unit id="f05e95138eee0f8263aaeecdb23d34bbf507f801" translate="yes" xml:space="preserve">
          <source>While the child view is being accessed a read lock is acquired on the associated document so that the model is stable while being accessed.</source>
          <target state="translated">하위 뷰에 액세스하는 동안 연결된 문서에 대한 읽기 잠금이 획득되어 모델이 액세스되는 동안 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="18005f1749c0380a1dd553fb852a3af3b6131165" translate="yes" xml:space="preserve">
          <source>While the drag and drop implementation calls &lt;code&gt;canImport&lt;/code&gt; to determine the suitability of a transfer before calling this method, the implementation of paste does not. As such, it cannot be assumed that the transfer is acceptable upon a call to this method for paste. It is recommended that &lt;code&gt;canImport&lt;/code&gt; be explicitly called to cover this case.</source>
          <target state="translated">끌어서 놓기 구현에서는 &lt;code&gt;canImport&lt;/code&gt; 를 호출하여이 메서드를 호출하기 전에 전송의 적합성을 결정하지만 붙여 넣기 구현에서는 그렇지 않습니다. 따라서 붙여 넣기를 위해이 메서드를 호출하면 전송이 허용된다고 가정 할 수 없습니다. 이 경우를 처리하기 위해 &lt;code&gt;canImport&lt;/code&gt; 를 명시 적으로 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4efe8fc428299599c701c1333f6be7122c0cee74" translate="yes" xml:space="preserve">
          <source>While the hook is being called, the new &lt;code&gt;ConstantCallSite&lt;/code&gt; object is in a partially constructed state. In this state, a call to &lt;code&gt;getTarget&lt;/code&gt;, or any other attempt to use the target, will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;. It is legal at all times to obtain the call site's type using the &lt;code&gt;type&lt;/code&gt; method.</source>
          <target state="translated">후크가 호출되는 동안 새 &lt;code&gt;ConstantCallSite&lt;/code&gt; 오브젝트는 부분적으로 구성된 상태입니다. 이 상태에서 &lt;code&gt;getTarget&lt;/code&gt; 에 대한 호출 또는 다른 대상을 사용하려고하면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생 합니다 . &lt;code&gt;type&lt;/code&gt; 메소드를 사용하여 콜 사이트의 유형을 얻는 것이 항상 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="e64de2c787d87b6255db69fb316860954d89cac4" translate="yes" xml:space="preserve">
          <source>While the scoping mechanism for &lt;code&gt;synchronized&lt;/code&gt; methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the &lt;code&gt;Lock&lt;/code&gt; interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</source>
          <target state="translated">&lt;code&gt;synchronized&lt;/code&gt; 메소드 및 명령문 의 범위 지정 메커니즘 으로 모니터 잠금을 사용하여 프로그래밍하는 것이 훨씬 쉬워지고 잠금과 관련된 많은 일반적인 프로그래밍 오류를 피할 수 있지만보다 유연한 방식으로 잠금으로 작업해야하는 경우가 있습니다. 예를 들어, 동시에 액세스되는 데이터 구조를 순회하기위한 일부 알고리즘에는 &quot;Hand-over-hand&quot;또는 &quot;chain locking&quot;을 사용해야합니다. 노드 A, 노드 B의 잠금을 획득 한 다음 A를 해제하고 C를 획득 한 다음 B를 해제하십시오. D 등을 얻습니다. &lt;code&gt;Lock&lt;/code&gt; 구현 인터페이스의 이 다른 범위에서 획득 및 해제 될 수있게하고, 임의의 순서로 다수의 잠금이 획득 및 해제 될 수있게함으로써 이러한 기술의 사용을 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="e4da0d73a5a72455f5512b34b17d391abf383ff0" translate="yes" xml:space="preserve">
          <source>While the specification of this method in the &lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;superclass&lt;/a&gt; recommends that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown if &lt;code&gt;len&lt;/code&gt; is negative or &lt;code&gt;off + len&lt;/code&gt; is negative, the implementation in this class does not throw such an exception in these cases but instead simply writes no characters.</source>
          <target state="translated">&lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;수퍼 클래스&lt;/a&gt; 에서이 메서드의 사양은 &lt;code&gt;len&lt;/code&gt; 이 음수이거나 &lt;code&gt;off + len&lt;/code&gt; 이 음수 이면 &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; &lt;/a&gt; 이 throw되도록 권장하지만 이 클래스의 구현은 이러한 경우에 이러한 예외를 throw하지 않고 대신 단순히 문자를 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fa594a26798c1bce1231654fe91cf1056a98394" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;append(char)&lt;/code&gt;, &lt;code&gt;
 append(CharSequence)&lt;/code&gt;, &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt;, &lt;code&gt;flush()&lt;/code&gt;, &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;write(char[])&lt;/code&gt;, and &lt;code&gt;write(char[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;append(char)&lt;/code&gt; , &lt;code&gt; append(CharSequence)&lt;/code&gt; , &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt; , &lt;code&gt;flush()&lt;/code&gt; , &lt;code&gt;write(int)&lt;/code&gt; , &lt;code&gt;write(char[])&lt;/code&gt; 및 &lt;code&gt;write(char[], int, int)&lt;/code&gt; 메서드는 아무것도하지 않습니다. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d7b18e67ae96f95fb89082471b6693cb13e2e148" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;available()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(byte[])&lt;/code&gt;, &lt;code&gt;read(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readAllBytes()&lt;/code&gt;, &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readNBytes(int)&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, &lt;code&gt;skipNBytes(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;available()&lt;/code&gt; , &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;read(byte[])&lt;/code&gt; , &lt;code&gt;read(byte[], int, int)&lt;/code&gt; , &lt;code&gt;readAllBytes()&lt;/code&gt; , &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt; , &lt;code&gt;readNBytes(int)&lt;/code&gt; , &lt;code&gt;skip(long)&lt;/code&gt; , &lt;code&gt;skipNBytes(long)&lt;/code&gt; 및 &lt;code&gt;transferTo()&lt;/code&gt; 메서드는 모두 스트림의 끝에 도달 한 것처럼 동작합니다. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9f27c207d45817eb6f9a257c7c530eb9bfcf4665" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;available()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(byte[])&lt;/code&gt;, &lt;code&gt;read(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readAllBytes()&lt;/code&gt;, &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readNBytes(int)&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;available()&lt;/code&gt; , &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;read(byte[])&lt;/code&gt; , &lt;code&gt;read(byte[], int, int)&lt;/code&gt; , &lt;code&gt;readAllBytes()&lt;/code&gt; , &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt; , &lt;code&gt;readNBytes(int)&lt;/code&gt; , &lt;code&gt;skip(long)&lt;/code&gt; 및 &lt;code&gt;transferTo()&lt;/code&gt; 메서드는 모두 스트림의 끝에 도달 한 것처럼 동작합니다. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="915add191b3db03099891be3aeb321c9cad7cf68" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(char[])&lt;/code&gt;, &lt;code&gt;read(char[], int, int)&lt;/code&gt;, &lt;code&gt;read(CharBuffer)&lt;/code&gt;, &lt;code&gt;
 ready()&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;read(char[])&lt;/code&gt; , &lt;code&gt;read(char[], int, int)&lt;/code&gt; , &lt;code&gt;read(CharBuffer)&lt;/code&gt; , &lt;code&gt; ready()&lt;/code&gt; , &lt;code&gt;skip(long)&lt;/code&gt; 및 &lt;code&gt;transferTo()&lt;/code&gt; 메서드는 모두 작동합니다. 마치 스트림의 끝에 도달 한 것처럼. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="354a3e678c0afc6d9c995cad19836af2c60e94bf" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(char[])&lt;/code&gt;, &lt;code&gt;read(char[], int, int)&lt;/code&gt;, &lt;code&gt;read(Charbuffer)&lt;/code&gt;, &lt;code&gt;
 ready()&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;read(char[])&lt;/code&gt; , &lt;code&gt;read(char[], int, int)&lt;/code&gt; , &lt;code&gt;read(Charbuffer)&lt;/code&gt; , &lt;code&gt; ready()&lt;/code&gt; , &lt;code&gt;skip(long)&lt;/code&gt; 및 &lt;code&gt;transferTo()&lt;/code&gt; 메서드는 모두 작동합니다. 마치 스트림의 끝에 도달 한 것처럼. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="38e5439eae991a55c97ddfd38870798ef229cbcd" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;
 write(byte[])&lt;/code&gt;, and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;
 IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;write(int)&lt;/code&gt; , &lt;code&gt; write(byte[])&lt;/code&gt; 및 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 메서드는 아무 작업도 수행하지 않습니다. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt; IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="dc1904d24dfdb2dc325b56134c9dce9b4ddaba55" translate="yes" xml:space="preserve">
          <source>While the unit of time of the return value is milliseconds, the granularity of the value depends on the underlying file system and may be larger. For example, some file systems use time stamps in units of seconds.</source>
          <target state="translated">반환 값의 시간 단위는 밀리 초이지만 값의 단위는 기본 파일 시스템에 따라 다르며 더 클 수 있습니다. 예를 들어, 일부 파일 시스템은 초 단위로 타임 스탬프를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="71a236fbeded33e61e30714b2af91dd5dfd1beff" translate="yes" xml:space="preserve">
          <source>While this class has been part of swing for a while now, it is public as of 1.4.</source>
          <target state="translated">이 클래스는 한동안 스윙의 일부 였지만 1.4에서 공개되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ebba50ef7f7692c7039eeb694af9a571417cf59" translate="yes" xml:space="preserve">
          <source>While this class inherits from &lt;a href=&quot;threadpoolexecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using &lt;code&gt;corePoolSize&lt;/code&gt; threads and an unbounded queue, adjustments to &lt;code&gt;maximumPoolSize&lt;/code&gt; have no useful effect. Additionally, it is almost never a good idea to set &lt;code&gt;corePoolSize&lt;/code&gt; to zero or use &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; because this may leave the pool without threads to handle tasks once they become eligible to run.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;threadpoolexecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; 로부터 상속 받지만 상속 된 튜닝 방법 중 일부는 유용하지 않습니다. 특히 &lt;code&gt;corePoolSize&lt;/code&gt; 스레드와 무제한 큐를 사용하여 고정 크기 풀 역할을하므로 &lt;code&gt;maximumPoolSize&lt;/code&gt; 를 조정 해도 아무런 효과가 없습니다. 또한 &lt;code&gt;corePoolSize&lt;/code&gt; 를 0 으로 설정 하거나 &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; 을 사용 하는 것은 좋은 아이디어가 아닙니다. 스레드가없는 풀에서 작업을 실행할 수있게되면 작업을 처리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="37f43590d9884fbad9cdec8f02f0705df36bced7" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;
 Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">이 인터페이스 메서드가 &lt;code&gt; Exception&lt;/code&gt; 을 throw하도록 선언되었지만 구현자는 보다 구체적인 예외를 throw하거나 닫기 작업이 실패 할 수없는 경우 예외를 전혀 throw하지 않도록 &lt;code&gt;close&lt;/code&gt; 메서드 의 구체적인 구현을 선언 &lt;em&gt;하는&lt;/em&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1c294c7b4d4f86f3493751e198f59f458ef4183c" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">이 인터페이스 메소드가 &lt;code&gt;Exception&lt;/code&gt; 을 발생 시키도록 선언되어 있지만 , 구현자는 &lt;code&gt;close&lt;/code&gt; 의 구체적인 구현을 선언 할 것을 &lt;em&gt;강력히&lt;/em&gt; 권장합니다. 더 구체적인 예외를 던져, 또는 가까운 작업이 실패 할 수없는 경우 전혀 예외를 던지지하는 방법.</target>
        </trans-unit>
        <trans-unit id="5aafec2ecc872a5e693872afd5344f871ab06e7e" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes.</source>
          <target state="translated">이것은 공용 메서드이지만 일반적으로 &lt;code&gt;JFormattedTextField&lt;/code&gt; 의 서브 클래 서에게만 유용합니다 . &lt;code&gt;JFormattedTextField&lt;/code&gt; 는 값이 변경되거나 내부 상태가 변경 될 때 적절한 시간에이 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="79111a912067f71a2c429865902e2e2dfdb6357a" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes. You will only need to invoke this yourself if you are subclassing &lt;code&gt;JFormattedTextField&lt;/code&gt; and installing/uninstalling &lt;code&gt;AbstractFormatter&lt;/code&gt; at a different time than &lt;code&gt;JFormattedTextField&lt;/code&gt; does.</source>
          <target state="translated">이것은 공용 메서드이지만 일반적으로 &lt;code&gt;JFormattedTextField&lt;/code&gt; 의 서브 클래 서에게만 유용합니다 . &lt;code&gt;JFormattedTextField&lt;/code&gt; 는 값이 변경되거나 내부 상태가 변경 될 때 적절한 시간에이 메소드를 호출합니다. 당신은 당신이 서브 클래스 화하는 경우이 직접 호출해야합니다 &lt;code&gt;JFormattedTextField&lt;/code&gt; 제거 / 및 설치 &lt;code&gt;AbstractFormatter&lt;/code&gt; 보다 다른 시간 &lt;code&gt;JFormattedTextField&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8962e33fe4ae692b6f0669c0b0060997d23406a" translate="yes" xml:space="preserve">
          <source>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</source>
          <target state="translated">이는 루프에서 누계를 단순히 변경하는 것보다 집계를 수행하는 데있어 가장 간단한 방법으로 보일 수 있지만 추가 동기화가 필요하지 않고 데이터 경쟁의 위험이 크게 줄어드는 대신 축소 작업이보다 정교하게 병렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="a47a2652b0c502dd1c763501db1290a29367490b" translate="yes" xml:space="preserve">
          <source>While this method is public, it should only be invoked by the &lt;code&gt;UIManager&lt;/code&gt; when the look and feel is set as the current look and feel and after &lt;code&gt;initialize&lt;/code&gt; has been invoked.</source>
          <target state="translated">이 메서드는 공용이지만 &lt;code&gt;UIManager&lt;/code&gt; 이 현재 룩앤필로 설정되고 &lt;code&gt;initialize&lt;/code&gt; 가 호출 된 후 UIManager에 의해서만 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="80a95185dab9cb4d4601e61790a61c53f8e58816" translate="yes" xml:space="preserve">
          <source>While this method returns an array of &lt;code&gt;
 Constructor&amp;lt;T&amp;gt;&lt;/code&gt; objects (that is an array of constructors from this class), the return type of this method is &lt;code&gt;
 Constructor&amp;lt;?&amp;gt;[]&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt;&lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt; as might be expected. This less informative return type is necessary since after being returned from this method, the array could be modified to hold &lt;code&gt;Constructor&lt;/code&gt; objects for different classes, which would violate the type guarantees of &lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 방법은 어레이 반환 동안 &lt;code&gt; Constructor&amp;lt;T&amp;gt;&lt;/code&gt; (이 클래스에서 생성자의 배열이다) 개체,이 메소드의 반환 타입이 &lt;code&gt; Constructor&amp;lt;?&amp;gt;[]&lt;/code&gt; 및 &lt;em&gt;하지 &lt;/em&gt; &lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt; 예상 할 수있다. 이 메서드에서 반환 된 후 배열 은 &lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt; 의 형식 보장을 위반하는 다른 클래스에 대한 &lt;code&gt;Constructor&lt;/code&gt; 개체 를 보유하도록 수정 될 수 있기 때문에 덜 유익한 반환 형식이 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="c581298e75ef5bf15df9b06bf2c664ea73c5c346" translate="yes" xml:space="preserve">
          <source>While writing an object via writeUnshared does not in itself guarantee a unique reference to the object when it is deserialized, it allows a single object to be defined multiple times in a stream, so that multiple calls to readUnshared by the receiver will not conflict. Note that the rules described above only apply to the base-level object written with writeUnshared, and not to any transitively referenced sub-objects in the object graph to be serialized.</source>
          <target state="translated">writeUnshared를 통해 객체를 작성한다고해서 역 직렬화 될 때 객체에 대한 고유 한 참조가 보장되는 것은 아니지만 단일 객체를 스트림에서 여러 번 정의 할 수 있으므로 수신자가 readUnshared를 여러 번 호출해도 충돌하지 않습니다. 위에서 설명한 규칙은 writeUnshared로 작성된 기본 레벨 오브젝트에만 적용되며 직렬화 할 오브젝트 그래프의 전 이적으로 참조 된 하위 오브젝트에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b0d3c4f0480a5e74d5383ac9ba2edc90d882c39" translate="yes" xml:space="preserve">
          <source>WhileLoopTree</source>
          <target state="translated">WhileLoopTree</target>
        </trans-unit>
        <trans-unit id="5da2d68669a03b947051233558b6ce56e6780f0a" translate="yes" xml:space="preserve">
          <source>White_Space</source>
          <target state="translated">White_Space</target>
        </trans-unit>
        <trans-unit id="325016380fb9842b99430cbb0b7cb06becabcdfe" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed on either side of ',', ';', '=', and '+'. Such whitespace is accepted but not generated by this code, and is ignored when comparing names.</source>
          <target state="translated">',', ';', '='및 '+'의 양쪽에 공백이 허용됩니다. 이러한 공백은 허용되지만이 코드에서 생성되지 않으며 이름을 비교할 때 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ef5e18e6403c342fcf6ad4db4c278abb2cb9d38" translate="yes" xml:space="preserve">
          <source>Whitespace is not significant in the above regular expressions.</source>
          <target state="translated">위 정규 표현식에서 공백은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d620fb7a85a0616f4a4e6e9dda029e04472a323" translate="yes" xml:space="preserve">
          <source>Wide Area Information Server (WAIS) protocol.</source>
          <target state="translated">WAIS (Wide Area Information Server) 프로토콜.</target>
        </trans-unit>
        <trans-unit id="4088f5317f57ea6f119849410abea3f8143240d0" translate="yes" xml:space="preserve">
          <source>Widget for user to</source>
          <target state="translated">사용자를위한 위젯</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="969d00f2cb9efe3539d44d8c60c74f5ad9d4d231" translate="yes" xml:space="preserve">
          <source>Width in pixels of the region of image data that this SampleModel describes.</source>
          <target state="translated">이 SampleModel이 설명하는 이미지 데이터 영역의 너비 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="ad438ebb7fecc02d85771ba7a5e164704291d2aa" translate="yes" xml:space="preserve">
          <source>Width margin between each column</source>
          <target state="translated">각 열 사이의 너비 여백</target>
        </trans-unit>
        <trans-unit id="2b1391aceba26f92ebfa3692913a873cad2e88d4" translate="yes" xml:space="preserve">
          <source>Width of border around image.</source>
          <target state="translated">이미지 주변의 테두리 너비입니다.</target>
        </trans-unit>
        <trans-unit id="1962f060f9fe9059e9a8a6c80aa4a55652760749" translate="yes" xml:space="preserve">
          <source>Width of border around image. See the border attribute definition in HTML 4.0. This attribute is deprecated in HTML 4.0.</source>
          <target state="translated">이미지 주변의 테두리 너비입니다. HTML 4.0의 테두리 속성 정의를 참조하십시오. 이 속성은 HTML 4.0에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25d4e6ae97de9d8e0668c4d723b13f4d0fb48f3e" translate="yes" xml:space="preserve">
          <source>Width of border around the object.</source>
          <target state="translated">개체 주변의 테두리 너비입니다.</target>
        </trans-unit>
        <trans-unit id="da0c6f8902b918d8abe553b58cfd7895baa25253" translate="yes" xml:space="preserve">
          <source>Width of border around the object. See the border attribute definition in HTML 4.0. This attribute is deprecated in HTML 4.0.</source>
          <target state="translated">개체 주변의 테두리 너비입니다. HTML 4.0의 테두리 속성 정의를 참조하십시오. 이 속성은 HTML 4.0에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0e3d6c9d2f09610830e5f522f7dc3562cd09301" translate="yes" xml:space="preserve">
          <source>Width of control (in characters).</source>
          <target state="translated">제어 폭 (문자).</target>
        </trans-unit>
        <trans-unit id="1fff79d676a28a0dd3d706794781c8d39249359f" translate="yes" xml:space="preserve">
          <source>Width of control (in characters). See the cols attribute definition in HTML 4.0.</source>
          <target state="translated">제어 폭 (문자). HTML 4.0의 cols 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="50794f4688ae96bdb4341321c3ffa61a405c19eb" translate="yes" xml:space="preserve">
          <source>Width of the back buffers</source>
          <target state="translated">백 버퍼의 너비</target>
        </trans-unit>
        <trans-unit id="9c249f6d47c523ac145af2ace67f2b7577b5b942" translate="yes" xml:space="preserve">
          <source>Width or height of the divider based on orientation &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; adds two to this.</source>
          <target state="translated">방향에 따른 구분선의 너비 또는 높이 &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; 는 여기에 2 개를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c3145705b3544273fd612b777459ce0a3125581a" translate="yes" xml:space="preserve">
          <source>WildcardTree</source>
          <target state="translated">WildcardTree</target>
        </trans-unit>
        <trans-unit id="d5208bbe059aa1046c3f08361ea1e178ca24d291" translate="yes" xml:space="preserve">
          <source>WildcardType</source>
          <target state="translated">WildcardType</target>
        </trans-unit>
        <trans-unit id="66c44a9ca081e2d89075ec9d49d2689c74584a8a" translate="yes" xml:space="preserve">
          <source>WildcardType represents a wildcard type expression, such as &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;? extends Number&lt;/code&gt;, or &lt;code&gt;? super Integer&lt;/code&gt;.</source>
          <target state="translated">와일드 카드 유형은 &lt;code&gt;?&lt;/code&gt; 와 같은 와일드 카드 유형 표현식을 나타냅니다 . , &lt;code&gt;? extends Number&lt;/code&gt; 또는 &lt;code&gt;? super Integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce867c4c796e6dbe1d3e38766feb789822009ee1" translate="yes" xml:space="preserve">
          <source>WildcardType.getExtendsBound()</source>
          <target state="translated">WildcardType.getExtendsBound()</target>
        </trans-unit>
        <trans-unit id="330bde92db69c2198109194787e6c21b7478f2c0" translate="yes" xml:space="preserve">
          <source>WildcardType.getLowerBounds()</source>
          <target state="translated">WildcardType.getLowerBounds()</target>
        </trans-unit>
        <trans-unit id="f81da7284909bf43711682454467244f68db18a0" translate="yes" xml:space="preserve">
          <source>WildcardType.getSuperBound()</source>
          <target state="translated">WildcardType.getSuperBound()</target>
        </trans-unit>
        <trans-unit id="97172c5abf520854245e039ae23bd4e64bc5422f" translate="yes" xml:space="preserve">
          <source>WildcardType.getUpperBounds()</source>
          <target state="translated">WildcardType.getUpperBounds()</target>
        </trans-unit>
        <trans-unit id="521d06dd779ba79ee4cea678dbe14d70dbe38387" translate="yes" xml:space="preserve">
          <source>Will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;java.awt.Image&lt;/code&gt; is not visible, the &lt;code&gt;java.desktop&lt;/code&gt; module is not loaded, or the &lt;code&gt;java.desktop&lt;/code&gt; module is not in the run-time image.</source>
          <target state="translated">수 있을까요 &lt;code&gt;null&lt;/code&gt; 의 경우 &lt;code&gt;java.awt.Image&lt;/code&gt; 의가 표시되지는 &lt;code&gt;java.desktop&lt;/code&gt; 의 모듈이 장착되지 않았거나 &lt;code&gt;java.desktop&lt;/code&gt; 의 모듈은 런타임 이미지에 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d33509e2ec308e6546857b8da6aba57cee35ab90" translate="yes" xml:space="preserve">
          <source>Will be called to see whether or not this cookie should be accepted.</source>
          <target state="translated">이 쿠키의 수락 여부를 확인하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="37fa7a262702fe582d3a1dccfa6ad0f9944b59d4" translate="yes" xml:space="preserve">
          <source>Will check the role according to its corresponding role definition provided in relation's relation type</source>
          <target state="translated">관계의 관계 유형에 제공된 해당 역할 정의에 따라 역할을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6ccf06bf2935ecc384eb6df2769fb29a28f7bd2b" translate="yes" xml:space="preserve">
          <source>Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern &quot;{1},{2}&quot; is used with the string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;. When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.</source>
          <target state="translated">구문 분석의 일부가 모호한 경우 항상 일치하는 항목을 찾을 수 없습니다. 예를 들어, 패턴 &quot;{1}, {2}&quot;를 문자열 인수 { &quot;a, b&quot;, &quot;c&quot;}와 함께 사용하면 &quot;a, b, c&quot;로 형식화됩니다. 결과가 구문 분석되면 { &quot;a&quot;, &quot;b, c&quot;}가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c58deb92d1c5c729de051dba7b43a35ac3101b21" translate="yes" xml:space="preserve">
          <source>Will not see uncommitted data (make &quot;dirty&quot; reads).</source>
          <target state="translated">커밋되지 않은 데이터를 볼 수 없습니다 ( &quot;더티 읽기&quot;).</target>
        </trans-unit>
        <trans-unit id="d669a272be58163914a204bccea56c09fa69e531" translate="yes" xml:space="preserve">
          <source>Will send a notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not).</source>
          <target state="translated">알림을 보냅니다 (관계가 MBean인지 여부에 따라 RELATION_BASIC_UPDATE 또는 RELATION_MBEAN_UPDATE 유형의 관계 알림).</target>
        </trans-unit>
        <trans-unit id="c456f440fcf296338c58bf917ef98c5c5d7bac84" translate="yes" xml:space="preserve">
          <source>Will send one notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not) per updated role.</source>
          <target state="translated">업데이트 된 역할마다 하나의 알림 (관계가 MBean인지 여부에 따라 RELATION_BASIC_UPDATE 또는 RELATION_MBEAN_UPDATE 유형의 관계 알림)을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="af60309eed9f0f92d76603dc55ac020d8599207d" translate="yes" xml:space="preserve">
          <source>Will start editing for node if there is a &lt;code&gt;cellEditor&lt;/code&gt; and &lt;code&gt;shouldSelectCell&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cellEditor&lt;/code&gt; 가 있고 &lt;code&gt;shouldSelectCell&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 노드 편집을 시작 합니다 .</target>
        </trans-unit>
        <trans-unit id="c95d75c28c35065fc1c57b0e876887193f122021" translate="yes" xml:space="preserve">
          <source>WinListener</source>
          <target state="translated">WinListener</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="5084a061070a3f1aa4d1ecab3a00df323a3b610e" translate="yes" xml:space="preserve">
          <source>Window events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">창 이벤트는 &lt;code&gt;enableEvents&lt;/code&gt; 를 통해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="652b21379200b4ccc460b4492fe0d5374614171a" translate="yes" xml:space="preserve">
          <source>Window focus events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">창 초점 이벤트는 &lt;code&gt;enableEvents&lt;/code&gt; 를 통해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="8ac26c71e069b6eaa7e969b40aec9f9b5620310d" translate="yes" xml:space="preserve">
          <source>Window.AccessibleAWTWindow</source>
          <target state="translated">Window.AccessibleAWTWindow</target>
        </trans-unit>
        <trans-unit id="507611730a02b402edd6e7ba76a6fcebba9f788e" translate="yes" xml:space="preserve">
          <source>Window.Type</source>
          <target state="translated">Window.Type</target>
        </trans-unit>
        <trans-unit id="5dca9b99152803aee06162ae5e180ed80d355a7c" translate="yes" xml:space="preserve">
          <source>WindowAdapter</source>
          <target state="translated">WindowAdapter</target>
        </trans-unit>
        <trans-unit id="d30877c43152fe36a3fd859538a40a5cdaf9bfe2" translate="yes" xml:space="preserve">
          <source>WindowConstants</source>
          <target state="translated">WindowConstants</target>
        </trans-unit>
        <trans-unit id="506bdfc6c0c9e73aacc009ccc59240f421dee55e" translate="yes" xml:space="preserve">
          <source>WindowEvent</source>
          <target state="translated">WindowEvent</target>
        </trans-unit>
        <trans-unit id="389aeec541bb01caf058a1c61a1a55c203773d3c" translate="yes" xml:space="preserve">
          <source>WindowFocusListener</source>
          <target state="translated">WindowFocusListener</target>
        </trans-unit>
        <trans-unit id="d1e4bbe2f756a9e07443c61cb2a25527b3f01627" translate="yes" xml:space="preserve">
          <source>WindowListener</source>
          <target state="translated">WindowListener</target>
        </trans-unit>
        <trans-unit id="36d800c05ccdf96a77f664405b24b1d515a7dcaa" translate="yes" xml:space="preserve">
          <source>WindowStateListener</source>
          <target state="translated">WindowStateListener</target>
        </trans-unit>
        <trans-unit id="b23f002c02bd817e7699352ab74ddf1956672a1c" translate="yes" xml:space="preserve">
          <source>Windows NT chooses to represent users, groups and realms (or domains) with not only common names, but also relatively unique numbers. These numbers are called Security IDentifiers, or SIDs. Windows NT also provides services that render these SIDs into string forms. This class represents these string forms.</source>
          <target state="translated">Windows NT는 공통 이름뿐만 아니라 상대적으로 고유 한 번호로 사용자, 그룹 및 영역 (또는 도메인)을 나타내도록 선택합니다. 이러한 번호를 보안 IDentifier 또는 SID라고합니다. Windows NT는 또한 이러한 SID를 문자열 형식으로 렌더링하는 서비스를 제공합니다. 이 클래스는 이러한 문자열 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a4ec586bd67aec6c5c53fd30fb990d116b2bc3ae" translate="yes" xml:space="preserve">
          <source>Windows are capable of generating the following WindowEvents: WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.</source>
          <target state="translated">Windows는 WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus와 같은 WindowEvents를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e736d7e9cd07fdd5619eb22e9d6ea04daf0e51ae" translate="yes" xml:space="preserve">
          <source>Windows cannot overlap the full-screen window. All other application windows will always appear beneath the full-screen window in the Z-order.</source>
          <target state="translated">Windows는 전체 화면 창과 겹칠 수 없습니다. 다른 모든 응용 프로그램 창은 항상 Z 순서로 전체 화면 창 아래에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="593ac35fa2bd24a666d120e3789447fbf9c25e2a" translate="yes" xml:space="preserve">
          <source>WindowsNT/x86/4.0/lib/stat.dll</source>
          <target state="translated">WindowsNT/x86/4.0/lib/stat.dll</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="de916a95a394d60b5970c72c8e49b95595c376f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; and &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">&lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; 및 &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; 를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 별도로 스테이플됩니다.</target>
        </trans-unit>
        <trans-unit id="ce065a2774362ea1c0b4b2a9c6d578002c87fa95" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">&lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; 를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 새 시트에 관계없이 단일 문서로 함께 스테이플 링됩니다.</target>
        </trans-unit>
        <trans-unit id="000a0d000df5c6984649ddbd1ee6d53891ba7395" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">&lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; 를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 단일 문서로 함께 스테이플 링되지만 문서 &lt;code&gt;b&lt;/code&gt; 는 새 시트에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="702bb02b91946be2e7d1e7c71af340e7112b4fc2" translate="yes" xml:space="preserve">
          <source>With SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">SEPARATE_DOCUMENTS_UNCOLLATED_COPIES 및 SEPARATE_DOCUMENTS_COLLATED_COPIES를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 별도로 스테이플됩니다.</target>
        </trans-unit>
        <trans-unit id="c6940d372bef23c372a894b2611764845d087573" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">SINGLE_DOCUMENT를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 새 시트에 관계없이 단일 문서로 스테이플됩니다.</target>
        </trans-unit>
        <trans-unit id="6aea5edd4595a1343229324f4788e3637ab7593b" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT_NEW_SHEET, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">SINGLE_DOCUMENT_NEW_SHEET을 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 단일 문서로 스테이플되지만 문서 &lt;code&gt;b&lt;/code&gt; 는 새 시트에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7a7f0a9b6a27b5ea272b2faa2111b50312da5684" translate="yes" xml:space="preserve">
          <source>With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.</source>
          <target state="translated">버전 0 쿠키의 경우 값에는 공백, 대괄호, 괄호, 등호, 쉼표, 큰 따옴표, 슬래시, 물음표, 부호, 콜론 및 세미콜론이 포함되지 않아야합니다. 빈 값은 모든 브라우저에서 동일한 방식으로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf66f17ae2780078f9fea48695737926c268f057" translate="yes" xml:space="preserve">
          <source>With a PermissionCollection, you can:</source>
          <target state="translated">PermissionCollection을 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf292b706b0ea961ebe157c83d2d5ff0fdfda77" translate="yes" xml:space="preserve">
          <source>With a reference to the &lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; element, a relative XPath expression can be written to select the &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; child element:</source>
          <target state="translated">&lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; 요소에 대한 참조를 사용 하여 &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; 하위 요소 를 선택하기 위해 상대 XPath 표현식을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7921a6a2bd87af6e70cb7478096f1f706c0eed48" translate="yes" xml:space="preserve">
          <source>With attribute type synonyms, a directory can assign multiple names to the same attribute. For example, &quot;cn&quot; and &quot;commonName&quot; might both refer to the same attribute. Asking for &quot;cn&quot; might return the &quot;commonName&quot; attribute.</source>
          <target state="translated">속성 유형 동의어를 사용하면 디렉토리는 동일한 속성에 여러 이름을 지정할 수 있습니다. 예를 들어 &quot;cn&quot;과 &quot;commonName&quot;은 모두 동일한 속성을 참조 할 수 있습니다. &quot;cn&quot;을 요청하면 &quot;commonName&quot;속성이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="342174bb35309e577ba49df9b6a0136aab3a5327" translate="yes" xml:space="preserve">
          <source>With both intervals and &lt;code&gt;Spring&lt;/code&gt;s we can define &quot;-&quot; and &lt;em&gt;min&lt;/em&gt; in terms of negation:</source>
          <target state="translated">간격과 &lt;code&gt;Spring&lt;/code&gt; 모두 부정의 관점에서 &quot;-&quot;와 &lt;em&gt;min&lt;/em&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b146947ce59686776207df75fa9d667325f9863" translate="yes" xml:space="preserve">
          <source>With most look and feels, the user can drag out a tool bar into a separate window (unless the &lt;code&gt;floatable&lt;/code&gt; property is set to &lt;code&gt;false&lt;/code&gt;). For drag-out to work correctly, it is recommended that you add &lt;code&gt;JToolBar&lt;/code&gt; instances to one of the four &quot;sides&quot; of a container whose layout manager is a &lt;code&gt;BorderLayout&lt;/code&gt;, and do not add children to any of the other four &quot;sides&quot;.</source>
          <target state="translated">대부분의 룩앤필에서 사용자는 도구 모음을 별도의 창으로 드래그 할 수 있습니다 ( &lt;code&gt;floatable&lt;/code&gt; 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되지 않은 경우 ). 드래그 아웃이 제대로 작동하려면 레이아웃 관리자가 &lt;code&gt;BorderLayout&lt;/code&gt; 인 컨테이너의 네 &quot;측면&quot;중 하나에 &lt;code&gt;JToolBar&lt;/code&gt; 인스턴스를 추가하고 다른 네 &quot;측면&quot;에 자식을 추가하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0aee19fea36c937253e601d256a319bb86142c5d" translate="yes" xml:space="preserve">
          <source>With some complex reduction operations, for example a &lt;code&gt;collect()&lt;/code&gt; that produces a &lt;code&gt;Map&lt;/code&gt;, such as:</source>
          <target state="translated">복잡한 축소 작업 &lt;code&gt;collect()&lt;/code&gt; 예 : 다음과 같이 &lt;code&gt;Map&lt;/code&gt; 을 생성하는 collect () 등)</target>
        </trans-unit>
        <trans-unit id="5e5f811ed587d929e889b7d29ba9d4370ee0e985" translate="yes" xml:space="preserve">
          <source>With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled.</source>
          <target state="translated">위 코드를 사용하면 로그 수준 FINER가 비활성화 된 경우에도 상태가 불필요하게 수집됩니다. 아래와 같이 공급 업체 승인 버전을 사용하면 로그 수준 FINER가 활성화 된 경우에만 상태가 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2156a4e2b3c1c33c618ec6f586c7ea7f4199d8" translate="yes" xml:space="preserve">
          <source>With the exception of re-imaging an entire document for multiple collated copies, the increasing page index order means that when page N is requested if a client needs to calculate page break position, it may safely discard any state related to pages &amp;lt; N, and make current that for page N. &quot;State&quot; usually is just the calculated position in the document that corresponds to the start of the page.</source>
          <target state="translated">한 부씩 인쇄 된 여러 복사본에 대해 전체 문서를 다시 이미지화하는 것을 제외하고 페이지 색인 순서가 증가한다는 것은 클라이언트가 페이지 나누기 위치를 계산해야하는 경우 페이지 N이 요청 될 때 &amp;lt;N 페이지와 관련된 모든 상태를 안전하게 버릴 수 있음을 의미합니다. 페이지 N에 대해 현재 상태로 만듭니다. &quot;상태&quot;는 일반적으로 페이지의 시작에 해당하는 문서에서 계산 된 위치입니다.</target>
        </trans-unit>
        <trans-unit id="2024497e2bf2f02b354dda9dd14a083e17ac2ff2" translate="yes" xml:space="preserve">
          <source>With the exception of selected printer, the PrinterJob state is not updated to reflect the user's changes. For the selections to affect a printer job, the attributes must be specified in the call to the &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; method. If using the Pageable interface, clients which intend to use media selected by the user must create a PageFormat derived from the user's selections. If the user cancels the dialog, the attributes will not reflect any changes made by the user.</source>
          <target state="translated">선택한 프린터를 제외하고는 PrinterJob 상태가 사용자의 변경 사항을 반영하도록 업데이트되지 않습니다. 선택 사항이 프린터 작업에 영향을 미치려면 &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; 메서드 에 대한 호출에서 속성을 지정해야합니다 . Pageable 인터페이스를 사용하는 경우 사용자가 선택한 미디어를 사용하려는 클라이언트는 사용자의 선택에서 파생 된 PageFormat을 만들어야합니다. 사용자가 대화 상자를 취소하면 속성은 사용자가 변경 한 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e344a6ab10b8325512c520c0690b8d3e445352c1" translate="yes" xml:space="preserve">
          <source>With the following HTML content:</source>
          <target state="translated">With the following HTML content:</target>
        </trans-unit>
        <trans-unit id="618b01eeb003ee4b1ffdf3f6106417f6de534070" translate="yes" xml:space="preserve">
          <source>With the information retrieved from the methods &lt;code&gt;getStatus&lt;/code&gt; and &lt;code&gt;getConflictValue&lt;/code&gt;, the application may make a determination as to which value should be persisted in the data source. The application then calls the &lt;code&gt;SyncResolver&lt;/code&gt; method &lt;code&gt;setResolvedValue&lt;/code&gt;, which sets the value to be persisted in the &lt;code&gt;RowSet&lt;/code&gt; object and also in the data source.</source>
          <target state="translated">With the information retrieved from the methods &lt;code&gt;getStatus&lt;/code&gt; and &lt;code&gt;getConflictValue&lt;/code&gt; , the application may make a determination as to which value should be persisted in the data source. The application then calls the &lt;code&gt;SyncResolver&lt;/code&gt; method &lt;code&gt;setResolvedValue&lt;/code&gt; , which sets the value to be persisted in the &lt;code&gt;RowSet&lt;/code&gt; object and also in the data source.</target>
        </trans-unit>
        <trans-unit id="c20e7358b9286868d2d9a41c8b600c7c286dd9b1" translate="yes" xml:space="preserve">
          <source>With this addition of a semicolon the input is a complete source snippet.</source>
          <target state="translated">세미콜론을 추가하면 입력이 완전한 소스 스 니펫이됩니다.</target>
        </trans-unit>
        <trans-unit id="9fa5906aa1c7ed8368080a25444cc18e3529411d" translate="yes" xml:space="preserve">
          <source>With this addition of a semicolon the input is a complete source snippet. This will only be returned when the end of input is encountered.</source>
          <target state="translated">세미콜론을 추가하면 입력이 완전한 소스 스 니펫이됩니다. 이것은 입력의 끝을 만났을 때만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e8ff6037d8867d2b3d47892d80515cedec13ebae" translate="yes" xml:space="preserve">
          <source>With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with &lt;code&gt;synchronized&lt;/code&gt; methods and statements. In most cases, the following idiom should be used:</source>
          <target state="translated">이러한 유연성으로 인해 추가 책임이 따릅니다. 블록 구조 잠금이 없으면 &lt;code&gt;synchronized&lt;/code&gt; 메소드 및 명령문에서 발생하는 자동 잠금 해제가 제거됩니다 . 대부분의 경우 다음 관용구를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3c389bbd15c03f9dd881098991d518ed6f3894d" translate="yes" xml:space="preserve">
          <source>Within a</source>
          <target state="translated">이내에</target>
        </trans-unit>
        <trans-unit id="eaa46bf4774a02d445fea7fa33dbb744f6506eaa" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentFragment&lt;/code&gt;, or &lt;code&gt;Entity&lt;/code&gt; being serialized, &lt;code&gt;Nodes&lt;/code&gt; are processed as follows</source>
          <target state="translated">Within a &lt;code&gt;Document&lt;/code&gt; , &lt;code&gt;DocumentFragment&lt;/code&gt; , or &lt;code&gt;Entity&lt;/code&gt; being serialized, &lt;code&gt;Nodes&lt;/code&gt; are processed as follows</target>
        </trans-unit>
        <trans-unit id="0d2a1649d264fff3b41ff1e86e92590c9426695c" translate="yes" xml:space="preserve">
          <source>Within a bracket expression the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; characters match themselves. The (&lt;code&gt;-&lt;/code&gt;) character matches itself if it is the first character within the brackets, or the first character after the &lt;code&gt;!&lt;/code&gt; if negating.</source>
          <target state="translated">브라켓 표현식 내에서 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; 및 &lt;code&gt;\&lt;/code&gt; 문자가 일치합니다. ( &lt;code&gt;-&lt;/code&gt; ) 문자는 대괄호 안의 첫 번째 문자이거나 &lt;code&gt;!&lt;/code&gt; 다음의 첫 번째 문자 인 경우 자체와 일치합니다 . 부정하면.</target>
        </trans-unit>
        <trans-unit id="83d916c5bbfc33ee16ea209e9686d45596a9c2ac" translate="yes" xml:space="preserve">
          <source>Within each &lt;code&gt;ClassLoader&lt;/code&gt; instance all classes from the same java package have the same Package object. The static methods allow a package to be found by name or the set of all packages known to the current class loader to be found.</source>
          <target state="translated">각 &lt;code&gt;ClassLoader&lt;/code&gt; 내 인스턴스 에서 동일한 Java 패키지의 모든 클래스는 동일한 Package 객체를 갖습니다. 정적 메소드를 사용하면 이름으로 패키지를 찾거나 현재 클래스 로더에 알려진 모든 패키지 세트를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0668371fa9b725d274f510f8d695c661c8f6c217" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</target>
        </trans-unit>
        <trans-unit id="ed5391ea4c2aede0070693a361a2994f5e4a6a05" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</target>
        </trans-unit>
        <trans-unit id="8f444b6815c4d0578f6ec1b24cacc82f1de3a985" translate="yes" xml:space="preserve">
          <source>Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a &lt;code&gt;DOMError&lt;/code&gt; fatal error. An example would be serializing the element &amp;lt;LaCa&amp;ntilde;ada/&amp;gt; with &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt;. This will result with a generation of a &lt;code&gt;DOMError&lt;/code&gt; &quot;wf-invalid-character-in-node-name&quot; (as proposed in &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;well-formed&lt;/a&gt;&quot;).</source>
          <target state="translated">Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a &lt;code&gt;DOMError&lt;/code&gt; fatal error. An example would be serializing the element &amp;lt;LaCa&amp;ntilde;ada/&amp;gt; with &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt; . This will result with a generation of a &lt;code&gt;DOMError&lt;/code&gt; &quot;wf-invalid-character-in-node-name&quot; (as proposed in &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;well-formed&lt;/a&gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="e65be46b0d82a65208f681b65c6b6af3ea153929" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, either using the XML DOM tree or a plug-in specific interface, modifies values by whatever means, then modifies the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, using either the &lt;code&gt;setFromTree&lt;/code&gt; or &lt;code&gt;mergeTree&lt;/code&gt; methods, or a plug-in specific interface. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOMetadata&lt;/code&gt; object is ready for use in a write operation.</source>
          <target state="translated">&lt;code&gt;activate&lt;/code&gt; 메소드 내에서 컨트롤러는 XML DOM 트리 또는 플러그인 특정 인터페이스를 사용하여 &lt;code&gt;IIOMetadata&lt;/code&gt; 오브젝트의 설정 을 조회하여 초기 값을 가져오고 어떤 방법 으로든 값을 수정 한 다음 &lt;code&gt;setFromTree&lt;/code&gt; 또는 &lt;code&gt;mergeTree&lt;/code&gt; 를 사용하여 &lt;code&gt;IIOMetadata&lt;/code&gt; 오브젝트의 설정 을 수정합니다. 메소드 또는 플러그인 특정 인터페이스. 일반적으로 애플리케이션은 &lt;code&gt;activate&lt;/code&gt; 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 &lt;code&gt;IIOMetadata&lt;/code&gt; 오브젝트가 쓰기 조작에 사용할 준비 가 된 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83029e44e09a5ba0623249885430579f4267be4f" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;get&lt;/code&gt; methods, modifies values by whatever means, then invokes the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;set&lt;/code&gt; methods to modify the appropriate settings. Normally, these &lt;code&gt;set&lt;/code&gt; methods will be invoked all at once at a final commit in order that a cancel operation not disturb existing values. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOParam&lt;/code&gt; object is ready for use in a read or write operation.</source>
          <target state="translated">&lt;code&gt;activate&lt;/code&gt; 메소드 내에서 제어기는 &lt;code&gt;IIOParam&lt;/code&gt; 오브젝트의 &lt;code&gt;get&lt;/code&gt; 메소드 를 조회하여 초기 값을 확보 하고 어떤 방법 으로든 값을 수정 한 다음 &lt;code&gt;IIOParam&lt;/code&gt; 오브젝트의 &lt;code&gt;set&lt;/code&gt; 메소드를 호출 하여 적절한 설정을 수정합니다. 일반적으로 이러한 &lt;code&gt;set&lt;/code&gt; 메소드는 최종 커밋시 한 번에 모두 호출되어 취소 작업이 기존 값을 방해하지 않습니다. 일반적으로 애플리케이션은 &lt;code&gt;activate&lt;/code&gt; 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 &lt;code&gt;IIOParam&lt;/code&gt; 오브젝트가 읽기 또는 쓰기 조작에 사용할 준비 가 된 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76c301b37038720275724c001f96646390680990" translate="yes" xml:space="preserve">
          <source>Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references. Occurrences of '&amp;lt;' and '&amp;amp;' are replaced by the predefined entities &amp;amp;lt; and &amp;amp;amp;. The other predefined entities (&amp;amp;gt;, &amp;amp;apos;, and &amp;amp;quot;) might not be used, except where needed (e.g. using &amp;amp;gt; in cases such as ']]&amp;gt;'). Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).</source>
          <target state="translated">Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references. Occurrences of '&amp;lt;' and '&amp;amp;' are replaced by the predefined entities &amp;amp;lt; and &amp;amp;amp;. The other predefined entities (&amp;amp;gt;, &amp;amp;apos;, and &amp;amp;quot;) might not be used, except where needed (e.g. using &amp;amp;gt; in cases such as ']]&amp;gt;'). Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).</target>
        </trans-unit>
        <trans-unit id="1759a0ebe8a5e5c04ff2fdb42ee3e41043aa418f" translate="yes" xml:space="preserve">
          <source>Without anchoring bounds, the boundaries of this matcher's region will not match anchors such as ^ and $.</source>
          <target state="translated">앵커 경계가 없으면이 매처 영역의 경계는 ^ 및 $와 같은 앵커와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d683f7eface7d10e82e3f102080ec5410bd6835c" translate="yes" xml:space="preserve">
          <source>Without this warning, an applet may pop up windows without the user knowing that they belong to an applet. Since users may make security-sensitive decisions based on whether or not the window belongs to an applet (entering a username and password into a dialog box, for example), disabling this warning banner may allow applets to trick the user into entering such information.</source>
          <target state="translated">Without this warning, an applet may pop up windows without the user knowing that they belong to an applet. Since users may make security-sensitive decisions based on whether or not the window belongs to an applet (entering a username and password into a dialog box, for example), disabling this warning banner may allow applets to trick the user into entering such information.</target>
        </trans-unit>
        <trans-unit id="6fd52a68c735f034b00232a476c8c2e710db36a9" translate="yes" xml:space="preserve">
          <source>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides.</source>
          <target state="translated">단어 경계 분석은 검색 및 바꾸기 기능과 사용자가 더블 클릭으로 단어를 선택할 수있는 텍스트 편집 응용 프로그램에서 사용됩니다. 단어 선택은 단어 내 및 뒤에 나오는 문장 부호를 올바르게 해석합니다. 기호 또는 문장 부호와 같이 단어에 포함되지 않은 문자는 양쪽에 단어 구분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="6e99a8e4272c2db9e95f06a1f314a0f285a61837" translate="yes" xml:space="preserve">
          <source>Would result in the string '123-____'. If &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; was invoked '123-1212' would result. The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used.</source>
          <target state="translated">Would result in the string '123-____'. If &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; was invoked '123-1212' would result. The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used.</target>
        </trans-unit>
        <trans-unit id="642d596b44e19ab47c9e267aa3cf4a6030e0380b" translate="yes" xml:space="preserve">
          <source>Wrap a key.</source>
          <target state="translated">열쇠를 감싼다.</target>
        </trans-unit>
        <trans-unit id="3bcf468a4c3b40978bdee293e80fc65249f9482b" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a SAXParseException.</source>
          <target state="translated">Wrap an existing exception in a SAXParseException.</target>
        </trans-unit>
        <trans-unit id="b0b650cb303bad45cc633704145a571455dd7664" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerConfigurationException.</source>
          <target state="translated">Wrap an existing exception in a TransformerConfigurationException.</target>
        </trans-unit>
        <trans-unit id="9b39d6715671bdb2580af79800238414d13f1fd7" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerException.</source>
          <target state="translated">Wrap an existing exception in a TransformerException.</target>
        </trans-unit>
        <trans-unit id="0c3ecd9442f9e1b1059ee6690619be457c11839a" translate="yes" xml:space="preserve">
          <source>Wrapped value (&lt;code&gt;Integer.valueOf(5)&lt;/code&gt;, &lt;code&gt;Boolean.FALSE&lt;/code&gt;, etc)</source>
          <target state="translated">랩핑 된 값 ( &lt;code&gt;Integer.valueOf(5)&lt;/code&gt; , &lt;code&gt;Boolean.FALSE&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="adbbb2fc6c4f8e1a93cb3431a12402bc3b7237ec" translate="yes" xml:space="preserve">
          <source>WrappedPlainView</source>
          <target state="translated">WrappedPlainView</target>
        </trans-unit>
        <trans-unit id="a9ebad9ce612c251b607a54c6d2d4842c89b63b2" translate="yes" xml:space="preserve">
          <source>Wrapper</source>
          <target state="translated">Wrapper</target>
        </trans-unit>
        <trans-unit id="2dbad62d494925b0cc5a9b12acb2cba9f5175ae5" translate="yes" xml:space="preserve">
          <source>Wrapper for primitive graphics calls.</source>
          <target state="translated">Wrapper for primitive graphics calls.</target>
        </trans-unit>
        <trans-unit id="ff0316ad77425467f6a86336f0b3c23b4f8eb43e" translate="yes" xml:space="preserve">
          <source>Wrapper information for malformed and incomplete snippets also generate wrappers. The list is in snippet encounter order. The wrapper changes as the environment changes, so calls to this method at different times may yield different results.</source>
          <target state="translated">형식이 잘못되었거나 불완전한 스 니펫에 대한 래퍼 정보도 래퍼를 생성합니다. 목록은 스 니펫 발생 순서입니다. 랩퍼는 환경이 변경됨에 따라 변경되므로 다른 시간에이 메서드를 호출하면 다른 결과가 생성 될 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="92704fc2036355b575a4c4fbf65bd7b09813a44e" translate="yes" xml:space="preserve">
          <source>Wrapping the attribute value into an Annotation object guarantees that adjacent text runs don't get merged even if the attribute values are equal, and indicates to text containers that the attribute should be discarded if the underlying text is modified.</source>
          <target state="translated">속성 값을 Annotation 객체로 래핑하면 속성 값이 같더라도 인접한 텍스트 실행이 병합되지 않으며 기본 텍스트가 수정되면 속성을 버려야한다는 텍스트 컨테이너를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cca5fcd7b5b7c14fbea5ee4fc3296a93d35e1da8" translate="yes" xml:space="preserve">
          <source>Wraps a byte array into a buffer.</source>
          <target state="translated">바이트 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="3e43b98c51021b6537868fda39974c26611122c5" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client.</source>
          <target state="translated">Wraps a byte array to be sent to the client.</target>
        </trans-unit>
        <trans-unit id="64cfb840ede8be7ea7901c7dfd0a6e52d56476fa" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, a &lt;code&gt;SaslException&lt;/code&gt; is thrown.</source>
          <target state="translated">클라이언트에 보낼 바이트 배열을 래핑합니다. 이 메소드는 인증 교환이 완료된 후 (즉, &lt;code&gt;isComplete()&lt;/code&gt; 가 true를 리턴 할 때 ) 인증 교환이 무결성 및 / 또는 프라이버시를 보호 품질로 협상 한 경우 에만 호출 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;SaslException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1be73d2494fd5ecf63ee8bc9278f31e2926d14e" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server.</source>
          <target state="translated">Wraps a byte array to be sent to the server.</target>
        </trans-unit>
        <trans-unit id="c58ede29ff7ee729e1131d3a1d2647f530332ea4" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">서버로 보낼 바이트 배열을 래핑합니다. 이 메소드는 인증 교환이 완료된 후 (즉, &lt;code&gt;isComplete()&lt;/code&gt; 가 true를 리턴 할 때 ) 인증 교환이 무결성 및 / 또는 프라이버시를 보호 품질로 협상 한 경우 에만 호출 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="67b1374ef549a7e954a05b9ec7009fb8bc41734f" translate="yes" xml:space="preserve">
          <source>Wraps a char array into a buffer.</source>
          <target state="translated">char 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="f7b95771a9ecdaf8c4f0c45b0a3050463bc0fb11" translate="yes" xml:space="preserve">
          <source>Wraps a character sequence into a buffer.</source>
          <target state="translated">문자 순서를 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="9cf8f103948e6b6d2a2e2dcbd8e83ddda5dcdf8e" translate="yes" xml:space="preserve">
          <source>Wraps a double array into a buffer.</source>
          <target state="translated">더블 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="7c38a95681b8bf75718f777dc7681e478936ebe7" translate="yes" xml:space="preserve">
          <source>Wraps a float array into a buffer.</source>
          <target state="translated">float 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="e875d8d4d7f1a26ef5338640a04b767dbb14b0fd" translate="yes" xml:space="preserve">
          <source>Wraps a long array into a buffer.</source>
          <target state="translated">긴 배열을 버퍼에 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="7a45b9eefe39a4cdc4f096f2050c4639eeae92e4" translate="yes" xml:space="preserve">
          <source>Wraps a short array into a buffer.</source>
          <target state="translated">짧은 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="35438f1499f1a894d95345e3941ad2b29de6319a" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; if the MBeanInfo passed in parameter is null.</target>
        </trans-unit>
        <trans-unit id="c1d32f710973f4fd61bdd696efd70daf69bd5b7d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</target>
        </trans-unit>
        <trans-unit id="526e84458ea6e6f011221fcab33932da84f5ba1d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">매개 변수로 전달 된 MBeanInfo가 null 인 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을&lt;/a&gt; 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="5b976fffcdb3184f30e314babf43e006ea0f5ad5" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">ModelMBean이 현재 MBeanServer에 등록되어있는 경우 &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 을&lt;/a&gt; 랩합니다 .</target>
        </trans-unit>
        <trans-unit id="0edf81e480b4a49c11c2dbafe5b84b7869d1aa13" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; with an unchecked exception.</source>
          <target state="translated">확인되지 않은 예외 로 &lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 을 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="6afb0fee856f2866c314288124d5fc7949a1696a" translate="yes" xml:space="preserve">
          <source>Wraps an int array into a buffer.</source>
          <target state="translated">int 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="f46c77a2dce440c1be651d2cef94b153c69cfdb1" translate="yes" xml:space="preserve">
          <source>Wraps an output stream for encoding byte data using the &lt;a href=&quot;base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt; encoding scheme.</source>
          <target state="translated">&lt;a href=&quot;base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt; 인코딩 체계를 사용하여 바이트 데이터를 인코딩하기위한 출력 스트림을 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="484e8635160ff209f16a26350fd86bb6ec73ccc2" translate="yes" xml:space="preserve">
          <source>Wraps an throwable thrown in the executing client.</source>
          <target state="translated">실행중인 클라이언트에서 throwable을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="cd0bad816dddec56a1fb6f782b800ce84060f392" translate="yes" xml:space="preserve">
          <source>Wraps an throwable thrown in the executing client. An instance of &lt;code&gt;EvalException&lt;/code&gt; can be returned in the &lt;a href=&quot;snippetevent#exception()&quot;&gt;&lt;code&gt;SnippetEvent.exception()&lt;/code&gt;&lt;/a&gt; query. The name of the throwable thrown is available from &lt;a href=&quot;#getExceptionClassName()&quot;&gt;&lt;code&gt;getExceptionClassName()&lt;/code&gt;&lt;/a&gt;. Message and stack can be queried by methods on &lt;code&gt;Exception&lt;/code&gt;.</source>
          <target state="translated">실행중인 클라이언트에서 throwable을 래핑합니다. &lt;code&gt;EvalException&lt;/code&gt; 인스턴스는 SnippetEvent.exception &lt;a href=&quot;snippetevent#exception()&quot;&gt; &lt;code&gt;SnippetEvent.exception()&lt;/code&gt; &lt;/a&gt; 쿼리 에서 반환 될 수 있습니다 . throwable의 이름은 &lt;a href=&quot;#getExceptionClassName()&quot;&gt; &lt;code&gt;getExceptionClassName()&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 . 메시지 및 스택은 &lt;code&gt;Exception&lt;/code&gt; 에 대한 메서드로 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="12b5eee30743d96f3a2465542a9df99878df7b23" translate="yes" xml:space="preserve">
          <source>Wraps exceptions thrown by the preRegister(), preDeregister() methods of the &lt;code&gt;MBeanRegistration&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;MBeanRegistration&lt;/code&gt; 인터페이스 의 preRegister (), preDeregister () 메소드에 의해 발생한 예외를 랩 합니다.</target>
        </trans-unit>
        <trans-unit id="ac820c6009b39e20e5ac984441a6a70e50be36a4" translate="yes" xml:space="preserve">
          <source>Wraps the result of &lt;a href=&quot;#getCharContent(boolean)&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader.</source>
          <target state="translated">Wraps the result of &lt;a href=&quot;#getCharContent(boolean)&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader.</target>
        </trans-unit>
        <trans-unit id="4a990b08c589c006db4f034d5b0f85b8c7bd9875" translate="yes" xml:space="preserve">
          <source>Wraps the result of &lt;a href=&quot;#getCharContent(boolean)&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader. Subclasses can change this behavior as long as the contract of &lt;a href=&quot;fileobject&quot;&gt;&lt;code&gt;FileObject&lt;/code&gt;&lt;/a&gt; is obeyed.</source>
          <target state="translated">Wraps the result of &lt;a href=&quot;#getCharContent(boolean)&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader. Subclasses can change this behavior as long as the contract of &lt;a href=&quot;fileobject&quot;&gt; &lt;code&gt;FileObject&lt;/code&gt; &lt;/a&gt; is obeyed.</target>
        </trans-unit>
        <trans-unit id="8a2449189a10e5f2a06487a9d1438073749161da" translate="yes" xml:space="preserve">
          <source>Wraps the result of &lt;a href=&quot;simplejavafileobject#getCharContent-boolean-&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader. Subclasses can change this behavior as long as the contract of &lt;a href=&quot;fileobject&quot;&gt;&lt;code&gt;FileObject&lt;/code&gt;&lt;/a&gt; is obeyed.</source>
          <target state="translated">&lt;a href=&quot;simplejavafileobject#getCharContent-boolean-&quot;&gt;getCharContent (boolean)&lt;/a&gt; 의 결과를 Reader에 랩합니다 . &lt;a href=&quot;fileobject&quot;&gt; &lt;code&gt;FileObject&lt;/code&gt; &lt;/a&gt; 의 계약을 준수 하는 한 서브 클래스는이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab924b7847e5e470bb4f8f381c5b7f772f8b220f" translate="yes" xml:space="preserve">
          <source>Wraps the result of openOutputStream in a Writer.</source>
          <target state="translated">Wraps the result of openOutputStream in a Writer.</target>
        </trans-unit>
        <trans-unit id="18643b36bb23e1c01a06054ba0da36eec75ea0b6" translate="yes" xml:space="preserve">
          <source>Wraps the result of openOutputStream in a Writer. Subclasses can change this behavior as long as the contract of &lt;a href=&quot;fileobject&quot;&gt;&lt;code&gt;FileObject&lt;/code&gt;&lt;/a&gt; is obeyed.</source>
          <target state="translated">Writer에서 openOutputStream의 결과를 래핑합니다. &lt;a href=&quot;fileobject&quot;&gt; &lt;code&gt;FileObject&lt;/code&gt; &lt;/a&gt; 의 계약을 준수 하는 한 서브 클래스는이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5c0446c81d41ca1fdd8fea8cfadd9a744960cb5" translate="yes" xml:space="preserve">
          <source>Wraps the specified transform.</source>
          <target state="translated">Wraps the specified transform.</target>
        </trans-unit>
        <trans-unit id="18aba0f6a8421686c79cd18305b44edb5756ae50" translate="yes" xml:space="preserve">
          <source>Wraps the specified transform. The transform is cloned and a reference to the clone is kept. The original transform is unchanged. If null is passed as the argument, this constructor behaves as though it were the identity transform. (Note that it is preferable to use &lt;a href=&quot;#IDENTITY&quot;&gt;&lt;code&gt;IDENTITY&lt;/code&gt;&lt;/a&gt; in this case.)</source>
          <target state="translated">Wraps the specified transform. The transform is cloned and a reference to the clone is kept. The original transform is unchanged. If null is passed as the argument, this constructor behaves as though it were the identity transform. (Note that it is preferable to use &lt;a href=&quot;#IDENTITY&quot;&gt; &lt;code&gt;IDENTITY&lt;/code&gt; &lt;/a&gt; in this case.)</target>
        </trans-unit>
        <trans-unit id="6da588377e328486ae18afd15219a2649754d3c0" translate="yes" xml:space="preserve">
          <source>Wraps this segment in a &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 세그먼트를 &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; &lt;/a&gt; 에 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="e8ef84101ba37aa05699837c391abecc35bc93c2" translate="yes" xml:space="preserve">
          <source>Wraps this segment in a &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;. Some of the properties of the returned buffer are linked to the properties of this segment. For instance, if this segment is &lt;em&gt;immutable&lt;/em&gt; (e.g. the segment has access mode &lt;a href=&quot;#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt;), then the resulting buffer is &lt;em&gt;read-only&lt;/em&gt; (see &lt;a href=&quot;../../../../java.base/java/nio/buffer#isReadOnly()&quot;&gt;&lt;code&gt;Buffer.isReadOnly()&lt;/code&gt;&lt;/a&gt;. Additionally, if this is a native memory segment, the resulting buffer is &lt;em&gt;direct&lt;/em&gt; (see &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer#isDirect()&quot;&gt;&lt;code&gt;ByteBuffer.isDirect()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 세그먼트를 &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; &lt;/a&gt; 에 래핑합니다 . 반환 된 버퍼의 일부 속성은이 세그먼트의 속성에 연결됩니다. 예를 들어,이 세그먼트가 &lt;em&gt;불변 인 경우&lt;/em&gt; (예 : 세그먼트에 &lt;a href=&quot;#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 액세스 모드가 있지만 &lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; 가&lt;/a&gt; 아님) 결과 버퍼는 &lt;em&gt;읽기 전용입니다&lt;/em&gt; ( &lt;a href=&quot;../../../../java.base/java/nio/buffer#isReadOnly()&quot;&gt; &lt;code&gt;Buffer.isReadOnly()&lt;/code&gt; &lt;/a&gt; 참조 ) . 또한 이것이 네이티브 메모리 세그먼트 인 경우 결과 버퍼 인 &lt;em&gt;다이렉트&lt;/em&gt; (참조 &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer#isDirect()&quot;&gt; &lt;code&gt;ByteBuffer.isDirect()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8f27a22b91fffa5fca45a36aaea975d25f5a8b2" translate="yes" xml:space="preserve">
          <source>WritableByteChannel</source>
          <target state="translated">WritableByteChannel</target>
        </trans-unit>
        <trans-unit id="232d2eb15dd5a8e6d5b8d3468d075c115e7d592c" translate="yes" xml:space="preserve">
          <source>WritableByteChannel.write()</source>
          <target state="translated">WritableByteChannel.write()</target>
        </trans-unit>
        <trans-unit id="8df121d40ab265ffb282618abaddabf62bf4b394" translate="yes" xml:space="preserve">
          <source>WritableRaster</source>
          <target state="translated">WritableRaster</target>
        </trans-unit>
        <trans-unit id="d89b72e5d40182fe2b3219c24a22ac87a1fc4964" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage</source>
          <target state="translated">WritableRenderedImage</target>
        </trans-unit>
        <trans-unit id="028b998a60e46208ce0ede4aa3a7013db3bcb901" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over.</source>
          <target state="translated">WritableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over.</target>
        </trans-unit>
        <trans-unit id="b356fedb82416c4bf9703a0aa4ef5cd0e33afc43" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over. The image data may be stored/produced as a single tile or a regular array of tiles.</source>
          <target state="translated">WritableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over. The image data may be stored/produced as a single tile or a regular array of tiles.</target>
        </trans-unit>
        <trans-unit id="c22974bfb92e8c252f00719977a7781037b8ef4a" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage provides notification to other interested objects when a tile is checked out for writing (via the getWritableTile method) and when the last writer of a particular tile relinquishes its access (via a call to releaseWritableTile). Additionally, it allows any caller to determine whether any tiles are currently checked out (via hasTileWriters), and to obtain a list of such tiles (via getWritableTileIndices, in the form of a Vector of Point objects).</source>
          <target state="translated">WritableRenderedImage provides notification to other interested objects when a tile is checked out for writing (via the getWritableTile method) and when the last writer of a particular tile relinquishes its access (via a call to releaseWritableTile). Additionally, it allows any caller to determine whether any tiles are currently checked out (via hasTileWriters), and to obtain a list of such tiles (via getWritableTileIndices, in the form of a Vector of Point objects).</target>
        </trans-unit>
        <trans-unit id="5da714036977cab66b8b81ed578fe655c485e622" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file.</source>
          <target state="translated">Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file.</target>
        </trans-unit>
        <trans-unit id="4c9ce4be9f1bfb0073774626ee67a785eab41413" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file. Characters are encoded into bytes using the &lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt;&lt;code&gt;UTF-8&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file. Characters are encoded into bytes using the &lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt; &lt;code&gt;UTF-8&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="792c5eb24bd75a6c8f430ef046aca72eecc461f1" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file. Characters are encoded into bytes using the specified &lt;a href=&quot;../charset/charset&quot;&gt;charset&lt;/a&gt;.</source>
          <target state="translated">Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file. Characters are encoded into bytes using the specified &lt;a href=&quot;../charset/charset&quot;&gt;charset&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="294afe002c539f61c1c0ee3dcb972c7d74bf355b" translate="yes" xml:space="preserve">
          <source>Write a DTD section.</source>
          <target state="translated">Write a DTD section.</target>
        </trans-unit>
        <trans-unit id="59ffb7b91778bf9267476f98e09dcacd6f27df3d" translate="yes" xml:space="preserve">
          <source>Write a DTD section. This string represents the entire doctypedecl production from the XML 1.0 specification.</source>
          <target state="translated">Write a DTD section. This string represents the entire doctypedecl production from the XML 1.0 specification.</target>
        </trans-unit>
        <trans-unit id="1fc0bd7118775692ac86213afd1d0d2701cb9b4d" translate="yes" xml:space="preserve">
          <source>Write a byte of data to the stream. If it is not a newline, then the byte is appended to the internal buffer. If it is a newline, then the currently buffered line is sent to the log's output stream, prefixed with the appropriate logging information.</source>
          <target state="translated">Write a byte of data to the stream. If it is not a newline, then the byte is appended to the internal buffer. If it is a newline, then the currently buffered line is sent to the log's output stream, prefixed with the appropriate logging information.</target>
        </trans-unit>
        <trans-unit id="98c22110dc7ee6d680da89d0b08efd62d28b6ef7" translate="yes" xml:space="preserve">
          <source>Write a portion of a string to the buffer.</source>
          <target state="translated">문자열의 일부를 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="4652631a628afd8a3f8a588fd0dbd737d2146884" translate="yes" xml:space="preserve">
          <source>Write a portion of a string.</source>
          <target state="translated">문자열의 일부를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="354cde68fb6c2f936b7c59bf670319ba0dcf0ab7" translate="yes" xml:space="preserve">
          <source>Write a portion of an array of characters.</source>
          <target state="translated">문자 배열의 일부를 씁니다.</target>
        </trans-unit>
        <trans-unit id="330fefb058de9e90d4a9120ede2b9e5d7c7923ca" translate="yes" xml:space="preserve">
          <source>Write a single character.</source>
          <target state="translated">단일 문자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="994c1ba05bfadf4cef0d6733c4c98bd025355fa4" translate="yes" xml:space="preserve">
          <source>Write a string of text followed by a newline character to a document stream opened by &lt;code&gt;open()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; 의해 열린 문서 스트림에 텍스트 문자열과 개행 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="498783f0999ed7eb8d0d11df50117632250e49f4" translate="yes" xml:space="preserve">
          <source>Write a string of text followed by a newline character to a document stream opened by &lt;code&gt;open()&lt;/code&gt; . The text is parsed into the document's structure model.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; 의해 열린 문서 스트림에 텍스트 문자열과 개행 문자를 씁니다 . 텍스트는 문서의 구조 모델로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cdad9bf95a1d8bc5e861dbd1d5513d4131edf9" translate="yes" xml:space="preserve">
          <source>Write a string of text to a document stream opened by &lt;code&gt;open()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; 의해 열린 문서 스트림에 텍스트 문자열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="6cf4f5d1c6394d5c94d488c2922b7aae5b015b7a" translate="yes" xml:space="preserve">
          <source>Write a string of text to a document stream opened by &lt;code&gt;open()&lt;/code&gt; . The text is parsed into the document's structure model.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; 의해 열린 문서 스트림에 텍스트 문자열을 씁니다 . 텍스트는 문서의 구조 모델로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e749d40ff493a236a023d30fb9fbee8148a6ef" translate="yes" xml:space="preserve">
          <source>Write a string.</source>
          <target state="translated">문자열을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0556df9723ab76c236dd36201ca6d8bc8762ef74" translate="yes" xml:space="preserve">
          <source>Write a subarray of bytes. Pass each through write byte method.</source>
          <target state="translated">Write a subarray of bytes. Pass each through write byte method.</target>
        </trans-unit>
        <trans-unit id="fa4bcd6ffc98fa169157314d2485ef4b0ffb5451" translate="yes" xml:space="preserve">
          <source>Write access mode; write operations are supported by a segment which supports this access mode.</source>
          <target state="translated">쓰기 액세스 모드; 쓰기 작업은이 액세스 모드를 지원하는 세그먼트에 의해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0669d7506d09ace8cad4d0f0e36010749d28970c" translate="yes" xml:space="preserve">
          <source>Write accesses to the segment's content &lt;a href=&quot;../../../java/util/concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt; hand-over from the current owner thread to the new owner thread, which in turn</source>
          <target state="translated">세그먼트의 콘텐츠에 대한 쓰기 액세스 는 현재 소유자 스레드에서 새 소유자 스레드로 핸드 오버 &lt;a href=&quot;../../../java/util/concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;되기 전에 발생&lt;/i&gt;&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="20a06ba0fb5f245b45c41b384d2689f6921e992d" translate="yes" xml:space="preserve">
          <source>Write an XML representation of the specified object to the output.</source>
          <target state="translated">지정된 객체의 XML 표현을 출력에 씁니다.</target>
        </trans-unit>
        <trans-unit id="be7a56a69ad18401ec15997f7d4e84d91cfc1967" translate="yes" xml:space="preserve">
          <source>Write an object to the underlying storage or stream.</source>
          <target state="translated">Write an object to the underlying storage or stream.</target>
        </trans-unit>
        <trans-unit id="edf1d95422469a4ca47028cba75c57280225b87b" translate="yes" xml:space="preserve">
          <source>Write an object to the underlying storage or stream. The class that implements this interface defines how the object is written.</source>
          <target state="translated">기본 저장소 또는 스트림에 개체를 씁니다. 이 인터페이스를 구현하는 클래스는 객체 작성 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1f519448d10b81232efe702c1adf54399740a1e6" translate="yes" xml:space="preserve">
          <source>Write any cached data to the underlying output mechanism.</source>
          <target state="translated">Write any cached data to the underlying output mechanism.</target>
        </trans-unit>
        <trans-unit id="e1449e213dd3fcab37865b1ea7eed0c6a6eda03c" translate="yes" xml:space="preserve">
          <source>Write content from a document to the given stream as plain text.</source>
          <target state="translated">Write content from a document to the given stream as plain text.</target>
        </trans-unit>
        <trans-unit id="47582b3fc1fd1ce73fc7f30356e130a469fc033d" translate="yes" xml:space="preserve">
          <source>Write content from a document to the given stream in a format appropriate for this kind of content handler.</source>
          <target state="translated">Write content from a document to the given stream in a format appropriate for this kind of content handler.</target>
        </trans-unit>
        <trans-unit id="81829db29a2fbd204bf7a7893714606039435c4e" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file.</source>
          <target state="translated">Write lines of text to a file.</target>
        </trans-unit>
        <trans-unit id="5f04a37c7592d94e8a688b1e22ea47eb19aaa578" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file. Characters are encoded into bytes using the &lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt;&lt;code&gt;UTF-8&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일에 텍스트 줄을 씁니다. 문자는 &lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt; &lt;code&gt;UTF-8&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; 을&lt;/a&gt; 사용하여 바이트로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc7e0443ea36cc424ea3c38e6c6339b26fa90a65" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file. Each line is a char sequence and is written to the file in sequence with each line terminated by the platform's line separator, as defined by the system property &lt;code&gt;
 line.separator&lt;/code&gt;. Characters are encoded into bytes using the specified charset.</source>
          <target state="translated">Write lines of text to a file. Each line is a char sequence and is written to the file in sequence with each line terminated by the platform's line separator, as defined by the system property &lt;code&gt; line.separator&lt;/code&gt; . Characters are encoded into bytes using the specified charset.</target>
        </trans-unit>
        <trans-unit id="422a884c7d36bcb6e46158dea6218bc82e12cb81" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file. Each line is a char sequence and is written to the file in sequence with each line terminated by the platform's line separator, as defined by the system property &lt;code&gt;line.separator&lt;/code&gt;. Characters are encoded into bytes using the specified charset.</source>
          <target state="translated">파일에 텍스트 줄을 씁니다. 각 행은 문자 순서이며 시스템 특성 &lt;code&gt;line.separator&lt;/code&gt; 에 의해 정의 된대로 플랫폼의 행 구분 기호로 종료 된 각 행과 함께 파일에 순서대로 기록됩니다 . 지정된 문자 세트를 사용하여 문자가 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="deab5959d8a2b2e287acf5a1e8d177d50eebcbfc" translate="yes" xml:space="preserve">
          <source>Write permission, group.</source>
          <target state="translated">쓰기 권한, 그룹.</target>
        </trans-unit>
        <trans-unit id="ded98708196db3375d703bc829781b7516b5d82b" translate="yes" xml:space="preserve">
          <source>Write permission, others.</source>
          <target state="translated">쓰기 권한, 다른 사람.</target>
        </trans-unit>
        <trans-unit id="b5122274cf00f9236d161b83cf0b1959eac868b3" translate="yes" xml:space="preserve">
          <source>Write permission, owner.</source>
          <target state="translated">쓰기 권한, 소유자.</target>
        </trans-unit>
        <trans-unit id="dc4ca2f6cd629c41dd78f0c1bd4a77413a6ba272" translate="yes" xml:space="preserve">
          <source>Write text to the output</source>
          <target state="translated">Write text to the output</target>
        </trans-unit>
        <trans-unit id="c27677af8097cdc9a850db19aa4fc10ea237786a" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration.</source>
          <target state="translated">Write the XML Declaration.</target>
        </trans-unit>
        <trans-unit id="34ae6a769a32d1c96d1a4d08e0485664c6f49728" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration. Defaults the XML version to 1.0</source>
          <target state="translated">Write the XML Declaration. Defaults the XML version to 1.0</target>
        </trans-unit>
        <trans-unit id="d8fdef7127a3c69001637df99c66003fee11b2af" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration. Defaults the XML version to 1.0, and the encoding to utf-8</source>
          <target state="translated">Write the XML Declaration. Defaults the XML version to 1.0, and the encoding to utf-8</target>
        </trans-unit>
        <trans-unit id="ab1b062ab03bc27d496ac4ab537a5eded352d293" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration. Note that the encoding parameter does not set the actual encoding of the underlying output. That must be set when the instance of the XMLStreamWriter is created using the XMLOutputFactory</source>
          <target state="translated">Write the XML Declaration. Note that the encoding parameter does not set the actual encoding of the underlying output. That must be set when the instance of the XMLStreamWriter is created using the XMLOutputFactory</target>
        </trans-unit>
        <trans-unit id="9895c1ecb033c87ffe0c615c065d32dfcc621b1a" translate="yes" xml:space="preserve">
          <source>Write the buffered fields to the stream.</source>
          <target state="translated">버퍼링 된 필드를 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="f155bd1e4a1fbf0d9f77f04b5cf3659190cb7a16" translate="yes" xml:space="preserve">
          <source>Write the data and fields to the specified ObjectOutput stream, which must be the same stream that produced this &lt;code&gt;PutField&lt;/code&gt; object.</source>
          <target state="translated">데이터와 필드를 지정된 ObjectOutput 스트림에 씁니다 . 이 &lt;code&gt;PutField&lt;/code&gt; 객체 를 생성 한 스트림과 동일해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2d78cda2a78c150de7205e7faea5f60ac062cf74" translate="yes" xml:space="preserve">
          <source>Write the new values to the data source if there is no conflict</source>
          <target state="translated">Write the new values to the data source if there is no conflict</target>
        </trans-unit>
        <trans-unit id="0eb67d8d108ef50bcb4d3a9affa038eaff061a85" translate="yes" xml:space="preserve">
          <source>Write the non-static and non-transient fields of the current class to this stream.</source>
          <target state="translated">Write the non-static and non-transient fields of the current class to this stream.</target>
        </trans-unit>
        <trans-unit id="ab3c2de8de514c7b931148e12444f33c0c77a32e" translate="yes" xml:space="preserve">
          <source>Write the non-static and non-transient fields of the current class to this stream. This may only be called from the writeObject method of the class being serialized. It will throw the NotActiveException if it is called otherwise.</source>
          <target state="translated">현재 클래스의 비 정적 및 비 과도 필드를이 스트림에 씁니다. 직렬화되는 클래스의 writeObject 메소드에서만 호출 할 수 있습니다. 그렇지 않은 경우 NotActiveException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2edab8000ccaace4ff203cc13300679ac4b1d96b" translate="yes" xml:space="preserve">
          <source>Write the specified class descriptor to the ObjectOutputStream.</source>
          <target state="translated">Write the specified class descriptor to the ObjectOutputStream.</target>
        </trans-unit>
        <trans-unit id="c8f5b81bb83d33a942ae2cbeb1415c3a0749b149" translate="yes" xml:space="preserve">
          <source>Write the specified class descriptor to the ObjectOutputStream. Class descriptors are used to identify the classes of objects written to the stream. Subclasses of ObjectOutputStream may override this method to customize the way in which class descriptors are written to the serialization stream. The corresponding method in ObjectInputStream, &lt;code&gt;readClassDescriptor&lt;/code&gt;, should then be overridden to reconstitute the class descriptor from its custom stream representation. By default, this method writes class descriptors according to the format defined in the Object Serialization specification.</source>
          <target state="translated">지정된 클래스 디스크립터를 ObjectOutputStream에 씁니다. 클래스 디스크립터는 스트림에 기록 된 오브젝트 클래스를 식별하는 데 사용됩니다. ObjectOutputStream의 서브 클래스는이 메소드를 오버라이드 (override) 해 클래스 기술자가 직렬화 스트림에 기입 해지는 방법을 커스터마이즈 할 수 있습니다. 그런 다음 ObjectInputStream의 해당 메소드 인 &lt;code&gt;readClassDescriptor&lt;/code&gt; 를 재정 의하여 사용자 정의 스트림 표현에서 클래스 디스크립터를 재구성해야합니다. 기본적으로이 메소드는 오브젝트 직렬화 스펙에 정의 된 형식에 따라 클래스 디스크립터를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="561471854d9e617fefb6f5e631dd834e2f7a127c" translate="yes" xml:space="preserve">
          <source>Write the specified object to the ObjectOutputStream.</source>
          <target state="translated">Write the specified object to the ObjectOutputStream.</target>
        </trans-unit>
        <trans-unit id="677457df7e5bc80c0b6feefc69e3beb6b15a7123" translate="yes" xml:space="preserve">
          <source>Write the specified object to the ObjectOutputStream. The class of the object, the signature of the class, and the values of the non-transient and non-static fields of the class and all of its supertypes are written. Default serialization for a class can be overridden using the writeObject and the readObject methods. Objects referenced by this object are written transitively so that a complete equivalent graph of objects can be reconstructed by an ObjectInputStream.</source>
          <target state="translated">지정된 개체를 ObjectOutputStream에 씁니다. 객체의 클래스, 클래스의 서명, 클래스의 비 일시적 필드와 비 정적 필드의 값 및 모든 수퍼 타입이 작성됩니다. 클래스의 기본 직렬화는 writeObject 및 readObject 메소드를 사용하여 대체 할 수 있습니다. 이 객체가 참조하는 객체는 전 이적으로 작성되므로 ObjectInputStream으로 객체의 완전한 동등한 그래프를 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8c20a4b40326e735cd9da6418440d4414b1a4ab" translate="yes" xml:space="preserve">
          <source>Write the specified object to the output stream.</source>
          <target state="translated">Write the specified object to the output stream.</target>
        </trans-unit>
        <trans-unit id="625c55deeb63764ede0c1729277f79d569d6d1fa" translate="yes" xml:space="preserve">
          <source>Write the specified object to the output stream. The serialized form will denote a series of expressions, the combined effect of which will create an equivalent object when the input stream is read. By default, the object is assumed to be a &lt;em&gt;JavaBean&lt;/em&gt; with a nullary constructor, whose state is defined by the matching pairs of &quot;setter&quot; and &quot;getter&quot; methods returned by the Introspector.</source>
          <target state="translated">지정된 개체를 출력 스트림에 씁니다. 직렬화 된 형식은 일련의 표현식을 나타내며, 그 조합 된 효과는 입력 스트림을 읽을 때 동등한 오브젝트를 작성합니다. 기본적으로 객체는 nullary 생성자를 가진 &lt;em&gt;JavaBean&lt;/em&gt; 으로 가정되며 , 상태는 Introspector에서 반환 한 &quot;setter&quot;및 &quot;getter&quot;메서드와 일치하는 쌍으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a0f768933c7776774b2478fd947d9ef03d2ebe96" translate="yes" xml:space="preserve">
          <source>Write this &lt;code&gt;ICC_Profile&lt;/code&gt; to a file.</source>
          <target state="translated">이 &lt;code&gt;ICC_Profile&lt;/code&gt; 을 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="278995a53b7c0304511a3172b13a3a18f1b7e97c" translate="yes" xml:space="preserve">
          <source>Write this &lt;code&gt;ICC_Profile&lt;/code&gt; to an &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;ICC_Profile&lt;/code&gt; 을 &lt;code&gt;OutputStream&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="35fe4c369854ef11a28df02657f28c0c907503a3" translate="yes" xml:space="preserve">
          <source>Write this ICC_Profile to a file.</source>
          <target state="translated">Write this ICC_Profile to a file.</target>
        </trans-unit>
        <trans-unit id="e1d9c07bfd2efb9ad99f30ea021931a574f4f6d6" translate="yes" xml:space="preserve">
          <source>Write this ICC_Profile to an OutputStream.</source>
          <target state="translated">Write this ICC_Profile to an OutputStream.</target>
        </trans-unit>
        <trans-unit id="936da01feb2f096577e8365b734cb08599ce6a37" translate="yes" xml:space="preserve">
          <source>WriteAbortedException</source>
          <target state="translated">WriteAbortedException</target>
        </trans-unit>
        <trans-unit id="6248c802937f8babd7f472dab3a9ccaa3cd8ca1e" translate="yes" xml:space="preserve">
          <source>WriteAbortedException.getCause()</source>
          <target state="translated">WriteAbortedException.getCause()</target>
        </trans-unit>
        <trans-unit id="d927b7d3922dccb6d4373916a1a508a5f9825f5b" translate="yes" xml:space="preserve">
          <source>WriteAbortedException.getMessage()</source>
          <target state="translated">WriteAbortedException.getMessage()</target>
        </trans-unit>
        <trans-unit id="9ee45a046a695fc62952355259c464d3782298a5" translate="yes" xml:space="preserve">
          <source>WriteLock</source>
          <target state="translated">WriteLock</target>
        </trans-unit>
        <trans-unit id="7c5510f1ed33e3b93fd55caec8daa43bd1ce2d2f" translate="yes" xml:space="preserve">
          <source>WritePendingException</source>
          <target state="translated">WritePendingException</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="3a612b47fe0eec805b37e580fcd5618c583e4cf4" translate="yes" xml:space="preserve">
          <source>Writer.append()</source>
          <target state="translated">Writer.append()</target>
        </trans-unit>
        <trans-unit id="b91c0ca8400fde6125b0c11f2497f37000c08a06" translate="yes" xml:space="preserve">
          <source>Writer.close()</source>
          <target state="translated">Writer.close()</target>
        </trans-unit>
        <trans-unit id="e0c57d77abf55ac12872750811814a29d64dcbfe" translate="yes" xml:space="preserve">
          <source>Writer.flush()</source>
          <target state="translated">Writer.flush()</target>
        </trans-unit>
        <trans-unit id="6b58bc364a56f8d61ed239ce03e81a9366cf0f8e" translate="yes" xml:space="preserve">
          <source>Writer.write()</source>
          <target state="translated">Writer.write()</target>
        </trans-unit>
        <trans-unit id="b2be28b744c30e1c5c5fb3a3d946aee604890aab" translate="yes" xml:space="preserve">
          <source>Writers should call &lt;code&gt;clearAbortRequest&lt;/code&gt; at the beginning of each write operation, and poll the value of &lt;code&gt;abortRequested&lt;/code&gt; regularly during the write.</source>
          <target state="translated">작성자는 각 쓰기 작업이 시작될 때 &lt;code&gt;clearAbortRequest&lt;/code&gt; 를 호출 하고 쓰기 중에 정기적으로 &lt;code&gt;abortRequested&lt;/code&gt; 의 값을 폴링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aecde5df091918dfeffcca27e002a97115f41c8d" translate="yes" xml:space="preserve">
          <source>Writers that do not make use of stream metadata (</source>
          <target state="translated">스트림 메타 데이터를 사용하지 않는 작성자 (</target>
        </trans-unit>
        <trans-unit id="2005d7caf2832e9b66c2ea6efe4c5aa8727e0190" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this file output stream.</source>
          <target state="translated">쓰기 &lt;code&gt;b.length&lt;/code&gt; 를 파일 출력 스트림에 지정된 바이트 배열의 바이트.</target>
        </trans-unit>
        <trans-unit id="475a7013d71b2530ccf213898f664fa5353bdd4f" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this file, starting at the current file pointer.</source>
          <target state="translated">현재 파일 포인터에서 시작하여 지정된 바이트 배열의 &lt;code&gt;b.length&lt;/code&gt; 바이트를이 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="94ad317d7b0ac67a67357470a8dfe034c14d2f1b" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this output stream.</source>
          <target state="translated">쓰기 &lt;code&gt;b.length&lt;/code&gt; 를 출력 스트림에 지정된 바이트 배열의 바이트.</target>
        </trans-unit>
        <trans-unit id="e624a17a648a4933d0e79844ab18e51cf30d0121" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this output stream. The general contract for &lt;code&gt;write(b)&lt;/code&gt; is that it should have exactly the same effect as the call &lt;code&gt;write(b, 0, b.length)&lt;/code&gt;.</source>
          <target state="translated">쓰기 &lt;code&gt;b.length&lt;/code&gt; 를 출력 스트림에 지정된 바이트 배열의 바이트. &lt;code&gt;write(b)&lt;/code&gt; 의 일반적인 계약 은 call &lt;code&gt;write(b, 0, b.length)&lt;/code&gt; 와 정확히 동일한 효과를 가져야한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5534222ccd82110cbb41a1dc6f9a045112f429c8" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes to this output stream.</source>
          <target state="translated">&lt;code&gt;b.length&lt;/code&gt; 바이트를이 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c1d0bdd8cec5ae9557cd3f32c364cea21614290d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from array &lt;code&gt;b&lt;/code&gt;, in order, to the output stream.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; bytes from array &lt;code&gt;b&lt;/code&gt; , in order, to the output stream.</target>
        </trans-unit>
        <trans-unit id="9f0e3c34e35200d337717f421eb2f8500aba265d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from array &lt;code&gt;b&lt;/code&gt;, in order, to the output stream. If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;off&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off+len&lt;/code&gt; is greater than the length of the array &lt;code&gt;b&lt;/code&gt;, then an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown. If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are written. Otherwise, the byte &lt;code&gt;b[off]&lt;/code&gt; is written first, then &lt;code&gt;b[off+1]&lt;/code&gt;, and so on; the last byte written is &lt;code&gt;b[off+len-1]&lt;/code&gt;.</source>
          <target state="translated">기입 &lt;code&gt;len&lt;/code&gt; 어레이에서 바이트 &lt;code&gt;b&lt;/code&gt; 출력 스트림 순서. 경우 &lt;code&gt;b&lt;/code&gt; 는 이다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다. 경우 &lt;code&gt;off&lt;/code&gt; 음수 또는 &lt;code&gt;len&lt;/code&gt; 음수 또는 &lt;code&gt;off+len&lt;/code&gt; 어레이의 길이보다 큰 경우 &lt;code&gt;b&lt;/code&gt; , 다음 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 발생된다. 경우 &lt;code&gt;len&lt;/code&gt; 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 바이트 &lt;code&gt;b[off]&lt;/code&gt; 가 먼저 기록 된 다음 &lt;code&gt;b[off+1]&lt;/code&gt; 등이 기록됩니다. 기록 된 마지막 바이트는 &lt;code&gt;b[off+len-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7493c7432d9d918d61b6c3585fce1581bbd60fd" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified &lt;code&gt;byte&lt;/code&gt; array starting at offset &lt;code&gt;off&lt;/code&gt; to this output stream.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작 하여 지정된 &lt;code&gt;byte&lt;/code&gt; 배열 에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f7ed92cd5964e41ce5935be590a970273e849d1d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream.</target>
        </trans-unit>
        <trans-unit id="b90204d909dc82fb7e5d3bbd0045ef72ec9d3faa" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트를 기본 출력 스트림에 씁니다 . 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;len&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="2a8058c4fe448481ba9f9667cd3950b5d1ac6e95" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt;.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59c2ffa0a4decb3975339af3e1141064e1cf801f" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 버퍼링 된 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="df6022a3c457bef633289c3b1eea0afc7d2501d2" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this byte array output stream.</source>
          <target state="translated">기입 &lt;code&gt;len&lt;/code&gt; 지정된 바이트 배열의 바이트 오프셋 &lt;code&gt;off&lt;/code&gt; 바이트 배열 출력 스트림.</target>
        </trans-unit>
        <trans-unit id="f47416c1bae43204d3ed0a20b6c785b1c8477de5" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this file output stream.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 파일 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7c910c38a8bd891a83fe0ebe30f88a0297205886" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this file.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="38c566418d538790a5eeae487d789010f4523286" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this output stream.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="4f851862b3139a3a60a822bd0fb6f38f95f98ef1" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this output stream. The general contract for &lt;code&gt;write(b, off, len)&lt;/code&gt; is that some of the bytes in the array &lt;code&gt;b&lt;/code&gt; are written to the output stream in order; element &lt;code&gt;b[off]&lt;/code&gt; is the first byte written and &lt;code&gt;b[off+len-1]&lt;/code&gt; is the last byte written by this operation.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 출력 스트림에 씁니다 . &lt;code&gt;write(b, off, len)&lt;/code&gt; 의 일반적인 계약 은 배열 &lt;code&gt;b&lt;/code&gt; 의 일부 바이트 가 순서대로 출력 스트림에 기록된다는 것입니다. 요소 &lt;code&gt;b[off]&lt;/code&gt; 는 기록 된 첫 번째 바이트이고 &lt;code&gt;b[off+len-1]&lt;/code&gt; 은이 연산에 의해 기록 된 마지막 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="c116a4517eaa68fb9db4dc9686e30823cb0481f2" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.</target>
        </trans-unit>
        <trans-unit id="131be3d9bd6c996bc02177007f5a10d152efcafd" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream. This method blocks until all the bytes are written to the output stream.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 파이프 된 출력 스트림에 씁니다 . 이 메소드는 모든 바이트가 출력 스트림에 기록 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="629af15734b4e0f5ce6696e3b16a10fcb7aa816f" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this stream.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this stream.</target>
        </trans-unit>
        <trans-unit id="1cf544354bc9caf492bbe86ef1abd2a2a4934186" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this stream. If automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트 를이 스트림에 씁니다 . 자동 플러싱이 활성화 된 경우 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0325a3c22e720aad80e29d337fb29a1216024c8d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters from the specified character array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; characters from the specified character array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.</target>
        </trans-unit>
        <trans-unit id="f574fcc90500ee21973d3a8593ee72900cccc153" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters from the specified character array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream. This method blocks until all the characters are written to the output stream. If a thread was reading data characters from the connected piped input stream, but the thread is no longer alive, then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">오프셋 &lt;code&gt;off&lt;/code&gt; 에서 시작하여 지정된 문자 배열에서 &lt;code&gt;len&lt;/code&gt; 파이프 문자 를이 파이프 된 출력 스트림에 씁니다 . 이 메소드는 모든 문자가 출력 스트림에 기록 될 때까지 차단됩니다. 스레드가 연결된 파이프 된 입력 스트림에서 데이터 문자를 읽었지만 스레드가 더 이상 &lt;code&gt;IOException&lt;/code&gt; 가 아닌 경우 IOException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f01163c247ccac36f98237d94dc0b5ab8aaa2406" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters of &lt;code&gt;str&lt;/code&gt;, starting at character &lt;code&gt;offset&lt;/code&gt;, to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; represents.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; characters of &lt;code&gt;str&lt;/code&gt; , starting at character &lt;code&gt;offset&lt;/code&gt; , to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; represents.</target>
        </trans-unit>
        <trans-unit id="89daa9fc4ab3d15a77384b157392739823e5c257" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters of &lt;code&gt;str&lt;/code&gt;, starting at character &lt;code&gt;offset&lt;/code&gt;, to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; represents. The string will overwrite the existing characters in the &lt;code&gt;Clob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Clob&lt;/code&gt; value is reached while writing the given string, then the length of the &lt;code&gt;Clob&lt;/code&gt; value will be increased to accommodate the extra characters.</source>
          <target state="translated">Writes &lt;code&gt;len&lt;/code&gt; characters of &lt;code&gt;str&lt;/code&gt; , starting at character &lt;code&gt;offset&lt;/code&gt; , to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; represents. The string will overwrite the existing characters in the &lt;code&gt;Clob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt; . If the end of the &lt;code&gt;Clob&lt;/code&gt; value is reached while writing the given string, then the length of the &lt;code&gt;Clob&lt;/code&gt; value will be increased to accommodate the extra characters.</target>
        </trans-unit>
        <trans-unit id="851de5604a486c60e5125c7a29a7e550895176b8" translate="yes" xml:space="preserve">
          <source>Writes A Portion of an array of characters.</source>
          <target state="translated">문자 배열의 일부를 씁니다.</target>
        </trans-unit>
        <trans-unit id="a283b0703eab7e9782450eee6c79c7aaaa9c7957" translate="yes" xml:space="preserve">
          <source>Writes a 16 bit char.</source>
          <target state="translated">16 비트 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="ca54d5eb5995c8bab76c02647925ee1f9521c712" translate="yes" xml:space="preserve">
          <source>Writes a 16 bit short.</source>
          <target state="translated">16 비트를 짧게 씁니다.</target>
        </trans-unit>
        <trans-unit id="057353e65922065a994b45703b910bf34047ab73" translate="yes" xml:space="preserve">
          <source>Writes a 32 bit float.</source>
          <target state="translated">32 비트 부동 소수점을 씁니다.</target>
        </trans-unit>
        <trans-unit id="c587a1942eeaf8dca64d6b527fb861b258ae3eb4" translate="yes" xml:space="preserve">
          <source>Writes a 32 bit int.</source>
          <target state="translated">32 비트 int를 씁니다.</target>
        </trans-unit>
        <trans-unit id="6071f86794e94e93ef2903e2a285a17fb6ff2270" translate="yes" xml:space="preserve">
          <source>Writes a 64 bit double.</source>
          <target state="translated">64 비트 double을 씁니다.</target>
        </trans-unit>
        <trans-unit id="ff1fe9b0868e3a400b0850e8cb5d3afef880236e" translate="yes" xml:space="preserve">
          <source>Writes a 64 bit long.</source>
          <target state="translated">64 비트 길이를 씁니다.</target>
        </trans-unit>
        <trans-unit id="144135fe6a8176a2fd809e5dce65a41b9d674878" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Blob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;Blob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="c56efcb35978d3f06a812ffb670b34f94389cacc" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Blob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialBlob&lt;/code&gt; SQL &lt;code&gt;BLOB&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;Blob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialBlob&lt;/code&gt; SQL &lt;code&gt;BLOB&lt;/code&gt; value before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="27ea08fa6afe5ea479439001df19499ba21a8430" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Clob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;Clob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="f08e5c41b2c35f3a884d25f9d8a8bfb34ced6103" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Clob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialClob&lt;/code&gt; SQL &lt;code&gt;CLOB&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;Clob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialClob&lt;/code&gt; SQL &lt;code&gt;CLOB&lt;/code&gt; value before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="798be35dcc4f07fd6b0ae715272f89610fd64df1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Ref&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;Ref&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="636814d8cf3b67bf23c99b7f771ee075f88a3374" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Ref&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialRef&lt;/code&gt; SQL &lt;code&gt;REF&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;Ref&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialRef&lt;/code&gt; SQL &lt;code&gt;REF&lt;/code&gt; value before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="7f8faba2a0fd1366ce7b8632168b17391d486b5e" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;String&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;String&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="1d363669fd2b9a7fa973904d4dc302d0c14ca56c" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;String&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;LONGVARCHAR&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;String&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;CHAR&lt;/code&gt; , &lt;code&gt;VARCHAR&lt;/code&gt; , or &lt;code&gt;LONGVARCHAR&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="a3c82abcc2a6031cf5de89c3f40ed0c7b95e4503" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Struct&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;Struct&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="35bce86c88fab81328de73526546c89a47a0e4b2" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Struct&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts this value to an SQL structured type before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;Struct&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts this value to an SQL structured type before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="1fa37549b16c8a2519ce9a3687936f0f07666745" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;boolean&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="61ea925b355afa858794bc3e803f693c259afae1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;boolean&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIT&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="155670a01232f738dceb009105519f94cd2248c1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the file as a one-byte value.</source>
          <target state="translated">Writes a &lt;code&gt;boolean&lt;/code&gt; to the file as a one-byte value.</target>
        </trans-unit>
        <trans-unit id="6349876fc09182b7513e2eb1fd4bd3e55d4b98d6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the file as a one-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. The write starts at the current position of the file pointer.</source>
          <target state="translated">파일에 &lt;code&gt;boolean&lt;/code&gt; 을 1 바이트 값으로 씁니다 . &lt;code&gt;true&lt;/code&gt; 값 은 값 &lt;code&gt;(byte)1&lt;/code&gt; 으로 기록됩니다 . &lt;code&gt;false&lt;/code&gt; 값 은 값 &lt;code&gt;(byte)0&lt;/code&gt; 으로 기록됩니다 . 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="12b530b90dc8d6c34bfe7ce905c795548bb350b9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as a 1-byte value.</source>
          <target state="translated">Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as a 1-byte value.</target>
        </trans-unit>
        <trans-unit id="0cf2d9ed9e1c02ddbe3d89c723dcba2e53e42da9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as a 1-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">기본 출력 스트림에 &lt;code&gt;boolean&lt;/code&gt; 을 1 바이트 값으로 씁니다 . &lt;code&gt;true&lt;/code&gt; 값 은 값 &lt;code&gt;(byte)1&lt;/code&gt; 으로 기록됩니다 . &lt;code&gt;false&lt;/code&gt; 값 은 값 &lt;code&gt;(byte)0&lt;/code&gt; 으로 기록됩니다 . 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;1&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="ccab39520060070dde762a951b5e9f4cef217922" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to the stream.</source>
          <target state="translated">Writes a &lt;code&gt;boolean&lt;/code&gt; value to the stream.</target>
        </trans-unit>
        <trans-unit id="95726257c14b22438de24b52e49b6a02de7eab08" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to the stream. If &lt;code&gt;v&lt;/code&gt; is true, the value &lt;code&gt;(byte)1&lt;/code&gt; is written; if &lt;code&gt;v&lt;/code&gt; is false, the value &lt;code&gt;(byte)0&lt;/code&gt; is written.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 값을 스트림에 씁니다 . 경우 &lt;code&gt;v&lt;/code&gt; 참 값 &lt;code&gt;(byte)1&lt;/code&gt; 기입; 만약 &lt;code&gt;v&lt;/code&gt; 거짓 값 &lt;code&gt;(byte)0&lt;/code&gt; 기입된다.</target>
        </trans-unit>
        <trans-unit id="7954ffaaa34e2883ad4a1325fb8863bb017aa172" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to this output stream.</source>
          <target state="translated">Writes a &lt;code&gt;boolean&lt;/code&gt; value to this output stream.</target>
        </trans-unit>
        <trans-unit id="ab4b1822b1f04ea72708cfe5295251a6c88b3464" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to this output stream. If the argument &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value &lt;code&gt;(byte)1&lt;/code&gt; is written; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the value &lt;code&gt;(byte)0&lt;/code&gt; is written. The byte written by this method may be read by the &lt;code&gt;readBoolean&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;boolean&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">이 출력 스트림에 &lt;code&gt;boolean&lt;/code&gt; 값을 씁니다 . 인수 &lt;code&gt;v&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 값 &lt;code&gt;(byte)1&lt;/code&gt; 이 기록됩니다. 만약 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 값 &lt;code&gt;(byte)0&lt;/code&gt; 기입된다. 이 메소드에 의해 쓰여진 바이트는 &lt;code&gt;DataInput&lt;/code&gt; 인터페이스 의 &lt;code&gt;readBoolean&lt;/code&gt; 메소드에 의해 읽힐 수 있으며 , 그러면 &lt;code&gt;v&lt;/code&gt; 와 동일한 &lt;code&gt;boolean&lt;/code&gt; 값이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc0bdbc304ed1a878f530d104ecb981483b8abc6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;byte&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="d24a0d82e4ec0d4586e61016d6bb4cb55ac02d93" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;byte&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIT&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="226b956afa02c16af4e38b4a4db3a94bf6b32311" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; to the file as a one-byte value.</source>
          <target state="translated">Writes a &lt;code&gt;byte&lt;/code&gt; to the file as a one-byte value.</target>
        </trans-unit>
        <trans-unit id="f2a444c3352131269a2014fd441028ab3058f1b7" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; to the file as a one-byte value. The write starts at the current position of the file pointer.</source>
          <target state="translated">파일에 &lt;code&gt;byte&lt;/code&gt; 를 1 바이트 값으로 씁니다 . 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="a939e11e65fc3a32a69989756481896e92055cac" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the file as a two-byte value, high byte first.</source>
          <target state="translated">Writes a &lt;code&gt;char&lt;/code&gt; to the file as a two-byte value, high byte first.</target>
        </trans-unit>
        <trans-unit id="09a398562bfe5665a5c3cb088f44ff93b0c13218" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the file as a two-byte value, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 를 파일에 2 바이트 값으로 상위 바이트부터 씁니다 . 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7a8024ee2d733a5dde0d484821170eb30275a356" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a 2-byte value, high byte first.</source>
          <target state="translated">Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a 2-byte value, high byte first.</target>
        </trans-unit>
        <trans-unit id="b0f1c2dfbde644fbb6c4c155f32906af8e2ee5c6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a 2-byte value, high byte first. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">기입 &lt;code&gt;char&lt;/code&gt; 2 바이트 값이 먼저 상위 바이트로 기본 출력 스트림. 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;2&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="1bbc6d917ff455c037781056578d00e4f4b388cd" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; value, which is comprised of two bytes, to the output stream.</source>
          <target state="translated">Writes a &lt;code&gt;char&lt;/code&gt; value, which is comprised of two bytes, to the output stream.</target>
        </trans-unit>
        <trans-unit id="e93587e1f09c65fb748c39e365179e015b1c4a2e" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; value, which is comprised of two bytes, to the output stream. The byte values to be written, in the order shown, are:</source>
          <target state="translated">2 바이트로 구성된 &lt;code&gt;char&lt;/code&gt; 값을 출력 스트림에 씁니다 . 표시된 순서대로 기록 될 바이트 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5da554cad4ed11876c2f538fc7a916a28ed5a347" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;double&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="90b842735b4381060da9c4b5e14aac5d144420c4" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;DOUBLE&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;double&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;DOUBLE&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="6bbd7c92457324520d422019ae1f2be3d912115c" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of eight bytes, to the output stream.</source>
          <target state="translated">Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of eight bytes, to the output stream.</target>
        </trans-unit>
        <trans-unit id="f9cf095e7c43223f0750c5a4985360abd3124032" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of eight bytes, to the output stream. It does this as if it first converts this &lt;code&gt;double&lt;/code&gt; value to a &lt;code&gt;long&lt;/code&gt; in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the &lt;code&gt;long&lt;/code&gt; value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt; method. The bytes written by this method may be read by the &lt;code&gt;readDouble&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;double&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">8 바이트로 구성된 &lt;code&gt;double&lt;/code&gt; 값을 출력 스트림에 씁니다 . 마치 &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; 메서드와 같은 방식 으로이 &lt;code&gt;double&lt;/code&gt; 값을 &lt;code&gt;long&lt;/code&gt; 으로 변환 한 다음 &lt;code&gt;writeLong&lt;/code&gt; 메서드 와 정확히 같은 방식으로 &lt;code&gt;long&lt;/code&gt; 값 을 쓰는 것처럼이 작업 을 수행합니다 . 이 메소드에 의해 쓰여진 바이트는 &lt;code&gt;DataInput&lt;/code&gt; 인터페이스 의 &lt;code&gt;readDouble&lt;/code&gt; 메소드에 의해 읽힐 수 있으며 , 그러면 &lt;code&gt;v&lt;/code&gt; 와 동일한 &lt;code&gt;double&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a947a1cfaafe404e203be28b1b2303e0b7c673d7" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</source>
          <target state="translated">Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</target>
        </trans-unit>
        <trans-unit id="a4d147e0e0d772cce4f1c826771d88ee33f93033" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;double&lt;/code&gt; value to a &lt;code&gt;long&lt;/code&gt; in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the long value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt; method.</source>
          <target state="translated">Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;double&lt;/code&gt; value to a &lt;code&gt;long&lt;/code&gt; in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the long value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="74c74f862659641ca760a0b4f5dbfe586ef1a16a" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;double&lt;/code&gt; value to an &lt;code&gt;long&lt;/code&gt; in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the long value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt; method.</source>
          <target state="translated">4 바이트로 구성된 &lt;code&gt;double&lt;/code&gt; 값을 출력 스트림에 씁니다 . 그것은 먼저 변환이 것처럼이 않는 &lt;code&gt;double&lt;/code&gt; 내지 An 값 &lt;code&gt;long&lt;/code&gt; 의 정확히 방식 &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; 용 의 완전히 같은 방법으로 긴 값을 기록하고 다음 방법 &lt;code&gt;writeLong&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="696fcd25e8c07d56053db6ad276a63ec4ce34071" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;float&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="e425d4085560efb681f434759145902b95c308e1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;REAL&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;float&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;REAL&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="b46ad218b9afdb0674da63775c5ae864b605f115" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</source>
          <target state="translated">Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</target>
        </trans-unit>
        <trans-unit id="de7505d5b28cd6dc24eb7936640d871233ddd0a4" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;float&lt;/code&gt; value to an &lt;code&gt;int&lt;/code&gt; in exactly the manner of the &lt;code&gt;Float.floatToIntBits&lt;/code&gt; method and then writes the &lt;code&gt;int&lt;/code&gt; value in exactly the manner of the &lt;code&gt;writeInt&lt;/code&gt; method. The bytes written by this method may be read by the &lt;code&gt;readFloat&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;float&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">4 바이트로 구성된 &lt;code&gt;float&lt;/code&gt; 값을 출력 스트림에 씁니다 . &lt;code&gt;Float.floatToIntBits&lt;/code&gt; 메서드와 같은 방식 으로이 &lt;code&gt;float&lt;/code&gt; 값을 &lt;code&gt;int&lt;/code&gt; 로 변환 한 다음 &lt;code&gt;writeInt&lt;/code&gt; 메서드 와 정확히 같은 방식으로 &lt;code&gt;int&lt;/code&gt; 값 을 쓰는 것처럼이 작업 을 수행합니다 . 이 메소드에 의해 쓰여진 바이트는 &lt;code&gt;DataInput&lt;/code&gt; 인터페이스 의 &lt;code&gt;readFloat&lt;/code&gt; 메소드에 의해 읽힐 수 있습니다. 그러면 &lt;code&gt;v&lt;/code&gt; 와 동일한 &lt;code&gt;float&lt;/code&gt; 가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5bc045873743c0ed400214abeb97588134df17b" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;float&lt;/code&gt; value to an &lt;code&gt;int&lt;/code&gt; in exactly the manner of the &lt;code&gt;Float.floatToIntBits&lt;/code&gt; method and then writes the int value in exactly the manner of the &lt;code&gt;writeInt&lt;/code&gt; method.</source>
          <target state="translated">4 바이트로 구성된 &lt;code&gt;float&lt;/code&gt; 값을 출력 스트림에 씁니다 . &lt;code&gt;Float.floatToIntBits&lt;/code&gt; 메서드와 같은 방식 으로이 &lt;code&gt;float&lt;/code&gt; 값을 &lt;code&gt;int&lt;/code&gt; 로 변환 한 다음 &lt;code&gt;writeInt&lt;/code&gt; 메서드 와 정확히 같은 방식으로 int 값을 쓰는 것처럼이 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c83ea96896ae8f5436a6aaa4859236c2aaf1ffec" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="c4b017c54fe11f7471c30be1a56fe857dd74f0f6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;NUMERIC&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;NUMERIC&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="452031f5ee72921a288236c0b6a26e63a6a7bbc9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="53464c77dc827a0b2303547abdc64eec0dc61db6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;DATE&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;DATE&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="b620918c71921bd543a3ee3ac81b3d78236ed1eb" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Time&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;java.sql.Time&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="55188659110941d98ac08fcc76d1a090d472b2c1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Time&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;TIME&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;java.sql.Time&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;TIME&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="10c24d5b17a0e026c5d7d374aa2559609ace759c" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="a591b58703a67375938736a34ac6cdf53113b82d" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="a7a6c04ca4913bbb6d71dcdb430bdadb44602d6f" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Writes a &lt;code&gt;long&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="a5e41834abe596a0f73b3cafbac1894059f99cb6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIGINT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">Writes a &lt;code&gt;long&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIGINT&lt;/code&gt; before returning it to the database.</target>
        </trans-unit>
        <trans-unit id="8895918fb39b48000205955fa45fde016f0c3d15" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the file as eight bytes, high byte first.</source>
          <target state="translated">Writes a &lt;code&gt;long&lt;/code&gt; to the file as eight bytes, high byte first.</target>
        </trans-unit>
        <trans-unit id="55c528963d4d2b5dc906130b6855614969aa9489" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the file as eight bytes, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">기록 &lt;code&gt;long&lt;/code&gt; 먼저 파일에 여덟 바이트 값을. 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="611eb1e8ef355d7f42537bc6bae8d758ff6c8171" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight bytes, high byte first.</source>
          <target state="translated">Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight bytes, high byte first.</target>
        </trans-unit>
        <trans-unit id="bc6accb6c7c3e908a144c301fc776e1a0598feb1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight bytes, high byte first. In no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;8&lt;/code&gt;.</source>
          <target state="translated">기입 &lt;code&gt;long&lt;/code&gt; 처음 8 바이트 값으로서 기본 출력 스트림. 예외는 발생하지 않으며 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;8&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="6c456969b969a70b0bafd0d849d8758576665b3e" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; value, which is comprised of eight bytes, to the output stream.</source>
          <target state="translated">8 바이트로 구성된 &lt;code&gt;long&lt;/code&gt; 값을 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="90977f382f90c1a5eef7e30f250984dbbf685fc0" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; value, which is comprised of eight bytes, to the output stream. The byte values to be written, in the order shown, are:</source>
          <target state="translated">8 바이트로 구성된 &lt;code&gt;long&lt;/code&gt; 값을 출력 스트림에 씁니다 . 표시된 순서대로 기록 될 바이트 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b73432a8b187a60ddbd8f3ea3cfe32efefece8a" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 대한 &lt;code&gt;short&lt;/code&gt; Java 프로그래밍 언어를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="c54483bbc01a1757da60b9e15f662ba88b52cf5f" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;SMALLINT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 대한 &lt;code&gt;short&lt;/code&gt; Java 프로그래밍 언어를 작성 합니다. 드라이버는이를 데이터베이스로 반환하기 전에 SQL &lt;code&gt;SMALLINT&lt;/code&gt; 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="88192947ad3bae1375cd61982af7c10dfe7bf288" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the file as two bytes, high byte first.</source>
          <target state="translated">기입 &lt;code&gt;short&lt;/code&gt; 처음 두 바이트 값으로서 파일에있다.</target>
        </trans-unit>
        <trans-unit id="08c5c0b7c3097cdebd2722567ae9d781529b69f1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the file as two bytes, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">기입 &lt;code&gt;short&lt;/code&gt; 처음 두 바이트 값으로서 파일에있다. 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="95148813e930a56ec7f9ba7cf377c3af425484b9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two bytes, high byte first.</source>
          <target state="translated">기본 출력 스트림에 &lt;code&gt;short&lt;/code&gt; 를 2 바이트로, 높은 바이트부터 씁니다 .</target>
        </trans-unit>
        <trans-unit id="02db58dd011e754f2707096b88fe2f8be9f657ed" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two bytes, high byte first. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">기입 &lt;code&gt;short&lt;/code&gt; 처음 두 바이트 값으로서 기본 출력 스트림을. 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;2&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="a90364be6749249db375cff460e3c17c03c9bbd9" translate="yes" xml:space="preserve">
          <source>Writes a CData section</source>
          <target state="translated">CData 섹션 작성</target>
        </trans-unit>
        <trans-unit id="df3d8a106b37266209385784427f6dc8189f1133" translate="yes" xml:space="preserve">
          <source>Writes a SQL &lt;code&gt;DATALINK&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;DATALINK&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b458ebbec899f10fb20f20b8b4375124ea3e7e52" translate="yes" xml:space="preserve">
          <source>Writes a String as a sequence of bytes.</source>
          <target state="translated">문자열을 바이트 시퀀스로 씁니다.</target>
        </trans-unit>
        <trans-unit id="afc7866c1825e9380b11088c400178f95a95cdbc" translate="yes" xml:space="preserve">
          <source>Writes a String as a sequence of chars.</source>
          <target state="translated">문자열을 일련의 문자로 씁니다.</target>
        </trans-unit>
        <trans-unit id="c2392262bb2e4275d7538e0294036fdf89687e24" translate="yes" xml:space="preserve">
          <source>Writes a boolean.</source>
          <target state="translated">부울을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f0dab3f9cfd243fc6ebe7043ee7a66237ab74a99" translate="yes" xml:space="preserve">
          <source>Writes a byte to the compressed output stream.</source>
          <target state="translated">압축 된 출력 스트림에 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="c0da5fee9a3c6b16bf35955f5f5c35dce130ca60" translate="yes" xml:space="preserve">
          <source>Writes a byte to the compressed output stream. This method will block until the byte can be written.</source>
          <target state="translated">압축 된 출력 스트림에 바이트를 씁니다. 이 메소드는 바이트를 쓸 수있을 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="9cf89ed21330c27e5aa3cc0f34d382c423419609" translate="yes" xml:space="preserve">
          <source>Writes a byte to the uncompressed output stream.</source>
          <target state="translated">압축되지 않은 출력 스트림에 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="3d47656c06088ca641ef1044e64c889463161b7a" translate="yes" xml:space="preserve">
          <source>Writes a byte.</source>
          <target state="translated">바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="311374422e4c207200ae10ac5f074fff7eabacab" translate="yes" xml:space="preserve">
          <source>Writes a byte. This method will block until the byte is actually written.</source>
          <target state="translated">바이트를 씁니다. 이 메소드는 바이트가 실제로 쓰여질 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="4f8553b815db13b6c88e3d97f9c0023965b0af9c" translate="yes" xml:space="preserve">
          <source>Writes a byte. Will block until the byte is actually written.</source>
          <target state="translated">바이트를 씁니다. 바이트가 실제로 쓰여질 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="5447f774a2ec3a7588ab7fffc585fd0847e17bfa" translate="yes" xml:space="preserve">
          <source>Writes a character to the buffer.</source>
          <target state="translated">버퍼에 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="e7ba7473a4f82684254953fa98bca6d77362c61b" translate="yes" xml:space="preserve">
          <source>Writes a datagram to this channel.</source>
          <target state="translated">이 채널에 데이터 그램을 씁니다.</target>
        </trans-unit>
        <trans-unit id="5efe0d1f19523d7334f9c488613efaa72bee6fd2" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this console's output stream using the specified format string and arguments.</source>
          <target state="translated">지정된 형식 문자열과 인수를 사용하여 형식화 된 문자열을이 콘솔의 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="508af09289f72e03d16ae1e4dd4b7e1a9e501d48" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this object's destination using the specified format string and arguments.</source>
          <target state="translated">지정된 형식 문자열 및 인수를 사용하여 형식화 된 문자열을이 개체의 대상에 씁니다.</target>
        </trans-unit>
        <trans-unit id="0a45e7a61a42a1faa620f3d8e59e1e8f0e6e5cc2" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this object's destination using the specified format string and arguments. The locale used is the one defined during the construction of this formatter.</source>
          <target state="translated">지정된 형식 문자열과 인수를 사용하여 형식화 된 문자열을이 객체의 대상에 씁니다. 사용 된 로케일은이 포맷터 구성 중에 정의 된 로케일입니다.</target>
        </trans-unit>
        <trans-unit id="b64a4a6ece44814969f921375d7b1535d8bf355a" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this object's destination using the specified locale, format string, and arguments.</source>
          <target state="translated">지정된 로케일, 형식 문자열 및 인수를 사용하여 형식화 된 문자열을이 객체의 대상에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ff42503cbe9f3786576fcf934db44ca1703f1239" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this output stream using the specified format string and arguments.</source>
          <target state="translated">지정된 형식 문자열과 인수를 사용하여 형식화 된 문자열을이 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="684abf86f0ae0bf9ca4893fa8d75709f881ea701" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this writer using the specified format string and arguments.</source>
          <target state="translated">지정된 형식 문자열 및 인수를 사용하여 형식화 된 문자열을이 작성기에 씁니다.</target>
        </trans-unit>
        <trans-unit id="df82bdd3d3608dc3ca77522fb3a2ccea02508a72" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this writer using the specified format string and arguments. If automatic flushing is enabled, calls to this method will flush the output buffer.</source>
          <target state="translated">지정된 형식 문자열과 인수를 사용하여 형식화 된 문자열을이 작성기에 기록합니다. 자동 플러시가 활성화 된 경우이 메서드를 호출하면 출력 버퍼가 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="17ff8b03f28f8652982d3549e1d470d8e0fa7304" translate="yes" xml:space="preserve">
          <source>Writes a line separator.</source>
          <target state="translated">줄 구분 기호를 씁니다.</target>
        </trans-unit>
        <trans-unit id="e2cc625afc6e32e0218832c9bab473756248e92a" translate="yes" xml:space="preserve">
          <source>Writes a line separator. The line separator string is defined by the system property &lt;code&gt;line.separator&lt;/code&gt;, and is not necessarily a single newline ('\n') character.</source>
          <target state="translated">줄 구분자를 씁니다. 행 구분자 문자열은 시스템 특성 &lt;code&gt;line.separator&lt;/code&gt; 에 의해 정의되며 반드시 단일 개행 ( ​​'\ n') 문자 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="27e81462b6e6b65223f5d2486f4dfbf626128a46" translate="yes" xml:space="preserve">
          <source>Writes a namespace to the output stream If the prefix argument to this method is the empty string, &quot;xmlns&quot;, or null this method will delegate to writeDefaultNamespace</source>
          <target state="translated">출력 스트림에 네임 스페이스를 씁니다.이 메서드의 접두사 인수가 빈 문자열, &quot;xmlns&quot;또는 null 인 경우이 메서드는 writeDefaultNamespace에 위임합니다.</target>
        </trans-unit>
        <trans-unit id="3ea473561fce7d15d0a8632a6efe064700e72fc5" translate="yes" xml:space="preserve">
          <source>Writes a packet to the target VM.</source>
          <target state="translated">대상 VM에 패킷을 씁니다.</target>
        </trans-unit>
        <trans-unit id="e06d1baf2766748f705a9ec924d45f761ff2e183" translate="yes" xml:space="preserve">
          <source>Writes a portion of a String.</source>
          <target state="translated">문자열의 일부를 씁니다.</target>
        </trans-unit>
        <trans-unit id="f72fbef395487327da1536d1995e28bc5cf9fb4c" translate="yes" xml:space="preserve">
          <source>Writes a portion of a string.</source>
          <target state="translated">문자열의 일부를 씁니다.</target>
        </trans-unit>
        <trans-unit id="56b0793b26c4a0f3cdcde22d46d24b35623bc380" translate="yes" xml:space="preserve">
          <source>Writes a portion of an array of characters.</source>
          <target state="translated">문자 배열의 일부를 씁니다.</target>
        </trans-unit>
        <trans-unit id="07fcbd7544ddeccee9b06f0cd837cd28b8435c95" translate="yes" xml:space="preserve">
          <source>Writes a processing instruction</source>
          <target state="translated">처리 명령을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="502ed5705e51254c59ad06919f6929d8c661179e" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bits, given by the &lt;code&gt;numBits&lt;/code&gt; least significant bits of the &lt;code&gt;bits&lt;/code&gt; argument in left-to-right order, to the stream at the current bit offset within the current byte position.</source>
          <target state="translated">왼쪽에서 오른쪽 순서로 &lt;code&gt;bits&lt;/code&gt; 인수 의 &lt;code&gt;numBits&lt;/code&gt; 최하위 비트로 지정된 비트 시퀀스를 현재 바이트 위치 내의 현재 비트 오프셋에있는 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7238cdbf395d0c16e058e39542beedf0196e6462" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bits, given by the &lt;code&gt;numBits&lt;/code&gt; least significant bits of the &lt;code&gt;bits&lt;/code&gt; argument in left-to-right order, to the stream at the current bit offset within the current byte position. The upper &lt;code&gt;64 - numBits&lt;/code&gt; bits of the argument are ignored. The bit offset is advanced by &lt;code&gt;numBits&lt;/code&gt; and reduced modulo 8. Note that a bit offset of 0 always indicates the most-significant bit of the byte, and bytes of bits are written out in sequence as they are encountered. Thus bit writes are always effectively in network byte order. The actual stream byte order setting is ignored.</source>
          <target state="translated">왼쪽에서 오른쪽으로 &lt;code&gt;bits&lt;/code&gt; 인수 의 &lt;code&gt;numBits&lt;/code&gt; 최하위 비트에 의해 주어진 비트 시퀀스를 현재 바이트 위치 내의 현재 비트 오프셋에서 스트림에 씁니다 . 인수 의 상위 &lt;code&gt;64 - numBits&lt;/code&gt; 비트는 무시됩니다. 비트 오프셋은 &lt;code&gt;numBits&lt;/code&gt; 및 감소 된 모듈로 8에 의해 진행됩니다 . 비트 오프셋 0은 항상 바이트의 최상위 비트를 나타내며 비트 바이트는 발생하는 순서대로 기록됩니다. 따라서 비트 쓰기는 항상 네트워크 바이트 순서로 효과적으로 이루어집니다. 실제 스트림 바이트 순서 설정은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="314d6e211d9795052649ceb03da878a72709c282" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 바이트 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="190c55636cfdf74b2ffb6a71ed2f57d50aeccf84" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to the stream at the current position. If &lt;code&gt;b.length&lt;/code&gt; is 0, nothing is written. The byte &lt;code&gt;b[0]&lt;/code&gt; is written first, then the byte &lt;code&gt;b[1]&lt;/code&gt;, and so on.</source>
          <target state="translated">현재 위치에서 스트림에 바이트 시퀀스를 씁니다. 경우 &lt;code&gt;b.length&lt;/code&gt; 를가 0, 아무것도 기입하지 않습니다. 바이트 &lt;code&gt;b[0]&lt;/code&gt; 이 먼저 기록 된 다음 바이트 &lt;code&gt;b[1]&lt;/code&gt; 등이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2235f3a78e2b1cb2ccd3a4168c479386e4f14d39" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The byte &lt;code&gt;b[off]&lt;/code&gt; is written first, then the byte &lt;code&gt;b[off + 1]&lt;/code&gt;, and so on.</source>
          <target state="translated">현재 위치에서 스트림에 바이트 시퀀스를 씁니다. 경우 &lt;code&gt;len&lt;/code&gt; 0, 아무것도 기입하지 않습니다. 바이트 &lt;code&gt;b[off]&lt;/code&gt; 가 먼저 기록 된 다음 바이트 &lt;code&gt;b[off + 1]&lt;/code&gt; 등이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="998e981037032866593747f4cad33ac3eb0066f8" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from a subsequence of the given buffers.</source>
          <target state="translated">주어진 버퍼의 서브 시퀀스로부터이 채널에 일련의 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="df42d642ba05e494d2cc831543ce9f23be20461b" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from a subsequence of the given buffers. This operation, sometimes called a &lt;em&gt;gathering write&lt;/em&gt;, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The &lt;code&gt;handler&lt;/code&gt; parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written.</source>
          <target state="translated">주어진 버퍼의 서브 시퀀스로부터이 채널에 일련의 바이트를 씁니다. &lt;em&gt;수집 쓰기&lt;/em&gt; 라고도하는이 작업 은 데이터를 하나 이상의 고정 길이 헤더와 가변 길이 본문으로 구성된 세그먼트로 그룹화하는 네트워크 프로토콜을 구현할 때 종종 유용합니다. &lt;code&gt;handler&lt;/code&gt; 파라미터는 기록 동작이 완료 (또는 실패) 때 호출되는 핸들러가 완료된다. 완료 핸들러에 전달 된 결과는 쓴 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="02441dac40077efefece8a0e55188a3959f39c79" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from the given buffer, starting at the given file position.</source>
          <target state="translated">주어진 파일 위치에서 시작하여 주어진 버퍼에서이 채널에 바이트 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="4b2b6d5918fe10f4267a0ae46ec7f71362fad27f" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from the given buffer.</source>
          <target state="translated">주어진 버퍼에서이 채널에 일련의 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="41853481b79dd7251b056000a101757ebc59a7f7" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from the given buffers.</source>
          <target state="translated">주어진 버퍼에서이 채널에 일련의 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="59c5ccb857f9bc25462065a57d0ce514fa8bf281" translate="yes" xml:space="preserve">
          <source>Writes a sequence of chars to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 문자 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="25372ececa06540883487ffc569630583f3356c4" translate="yes" xml:space="preserve">
          <source>Writes a sequence of chars to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The char &lt;code&gt;c[off]&lt;/code&gt; is written first, then the char &lt;code&gt;c[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">현재 위치의 스트림에 일련의 문자를 씁니다. 경우 &lt;code&gt;len&lt;/code&gt; 0, 아무것도 기입하지 않습니다. char &lt;code&gt;c[off]&lt;/code&gt; 가 먼저 작성된 다음 char &lt;code&gt;c[off + 1]&lt;/code&gt; 등이 작성됩니다. 스트림의 바이트 순서는 개별 바이트가 기록되는 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3d4937205bb517a2764876ca8d0ce3625add0c" translate="yes" xml:space="preserve">
          <source>Writes a sequence of doubles to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 double 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b8d73713479b20f3c0e88b9a7d06d7681fdd8c40" translate="yes" xml:space="preserve">
          <source>Writes a sequence of doubles to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The double &lt;code&gt;d[off]&lt;/code&gt; is written first, then the double &lt;code&gt;d[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">현재 위치의 스트림에 복열 시퀀스를 씁니다. 경우 &lt;code&gt;len&lt;/code&gt; 0, 아무것도 기입하지 않습니다. 이중 &lt;code&gt;d[off]&lt;/code&gt; 가 먼저 기록 된 다음 이중 &lt;code&gt;d[off + 1]&lt;/code&gt; 등이 기록됩니다. 스트림의 바이트 순서는 개별 바이트가 기록되는 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="446789ef076930615fe1f5c41aac52f13cc1cee0" translate="yes" xml:space="preserve">
          <source>Writes a sequence of floats to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 부동 소수점 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="ee5692e375b6806782e1c51563426dd418bee68f" translate="yes" xml:space="preserve">
          <source>Writes a sequence of floats to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The float &lt;code&gt;f[off]&lt;/code&gt; is written first, then the float &lt;code&gt;f[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">현재 위치에서 스트림에 float 시퀀스를 씁니다. 경우 &lt;code&gt;len&lt;/code&gt; 0, 아무것도 기입하지 않습니다. float &lt;code&gt;f[off]&lt;/code&gt; 가 먼저 기록 된 다음 float &lt;code&gt;f[off + 1]&lt;/code&gt; 등이 기록됩니다. 스트림의 바이트 순서는 개별 바이트가 기록되는 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de705ba6a174586a9c837cd917c5bd44f25429f8" translate="yes" xml:space="preserve">
          <source>Writes a sequence of ints to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 int 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="2e22e143b7aa537e10aa473bc7180b02b29a9e27" translate="yes" xml:space="preserve">
          <source>Writes a sequence of ints to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The int &lt;code&gt;i[off]&lt;/code&gt; is written first, then the int &lt;code&gt;i[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">현재 위치의 스트림에 int 시퀀스를 씁니다. 경우 &lt;code&gt;len&lt;/code&gt; 0, 아무것도 기입하지 않습니다. int &lt;code&gt;i[off]&lt;/code&gt; 가 먼저 작성된 다음 int &lt;code&gt;i[off + 1]&lt;/code&gt; 등이 기록됩니다. 스트림의 바이트 순서는 개별 바이트가 기록되는 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69c5aaa383ce6ea26910c68605710771e3d57380" translate="yes" xml:space="preserve">
          <source>Writes a sequence of longs to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 long 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="8f619dc03c935ddbc5713f176006c9051deaeab8" translate="yes" xml:space="preserve">
          <source>Writes a sequence of longs to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The long &lt;code&gt;l[off]&lt;/code&gt; is written first, then the long &lt;code&gt;l[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">현재 위치에서 스트림에 long 시퀀스를 씁니다. 경우 &lt;code&gt;len&lt;/code&gt; 0, 아무것도 기입하지 않습니다. long &lt;code&gt;l[off]&lt;/code&gt; 가 먼저 기록 된 다음 long &lt;code&gt;l[off + 1]&lt;/code&gt; 등이 기록됩니다. 스트림의 바이트 순서는 개별 바이트가 기록되는 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e2827725195f2c36013b35ab2dccbe6663b69f6" translate="yes" xml:space="preserve">
          <source>Writes a sequence of shorts to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 단락 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b21ca2f4d5f95b31acfd2f5bbc0ce005cc3a5fb6" translate="yes" xml:space="preserve">
          <source>Writes a sequence of shorts to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The short &lt;code&gt;s[off]&lt;/code&gt; is written first, then the short &lt;code&gt;s[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">현재 위치에서 스트림에 일련의 단락을 씁니다. 경우 &lt;code&gt;len&lt;/code&gt; 0, 아무것도 기입하지 않습니다. 짧은 &lt;code&gt;s[off]&lt;/code&gt; 가 먼저 기록 된 다음 짧은 &lt;code&gt;s[off + 1]&lt;/code&gt; 등이 기록됩니다. 스트림의 바이트 순서는 개별 바이트가 기록되는 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e25011a9c8fdafeb10663081e9d168f9a6cefb9" translate="yes" xml:space="preserve">
          <source>Writes a set of attributes to the given object stream for the purpose of serialization.</source>
          <target state="translated">직렬화를 위해 지정된 개체 스트림에 특성 집합을 씁니다.</target>
        </trans-unit>
        <trans-unit id="9b3b3b853ce10c9f53ce13bee2be516282c111c7" translate="yes" xml:space="preserve">
          <source>Writes a set of attributes to the given object stream for the purpose of serialization. This will take special care to deal with static attribute keys that have been registered wit the &lt;code&gt;registerStaticAttributeKey&lt;/code&gt; method. Any attribute key not registered as a static key will be serialized directly. All values are expected to be serializable.</source>
          <target state="translated">직렬화를 위해 지정된 개체 스트림에 특성 집합을 씁니다. 이는 &lt;code&gt;registerStaticAttributeKey&lt;/code&gt; 메소드에 등록 된 정적 속성 키를 처리하는 데 특별한주의를 기울 입니다. 정적 키로 등록되지 않은 속성 키는 직접 직렬화됩니다. 모든 값은 직렬화 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3cbf0c42aabe7ea4836e02acdffa16497650e0c" translate="yes" xml:space="preserve">
          <source>Writes a single bit, given by the least significant bit of the argument, to the stream at the current bit offset within the current byte position.</source>
          <target state="translated">인수의 최하위 비트로 지정된 단일 비트를 현재 바이트 위치 내의 현재 비트 오프셋에있는 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7b943c58e32fcea952a5a176b2b64b74481ec8ac" translate="yes" xml:space="preserve">
          <source>Writes a single bit, given by the least significant bit of the argument, to the stream at the current bit offset within the current byte position. The upper 31 bits of the argument are ignored. The given bit replaces the previous bit at that position. The bit offset is advanced by one and reduced modulo 8.</source>
          <target state="translated">인수의 최하위 비트가 제공하는 단일 비트를 현재 바이트 위치 내의 현재 비트 오프셋에서 스트림에 씁니다. 인수의 상위 31 비트는 무시됩니다. 주어진 비트는 해당 위치에서 이전 비트를 대체합니다. 비트 오프셋은 1로 감소되고 모듈로 8이 감소합니다.</target>
        </trans-unit>
        <trans-unit id="001052a859bb1446c0fd19a7d0140fd8e78c87da" translate="yes" xml:space="preserve">
          <source>Writes a single byte to the stream at the current position.</source>
          <target state="translated">현재 위치의 스트림에 단일 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="4d25d450c91f1b954e5d3226b5eb0d63eb9f3de1" translate="yes" xml:space="preserve">
          <source>Writes a single byte to the stream at the current position. The 24 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.</source>
          <target state="translated">현재 위치에서 스트림에 단일 바이트를 씁니다. &lt;code&gt;b&lt;/code&gt; 의 24 개 상위 비트 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="664dba2ff2df999d8a27b0049a85c61d9db7e29f" translate="yes" xml:space="preserve">
          <source>Writes a single character.</source>
          <target state="translated">단일 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="f933296edffab5638d15f828802522dc84897cf3" translate="yes" xml:space="preserve">
          <source>Writes a single character. The character to be written is contained in the 16 low-order bits of the given integer value; the 16 high-order bits are ignored.</source>
          <target state="translated">단일 문자를 씁니다. 기록 될 문자는 주어진 정수 값의 하위 16 비트 비트에 포함됩니다. 16 개의 상위 비트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="358e1ae6ec30a51046bb824cdc45a4602b363152" translate="yes" xml:space="preserve">
          <source>Writes a start tag to the output</source>
          <target state="translated">출력에 시작 태그를 씁니다.</target>
        </trans-unit>
        <trans-unit id="49bd4c043b641203f67a25a8faaedf06ff7164e9" translate="yes" xml:space="preserve">
          <source>Writes a start tag to the output.</source>
          <target state="translated">출력에 시작 태그를 씁니다.</target>
        </trans-unit>
        <trans-unit id="75052e90a50a88eddb0c2fcd32eec44274289114" translate="yes" xml:space="preserve">
          <source>Writes a start tag to the output. All writeStartElement methods open a new scope in the internal namespace context. Writing the corresponding EndElement causes the scope to be closed.</source>
          <target state="translated">출력에 시작 태그를 씁니다. 모든 writeStartElement 메서드는 내부 네임 스페이스 컨텍스트에서 새 범위를 엽니 다. 해당 EndElement를 작성하면 범위가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="8e408c44ea4aa78ea372d668a61e9a79e9878cfa" translate="yes" xml:space="preserve">
          <source>Writes a stream of ASCII characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트 에 ASCII 문자 스트림을 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="0c35566fb936fe3c434bc325013cef4ac2fd2d64" translate="yes" xml:space="preserve">
          <source>Writes a stream of ASCII characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver will do any necessary conversion from ASCII to the database &lt;code&gt;CHAR&lt;/code&gt; format.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트 에 ASCII 문자 스트림을 기록 합니다. 드라이버는 ASCII에서 데이터베이스 &lt;code&gt;CHAR&lt;/code&gt; 형식으로 필요한 모든 변환을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="a8d35bd84279b6609e622d6ab06f4beb72906404" translate="yes" xml:space="preserve">
          <source>Writes a stream of Unicode characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트 에 유니 코드 문자 스트림을 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="103c70c642901a5a9a51a3605fe74dc57e1fabd2" translate="yes" xml:space="preserve">
          <source>Writes a stream of Unicode characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트 에 유니 코드 문자 스트림을 기록 합니다. 드라이버는 유니 코드에서 데이터베이스 &lt;code&gt;CHAR&lt;/code&gt; 형식으로 필요한 모든 변환을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="df213335179c5ed8ca6afe71e0677d7424da6195" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a MIDI file of the file type indicated to the external file provided.</source>
          <target state="translated">제공된 외부 파일에 표시된 파일 형식의 MIDI 파일을 나타내는 바이트 스트림을 씁니다.</target>
        </trans-unit>
        <trans-unit id="e8a5f176816806a6fbca88570a3f6372ece24192" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a MIDI file of the file type indicated to the output stream provided.</source>
          <target state="translated">제공된 출력 스트림에 표시된 파일 형식의 MIDI 파일을 나타내는 바이트 스트림을 씁니다.</target>
        </trans-unit>
        <trans-unit id="d0e751b02c4917e9384d9893ee2785bf31c7eb4d" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a file of the MIDI file type indicated to the external file provided.</source>
          <target state="translated">제공된 외부 파일에 표시된 MIDI 파일 형식의 파일을 나타내는 바이트 스트림을 씁니다.</target>
        </trans-unit>
        <trans-unit id="68b7db83aee7a60d72e213514b372c08156d7b87" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a file of the MIDI file type indicated to the output stream provided.</source>
          <target state="translated">제공된 출력 스트림에 표시된 MIDI 파일 형식의 파일을 나타내는 바이트 스트림을 씁니다.</target>
        </trans-unit>
        <trans-unit id="9036acda052c4911938040861a1e300f1ef2410e" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file format indicated to the external file provided.</source>
          <target state="translated">제공된 외부 파일에 표시된 파일 형식의 오디오 파일을 나타내는 바이트 스트림을 씁니다.</target>
        </trans-unit>
        <trans-unit id="6fb88014c7ccd9861b8e71915804360144829a00" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file type indicated to the output stream provided.</source>
          <target state="translated">제공된 출력 스트림에 표시된 파일 유형의 오디오 파일을 나타내는 바이트 스트림을 씁니다.</target>
        </trans-unit>
        <trans-unit id="9ddecea0d160b45426ce4e501d8df92507ba73a8" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file type indicated to the output stream provided. Some file types require that the length be written into the file header, and cannot be written from start to finish unless the length is known in advance. An attempt to write such a file type will fail with an &lt;code&gt;IOException&lt;/code&gt; if the length in the audio file format is &lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt;&lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 출력 스트림에 표시된 파일 유형의 오디오 파일을 나타내는 바이트 스트림을 씁니다. 일부 파일 유형은 길이를 파일 헤더에 기록해야하며 길이를 미리 알고 있지 않으면 처음부터 끝까지 기록 할 수 없습니다. 오디오 파일 형식의 길이가 &lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt; &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; 인&lt;/a&gt; 경우 이러한 파일 유형을 작성하려는 시도는 &lt;code&gt;IOException&lt;/code&gt; 과 함께 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="b61ebe87fae82a3f3e78f56158a3a4c202901a7e" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file type indicated to the output stream provided. Some file types require that the length be written into the file header, and cannot be written from start to finish unless the length is known in advance. An attempt to write such a file type will fail with an IOException if the length in the audio file format is &lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt;&lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 출력 스트림에 표시된 파일 유형의 오디오 파일을 나타내는 바이트 스트림을 씁니다. 일부 파일 유형에서는 길이를 파일 헤더에 기록해야하며 길이를 미리 알지 못하면 처음부터 끝까지 기록 할 수 없습니다. 오디오 파일 형식의 길이가 &lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt; &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; 인&lt;/a&gt; 경우 이러한 파일 형식을 쓰려는 시도는 IOException으로 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f0adc20f1af94af22a8e4d67c6778209fd2469" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the external file provided.</source>
          <target state="translated">지정된 파일 형식의 오디오 파일을 나타내는 바이트 스트림을 제공된 외부 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="5347af5a0d11f28a81ca89b06b58fba3a2384a75" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the output stream provided.</source>
          <target state="translated">지정된 파일 형식의 오디오 파일을 나타내는 바이트 스트림을 제공된 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="6c3e579ee5254986120d6bd885e12ecea3e2510c" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the output stream provided. Some file types require that the length be written into the file header; such files cannot be written from start to finish unless the length is known in advance. An attempt to write a file of such a type will fail with an &lt;code&gt;IOException&lt;/code&gt; if the length in the audio file type is &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;.</source>
          <target state="translated">지정된 파일 형식의 오디오 파일을 나타내는 바이트 스트림을 제공된 출력 스트림에 씁니다. 일부 파일 유형은 길이를 파일 헤더에 기록해야합니다. 이러한 파일은 길이를 미리 알고 있지 않으면 처음부터 끝까지 쓸 수 없습니다. 오디오 파일 유형의 길이가 &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; 인 경우 이러한 유형의 파일 쓰기 시도는 &lt;code&gt;IOException&lt;/code&gt; 과 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="457626ec7057ea1509e697c0d5f9754010afd06b" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the output stream provided. Some file types require that the length be written into the file header; such files cannot be written from start to finish unless the length is known in advance. An attempt to write a file of such a type will fail with an IOException if the length in the audio file type is &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;.</source>
          <target state="translated">지정된 파일 형식의 오디오 파일을 나타내는 바이트 스트림을 제공된 출력 스트림에 씁니다. 일부 파일 유형에서는 파일 헤더에 길이를 기록해야합니다. 길이를 미리 알고 있지 않으면 이러한 파일을 처음부터 끝까지 쓸 수 없습니다. 오디오 파일 형식의 길이가 &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; 인 경우 이러한 형식의 파일을 쓰려는 시도는 IOException과 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="d764e9d1a1cb8b672089bc62810766169a891d6b" translate="yes" xml:space="preserve">
          <source>Writes a stream of uninterpreted bytes to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">해석되지 않은 바이트의 스트림을이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="0603b3d486c3582197330dfc0883ac877fa7af38" translate="yes" xml:space="preserve">
          <source>Writes a string to the file as a sequence of characters.</source>
          <target state="translated">문자열을 일련의 문자로 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="cbfebbe442291a3e8e465b80272932906f7ed4fb" translate="yes" xml:space="preserve">
          <source>Writes a string to the file as a sequence of characters. Each character is written to the data output stream as if by the &lt;code&gt;writeChar&lt;/code&gt; method. The write starts at the current position of the file pointer.</source>
          <target state="translated">문자열을 파일에 일련의 문자로 씁니다. 각 문자는 &lt;code&gt;writeChar&lt;/code&gt; 메소드에 의해 데이터 출력 스트림에 기록됩니다 . 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="b63ac37afa3c7e30a7ec3f4bba3342bb93883711" translate="yes" xml:space="preserve">
          <source>Writes a string to the file using &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; encoding in a machine-independent manner.</source>
          <target state="translated">기계 독립적 인 방식으로 &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;수정 된 UTF-8&lt;/a&gt; 인코딩을 사용하여 파일에 문자열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b0ca487aa3c16ea83ab86aed17493dcc33edb03f" translate="yes" xml:space="preserve">
          <source>Writes a string to the output stream.</source>
          <target state="translated">출력 스트림에 문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="2d6f810066617d11d6cb068e9ebc2b6257515d4f" translate="yes" xml:space="preserve">
          <source>Writes a string to the output stream. For every character in the string &lt;code&gt;s&lt;/code&gt;, taken in order, one byte is written to the output stream. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">출력 스트림에 문자열을 씁니다. 문자열 &lt;code&gt;s&lt;/code&gt; 의 모든 문자에 대해 순서대로 1 바이트가 출력 스트림에 기록됩니다. 경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bc2a7fd94389452a3c96d490dbd418c7fc0f9085" translate="yes" xml:space="preserve">
          <source>Writes a string to the output stream. For every character in the string &lt;code&gt;s&lt;/code&gt;, taken in order, two bytes are written to the output stream, ordered according to the current byte order setting. If network byte order is being used, the high-order byte is written first; the order is reversed otherwise. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">출력 스트림에 문자열을 씁니다. 문자열 &lt;code&gt;s&lt;/code&gt; 의 모든 문자를 순서대로 취하면 현재 바이트 순서 설정에 따라 2 바이트가 출력 스트림에 기록됩니다. 네트워크 바이트 순서가 사용되는 경우 상위 바이트가 먼저 기록됩니다. 그렇지 않으면 순서가 반대로됩니다. 경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0718eb4fd31a016094bf9fb2c14b92e5e34e810c" translate="yes" xml:space="preserve">
          <source>Writes a string to the underlying output stream as a sequence of characters.</source>
          <target state="translated">문자열을 문자 시퀀스로 기본 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ea2333de6bb14f6753c8467ddb361808ddce3a17" translate="yes" xml:space="preserve">
          <source>Writes a string to the underlying output stream as a sequence of characters. Each character is written to the data output stream as if by the &lt;code&gt;writeChar&lt;/code&gt; method. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by twice the length of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">문자열을 기본 출력 스트림에 일련의 문자로 씁니다. 각 문자는 &lt;code&gt;writeChar&lt;/code&gt; 메소드에 의해 데이터 출력 스트림에 기록됩니다 . 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;s&lt;/code&gt; 길이의 두 배 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="d1f60a0c985ee3c99884db52d5d00830332832d9" translate="yes" xml:space="preserve">
          <source>Writes a string to the underlying output stream using &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; encoding in a machine-independent manner.</source>
          <target state="translated">기계 독립적 인 방식으로 &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;수정 된 UTF-8&lt;/a&gt; 인코딩을 사용하여 기본 출력 스트림에 문자열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="11a73af4769d2fa84714761c91018f9161b700b9" translate="yes" xml:space="preserve">
          <source>Writes a string.</source>
          <target state="translated">문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="5a1953b8b9d27d19a7b5afed0358700c0f0015e7" translate="yes" xml:space="preserve">
          <source>Writes a string. This method cannot be inherited from the Writer class because it must suppress I/O exceptions.</source>
          <target state="translated">문자열을 씁니다. 이 메소드는 I / O 예외를 억제해야하므로 Writer 클래스에서 상속 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb6ba0073288a7f37d493353625aab60dc1fed80" translate="yes" xml:space="preserve">
          <source>Writes a sub array of bytes.</source>
          <target state="translated">바이트의 하위 배열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f22826c17e01b8bd59b4c5796200d64c603fcf1a" translate="yes" xml:space="preserve">
          <source>Writes all bytes from the specified byte array to this stream.</source>
          <target state="translated">지정된 바이트 배열의 모든 바이트를이 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="8803c2d78bed399e9ad588006376c473344e3347" translate="yes" xml:space="preserve">
          <source>Writes all bytes from the specified byte array to this stream. If automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.</source>
          <target state="translated">지정된 바이트 배열의 모든 바이트를이 스트림에 씁니다. 자동 플러시가 활성화 된 경우 &lt;code&gt;flush&lt;/code&gt; 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a0df9dc457ff568fd4c4f2c296551eeed0d5de99" translate="yes" xml:space="preserve">
          <source>Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents and returns the number of bytes written.</source>
          <target state="translated">이 &lt;code&gt;Blob&lt;/code&gt; 개체가 나타내는 &lt;code&gt;BLOB&lt;/code&gt; 값에 지정된 &lt;code&gt;byte&lt;/code&gt; 배열 의 전체 또는 일부를 쓰고 쓴 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3916c44b0f32a0be157b07e40b36b95460d2286" translate="yes" xml:space="preserve">
          <source>Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents and returns the number of bytes written. Writing starts at position &lt;code&gt;pos&lt;/code&gt; in the &lt;code&gt;BLOB&lt;/code&gt; value;</source>
          <target state="translated">이 &lt;code&gt;Blob&lt;/code&gt; 개체가 나타내는 &lt;code&gt;BLOB&lt;/code&gt; 값에 지정된 &lt;code&gt;byte&lt;/code&gt; 배열 의 전체 또는 일부를 쓰고 쓴 바이트 수를 반환합니다. 쓰기는 &lt;code&gt;BLOB&lt;/code&gt; 값의 &lt;code&gt;pos&lt;/code&gt; 위치 에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ba3884f1c2a43aa01130052e714b962961fe375" translate="yes" xml:space="preserve">
          <source>Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents and returns the number of bytes written. Writing starts at position &lt;code&gt;pos&lt;/code&gt; in the &lt;code&gt;BLOB&lt;/code&gt; value; &lt;code&gt;len&lt;/code&gt; bytes from the given byte array are written. The array of bytes will overwrite the existing bytes in the &lt;code&gt;Blob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Blob&lt;/code&gt; value is reached while writing the array of bytes, then the length of the &lt;code&gt;Blob&lt;/code&gt; value will be increased to accommodate the extra bytes.</source>
          <target state="translated">이 &lt;code&gt;Blob&lt;/code&gt; 개체가 나타내는 &lt;code&gt;BLOB&lt;/code&gt; 값에 지정된 &lt;code&gt;byte&lt;/code&gt; 배열 의 전체 또는 일부를 쓰고 쓴 바이트 수를 반환합니다. 쓰기는 &lt;code&gt;BLOB&lt;/code&gt; 값의 &lt;code&gt;pos&lt;/code&gt; 위치 에서 시작됩니다 . 주어진 바이트 배열에서 &lt;code&gt;len&lt;/code&gt; 바이트가 기록됩니다. 바이트 배열은 &lt;code&gt;pos&lt;/code&gt; 위치에서 시작 하는 &lt;code&gt;Blob&lt;/code&gt; 객체 의 기존 바이트를 덮어 씁니다 . 바이트 배열을 쓰는 동안 &lt;code&gt;Blob&lt;/code&gt; 값 의 끝에 도달 하면 추가 바이트를 수용하기 위해 &lt;code&gt;Blob&lt;/code&gt; 값 의 길이 가 늘어납니다.</target>
        </trans-unit>
        <trans-unit id="8600843172fc5ab2a734a9e588ad884c7079c4af" translate="yes" xml:space="preserve">
          <source>Writes an &quot;unshared&quot; object to the ObjectOutputStream.</source>
          <target state="translated">ObjectOutputStream에 &quot;비공유&quot;개체를 씁니다.</target>
        </trans-unit>
        <trans-unit id="3f4a23d3b350bf5bfadf2b639abb0bdae3bb550b" translate="yes" xml:space="preserve">
          <source>Writes an &quot;unshared&quot; object to the ObjectOutputStream. This method is identical to writeObject, except that it always writes the given object as a new, unique object in the stream (as opposed to a back-reference pointing to a previously serialized instance). Specifically:</source>
          <target state="translated">&quot;공유되지 않은&quot;객체를 ObjectOutputStream에 씁니다. 이 메소드는 지정된 객체를 항상 스트림에 새로운 고유 한 객체로 기록한다는 점을 제외하면 writeObject와 동일합니다 (이전의 직렬화 된 인스턴스를 가리키는 역 참조가 아님). 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="1740f6f71c4cd03887821da91243ca075fe07b7b" translate="yes" xml:space="preserve">
          <source>Writes an 8 bit byte.</source>
          <target state="translated">8 비트 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="6c180c959eabf9437bdf6b923f53cbff4e46e305" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;Array&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 Java 프로그래밍 언어로 된 &lt;code&gt;Array&lt;/code&gt; 오브젝트를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="25811b29146a7e96216cf995ac952bf827c6c7d1" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;Array&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts this value to a serializable &lt;code&gt;SerialArray&lt;/code&gt; SQL &lt;code&gt;ARRAY&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 Java 프로그래밍 언어로 된 &lt;code&gt;Array&lt;/code&gt; 오브젝트를 기록 합니다. 드라이버는이 값을 데이터베이스에 반환하기 전에 직렬화 가능한 &lt;code&gt;SerialArray&lt;/code&gt; SQL &lt;code&gt;ARRAY&lt;/code&gt; 값으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="63e4a51e27dbbb2d1fa9e791eaa83fc6e7d81bc8" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">기록 &lt;code&gt;int&lt;/code&gt; 이에 Java 프로그램 언어의 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="672c9a7f2d0d068e3cb4e8d6a9ddf3485c9df6a4" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;INTEGER&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">기록 &lt;code&gt;int&lt;/code&gt; 이에 Java 프로그램 언어의 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 의 객체입니다. 드라이버는이를 데이터베이스로 리턴하기 전에 SQL &lt;code&gt;INTEGER&lt;/code&gt; 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="a3bfe788ce31762630ef5185bd75a500a0052987" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the file as four bytes, high byte first.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 를 파일에 4 바이트, 상위 바이트 먼저 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1e21e726eeab5953cd125b7495eec89ed335d609" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the file as four bytes, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">기록 &lt;code&gt;int&lt;/code&gt; 4 바이트 값으로서 파일에. 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a4ba08cd12771cf8e041f1c2a9ab0bc67ead61" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four bytes, high byte first.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 를 기본 출력 스트림에 4 바이트로 높은 바이트부터 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9fc8ec8c439b095c865cb112354e78c579eab601" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four bytes, high byte first. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">기입 &lt;code&gt;int&lt;/code&gt; 4 바이트 값으로서 기본 출력 스트림. 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;4&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="21fd77840911adcb012148e0dd277d71fbc9f872" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</source>
          <target state="translated">4 바이트로 구성된 &lt;code&gt;int&lt;/code&gt; 값을 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e04bb9fdd6e28e1e95affa5629a2ce9b0aeb2c1d" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; value, which is comprised of four bytes, to the output stream. The byte values to be written, in the order shown, are:</source>
          <target state="translated">4 바이트로 구성된 &lt;code&gt;int&lt;/code&gt; 값을 출력 스트림에 씁니다 . 표시된 순서대로 기록 될 바이트 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6564ff5174255cf0e7122d7fc5cb299aea6bc492" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">Java 프로그래밍 언어로 된 &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; 오브젝트를이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="6f372b9f15bffd1cd7326fb3b4792b5cc954e159" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts this value to a serializable &lt;code&gt;SerialDatalink&lt;/code&gt; SQL &lt;code&gt;DATALINK&lt;/code&gt; value before return it to the database.</source>
          <target state="translated">Java 프로그래밍 언어로 된 &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; 오브젝트를이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 기록합니다. 드라이버는이 값을 데이터베이스로 반환하기 전에 직렬화 가능한 &lt;code&gt;SerialDatalink&lt;/code&gt; SQL &lt;code&gt;DATALINK&lt;/code&gt; 값으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="5e8354c8cfe9f0d9932569289c2573c78614272a" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;ARRAY&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;ARRAY&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="2b88fbfeb3285de8f20dc32999b639f985e8827e" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;BLOB&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;BLOB&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e5cc9a2762874135cdf783e5ef59bd592db783ab" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;CLOB&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;CLOB&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7ac466542da1fd570e1cd8a85e10a89c5a0478d3" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;NCLOB&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;NCLOB&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7b0bab43ec185e7755ca9c724c82dd497e3a75ed" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;REF&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;REF&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a32b75a2ac4c35b2bd936894dad35a1a6f742c74" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;ROWID&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;ROWID&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="afc969edfce1a8e9fcd57215da43efe7e17bb98e" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;XML&lt;/code&gt; value to the stream.</source>
          <target state="translated">SQL &lt;code&gt;XML&lt;/code&gt; 값을 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7240a87818ff11b59c7bd527a158977756f9198d" translate="yes" xml:space="preserve">
          <source>Writes an SQL structured type value to the stream.</source>
          <target state="translated">SQL 구조화 된 유형 값을 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="c44ca6e735d840ae66abcebcaf5b0d7cfe24713f" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;bytes&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 Java 프로그래밍 언어 의 &lt;code&gt;bytes&lt;/code&gt; 배열을 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="b474a9b337ecaac54d234baeb045aa62283d0dc8" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;bytes&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;VARBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">이 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 오브젝트에 Java 프로그래밍 언어 의 &lt;code&gt;bytes&lt;/code&gt; 배열을 기록 합니다. 드라이버는이를 데이터베이스로 리턴하기 전에 SQL &lt;code&gt;VARBINARY&lt;/code&gt; 또는 &lt;code&gt;LONGVARBINARY&lt;/code&gt; 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="5217c0bfa237688fd5947f4b90ec0cc289c0ec25" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the compressed output stream.</source>
          <target state="translated">압축 된 출력 스트림에 바이트 배열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="91391ca01713b61e3a68471e88e1a2ec74a5e484" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the compressed output stream. This method will block until all the bytes are written.</source>
          <target state="translated">바이트 배열을 압축 출력 스트림에 기입합니다. 이 메소드는 모든 바이트가 기록 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="6dce90598d23fb38220959b230e17daa56e43c23" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the current ZIP entry data.</source>
          <target state="translated">현재 ZIP 항목 데이터에 바이트 배열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="5bcc78bbe57b6ce8a96809d5c51d5bdd7eb8d10e" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the current ZIP entry data. This method will block until all the bytes are written.</source>
          <target state="translated">바이트 배열을 현재 ZIP 항목 데이터에 씁니다. 이 메소드는 모든 바이트가 기록 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="b65fd57256c0433acff32087a2d8da5eaf47411f" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the uncompressed output stream.</source>
          <target state="translated">압축되지 않은 출력 스트림에 바이트 배열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="197c4236f7ff27946de3d127438d615e38302ed3" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes.</source>
          <target state="translated">바이트 배열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="184076d4a82e468a9041fc00d661d8b7d8f621bd" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes. This method will block until the bytes are actually written.</source>
          <target state="translated">바이트 배열을 씁니다. 이 메소드는 실제로 바이트가 기록 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd5aee302b286670386d8cc0bc1e852dfd89da5" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes. Will block until the bytes are actually written.</source>
          <target state="translated">바이트 배열을 씁니다. 바이트가 실제로 쓰여질 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="ea42af8fd102a5d23675fcd8f7e1a21accb34a84" translate="yes" xml:space="preserve">
          <source>Writes an array of characters.</source>
          <target state="translated">문자 배열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="928868e95fe6511cf01eeb699debe02725148a7f" translate="yes" xml:space="preserve">
          <source>Writes an array of characters. This method cannot be inherited from the Writer class because it must suppress I/O exceptions.</source>
          <target state="translated">문자 배열을 씁니다. 이 메소드는 I / O 예외를 억제해야하므로 Writer 클래스에서 상속 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52aa56d648776d9495d9366408ffa13186bb65ce" translate="yes" xml:space="preserve">
          <source>Writes an attribute to the output stream</source>
          <target state="translated">출력 스트림에 속성을 씁니다.</target>
        </trans-unit>
        <trans-unit id="d2be112208b86261986a1ae461b3c896dc388e6c" translate="yes" xml:space="preserve">
          <source>Writes an attribute to the output stream without a prefix.</source>
          <target state="translated">접두사없이 출력 스트림에 속성을 씁니다.</target>
        </trans-unit>
        <trans-unit id="fff7d6a6f1bfe9778737c1fd78975331a3f83b47" translate="yes" xml:space="preserve">
          <source>Writes an empty element tag to the output</source>
          <target state="translated">출력에 빈 요소 태그를 씁니다.</target>
        </trans-unit>
        <trans-unit id="f365dd8923cf096a9c9ae1d8063f6577f24f28f0" translate="yes" xml:space="preserve">
          <source>Writes an end tag to the output relying on the internal state of the writer to determine the prefix and local name of the event.</source>
          <target state="translated">이벤트의 접두사 및 로컬 이름을 결정하기 위해 작성기의 내부 상태에 따라 출력에 종료 태그를 씁니다.</target>
        </trans-unit>
        <trans-unit id="2f6c2c4a372fcf8e32fba62c76c2b54b46f82b19" translate="yes" xml:space="preserve">
          <source>Writes an entity reference</source>
          <target state="translated">엔티티 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="845ca9715bac35ef1947ecff1b01781b98b923f3" translate="yes" xml:space="preserve">
          <source>Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to a &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">주어진 형식을 지원 하는 임의의 &lt;code&gt;ImageWriter&lt;/code&gt; 를 사용하여 이미지를 &lt;code&gt;File&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ab7e466b9e9f6735bac5eb62165c0f91b84b2869" translate="yes" xml:space="preserve">
          <source>Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to a &lt;code&gt;File&lt;/code&gt;. If there is already a &lt;code&gt;File&lt;/code&gt; present, its contents are discarded.</source>
          <target state="translated">주어진 형식을 지원 하는 임의의 &lt;code&gt;ImageWriter&lt;/code&gt; 를 사용하여 이미지를 &lt;code&gt;File&lt;/code&gt; 에 씁니다 . &lt;code&gt;File&lt;/code&gt; 이 이미 존재하면 그 내용은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c33f9616c13e7b7edbad66a907a09cd89959adef" translate="yes" xml:space="preserve">
          <source>Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to an &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">임의 이용한 화상 기입 &lt;code&gt;ImageWriter&lt;/code&gt; 내지 An 지정된 포맷을 지원 &lt;code&gt;OutputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="029b27106448a88b4763369b511ecf056a37b60f" translate="yes" xml:space="preserve">
          <source>Writes an image using the an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to an &lt;code&gt;ImageOutputStream&lt;/code&gt;.</source>
          <target state="translated">지정된 형식을 지원 하는 임의의 &lt;code&gt;ImageWriter&lt;/code&gt; 를 사용하여 &lt;code&gt;ImageOutputStream&lt;/code&gt; 에 이미지를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="50e3dd58b633ef56e1113523580bcc40cd8f5260" translate="yes" xml:space="preserve">
          <source>Writes an image using the an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to an &lt;code&gt;ImageOutputStream&lt;/code&gt;. The image is written to the &lt;code&gt;ImageOutputStream&lt;/code&gt; starting at the current stream pointer, overwriting existing stream data from that point forward, if present.</source>
          <target state="translated">지정된 형식을 지원 하는 임의의 &lt;code&gt;ImageWriter&lt;/code&gt; 를 사용해 이미지를 &lt;code&gt;ImageOutputStream&lt;/code&gt; 에 기입 합니다. 이미지는 현재 스트림 포인터에서 시작 하여 &lt;code&gt;ImageOutputStream&lt;/code&gt; 에 기록되며 , 존재하는 경우 해당 시점부터 기존 스트림 데이터를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="90f8a005a0e018089c9a966aa619c33c07892546" translate="yes" xml:space="preserve">
          <source>Writes an xml comment with the data enclosed</source>
          <target state="translated">데이터를 포함하여 xml 주석을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5de95ba3e3608236749217a0c7e571c0056a27af" translate="yes" xml:space="preserve">
          <source>Writes any cached events to the underlying output mechanism</source>
          <target state="translated">캐시 된 이벤트를 기본 출력 메커니즘에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="ab24f3dcbe1fa930ff321e8116207af7e2609aeb" translate="yes" xml:space="preserve">
          <source>Writes any remaining uncompressed data to the output stream and closes the underlying output stream.</source>
          <target state="translated">압축되지 않은 나머지 데이터를 출력 스트림에 기록하고 기본 출력 스트림을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="ea812aceedf14d0e6ad904b2cb8f433e4915a909" translate="yes" xml:space="preserve">
          <source>Writes array of bytes to the compressed output stream.</source>
          <target state="translated">압축 된 출력 스트림에 바이트 배열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="bf35ba162e8457e73f54882a5c5184fa9e4fc908" translate="yes" xml:space="preserve">
          <source>Writes array of bytes to the compressed output stream. This method will block until all the bytes are written.</source>
          <target state="translated">바이트 배열을 압축 출력 스트림에 기입합니다. 이 메소드는 모든 바이트가 기록 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="37ced05917aa020878d79b8932701d27f22098fc" translate="yes" xml:space="preserve">
          <source>Writes audio data to the mixer via this source data line.</source>
          <target state="translated">이 소스 데이터 라인을 통해 오디오 데이터를 믹서에 씁니다.</target>
        </trans-unit>
        <trans-unit id="f8a4f11dbea6b299c527b750b72fea853ce19352" translate="yes" xml:space="preserve">
          <source>Writes audio data to the mixer via this source data line. The requested number of bytes of data are read from the specified array, starting at the given offset into the array, and written to the data line's buffer. If the caller attempts to write more data than can currently be written (see &lt;a href=&quot;dataline#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;), this method blocks until the requested amount of data has been written. This applies even if the requested amount of data to write is greater than the data line's buffer size. However, if the data line is closed, stopped, or flushed before the requested amount has been written, the method no longer blocks, but returns the number of bytes written thus far.</source>
          <target state="translated">이 소스 데이터 라인을 통해 오디오 데이터를 믹서에 씁니다. 요청 된 데이터 바이트 수는 지정된 오프셋에서 시작하여 지정된 배열에서 읽혀지고 데이터 라인의 버퍼에 기록됩니다. 호출자가 현재 쓸 수있는 것보다 더 많은 데이터를 쓰려고하면 ( &lt;a href=&quot;dataline#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; 참조 )이 메서드는 요청 된 양의 데이터가 기록 될 때까지 차단됩니다. 이는 쓰기 위해 요청 된 데이터 양이 데이터 라인의 버퍼 크기보다 큰 경우에도 적용됩니다. 그러나 요청 된 양이 기록되기 전에 데이터 라인이 닫히거나 중지되거나 플러시되면 메서드는 더 이상 차단되지 않고 지금까지 기록 된 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f542e25c7d41a9ed23b80d6673b5442bf3f0be9" translate="yes" xml:space="preserve">
          <source>Writes audio data to the mixer via this source data line. The requested number of bytes of data are read from the specified array, starting at the given offset into the array, and written to the data line's buffer. If the caller attempts to write more data than can currently be written (see &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;), this method blocks until the requested amount of data has been written. This applies even if the requested amount of data to write is greater than the data line's buffer size. However, if the data line is closed, stopped, or flushed before the requested amount has been written, the method no longer blocks, but returns the number of bytes written thus far.</source>
          <target state="translated">이 소스 데이터 라인을 통해 오디오 데이터를 믹서에 씁니다. 요청 된 바이트 수의 데이터는 지정된 오프셋에서 지정된 오프셋부터 배열로 읽어 들여 데이터 라인의 버퍼에 기록됩니다. 발신자가 현재 쓸 수있는 것보다 많은 데이터를 쓰려고 시도하는 경우 ( &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 참조) )이 방법은 요청 된 양의 데이터가 쓰여질 때까지 차단됩니다. 이것은 요청 된 쓰기 데이터 량이 데이터 라인의 버퍼 크기보다 큰 경우에도 적용됩니다. 그러나 요청 된 양이 쓰여지기 전에 데이터 라인이 닫히거나 중지되거나 플러시되면 메소드는 더 이상 차단되지 않고 지금까지 기록 된 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="70af5ea88b88ac39f37fa0e6431e3587c4947620" translate="yes" xml:space="preserve">
          <source>Writes bytes to a file.</source>
          <target state="translated">파일에 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="539e94f80819f8addfe61f29f8d0c0095d59f44a" translate="yes" xml:space="preserve">
          <source>Writes bytes to a file. The &lt;code&gt;options&lt;/code&gt; parameter specifies how the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. All bytes in the byte array are written to the file. The method ensures that the file is closed when all bytes have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has been created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">파일에 바이트를 씁니다. &lt;code&gt;options&lt;/code&gt; 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메서드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 쓰기 위해 파일을 열고, 파일이없는 경우 파일을 생성하거나, 기존 &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 을 처음 에 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다 . 바이트 배열의 모든 바이트가 파일에 기록됩니다. 이 메서드는 모든 바이트가 기록되었을 때 (또는 I / O 오류 또는 기타 런타임 예외가 발생했을 때) 파일이 닫히도록합니다. I / O 오류가 발생하면 파일이 작성되거나 잘린 후 또는 파일에 일부 바이트가 기록 된 후 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87e219a2917354808d12478e2ed7441db173e738" translate="yes" xml:space="preserve">
          <source>Writes bytes to a file. The &lt;code&gt;options&lt;/code&gt; parameter specifies how the the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. All bytes in the byte array are written to the file. The method ensures that the file is closed when all bytes have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">바이트를 파일에 씁니다. &lt;code&gt;options&lt;/code&gt; 하여 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메소드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 파일을 작성하기 위해 파일을 열거 나 존재하지 않는 경우 파일을 만들거나 기존 &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다. . 바이트 배열의 모든 바이트가 파일에 기록됩니다. 이 메소드는 모든 바이트가 기록 될 때 파일이 닫히도록합니다 (또는 I / O 오류 또는 기타 런타임 예외가 발생 함). I / O 오류가 발생하면 파일이 작성되거나 잘린 후 또는 일부 바이트가 파일에 기록 된 후에 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa9eb435ce66122fd3b1fbb9683dc6f39b12396" translate="yes" xml:space="preserve">
          <source>Writes characters to the buffer.</source>
          <target state="translated">버퍼에 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="7d60a1b7a1a3d14a49cb496536b68fe0e5783720" translate="yes" xml:space="preserve">
          <source>Writes content from a document to the given stream as plain text.</source>
          <target state="translated">문서의 내용을 지정된 스트림에 일반 텍스트로 씁니다.</target>
        </trans-unit>
        <trans-unit id="d97477c205ceea09c92c5946659e274241b1ae36" translate="yes" xml:space="preserve">
          <source>Writes content from a document to the given stream in a format appropriate for this kind of content handler.</source>
          <target state="translated">이러한 종류의 콘텐츠 처리기에 적합한 형식으로 문서의 콘텐츠를 지정된 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="b26649091ef7b5d2a209d730bd88924f12963e9c" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given double value, in the current byte order, into this buffer at the current position, and then increments the position by eight.</source>
          <target state="translated">현재의 바이트 순서로 지정된 double 치를 포함한 8 바이트를 현재 위치의이 버퍼에 기입 해, 위치를 8 증분시킵니다.</target>
        </trans-unit>
        <trans-unit id="29fc7be2d2fa2a9838cc38ff4c3934f5c3f3655d" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given double value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">현재의 바이트 순서로 지정된 double 치를 포함한 8 바이트를 지정된 인덱스의이 버퍼에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="cc89b642bf8674896232f688adbc8ebc5d1dfdc8" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given long value, in the current byte order, into this buffer at the current position, and then increments the position by eight.</source>
          <target state="translated">현재 바이트 순서로 지정된 long 값을 포함하는 8 바이트를 현재 위치의이 버퍼에 쓴 다음 위치를 8 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="2bb4a200c6266d5b89a3ab96d32530f2a49d3e59" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given long value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">현재의 바이트 순서로, 지정된 long 치를 포함한 8 바이트를, 지정된 인덱스의이 버퍼에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="2487fee69be7365dce9130ceec028a6bb7fc07e9" translate="yes" xml:space="preserve">
          <source>Writes every character in the string &lt;code&gt;s&lt;/code&gt;, to the output stream, in order, two bytes per character.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 의 모든 문자를 문자 당 2 바이트 순서대로 출력 스트림 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b9d0787a90c45f72d95f7e055e81599ca892dbaf" translate="yes" xml:space="preserve">
          <source>Writes every character in the string &lt;code&gt;s&lt;/code&gt;, to the output stream, in order, two bytes per character. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;s.length&lt;/code&gt; is zero, then no characters are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, two bytes are actually written, high-order byte first, in exactly the manner of the &lt;code&gt;writeChar&lt;/code&gt; method.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 의 모든 문자를 문자 당 2 바이트의 순서로 출력 스트림 에 씁니다 . 경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 발생합니다. 경우 &lt;code&gt;s.length&lt;/code&gt; 가 제로 다음에 문자가 기록되지 않습니다. 그렇지 않으면 문자 &lt;code&gt;s[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;s[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 문자는 &lt;code&gt;s[s.length-1]&lt;/code&gt; 입니다. 각 문자에 대해 정확히 2 개의 바이트가 &lt;code&gt;writeChar&lt;/code&gt; 메소드 의 방식으로 실제로 높은 순서의 바이트가 먼저 기록 됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4e00ea7b401f90dc90c64677abaf47d2170156" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given float value, in the current byte order, into this buffer at the current position, and then increments the position by four.</source>
          <target state="translated">현재 바이트 순서로 지정된 float 값을 포함하는 4 바이트를 현재 위치의이 버퍼에 쓴 다음 위치를 4 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="5d979f53ff93d5b35a5d4de9156c84a797cd1d5a" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given float value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">현재의 바이트 순서로, 지정된 float 치를 포함한 4 바이트를 지정된 인덱스의이 버퍼에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="d8eac6d4c7237a86bdd435eec454a1165fa276c0" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given int value, in the current byte order, into this buffer at the current position, and then increments the position by four.</source>
          <target state="translated">현재 바이트 순서로 지정된 int 값을 포함하는 4 바이트를 현재 위치의이 버퍼에 쓴 다음 위치를 4 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="5cf0746092fdb63187e2dce0e857024f58099778" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given int value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">지정된 int 값을 포함하는 4 바이트를 현재 바이트 순서로 지정된 인덱스의이 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ceb6f95baf23beaeef39ebca1fb801718774f47c" translate="yes" xml:space="preserve">
          <source>Writes next block of compressed data to the output stream.</source>
          <target state="translated">다음 압축 데이터 블록을 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="f716150ad2b59e1e2c39f51e686b6112c9516c37" translate="yes" xml:space="preserve">
          <source>Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as a 1-byte value.</source>
          <target state="translated">기본 출력 스트림에 1 바이트 값으로 &lt;code&gt;byte&lt;/code&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="793d3092c9065640c3553038c363272625fcd2c4" translate="yes" xml:space="preserve">
          <source>Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as a 1-byte value. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">기본 출력 스트림에 1 바이트 값으로 &lt;code&gt;byte&lt;/code&gt; 를 씁니다 . 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;1&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="d781a8fad1ddbd48d34b00f1d27f845c18c1752a" translate="yes" xml:space="preserve">
          <source>Writes out a character.</source>
          <target state="translated">문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="a4149ecfaf0a53ba4649ab673e88332a5ee9da18" translate="yes" xml:space="preserve">
          <source>Writes out a character. This is implemented to invoke the &lt;code&gt;write&lt;/code&gt; method that takes a char[].</source>
          <target state="translated">문자를 씁니다. 이것은 char []를 받는 &lt;code&gt;write&lt;/code&gt; 메소드 를 호출하기 위해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="b140b7ef352adc85171d5601e6a4059a8beb9ddb" translate="yes" xml:space="preserve">
          <source>Writes out a start tag appropriately indented.</source>
          <target state="translated">적절하게 들여 쓰기 된 시작 태그를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="59cd99484ad8b2ddeeb11187543a4b9e32ee97be" translate="yes" xml:space="preserve">
          <source>Writes out a start tag appropriately indented. Also increments the indent level.</source>
          <target state="translated">적절하게 들여 쓰기 된 시작 태그를 작성합니다. 또한 들여 쓰기 수준을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="3adc971c51b7b35d342948b59ee6c8ece76c15bf" translate="yes" xml:space="preserve">
          <source>Writes out a start tag for the &amp;lt;font&amp;gt; tag. Because font tags cannot be nested, this method closes out any enclosing font tag before writing out a new start tag.</source>
          <target state="translated">&amp;lt;font&amp;gt; 태그의 시작 태그를 작성합니다. 글꼴 태그는 중첩 될 수 없기 때문에이 메서드는 새 시작 태그를 작성하기 전에 둘러싸는 글꼴 태그를 모두 닫습니다.</target>
        </trans-unit>
        <trans-unit id="79f42a920e1137b6f79fa6f072c0a5db14d2ce25" translate="yes" xml:space="preserve">
          <source>Writes out a start tag for the element.</source>
          <target state="translated">요소의 시작 태그를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="356d987d07c2b42cce555e735e5353fcf20d7274" translate="yes" xml:space="preserve">
          <source>Writes out a start tag for the element. Ignores all synthesized elements.</source>
          <target state="translated">요소의 시작 태그를 작성합니다. 합성 된 모든 요소를 ​​무시합니다.</target>
        </trans-unit>
        <trans-unit id="32e7980350f2d5d345b80613927c3a10708d9d12" translate="yes" xml:space="preserve">
          <source>Writes out a string.</source>
          <target state="translated">문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="493534febd569e8eefd0de76e69315ffc098581b" translate="yes" xml:space="preserve">
          <source>Writes out a string. This is implemented to invoke the &lt;code&gt;write&lt;/code&gt; method that takes a char[].</source>
          <target state="translated">문자열을 씁니다. 이것은 char []를 받는 &lt;code&gt;write&lt;/code&gt; 메소드 를 호출하기 위해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="242b41b748966187939dd514ce8f221ecfb52196" translate="yes" xml:space="preserve">
          <source>Writes out all empty elements (all tags that have no corresponding end tag).</source>
          <target state="translated">모든 빈 요소 (해당하는 종료 태그가없는 모든 태그)를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="45fd8d7e498fa017170b717aede40700f6694fc2" translate="yes" xml:space="preserve">
          <source>Writes out all the attributes for the following types: StyleConstants.ParagraphConstants, StyleConstants.CharacterConstants, StyleConstants.FontConstants, StyleConstants.ColorConstants.</source>
          <target state="translated">StyleConstants.ParagraphConstants, StyleConstants.CharacterConstants, StyleConstants.FontConstants, StyleConstants.ColorConstants 유형에 대한 모든 속성을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b15c5c0d66618d9399589ac1eea1921ed967d0f6" translate="yes" xml:space="preserve">
          <source>Writes out all the attributes for the following types: StyleConstants.ParagraphConstants, StyleConstants.CharacterConstants, StyleConstants.FontConstants, StyleConstants.ColorConstants. The attribute name and value are separated by a colon. Each pair is separated by a semicolon.</source>
          <target state="translated">StyleConstants.ParagraphConstants, StyleConstants.CharacterConstants, StyleConstants.FontConstants, StyleConstants.ColorConstants 유형에 대한 모든 속성을 작성합니다. 속성 이름과 값은 콜론으로 구분됩니다. 각 쌍은 세미콜론으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea000abebf3e796c2231c4084f5c3ec51fda40e" translate="yes" xml:space="preserve">
          <source>Writes out all the named styles as the content of the &amp;lt;style&amp;gt; tag.</source>
          <target state="translated">모든 명명 된 스타일을 &amp;lt;style&amp;gt; 태그의 내용으로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="95aa7506da86487c9d8a3dd4aad789dffcf726cb" translate="yes" xml:space="preserve">
          <source>Writes out an end tag appropriately indented.</source>
          <target state="translated">적절하게 들여 쓰기 된 종료 태그를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f8a3e8b63a7d7db5de505123b83e2632e59b6f4a" translate="yes" xml:space="preserve">
          <source>Writes out an end tag appropriately indented. Also decrements the indent level.</source>
          <target state="translated">적절하게 들여 쓰기 된 종료 태그를 작성합니다. 또한 들여 쓰기 수준을 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="91e658fa4cec6ec79dc0e2ffcd3905fbdaf669c0" translate="yes" xml:space="preserve">
          <source>Writes out an end tag for the &amp;lt;font&amp;gt; tag.</source>
          <target state="translated">Writes out an end tag for the &amp;lt;font&amp;gt; tag.</target>
        </trans-unit>
        <trans-unit id="3d31826423dc7c1e67f148ff784ac0beacea46fe" translate="yes" xml:space="preserve">
          <source>Writes out an end tag for the element.</source>
          <target state="translated">Writes out an end tag for the element.</target>
        </trans-unit>
        <trans-unit id="3a070bf3f90011012888b6f65043e51f7be1db04" translate="yes" xml:space="preserve">
          <source>Writes out comments.</source>
          <target state="translated">Writes out comments.</target>
        </trans-unit>
        <trans-unit id="2e3bee8704d332f162a00133a136ad93991e1fcd" translate="yes" xml:space="preserve">
          <source>Writes out text that is contained in a TEXTAREA form element.</source>
          <target state="translated">Writes out text that is contained in a TEXTAREA form element.</target>
        </trans-unit>
        <trans-unit id="d8271b9150a2c67ce97fd91c10873bb46909d357" translate="yes" xml:space="preserve">
          <source>Writes out text.</source>
          <target state="translated">Writes out text.</target>
        </trans-unit>
        <trans-unit id="abc7bcf64efcb93db19ad0308ad3a28eed435488" translate="yes" xml:space="preserve">
          <source>Writes out text. If a range is specified when the constructor is invoked, then only the appropriate range of text is written out.</source>
          <target state="translated">Writes out text. If a range is specified when the constructor is invoked, then only the appropriate range of text is written out.</target>
        </trans-unit>
        <trans-unit id="1a2feb0ee03b2fb37577d2683165471850570c57" translate="yes" xml:space="preserve">
          <source>Writes out the &amp;lt;head&amp;gt; and &amp;lt;style&amp;gt; tags, and then invokes writeStyles() to write out all the named styles as the content of the &amp;lt;style&amp;gt; tag.</source>
          <target state="translated">Writes out the &amp;lt;head&amp;gt; and &amp;lt;style&amp;gt; tags, and then invokes writeStyles() to write out all the named styles as the content of the &amp;lt;style&amp;gt; tag.</target>
        </trans-unit>
        <trans-unit id="1d67167a503faefc3b4e96ac0d49dfd64c919c5a" translate="yes" xml:space="preserve">
          <source>Writes out the &amp;lt;head&amp;gt; and &amp;lt;style&amp;gt; tags, and then invokes writeStyles() to write out all the named styles as the content of the &amp;lt;style&amp;gt; tag. The content is surrounded by valid HTML comment markers to ensure that the document is viewable in applications/browsers that do not support the tag.</source>
          <target state="translated">Writes out the &amp;lt;head&amp;gt; and &amp;lt;style&amp;gt; tags, and then invokes writeStyles() to write out all the named styles as the content of the &amp;lt;style&amp;gt; tag. The content is surrounded by valid HTML comment markers to ensure that the document is viewable in applications/browsers that do not support the tag.</target>
        </trans-unit>
        <trans-unit id="cb594e7c2614c3f26268fa1d6f121a7690ffbc18" translate="yes" xml:space="preserve">
          <source>Writes out the attribute set in an HTML-compliant manner.</source>
          <target state="translated">Writes out the attribute set in an HTML-compliant manner.</target>
        </trans-unit>
        <trans-unit id="50df6d6c3b3e39b2b4d38cb825b404ff3b15a69f" translate="yes" xml:space="preserve">
          <source>Writes out the attribute set.</source>
          <target state="translated">Writes out the attribute set.</target>
        </trans-unit>
        <trans-unit id="3bbd16063a5b5b4cb118131679e17c07f900bc85" translate="yes" xml:space="preserve">
          <source>Writes out the attribute set. Ignores all attributes with a key of type HTML.Tag, attributes with a key of type StyleConstants, and attributes with a key of type HTML.Attribute.ENDTAG.</source>
          <target state="translated">Writes out the attribute set. Ignores all attributes with a key of type HTML.Tag, attributes with a key of type StyleConstants, and attributes with a key of type HTML.Attribute.ENDTAG.</target>
        </trans-unit>
        <trans-unit id="1b012971e329c1b5642a4a72d93bbe2b77837d70" translate="yes" xml:space="preserve">
          <source>Writes out the content of the Option form element.</source>
          <target state="translated">Writes out the content of the Option form element.</target>
        </trans-unit>
        <trans-unit id="522f62e68017f3dd760479be9b0d3f17baeb3def" translate="yes" xml:space="preserve">
          <source>Writes out the content of the SELECT form element.</source>
          <target state="translated">Writes out the content of the SELECT form element.</target>
        </trans-unit>
        <trans-unit id="4d59bf0b74e182fe97baa2f628898aa78e036aba" translate="yes" xml:space="preserve">
          <source>Writes out the remaining character-level attributes (attributes other than bold, italic, and underline) in an HTML-compliant way.</source>
          <target state="translated">Writes out the remaining character-level attributes (attributes other than bold, italic, and underline) in an HTML-compliant way.</target>
        </trans-unit>
        <trans-unit id="aab68f7962761ed64910659bf2f1f7f92a40c4d4" translate="yes" xml:space="preserve">
          <source>Writes out the remaining character-level attributes (attributes other than bold, italic, and underline) in an HTML-compliant way. Given that attributes such as font family and font size have no direct mapping to HTML tags, a &amp;lt;span&amp;gt; tag is generated and its style attribute is set to contain the list of remaining attributes just like inline styles.</source>
          <target state="translated">Writes out the remaining character-level attributes (attributes other than bold, italic, and underline) in an HTML-compliant way. Given that attributes such as font family and font size have no direct mapping to HTML tags, a &amp;lt;span&amp;gt; tag is generated and its style attribute is set to contain the list of remaining attributes just like inline styles.</target>
        </trans-unit>
        <trans-unit id="f1da4ae2350b8ea9bf6c7b5422ed8adaeef31d8e" translate="yes" xml:space="preserve">
          <source>Writes out the set of attributes as &quot; &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&quot; pairs.</source>
          <target state="translated">Writes out the set of attributes as &quot; &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&quot; pairs.</target>
        </trans-unit>
        <trans-unit id="8a0f5a5f07a705ce87b430d9d69b03ff6c74cbfc" translate="yes" xml:space="preserve">
          <source>Writes out the set of attributes as &quot; &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&quot; pairs. It throws an IOException when encountered.</source>
          <target state="translated">Writes out the set of attributes as &quot; &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&quot; pairs. It throws an IOException when encountered.</target>
        </trans-unit>
        <trans-unit id="88fb3884fdd7120949e40123aff7eb69222dd291" translate="yes" xml:space="preserve">
          <source>Writes out the string to the underlying output stream as a sequence of bytes.</source>
          <target state="translated">Writes out the string to the underlying output stream as a sequence of bytes.</target>
        </trans-unit>
        <trans-unit id="b05d15e021ce2f4dcac9e9d78114869b4a50f886" translate="yes" xml:space="preserve">
          <source>Writes out the string to the underlying output stream as a sequence of bytes. Each character in the string is written out, in sequence, by discarding its high eight bits. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by the length of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">문자열을 기본 출력 스트림에 바이트 시퀀스로 씁니다. 문자열의 각 문자는 상위 8 비트를 삭제하여 순서대로 작성됩니다. 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;s&lt;/code&gt; 길이만큼 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="d426192659256406de28eda44669a9ce5d358062" translate="yes" xml:space="preserve">
          <source>Writes recording data to a file.</source>
          <target state="translated">기록 데이터를 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="37980950b6bfa72a356d0cb2c6fe45c994849d35" translate="yes" xml:space="preserve">
          <source>Writes recording data to the specified file.</source>
          <target state="translated">기록 데이터를 지정된 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="6a3054c268468152f2a8887eea01d971616cbb74" translate="yes" xml:space="preserve">
          <source>Writes remaining compressed data to the output stream and closes the underlying stream.</source>
          <target state="translated">나머지 압축 데이터를 출력 스트림에 기록하고 기본 스트림을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="28f3ab69dea5b395ecbb033c1f9e3a56f4abd902" translate="yes" xml:space="preserve">
          <source>Writes statement &lt;code&gt;oldStm&lt;/code&gt; to the stream.</source>
          <target state="translated">Writes statement &lt;code&gt;oldStm&lt;/code&gt; to the stream.</target>
        </trans-unit>
        <trans-unit id="61581676dc1ea35473d6a783082bf72e9c80ceec" translate="yes" xml:space="preserve">
          <source>Writes statement &lt;code&gt;oldStm&lt;/code&gt; to the stream. The &lt;code&gt;oldStm&lt;/code&gt; should be written entirely in terms of the callers environment, i.e. the target and all arguments should be part of the object graph being written. These expressions represent a series of &quot;what happened&quot; expressions which tell the output stream how to produce an object graph like the original.</source>
          <target state="translated">&lt;code&gt;oldStm&lt;/code&gt; 문 을 스트림에 씁니다 . &lt;code&gt;oldStm&lt;/code&gt; 는 호출자 환경의 관점에서 완전히 기록 대상 즉 모든 인자 객체 그래프의 일부가 기록되어 있어야한다. 이 표현식은 출력 스트림에 원본과 같은 객체 그래프를 생성하는 방법을 알려주는 일련의 &quot;무슨 일&quot;표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f052f35920dd89a7054c35d1df3b6bfb93d13930" translate="yes" xml:space="preserve">
          <source>Writes text to a character-output stream, buffering characters so as to provide for the efficient writing of single characters, arrays, and strings.</source>
          <target state="translated">단일 문자, 배열 및 문자열을 효율적으로 쓸 수 있도록 문자를 버퍼링하여 문자 출력 스트림에 텍스트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="597dfd2df5025e0ac661bb05d062c2aa056c141e" translate="yes" xml:space="preserve">
          <source>Writes text to character files using a default buffer size.</source>
          <target state="translated">Writes text to character files using a default buffer size.</target>
        </trans-unit>
        <trans-unit id="6167d657904cfcab0dbb9315dd6a6ecb18ddf064" translate="yes" xml:space="preserve">
          <source>Writes text to character files using a default buffer size. Encoding from characters to bytes uses either a specified &lt;a href=&quot;../nio/charset/charset&quot;&gt;charset&lt;/a&gt; or the platform's &lt;a href=&quot;../nio/charset/charset#defaultCharset()&quot;&gt;default charset&lt;/a&gt;.</source>
          <target state="translated">Writes text to character files using a default buffer size. Encoding from characters to bytes uses either a specified &lt;a href=&quot;../nio/charset/charset&quot;&gt;charset&lt;/a&gt; or the platform's &lt;a href=&quot;../nio/charset/charset#defaultCharset()&quot;&gt;default charset&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="862b19d4b6ff1b6eff3c4ad6b6bdab89231c477b" translate="yes" xml:space="preserve">
          <source>Writes the 16 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">Writes the 16 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream.</target>
        </trans-unit>
        <trans-unit id="46f7ffb3816bb380e3513417982c2f71b9fe2e32" translate="yes" xml:space="preserve">
          <source>Writes the 16 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream. The 16 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. If the stream uses network byte order, the bytes written, in order, will be:</source>
          <target state="translated">하위 16 비트의 &lt;code&gt;v&lt;/code&gt; 를 스트림에 씁니다 . &lt;code&gt;v&lt;/code&gt; 의 16 개의 상위 비트 는 무시됩니다. 스트림이 네트워크 바이트 순서를 사용하는 경우 순서대로 작성된 바이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2285f29a0b24000b5b0b1f1f80d441c9b5148486" translate="yes" xml:space="preserve">
          <source>Writes the 32 bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">Writes the 32 bits of &lt;code&gt;v&lt;/code&gt; to the stream.</target>
        </trans-unit>
        <trans-unit id="1695f3633211b76ec7f857f5454ea6a247025c8d" translate="yes" xml:space="preserve">
          <source>Writes the 32 bits of &lt;code&gt;v&lt;/code&gt; to the stream. If the stream uses network byte order, the bytes written, in order, will be:</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 32 비트를 스트림에 씁니다 . 스트림이 네트워크 바이트 순서를 사용하는 경우 순서대로 작성된 바이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12bdda69ade361eb7dbeae8003665e8a3eff12fb" translate="yes" xml:space="preserve">
          <source>Writes the 64 bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">Writes the 64 bits of &lt;code&gt;v&lt;/code&gt; to the stream.</target>
        </trans-unit>
        <trans-unit id="1ad02fac0fe368119ddb18c395ff897d2d58089f" translate="yes" xml:space="preserve">
          <source>Writes the 64 bits of &lt;code&gt;v&lt;/code&gt; to the stream. If the stream uses network byte order, the bytes written, in order, will be:</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 64 비트를 스트림에 씁니다 . 스트림이 네트워크 바이트 순서를 사용하는 경우 순서대로 작성된 바이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1e7aaab26c2b74832628edc0bc5c54f2c2b6383" translate="yes" xml:space="preserve">
          <source>Writes the 8 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">Writes the 8 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream.</target>
        </trans-unit>
        <trans-unit id="1804455e9da4aaf420e36d129972367ec781e360" translate="yes" xml:space="preserve">
          <source>Writes the 8 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream. The 24 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. (This means that &lt;code&gt;writeByte&lt;/code&gt; does exactly the same thing as &lt;code&gt;write&lt;/code&gt; for an integer argument.)</source>
          <target state="translated">하위 8 비트의 &lt;code&gt;v&lt;/code&gt; 를 스트림에 씁니다 . &lt;code&gt;v&lt;/code&gt; 의 24 개 상위 비트 는 무시됩니다. 이것은 &lt;code&gt;writeByte&lt;/code&gt; 가 정수 인수에 대한 &lt;code&gt;write&lt;/code&gt; 와 정확히 같은 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="19e78fdb1971c9362622f784b86e72a51fdd9069" translate="yes" xml:space="preserve">
          <source>Writes the Manifest to the specified OutputStream.</source>
          <target state="translated">Writes the Manifest to the specified OutputStream.</target>
        </trans-unit>
        <trans-unit id="89cd571628123202a3823b52aeb30a696038cb43" translate="yes" xml:space="preserve">
          <source>Writes the Manifest to the specified OutputStream. Attributes.Name.MANIFEST_VERSION must be set in MainAttributes prior to invoking this method.</source>
          <target state="translated">매니페스트를 지정된 OutputStream에 씁니다. 이 메소드를 호출하기 전에 MainAttributes에서 Attributes.Name.MANIFEST_VERSION을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="56a6e43f8f49e535184e69201b1785713f290620" translate="yes" xml:space="preserve">
          <source>Writes the changes in this &lt;code&gt;RowSetWriter&lt;/code&gt; object's rowset back to the data source from which it got its data.</source>
          <target state="translated">Writes the changes in this &lt;code&gt;RowSetWriter&lt;/code&gt; object's rowset back to the data source from which it got its data.</target>
        </trans-unit>
        <trans-unit id="ed35cca7d83e05daee22aa9a3f126d06b836d5a5" translate="yes" xml:space="preserve">
          <source>Writes the complete contents of the specified byte array to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt;.</source>
          <target state="translated">Writes the complete contents of the specified byte array to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9e9501319b3d34bbec70c3333e794fa37a6d454" translate="yes" xml:space="preserve">
          <source>Writes the complete contents of this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; to the specified output stream argument, as if by calling the output stream's write method using &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt;.</source>
          <target state="translated">Writes the complete contents of this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; to the specified output stream argument, as if by calling the output stream's write method using &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c24338bb5d1fb51bd9cbd3d86a25bb4355deba24" translate="yes" xml:space="preserve">
          <source>Writes the complete contents of this byte array output stream to the specified output stream argument, as if by calling the output stream's write method using &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out.write(buf, 0, count)&lt;/code&gt; 사용하여 출력 스트림의 write 메소드를 호출하는 것처럼이 바이트 배열 출력 스트림의 전체 내용을 지정된 출력 스트림 인수에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ff4dae149c1ce83c7a6b820b14212cbe3bbf93f1" translate="yes" xml:space="preserve">
          <source>Writes the contents of the buffer to another character stream.</source>
          <target state="translated">버퍼의 내용을 다른 문자 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="625df89357bdd2344ade2b496e40fd50120f1e3a" translate="yes" xml:space="preserve">
          <source>Writes the data, properties, and metadata for this &lt;code&gt;WebRowSet&lt;/code&gt; object to the given &lt;code&gt;OutputStream&lt;/code&gt; object in XML format.</source>
          <target state="translated">Writes the data, properties, and metadata for this &lt;code&gt;WebRowSet&lt;/code&gt; object to the given &lt;code&gt;OutputStream&lt;/code&gt; object in XML format.</target>
        </trans-unit>
        <trans-unit id="5c40001a80f650ccea2798916fa3dc59bfca35b4" translate="yes" xml:space="preserve">
          <source>Writes the data, properties, and metadata for this &lt;code&gt;WebRowSet&lt;/code&gt; object to the given &lt;code&gt;Writer&lt;/code&gt; object in XML format.</source>
          <target state="translated">Writes the data, properties, and metadata for this &lt;code&gt;WebRowSet&lt;/code&gt; object to the given &lt;code&gt;Writer&lt;/code&gt; object in XML format.</target>
        </trans-unit>
        <trans-unit id="def01038d2b375e9be7d7c972c662a60bf85f6ed" translate="yes" xml:space="preserve">
          <source>Writes the default namespace to the stream</source>
          <target state="translated">Writes the default namespace to the stream</target>
        </trans-unit>
        <trans-unit id="8b1da37e0b3c109b19027e60ce196dfcfe9d6bb8" translate="yes" xml:space="preserve">
          <source>Writes the field values, time stamp, and event duration to the Flight Recorder system.</source>
          <target state="translated">비행 레코더 시스템에 필드 값, 타임 스탬프 및 이벤트 기간을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f79062814f665166b5bf8b4fbf187fc654014a55" translate="yes" xml:space="preserve">
          <source>Writes the given &lt;code&gt;WebRowSet&lt;/code&gt; object to the specified &lt;code&gt;java.io.Writer&lt;/code&gt; output stream as an XML document.</source>
          <target state="translated">Writes the given &lt;code&gt;WebRowSet&lt;/code&gt; object to the specified &lt;code&gt;java.io.Writer&lt;/code&gt; output stream as an XML document.</target>
        </trans-unit>
        <trans-unit id="c53959f7ef1e7a69156e9085d95064c77f4d010b" translate="yes" xml:space="preserve">
          <source>Writes the given &lt;code&gt;WebRowSet&lt;/code&gt; object to the specified &lt;code&gt;java.io.Writer&lt;/code&gt; output stream as an XML document. This document includes the rowset's data, metadata, and properties plus the appropriate XML tags.</source>
          <target state="translated">Writes the given &lt;code&gt;WebRowSet&lt;/code&gt; object to the specified &lt;code&gt;java.io.Writer&lt;/code&gt; output stream as an XML document. This document includes the rowset's data, metadata, and properties plus the appropriate XML tags.</target>
        </trans-unit>
        <trans-unit id="2fc66b6ae43cb5f22e10fbdc9f01c80ebb40e0aa" translate="yes" xml:space="preserve">
          <source>Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; object designates at the position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; object designates at the position &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d16b2514bafe679b47004e8cd89d3c68d61aebc" translate="yes" xml:space="preserve">
          <source>Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; object designates at the position &lt;code&gt;pos&lt;/code&gt;. The string will overwrite the existing characters in the &lt;code&gt;Clob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Clob&lt;/code&gt; value is reached while writing the given string, then the length of the &lt;code&gt;Clob&lt;/code&gt; value will be increased to accommodate the extra characters.</source>
          <target state="translated">Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; object designates at the position &lt;code&gt;pos&lt;/code&gt; . The string will overwrite the existing characters in the &lt;code&gt;Clob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt; . If the end of the &lt;code&gt;Clob&lt;/code&gt; value is reached while writing the given string, then the length of the &lt;code&gt;Clob&lt;/code&gt; value will be increased to accommodate the extra characters.</target>
        </trans-unit>
        <trans-unit id="57a742d5137a159149b8c8b646d025117a64f0e3" translate="yes" xml:space="preserve">
          <source>Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;SerialClob&lt;/code&gt; object represents, at the position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;SerialClob&lt;/code&gt; object represents, at the position &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a11fbed6e0f0c000e7ac73c751f5706337ffea4" translate="yes" xml:space="preserve">
          <source>Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position &lt;code&gt;pos&lt;/code&gt;, and returns the number of bytes written.</source>
          <target state="translated">Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position &lt;code&gt;pos&lt;/code&gt; , and returns the number of bytes written.</target>
        </trans-unit>
        <trans-unit id="de7a837912d2ada585ea670a18a22c40ee3566d8" translate="yes" xml:space="preserve">
          <source>Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position &lt;code&gt;pos&lt;/code&gt;, and returns the number of bytes written. The array of bytes will overwrite the existing bytes in the &lt;code&gt;Blob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Blob&lt;/code&gt; value is reached while writing the array of bytes, then the length of the &lt;code&gt;Blob&lt;/code&gt; value will be increased to accommodate the extra bytes.</source>
          <target state="translated">Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position &lt;code&gt;pos&lt;/code&gt; , and returns the number of bytes written. The array of bytes will overwrite the existing bytes in the &lt;code&gt;Blob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt; . If the end of the &lt;code&gt;Blob&lt;/code&gt; value is reached while writing the array of bytes, then the length of the &lt;code&gt;Blob&lt;/code&gt; value will be increased to accommodate the extra bytes.</target>
        </trans-unit>
        <trans-unit id="d1d0f592eeac5c796ea935b5d994096745d157f7" translate="yes" xml:space="preserve">
          <source>Writes the given byte into this buffer at the current position, and then increments the position.</source>
          <target state="translated">현재 위치에서 지정된 바이트를이 버퍼에 쓴 다음 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="dd7b88652ec60af74a840f947c7b86d252782b34" translate="yes" xml:space="preserve">
          <source>Writes the given byte into this buffer at the given index.</source>
          <target state="translated">지정된 인덱스의 지정된 바이트를이 버퍼에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="6a61149f23f16decaac4eae92463c7ef12672ae5" translate="yes" xml:space="preserve">
          <source>Writes the given char into this buffer at the current position, and then increments the position.</source>
          <target state="translated">현재 위치에서 지정된 문자를이 버퍼에 쓴 다음 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="4f770fa38d98aec466fccb25555cc99c0b9ddbaf" translate="yes" xml:space="preserve">
          <source>Writes the given char into this buffer at the given index.</source>
          <target state="translated">지정된 인덱스의 지정된 문자를이 버퍼에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="f2d1506e6de2b9485d5e760430b8d8a6e992441f" translate="yes" xml:space="preserve">
          <source>Writes the given double into this buffer at the current position, and then increments the position.</source>
          <target state="translated">현재 위치에서 지정된 double을이 버퍼에 쓴 다음 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="68ee8a87d76de1cd2a770b8396c4ab7cf9175f3b" translate="yes" xml:space="preserve">
          <source>Writes the given double into this buffer at the given index.</source>
          <target state="translated">주어진 인덱스에서 주어진 double을이 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="370abd73ada65b5904921d209602fcc69611ebec" translate="yes" xml:space="preserve">
          <source>Writes the given float into this buffer at the current position, and then increments the position.</source>
          <target state="translated">주어진 float를 현재 위치에서이 버퍼에 쓴 다음 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="07eaa541d5c0633efea85fbc2ae9bba6c20a12a6" translate="yes" xml:space="preserve">
          <source>Writes the given float into this buffer at the given index.</source>
          <target state="translated">주어진 인덱스에서 주어진 float를이 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="19e622dee348636b8ed78c68d535a1074887c524" translate="yes" xml:space="preserve">
          <source>Writes the given int into this buffer at the current position, and then increments the position.</source>
          <target state="translated">주어진 int를 현재 위치에서이 버퍼에 쓴 다음 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="b845c5f27efaa6c518dc0d967f43b3a146bebef9" translate="yes" xml:space="preserve">
          <source>Writes the given int into this buffer at the given index.</source>
          <target state="translated">지정된 인덱스의 지정된 int를이 버퍼에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="712fe7e7e38b5fd24f11498bd179d0ff8bdc747b" translate="yes" xml:space="preserve">
          <source>Writes the given long into this buffer at the current position, and then increments the position.</source>
          <target state="translated">현재 위치에서 지정된 long을이 버퍼에 쓴 다음 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="fabaa8aff4aa813be322673a9965363c8f76cba7" translate="yes" xml:space="preserve">
          <source>Writes the given long into this buffer at the given index.</source>
          <target state="translated">주어진 인덱스에서 주어진 시간을이 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="9495203bcfa27d90ba40a65bedf36e96cec6cc11" translate="yes" xml:space="preserve">
          <source>Writes the given short into this buffer at the current position, and then increments the position.</source>
          <target state="translated">현재 위치에서 주어진 short를이 버퍼에 쓴 다음 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="10ed6376a80a004d623217c1faeb7c99a1dda8a2" translate="yes" xml:space="preserve">
          <source>Writes the given short into this buffer at the given index.</source>
          <target state="translated">주어진 인덱스에서 주어진 short를이 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="0d58e1f54ac285ebe48be0cf8a78bf6938ac3d49" translate="yes" xml:space="preserve">
          <source>Writes the line separator.</source>
          <target state="translated">Writes the line separator.</target>
        </trans-unit>
        <trans-unit id="0f1871aeccc02c9dbbfa7844c873c3486c323372" translate="yes" xml:space="preserve">
          <source>Writes the line separator. This invokes &lt;code&gt;output&lt;/code&gt; directly as well as setting the &lt;code&gt;lineLength&lt;/code&gt; to 0.</source>
          <target state="translated">Writes the line separator. This invokes &lt;code&gt;output&lt;/code&gt; directly as well as setting the &lt;code&gt;lineLength&lt;/code&gt; to 0.</target>
        </trans-unit>
        <trans-unit id="a9b3e59953847a43bcec280307207b82f61a7fe6" translate="yes" xml:space="preserve">
          <source>Writes the line separator. This is overriden to make sure we don't replace the newline content in case it is outside normal ascii.</source>
          <target state="translated">Writes the line separator. This is overriden to make sure we don't replace the newline content in case it is outside normal ascii.</target>
        </trans-unit>
        <trans-unit id="24d0b6fd544532d6da39d30f6b008384dfc920fd" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="340f6324944e39f9ec811cc3204c298ba8e22898" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language. The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt; value (depending on the argument's size relative to the driver's limits on &lt;code&gt;NVARCHAR&lt;/code&gt; values) when it sends it to the stream.</source>
          <target state="translated">Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language. The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt; value (depending on the argument's size relative to the driver's limits on &lt;code&gt;NVARCHAR&lt;/code&gt; values) when it sends it to the stream.</target>
        </trans-unit>
        <trans-unit id="2d1f3589491c7e59f4409b383151d9dbaea50dfd" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java boolean.</source>
          <target state="translated">Writes the next attribute to the stream as a Java boolean.</target>
        </trans-unit>
        <trans-unit id="be7661a9ba802f0f8404dcff2f25d0e79592926c" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java boolean. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a Java boolean. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="ac60e91c51e05c39515073eaf54895db2613b6e4" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java byte.</source>
          <target state="translated">Writes the next attribute to the stream as a Java byte.</target>
        </trans-unit>
        <trans-unit id="0a639b1d5b4b69d9459220fd2461435c95a20fc2" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java byte. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a Java byte. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="9593bde4bf357c583e7328e5ea9018696aabeee7" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java double.</source>
          <target state="translated">Writes the next attribute to the stream as a Java double.</target>
        </trans-unit>
        <trans-unit id="0f6bfb271a92d8c8e21181c42abe87ecff6afb06" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java double. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a Java double. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="da9b1e5fa972f78972b24c6e7825131d395a8ccc" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java float.</source>
          <target state="translated">Writes the next attribute to the stream as a Java float.</target>
        </trans-unit>
        <trans-unit id="eb4c3c391c1b9901ee09ed26e81a11b12b2b70d4" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java float. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a Java float. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="a8dec4054e8f37abc1c891b14916680cd86d65a1" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java int.</source>
          <target state="translated">Writes the next attribute to the stream as a Java int.</target>
        </trans-unit>
        <trans-unit id="ab6ffa745bb17cb2125b60fa279c0798e5670e2f" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java int. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a Java int. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="47790b3016da43b530a0ad20df6ae1300b2e0e29" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java long.</source>
          <target state="translated">Writes the next attribute to the stream as a Java long.</target>
        </trans-unit>
        <trans-unit id="1612f1a47c6ca7a2deed650adf88239bc52b77a1" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java long. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a Java long. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="7f9e25e8282f094090e93103d929b57bc1dae11f" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java short.</source>
          <target state="translated">Writes the next attribute to the stream as a Java short.</target>
        </trans-unit>
        <trans-unit id="2d7c5fcc6f952395e88a8fee07a40dc57357b4ce" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java short. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a Java short. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="ae795241e4d0dbed163c78ace2898ad64a209d95" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.math.BigDecimal object.</source>
          <target state="translated">Writes the next attribute to the stream as a java.math.BigDecimal object.</target>
        </trans-unit>
        <trans-unit id="966a161abb638bc66e062577c6601a2f0243654b" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.math.BigDecimal object. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a java.math.BigDecimal object. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="84b6f38a64127bc13fe0460d5ba6bb6f767b58c8" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Date object.</source>
          <target state="translated">Writes the next attribute to the stream as a java.sql.Date object.</target>
        </trans-unit>
        <trans-unit id="94c8593503581612e5c62a36c73e3be22c143d60" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Date object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a java.sql.Date object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="fc86fddad392435fe68b386370732f81602fca4f" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Time object.</source>
          <target state="translated">Writes the next attribute to the stream as a java.sql.Time object.</target>
        </trans-unit>
        <trans-unit id="65f27154a6884b242089f59999a75bc40f12eefa" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Time object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a java.sql.Time object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="b22105b1215f732b1187e26860f8ed1a36976e32" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Timestamp object.</source>
          <target state="translated">Writes the next attribute to the stream as a java.sql.Timestamp object.</target>
        </trans-unit>
        <trans-unit id="5e422e5fae800f499fb8e1d4969f89024012858c" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Timestamp object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as a java.sql.Timestamp object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="cf6ba5d83a2992ff0d3a302518dd1dd97f407273" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a stream of ASCII characters.</source>
          <target state="translated">Writes the next attribute to the stream as a stream of ASCII characters.</target>
        </trans-unit>
        <trans-unit id="a38ae5c63be734084b684282016282bc8c0a5985" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a stream of Unicode characters.</source>
          <target state="translated">Writes the next attribute to the stream as a stream of Unicode characters.</target>
        </trans-unit>
        <trans-unit id="0970c547d7936b50ee00426701f83ff57fde3cfa" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a stream of uninterpreted bytes.</source>
          <target state="translated">Writes the next attribute to the stream as a stream of uninterpreted bytes.</target>
        </trans-unit>
        <trans-unit id="7f36f131f8ab34500af50462c7eadd92c2b76022" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as an array of bytes.</source>
          <target state="translated">Writes the next attribute to the stream as an array of bytes.</target>
        </trans-unit>
        <trans-unit id="7e61a033c461fb7dcfbfdeeada45e9ae7b6869b0" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as an array of bytes. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">Writes the next attribute to the stream as an array of bytes. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</target>
        </trans-unit>
        <trans-unit id="8d975120559c26edf427658d3a3c3d0ebc4d2550" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;byte&lt;/code&gt; to the piped output stream.</source>
          <target state="translated">지정된 &lt;code&gt;byte&lt;/code&gt; 를 파이프 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="5f14d6eee88508e464e25626a9203ab46c7ae8c1" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;byte&lt;/code&gt; to this output stream.</source>
          <target state="translated">지정된 &lt;code&gt;byte&lt;/code&gt; 를이 출력 스트림에 기입합니다 .</target>
        </trans-unit>
        <trans-unit id="2ded1a3671d9de0d3963eef8e96f5518c65ec142" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;char&lt;/code&gt; to the piped output stream.</source>
          <target state="translated">Writes the specified &lt;code&gt;char&lt;/code&gt; to the piped output stream.</target>
        </trans-unit>
        <trans-unit id="fc8ccadb9cba29bd2eb5a6b400b75de445d2099d" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;char&lt;/code&gt; to the piped output stream. If a thread was reading data characters from the connected piped input stream, but the thread is no longer alive, then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">지정된 &lt;code&gt;char&lt;/code&gt; 를 파이프 출력 스트림에 씁니다 . 스레드가 연결된 파이프 된 입력 스트림에서 데이터 문자를 읽었지만 스레드가 더 이상 &lt;code&gt;IOException&lt;/code&gt; 가 아닌 경우 IOException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ab111c3fb2ece34959961ef2a47f24f69db4b45" translate="yes" xml:space="preserve">
          <source>Writes the specified byte (the low eight bits of the argument &lt;code&gt;b&lt;/code&gt;) to the underlying output stream.</source>
          <target state="translated">Writes the specified byte (the low eight bits of the argument &lt;code&gt;b&lt;/code&gt; ) to the underlying output stream.</target>
        </trans-unit>
        <trans-unit id="6a361965d78596b1ec164e036366e12d2c75bb2c" translate="yes" xml:space="preserve">
          <source>Writes the specified byte (the low eight bits of the argument &lt;code&gt;b&lt;/code&gt;) to the underlying output stream. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">지정된 바이트 (인수 &lt;code&gt;b&lt;/code&gt; 의 하위 8 비트 )를 기본이되는 출력 스트림에 기입합니다. 예외가 발생하지 않으면 &lt;code&gt;written&lt;/code&gt; 된 카운터 는 &lt;code&gt;1&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="f395fe152479fa6fe3982d50f757a564445e03a3" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt;.</source>
          <target state="translated">Writes the specified byte to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="112760f7a5bd1088e95174f743f77e6540d54a2b" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this buffered output stream.</source>
          <target state="translated">지정된 바이트를이 버퍼 된 출력 스트림에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="7609567d3c31861f0c015f22b9e866c66abef6ef" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this byte array output stream.</source>
          <target state="translated">지정된 바이트를이 바이트 배열 출력 스트림에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="f7ca3263ecdf5bfa2fcb28af4f0f50c9aa5238d5" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file output stream.</source>
          <target state="translated">Writes the specified byte to this file output stream.</target>
        </trans-unit>
        <trans-unit id="2b4802f7b977b1bf85147c28f9685965b5454afa" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file output stream. Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">지정된 바이트를이 파일 출력 스트림에 기입합니다. &lt;code&gt;OutputStream&lt;/code&gt; 의 &lt;code&gt;write&lt;/code&gt; 메소드를 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="aef8e765886b82ee496b736f4dd9d04b5b58c2cb" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file.</source>
          <target state="translated">Writes the specified byte to this file.</target>
        </trans-unit>
        <trans-unit id="b729d9dffaa8a1f4157fef1e1ce618b624909b04" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file. The write starts at the current file pointer.</source>
          <target state="translated">지정된 바이트를이 파일에 씁니다. 현재 파일 포인터에서 쓰기가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ba3a4edd85917756c50fa03243093621eed1d538" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this output stream.</source>
          <target state="translated">지정된 바이트를이 출력 스트림에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="b599b1fa291253a78c3e88600501e421edb1c042" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this output stream. The general contract for &lt;code&gt;write&lt;/code&gt; is that one byte is written to the output stream. The byte to be written is the eight low-order bits of the argument &lt;code&gt;b&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.</source>
          <target state="translated">지정된 바이트를이 출력 스트림에 기입합니다. &lt;code&gt;write&lt;/code&gt; 의 일반적인 계약 은 1 바이트가 출력 스트림에 쓰여지는 것입니다. 기입 해지는 바이트는 인수 &lt;code&gt;b&lt;/code&gt; 의 하위 8 비트입니다 . &lt;code&gt;b&lt;/code&gt; 의 24 개 상위 비트 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8971c513647c69b909bf210695c94f545ca38243" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this stream.</source>
          <target state="translated">Writes the specified byte to this stream.</target>
        </trans-unit>
        <trans-unit id="e958c00a95c755222bae929710882f0ef7598984" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this stream. If the byte is a newline and automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.</source>
          <target state="translated">지정된 바이트를이 스트림에 기입합니다. 바이트가 줄 바꿈이고 자동 플러시가 사용 가능한 경우 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b17cdee8b1cf493966a1e22479e14f7926cbdbfb" translate="yes" xml:space="preserve">
          <source>Writes the string to the file as a sequence of bytes.</source>
          <target state="translated">Writes the string to the file as a sequence of bytes.</target>
        </trans-unit>
        <trans-unit id="8a7ff01c245c6e87c2ac4ef96cf3070915dfcaaf" translate="yes" xml:space="preserve">
          <source>Writes the string to the file as a sequence of bytes. Each character in the string is written out, in sequence, by discarding its high eight bits. The write starts at the current position of the file pointer.</source>
          <target state="translated">문자열을 바이트 시퀀스로 파일에 씁니다. 문자열의 각 문자는 상위 8 비트를 삭제하여 순서대로 작성됩니다. 쓰기는 파일 포인터의 현재 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a5af43cf06c929a83885e6406856a92aa5cc38" translate="yes" xml:space="preserve">
          <source>Writes the value of a user-defined attribute from a buffer.</source>
          <target state="translated">버퍼에서 사용자 정의 속성 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="6de7b1d847ae56079e54f185e80246ad8ca6539e" translate="yes" xml:space="preserve">
          <source>Writes this object to the given SQL data stream, converting it back to its SQL value in the data source.</source>
          <target state="translated">Writes this object to the given SQL data stream, converting it back to its SQL value in the data source.</target>
        </trans-unit>
        <trans-unit id="d10aa40878b44a62bd75f37a923af2794ac38513" translate="yes" xml:space="preserve">
          <source>Writes this object to the given SQL data stream, converting it back to its SQL value in the data source. The implementation of the method must follow this protocol:</source>
          <target state="translated">Writes this object to the given SQL data stream, converting it back to its SQL value in the data source. The implementation of the method must follow this protocol:</target>
        </trans-unit>
        <trans-unit id="207b013c329390f09844c66437576494a2852d98" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output character stream in a format suitable for using the &lt;a href=&quot;#load(java.io.Reader)&quot;&gt;&lt;code&gt;load(Reader)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output character stream in a format suitable for using the &lt;a href=&quot;#load(java.io.Reader)&quot;&gt; &lt;code&gt;load(Reader)&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="51e35b34ff21aa3824ad435b3d42b717ac1044a7" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output character stream in a format suitable for using the &lt;a href=&quot;properties#load-java.io.Reader-&quot;&gt;&lt;code&gt;load(Reader)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 &lt;code&gt;Properties&lt;/code&gt; 테이블 의이 속성 목록 (키 및 요소 쌍)을 &lt;a href=&quot;properties#load-java.io.Reader-&quot;&gt; &lt;code&gt;load(Reader)&lt;/code&gt; &lt;/a&gt; 메서드 사용에 적합한 형식으로 출력 문자 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e495c69a1b37a4ce090a0f61eb84303001e2f066" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output stream in a format suitable for loading into a &lt;code&gt;Properties&lt;/code&gt; table using the &lt;a href=&quot;#load(java.io.InputStream)&quot;&gt;&lt;code&gt;load(InputStream)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output stream in a format suitable for loading into a &lt;code&gt;Properties&lt;/code&gt; table using the &lt;a href=&quot;#load(java.io.InputStream)&quot;&gt; &lt;code&gt;load(InputStream)&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="51b4a7c90bf5626fec9c9f129aa1374ad6737d2c" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output stream in a format suitable for loading into a &lt;code&gt;Properties&lt;/code&gt; table using the &lt;a href=&quot;properties#load-java.io.InputStream-&quot;&gt;&lt;code&gt;load(InputStream)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;properties#load-java.io.InputStream-&quot;&gt; &lt;code&gt;load(InputStream)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;Properties&lt;/code&gt; 테이블 에로드하기에 적합한 형식 으로이 &lt;code&gt;Properties&lt;/code&gt; 테이블 의이 특성 목록 (키 및 요소 쌍)을 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="5d1e33d407f7be7c57261888fc679ef1b7584671" translate="yes" xml:space="preserve">
          <source>Writes to the output stream all the bytes in array &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Writes to the output stream all the bytes in array &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f13a505bf6f1163d15ecf793f7208b545f326a38" translate="yes" xml:space="preserve">
          <source>Writes to the output stream all the bytes in array &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;b.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the byte &lt;code&gt;b[0]&lt;/code&gt; is written first, then &lt;code&gt;b[1]&lt;/code&gt;, and so on; the last byte written is &lt;code&gt;b[b.length-1]&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;b&lt;/code&gt; 의 모든 바이트를 출력 스트림에 기입합니다 . 경우 &lt;code&gt;b&lt;/code&gt; 는 이다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다. 만약 &lt;code&gt;b.length&lt;/code&gt; 를 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 바이트 &lt;code&gt;b[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;b[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 바이트는 &lt;code&gt;b[b.length-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8514d628233a1a6ce1964bd5fc5b29aeaa728dad" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low- order bits of the argument &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Writes to the output stream the eight low- order bits of the argument &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3634369cc0a70228335b7c0d1b3ea2b4c26bb08d" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low- order bits of the argument &lt;code&gt;v&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. (This means that &lt;code&gt;writeByte&lt;/code&gt; does exactly the same thing as &lt;code&gt;write&lt;/code&gt; for an integer argument.) The byte written by this method may be read by the &lt;code&gt;readByte&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;byte&lt;/code&gt; equal to &lt;code&gt;(byte)v&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;v&lt;/code&gt; 의 하위 8 비트를 출력 스트림에 출력합니다 . &lt;code&gt;v&lt;/code&gt; 의 24 개 상위 비트 는 무시됩니다. 이것은 &lt;code&gt;writeByte&lt;/code&gt; 가 정수 인수에 대한 &lt;code&gt;write&lt;/code&gt; 와 정확히 같은 것을 의미합니다 .이 메소드에 의해 쓰여진 바이트는 &lt;code&gt;readByte&lt;/code&gt; 에 의해 읽힐 수 있습니다. &lt;code&gt;DataInput&lt;/code&gt; 인터페이스 메소드에 , 그런 다음 &lt;code&gt;(byte)v&lt;/code&gt; 와 동일한 &lt;code&gt;byte&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a0cf69d6c69bcf0faa8baab0cbc731ba085221ea" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Writes to the output stream the eight low-order bits of the argument &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94e71f080b530ff97228da57a38da0da555e275b" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;b&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.</source>
          <target state="translated">인수 &lt;code&gt;b&lt;/code&gt; 의 하위 8 비트를 출력 스트림에 출력합니다 . &lt;code&gt;b&lt;/code&gt; 의 24 개 상위 비트 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c65468e87575c6e9fa9a826657a87e56933e290" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;v&lt;/code&gt; 의 하위 8 비트를 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="54f0fe973a856a893d528e0a57e3fd8c6d66f0de" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;v&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. (This means that &lt;code&gt;writeByte&lt;/code&gt; does exactly the same thing as &lt;code&gt;write&lt;/code&gt; for an integer argument.) The byte written by this method may be read by the &lt;code&gt;readByte&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;byte&lt;/code&gt; equal to &lt;code&gt;(byte)v&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;v&lt;/code&gt; 의 하위 8 비트를 출력 스트림에 씁니다 . &lt;code&gt;v&lt;/code&gt; 의 상위 24 비트 는 무시됩니다. (이것은 &lt;code&gt;writeByte&lt;/code&gt; 가 정수 인수에 대한 &lt;code&gt;write&lt;/code&gt; 와 정확히 동일한 작업 을 수행함을 의미합니다 .)이 메소드가 쓴 바이트는 &lt;code&gt;DataInput&lt;/code&gt; 인터페이스 의 &lt;code&gt;readByte&lt;/code&gt; 메소드에서 읽을 수 있으며 , 그러면 &lt;code&gt;(byte)v&lt;/code&gt; 와 같은 &lt;code&gt;byte&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bf32e90bca78d37e28d45fb95b94078d84950f46" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object.</source>
          <target state="translated">Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="1839e48f3104f8ae0db661096310023645bcf7d2" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object. When the &lt;code&gt;SQLData&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;, this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream. Otherwise, it calls the &lt;code&gt;SQLData.writeSQL&lt;/code&gt; method of the given object, which writes the object's attributes to the stream.</source>
          <target state="translated">Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object. When the &lt;code&gt;SQLData&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt; , this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream. Otherwise, it calls the &lt;code&gt;SQLData.writeSQL&lt;/code&gt; method of the given object, which writes the object's attributes to the stream.</target>
        </trans-unit>
        <trans-unit id="363c2b77917ba97ed7dfdca74cae97621fbdddc4" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object. When the &lt;code&gt;SQLData&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;, this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream. Otherwise, it calls the &lt;code&gt;SQLData.writeSQL&lt;/code&gt; method of the given object, which writes the object's attributes to the stream. The implementation of the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; calls the appropriate &lt;code&gt;SQLOutput&lt;/code&gt; writer method(s) for writing each of the object's attributes in order. The attributes must be read from an &lt;code&gt;SQLInput&lt;/code&gt; input stream and written to an &lt;code&gt;SQLOutput&lt;/code&gt; output stream in the same order in which they were listed in the SQL definition of the user-defined type.</source>
          <target state="translated">Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object. When the &lt;code&gt;SQLData&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt; , this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream. Otherwise, it calls the &lt;code&gt;SQLData.writeSQL&lt;/code&gt; method of the given object, which writes the object's attributes to the stream. The implementation of the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; calls the appropriate &lt;code&gt;SQLOutput&lt;/code&gt; writer method(s) for writing each of the object's attributes in order. The attributes must be read from an &lt;code&gt;SQLInput&lt;/code&gt; input stream and written to an &lt;code&gt;SQLOutput&lt;/code&gt; output stream in the same order in which they were listed in the SQL definition of the user-defined type.</target>
        </trans-unit>
        <trans-unit id="8e830ac9520dde8effa90ef42b6c3c7f73f65364" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given object.</source>
          <target state="translated">Writes to the stream the data contained in the given object.</target>
        </trans-unit>
        <trans-unit id="8873fa76c2f527781970d368373d33a03dbd6d75" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given object. The object will be converted to the specified targetSqlType before being sent to the stream.</source>
          <target state="translated">Writes to the stream the data contained in the given object. The object will be converted to the specified targetSqlType before being sent to the stream.</target>
        </trans-unit>
        <trans-unit id="1dcbd1fcd9c20910e4d19c79a6908b0180531555" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given char value, in the current byte order, into this buffer at the current position, and then increments the position by two.</source>
          <target state="translated">현재 바이트 순서로 지정된 char 값을 포함하는 2 바이트를 현재 위치의이 버퍼에 쓴 다음 위치를 2 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e978de920f972d75d95f1255bab54910641e5e61" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given char value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">지정된 char 값을 포함하는 2 바이트를 현재 바이트 순서로 지정된 인덱스의이 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="6fc0c682093f02b665c23020bba01582a4b98e28" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given short value, in the current byte order, into this buffer at the current position, and then increments the position by two.</source>
          <target state="translated">주어진 바이트 값으로 주어진 짧은 값을 포함하는 2 바이트를 현재 위치의이 버퍼에 쓴 다음 위치를 2 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="0f419b1c9cfcd70b38af34a51aebf7df8b86f76e" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given short value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">주어진 짧은 값을 포함하는 두 바이트를 현재 바이트 순서로 지정된 인덱스의이 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="e6d8fbbfcfd69eef504dcac6d1ae51eb79ffbc5f" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt; modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">2 바이트 길이 정보를 네트워크 바이트 순서로 출력 스트림에 쓴 다음 문자열 &lt;code&gt;s&lt;/code&gt; 에있는 모든 문자 의 &lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt;수정 된 UTF-8&lt;/a&gt; 표현을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="11f8bb9bf8b8a3b9415c961461d6b9561351459f" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt; modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. Each character in the string &lt;code&gt;s&lt;/code&gt; is converted to a group of one, two, or three bytes, depending on the value of the character.</source>
          <target state="translated">2 바이트 길이 정보를 네트워크 바이트 순서로 출력 스트림에 쓴 다음 문자열 &lt;code&gt;s&lt;/code&gt; 에있는 모든 문자 의 &lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt;수정 된 UTF-8&lt;/a&gt; 표현을 씁니다 . 경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 발생합니다. 문자열 &lt;code&gt;s&lt;/code&gt; 의 각 문자 는 문자 값에 따라 1, 2 또는 3 바이트 그룹으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ee80091edbeade9265ab307086b86eb4ae01dddf" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6256eb9d0d72cbe71b13a3c7e9f7676978fe16" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. Each character in the string &lt;code&gt;s&lt;/code&gt; is converted to a group of one, two, or three bytes, depending on the value of the character.</source>
          <target state="translated">네트워크 바이트 순서로 출력 스트림에 2 바이트 길이의 정보를 &lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;쓰고&lt;/a&gt; 문자열 &lt;code&gt;s&lt;/code&gt; 의 모든 문자에 대해 수정 된 UTF-8 표현을 씁니다. . 경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 발생합니다. 문자열 &lt;code&gt;s&lt;/code&gt; 각 문자 는 문자 값에 따라 1, 2 또는 3 바이트 그룹으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="61fed0fe63590aa8fe08508149b0ac07f0edb001" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream, followed by the &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Writes two bytes of length information to the output stream, followed by the &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acb381ca0baa70d627eb89fc91539d21b5b1970f" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream, followed by the &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. Each character in the string &lt;code&gt;s&lt;/code&gt; is converted to a group of one, two, or three bytes, depending on the value of the character.</source>
          <target state="translated">출력 스트림에 2 바이트 길이의 정보를 쓴 다음 문자열 &lt;code&gt;s&lt;/code&gt; 에있는 모든 문자 의 &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;수정 된 UTF-8&lt;/a&gt; 표현을 씁니다 . 만약 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 발생합니다. 문자열 &lt;code&gt;s&lt;/code&gt; 각 문자 는 문자 값에 따라 1, 2 또는 3 바이트 그룹으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="11a7c7a4a4b01ec9ba0d240cb1a9682883bcf927" translate="yes" xml:space="preserve">
          <source>Writes two bytes to the output stream to represent the value of the argument.</source>
          <target state="translated">Writes two bytes to the output stream to represent the value of the argument.</target>
        </trans-unit>
        <trans-unit id="840baa9d6bfa2b29f18593baa6d5a15f4137eaeb" translate="yes" xml:space="preserve">
          <source>Writes two bytes to the output stream to represent the value of the argument. The byte values to be written, in the order shown, are:</source>
          <target state="translated">인수의 값을 나타 내기 위해 출력 스트림에 2 바이트를 씁니다. 표시된 순서대로 기록 할 바이트 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2dabb8334b6cbbc19635a160f00032f11eeb9962" translate="yes" xml:space="preserve">
          <source>Writing</source>
          <target state="translated">Writing</target>
        </trans-unit>
        <trans-unit id="95ad111c35bebeafa25fe06efdef5f08bcb7e909" translate="yes" xml:space="preserve">
          <source>Writing GIF images</source>
          <target state="translated">GIF 이미지 쓰기</target>
        </trans-unit>
        <trans-unit id="424422e9c1df6af363f8dd1c46652e8af0cdb465" translate="yes" xml:space="preserve">
          <source>Writing a &lt;code&gt;WebRowSet&lt;/code&gt; object includes printing the rowset's data, metadata, and properties, all with the appropriate XML tags.</source>
          <target state="translated">Writing a &lt;code&gt;WebRowSet&lt;/code&gt; object includes printing the rowset's data, metadata, and properties, all with the appropriate XML tags.</target>
        </trans-unit>
        <trans-unit id="dddf90dcfc18cbf45f914c903cf3587716a02561" translate="yes" xml:space="preserve">
          <source>Writing a packet does not do any integrity checking on the packet aside from checking the packet length. Checking the packet length requires checking that the value of the &lt;code&gt;length&lt;/code&gt; field (as indicated by the first four bytes of the packet) is 11 or greater. Consequently the length of the byte array provided to this method, that is &lt;code&gt;pkt.length&lt;/code&gt;, must be 11 or more, and must be equal or greater than the value of the &lt;code&gt;length&lt;/code&gt; field. If the length of the byte array is greater than the value of the &lt;code&gt;length&lt;/code&gt; field then all bytes from element &lt;code&gt;pkt[length]&lt;/code&gt; onwards are ignored. In other words, any additional bytes that follow the packet in the byte array are ignored and will not be transmitted to the target VM.</source>
          <target state="translated">패킷을 쓰는 것은 패킷 길이를 확인하는 것 외에 패킷에 대한 무결성 확인을 수행하지 않습니다. 패킷 길이를 확인하려면 &lt;code&gt;length&lt;/code&gt; 필드 의 값 (패킷의 처음 4 바이트로 표시됨)이 11 이상인지 확인해야합니다. 결과적으로이 메소드에 제공된 바이트 배열의 길이, 즉 &lt;code&gt;pkt.length&lt;/code&gt; 는 11 이상이어야하며 &lt;code&gt;length&lt;/code&gt; 필드 의 값보다 크거나 같아야 합니다. 바이트 배열의 &lt;code&gt;length&lt;/code&gt; 필드 의 값보다 크면 &lt;code&gt;pkt[length]&lt;/code&gt; 요소 이후의 모든 바이트 가 무시됩니다. 즉, 바이트 배열에서 패킷 뒤에 오는 추가 바이트는 무시되고 대상 VM으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cd3c35e027988d3e72acc1181f58b176b562470" translate="yes" xml:space="preserve">
          <source>Writing out a bean, on the other hand, sometimes requires special knowledge of the bean's type. If the bean's state can be expressed using only the no-argument constructor and public getter and setter methods for properties, no special knowledge is required. Otherwise, the bean requires a custom &lt;em&gt;persistence delegate&lt;/em&gt; -- an object that is in charge of writing out beans of a particular type. All classes provided in the JDK that descend from &lt;code&gt;java.awt.Component&lt;/code&gt;, as well as all their properties, automatically have persistence delegates.</source>
          <target state="translated">반면에 콩을 쓰려면 콩의 종류에 대한 특별한 지식이 필요합니다. 인수없이 생성자 및 특성에 대한 공용 getter 및 setter 메소드 만 사용하여 Bean의 상태를 표시 할 수있는 경우 특별한 지식이 필요하지 않습니다. 그렇지 않으면, Bean은 사용자 정의가 필요합니다&lt;em&gt;&lt;/em&gt; 특정 유형의 Bean을 작성하는 오브젝트 인&lt;em&gt; 지속성 위임이&lt;/em&gt; . JDK에서 제공되는 모든 클래스 뿐만 아니라 &lt;code&gt;java.awt.Component&lt;/code&gt; 에서 파생 된 모든 클래스 에는 자동으로 지속성 위임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aca6c8bd10dab33a4eec99abb3e68b55ac1f71c" translate="yes" xml:space="preserve">
          <source>Writing to file descriptors</source>
          <target state="translated">파일 디스크립터에 쓰기</target>
        </trans-unit>
        <trans-unit id="087742bd2a01740eeb022cb23d5b57ca20a16d8d" translate="yes" xml:space="preserve">
          <source>WrongMethodTypeException</source>
          <target state="translated">WrongMethodTypeException</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="db449d7dc04f973b1ad97228d3cd5fa1f5225e0b" translate="yes" xml:space="preserve">
          <source>X be the MBean named by &lt;code&gt;name&lt;/code&gt;,</source>
          <target state="translated">X는 다음에 의해 명명 된 MBean입니다. &lt;code&gt;name&lt;/code&gt; 으로 .</target>
        </trans-unit>
        <trans-unit id="04d117bbef4a6bcdcdff089df98755d8aa7b99de" translate="yes" xml:space="preserve">
          <source>X coordinate the control point</source>
          <target state="translated">X coordinate the control point</target>
        </trans-unit>
        <trans-unit id="d6eed17085cd961824e6cc026bad4e1f6bbfdf9a" translate="yes" xml:space="preserve">
          <source>X dimension (&amp;micro;m).</source>
          <target state="translated">X 치수 (&amp;micro;m).</target>
        </trans-unit>
        <trans-unit id="7f266332102748822354cc0a5aa107093c35ebbd" translate="yes" xml:space="preserve">
          <source>X dimension.</source>
          <target state="translated">X 치수.</target>
        </trans-unit>
        <trans-unit id="b5610424b8a02ba2abc09a2e8508cc30ad10e2b3" translate="yes" xml:space="preserve">
          <source>X,</source>
          <target state="translated">X,</target>
        </trans-unit>
        <trans-unit id="34826acc1a06fc5b72d40097770b09d8e5c62652" translate="yes" xml:space="preserve">
          <source>X, as a &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#cg&quot;&gt;캡처 그룹&lt;/a&gt; 으로서의 X</target>
        </trans-unit>
        <trans-unit id="153bf828911a9b26f94f5e8da8f2fb9bb7b28fe4" translate="yes" xml:space="preserve">
          <source>X.509, PGP, and SDSI certificates can all be implemented by subclassing the Certificate class, even though they contain different sets of information, and they store and retrieve the information in different ways.</source>
          <target state="translated">X.509, PGP 및 SDSI 인증서는 서로 다른 정보 세트가 포함되어 있어도 Certificate 클래스를 서브 클래 싱하여 구현할 수 있으며 다른 방식으로 정보를 저장 및 검색합니다.</target>
        </trans-unit>
        <trans-unit id="4590145268458005ff818a940acd5d70ab872d49" translate="yes" xml:space="preserve">
          <source>X25519</source>
          <target state="translated">X25519</target>
        </trans-unit>
        <trans-unit id="1c1a210cdcf74ff605ceeee78ea3b4156161eddf" translate="yes" xml:space="preserve">
          <source>X448</source>
          <target state="translated">X448</target>
        </trans-unit>
        <trans-unit id="1bd269c56dd4b87ce14015ee8fa37115311520bf" translate="yes" xml:space="preserve">
          <source>X500Principal</source>
          <target state="translated">X500Principal</target>
        </trans-unit>
        <trans-unit id="ebe07aff1a5d06134e103668254133e47ebed3d3" translate="yes" xml:space="preserve">
          <source>X500Principal.equals()</source>
          <target state="translated">X500Principal.equals()</target>
        </trans-unit>
        <trans-unit id="44f531c8910ef1690c5414e940f95622b4b29dac" translate="yes" xml:space="preserve">
          <source>X500Principal.getEncoded()</source>
          <target state="translated">X500Principal.getEncoded()</target>
        </trans-unit>
        <trans-unit id="08dc2bb2b748578a12935a031ae247bdbc506c92" translate="yes" xml:space="preserve">
          <source>X500Principal.getName()</source>
          <target state="translated">X500Principal.getName()</target>
        </trans-unit>
        <trans-unit id="85e52a880efe4b288d45c41cedbc91debb817b34" translate="yes" xml:space="preserve">
          <source>X500Principal.hashCode()</source>
          <target state="translated">X500Principal.hashCode()</target>
        </trans-unit>
        <trans-unit id="f6d4ed090724f259caa864b84485151a2f5ed2a6" translate="yes" xml:space="preserve">
          <source>X500Principal.toString()</source>
          <target state="translated">X500Principal.toString()</target>
        </trans-unit>
        <trans-unit id="aa7c4644ed192385ca463ead0261d1728512dd3b" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential</source>
          <target state="translated">X500PrivateCredential</target>
        </trans-unit>
        <trans-unit id="d034f128505231d7ac518742ffbbed3e97e6e481" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.destroy()</source>
          <target state="translated">X500PrivateCredential.destroy()</target>
        </trans-unit>
        <trans-unit id="a6e9eecb44deb79c51837aacde9e046aa902e33a" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.getAlias()</source>
          <target state="translated">X500PrivateCredential.getAlias()</target>
        </trans-unit>
        <trans-unit id="9f750adea9e5263dff3d30eb16f0098cfb5c1a5b" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.getCertificate()</source>
          <target state="translated">X500PrivateCredential.getCertificate()</target>
        </trans-unit>
        <trans-unit id="6ad4479421ed09f884c8c3e0c36adabeee8170df" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.getPrivateKey()</source>
          <target state="translated">X500PrivateCredential.getPrivateKey()</target>
        </trans-unit>
        <trans-unit id="ef0ff1d8b5787f71f3646c30049b1d7a2bca631f" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.isDestroyed()</source>
          <target state="translated">X500PrivateCredential.isDestroyed()</target>
        </trans-unit>
        <trans-unit id="686dd940cc8227b0aa2cd69ee1f44cfa6d1e893f" translate="yes" xml:space="preserve">
          <source>X509CRL</source>
          <target state="translated">X509CRL</target>
        </trans-unit>
        <trans-unit id="7110aa0404043c957aa839aa47f0f0c0a235d814" translate="yes" xml:space="preserve">
          <source>X509CRL.equals()</source>
          <target state="translated">X509CRL.equals()</target>
        </trans-unit>
        <trans-unit id="a8d0f2a8e61792cb750521d01ae1c425200eee29" translate="yes" xml:space="preserve">
          <source>X509CRL.getEncoded()</source>
          <target state="translated">X509CRL.getEncoded()</target>
        </trans-unit>
        <trans-unit id="2f2c2d9ad2feed06f68886e5534e5a1725acf6f0" translate="yes" xml:space="preserve">
          <source>X509CRL.getIssuerDN()</source>
          <target state="translated">X509CRL.getIssuerDN()</target>
        </trans-unit>
        <trans-unit id="d5041e1c7a5b762dee37a31bfd82a14e09c5c33e" translate="yes" xml:space="preserve">
          <source>X509CRL.getIssuerX500Principal()</source>
          <target state="translated">X509CRL.getIssuerX500Principal()</target>
        </trans-unit>
        <trans-unit id="b2723672bad69076cb03b2b1698dc03f59d0ea09" translate="yes" xml:space="preserve">
          <source>X509CRL.getNextUpdate()</source>
          <target state="translated">X509CRL.getNextUpdate()</target>
        </trans-unit>
        <trans-unit id="406fe17fe2408adebb3de6191ff98d0aae6574e7" translate="yes" xml:space="preserve">
          <source>X509CRL.getRevokedCertificate()</source>
          <target state="translated">X509CRL.getRevokedCertificate()</target>
        </trans-unit>
        <trans-unit id="c282b03b35ba6133d7f69263475d3e79c4c96d18" translate="yes" xml:space="preserve">
          <source>X509CRL.getRevokedCertificates()</source>
          <target state="translated">X509CRL.getRevokedCertificates()</target>
        </trans-unit>
        <trans-unit id="676975bb590ac24ff50fbec531440b871beceedb" translate="yes" xml:space="preserve">
          <source>X509CRL.getSigAlgName()</source>
          <target state="translated">X509CRL.getSigAlgName()</target>
        </trans-unit>
        <trans-unit id="cca79e74cc8ba51fac9fb5484e66124607d369d9" translate="yes" xml:space="preserve">
          <source>X509CRL.getSigAlgOID()</source>
          <target state="translated">X509CRL.getSigAlgOID()</target>
        </trans-unit>
        <trans-unit id="28c2198822dff08b6100d64abef2998ea91df931" translate="yes" xml:space="preserve">
          <source>X509CRL.getSigAlgParams()</source>
          <target state="translated">X509CRL.getSigAlgParams()</target>
        </trans-unit>
        <trans-unit id="817097db4f4524b7475ee9a94624753adaeec91b" translate="yes" xml:space="preserve">
          <source>X509CRL.getSignature()</source>
          <target state="translated">X509CRL.getSignature()</target>
        </trans-unit>
        <trans-unit id="a6853b01102efc16cd41b4f21b2c2403aa88fbec" translate="yes" xml:space="preserve">
          <source>X509CRL.getTBSCertList()</source>
          <target state="translated">X509CRL.getTBSCertList()</target>
        </trans-unit>
        <trans-unit id="859688e6f0f0d21f0915e65120c504f1568c0fa0" translate="yes" xml:space="preserve">
          <source>X509CRL.getThisUpdate()</source>
          <target state="translated">X509CRL.getThisUpdate()</target>
        </trans-unit>
        <trans-unit id="666eba5f3eb0836f485542f2b3612b3740a26658" translate="yes" xml:space="preserve">
          <source>X509CRL.getVersion()</source>
          <target state="translated">X509CRL.getVersion()</target>
        </trans-unit>
        <trans-unit id="ef777faf32e00157c932d26e4a91ee3ec2d48f1e" translate="yes" xml:space="preserve">
          <source>X509CRL.hashCode()</source>
          <target state="translated">X509CRL.hashCode()</target>
        </trans-unit>
        <trans-unit id="7df628731cfd156631b4a6dde9d8100f8bf13d59" translate="yes" xml:space="preserve">
          <source>X509CRL.verify()</source>
          <target state="translated">X509CRL.verify()</target>
        </trans-unit>
        <trans-unit id="4929c310370b1f2c4432d741b376aa8796d6daa6" translate="yes" xml:space="preserve">
          <source>X509CRLEntry</source>
          <target state="translated">X509CRLEntry</target>
        </trans-unit>
        <trans-unit id="6f506b182e9c3e2ee873d77a6b41722c00ad04f0" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.equals()</source>
          <target state="translated">X509CRLEntry.equals()</target>
        </trans-unit>
        <trans-unit id="4ea40e3fc5a6e22b9ad4abfb207a580ed449dd38" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getCertificateIssuer()</source>
          <target state="translated">X509CRLEntry.getCertificateIssuer()</target>
        </trans-unit>
        <trans-unit id="236c0633cfcd4437299c5cfa51b69a58189686f3" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getEncoded()</source>
          <target state="translated">X509CRLEntry.getEncoded()</target>
        </trans-unit>
        <trans-unit id="dc242325ee95b283e2bce2346034bb12bd0bfcec" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getRevocationDate()</source>
          <target state="translated">X509CRLEntry.getRevocationDate()</target>
        </trans-unit>
        <trans-unit id="c8deeea3d6af56508cad742a99121e62126d0753" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getRevocationReason()</source>
          <target state="translated">X509CRLEntry.getRevocationReason()</target>
        </trans-unit>
        <trans-unit id="70dc85fba9f70a00f5b5be5375f4f46bd97ff72f" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getSerialNumber()</source>
          <target state="translated">X509CRLEntry.getSerialNumber()</target>
        </trans-unit>
        <trans-unit id="82ac9fc56fd26a520483391d1fc255e7a65ad123" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.hasExtensions()</source>
          <target state="translated">X509CRLEntry.hasExtensions()</target>
        </trans-unit>
        <trans-unit id="e49e98981f178c407f6c206c52398697a35c2131" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.hashCode()</source>
          <target state="translated">X509CRLEntry.hashCode()</target>
        </trans-unit>
        <trans-unit id="002a4ee189ce5a952707a0330d74fddbc21248bf" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.toString()</source>
          <target state="translated">X509CRLEntry.toString()</target>
        </trans-unit>
        <trans-unit id="0537cdb42327ff3a67d3ea83f714032cba724024" translate="yes" xml:space="preserve">
          <source>X509CRLSelector</source>
          <target state="translated">X509CRLSelector</target>
        </trans-unit>
        <trans-unit id="005121bdf2647a03921558ab963894a107961c75" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.addIssuer()</source>
          <target state="translated">X509CRLSelector.addIssuer()</target>
        </trans-unit>
        <trans-unit id="7aceb5d988f24a52dd02f464ca3d9494b9babed9" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.addIssuerName()</source>
          <target state="translated">X509CRLSelector.addIssuerName()</target>
        </trans-unit>
        <trans-unit id="8284e8efc69ac3a83307e2cafdf63753734cc0c4" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.clone()</source>
          <target state="translated">X509CRLSelector.clone()</target>
        </trans-unit>
        <trans-unit id="db9deb73c56072075cef0974014cbfa6b6abb260" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getCertificateChecking()</source>
          <target state="translated">X509CRLSelector.getCertificateChecking()</target>
        </trans-unit>
        <trans-unit id="6ab4ca2011fa8c661e4158060a00d8943b99ef0e" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getDateAndTime()</source>
          <target state="translated">X509CRLSelector.getDateAndTime()</target>
        </trans-unit>
        <trans-unit id="5532ca5d6569c1cbe8f868920ffc31a6e9707b99" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getIssuerNames()</source>
          <target state="translated">X509CRLSelector.getIssuerNames()</target>
        </trans-unit>
        <trans-unit id="032e18f3ad4222c7bc737794768e950215da9b65" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getIssuers()</source>
          <target state="translated">X509CRLSelector.getIssuers()</target>
        </trans-unit>
        <trans-unit id="07343df6a607c3fccbbf96fd3aa6b9b3a4fc4ef9" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getMaxCRL()</source>
          <target state="translated">X509CRLSelector.getMaxCRL()</target>
        </trans-unit>
        <trans-unit id="5caa7704f0fbf71e8eda99020577a4f32ed3aec7" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getMinCRL()</source>
          <target state="translated">X509CRLSelector.getMinCRL()</target>
        </trans-unit>
        <trans-unit id="cd016510ad0b64a2934299f67f11e5252571bb4c" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.match()</source>
          <target state="translated">X509CRLSelector.match()</target>
        </trans-unit>
        <trans-unit id="258d0b9571e5a2fda60a3574315cefbabaa4dd5a" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setCertificateChecking()</source>
          <target state="translated">X509CRLSelector.setCertificateChecking()</target>
        </trans-unit>
        <trans-unit id="d500c0b9ab0836602fbfeff49c264f434688fe8b" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setDateAndTime()</source>
          <target state="translated">X509CRLSelector.setDateAndTime()</target>
        </trans-unit>
        <trans-unit id="96a92cb7a8b71831980d1424a5364d676285b68d" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setIssuerNames()</source>
          <target state="translated">X509CRLSelector.setIssuerNames()</target>
        </trans-unit>
        <trans-unit id="90cfbcab2db3279ddd6db3561807d714cfdd0713" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setIssuers()</source>
          <target state="translated">X509CRLSelector.setIssuers()</target>
        </trans-unit>
        <trans-unit id="bf06aacef9a3be1a9ced4a10cbdd678a2f274350" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setMaxCRLNumber()</source>
          <target state="translated">X509CRLSelector.setMaxCRLNumber()</target>
        </trans-unit>
        <trans-unit id="86a0b242f3cd5aa3f58de645180e4a240a5db1f7" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setMinCRLNumber()</source>
          <target state="translated">X509CRLSelector.setMinCRLNumber()</target>
        </trans-unit>
        <trans-unit id="4321c653c660b241a08140ff511b46a70156446e" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.toString()</source>
          <target state="translated">X509CRLSelector.toString()</target>
        </trans-unit>
        <trans-unit id="94342e1781dc9c33a70ca21cb6357db0b0b9dd67" translate="yes" xml:space="preserve">
          <source>X509CertSelector</source>
          <target state="translated">X509CertSelector</target>
        </trans-unit>
        <trans-unit id="849c98616043746f73f4de24a5afbac1d44d1497" translate="yes" xml:space="preserve">
          <source>X509CertSelector.addPathToName()</source>
          <target state="translated">X509CertSelector.addPathToName()</target>
        </trans-unit>
        <trans-unit id="6278349d36bb944f429eb415b0b2f5653f53be35" translate="yes" xml:space="preserve">
          <source>X509CertSelector.addSubjectAlternativeName()</source>
          <target state="translated">X509CertSelector.addSubjectAlternativeName()</target>
        </trans-unit>
        <trans-unit id="ed2ee8251ff17d4037102b86a0eb818ed7b9158b" translate="yes" xml:space="preserve">
          <source>X509CertSelector.clone()</source>
          <target state="translated">X509CertSelector.clone()</target>
        </trans-unit>
        <trans-unit id="4f7c0218aa9ee861a280f2a8a3d681319af44dc2" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getAuthorityKeyIdentifier()</source>
          <target state="translated">X509CertSelector.getAuthorityKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="40d694ea6a0a9eae7c98a82ec7b08ba8c6e7d8c0" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getBasicConstraints()</source>
          <target state="translated">X509CertSelector.getBasicConstraints()</target>
        </trans-unit>
        <trans-unit id="489a03ee864e5186cbe7e408a9342a09b16aa78a" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getCertificate()</source>
          <target state="translated">X509CertSelector.getCertificate()</target>
        </trans-unit>
        <trans-unit id="bdaabe014d6ad8fd33d855ee9bb1f16ef2b29b42" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getCertificateValid()</source>
          <target state="translated">X509CertSelector.getCertificateValid()</target>
        </trans-unit>
        <trans-unit id="e0b06dfa030eecee34ff0d43f2bf88f7c677a1f8" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getExtendedKeyUsage()</source>
          <target state="translated">X509CertSelector.getExtendedKeyUsage()</target>
        </trans-unit>
        <trans-unit id="df6a6707a1f1e6b86730e8d99239277ba12cc213" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getIssuer()</source>
          <target state="translated">X509CertSelector.getIssuer()</target>
        </trans-unit>
        <trans-unit id="ae7e401dc377f554ece71569312befdac83a6d76" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getIssuerAsBytes()</source>
          <target state="translated">X509CertSelector.getIssuerAsBytes()</target>
        </trans-unit>
        <trans-unit id="fff1dd584edf03c78d3f48961f0068ee33aec9fd" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getIssuerAsString()</source>
          <target state="translated">X509CertSelector.getIssuerAsString()</target>
        </trans-unit>
        <trans-unit id="fb95fd548f3274ae1629644c5d7f19e3399b95b9" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getKeyUsage()</source>
          <target state="translated">X509CertSelector.getKeyUsage()</target>
        </trans-unit>
        <trans-unit id="201ecc89e49a111d0b388bd6788c96cf2da4cfe1" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getMatchAllSubjectAltNames()</source>
          <target state="translated">X509CertSelector.getMatchAllSubjectAltNames()</target>
        </trans-unit>
        <trans-unit id="d832903d93a4fa039be163837346386802abfb52" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getNameConstraints()</source>
          <target state="translated">X509CertSelector.getNameConstraints()</target>
        </trans-unit>
        <trans-unit id="c963901b33f3f86f39cdd1dd2864b23d5088719e" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getPathToNames()</source>
          <target state="translated">X509CertSelector.getPathToNames()</target>
        </trans-unit>
        <trans-unit id="781ef4d399e43252f203c8dc4b5efd48a663b7ac" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getPolicy()</source>
          <target state="translated">X509CertSelector.getPolicy()</target>
        </trans-unit>
        <trans-unit id="28ebd04b297719d66e00f58a120d42c627462c32" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getPrivateKeyValid()</source>
          <target state="translated">X509CertSelector.getPrivateKeyValid()</target>
        </trans-unit>
        <trans-unit id="299d03b8810ccbde189382f778e1e69a9edf5518" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSerialNumber()</source>
          <target state="translated">X509CertSelector.getSerialNumber()</target>
        </trans-unit>
        <trans-unit id="30fadb44582a38c2c581267a782a13ef48ce3f8c" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubject()</source>
          <target state="translated">X509CertSelector.getSubject()</target>
        </trans-unit>
        <trans-unit id="8fe339cc206ef73ed54a20b13ef60192e178f844" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectAlternativeNames()</source>
          <target state="translated">X509CertSelector.getSubjectAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="ca470a951b9db1a85e008465b33f7f0025fd4ed7" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectAsBytes()</source>
          <target state="translated">X509CertSelector.getSubjectAsBytes()</target>
        </trans-unit>
        <trans-unit id="aed8aae80b16c67e2bd98bedd10564828eed6a02" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectAsString()</source>
          <target state="translated">X509CertSelector.getSubjectAsString()</target>
        </trans-unit>
        <trans-unit id="024358cc8426c59dad8537730df35ef69e5374a4" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectKeyIdentifier()</source>
          <target state="translated">X509CertSelector.getSubjectKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="f5738e2b6e6f38f47f261f937e072b25f4ec2eb5" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectPublicKey()</source>
          <target state="translated">X509CertSelector.getSubjectPublicKey()</target>
        </trans-unit>
        <trans-unit id="650c289d16e4fd83b1e95660cbfed07706bb9286" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectPublicKeyAlgID()</source>
          <target state="translated">X509CertSelector.getSubjectPublicKeyAlgID()</target>
        </trans-unit>
        <trans-unit id="227c01cacf995c323f3ba2ddda72a8c1d03e6e30" translate="yes" xml:space="preserve">
          <source>X509CertSelector.match()</source>
          <target state="translated">X509CertSelector.match()</target>
        </trans-unit>
        <trans-unit id="68c0f28130a6bf8d3c2abd14522f6c6c9688eb02" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setAuthorityKeyIdentifier()</source>
          <target state="translated">X509CertSelector.setAuthorityKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="0743dae5d1f40b69fc2ed7f9f8063b882e1c6506" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setBasicConstraints()</source>
          <target state="translated">X509CertSelector.setBasicConstraints()</target>
        </trans-unit>
        <trans-unit id="3f91236f46d4c1ca997bb1dd60eaa6480e178eac" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setCertificate()</source>
          <target state="translated">X509CertSelector.setCertificate()</target>
        </trans-unit>
        <trans-unit id="f753e79d07d1c7ff8e7766426c9008f7d741f947" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setCertificateValid()</source>
          <target state="translated">X509CertSelector.setCertificateValid()</target>
        </trans-unit>
        <trans-unit id="357a71aae1cd2f35c6a80fb733aa1088092c6474" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setExtendedKeyUsage()</source>
          <target state="translated">X509CertSelector.setExtendedKeyUsage()</target>
        </trans-unit>
        <trans-unit id="9ea83d746002bc0aa736e6f65afa241bdcc775dc" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setIssuer()</source>
          <target state="translated">X509CertSelector.setIssuer()</target>
        </trans-unit>
        <trans-unit id="c56e1298bc77fda9dd1a56fdf04575b296fc14b7" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setKeyUsage()</source>
          <target state="translated">X509CertSelector.setKeyUsage()</target>
        </trans-unit>
        <trans-unit id="b486a38a689304e6df785424134afd125d8d5032" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setMatchAllSubjectAltNames()</source>
          <target state="translated">X509CertSelector.setMatchAllSubjectAltNames()</target>
        </trans-unit>
        <trans-unit id="b48400dc4f916de3cc95f9337e25d568a2a1c742" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setNameConstraints()</source>
          <target state="translated">X509CertSelector.setNameConstraints()</target>
        </trans-unit>
        <trans-unit id="fe470ccac7aaaa2979faf49d5584f5491d1c6565" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setPathToNames()</source>
          <target state="translated">X509CertSelector.setPathToNames()</target>
        </trans-unit>
        <trans-unit id="dfaf5c753f0e41d22b63a535d3937b53aae07e5f" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setPolicy()</source>
          <target state="translated">X509CertSelector.setPolicy()</target>
        </trans-unit>
        <trans-unit id="6d0c7877f10fc09b324ca3d3047400411f1c6ea4" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setPrivateKeyValid()</source>
          <target state="translated">X509CertSelector.setPrivateKeyValid()</target>
        </trans-unit>
        <trans-unit id="86af9d1edb45e22a2903875dd9b2971784e2c8d1" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSerialNumber()</source>
          <target state="translated">X509CertSelector.setSerialNumber()</target>
        </trans-unit>
        <trans-unit id="ec33f3cc9bc744f7b4f027680c1da2ad2b108a48" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubject()</source>
          <target state="translated">X509CertSelector.setSubject()</target>
        </trans-unit>
        <trans-unit id="7424eda4b963ea374a5ffa98029c541ca2d056a1" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectAlternativeNames()</source>
          <target state="translated">X509CertSelector.setSubjectAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="ac907bb460f67c33f513b32cdf50d78c639a3427" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectKeyIdentifier()</source>
          <target state="translated">X509CertSelector.setSubjectKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="e6a4ccb21547f2a34b70f98ec9ba1b1eaeb60dd0" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectPublicKey()</source>
          <target state="translated">X509CertSelector.setSubjectPublicKey()</target>
        </trans-unit>
        <trans-unit id="1e9218b693cd7e79257d7ae26d7276128e5c3b2b" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectPublicKeyAlgID()</source>
          <target state="translated">X509CertSelector.setSubjectPublicKeyAlgID()</target>
        </trans-unit>
        <trans-unit id="c5a923a527dc9c62dba9aebf1122462312f07cc2" translate="yes" xml:space="preserve">
          <source>X509CertSelector.toString()</source>
          <target state="translated">X509CertSelector.toString()</target>
        </trans-unit>
        <trans-unit id="f6f0e8b60112f1c3be8ebabdeb6d7e48d60d9d02" translate="yes" xml:space="preserve">
          <source>X509Certificate</source>
          <target state="translated">X509Certificate</target>
        </trans-unit>
        <trans-unit id="7d60e0e197d0c0d506aa9dca6d156b869f512905" translate="yes" xml:space="preserve">
          <source>X509Certificate.checkValidity()</source>
          <target state="translated">X509Certificate.checkValidity()</target>
        </trans-unit>
        <trans-unit id="5f9840aac5626ba3ca82b57ed531cd3d3f4c15d3" translate="yes" xml:space="preserve">
          <source>X509Certificate.getBasicConstraints()</source>
          <target state="translated">X509Certificate.getBasicConstraints()</target>
        </trans-unit>
        <trans-unit id="8647c6b8afd81e28f330459dec8c7e3ccd121504" translate="yes" xml:space="preserve">
          <source>X509Certificate.getExtendedKeyUsage()</source>
          <target state="translated">X509Certificate.getExtendedKeyUsage()</target>
        </trans-unit>
        <trans-unit id="008ce5566e57c20d1a7ef32f815136c72bee066c" translate="yes" xml:space="preserve">
          <source>X509Certificate.getInstance()</source>
          <target state="translated">X509Certificate.getInstance()</target>
        </trans-unit>
        <trans-unit id="ac9c7d03b54b6ef087068f76feb5ca6ca90487ea" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerAlternativeNames()</source>
          <target state="translated">X509Certificate.getIssuerAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="7ceb0ae93b0e59134baf7b2cea3a9b450c9ddc10" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerDN()</source>
          <target state="translated">X509Certificate.getIssuerDN()</target>
        </trans-unit>
        <trans-unit id="2a45c4d375bea0212b9380afe65c7359177ff695" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerUniqueID()</source>
          <target state="translated">X509Certificate.getIssuerUniqueID()</target>
        </trans-unit>
        <trans-unit id="81b58aa8abdd44a650146b3a19b6a2755b7ceddf" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerX500Principal()</source>
          <target state="translated">X509Certificate.getIssuerX500Principal()</target>
        </trans-unit>
        <trans-unit id="e6633e0189c761013fb963894756a20bd053a6c4" translate="yes" xml:space="preserve">
          <source>X509Certificate.getKeyUsage()</source>
          <target state="translated">X509Certificate.getKeyUsage()</target>
        </trans-unit>
        <trans-unit id="12e70fdfd017b4e91263c6b022d715a90fce8f33" translate="yes" xml:space="preserve">
          <source>X509Certificate.getNotAfter()</source>
          <target state="translated">X509Certificate.getNotAfter()</target>
        </trans-unit>
        <trans-unit id="9a92edc1a9f8a4fd9110f3acb8fda4b1b3c6ab4e" translate="yes" xml:space="preserve">
          <source>X509Certificate.getNotBefore()</source>
          <target state="translated">X509Certificate.getNotBefore()</target>
        </trans-unit>
        <trans-unit id="27da78eb87b805e2444b1f82afb90e9bc7835b4c" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSerialNumber()</source>
          <target state="translated">X509Certificate.getSerialNumber()</target>
        </trans-unit>
        <trans-unit id="6f8af08573e408c5a6b7bc75cb80ecc6b451cb9e" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSigAlgName()</source>
          <target state="translated">X509Certificate.getSigAlgName()</target>
        </trans-unit>
        <trans-unit id="607a3a0749c8b1dab746e512d28d69eda4f25849" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSigAlgOID()</source>
          <target state="translated">X509Certificate.getSigAlgOID()</target>
        </trans-unit>
        <trans-unit id="02b5c5e5de572fff22a8a962331d8bfb41d52abc" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSigAlgParams()</source>
          <target state="translated">X509Certificate.getSigAlgParams()</target>
        </trans-unit>
        <trans-unit id="abf0378af3325f51ffce60cc5e76863d6e64cb7c" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSignature()</source>
          <target state="translated">X509Certificate.getSignature()</target>
        </trans-unit>
        <trans-unit id="63ea54ab328cdf2e3ffeca94bf86dcb1fc3ba3b2" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectAlternativeNames()</source>
          <target state="translated">X509Certificate.getSubjectAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="db892dc548dadaea8e72280046ee97a7d31aff5e" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectDN()</source>
          <target state="translated">X509Certificate.getSubjectDN()</target>
        </trans-unit>
        <trans-unit id="2efa2a18e43e940888c9b04b569ccc74f02ab50b" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectUniqueID()</source>
          <target state="translated">X509Certificate.getSubjectUniqueID()</target>
        </trans-unit>
        <trans-unit id="28cd8f5a485793a0f7cad8c499296d29e2ac48d4" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectX500Principal()</source>
          <target state="translated">X509Certificate.getSubjectX500Principal()</target>
        </trans-unit>
        <trans-unit id="33d127567465109550abfdba854639b9080179ac" translate="yes" xml:space="preserve">
          <source>X509Certificate.getTBSCertificate()</source>
          <target state="translated">X509Certificate.getTBSCertificate()</target>
        </trans-unit>
        <trans-unit id="cfdd8cbb40490d2380f820a508eb536dc1f316f5" translate="yes" xml:space="preserve">
          <source>X509Certificate.getVersion()</source>
          <target state="translated">X509Certificate.getVersion()</target>
        </trans-unit>
        <trans-unit id="06976b95a9323811dcf9535aa216a7ec252ae43d" translate="yes" xml:space="preserve">
          <source>X509Certificate.verify()</source>
          <target state="translated">X509Certificate.verify()</target>
        </trans-unit>
        <trans-unit id="cc2e615ba7cbd040c10d3be3571d5078c66f8b54" translate="yes" xml:space="preserve">
          <source>X509Data</source>
          <target state="translated">X509Data</target>
        </trans-unit>
        <trans-unit id="ae8f17ee616d8138bab4d4f0e4737dd1f9da13cc" translate="yes" xml:space="preserve">
          <source>X509EncodedKeySpec</source>
          <target state="translated">X509EncodedKeySpec</target>
        </trans-unit>
        <trans-unit id="626dd44a2314d53b33d369a1f08f07026b41ff51" translate="yes" xml:space="preserve">
          <source>X509EncodedKeySpec.getEncoded()</source>
          <target state="translated">X509EncodedKeySpec.getEncoded()</target>
        </trans-unit>
        <trans-unit id="5839e3e80e77157ebc8b17529536f8d4a0941fd3" translate="yes" xml:space="preserve">
          <source>X509EncodedKeySpec.getFormat()</source>
          <target state="translated">X509EncodedKeySpec.getFormat()</target>
        </trans-unit>
        <trans-unit id="d234842c0789a795b12742b8d823eef9ed978f36" translate="yes" xml:space="preserve">
          <source>X509ExtendedKeyManager</source>
          <target state="translated">X509ExtendedKeyManager</target>
        </trans-unit>
        <trans-unit id="b493b829ae35b2377354cbba6507ba8b89557e66" translate="yes" xml:space="preserve">
          <source>X509ExtendedKeyManager.chooseEngineClientAlias()</source>
          <target state="translated">X509ExtendedKeyManager.chooseEngineClientAlias()</target>
        </trans-unit>
        <trans-unit id="268c5e4bfe9daff1d0c54174fb32327af88ecc99" translate="yes" xml:space="preserve">
          <source>X509ExtendedKeyManager.chooseEngineServerAlias()</source>
          <target state="translated">X509ExtendedKeyManager.chooseEngineServerAlias()</target>
        </trans-unit>
        <trans-unit id="4ab0984afa85cd2e8f19d0156d09d7aef547baaf" translate="yes" xml:space="preserve">
          <source>X509ExtendedTrustManager</source>
          <target state="translated">X509ExtendedTrustManager</target>
        </trans-unit>
        <trans-unit id="308fba37a669971bdf5c83e790461904ac757d89" translate="yes" xml:space="preserve">
          <source>X509ExtendedTrustManager.checkClientTrusted()</source>
          <target state="translated">X509ExtendedTrustManager.checkClientTrusted()</target>
        </trans-unit>
        <trans-unit id="2339dd435d457b4c465d46b8f4645892098fa99f" translate="yes" xml:space="preserve">
          <source>X509ExtendedTrustManager.checkServerTrusted()</source>
          <target state="translated">X509ExtendedTrustManager.checkServerTrusted()</target>
        </trans-unit>
        <trans-unit id="80b51310f31ac6afeea08769e4d4b9f50226c664" translate="yes" xml:space="preserve">
          <source>X509Extension</source>
          <target state="translated">X509Extension</target>
        </trans-unit>
        <trans-unit id="e5f5dadf1208209f33dc58be405a7eb9ebcb5d0d" translate="yes" xml:space="preserve">
          <source>X509Extension.getCriticalExtensionOIDs()</source>
          <target state="translated">X509Extension.getCriticalExtensionOIDs()</target>
        </trans-unit>
        <trans-unit id="71bb077b1f322fd963fa780ed45ada48fbd41624" translate="yes" xml:space="preserve">
          <source>X509Extension.getExtensionValue()</source>
          <target state="translated">X509Extension.getExtensionValue()</target>
        </trans-unit>
        <trans-unit id="3e4a2928f4c2275aeba3a445dda0561efd55c7f5" translate="yes" xml:space="preserve">
          <source>X509Extension.getNonCriticalExtensionOIDs()</source>
          <target state="translated">X509Extension.getNonCriticalExtensionOIDs()</target>
        </trans-unit>
        <trans-unit id="5d5e4a7a3f7e1ee7a5fb70fc335737e9208f5abe" translate="yes" xml:space="preserve">
          <source>X509Extension.hasUnsupportedCriticalExtension()</source>
          <target state="translated">X509Extension.hasUnsupportedCriticalExtension()</target>
        </trans-unit>
        <trans-unit id="6220cf77d0d34cae0d597adcdf425c3abce279b5" translate="yes" xml:space="preserve">
          <source>X509IssuerSerial</source>
          <target state="translated">X509IssuerSerial</target>
        </trans-unit>
        <trans-unit id="dd3d3c5c395ab8f86b05f638bc2e2f70a0b2cf27" translate="yes" xml:space="preserve">
          <source>X509KeyManager</source>
          <target state="translated">X509KeyManager</target>
        </trans-unit>
        <trans-unit id="beab63b45c7665300d68a9a410348592b8d02385" translate="yes" xml:space="preserve">
          <source>X509KeyManager.chooseClientAlias()</source>
          <target state="translated">X509KeyManager.chooseClientAlias()</target>
        </trans-unit>
        <trans-unit id="e2ed5257aee8f84943c3c5175c5720366da48e31" translate="yes" xml:space="preserve">
          <source>X509KeyManager.chooseServerAlias()</source>
          <target state="translated">X509KeyManager.chooseServerAlias()</target>
        </trans-unit>
        <trans-unit id="546a546e5697acf8b86342e95b6031173171bf16" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getCertificateChain()</source>
          <target state="translated">X509KeyManager.getCertificateChain()</target>
        </trans-unit>
        <trans-unit id="360d2a2870aa288733c777b743cf1e807d032144" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getClientAliases()</source>
          <target state="translated">X509KeyManager.getClientAliases()</target>
        </trans-unit>
        <trans-unit id="aac579d7db0dfe6ca743f44f435647577da385a7" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getPrivateKey()</source>
          <target state="translated">X509KeyManager.getPrivateKey()</target>
        </trans-unit>
        <trans-unit id="e3ca12c81385c04439e1e70f0e10117530ced15d" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getServerAliases()</source>
          <target state="translated">X509KeyManager.getServerAliases()</target>
        </trans-unit>
        <trans-unit id="3398eab6590ac27408e569fc599faf599df3542b" translate="yes" xml:space="preserve">
          <source>X509TrustManager</source>
          <target state="translated">X509TrustManager</target>
        </trans-unit>
        <trans-unit id="b49a3c450c79104083adf3bf74cf91b3b48f5e5d" translate="yes" xml:space="preserve">
          <source>X509TrustManager.checkClientTrusted()</source>
          <target state="translated">X509TrustManager.checkClientTrusted()</target>
        </trans-unit>
        <trans-unit id="629ebeabcce436e9b7c77948c6913d0dc0dcf13a" translate="yes" xml:space="preserve">
          <source>X509TrustManager.checkServerTrusted()</source>
          <target state="translated">X509TrustManager.checkServerTrusted()</target>
        </trans-unit>
        <trans-unit id="c6144704bd36cad2146f534a13d9f8f6ba6eaabf" translate="yes" xml:space="preserve">
          <source>X509TrustManager.getAcceptedIssuers()</source>
          <target state="translated">X509TrustManager.getAcceptedIssuers()</target>
        </trans-unit>
        <trans-unit id="76c2edae465246aa26b0ff1bee9fd3b755611967" translate="yes" xml:space="preserve">
          <source>XAConnection</source>
          <target state="translated">XAConnection</target>
        </trans-unit>
        <trans-unit id="6787db011941d44e2a8b3eab70c087e56129c431" translate="yes" xml:space="preserve">
          <source>XAConnectionBuilder</source>
          <target state="translated">XAConnectionBuilder</target>
        </trans-unit>
        <trans-unit id="f0523ae2f59dd9e2c59e420113c94bae314feb13" translate="yes" xml:space="preserve">
          <source>XADataSource</source>
          <target state="translated">XADataSource</target>
        </trans-unit>
        <trans-unit id="bb284274415eb83f5f2baa08b5fc1d9f2a6efa61" translate="yes" xml:space="preserve">
          <source>XAER_ASYNC</source>
          <target state="translated">XAER_ASYNC</target>
        </trans-unit>
        <trans-unit id="dadbb855e925668e84ee8a8ef3783fc2c8d1de90" translate="yes" xml:space="preserve">
          <source>XAER_DUPID</source>
          <target state="translated">XAER_DUPID</target>
        </trans-unit>
        <trans-unit id="5b22cf5171ebbc5232aa6b8051b43cd1ff53c18a" translate="yes" xml:space="preserve">
          <source>XAER_INVAL</source>
          <target state="translated">XAER_INVAL</target>
        </trans-unit>
        <trans-unit id="fbf0ba17d7abb15669590db0ad5a834ef16539cd" translate="yes" xml:space="preserve">
          <source>XAER_NOTA</source>
          <target state="translated">XAER_NOTA</target>
        </trans-unit>
        <trans-unit id="3241a99d17fea78a9a97d02a84b4f7a1f0dee77d" translate="yes" xml:space="preserve">
          <source>XAER_OUTSIDE</source>
          <target state="translated">XAER_OUTSIDE</target>
        </trans-unit>
        <trans-unit id="5cb21154c19010904ddcbce89b38ae6fcf3b497d" translate="yes" xml:space="preserve">
          <source>XAER_PROTO</source>
          <target state="translated">XAER_PROTO</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
