<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="78ac89e34bb33075084c8e8edd00338d1db15d21" translate="yes" xml:space="preserve">
          <source>The notification emitted is a &lt;a href=&quot;../../../javax/management/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; instance whose &lt;a href=&quot;../../../javax/management/notification#setUserData(java.lang.Object)&quot;&gt;&lt;code&gt;user data&lt;/code&gt;&lt;/a&gt; is set to a &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt; that represents a &lt;a href=&quot;memorynotificationinfo&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt; object containing information about the memory pool when the notification was constructed. The &lt;code&gt;CompositeData&lt;/code&gt; contains the attributes as described in &lt;a href=&quot;memorynotificationinfo#from(javax.management.openmbean.CompositeData)&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The notification emitted is a &lt;a href=&quot;../../../javax/management/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; instance whose &lt;a href=&quot;../../../javax/management/notification#setUserData(java.lang.Object)&quot;&gt; &lt;code&gt;user data&lt;/code&gt; &lt;/a&gt; is set to a &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; that represents a &lt;a href=&quot;memorynotificationinfo&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; object containing information about the memory pool when the notification was constructed. The &lt;code&gt;CompositeData&lt;/code&gt; contains the attributes as described in &lt;a href=&quot;memorynotificationinfo#from(javax.management.openmbean.CompositeData)&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b815b7a69fff83a89aecb794ceb17aa59e315dbf" translate="yes" xml:space="preserve">
          <source>The notification emitted is a &lt;a href=&quot;../../../javax/management/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; instance whose &lt;a href=&quot;../../../javax/management/notification#setUserData-java.lang.Object-&quot;&gt;&lt;code&gt;user data&lt;/code&gt;&lt;/a&gt; is set to a &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt; that represents a &lt;a href=&quot;memorynotificationinfo&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt; object containing information about the memory pool when the notification was constructed. The &lt;code&gt;CompositeData&lt;/code&gt; contains the attributes as described in &lt;a href=&quot;memorynotificationinfo#from-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성 된 알림은 &lt;a href=&quot;../../../javax/management/notification#setUserData-java.lang.Object-&quot;&gt; &lt;code&gt;user data&lt;/code&gt; &lt;/a&gt; 가 알림이 생성 될 때 메모리 풀에 대한 정보를 포함 하는 &lt;a href=&quot;memorynotificationinfo&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; 객체 를 나타내는 &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 로 설정된 &lt;a href=&quot;../../../javax/management/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; 인스턴스입니다 . &lt;code&gt;CompositeData&lt;/code&gt; 에은 에 설명 된대로 속성을 포함 &lt;a href=&quot;memorynotificationinfo#from-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d43792640468618be4943696b58814c5982d2f01" translate="yes" xml:space="preserve">
          <source>The notification sequence number within the source object. It's a serial number identifying a particular instance of notification in the context of the notification source. The notification model does not assume that notifications will be received in the same order that they are sent. The sequence number helps listeners to sort received notifications.</source>
          <target state="translated">소스 객체 내의 알림 시퀀스 번호입니다. 알림 소스와 관련하여 특정 알림 인스턴스를 식별하는 일련 번호입니다. 통지 모델은 통지가 송신 된 순서와 동일한 순서로 수신된다고 가정하지 않습니다. 시퀀스 번호는 리스너가 수신 된 알림을 정렬하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="047c41230a085945fb649a5ebbbac0f9cc2023e7" translate="yes" xml:space="preserve">
          <source>The notification source and a set of parameters concerning the monitor MBean's state need to be specified when creating a new object of this class. The list of notifications fired by the monitor MBeans is the following:</source>
          <target state="translated">이 클래스의 새 오브젝트를 작성할 때 모니터 MBean 상태에 관한 알림 소스 및 매개 변수 세트를 지정해야합니다. 모니터 MBean에 의해 발생 된 통지 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5e52f5aa1ac9e3d0cc53022642f1d2fa738c7f5" translate="yes" xml:space="preserve">
          <source>The notification timestamp.</source>
          <target state="translated">알림 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="1cc0bdffa957699c3503e9a21edd9c5510954093" translate="yes" xml:space="preserve">
          <source>The notification type is one of the following:</source>
          <target state="translated">알림 유형은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="54f36e19da8052d6b002a6408bea252c14dac4d8" translate="yes" xml:space="preserve">
          <source>The notification type. It's a string expressed in a dot notation similar to Java properties. It is recommended that the notification type should follow the reverse-domain-name convention used by Java package names. An example of a notification type is com.example.alarm.router.</source>
          <target state="translated">알림 유형 Java 특성과 유사한 점 표기법으로 표현 된 문자열입니다. 알림 유형은 Java 패키지 이름에서 사용하는 역 도메인 이름 규칙을 따라야합니다. 알림 유형의 예는 com.example.alarm.router입니다.</target>
        </trans-unit>
        <trans-unit id="1924a5b15b3249ce092a029bd89121d0f77e325f" translate="yes" xml:space="preserve">
          <source>The notification.</source>
          <target state="translated">알림.</target>
        </trans-unit>
        <trans-unit id="fab265b6684bbffb1f218488bc04b79bf0141ad3" translate="yes" xml:space="preserve">
          <source>The null byte &lt;code&gt;'\u0000'&lt;/code&gt; is encoded in 2-byte format rather than 1-byte, so that the encoded strings never have embedded nulls.</source>
          <target state="translated">널 바이트 &lt;code&gt;'\u0000'&lt;/code&gt; 은 1 바이트가 아닌 2 바이트 형식으로 인코딩되므로 인코딩 된 문자열에 널이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="556c462e53e5ab353ef562a0763b91624cdf0bb0" translate="yes" xml:space="preserve">
          <source>The null character &lt;code&gt;'\u0000'&lt;/code&gt; and characters in the range &lt;code&gt;'\u0080'&lt;/code&gt; to &lt;code&gt;'\u07FF'&lt;/code&gt; are represented by a pair of bytes.</source>
          <target state="translated">The null character &lt;code&gt;'\u0000'&lt;/code&gt; and characters in the range &lt;code&gt;'\u0080'&lt;/code&gt; to &lt;code&gt;'\u07FF'&lt;/code&gt; are represented by a pair of bytes.</target>
        </trans-unit>
        <trans-unit id="3b8e10011b092d252f9eb3176c082893795abb5d" translate="yes" xml:space="preserve">
          <source>The null character &lt;code&gt;'\u0000'&lt;/code&gt; and characters in the range &lt;code&gt;'\u0080'&lt;/code&gt; to &lt;code&gt;'\u07FF'&lt;/code&gt; are represented by a pair of bytes:</source>
          <target state="translated">널 문자 &lt;code&gt;'\u0000'&lt;/code&gt; 범위의 문자 &lt;code&gt;'\u0080'&lt;/code&gt; 에 &lt;code&gt;'\u07FF'&lt;/code&gt; 바이트 쌍으로 표현된다 :</target>
        </trans-unit>
        <trans-unit id="fdf012dbbee5e63f7359a0dcd636e783461bf0ec" translate="yes" xml:space="preserve">
          <source>The null type.</source>
          <target state="translated">널 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bfa4624adbb58928ef8efb29a2f80d2c80dac18c" translate="yes" xml:space="preserve">
          <source>The null value.</source>
          <target state="translated">널값</target>
        </trans-unit>
        <trans-unit id="72eeb7ae48294ef46081a7a538e4507ac50ff336" translate="yes" xml:space="preserve">
          <source>The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers in dates and times.</source>
          <target state="translated">The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers in dates and times.</target>
        </trans-unit>
        <trans-unit id="62bb929eddf4e5076a6c1af6a73ff7f12b318660" translate="yes" xml:space="preserve">
          <source>The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers in dates and times. Subclasses should initialize this to a number format appropriate for the locale associated with this &lt;code&gt;DateFormat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DateFormat&lt;/code&gt; 이 날짜 및 시간 의 숫자를 형식화하는 데 사용하는 숫자 형식 기입니다 . 서브 클래스는 이것을이 &lt;code&gt;DateFormat&lt;/code&gt; 에 관련한 로케일에 적절한 수치 형식으로 초기화 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e937f460d16c2dd03c469010edefe2fdea52818a" translate="yes" xml:space="preserve">
          <source>The number is equal to or greater than 70 and followed by a space, comma, slash, or end of string</source>
          <target state="translated">숫자는 70 이상이며 공백, 쉼표, 슬래시 또는 문자열 끝이 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="20c65393a3bac9d4d95cbcb35c3376b737c51fb4" translate="yes" xml:space="preserve">
          <source>The number is less than 70, and both a month and a day of the month have already been recognized</source>
          <target state="translated">숫자는 70보다 작으며 한 달과 한 달이 이미 인식되었습니다.</target>
        </trans-unit>
        <trans-unit id="1cc438c896ef962d5026bc123197b09edc413720" translate="yes" xml:space="preserve">
          <source>The number is regarded as a year number if one of the following conditions is true:</source>
          <target state="translated">다음 조건 중 하나에 해당하면 숫자는 연도 숫자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd17b0115dc526bf174fa810f72abf0661f26d1" translate="yes" xml:space="preserve">
          <source>The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below.</source>
          <target state="translated">The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below.</target>
        </trans-unit>
        <trans-unit id="75342f1094eb495c3aabd48425339086d2ad1cdf" translate="yes" xml:space="preserve">
          <source>The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below. This may have the value zero, i.e., &lt;code&gt;CharacterData&lt;/code&gt; nodes may be empty.</source>
          <target state="translated">The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below. This may have the value zero, i.e., &lt;code&gt;CharacterData&lt;/code&gt; nodes may be empty.</target>
        </trans-unit>
        <trans-unit id="abe9a464eadb8b45be72b38683ef575d9e77b2a1" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CSSRules&lt;/code&gt; in the list.</source>
          <target state="translated">목록 의 &lt;code&gt;CSSRules&lt;/code&gt; 수입니다 .</target>
        </trans-unit>
        <trans-unit id="78bea75b4c9ef6959cd5b4f540c0e1736d470c61" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CSSRules&lt;/code&gt; in the list. The range of valid child rule indices is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">목록 의 &lt;code&gt;CSSRules&lt;/code&gt; 수입니다 . 유효한 하위 규칙 색인의 범위는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;length-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="c548becf36faf403211c576595e031a659f44d7d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CSSValues&lt;/code&gt; in the list.</source>
          <target state="translated">목록에있는 &lt;code&gt;CSSValues&lt;/code&gt; 의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="f32bb8eee085247884b90546de84a4a8f1aac4f0" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CSSValues&lt;/code&gt; in the list. The range of valid values of the indices is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">목록에있는 &lt;code&gt;CSSValues&lt;/code&gt; 의 수입니다 . 인덱스의 유효한 값 범위는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;length-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="0c4b5ddabaf56d5c4c36a5570d9d6d29d030dd4e" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMImplementation&lt;/code&gt;s in the list.</source>
          <target state="translated">The number of &lt;code&gt;DOMImplementation&lt;/code&gt; s in the list.</target>
        </trans-unit>
        <trans-unit id="9489088a467b83bdca0bfdbd7c936cad49d78114" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMImplementation&lt;/code&gt;s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of &lt;code&gt;DOMImplementation&lt;/code&gt; s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="3151dddf297321dd67d138ddf19d1b8fa0097bde" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMString&lt;/code&gt;s in the list.</source>
          <target state="translated">The number of &lt;code&gt;DOMString&lt;/code&gt; s in the list.</target>
        </trans-unit>
        <trans-unit id="675390bfaee708d77610d340d5e3baa3976e86f8" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMString&lt;/code&gt;s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of &lt;code&gt;DOMString&lt;/code&gt; s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="476dd7b1e6f4eb5dfcec4e9dbe2a94ee1b0badd8" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;StyleSheets&lt;/code&gt; in the list.</source>
          <target state="translated">목록 의 스타일 &lt;code&gt;StyleSheets&lt;/code&gt; 수입니다 .</target>
        </trans-unit>
        <trans-unit id="7ac5b164af72e445fb4f8455f787b7eca198e969" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;StyleSheets&lt;/code&gt; in the list. The range of valid child stylesheet indices is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">목록 의 스타일 &lt;code&gt;StyleSheets&lt;/code&gt; 수입니다 . 유효한 하위 스타일 시트 색인의 범위는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;length-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="60a60822d38a3770fe364352a19792205d536947" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;TIFFField&lt;/code&gt;s in this &lt;code&gt;TIFFDirectory&lt;/code&gt;.</source>
          <target state="translated">The number of &lt;code&gt;TIFFField&lt;/code&gt; s in this &lt;code&gt;TIFFDirectory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df8cbf65b57833acddb4ff0a78d9a0353df9a3f4" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;char&lt;/code&gt; values added to the buffer, or -1 if this source of characters is at its end</source>
          <target state="translated">버퍼에 추가 된 &lt;code&gt;char&lt;/code&gt; 값 수 또는이 문자 소스가 끝에있는 경우 -1</target>
        </trans-unit>
        <trans-unit id="6a4fe6c9ed8723108cce0e192446f1016bb5190a" translate="yes" xml:space="preserve">
          <source>The number of DataBuffer data elements per pixel.</source>
          <target state="translated">The number of DataBuffer data elements per pixel.</target>
        </trans-unit>
        <trans-unit id="a13aedd88da9ff953a45546a659c446cf0d4bcbb" translate="yes" xml:space="preserve">
          <source>The number of array elements when deserializing an array of the class.</source>
          <target state="translated">The number of array elements when deserializing an array of the class.</target>
        </trans-unit>
        <trans-unit id="a9e565d04a934465ec5fead6c1f84b201f781fa2" translate="yes" xml:space="preserve">
          <source>The number of attributes in the list.</source>
          <target state="translated">The number of attributes in the list.</target>
        </trans-unit>
        <trans-unit id="f3a97128719266ddb790af1c18af9062d75593ec" translate="yes" xml:space="preserve">
          <source>The number of attributes in this attribute set.</source>
          <target state="translated">이 속성 세트의 속성 수입니다.</target>
        </trans-unit>
        <trans-unit id="6ec090dddd82f048df0c06bf0d557ff56e2af995" translate="yes" xml:space="preserve">
          <source>The number of audio channels in this format (1 for mono, 2 for stereo).</source>
          <target state="translated">이 형식의 오디오 채널 수입니다 (모노의 경우 1, 스테레오의 경우 2).</target>
        </trans-unit>
        <trans-unit id="da794183d91354fbd66821a8a0c13b012e54b407" translate="yes" xml:space="preserve">
          <source>The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition or if this number cannot be obtained. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;#getFreeSpace()&quot;&gt;&lt;code&gt;getFreeSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션에서 사용 가능한 바이트 수 또는 추상 경로 이름이 파티션의 이름을 지정하지 &lt;code&gt;0L&lt;/code&gt; 번호를 얻을 수없는 경우 0L 입니다. 이 정보를 사용할 수없는 시스템에서이 메서드는 &lt;a href=&quot;#getFreeSpace()&quot;&gt; &lt;code&gt;getFreeSpace()&lt;/code&gt; &lt;/a&gt; 에 대한 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="afbe542c12a90a28a0f4b4b26ed2890e7aa85abd" translate="yes" xml:space="preserve">
          <source>The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;#getFreeSpace()&quot;&gt;&lt;code&gt;getFreeSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;#getFreeSpace()&quot;&gt; &lt;code&gt;getFreeSpace()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ebe508295acf5978d83f70bb43c4b3bd8b4274fb" translate="yes" xml:space="preserve">
          <source>The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;file#getFreeSpace--&quot;&gt;&lt;code&gt;getFreeSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션에서 사용 가능한 바이트 수 또는 추상 경로 이름으로 파티션 이름을 지정하지 않은 경우 &lt;code&gt;0L&lt;/code&gt; 이 정보를 사용할 수없는 시스템에서이 메소드는 &lt;a href=&quot;file#getFreeSpace--&quot;&gt; &lt;code&gt;getFreeSpace()&lt;/code&gt; &lt;/a&gt; 호출에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="986d228b1cb124a7f2771a51d5eedb83ae9e201a" translate="yes" xml:space="preserve">
          <source>The number of bands in the Raster.</source>
          <target state="translated">The number of bands in the Raster.</target>
        </trans-unit>
        <trans-unit id="ebe7d42d7d56efc03967bcfad1c053de532602df" translate="yes" xml:space="preserve">
          <source>The number of bands in this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.</source>
          <target state="translated">The number of bands in this &lt;code&gt;ComponentSampleModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0a45d9f8790184259c173f5fdc53836106419a" translate="yes" xml:space="preserve">
          <source>The number of banks in this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.</source>
          <target state="translated">The number of banks in this &lt;code&gt;ComponentSampleModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d71dc51d09a652590c4253e71d8987c66a2cdde" translate="yes" xml:space="preserve">
          <source>The number of banks in this DataBuffer.</source>
          <target state="translated">The number of banks in this DataBuffer.</target>
        </trans-unit>
        <trans-unit id="1130b4382f1b7fe878fe4148c6bceffdb27b5491" translate="yes" xml:space="preserve">
          <source>The number of bits in each sample of a sound that has this format.</source>
          <target state="translated">이 형식을 가진 각 사운드 샘플의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2c6ef0f30695893dbdb9d64573a808a0335d172d" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;byte&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;byte&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="15e790ed5a0a48d5374c994c58d90003c84875ca" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;char&lt;/code&gt; value in unsigned binary form, constant &lt;code&gt;16&lt;/code&gt;.</source>
          <target state="translated">부호없는 이진 형식으로 상수 &lt;code&gt;16&lt;/code&gt; 을 &lt;code&gt;char&lt;/code&gt; 값 으로 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="262c8f5ae61f9348f39f6db260ec423eb0e0fc41" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="db7608f15c88ac6b6517884137b2698cc2061366" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;float&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e0bfa0a3ed9120efd3be680d6da69e3fb3b7ff5a" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;long&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;long&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="8b6311d22d425e5b3c17619c262b0fb241a15127" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;short&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;short&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="11b4eca6a42f5c3d86eeb7e9b58d5fd4c96c3c69" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;int&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b5aa872ec500b92f693ae617360824bca852a7c7" translate="yes" xml:space="preserve">
          <source>The number of buffers</source>
          <target state="translated">The number of buffers</target>
        </trans-unit>
        <trans-unit id="b595b8a977d69a8109f568a8e86df5418ffc6011" translate="yes" xml:space="preserve">
          <source>The number of bytes allocated to read data from this stream and return the result is bounded by &lt;code&gt;2*(long)len&lt;/code&gt;, inclusive.</source>
          <target state="translated">The number of bytes allocated to read data from this stream and return the result is bounded by &lt;code&gt;2*(long)len&lt;/code&gt; , inclusive.</target>
        </trans-unit>
        <trans-unit id="17d4e70f10cd5538ecaddea27e5925f3b39b1260" translate="yes" xml:space="preserve">
          <source>The number of bytes in each frame of a sound that has this format.</source>
          <target state="translated">이 형식을 가진 사운드의 각 프레임에있는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="10ce5b479dd18c652ab8267df15337a3c496022c" translate="yes" xml:space="preserve">
          <source>The number of bytes in the MIDI message, including the status byte and any data bytes.</source>
          <target state="translated">상태 바이트 및 데이터 바이트를 포함한 MIDI 메시지의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d13a4622dc0f210135891bcff08ace66977b3820" translate="yes" xml:space="preserve">
          <source>The number of bytes of primitive data available to be read in the current buffer.</source>
          <target state="translated">현재 버퍼에서 읽을 수있는 기본 데이터의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="6341e47288eb142c81634939fc65c544723e74d1" translate="yes" xml:space="preserve">
          <source>The number of bytes read, &lt;code&gt;-1&lt;/code&gt; if the channel is an &lt;a href=&quot;sctpchannel&quot;&gt;&lt;code&gt;SctpChannel&lt;/code&gt;&lt;/a&gt; that has reached end-of-stream, otherwise &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">읽은 바이트 수, 채널이 스트림 끝에 도달 한 &lt;a href=&quot;sctpchannel&quot;&gt; &lt;code&gt;SctpChannel&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-1&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfdd8b77cfc1f1b2a6f5515e18f818690cf800f0" translate="yes" xml:space="preserve">
          <source>The number of bytes read, or -1 if the end of the stream has already been reached</source>
          <target state="translated">읽은 바이트 수 또는 스트림 끝에 이미 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="cbcb5512c2972dbeb5124314fe8397ab9324ba4c" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero</source>
          <target state="translated">읽은 바이트 수, 아마도 0</target>
        </trans-unit>
        <trans-unit id="e54fa04ce29f88473805b5e56fe5895a6e99f815" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero, or &lt;code&gt;-1&lt;/code&gt; if the channel has reached end-of-stream</source>
          <target state="translated">읽은 바이트 수 (0 일 수 있음) 또는 채널이 스트림 끝에 도달 한 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2adccbd80eaab01d04b629a86d5b76357c7316e9" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero, or &lt;code&gt;-1&lt;/code&gt; if the given position is greater than or equal to the file's current size</source>
          <target state="translated">읽은 바이트 수 (0 또는 가능)- 주어진 위치가 파일의 현재 크기보다 크거나 같은 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="654ef5023c84ef66a6381000b6a3d72b3ddd64a4" translate="yes" xml:space="preserve">
          <source>The number of bytes sent, which will be either the number of bytes that were remaining in the messages buffer when this method was invoked or, if this channel is non-blocking, may be zero if there was insufficient room for the message in the underlying output buffer</source>
          <target state="translated">전송 된 바이트 수는이 메소드가 호출 될 때 메시지 버퍼에 남아 있던 바이트 수이거나이 채널이 비 차단 상태 인 경우 기본 메시지에 대한 공간이 충분하지 않은 경우 0 일 수 있습니다. 출력 버퍼</target>
        </trans-unit>
        <trans-unit id="57a7079e650bee5a8a354dd28ed5d308b1f47e06" translate="yes" xml:space="preserve">
          <source>The number of bytes sent, which will be either the number of bytes that were remaining in the source buffer when this method was invoked or, if this channel is non-blocking, may be zero if there was insufficient room for the datagram in the underlying output buffer</source>
          <target state="translated">전송 된 바이트 수.이 메소드가 호출 될 때 소스 버퍼에 남아있는 바이트 수이거나,이 채널이 비 블로킹 인 경우, 기본에 데이터 그램에 대한 공간이 충분하지 않으면 0이 될 수 있습니다. 출력 버퍼</target>
        </trans-unit>
        <trans-unit id="2255a94d1e2a76f353fed8a1d7b8e435de23cbd1" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be read without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be read without blocking, there is no guarantee that attempts to read additional data will block.)</source>
          <target state="translated">The number of bytes that can be read without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be read without blocking, there is no guarantee that attempts to read additional data will block.)</target>
        </trans-unit>
        <trans-unit id="9e97ccf1d843b3b3580662091dfd95f1358e8031" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be read without blocking can be ascertained using the &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be read without blocking, there is no guarantee that attempts to read additional data will block.)</source>
          <target state="translated">차단없이 읽을 수있는 바이트 수 는 &lt;code&gt;DataLine&lt;/code&gt; 인터페이스 의 &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드를 사용하여 확인할 수 있습니다 . (이 바이트 수를 차단하지 않고 읽을 수는 있지만 추가 데이터를 읽으려고하면 차단 될 것이라는 보장은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="fd338086f6f6b37beee7c38de457fa661d7d1f92" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.)</source>
          <target state="translated">The number of bytes that can be written without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.)</target>
        </trans-unit>
        <trans-unit id="f0013bec32edf3c0c9dad2765e90a066acc9e7ad" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written without blocking can be ascertained using the &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.)</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;DataLine&lt;/code&gt; 인터페이스 메소드를 사용하여 차단하지 않고 쓸 수있는 바이트 수를 확인할 수 있습니다 . (이 바이트 수를 차단하지 않고 기록 할 수 있지만 추가 데이터 쓰기 시도가 차단된다는 보장은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="80f6fef15a305bb856be09b4ef7409dc0dfb2fc8" translate="yes" xml:space="preserve">
          <source>The number of bytes to be read must represent an integral number of sample frames, such that:</source>
          <target state="translated">읽을 바이트 수는 다음과 같이 정수의 샘플 프레임 수를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="4523152343dab6798c93c7c3562ed8220c409f7a" translate="yes" xml:space="preserve">
          <source>The number of bytes to write must represent an integral number of sample frames, such that:</source>
          <target state="translated">쓸 바이트 수는 다음과 같이 정수의 샘플 프레임 수를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="a610a04d9530184116d0938a5b3f9e488bba7801" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;byte&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">바이트를 나타내는 데 사용 된 &lt;code&gt;byte&lt;/code&gt; 2의 보수 이진 형태 값 .</target>
        </trans-unit>
        <trans-unit id="1796e9529f51151f2a6f5b7fcdc6d4bd70c786af" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;char&lt;/code&gt; value in unsigned binary form.</source>
          <target state="translated">부호없는 이진 형식으로 &lt;code&gt;char&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="3d71b8f32cede9bbb676411377aebced3b7d4c67" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="229d3c03b3ae3c1ed8f12a7910a48a2be5adc533" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;float&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="aa4672a7d102168489149e5d5e7d36728647ebc6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;int&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="dcc8fa85fe3017a1bc6d96fbdb414b709a9b995c" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;long&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형식 으로 &lt;code&gt;long&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="d331db734169c052769944e176d28ab646bccf3a" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;short&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;short&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="fbddc6e94c7277988d661bc338017f0ceb95e132" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">The number of bytes used to represent an &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</target>
        </trans-unit>
        <trans-unit id="49cea9bc18d6128266132564ff26cd7bbad3f15a" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the data output stream so far.</source>
          <target state="translated">The number of bytes written to the data output stream so far.</target>
        </trans-unit>
        <trans-unit id="ccba44d3bc4162d753710c71c12cf8138d21d82d" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the data output stream so far. If this counter overflows, it will be wrapped to Integer.MAX_VALUE.</source>
          <target state="translated">지금까지 데이터 출력 스트림에 쓴 바이트 수입니다. 이 카운터가 오버플로되면 Integer.MAX_VALUE로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f42b4506dd9b1a24e0be2228b3cc5e5f34c15a" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the output byte array</source>
          <target state="translated">출력 바이트 배열에 쓴 바이트 수</target>
        </trans-unit>
        <trans-unit id="6624a626639ad8ac1c8cb97de741a539df918fa9" translate="yes" xml:space="preserve">
          <source>The number of bytes written, possibly zero</source>
          <target state="translated">쓴 바이트 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="2e83b9c69c8e5617a17c757bc7b8be745b27a54c" translate="yes" xml:space="preserve">
          <source>The number of bytes, possibly zero, that were actually transferred</source>
          <target state="translated">실제로 전송 된 바이트 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="af7ab7cd4f3072661b7c20abd685bf0c436d55bc" translate="yes" xml:space="preserve">
          <source>The number of capturing groups in this matcher's pattern</source>
          <target state="translated">이 매처의 패턴에있는 캡처 그룹 수</target>
        </trans-unit>
        <trans-unit id="2f329af4f477cd85e689456398c923d81cd9c8c1" translate="yes" xml:space="preserve">
          <source>The number of channels (1 for mono, 2 for stereo, etc.), or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;</source>
          <target state="translated">채널 수 (모노의 경우 1, 스테레오의 경우 2 등) 또는 &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="032b81eac6a8ead6bf3bea51101baeb3b3e0d8f0" translate="yes" xml:space="preserve">
          <source>The number of characters actually skipped</source>
          <target state="translated">실제로 건너 뛴 문자 수</target>
        </trans-unit>
        <trans-unit id="386f609288a9f0b220b6ac9838664b0f43846b2d" translate="yes" xml:space="preserve">
          <source>The number of characters added to the buffer, or -1 if this source of characters is at its end</source>
          <target state="translated">버퍼에 추가 된 문자 수 또는이 문자 소스가 끝에있는 경우 -1</target>
        </trans-unit>
        <trans-unit id="ecf5ab475eeef8fcb49643a9532fa7b4dc7af88a" translate="yes" xml:space="preserve">
          <source>The number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">읽은 문자 수 또는 스트림 끝에 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="205c7f1702ff1d1066de34202d523525add5dd9e" translate="yes" xml:space="preserve">
          <source>The number of chars in the buffer.</source>
          <target state="translated">버퍼의 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="6cce150dda936838801add841ddd847a738448a1" translate="yes" xml:space="preserve">
          <source>The number of color components in the profile's input color space.</source>
          <target state="translated">The number of color components in the profile's input color space.</target>
        </trans-unit>
        <trans-unit id="3a06c379ffd04e632888118323157e2ad1d24593" translate="yes" xml:space="preserve">
          <source>The number of columns of frames in the frameset.</source>
          <target state="translated">프레임 세트의 프레임 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="8ffe520e7d4024db8e4e5b1854078d07ec5d7d3a" translate="yes" xml:space="preserve">
          <source>The number of columns of frames in the frameset. See the cols attribute definition in HTML 4.0.</source>
          <target state="translated">프레임 세트의 프레임 열 수입니다. HTML 4.0의 cols 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b27fe1795e395f12dea2f5b4c6f95e4dd635c4f5" translate="yes" xml:space="preserve">
          <source>The number of components in this &lt;code&gt;ColorSpace&lt;/code&gt;.</source>
          <target state="translated">The number of components in this &lt;code&gt;ColorSpace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5459d16fb3b7c8ed8621399fa51604616eecd04" translate="yes" xml:space="preserve">
          <source>The number of data items present in the field.</source>
          <target state="translated">The number of data items present in the field.</target>
        </trans-unit>
        <trans-unit id="929430c1d8c5ac6d7a42cbccdfc2c26fcd50c43a" translate="yes" xml:space="preserve">
          <source>The number of days considered to define the first week of a month or year varies by culture. For example, the ISO-8601 requires 4 days (more than half a week) to be present before counting the first week.</source>
          <target state="translated">월 또는 연도의 첫 주를 정의하는 것으로 간주되는 일 수는 문화에 따라 다릅니다. 예를 들어, ISO-8601은 첫 주를 계산하기 전에 4 일 (1 주일 이상)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="82d024cc379193ffdf9a30ee6d903c40b1cdc418" translate="yes" xml:space="preserve">
          <source>The number of days is multiplied by 86400 to obtain the number of seconds to add. This is based on the standard definition of a day as 24 hours.</source>
          <target state="translated">추가 할 초 수를 얻기 위해 일 수에 86400을 곱합니다. 이는 하루 24 시간의 표준 정의를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="080fc6c7c7c958c7b7e37d0533887be92a47406d" translate="yes" xml:space="preserve">
          <source>The number of days is multiplied by 86400 to obtain the number of seconds to subtract. This is based on the standard definition of a day as 24 hours.</source>
          <target state="translated">빼는 초 수를 얻기 위해 일 수에 86400을 곱합니다. 이는 하루 24 시간의 표준 정의를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="4c5a8510ea5cd109d91d0cd1e886868f35891a33" translate="yes" xml:space="preserve">
          <source>The number of digit characters after the exponent character gives the minimum exponent digit count. There is no maximum. Negative exponents are formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix from the pattern. This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.</source>
          <target state="translated">지수 문자 뒤의 숫자는 최소 지수 숫자를 나타냅니다. 최대 값이 없습니다. 음수 지수는 패턴의 접두사와 접미사가 &lt;em&gt;아닌&lt;/em&gt; 지역화 된 빼기 부호를 사용하여 형식이 지정됩니다 . 이것은 &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt; 와 같은 패턴을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="4b53b240407fd962e2dd3b27a91febfe24bbf171" translate="yes" xml:space="preserve">
          <source>The number of digits in the result for the fractional part of</source>
          <target state="translated">소수 부분에 대한 결과의 자릿수</target>
        </trans-unit>
        <trans-unit id="05d292761fd82f9f0dd80c9070f0ac52df331589" translate="yes" xml:space="preserve">
          <source>The number of dimensions of the new array must not exceed 255.</source>
          <target state="translated">새 배열의 차원 수는 255를 초과하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d6cd0b74c19721cb1208c561a00d8161cb59f302" translate="yes" xml:space="preserve">
          <source>The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a45d0d315d987c393e3a2c515c64048ccf875d3" translate="yes" xml:space="preserve">
          <source>The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. Field numbers range from &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 이 인식하는 고유 필드 수입니다 . 필드 번호 범위는 &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0dfd1950909619c9868b487a9d57d847c0cc29b" translate="yes" xml:space="preserve">
          <source>The number of elements covered by the stream source is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt;, does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is 4 and there is no need to execute the pipeline and, as a side-effect, print out the elements.</source>
          <target state="translated">The number of elements covered by the stream source is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt; , does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is 4 and there is no need to execute the pipeline and, as a side-effect, print out the elements.</target>
        </trans-unit>
        <trans-unit id="789ce93185a0e2beb4cc5bbc9f0b5bac9d5ce9c3" translate="yes" xml:space="preserve">
          <source>The number of elements covered by the stream source, a &lt;code&gt;List&lt;/code&gt;, is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt;, does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is the size of the &lt;code&gt;List&lt;/code&gt; and there is no need to execute the pipeline and, as a side-effect, print out the list elements.</source>
          <target state="translated">The number of elements covered by the stream source, a &lt;code&gt;List&lt;/code&gt; , is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt; , does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is the size of the &lt;code&gt;List&lt;/code&gt; and there is no need to execute the pipeline and, as a side-effect, print out the list elements.</target>
        </trans-unit>
        <trans-unit id="9860eaa69c7abfda9de7a6d02811a1e3a1871e66" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;constants&lt;/code&gt; equals to number of \2 tags in &lt;code&gt;recipe&lt;/code&gt;</source>
          <target state="translated">The number of elements in &lt;code&gt;constants&lt;/code&gt; equals to number of \2 tags in &lt;code&gt;recipe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f7e127090b80ab82ce71cab846f1367b5d71e09" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;constants&lt;/code&gt; is equal to number of \2 tags in &lt;code&gt;recipe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;constants&lt;/code&gt; 의 요소 수는 &lt;code&gt;recipe&lt;/code&gt; 의 \ 2 태그 수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="acd4fd691fac05bdf2d5e37af4276341169d50a8" translate="yes" xml:space="preserve">
          <source>The number of elements remaining in this buffer</source>
          <target state="translated">이 버퍼에 남아있는 요소의 수</target>
        </trans-unit>
        <trans-unit id="b2e83b34b6fc477f1ef053898329bc6fcb7133b3" translate="yes" xml:space="preserve">
          <source>The number of entries in the search result, or zero if unknown.</source>
          <target state="translated">검색 결과의 항목 수이거나 알 수없는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="7279b8ec5b65eee9ab8817c690539d89f1ed6013" translate="yes" xml:space="preserve">
          <source>The number of events generated for an event request can be controlled through filters. Filters provide additional constraints that an event must satisfy before it is placed on the event queue. Multiple filters can be used by making multiple calls to filter addition methods such as &lt;a href=&quot;exceptionrequest#addClassFilter(java.lang.String)&quot;&gt;&lt;code&gt;ExceptionRequest.addClassFilter(java.lang.String classPattern)&lt;/code&gt;&lt;/a&gt;. Filters are added to an event one at a time only while the event is disabled. Multiple filters are applied with CUT-OFF AND, in the order it was added to the request. Only events that satisfy all filters are placed in the event queue.</source>
          <target state="translated">이벤트 요청에 대해 생성되는 이벤트 수는 필터를 통해 제어 할 수 있습니다. 필터는 이벤트가 이벤트 큐에 배치되기 전에 충족해야하는 추가 제한 조건을 제공합니다. &lt;a href=&quot;exceptionrequest#addClassFilter(java.lang.String)&quot;&gt; &lt;code&gt;ExceptionRequest.addClassFilter(java.lang.String classPattern)&lt;/code&gt; &lt;/a&gt; 과 같은 필터 추가 메소드를 여러 번 호출하여 여러 필터를 사용할 수 있습니다 . 필터는 이벤트가 비활성화 된 동안에 만 한 번에 하나씩 이벤트에 추가됩니다. CUT-OFF AND를 사용하여 요청에 추가 된 순서대로 여러 필터가 적용됩니다. 모든 필터를 충족하는 이벤트 만 이벤트 큐에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="fe1506fbc3937c30ae3fb6b2818335f09a36a8fc" translate="yes" xml:space="preserve">
          <source>The number of form controls in the form.</source>
          <target state="translated">양식의 양식 컨트롤 수입니다.</target>
        </trans-unit>
        <trans-unit id="a84c6c62b5a42df25220cabbfa4124476735b0f2" translate="yes" xml:space="preserve">
          <source>The number of formal parameters for the executable this object represents</source>
          <target state="translated">이 객체가 나타내는 실행 파일의 형식 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="dfefc77d44f13f44ad950d4ebe9a5e1dcbcc6e1d" translate="yes" xml:space="preserve">
          <source>The number of frames played or recorded per second, for sounds that have this format.</source>
          <target state="translated">이 형식의 사운드에 대해 초당 재생 또는 녹음 된 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="4edbcfc8aa45cc498cde3e783850921f5632be3c" translate="yes" xml:space="preserve">
          <source>The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.</source>
          <target state="translated">빼는 초 수를 얻기 위해 시간 수에 3600을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="307478f090dcd23f5ff03bb51efd07fb84315e34" translate="yes" xml:space="preserve">
          <source>The number of hours is multiplied by 60 to obtain the number of seconds to subtract.</source>
          <target state="translated">빼는 초 수를 얻기 위해 시간 수에 60을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="78247313d86cd76765e1c133a2b09bbb32f29107" translate="yes" xml:space="preserve">
          <source>The number of instances of a serializable &lt;code&gt;BeanContextServceProvider&lt;/code&gt;.</source>
          <target state="translated">직렬화 가능한 &lt;code&gt;BeanContextServceProvider&lt;/code&gt; 의 인스턴스 수입니다 .</target>
        </trans-unit>
        <trans-unit id="317369d1e0be16bc5ba4718d3219b54f3b09d26c" translate="yes" xml:space="preserve">
          <source>The number of items in the result</source>
          <target state="translated">The number of items in the result</target>
        </trans-unit>
        <trans-unit id="097f0a8d71914cb9c6dea77c3a145d38daa1e596" translate="yes" xml:space="preserve">
          <source>The number of iterations is determined by the &lt;code&gt;iterations&lt;/code&gt; handle evaluation result. The loop counter &lt;code&gt;i&lt;/code&gt; is an extra loop iteration variable of type &lt;code&gt;int&lt;/code&gt;. It will be initialized to 0 and incremented by 1 in each iteration.</source>
          <target state="translated">The number of iterations is determined by the &lt;code&gt;iterations&lt;/code&gt; handle evaluation result. The loop counter &lt;code&gt;i&lt;/code&gt; is an extra loop iteration variable of type &lt;code&gt;int&lt;/code&gt; . It will be initialized to 0 and incremented by 1 in each iteration.</target>
        </trans-unit>
        <trans-unit id="3e1adaf0033f7bba7e092443336bc7fbe43cefde" translate="yes" xml:space="preserve">
          <source>The number of keys, possibly zero, whose ready-operation sets were updated</source>
          <target state="translated">준비 작업 세트가 업데이트 된 키 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="4418abf384fb3ff1dd1752bbc4761bc8afef107c" translate="yes" xml:space="preserve">
          <source>The number of keys, possibly zero, whose ready-operation sets were updated by the selection operation</source>
          <target state="translated">준비 작업 세트가 선택 작업으로 업데이트 된 키 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="c20843ef3b72fbf752c53fffbd60b239fd23c93b" translate="yes" xml:space="preserve">
          <source>The number of media in the list.</source>
          <target state="translated">목록의 미디어 수입니다.</target>
        </trans-unit>
        <trans-unit id="d182bf34796729394244e789fd603bbd0ac1ef98" translate="yes" xml:space="preserve">
          <source>The number of media in the list. The range of valid media is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">목록의 미디어 수입니다. 유효한 매체의 범위는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;length-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="58599d8f7a9756bbcaa8cb541eec393ad429d292" translate="yes" xml:space="preserve">
          <source>The number of nodes in the list.</source>
          <target state="translated">The number of nodes in the list.</target>
        </trans-unit>
        <trans-unit id="10c3a3ca6ddaa4e8f11f7782659de88cb00a5425" translate="yes" xml:space="preserve">
          <source>The number of nodes in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">목록의 노드 수 유효한 자식 노드 인덱스의 범위는 0에서 &lt;code&gt;length-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="89a5e0b13372e6fc062adb249daacd8031860d98" translate="yes" xml:space="preserve">
          <source>The number of nodes in the result snapshot.</source>
          <target state="translated">결과 스냅 샷의 노드 수입니다.</target>
        </trans-unit>
        <trans-unit id="571156ab8ed4d3c2f5cbffafc1a6e233235445db" translate="yes" xml:space="preserve">
          <source>The number of nodes in the result snapshot. Valid values for snapshotItem indices are &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;snapshotLength-1&lt;/code&gt; inclusive.</source>
          <target state="translated">결과 스냅 샷의 노드 수입니다. snapshotItem 인덱스의 유효한 값은 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;snapshotLength-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="c7ccd76fa8856f04dcd4795c012af0ade0677dc3" translate="yes" xml:space="preserve">
          <source>The number of nodes in this map.</source>
          <target state="translated">The number of nodes in this map.</target>
        </trans-unit>
        <trans-unit id="99714a0533e48c069f5d0251fb069318d7bc8ed0" translate="yes" xml:space="preserve">
          <source>The number of nodes in this map. The range of valid child node indices is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of nodes in this map. The range of valid child node indices is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="b11bc3b865afb868876d196a399af8b369dc2995" translate="yes" xml:space="preserve">
          <source>The number of options in this &lt;code&gt;SELECT&lt;/code&gt; .</source>
          <target state="translated">이 &lt;code&gt;SELECT&lt;/code&gt; 의 옵션 수입니다 .</target>
        </trans-unit>
        <trans-unit id="2ae7dea8f5d3421534529bc5cc4c84ee7b852657" translate="yes" xml:space="preserve">
          <source>The number of pairs (name and namespaceURI) in the list.</source>
          <target state="translated">The number of pairs (name and namespaceURI) in the list.</target>
        </trans-unit>
        <trans-unit id="c3847744dd637bbb831cfd22ebd7a7b7aa4dd88e" translate="yes" xml:space="preserve">
          <source>The number of pairs (name and namespaceURI) in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of pairs (name and namespaceURI) in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="555261104557ed52a03a89935ea1fbf0b6fdc34b" translate="yes" xml:space="preserve">
          <source>The number of parameter slots in &lt;code&gt;concatType&lt;/code&gt; is less than or equal to 200</source>
          <target state="translated">The number of parameter slots in &lt;code&gt;concatType&lt;/code&gt; is less than or equal to 200</target>
        </trans-unit>
        <trans-unit id="d0b15529b633a23cd3e86f0403d34390bbda7486" translate="yes" xml:space="preserve">
          <source>The number of parameters (parameter_count) is wrong for the method</source>
          <target state="translated">메소드의 매개 변수 수 (parameter_count)가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="305a1cc134b6c645204fd4641631706c7a3bf073" translate="yes" xml:space="preserve">
          <source>The number of pixels and scanlines to be used are calculated as follows.</source>
          <target state="translated">사용되는 픽셀 수와 스캔 라인은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="6343b0fcd544950cdbcf24b5aaa789b892836bb5" translate="yes" xml:space="preserve">
          <source>The number of properties that have been explicitly set in this declaration block.</source>
          <target state="translated">이 선언 블록에 명시 적으로 설정된 속성 수입니다.</target>
        </trans-unit>
        <trans-unit id="4561440cc6cdd63b07a44062ec81252e18c80b7f" translate="yes" xml:space="preserve">
          <source>The number of properties that have been explicitly set in this declaration block. The range of valid indices is 0 to length-1 inclusive.</source>
          <target state="translated">이 선언 블록에 명시 적으로 설정된 속성 수입니다. 유효한 인덱스의 범위는 0에서 길이 1까지입니다.</target>
        </trans-unit>
        <trans-unit id="d9e36ed639ce030e50c74a42001c8392fa0df35e" translate="yes" xml:space="preserve">
          <source>The number of rows of frames in the frameset.</source>
          <target state="translated">프레임 세트의 프레임 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="5a3bca561abb5210de2c168887b1285b153fe5c7" translate="yes" xml:space="preserve">
          <source>The number of rows of frames in the frameset. See the rows attribute definition in HTML 4.0.</source>
          <target state="translated">프레임 세트의 프레임 행 수입니다. HTML 4.0의 행 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0b09023fb617952757d1c12c7474a0c419e6159" translate="yes" xml:space="preserve">
          <source>The number of samples played or recorded per second, for sounds that have this format.</source>
          <target state="translated">이 형식의 사운드에 대해 초당 재생 또는 녹음 된 샘플 수입니다.</target>
        </trans-unit>
        <trans-unit id="9bbc1ff0553b0381a0869f137c83f31dcb608500" translate="yes" xml:space="preserve">
          <source>The number of scanlines to be used can be computed similarly.</source>
          <target state="translated">사용될 스캔 라인의 수는 유사하게 계산 될 수있다.</target>
        </trans-unit>
        <trans-unit id="afe45a69b86f3105c28dbba507ef13df1b6571f1" translate="yes" xml:space="preserve">
          <source>The number of seconds is calculated using the era, year-of-era, month, day-of-month, hour, minute, second, and zoneOffset.</source>
          <target state="translated">The number of seconds is calculated using the era, year-of-era, month, day-of-month, hour, minute, second, and zoneOffset.</target>
        </trans-unit>
        <trans-unit id="2e29a6191dda7aba6c2290709789914d31fdc135" translate="yes" xml:space="preserve">
          <source>The number of seconds is calculated using the proleptic-year, month, day-of-month, hour, minute, second, and zoneOffset.</source>
          <target state="translated">The number of seconds is calculated using the proleptic-year, month, day-of-month, hour, minute, second, and zoneOffset.</target>
        </trans-unit>
        <trans-unit id="27d50337df7b10c0b2a7bea6efd93de22a290207" translate="yes" xml:space="preserve">
          <source>The number of seconds is calculated using the year, month, day-of-month, hour, minute, second, and zoneOffset.</source>
          <target state="translated">The number of seconds is calculated using the year, month, day-of-month, hour, minute, second, and zoneOffset.</target>
        </trans-unit>
        <trans-unit id="7ba563126126250d6b36a8f34204fd2b8961d6b5" translate="yes" xml:space="preserve">
          <source>The number of sequence elements isn't necessarily bounded.</source>
          <target state="translated">The number of sequence elements isn't necessarily bounded.</target>
        </trans-unit>
        <trans-unit id="be3893e01cc76c096f13435ff5df0b674f3d85d4" translate="yes" xml:space="preserve">
          <source>The number of sessions that can be stored in context can be limited.</source>
          <target state="translated">컨텍스트에 저장할 수있는 세션 수는 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc312459807625f373e756dee442f9bfa948a13e" translate="yes" xml:space="preserve">
          <source>The number of significant digits in the mantissa is the sum of the &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is unaffected by the maximum integer digits. For example, 12345 formatted with &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set the significant digits count to zero. The number of significant digits does not affect parsing.</source>
          <target state="translated">가수의 유효 자릿수는 &lt;em&gt;최소 정수&lt;/em&gt; 와 &lt;em&gt;최대 소수&lt;/em&gt; 자릿수 의 합이며 최대 정수 자릿수의 영향을받지 않습니다. 예를 들어 &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; 으로 형식이 지정된 12345 는 &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt; 입니다. 입니다. 모든 자릿수를 표시하려면 유효 자릿수를 0으로 설정하십시오. 유효 자릿수는 구문 분석에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d91005939f84137a8df80f671cacf84df36e6b8" translate="yes" xml:space="preserve">
          <source>The number of subsampled pixels in a scanline is given by</source>
          <target state="translated">스캔 라인에서 서브 샘플링 된 픽셀 수는</target>
        </trans-unit>
        <trans-unit id="dcd109508ee8f3a6f378ef74aa92b469fe67d4fc" translate="yes" xml:space="preserve">
          <source>The number of system colors in the array.</source>
          <target state="translated">The number of system colors in the array.</target>
        </trans-unit>
        <trans-unit id="ff212c63b39ca97d00e31f372ba96ac08c1c2239" translate="yes" xml:space="preserve">
          <source>The number of timer notifications.</source>
          <target state="translated">타이머 알림 수입니다.</target>
        </trans-unit>
        <trans-unit id="a99c933e31e58e2b2effa06d1ecd99e60ab9562d" translate="yes" xml:space="preserve">
          <source>The number of times that the memory usage has crossed a threshold when the notification was constructed. For usage threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount()&quot;&gt;&lt;code&gt;usage threshold
       count&lt;/code&gt;&lt;/a&gt;. For collection threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount()&quot;&gt;&lt;code&gt;collection usage threshold count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The number of times that the memory usage has crossed a threshold when the notification was constructed. For usage threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount()&quot;&gt; &lt;code&gt;usage threshold count&lt;/code&gt; &lt;/a&gt;. For collection threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount()&quot;&gt; &lt;code&gt;collection usage threshold count&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="19bd983290a225549adc50288431558c89bf12d7" translate="yes" xml:space="preserve">
          <source>The number of times that the memory usage has crossed a threshold when the notification was constructed. For usage threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;usage threshold
       count&lt;/code&gt;&lt;/a&gt;. For collection threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount--&quot;&gt;&lt;code&gt;collection usage threshold count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">알림이 생성 될 때 메모리 사용량이 임계 값을 초과 한 횟수입니다. 사용 임계 값 알림의 경우이 수는 &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;usage threshold count&lt;/code&gt; &lt;/a&gt; 입니다. 수집 임계 값 알림의 경우이 수는 &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount--&quot;&gt; &lt;code&gt;collection usage threshold count&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d5233e312eca4b40bdcfff8caabd2847f926280" translate="yes" xml:space="preserve">
          <source>The number of times that the thread has blocked for synchronization or waited for notification.</source>
          <target state="translated">스레드가 동기화를 차단하거나 알림을 기다린 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="3736904d09a27872b02330b53922aff48808ffef" translate="yes" xml:space="preserve">
          <source>The number of times this list has been</source>
          <target state="translated">이 목록의 횟수</target>
        </trans-unit>
        <trans-unit id="357ec448a341d2b228db1dbd27bc9cf72c53aabb" translate="yes" xml:space="preserve">
          <source>The number of type arguments must either equal the number of the type element's formal type parameters, or must be zero. If zero, and if the type element is generic, then the type element's raw type is returned.</source>
          <target state="translated">형식 인수의 수는 형식 요소의 형식 형식 매개 변수의 수와 같거나 0이어야합니다. 0이고 유형 요소가 일반이면 유형 요소의 원시 유형이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6b602b7781dbf08e5719fd58a4e1bbbbeccdfe65" translate="yes" xml:space="preserve">
          <source>The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition or if this number cannot be obtained. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;#getTotalSpace()&quot;&gt;&lt;code&gt;getTotalSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션의 할당되지 않은 바이트 수 또는 추상 경로 이름이 파티션의 이름을 지정하지 &lt;code&gt;0L&lt;/code&gt; 번호를 얻을 수없는 경우 0L 입니다. 이 값은 &lt;a href=&quot;#getTotalSpace()&quot;&gt; &lt;code&gt;getTotalSpace()&lt;/code&gt; &lt;/a&gt; 반환 된 총 파일 시스템 크기보다 작거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="668af3c185c4b261a4b5f605aa7eb30233f7fa80" translate="yes" xml:space="preserve">
          <source>The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;#getTotalSpace()&quot;&gt;&lt;code&gt;getTotalSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;#getTotalSpace()&quot;&gt; &lt;code&gt;getTotalSpace()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bb5dcdeeed728c559a3fe4b12406c534b1b7846c" translate="yes" xml:space="preserve">
          <source>The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;file#getTotalSpace--&quot;&gt;&lt;code&gt;getTotalSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션에서 할당되지 않은 바이트 수 또는 추상 경로 이름으로 파티션 이름을 지정하지 않은 경우 &lt;code&gt;0L&lt;/code&gt; 이 값은 다음으로 반환되는 총 파일 시스템 크기보다 작거나 같습니다.&lt;a href=&quot;file#getTotalSpace--&quot;&gt; &lt;code&gt;getTotalSpace()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="43d617bb62a7a18964f7ca8a27418ffb89cf70e0" translate="yes" xml:space="preserve">
          <source>The number of unique keys consumed, possibly zero</source>
          <target state="translated">The number of unique keys consumed, possibly zero</target>
        </trans-unit>
        <trans-unit id="87c541a3e7a17d1566331ea8f74b8b01cec37942" translate="yes" xml:space="preserve">
          <source>The number of valid bytes in the buffer.</source>
          <target state="translated">버퍼에서 유효한 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="24896816bf723dc5a3b4b2e1bd2ca0f9074de51b" translate="yes" xml:space="preserve">
          <source>The number of valid bytes in the buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;buf.length&lt;/code&gt;; elements &lt;code&gt;buf[0]&lt;/code&gt; through &lt;code&gt;buf[count-1]&lt;/code&gt; contain valid byte data.</source>
          <target state="translated">버퍼에서 유효한 바이트 수입니다. 이 값의 범위는 항상 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;buf.length&lt;/code&gt; 입니다 . 요소 &lt;code&gt;buf[0]&lt;/code&gt; 통해 &lt;code&gt;buf[count-1]&lt;/code&gt; 유효 바이트 데이터를 포함한다.</target>
        </trans-unit>
        <trans-unit id="2e96ff8f9eedefb579c2382e0dc82d928321f101" translate="yes" xml:space="preserve">
          <source>The number of valid characters in the input stream buffer.</source>
          <target state="translated">입력 스트림 버퍼의 유효한 문자 수</target>
        </trans-unit>
        <trans-unit id="e57f66c301a924e445314f3299d3af941360076b" translate="yes" xml:space="preserve">
          <source>The number of valid components in the vector of observed objects.</source>
          <target state="translated">관찰 된 객체의 벡터에서 유효한 구성 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="d8ec9845a21a8802586d218cdb961c9632ff679e" translate="yes" xml:space="preserve">
          <source>The number of valid components in this &lt;code&gt;Vector&lt;/code&gt; object.</source>
          <target state="translated">The number of valid components in this &lt;code&gt;Vector&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="f6b3f8e949ab3c4c73047ca1f7e1396e53ad0edf" translate="yes" xml:space="preserve">
          <source>The number of valid components in this &lt;code&gt;Vector&lt;/code&gt; object. Components &lt;code&gt;elementData[0]&lt;/code&gt; through &lt;code&gt;elementData[elementCount-1]&lt;/code&gt; are the actual items.</source>
          <target state="translated">이 &lt;code&gt;Vector&lt;/code&gt; 객체 의 유효한 구성 요소 수입니다 . 부품 &lt;code&gt;elementData[0]&lt;/code&gt; 내지 &lt;code&gt;elementData[elementCount-1]&lt;/code&gt; 의 실제 항목이다.</target>
        </trans-unit>
        <trans-unit id="d36405cf1838f4623a0028cc40d5619b16565f33" translate="yes" xml:space="preserve">
          <source>The number of values between the major tick marks -- the larger marks that break up the minor tick marks.</source>
          <target state="translated">The number of values between the major tick marks -- the larger marks that break up the minor tick marks.</target>
        </trans-unit>
        <trans-unit id="6f14995f2deadbb2d0a053c0fbe4ed6a82bd8ff5" translate="yes" xml:space="preserve">
          <source>The number of values between the minor tick marks -- the smaller marks that occur between the major tick marks.</source>
          <target state="translated">The number of values between the minor tick marks -- the smaller marks that occur between the major tick marks.</target>
        </trans-unit>
        <trans-unit id="bc51c3cdfd5086e82cbbf9f7edebb6104b8eb202" translate="yes" xml:space="preserve">
          <source>The number, types and properties of a &lt;code&gt;ResultSet&lt;/code&gt; object's columns are provided by the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object returned by the &lt;code&gt;ResultSet.getMetaData&lt;/code&gt; method.</source>
          <target state="translated">The number, types and properties of a &lt;code&gt;ResultSet&lt;/code&gt; object's columns are provided by the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object returned by the &lt;code&gt;ResultSet.getMetaData&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="f57f709838bfc1167d3aa24e20f38dfd74e18c34" translate="yes" xml:space="preserve">
          <source>The numerically largest constant representing a TIFF data type.</source>
          <target state="translated">The numerically largest constant representing a TIFF data type.</target>
        </trans-unit>
        <trans-unit id="7b270a943d9f7ce2a2bc2099cd7e009b0695ba7c" translate="yes" xml:space="preserve">
          <source>The numerically smallest constant representing a TIFF data type.</source>
          <target state="translated">The numerically smallest constant representing a TIFF data type.</target>
        </trans-unit>
        <trans-unit id="9bc6965ff85bb150de99e69a5605bbc312ce5005" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;crs&lt;/code&gt; now contains the data from the table &lt;code&gt;EMPLOYEES&lt;/code&gt;, just as the object &lt;code&gt;rs&lt;/code&gt; does. The difference is that the cursor for &lt;code&gt;crs&lt;/code&gt; can be moved forward, backward, or to a particular row even if the cursor for &lt;code&gt;rs&lt;/code&gt; can move only forward. In addition, &lt;code&gt;crs&lt;/code&gt; is updatable even if &lt;code&gt;rs&lt;/code&gt; is not because by default, a &lt;code&gt;CachedRowSet&lt;/code&gt; object is both scrollable and updatable.</source>
          <target state="translated">The object &lt;code&gt;crs&lt;/code&gt; now contains the data from the table &lt;code&gt;EMPLOYEES&lt;/code&gt; , just as the object &lt;code&gt;rs&lt;/code&gt; does. The difference is that the cursor for &lt;code&gt;crs&lt;/code&gt; can be moved forward, backward, or to a particular row even if the cursor for &lt;code&gt;rs&lt;/code&gt; can move only forward. In addition, &lt;code&gt;crs&lt;/code&gt; is updatable even if &lt;code&gt;rs&lt;/code&gt; is not because by default, a &lt;code&gt;CachedRowSet&lt;/code&gt; object is both scrollable and updatable.</target>
        </trans-unit>
        <trans-unit id="8e1ec64095853fe197aa6cf41100bd72f0b70a53" translate="yes" xml:space="preserve">
          <source>The object acts as a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt;&lt;code&gt;Flow.Subscriber&lt;/code&gt;&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;&amp;gt;&amp;gt; to the HTTP Client implementation, which publishes lists of ByteBuffers containing the response body. The Flow of data, as well as the order of ByteBuffers in the Flow lists, is a strictly ordered representation of the response body. Both the Lists and the ByteBuffers, once passed to the subscriber, are no longer used by the HTTP Client. The subscriber converts the incoming buffers of data to some higher-level Java type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">The object acts as a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt; &lt;code&gt;Flow.Subscriber&lt;/code&gt; &lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; &lt;/a&gt;&amp;gt;&amp;gt; to the HTTP Client implementation, which publishes lists of ByteBuffers containing the response body. The Flow of data, as well as the order of ByteBuffers in the Flow lists, is a strictly ordered representation of the response body. Both the Lists and the ByteBuffers, once passed to the subscriber, are no longer used by the HTTP Client. The subscriber converts the incoming buffers of data to some higher-level Java type &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee52cc4a979dfa290de71fa0d59778b99e3b2595" translate="yes" xml:space="preserve">
          <source>The object at the top of this stack (the last item of the &lt;code&gt;Vector&lt;/code&gt; object).</source>
          <target state="translated">이 스택의 맨 위에있는 객체입니다 ( &lt;code&gt;Vector&lt;/code&gt; 객체 의 마지막 항목 ).</target>
        </trans-unit>
        <trans-unit id="94b3742377d13942b81c18e1127b983561a8c3d5" translate="yes" xml:space="preserve">
          <source>The object being edited</source>
          <target state="translated">The object being edited</target>
        </trans-unit>
        <trans-unit id="e3463f0dce6f74d0351102935f5ca5c5e97f8ec9" translate="yes" xml:space="preserve">
          <source>The object being observed.</source>
          <target state="translated">관찰되는 물체.</target>
        </trans-unit>
        <trans-unit id="549576c93743bbc010ab0c4c1c93ac04bc78070c" translate="yes" xml:space="preserve">
          <source>The object bound; null if this binding does not contain an object.</source>
          <target state="translated">개체가 바인딩되었습니다. 이 바인딩에 객체가없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="449d3598041a294afe3399942437e9f97f025dcf" translate="yes" xml:space="preserve">
          <source>The object contains some &lt;code&gt;Accessible&lt;/code&gt; information, but its role is not known.</source>
          <target state="translated">The object contains some &lt;code&gt;Accessible&lt;/code&gt; information, but its role is not known.</target>
        </trans-unit>
        <trans-unit id="ab8401c61b78ecc0ded2083081b9915784d7e095" translate="yes" xml:space="preserve">
          <source>The object created; null if an object cannot be created.</source>
          <target state="translated">생성 된 객체; 객체를 작성할 수없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="25101b399f33f9945d69632115c3f921d4a373f9" translate="yes" xml:space="preserve">
          <source>The object currently attached to this key, or &lt;code&gt;null&lt;/code&gt; if there is no attachment</source>
          <target state="translated">현재이 키에 연결된 객체 또는 &lt;code&gt;null&lt;/code&gt; 첨부가없는 경우는</target>
        </trans-unit>
        <trans-unit id="83e78860e5f6b1711764595fee4d0cebd5f6dd80" translate="yes" xml:space="preserve">
          <source>The object factories tried must implement either &lt;code&gt;ObjectFactory&lt;/code&gt; or &lt;code&gt;DirObjectFactory&lt;/code&gt;. If it implements &lt;code&gt;DirObjectFactory&lt;/code&gt;, &lt;code&gt;DirObjectFactory.getObjectInstance()&lt;/code&gt; is used, otherwise, &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; is used.</source>
          <target state="translated">시도한 객체 팩토리는 &lt;code&gt;ObjectFactory&lt;/code&gt; 또는 &lt;code&gt;DirObjectFactory&lt;/code&gt; 를 구현해야합니다 . 그것을 구현하는 경우 &lt;code&gt;DirObjectFactory&lt;/code&gt; 를 , &lt;code&gt;DirObjectFactory.getObjectInstance()&lt;/code&gt; 사용하고, 그렇지 않으면 &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="ab1ce82fc4930728131e5f5b4937333efd1a4cdb" translate="yes" xml:space="preserve">
          <source>The object identifier string, &quot;1.3.6.1.4.1.1466.20037&quot;.</source>
          <target state="translated">개체 식별자 문자열 &quot;1.3.6.1.4.1.1466.20037&quot;</target>
        </trans-unit>
        <trans-unit id="d1a4549046096f69268afef4b505824d9f29c7f1" translate="yes" xml:space="preserve">
          <source>The object implementing the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface returns from its &lt;code&gt;getProduct&lt;/code&gt; method an object implementing the &lt;code&gt;ProductMXBean&lt;/code&gt; interface. The &lt;code&gt;ModuleMXBean&lt;/code&gt; object and the returned &lt;code&gt;
      ProductMXBean&lt;/code&gt; objects must both be registered as MXBeans in the same MBean Server.</source>
          <target state="translated">The object implementing the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface returns from its &lt;code&gt;getProduct&lt;/code&gt; method an object implementing the &lt;code&gt;ProductMXBean&lt;/code&gt; interface. The &lt;code&gt;ModuleMXBean&lt;/code&gt; object and the returned &lt;code&gt; ProductMXBean&lt;/code&gt; objects must both be registered as MXBeans in the same MBean Server.</target>
        </trans-unit>
        <trans-unit id="d478c804036047e663cb169378cb0113711a662b" translate="yes" xml:space="preserve">
          <source>The object implementing the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface returns from its &lt;code&gt;getProduct&lt;/code&gt; method an object implementing the &lt;code&gt;ProductMXBean&lt;/code&gt; interface. The &lt;code&gt;ModuleMXBean&lt;/code&gt; object and the returned &lt;code&gt;ProductMXBean&lt;/code&gt; objects must both be registered as MXBeans in the same MBean Server.</source>
          <target state="translated">구현하는 객체 &lt;code&gt;ModuleMXBean&lt;/code&gt; 의에서 인터페이스를 반환 &lt;code&gt;getProduct&lt;/code&gt; 의 메소드 구현하는 객체 &lt;code&gt;ProductMXBean&lt;/code&gt; 인터페이스를. &lt;code&gt;ModuleMXBean&lt;/code&gt; 의 객체와 반환되는 &lt;code&gt;ProductMXBean&lt;/code&gt; 은 반드시 모두 동일한의 MBean 서버에 MXBean에로 등록 객체.</target>
        </trans-unit>
        <trans-unit id="3dd2f9f197debe54b55c044ebc8513127ed88c2f" translate="yes" xml:space="preserve">
          <source>The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays.</source>
          <target state="translated">The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays.</target>
        </trans-unit>
        <trans-unit id="acbe0492ed2a56ae25a5b225e810323a17ee9567" translate="yes" xml:space="preserve">
          <source>The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays. The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.</source>
          <target state="translated">객체는 readExternal 메소드를 구현하여 기본 유형에 대해서는 DataInput 메소드를, 객체, 문자열 및 배열에 대해서는 readObject 메소드를 호출하여 컨텐츠를 복원합니다. readExternal 메소드는 writeExternal이 작성한 것과 동일한 순서 및 유형으로 값을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="c660c0ad9f3d328f1f20a48dcdf28911ebb8dafe" translate="yes" xml:space="preserve">
          <source>The object implements the writeExternal method to save its contents by calling the methods of DataOutput for its primitive values or calling the writeObject method of ObjectOutput for objects, strings, and arrays.</source>
          <target state="translated">객체는 기본 값으로 DataOutput의 메소드를 호출하거나 객체, 문자열 및 배열에 대해 ObjectOutput의 writeObject 메소드를 호출하여 컨텐츠를 저장하기 위해 writeExternal 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="49b3c7a825f5c8fce74e67a564c0c3afebb0bbd2" translate="yes" xml:space="preserve">
          <source>The object is converted to a &lt;code&gt;String&lt;/code&gt; by calling its &lt;code&gt;toString&lt;/code&gt; method. The result is wrapped in a &lt;code&gt;JLabel&lt;/code&gt; and displayed.</source>
          <target state="translated">The object is converted to a &lt;code&gt;String&lt;/code&gt; by calling its &lt;code&gt;toString&lt;/code&gt; method. The result is wrapped in a &lt;code&gt;JLabel&lt;/code&gt; and displayed.</target>
        </trans-unit>
        <trans-unit id="416c57a91832721c9f5aceb6449ffd3e9e13e27e" translate="yes" xml:space="preserve">
          <source>The object is exported with a server socket created using the &lt;a href=&quot;rmisocketfactory&quot;&gt;&lt;code&gt;RMISocketFactory&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">객체는 &lt;a href=&quot;rmisocketfactory&quot;&gt; &lt;code&gt;RMISocketFactory&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 생성 된 서버 소켓과 함께 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="803c0a9c70ce150a1fdc3f8dcd7dcababb9b43c4" translate="yes" xml:space="preserve">
          <source>The object name for identifying the MXBean in the platform MBean server is:</source>
          <target state="translated">플랫폼 MBean 서버에서 MXBean을 식별하기위한 오브젝트 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38b36518730fd2c13f206fa344da4fbf71908e2b" translate="yes" xml:space="preserve">
          <source>The object name is written using the usual syntax for &lt;a href=&quot;objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt;. It may contain any legal characters, including &lt;code&gt;]&lt;/code&gt;. It is terminated by a &lt;code&gt;]&lt;/code&gt; character that is the last character in the string.</source>
          <target state="translated">객체 이름은 일반적인 &lt;a href=&quot;objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; 구문을 사용하여 작성 됩니다 . &lt;code&gt;]&lt;/code&gt; 를 포함하여 유효한 문자를 포함 할 수 있습니다 . 문자열에서 마지막 문자 인 &lt;code&gt;]&lt;/code&gt; 문자 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcd8b487cf6c43869dd95c8f0bff1303f6f407e8" translate="yes" xml:space="preserve">
          <source>The object on which the Event initially occurred.</source>
          <target state="translated">이벤트가 처음 발생한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a1808bbdd8fe581c5b3453a2a271ffb2f9d6c722" translate="yes" xml:space="preserve">
          <source>The object reference returned from &lt;code&gt;Transferable.getTransferData&lt;/code&gt; for a &lt;code&gt;DataFlavor&lt;/code&gt; with this MIME Content-Type is required to be an instance of the representation Class of the &lt;code&gt;DataFlavor&lt;/code&gt;.</source>
          <target state="translated">이 MIME Content-Type 을 가진 &lt;code&gt;DataFlavor&lt;/code&gt; 에 대해 &lt;code&gt;Transferable.getTransferData&lt;/code&gt; 에서 반환 된 객체 참조 는 DataFlavor 표현 클래스의 인스턴스 여야 &lt;code&gt;DataFlavor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81130672cbc8ff967d42b441aaca30a9b8bdf723" translate="yes" xml:space="preserve">
          <source>The object returned by the action, which represents the result of invoking the action on the MBean specified.</source>
          <target state="translated">액션이 돌려주는 오브젝트. 지정된 MBean상에서 액션을 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36afb72a7b72fb42fa69bd024e797eb65658034c" translate="yes" xml:space="preserve">
          <source>The object returned by the method, which represents the result of invoking the method on the specified managed resource.</source>
          <target state="translated">메소드가 리턴 한 오브젝트. 지정된 관리 자원에서 메소드를 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4aed1f261990252b69271a77a6e7502c08d201c0" translate="yes" xml:space="preserve">
          <source>The object returned by the operation, which represents the result of invoking the operation on the MBean specified.</source>
          <target state="translated">오퍼레이션에 의해 돌려 주어지는 오브젝트. 지정된 MBean상에서 오퍼레이션을 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6c93f62d51e3b2cfddc806818f63e0d7ad31bfac" translate="yes" xml:space="preserve">
          <source>The object returned by this method is a &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is an &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt;&lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 객체는 &lt;code&gt;InvocationHandler&lt;/code&gt; 가 &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt; &lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt; &lt;/a&gt; 인 &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="19c49d417b2958f22cd9e8d59294bafdefc26984" translate="yes" xml:space="preserve">
          <source>The object returned by this method is a &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is an &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt;&lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 돌려 주어진 오브젝트는 , &lt;code&gt;InvocationHandler&lt;/code&gt; 가 &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt; &lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt; &lt;/a&gt; 인 &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="2fd75977ed6de60086bb423f950b0a7c4c202381" translate="yes" xml:space="preserve">
          <source>The object returned by this method is owned by the caller. The implementation will not subsequently modify it. It will contain either a new &lt;code&gt;Attributes&lt;/code&gt; object that is likewise owned by the caller, or a reference to the original &lt;code&gt;attrs&lt;/code&gt; parameter.</source>
          <target state="translated">이 메소드에 의해 리턴 된 오브젝트는 호출자가 소유합니다. 구현은 나중에 수정하지 않습니다. 호출자가 소유 한 새로운 &lt;code&gt;Attributes&lt;/code&gt; 객체 또는 원래 &lt;code&gt;attrs&lt;/code&gt; 매개 변수에 대한 참조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="de60c4905cdacdd6d8601ccdfcd944817e444f9d" translate="yes" xml:space="preserve">
          <source>The object that holds the data for the progress bar.</source>
          <target state="translated">진행률 표시 줄에 대한 데이터를 보유하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="592ac681baf8df60b8a9b00bdcd506d4334a9175" translate="yes" xml:space="preserve">
          <source>The object that implements the &lt;code&gt;ActionListener&lt;/code&gt; interface gets this &lt;code&gt;ActionEvent&lt;/code&gt; when the event occurs. The listener is therefore spared the details of processing individual mouse movements and mouse clicks, and can instead process a &quot;meaningful&quot; (semantic) event like &quot;button pressed&quot;.</source>
          <target state="translated">&lt;code&gt;ActionListener&lt;/code&gt; 인터페이스 를 구현하는 객체 는 이벤트가 발생할 때이 &lt;code&gt;ActionEvent&lt;/code&gt; 를 가져 옵니다. 따라서 청취자는 개별 마우스 움직임 및 마우스 클릭 처리에 대한 세부 사항을 아끼지 않고 대신 &quot;버튼 누름&quot;과 같은 &quot;의미있는&quot;(의미있는) 이벤트를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="378268adb2f0c5ea9f44ef1d220ef0a45f3c5690" translate="yes" xml:space="preserve">
          <source>The object that implements the &lt;code&gt;ItemListener&lt;/code&gt; interface gets this &lt;code&gt;ItemEvent&lt;/code&gt; when the event occurs. The listener is spared the details of processing individual mouse movements and mouse clicks, and can instead process a &quot;meaningful&quot; (semantic) event like &quot;item selected&quot; or &quot;item deselected&quot;.</source>
          <target state="translated">&lt;code&gt;ItemListener&lt;/code&gt; 인터페이스 를 구현하는 객체 는 이벤트가 발생할 때이 &lt;code&gt;ItemEvent&lt;/code&gt; 를 가져 옵니다. 리스너는 개별 마우스 이동 및 마우스 클릭 처리에 대한 세부 사항을 아끼지 않고 대신 &quot;선택된 항목&quot;또는 &quot;선택 취소 된 항목&quot;과 같은 &quot;의미있는&quot;(의미있는) 이벤트를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="722913fb70b4d355c5461a06c046ff754baedd55" translate="yes" xml:space="preserve">
          <source>The object that implements the &lt;code&gt;TextListener&lt;/code&gt; interface gets this &lt;code&gt;TextEvent&lt;/code&gt; when the event occurs. The listener is spared the details of processing individual mouse movements and key strokes Instead, it can process a &quot;meaningful&quot; (semantic) event like &quot;text changed&quot;.</source>
          <target state="translated">&lt;code&gt;TextListener&lt;/code&gt; 인터페이스 를 구현하는 객체 는 이벤트가 발생할 때이 &lt;code&gt;TextEvent&lt;/code&gt; 를 가져 옵니다. 청취자는 개별 마우스 움직임 및 키 입력 처리에 대한 세부 사항을 아끼지 않고 대신 &quot;텍스트 변경&quot;과 같은 &quot;의미있는&quot;(의미 적) 이벤트를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="3a04190473c4b64ec143351918e9e15b033c0e14" translate="yes" xml:space="preserve">
          <source>The object that will generate the parameters can be initialized in two different ways: in an algorithm-independent manner, or in an algorithm-specific manner:</source>
          <target state="translated">매개 변수를 생성하는 오브젝트는 알고리즘 독립적 방식 또는 알고리즘 고유 방식의 두 가지 방식으로 초기화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0bfa8896361883de50652f049a3abf89fa5b629" translate="yes" xml:space="preserve">
          <source>The object to which this reference refers, or &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</source>
          <target state="translated">이 참조가 참조하는 객체 또는 &lt;code&gt;null&lt;/code&gt; 이 참조가 참조하는 오브젝트.이 참조 오브젝트가 클리어 된 경우</target>
        </trans-unit>
        <trans-unit id="479e4c581de3dc9c3988355f57b5a21b657c8262" translate="yes" xml:space="preserve">
          <source>The object upon which the thread is blocked due to:</source>
          <target state="translated">다음으로 인해 스레드가 차단 된 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="59e05639dc4486cdfe5ff6a8dce8bd4e58ea0a79" translate="yes" xml:space="preserve">
          <source>The object used for executing a static SQL statement and returning the results it produces.</source>
          <target state="translated">정적 SQL 문을 실행하고 생성 된 결과를 반환하는 데 사용되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="972046ff7e08954078fcad07463a0ebbf2c0d1a7" translate="yes" xml:space="preserve">
          <source>The object used to represent the &lt;code&gt;TH&lt;/code&gt; and &lt;code&gt;TD&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;TH&lt;/code&gt; 및 &lt;code&gt;TD&lt;/code&gt; 요소 를 나타내는 데 사용되는 개체 입니다.</target>
        </trans-unit>
        <trans-unit id="aee621353b81778427a3f1b8c0393e308ca6d4b9" translate="yes" xml:space="preserve">
          <source>The object used to represent the &lt;code&gt;TH&lt;/code&gt; and &lt;code&gt;TD&lt;/code&gt; elements. See the TD element definition in HTML 4.0.</source>
          <target state="translated">&lt;code&gt;TH&lt;/code&gt; 및 &lt;code&gt;TD&lt;/code&gt; 요소 를 나타내는 데 사용되는 개체 입니다. HTML 4.0의 TD 요소 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d7b9c42317e2e24d3b3dab9ab7fe4afbf8756cb" translate="yes" xml:space="preserve">
          <source>The object used to synchronize operations on this stream.</source>
          <target state="translated">이 스트림에서 작업을 동기화하는 데 사용되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="47d5085633f8d27160804ec39a21ef33e1d60c26" translate="yes" xml:space="preserve">
          <source>The object used to synchronize operations on this stream. For efficiency, a character-stream object may use an object other than itself to protect critical sections. A subclass should therefore use the object in this field rather than &lt;code&gt;this&lt;/code&gt; or a synchronized method.</source>
          <target state="translated">이 스트림의 조작을 동기화하는데 사용되는 객체입니다. 효율을 높이기 위해 캐릭터 스트림 객체는 중요한 섹션을 보호하기 위해 자체 이외의 객체를 사용할 수 있습니다. 따라서 서브 클래스보다는이 분야에서 객체를 사용해야 &lt;code&gt;this&lt;/code&gt; 또는 동기화 방법.</target>
        </trans-unit>
        <trans-unit id="c7cc5f2db4bc998308c976129ab12d35d38dc95c" translate="yes" xml:space="preserve">
          <source>The object's remote reference.</source>
          <target state="translated">개체의 원격 참조입니다.</target>
        </trans-unit>
        <trans-unit id="a07b833139a6ad3c188a63203fee507e5dfad4ab" translate="yes" xml:space="preserve">
          <source>The object's state for binding; null if the factory is not returning any changes.</source>
          <target state="translated">바인딩을위한 객체의 상태. 팩토리가 변경을 돌려주지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="66b636c530e62514647286e66dec68718239aedb" translate="yes" xml:space="preserve">
          <source>The object, null if the object has not been seen before.</source>
          <target state="translated">객체. 이전에 객체를 보지 못한 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="4b2eb00905a91560fe1394f171982be773d4da7b" translate="yes" xml:space="preserve">
          <source>The objects being observed.</source>
          <target state="translated">관찰되는 물체.</target>
        </trans-unit>
        <trans-unit id="31a9cc545d293e2f13a000cd7cec43d84ee2b3fc" translate="yes" xml:space="preserve">
          <source>The objects of the classes implementing &lt;code&gt;Stroke&lt;/code&gt; must be read-only because &lt;code&gt;Graphics2D&lt;/code&gt; does not clone these objects either when they are set as an attribute with the &lt;code&gt;setStroke&lt;/code&gt; method or when the &lt;code&gt;Graphics2D&lt;/code&gt; object is itself cloned. If a &lt;code&gt;Stroke&lt;/code&gt; object is modified after it is set in the &lt;code&gt;Graphics2D&lt;/code&gt; context then the behavior of subsequent rendering would be undefined.</source>
          <target state="translated">&lt;code&gt;Stroke&lt;/code&gt; 를 구현하는 클래스의 개체는 읽기 전용이어야합니다. &lt;code&gt;Graphics2D&lt;/code&gt; 는 &lt;code&gt;setStroke&lt;/code&gt; 메서드 를 사용하여 특성으로 설정 되거나 &lt;code&gt;Graphics2D&lt;/code&gt; 개체가 자체적으로 복제 될 때 이러한 개체를 복제하지 않기 때문 입니다. &lt;code&gt;Stroke&lt;/code&gt; 객체가 &lt;code&gt;Graphics2D&lt;/code&gt; 컨텍스트에 설정된 후 수정 되면 후속 렌더링의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6a36576b202e3f5841ae4674e3a1e6bfeff7ce9" translate="yes" xml:space="preserve">
          <source>The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the &lt;a href=&quot;../package-summary#dom_req&quot;&gt;DOM Mechanism Requirements&lt;/a&gt;. See the &lt;code&gt;KeyInfoFactory&lt;/code&gt; section in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt; Java Security Standard Algorithm Names Specification&lt;/a&gt; for a list of standard mechanism types.</source>
          <target state="translated">이 팩토리가 생성하는 객체는 DOM을 기반으로하며 &lt;a href=&quot;../package-summary#dom_req&quot;&gt;DOM 메커니즘 요구 사항에&lt;/a&gt; 정의 된 DOM 상호 운용성 요구 사항을 준수합니다 . 표준 메커니즘 유형 목록은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt;Java 보안 표준 알고리즘 이름 사양&lt;/a&gt; 의 &lt;code&gt;KeyInfoFactory&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebe728976b073c45bf744821ca6ba80ce51a0da6" translate="yes" xml:space="preserve">
          <source>The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM Mechanism Requirements&lt;/a&gt; section of the API overview. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for more information.</source>
          <target state="translated">이 팩토리가 생성하는 객체는 DOM을 기반으로 하며 API 개요 의 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM 메커니즘 요구 사항&lt;/a&gt; 섹션에 정의 된 DOM 상호 운용성 요구 사항을 준수합니다 . 자세한 정보는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt;Java Security Standard Algorithm Names&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d122f0c0cc63ee07c0c1d3a3a38f8a6e6ad5a6b" translate="yes" xml:space="preserve">
          <source>The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM Mechanism Requirements&lt;/a&gt; section of the API overview. See the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_provider&quot;&gt;Service Providers&lt;/a&gt; section of the API overview for a list of standard mechanism types.</source>
          <target state="translated">이 팩토리가 생성하는 객체는 DOM을 기반으로 하며 API 개요 의 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM 메커니즘 요구 사항&lt;/a&gt; 섹션에 정의 된 DOM 상호 운용성 요구 사항을 준수합니다 . 표준 메커니즘 유형 목록은 API 개요 의 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_provider&quot;&gt;서비스 제공 업체&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="ef9527d4f8b103acbd8f0c5c4ab283344d88a9c1" translate="yes" xml:space="preserve">
          <source>The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the &lt;a href=&quot;package-summary#dom_req&quot;&gt;DOM Mechanism Requirements&lt;/a&gt;. See the &lt;code&gt;XMLSignatureFactory&lt;/code&gt; section in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt; Java Security Standard Algorithm Names Specification&lt;/a&gt; for a list of standard mechanism types.</source>
          <target state="translated">이 팩토리가 생성하는 객체는 DOM을 기반으로하며 &lt;a href=&quot;package-summary#dom_req&quot;&gt;DOM 메커니즘 요구 사항에&lt;/a&gt; 정의 된 DOM 상호 운용성 요구 사항을 준수합니다 . 표준 메커니즘 유형 목록은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt;Java 보안 표준 알고리즘 이름 사양&lt;/a&gt; 의 &lt;code&gt;XMLSignatureFactory&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="429abc75cd4f81d9b58c4ca6b602d61ef39ec33b" translate="yes" xml:space="preserve">
          <source>The observed attribute has differed from the &quot;string to compare&quot; value.</source>
          <target state="translated">관찰 된 속성이 &quot;string to compare&quot;값과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="871c7770e55cdc1bbf71029ab54209655d703ea8" translate="yes" xml:space="preserve">
          <source>The observed attribute has exceeded the threshold high value.</source>
          <target state="translated">관찰 된 속성이 임계 값 상한값을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="672d698adf676e55830651a3e0dd447d91d839f5" translate="yes" xml:space="preserve">
          <source>The observed attribute has exceeded the threshold low value.</source>
          <target state="translated">관찰 된 속성이 임계 값 하한값을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="999e98019d02c1e1a5253c17913dd0ced4ce971f" translate="yes" xml:space="preserve">
          <source>The observed attribute has matched the &quot;string to compare&quot; value.</source>
          <target state="translated">관찰 된 속성이 &quot;string to compare&quot;값과 일치했습니다.</target>
        </trans-unit>
        <trans-unit id="46421981f801d958da0b6eee8f1acb3f27c41fd9" translate="yes" xml:space="preserve">
          <source>The observed attribute has reached the threshold value.</source>
          <target state="translated">관찰 된 속성이 임계 값에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="fca6efcbf0300595dc90421a5999ce724786f218" translate="yes" xml:space="preserve">
          <source>The observed attribute is not contained in the observed object.</source>
          <target state="translated">관찰 된 속성은 관찰 된 개체에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a495e45796ee85b6f7b4712f3dc6b44dbd9667b" translate="yes" xml:space="preserve">
          <source>The observed attribute is not initialized by default (set to null).</source>
          <target state="translated">관찰 된 속성은 기본적으로 초기화되지 않습니다 (null로 설정).</target>
        </trans-unit>
        <trans-unit id="01626b79ebba8880f72349668f94f078b89c13bd" translate="yes" xml:space="preserve">
          <source>The observed attribute.</source>
          <target state="translated">관찰 된 속성.</target>
        </trans-unit>
        <trans-unit id="0a9f956d167d7d6dbfd3e8ba63d5548489a146e8" translate="yes" xml:space="preserve">
          <source>The observed object is not registered in the MBean server.</source>
          <target state="translated">관찰 된 오브젝트가 MBean 서버에 등록되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="416b7e765f8103a9eb70b7e15edec19bb2ecc0e9" translate="yes" xml:space="preserve">
          <source>The observed object.</source>
          <target state="translated">관찰 된 물체.</target>
        </trans-unit>
        <trans-unit id="45dc8c9c6ea7bb9a99fef1fccbc3548f32fa1a9e" translate="yes" xml:space="preserve">
          <source>The obtained &lt;a href=&quot;typeinfoprovider&quot;&gt;&lt;code&gt;TypeInfoProvider&lt;/code&gt;&lt;/a&gt; can be queried during a parse to access the type information determined by the validator.</source>
          <target state="translated">획득 한 &lt;a href=&quot;typeinfoprovider&quot;&gt; &lt;code&gt;TypeInfoProvider&lt;/code&gt; &lt;/a&gt; 는 유효성 검사기가 결정한 유형 정보에 액세스하기 위해 구문 분석 중에 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="57e624d8b36b41f9dc5b92485a65e92541347bbe" translate="yes" xml:space="preserve">
          <source>The official ISO-8601 standard does not define eras, however &lt;code&gt;IsoChronology&lt;/code&gt; does. It defines two eras, 'CE' from year one onwards and 'BCE' from year zero backwards. Since dates before the Julian-Gregorian cutover are not in line with history, the cutover between 'BCE' and 'CE' is also not aligned with the commonly used eras, often referred to using 'BC' and 'AD'.</source>
          <target state="translated">공식 ISO-8601 표준은 시대를 정의 하지 않지만 &lt;code&gt;IsoChronology&lt;/code&gt; 는 시대를 정의하지 않습니다 . 1 년부터 'CE', 0 년부터 'BCE'의 두 시대를 정의합니다. Julian-Gregorian 컷 오버 이전 날짜는 역사와 일치하지 않기 때문에 'BCE'와 'CE'사이의 컷 오버는 흔히 'BC'와 'AD'를 사용하는 데 사용되는 일반적으로 사용되는 시대와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="702e5e5fb4fee8a147a291965da3b8b686cd784a" translate="yes" xml:space="preserve">
          <source>The official XML Namespace name URI.</source>
          <target state="translated">공식 XML 네임 스페이스 이름 URI입니다.</target>
        </trans-unit>
        <trans-unit id="ffab6be2401ae307b4e44045f56125a67011b1bb" translate="yes" xml:space="preserve">
          <source>The official XML Namespace prefix.</source>
          <target state="translated">공식 XML 네임 스페이스 접두사.</target>
        </trans-unit>
        <trans-unit id="a4a7af578f6f669ed14b4164a2625019a1a64582" translate="yes" xml:space="preserve">
          <source>The official XML attribute used for specifying XML Namespace declarations, &lt;a href=&quot;#XMLNS_ATTRIBUTE&quot;&gt;&lt;code&gt;XMLConstants.XMLNS_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;, Namespace name URI.</source>
          <target state="translated">XML 네임 스페이스 선언, &lt;a href=&quot;#XMLNS_ATTRIBUTE&quot;&gt; &lt;code&gt;XMLConstants.XMLNS_ATTRIBUTE&lt;/code&gt; &lt;/a&gt; , 네임 스페이스 이름 URI 를 지정하는 데 사용되는 공식 XML 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="7c5ea6d3db745c887e7f367926242e325c40c6a6" translate="yes" xml:space="preserve">
          <source>The official XML attribute used for specifying XML Namespace declarations.</source>
          <target state="translated">XML 네임 스페이스 선언을 지정하는 데 사용되는 공식 XML 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9aa0cbb0971f94ec243f04bed4069fee72927eed" translate="yes" xml:space="preserve">
          <source>The offset</source>
          <target state="translated">오프셋</target>
        </trans-unit>
        <trans-unit id="7452b72544afe4ea17383b9c1a0ddd335f187953" translate="yes" xml:space="preserve">
          <source>The offset after the last character captured by the group, or &lt;code&gt;-1&lt;/code&gt; if the match was successful but the group itself did not match anything</source>
          <target state="translated">그룹이 마지막으로 캡처 한 문자 이후의 오프셋 또는 &lt;code&gt;-1&lt;/code&gt; 일치하지만 그룹 자체가 아무 것도 일치하지 않으면</target>
        </trans-unit>
        <trans-unit id="a6a514a96e4c706169df1bae50ab993a34ff2649" translate="yes" xml:space="preserve">
          <source>The offset after the last character matched</source>
          <target state="translated">마지막 문자 이후의 오프셋</target>
        </trans-unit>
        <trans-unit id="95184cd7d4878804e4744550fed5412ac87a781a" translate="yes" xml:space="preserve">
          <source>The offset does not affect the calculation and will be the same in the result.</source>
          <target state="translated">오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8d0ea8f68c9762891010ddff46c446503f293682" translate="yes" xml:space="preserve">
          <source>The offset from UTC/Greenwich.</source>
          <target state="translated">UTC / 그리니치와의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="187e2b59cf9b7d7beab7161e59a7d3c2b6d648e0" translate="yes" xml:space="preserve">
          <source>The offset in the destination where the upper-left decoded pixel should be placed.</source>
          <target state="translated">디코딩 된 왼쪽 상단 픽셀이 배치되어야하는 대상의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="f5e45443bbef26f421b83a68935e17782face615" translate="yes" xml:space="preserve">
          <source>The offset in the destination where the upper-left decoded pixel should be placed. By default, the value is (0, 0).</source>
          <target state="translated">왼쪽 상단의 디코딩 된 픽셀을 배치 할 대상의 오프셋입니다. 기본적으로 값은 (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="bcad531c02ce778e413b93f44d2a73d86d13c97e" translate="yes" xml:space="preserve">
          <source>The offset must be in the range &lt;code&gt;-18:00&lt;/code&gt; to &lt;code&gt;+18:00&lt;/code&gt;, which corresponds to -64800 to +64800.</source>
          <target state="translated">오프셋은 &lt;code&gt;-18:00&lt;/code&gt; ~ &lt;code&gt;+18:00&lt;/code&gt; 범위에 있어야하며 이는 -64800 ~ +64800에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="1779234f1100c3b7e70e689137679a16d92bfee0" translate="yes" xml:space="preserve">
          <source>The offset of the caret is relative to the current composed text; that is, the composed text within getText() if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within getText() of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.</source>
          <target state="translated">캐럿의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 이것이 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 인 경우 getText () 내의 작성된 텍스트, 그렇지 않은 경우 이전 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 의 getText () 내의 작성된 텍스트 입니다.</target>
        </trans-unit>
        <trans-unit id="298942ecb904f06c2e9ab9e10fc0a7a6f6c5d93f" translate="yes" xml:space="preserve">
          <source>The offset of the divider.</source>
          <target state="translated">구분선의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="bc4e0b22e164423e697bcbfa93e4a52b80e4ded8" translate="yes" xml:space="preserve">
          <source>The offset of the visible position is relative to the current composed text; that is, the composed text within getText() if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within getText() of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.</source>
          <target state="translated">보이는 위치의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 이것이 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 인 경우 getText () 내의 작성된 텍스트, 그렇지 않은 경우 이전 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 의 getText () 내의 작성된 텍스트 입니다.</target>
        </trans-unit>
        <trans-unit id="dbff04852ae6dc7f91ef52e4416eeb9c4bdba3f8" translate="yes" xml:space="preserve">
          <source>The offset value.</source>
          <target state="translated">오프셋 값.</target>
        </trans-unit>
        <trans-unit id="1ee05bd1235e40acbee8bde4cc93361e017df6f0" translate="yes" xml:space="preserve">
          <source>The offset within this buffer's array of the first element of the buffer</source>
          <target state="translated">버퍼의 첫 번째 요소에 대한이 버퍼의 배열 내 오프셋</target>
        </trans-unit>
        <trans-unit id="fe8294ba666d8dd39741a182a81b1fec80b75498" translate="yes" xml:space="preserve">
          <source>The offset, in bits, of the layout selected by the layout path in &lt;code&gt;elements&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;elements&lt;/code&gt; 의 레이아웃 경로에 의해 선택된 레이아웃의 오프셋 (비트)입니다 .</target>
        </trans-unit>
        <trans-unit id="4c97a082dbdaef80700756fbcab43cc75fe82149" translate="yes" xml:space="preserve">
          <source>The offset, in bytes, of the layout selected by the layout path in &lt;code&gt;elements&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;elements&lt;/code&gt; 의 레이아웃 경로에 의해 선택된 레이아웃의 오프셋 (바이트)입니다 .</target>
        </trans-unit>
        <trans-unit id="c2f54cdf947745f8f0b6ab00403e70f969ef9fcc" translate="yes" xml:space="preserve">
          <source>The offset-based date-time types &lt;code&gt;OffsetTime&lt;/code&gt; and &lt;code&gt;OffsetDateTime&lt;/code&gt;, are intended primarily for use with network protocols and database access. For example, most databases cannot automatically store a time-zone like 'Europe/Paris', but they can store an offset like '+02:00'.</source>
          <target state="translated">오프셋 기반 날짜-시간 유형 &lt;code&gt;OffsetTime&lt;/code&gt; 및 &lt;code&gt;OffsetDateTime&lt;/code&gt; 은 주로 네트워크 프로토콜 및 데이터베이스 액세스에 사용하기위한 것입니다. 예를 들어, 대부분의 데이터베이스는 '유럽 / 파리'와 같은 시간대를 자동으로 저장할 수 없지만 '+02 : 00'과 같은 오프셋을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118a1e86d2011a80aabb35687d2f8db1fc48e418" translate="yes" xml:space="preserve">
          <source>The offsets are compared in the order that they occur for the same time of day around the world. Thus, an offset of &lt;code&gt;+10:00&lt;/code&gt; comes before an offset of &lt;code&gt;+09:00&lt;/code&gt; and so on down to &lt;code&gt;-18:00&lt;/code&gt;.</source>
          <target state="translated">오프셋은 전 세계 동일한 시간에 발생하는 순서대로 비교됩니다. 따라서 &lt;code&gt;+10:00&lt;/code&gt; 오프셋은 &lt;code&gt;+09:00&lt;/code&gt; 오프셋 앞에오고 &lt;code&gt;-18:00&lt;/code&gt; 까지 내려갑니다 .</target>
        </trans-unit>
        <trans-unit id="b9fdfa406d3d4cfc6d0cc44eef8e628beb67c6ec" translate="yes" xml:space="preserve">
          <source>The offsets of &lt;code&gt;caret&lt;/code&gt; and &lt;code&gt;visiblePosition&lt;/code&gt; are relative to the current composed text; that is, the composed text within the &lt;code&gt;text&lt;/code&gt; of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event if the event being constructed as a &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt; event. For an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event without text, &lt;code&gt;caret&lt;/code&gt; and &lt;code&gt;visiblePosition&lt;/code&gt; must be &lt;code&gt;null&lt;/code&gt;. The time stamp for this event is initialized by invoking &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt;&lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;caret&lt;/code&gt; 및 &lt;code&gt;visiblePosition&lt;/code&gt; 의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 내부 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 앞의 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트는 이벤트로 구성되는 경우 &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt; 이벤트. 를 들어 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 텍스트없이 이벤트 &lt;code&gt;caret&lt;/code&gt; 및 &lt;code&gt;visiblePosition&lt;/code&gt; 이 있어야합니다 &lt;code&gt;null&lt;/code&gt; . 이 이벤트의 타임 스탬프는 &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt; &lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt; &lt;/a&gt; 을 호출하여 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9615764801bc7f0118b08c3cedefd1d207963ebd" translate="yes" xml:space="preserve">
          <source>The offsets of caret and visiblePosition are relative to the current composed text; that is, the composed text within &lt;code&gt;text&lt;/code&gt; if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within the &lt;code&gt;text&lt;/code&gt; of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.</source>
          <target state="translated">caret 및 visiblePosition의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 내 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 이는 경우 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트는 내의 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 앞의 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 그렇지 않으면 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="e3efed3cce04acecd68237e471d78f4ab8c10742" translate="yes" xml:space="preserve">
          <source>The offsets of caret and visiblePosition are relative to the current composed text; that is, the composed text within &lt;code&gt;text&lt;/code&gt; if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within the &lt;code&gt;text&lt;/code&gt; of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise. The time stamp for this event is initialized by invoking &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt;&lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">caret 및 visiblePosition의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 내 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 이는 경우 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트는 내의 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 앞의 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 그렇지 않으면 이벤트입니다. 이 이벤트의 타임 스탬프는 &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt; &lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt; &lt;/a&gt; 을 호출하여 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e102309a5333ab2237cebc7d402fc7f4a95ad222" translate="yes" xml:space="preserve">
          <source>The old binding: information about the object before the change.</source>
          <target state="translated">기존 바인딩 : 변경 전 객체에 대한 정보</target>
        </trans-unit>
        <trans-unit id="d5f61ec25f174a0aa0e3e129763ffbe8890fd5d4" translate="yes" xml:space="preserve">
          <source>The old modifiers</source>
          <target state="translated">이전 수정 자</target>
        </trans-unit>
        <trans-unit id="d09e0e17113c933353bdc17d7b91ac2797ae7090" translate="yes" xml:space="preserve">
          <source>The old modifiers listed below also can be used, but they are mapped to _DOWN_ modifiers.</source>
          <target state="translated">아래에 나열된 이전 수정 자도 사용할 수 있지만 _DOWN_ 수정 자에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="eaa830de2cd1ee40ef0e64424b6658b54dfedf50" translate="yes" xml:space="preserve">
          <source>The old value for the property, expressed as an Object. May be null if multiple properties have changed.</source>
          <target state="translated">속성의 이전 값으로, Object로 표시됩니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8804e2adfeaa4e67e196991549e2b345ab8e8bf" translate="yes" xml:space="preserve">
          <source>The old/new binding in &lt;code&gt;NamingEvent&lt;/code&gt; may be null if the old name or new name is outside of the scope for which the listener has registered.</source>
          <target state="translated">이전 이름 ​​또는 새 이름이 리스너가 등록한 범위를 벗어나면 &lt;code&gt;NamingEvent&lt;/code&gt; 의 이전 / 새 바인딩 이 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="100741ba84acd0a7c97819d3b1fe9d00db066275" translate="yes" xml:space="preserve">
          <source>The one exception to this is a treeNodesChanged event that is to identify the root, in which case this will return the root and &lt;code&gt;getChildIndices&lt;/code&gt; will return null.</source>
          <target state="translated">이에 대한 한 가지 예외는 루트를 식별하는 treeNodesChanged 이벤트입니다.이 경우 루트 를 반환 하고 &lt;code&gt;getChildIndices&lt;/code&gt; 는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8fe09a5500bade693b5533a5b93beed8253b86c" translate="yes" xml:space="preserve">
          <source>The one variation from Java language access control is that the checks by reflected objects assume readability. That is, the module containing the use of a reflected object is assumed to read the module in which the underlying field, method, or constructor is declared.</source>
          <target state="translated">Java 언어 액세스 제어의 한 가지 변형은 반사 된 객체에 의한 검사가 가독성을 가정한다는 것입니다. 즉, 리플렉션 된 객체의 사용을 포함하는 모듈은 기본 필드, 메서드 또는 생성자가 선언 된 모듈을 읽는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3680a0d410cbf7c86a348b63caf1fd252cbc022a" translate="yes" xml:space="preserve">
          <source>The only characters in attribute values that are escaped are those which section 2.4 of RFC 2253 states must be escaped (they are escaped using a preceding backslash character)</source>
          <target state="translated">이스케이프되는 속성 값의 유일한 문자는 RFC 2253 상태의 2.4 섹션을 이스케이프해야하는 문자입니다 (앞의 백 슬래시 문자를 사용하여 이스케이프됩니다).</target>
        </trans-unit>
        <trans-unit id="295fb6b399f1423277a11d5a7f557688d118f6dd" translate="yes" xml:space="preserve">
          <source>The only dataTypes supported currently are TYPE_BYTE and TYPE_USHORT.</source>
          <target state="translated">현재 지원되는 유일한 데이터 유형은 TYPE_BYTE 및 TYPE_USHORT입니다.</target>
        </trans-unit>
        <trans-unit id="e7143ae9d93c0b9dfc0aad9a9d7d22c047ec7cdb" translate="yes" xml:space="preserve">
          <source>The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT, and TYPE_INT.</source>
          <target state="translated">현재 지원되는 유일한 데이터 유형은 TYPE_BYTE, TYPE_USHORT 및 TYPE_INT입니다.</target>
        </trans-unit>
        <trans-unit id="2e9ed2799ba6b886f681d8689a9cf0acba5d537b" translate="yes" xml:space="preserve">
          <source>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using &quot;&lt;code&gt;parallelStream()&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;stream()&lt;/code&gt;&quot;. The stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which the terminal operation is invoked. The sequential or parallel mode of a stream can be determined with the &lt;a href=&quot;basestream#isParallel()&quot;&gt;&lt;code&gt;BaseStream.isParallel()&lt;/code&gt;&lt;/a&gt; method, and the stream's mode can be modified with the &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basestream#parallel()&quot;&gt;&lt;code&gt;BaseStream.parallel()&lt;/code&gt;&lt;/a&gt; operations. The most recent sequential or parallel mode setting applies to the execution of the entire stream pipeline.</source>
          <target state="translated">이 예제의 직렬 버전과 병렬 버전의 유일한 차이점 은 &quot; &lt;code&gt;stream()&lt;/code&gt; &quot; 대신 &quot; &lt;code&gt;parallelStream()&lt;/code&gt; &quot;을 사용하여 초기 스트림을 생성 한다는 것입니다 . 스트림 파이프 라인은 터미널 작업이 호출되는 스트림의 모드에 따라 순차적으로 또는 병렬로 실행됩니다. 스트림의 순차 또는 병렬 모드는 &lt;a href=&quot;basestream#isParallel()&quot;&gt; &lt;code&gt;BaseStream.isParallel()&lt;/code&gt; &lt;/a&gt; 메서드 로 결정될 수 있으며 스트림의 모드는 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;basestream#parallel()&quot;&gt; &lt;code&gt;BaseStream.parallel()&lt;/code&gt; &lt;/a&gt; 작업 으로 수정할 수 있습니다 . 가장 최근의 순차 또는 병렬 모드 설정은 전체 스트림 파이프 라인의 실행에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c196d72932e1d175e571f345ae61f12d79c6347" translate="yes" xml:space="preserve">
          <source>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using &quot;&lt;code&gt;parallelStream()&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;stream()&lt;/code&gt;&quot;. When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the orientation of the stream on which it is invoked. Whether a stream will execute in serial or parallel can be determined with the &lt;code&gt;isParallel()&lt;/code&gt; method, and the orientation of a stream can be modified with the &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basestream#parallel--&quot;&gt;&lt;code&gt;BaseStream.parallel()&lt;/code&gt;&lt;/a&gt; operations. When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which it is invoked.</source>
          <target state="translated">이 예제의 직렬 버전과 병렬 버전의 유일한 차이점은 &quot; &lt;code&gt;parallelStream()&lt;/code&gt; 사용하여 초기 스트림을 만드는 것입니다. 은 &quot; &lt;code&gt;stream()&lt;/code&gt; &quot; 대신 &quot;을 . 터미널 작업이 시작되면 스트림 파이프 라인은 호출 된 스트림의 방향에 따라 순차적으로 또는 병렬로 실행됩니다. 직렬 또는 병렬로 스트림을 실행할지 여부는 &lt;code&gt;isParallel()&lt;/code&gt; 메서드로 확인할 수 있으며 &lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;basestream#parallel--&quot;&gt; &lt;code&gt;BaseStream.parallel()&lt;/code&gt; &lt;/a&gt; 작업 을 사용하여 스트림 방향을 수정할 수 있습니다 . 터미널 동작이 시작될 때, 스트림 파이프 라인은 그것이 호출되는 스트림의 모드에 따라 순차적으로 또는 병렬로 실행된다.</target>
        </trans-unit>
        <trans-unit id="30c57e209d37493c24bd2337628683ad099f2c41" translate="yes" xml:space="preserve">
          <source>The only features recognized are namespaces and namespace-prefixes.</source>
          <target state="translated">인식되는 유일한 기능은 네임 스페이스와 네임 스페이스 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="f349a38007f0fe5c739a24493c39f2bc7e05087f" translate="yes" xml:space="preserve">
          <source>The only possible modifiers for constructors are the access modifiers &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;. Only one of these may appear, or none if the constructor has default (package) access.</source>
          <target state="translated">생성자에 가능한 유일한 수정자는 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 액세스 수정 자 입니다. 이 중 하나만 표시되거나 생성자가 기본 (패키지) 액세스 권한을 가진 경우 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89b452c765bdde7f50f7ca76fd6cb50b91fd636" translate="yes" xml:space="preserve">
          <source>The opacity value is in the range [0..1]. Note that setting the opacity level of 0 may or may not disable the mouse event handling on this window. This is a platform-dependent behavior.</source>
          <target state="translated">불투명도 값은 [0..1] 범위에 있습니다. 불투명도 수준을 0으로 설정하면이 창에서 마우스 이벤트 처리가 비활성화되거나 비활성화되지 않을 수 있습니다. 이것은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="be1c279f5e78386178da2165b50da21200087330" translate="yes" xml:space="preserve">
          <source>The open package was implicitly declared in the source of the module declaration.</source>
          <target state="translated">오픈 패키지는 모듈 선언의 소스에서 암시 적으로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="bcc4bb5d73de91ce75aba43acec34215a0639c91" translate="yes" xml:space="preserve">
          <source>The open package was not explicitly or implicitly declared in the source of the module declaration.</source>
          <target state="translated">열린 패키지가 모듈 선언의 소스에서 명시 적으로 또는 암시 적으로 선언되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8ede533a4ed0afa29ef99e43a7a5d5449c703aa3" translate="yes" xml:space="preserve">
          <source>The operable part of the drop site for the &lt;code&gt;DropTarget&lt;/code&gt; is the part of the associated &lt;code&gt;Component&lt;/code&gt;'s geometry that is not obscured by an overlapping top-level window or by another &lt;code&gt;Component&lt;/code&gt; higher in the Z-order that has an associated active &lt;code&gt;DropTarget&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DropTarget&lt;/code&gt; 에 대한 드롭 사이트의 작동 가능한 부분은 겹치는 최상위 창이나 연결된 활성 &lt;code&gt;DropTarget&lt;/code&gt; 이있는 Z 순서에서 상위에있는 다른 &lt;code&gt;Component&lt;/code&gt; 의해 가려지지 않는 연결된 &lt;code&gt;Component&lt;/code&gt; 의 지오메트리 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="9b89a3f4960ca6976b23674244f345949cec31a1" translate="yes" xml:space="preserve">
          <source>The operand stack is restored, however, any changes to the arguments that occurred in the called method, remain. For example, if the method &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">피연산자 스택은 복원되지만 호출 된 메서드에서 발생한 인수의 변경 사항은 그대로 유지됩니다. 예를 들어, 메소드 &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="757cee3ea404c7279f0c6b75405f9e5d965d2914" translate="yes" xml:space="preserve">
          <source>The operating system program file was not found.</source>
          <target state="translated">운영 체제 프로그램 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="47390cdf3b88c3e58ad9e0ae77f10ad59aa1eaf6" translate="yes" xml:space="preserve">
          <source>The operation just closed this side of the &lt;code&gt;SSLEngine&lt;/code&gt;, or the operation could not be completed because it was already closed.</source>
          <target state="translated">작업이 &lt;code&gt;SSLEngine&lt;/code&gt; 의 이면을 닫았 거나 이미 닫혀서 작업을 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d716f5e6eb73ca33a6b17f0e7fa84479a8ab34c7" translate="yes" xml:space="preserve">
          <source>The operation of this method is slightly different to similar methods using &lt;code&gt;ParsePosition&lt;/code&gt; on &lt;code&gt;java.text.Format&lt;/code&gt;. That class will return errors using the error index on the &lt;code&gt;ParsePosition&lt;/code&gt;. By contrast, this method will throw a &lt;a href=&quot;datetimeparseexception&quot;&gt;&lt;code&gt;DateTimeParseException&lt;/code&gt;&lt;/a&gt; if an error occurs, with the exception containing the error index. This change in behavior is necessary due to the increased complexity of parsing and resolving dates/times in this API.</source>
          <target state="translated">이 메소드의 조작은 &lt;code&gt;java.text.Format&lt;/code&gt; 에서 &lt;code&gt;ParsePosition&lt;/code&gt; 을 사용하는 유사한 메소드와 약간 다릅니다. . 해당 클래스는 &lt;code&gt;ParsePosition&lt;/code&gt; 의 오류 인덱스를 사용하여 오류를 반환합니다 . 반대로,이 메서드는 오류 인덱스가 포함 된 예외를 제외하고 오류가 발생 하면 &lt;a href=&quot;datetimeparseexception&quot;&gt; &lt;code&gt;DateTimeParseException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다. 이 동작의 변경은이 API에서 구문 분석 및 날짜 / 시간의 복잡성이 증가함에 따라 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8c2dbe5cb88129c338520227f951d5d21bc3adc0" translate="yes" xml:space="preserve">
          <source>The operation proceeds as follows:</source>
          <target state="translated">작업은 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="6229974772e67797588385f119266fb6e2f20834" translate="yes" xml:space="preserve">
          <source>The operation to perform when this action is triggered.</source>
          <target state="translated">이 작업이 트리거 될 때 수행 할 작업입니다.</target>
        </trans-unit>
        <trans-unit id="385a016e839d895d961c9b7fc691a93ab6bd727c" translate="yes" xml:space="preserve">
          <source>The operation will be performed field by field with the precision of &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt;. Since all the fields except seconds are restricted to hold integers, any fraction produced by the computation will be carried down toward the next lower unit. For example, if you multiply &quot;P1D&quot; (1 day) with &quot;0.5&quot;, then it will be 0.5 day, which will be carried down to &quot;PT12H&quot; (12 hours). When fractions of month cannot be meaningfully carried down to days, or year to months, this will cause an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; to be thrown. For example if you multiple one month by 0.5.</source>
          <target state="translated">작업은 &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt; 정밀도로 필드별로 수행됩니다 . 초를 제외한 모든 필드는 정수를 보유하도록 제한되므로 계산에 의해 생성 된 모든 분수는 다음 하위 단위로 전달됩니다. 예를 들어 &quot;P1D&quot;(1 일)에 &quot;0.5&quot;를 곱하면 0.5 일이되고 &quot;PT12H&quot;(12 시간)로 이월됩니다. 월의 분수가 의미있게 일 또는 연 단위로 이월 될 수없는 경우 &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 예를 들어 한 달에 0.5를 곱한 경우.</target>
        </trans-unit>
        <trans-unit id="1e9b100e7d6bf71d9d81c5cf765dd6e9312adf7f" translate="yes" xml:space="preserve">
          <source>The optical photo conductor is near end of life.</source>
          <target state="translated">광학 포토 컨덕터의 수명이 거의 다되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc98736e760491006a9169783a49bc78538cc3ca" translate="yes" xml:space="preserve">
          <source>The optical photo conductor is no longer functioning.</source>
          <target state="translated">광학 포토 컨덕터가 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c62ce663f6e5bbb6451017676b19762e1fbf3161" translate="yes" xml:space="preserve">
          <source>The option must be set prior to entering a blocking operation to take effect. If the timeout expires and the operation would continue to block, &lt;b&gt;java.io.InterruptedIOException&lt;/b&gt; is raised. The Socket is not closed in this case.</source>
          <target state="translated">차단 작업을 시작하기 전에 옵션을 설정해야 적용됩니다. 시간 초과가 만료되고 작업이 계속 차단되면&lt;b&gt; java.io.InterruptedIOException&lt;/b&gt; 이 발생합니다. 이 경우 소켓이 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="780ff6733d087d7bf446709714c8ebb00a2cffdb" translate="yes" xml:space="preserve">
          <source>The optional build information is compared lexicographically. During this comparison, a version with optional build information is considered to be greater than a version without one.</source>
          <target state="translated">선택적 빌드 정보는 사전 식으로 비교됩니다. 이 비교 중에 선택적 빌드 정보가있는 버전은없는 버전보다 큰 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7d31088ebde33203706fda6d4531c19f262ae377" translate="yes" xml:space="preserve">
          <source>The optional build number.</source>
          <target state="translated">선택적 빌드 번호입니다.</target>
        </trans-unit>
        <trans-unit id="7fde895ca15e28398e2093122f9b0e89dd2c837e" translate="yes" xml:space="preserve">
          <source>The optional capacity bound constructor argument serves as a way to prevent excessive expansion. The capacity, if unspecified, is equal to &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity.</source>
          <target state="translated">선택적 용량 바운드 생성자 인수는 과도한 확장을 방지하는 방법으로 사용됩니다. 지정되지 않은 경우 용량은 &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 같습니다 .MAX_VALUE . 링크 노드는 용량을 초과하지 않는 한 각 삽입시 동적으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1b391ca196a239752a071899940b30e945c7e626" translate="yes" xml:space="preserve">
          <source>The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.</source>
          <target state="translated">선택적 용량 바운드 생성자 인수는 과도한 큐 확장을 방지하는 방법으로 사용됩니다. 지정되지 않은 경우 용량은 &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 같습니다 .MAX_VALUE . 큐가 용량을 초과하지 않는 한 링크 된 노드는 각 삽입시 동적으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="40329cb44fef466069a746e7e8616ce88f318acf" translate="yes" xml:space="preserve">
          <source>The optional interface implemented by ScriptEngines whose methods allow the invocation of procedures in scripts that have previously been executed.</source>
          <target state="translated">이전에 실행 된 스크립트에서 프로 시저를 호출 할 수있는 메소드를 가진 ScriptEngine에 의해 구현 된 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="af44167d5098cd1640942f676f56da64386bc769" translate="yes" xml:space="preserve">
          <source>The optional interface implemented by ScriptEngines whose methods compile scripts to a form that can be executed repeatedly without recompilation.</source>
          <target state="translated">스크립트 엔진이 다시 컴파일하지 않고 반복적으로 실행할 수있는 형식으로 스크립트를 컴파일하는 ScriptEngine에서 구현 한 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bc1b7b35aca1d8eeff15523a95ddf328b6c781ce" translate="yes" xml:space="preserve">
          <source>The optional module name is prefixed to the type name or package name and separated using a &quot;&lt;code&gt;/&lt;/code&gt;&quot; character. For example, to create a class file for type &lt;code&gt;a.B&lt;/code&gt; in module &lt;code&gt;foo&lt;/code&gt;, use a &lt;code&gt;name&lt;/code&gt; argument of &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt;.</source>
          <target state="translated">선택적 모듈 이름은 유형 이름 또는 패키지 이름 앞에 붙고 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자를 사용하여 구분됩니다 . 예를 들어, &lt;code&gt;foo&lt;/code&gt; 모듈에서 &lt;code&gt;a.B&lt;/code&gt; 유형에 대한 클래스 파일을 생성 하려면 &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7b05f568bb77158d95ed44eb1b1ee848f1cc15e" translate="yes" xml:space="preserve">
          <source>The optional module name is prefixed to the type name or package name and separated using a &quot;&lt;code&gt;/&lt;/code&gt;&quot; character. For example, to create a source file for type &lt;code&gt;a.B&lt;/code&gt; in module &lt;code&gt;foo&lt;/code&gt;, use a &lt;code&gt;name&lt;/code&gt; argument of &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt;.</source>
          <target state="translated">선택적 모듈 이름은 유형 이름 또는 패키지 이름 앞에 붙고 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자를 사용하여 구분됩니다 . 예를 들어, &lt;code&gt;foo&lt;/code&gt; 모듈에서 &lt;code&gt;a.B&lt;/code&gt; 유형에 대한 소스 파일을 만들려면 &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d5829c87f129903c32edbc130685e2ce1d68c681" translate="yes" xml:space="preserve">
          <source>The optional pre-release information as a String</source>
          <target state="translated">선택적 시험판 정보 (문자열)</target>
        </trans-unit>
        <trans-unit id="fc3f9d6f338a5687d0aaac4c1e2d14791c14a93e" translate="yes" xml:space="preserve">
          <source>The options objects should contain either instances of &lt;code&gt;Component&lt;/code&gt;s, (which are added directly) or &lt;code&gt;Strings&lt;/code&gt; (which are wrapped in a &lt;code&gt;JButton&lt;/code&gt;). If you provide &lt;code&gt;Component&lt;/code&gt;s, you must ensure that when the &lt;code&gt;Component&lt;/code&gt; is clicked it messages &lt;code&gt;setValue&lt;/code&gt; in the created &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">옵션 객체는 &lt;code&gt;Component&lt;/code&gt; 의 인스턴스 (직접 추가됨) 또는 &lt;code&gt;Strings&lt;/code&gt; ( &lt;code&gt;JButton&lt;/code&gt; 에 래핑 됨 ) 중 하나를 포함해야합니다 . &lt;code&gt;Component&lt;/code&gt; 를 제공 하는 경우 &lt;code&gt;Component&lt;/code&gt; 를 클릭하면 생성 된 &lt;code&gt;JOptionPane&lt;/code&gt; 에 &lt;code&gt;setValue&lt;/code&gt; 메시지가 표시 되는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d323759d66423b856604e1ca269cc6f1231f8e4" translate="yes" xml:space="preserve">
          <source>The order in which notifications will be delivered is unspecified. The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose.</source>
          <target state="translated">알림이 전달되는 순서는 지정되지 않았습니다. Observable 클래스에서 제공되는 기본 구현은 Observer에게 관심 등록 된 순서대로 통지하지만 서브 클래스는이 순서를 변경하거나 보장 된 순서를 사용하지 않으며 별도의 스레드에 알림을 전달하거나 서브 클래스가이 순서를 따르도록 보장 할 수 있습니다 고르다.</target>
        </trans-unit>
        <trans-unit id="6143ddfdc758405eea52fe688b165bfc50d049e2" translate="yes" xml:space="preserve">
          <source>The order in which the certificates are presented to the &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; may be either in the forward direction (from target to most-trusted CA) or in the reverse direction (from most-trusted CA to target). A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; implementation &lt;b&gt;must&lt;/b&gt; support reverse checking (the ability to perform its checks when it is presented with certificates in the reverse direction) and &lt;b&gt;may&lt;/b&gt; support forward checking (the ability to perform its checks when it is presented with certificates in the forward direction). The &lt;a href=&quot;#isForwardCheckingSupported()&quot;&gt;&lt;code&gt;isForwardCheckingSupported&lt;/code&gt;&lt;/a&gt; method indicates whether forward checking is supported.</source>
          <target state="translated">인증서가 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 에 제공되는 순서 는 순방향 (대상에서 가장 신뢰할 수있는 CA로) 또는 역방향 (가장 신뢰할 수있는 CA에서 대상으로) 일 수 있습니다. &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 구현 &lt;b&gt;한다&lt;/b&gt; (이 역방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 역방향 확인을 지원하고 &lt;b&gt;있다&lt;/b&gt; (이 순방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 검사 전방지지한다. &lt;a href=&quot;#isForwardCheckingSupported()&quot;&gt; &lt;code&gt;isForwardCheckingSupported&lt;/code&gt; &lt;/a&gt; 방법 방향의 체크가 지원되는지 여부를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="786679264f791da220873f1e88f2073a40d4300a" translate="yes" xml:space="preserve">
          <source>The order in which the certificates are presented to the &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; may be either in the forward direction (from target to most-trusted CA) or in the reverse direction (from most-trusted CA to target). A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; implementation &lt;b&gt;must&lt;/b&gt; support reverse checking (the ability to perform its checks when it is presented with certificates in the reverse direction) and &lt;b&gt;may&lt;/b&gt; support forward checking (the ability to perform its checks when it is presented with certificates in the forward direction). The &lt;a href=&quot;pkixcertpathchecker#isForwardCheckingSupported--&quot;&gt;&lt;code&gt;isForwardCheckingSupported&lt;/code&gt;&lt;/a&gt; method indicates whether forward checking is supported.</source>
          <target state="translated">인증서가 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 에 제공되는 순서 는 정방향 (대상에서 가장 신뢰할 수있는 CA로) 또는 역방향 (가장 신뢰할 수있는 CA에서 대상으로) 일 수 있습니다. &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 구현 &lt;b&gt;한다&lt;/b&gt; (이 역방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 역방향 확인을 지원하고 &lt;b&gt;있다&lt;/b&gt; (이 순방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 검사 전방지지한다. &lt;a href=&quot;pkixcertpathchecker#isForwardCheckingSupported--&quot;&gt; &lt;code&gt;isForwardCheckingSupported&lt;/code&gt; &lt;/a&gt; 방법 방향의 체크가 지원되는지 여부를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="d2f8d57b1d164c84e4b4ac092f45d02503e996db" translate="yes" xml:space="preserve">
          <source>The order of Catalogs in the returned stream is the same as the order in which the corresponding &lt;code&gt;nextCatalog&lt;/code&gt; entries appear in the current catalog. The alternative catalogs from the input file list are appended to the end of the stream in the order they are entered.</source>
          <target state="translated">리턴 된 스트림의 카탈로그 순서 는 현재 카탈로그에 해당 &lt;code&gt;nextCatalog&lt;/code&gt; 항목이 나타나는 순서와 동일 합니다. 입력 파일 목록의 대체 카탈로그는 입력 된 순서대로 스트림 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3b0a1444d580fbd23f88a9b291fb618ecf7e54" translate="yes" xml:space="preserve">
          <source>The order of MBeans in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt; is significant. For any two MBeans &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;, &lt;em&gt;X&lt;/em&gt; must appear before &lt;em&gt;Y&lt;/em&gt; if the registration of &lt;em&gt;X&lt;/em&gt; was completed before the registration of &lt;em&gt;Y&lt;/em&gt; started. If &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; were registered concurrently, their order is indeterminate. The registration of an MBean corresponds to the call to &lt;a href=&quot;../mbeanserver#registerMBean(java.lang.Object,javax.management.ObjectName)&quot;&gt;&lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt;&lt;/a&gt; or one of the &lt;a href=&quot;../mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.createMBean&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에서 MBean의 순서 는 중요합니다. 두 MBean의 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;Y&lt;/em&gt; 에서 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에 , &lt;em&gt;X는&lt;/em&gt; 이전에 나타나야 &lt;em&gt;Y&lt;/em&gt; 의 등록하면 &lt;em&gt;X가&lt;/em&gt; 의 등록 이전에 완료 &lt;em&gt;Y는&lt;/em&gt; 시작했다. &lt;em&gt;X&lt;/em&gt; 와 &lt;em&gt;Y&lt;/em&gt; 가 동시에 등록 된 경우 순서는 확정되지 않습니다. MBean 등록은 &lt;a href=&quot;../mbeanserver#registerMBean(java.lang.Object,javax.management.ObjectName)&quot;&gt; &lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.createMBean&lt;/code&gt; 메소드 중 하나에 대한 호출에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="3007914f7a4138270cf5fa55368f3ef46fd6ca3f" translate="yes" xml:space="preserve">
          <source>The order of MBeans in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt; is significant. For any two MBeans &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;, &lt;em&gt;X&lt;/em&gt; must appear before &lt;em&gt;Y&lt;/em&gt; if the registration of &lt;em&gt;X&lt;/em&gt; was completed before the registration of &lt;em&gt;Y&lt;/em&gt; started. If &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; were registered concurrently, their order is indeterminate. The registration of an MBean corresponds to the call to &lt;a href=&quot;../mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt;&lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt;&lt;/a&gt; or one of the &lt;a href=&quot;../mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.createMBean&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;ClassLoaderRepository&lt;/code&gt; 의 MBean 순서 는 중요합니다. 두 MBean의 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;Y&lt;/em&gt; 에서 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에 , &lt;em&gt;X는&lt;/em&gt; 이전에 나타나야 &lt;em&gt;Y&lt;/em&gt; 의 등록하면 &lt;em&gt;X가&lt;/em&gt; 의 등록 이전에 완료 &lt;em&gt;Y는&lt;/em&gt; 시작했다. &lt;em&gt;X&lt;/em&gt; 와 &lt;em&gt;Y&lt;/em&gt; 가 동시에 등록 된 경우 순서가 불확실합니다. MBean 등록은 &lt;a href=&quot;../mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt; &lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.createMBean&lt;/code&gt; 중 하나에 대한 호출에 해당합니다. 메소드 합니다.</target>
        </trans-unit>
        <trans-unit id="69b59e9b859e1a5e657654408c45f91692763d5e" translate="yes" xml:space="preserve">
          <source>The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. For predictable results, the accumulator function should be associative and commutative. The function is applied with an existing value (or identity) as one argument, and a given update as the other argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;
 Long::max&lt;/code&gt; along with &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; as the identity.</source>
          <target state="translated">스레드 내 또는 스레드 간의 누적 순서는 보장되지 않으며 의존 할 수 없으므로이 클래스는 누적 순서가 중요하지 않은 함수에만 적용됩니다. 제공된 누산기 함수는 스레드 간의 경합으로 인해 업데이트 시도가 실패 할 때 다시 적용될 수 있으므로 부작용이 없어야합니다. 예측 가능한 결과를 위해 누산기 함수는 연관 및 교환이어야합니다. 함수는 기존 값 (또는 ID)을 하나의 인수로 적용하고 주어진 업데이트를 다른 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하려면 &lt;code&gt; Long::max&lt;/code&gt; 와 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 를 ID로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6726bce2cabc5276351a481e6e10cf57a7fb4a23" translate="yes" xml:space="preserve">
          <source>The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Long::max&lt;/code&gt; along with &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; as the identity.</source>
          <target state="translated">스레드 내에서 또는 스레드 간 누적 순서는 보장되지 않으며 의존 할 수 없으므로이 클래스는 누적 순서가 중요하지 않은 함수에만 적용 할 수 있습니다. 제공된 누산기 기능은 부작용이 없어야합니다. 스레드 간의 경합으로 인해 업데이트 시도가 실패하면 다시 적용될 수 있습니다. 이 함수는 현재 값을 첫 번째 인수로, 지정된 업데이트를 두 번째 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하기 위해 &lt;code&gt;Long::max&lt;/code&gt; 와 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 를 제공 할 수 있습니다. ID로 있습니다.</target>
        </trans-unit>
        <trans-unit id="85066ede09274b9f9c61cffaf82980ac01b16326" translate="yes" xml:space="preserve">
          <source>The order of attributes in the list is unspecified, and will vary from implementation to implementation.</source>
          <target state="translated">목록의 속성 순서는 지정되지 않으며 구현마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ec494cb7fce413a23ae1b9813822d9a7c9181642" translate="yes" xml:space="preserve">
          <source>The order of elements in the list is the same as the order of the provided arguments, or of the elements in the provided array.</source>
          <target state="translated">목록의 요소 순서는 제공된 인수 또는 제공된 배열의 요소 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c8d2c884b5e85c4c029c8b772764cc9802c52974" translate="yes" xml:space="preserve">
          <source>The order of events in this interface is very important, and mirrors the order of information in the document itself. For example, all of an element's content (character data, processing instructions, and/or subelements) will appear, in order, between the startElement event and the corresponding endElement event.</source>
          <target state="translated">이 인터페이스의 이벤트 순서는 매우 중요하며 문서 자체의 정보 순서를 반영합니다. 예를 들어 모든 요소의 콘텐츠 (문자 데이터, 처리 명령 및 / 또는 하위 요소)는 startElement 이벤트와 해당 endElement 이벤트 사이에 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9ec7a44975564e560e5ebfd67d34b556640a1ec3" translate="yes" xml:space="preserve">
          <source>The order of the color indices is specified by the &lt;code&gt;ColorSpace&lt;/code&gt;. Typically, this reflects the name of the color space type (for example, TYPE_RGB), index 0 corresponds to red, index 1 to green, and index 2 to blue.</source>
          <target state="translated">색 인덱스의 순서는 &lt;code&gt;ColorSpace&lt;/code&gt; 에 의해 지정됩니다 . 일반적으로 이것은 색 공간 유형의 이름 (예 : TYPE_RGB)을 반영하고 인덱스 0은 빨간색, 인덱스 1은 녹색, 인덱스 2는 파란색에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e39109fa74536dbd205739a657a79c8c946a6365" translate="yes" xml:space="preserve">
          <source>The order of the list specifies the preference order of the client or server. An implementation should allow configuration of the meaning of these values. An application may use the Java Cryptography Extension (JCE) with JCE-aware mechanisms to control the selection of cipher suites that match the strength values.</source>
          <target state="translated">목록의 순서는 클라이언트 또는 서버의 기본 설정 순서를 지정합니다. 구현시 이러한 값의 의미를 구성 할 수 있어야합니다. 애플리케이션은 JCE 인식 메커니즘과 함께 JCE (Java Cryptography Extension)를 사용하여 강도 값과 일치하는 암호 스위트 선택을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7e2a675c70b61b722a61131dcca11cbc86fea1" translate="yes" xml:space="preserve">
          <source>The order of the list specifies the preference order of the client or server. If this property is absent, the default qop is &lt;code&gt;&quot;auth&quot;&lt;/code&gt;. The value of this constant is &lt;code&gt;&quot;javax.security.sasl.qop&quot;&lt;/code&gt;.</source>
          <target state="translated">목록의 순서는 클라이언트 또는 서버의 기본 설정 순서를 지정합니다. 이 특성이 없으면 기본 qop는 &lt;code&gt;&quot;auth&quot;&lt;/code&gt; 입니다. 이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.qop&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ea3d28b0369798168d59098f402bfbd2dc55933a" translate="yes" xml:space="preserve">
          <source>The order of the value descriptors specifies the index to use when setting event values.</source>
          <target state="translated">값 설명 자의 순서는 이벤트 값을 설정할 때 사용할 인덱스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f55568d5954bb088575a4a35d0388cb5151097fe" translate="yes" xml:space="preserve">
          <source>The order of transformation is described in &lt;a href=&quot;classfiletransformer&quot;&gt;&lt;code&gt;ClassFileTransformer&lt;/code&gt;&lt;/a&gt;. This same order is used in the automatic reapplication of retransformation incapable transforms.</source>
          <target state="translated">변환 순서는 &lt;a href=&quot;classfiletransformer&quot;&gt; &lt;code&gt;ClassFileTransformer&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다. 이 동일한 순서는 재 변환 불가능 변환의 자동 재 적용에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f586d409022fb2da015fb1af6296fa734a0d31fd" translate="yes" xml:space="preserve">
          <source>The order of transformation is described in the &lt;a href=&quot;classfiletransformer#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; method. This same order is used in the automatic reapplication of retransformation incapable transforms.</source>
          <target state="translated">변환 순서는 &lt;a href=&quot;classfiletransformer#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; 방법에 설명되어 있습니다. 동일한 순서가 재 변환 불가능 변환의 자동 재 적용에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b636074ef1a5a271212dd8309cd64648a786776" translate="yes" xml:space="preserve">
          <source>The order of views relative to the model is up to the implementation. Although child views will typically be arranged in the same order that they occur in the model, they may be visually arranged in an entirely different order. View implementations may have Z-Order associated with them if the children are overlapping.</source>
          <target state="translated">모델과 관련된 뷰의 순서는 구현에 달려 있습니다. 일반적으로 하위 뷰는 모델에서 발생하는 순서와 동일한 순서로 배열되지만 시각적으로 완전히 다른 순서로 배열 될 수 있습니다. 뷰 구현에는 자식이 겹치는 경우 Z-Order가 연결되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="218227e103dee75adf30e33cccee9cc838d6df1c" translate="yes" xml:space="preserve">
          <source>The ordering imposed by a comparator &lt;code&gt;c&lt;/code&gt; on a set of elements &lt;code&gt;S&lt;/code&gt; is said to be</source>
          <target state="translated">요소 집합 &lt;code&gt;S&lt;/code&gt; 에 비교기 &lt;code&gt;c&lt;/code&gt; 에 의해 부과 된 순서 는</target>
        </trans-unit>
        <trans-unit id="35ceedf75591c16657215454c74762f532506371" translate="yes" xml:space="preserve">
          <source>The ordering is based on the order that the class loader's &lt;code&gt;
   getResources&lt;/code&gt; method finds the service configuration files and within that, the order that the class names are listed in the file.</source>
          <target state="translated">순서는 클래스 로더의 &lt;code&gt; getResources&lt;/code&gt; 메소드가 서비스 구성 파일을 찾는 순서와 그 안에서 클래스 이름이 파일에 나열되는 순서를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="fa90a160007f418563c4b70e7a41641e8b8af99c" translate="yes" xml:space="preserve">
          <source>The ordering of URIs is defined as follows:</source>
          <target state="translated">URI의 순서는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="10e213727ab1efb66ce40fdac2f168fd5ab6e836" translate="yes" xml:space="preserve">
          <source>The ordering of cards is determined by the container's own internal ordering of its component objects. &lt;code&gt;CardLayout&lt;/code&gt; defines a set of methods that allow an application to flip through these cards sequentially, or to show a specified card. The &lt;a href=&quot;#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;addLayoutComponent(java.awt.Component, java.lang.Object)&lt;/code&gt;&lt;/a&gt; method can be used to associate a string identifier with a given card for fast random access.</source>
          <target state="translated">카드의 순서는 구성 요소 개체의 컨테이너 자체 내부 순서에 의해 결정됩니다. &lt;code&gt;CardLayout&lt;/code&gt; 은 애플리케이션이 이러한 카드를 순차적으로 넘기거나 지정된 카드를 표시 할 수 있도록하는 일련의 메서드를 정의합니다. &lt;a href=&quot;#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;addLayoutComponent(java.awt.Component, java.lang.Object)&lt;/code&gt; &lt;/a&gt; 방법은 빠른 랜덤 액세스에 대해 주어진 카드 문자열 식별자를 연결하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d740108fcacd8b33f949d001977d3ba5521ae114" translate="yes" xml:space="preserve">
          <source>The ordering of lock reacquisition for threads returning from waiting methods is the same as for threads initially acquiring the lock, which is in the default case not specified, but for &lt;em&gt;fair&lt;/em&gt; locks favors those threads that have been waiting the longest.</source>
          <target state="translated">대기 메소드에서 리턴하는 스레드에 대한 잠금 재 취득 순서는 기본적으로 지정되지 않은 초기 잠금을 획득하는 스레드의 순서와 동일하지만 &lt;em&gt;공정&lt;/em&gt; 잠금의 경우 가장 오래 기다린 스레드를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="ebe3338db3779264959a01c896fab9cc8151a384" translate="yes" xml:space="preserve">
          <source>The ordering of modules in a module layer is not defined.</source>
          <target state="translated">모듈 계층의 모듈 순서는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2d4dae6bc907437ac679c9f1928886b7eb910aa2" translate="yes" xml:space="preserve">
          <source>The ordering of side-effects may be surprising. Even when a pipeline is constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream source (for example, &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; must produce &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt;), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</source>
          <target state="translated">부작용의 순서는 놀랍습니다. 파이프 라인이 스트림 소스의 발생 순서와 일치 하는 &lt;em&gt;결과&lt;/em&gt; 를 생성하도록 제한되어있는 경우에도 (예 : &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; 는 &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt; )을 생성해야 하며, 매퍼 함수가 개별 요소에 적용되는 순서 또는 특정 요소에 대해 실행되는 동작 매개 변수가 어떤 스레드에서 실행되는지에 대해서는 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c351a0d0a5c5fd7fc6873693e09a2f6e8d0c8198" translate="yes" xml:space="preserve">
          <source>The ordering will be used by the &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">순서는 &lt;code&gt;useOrdering&lt;/code&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 일 때 &lt;code&gt;getServiceProviders&lt;/code&gt; 메소드에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c51946205bec8d4e4a34dc331905e41621242078" translate="yes" xml:space="preserve">
          <source>The ordinal index of the selected option, starting from 0.</source>
          <target state="translated">0부터 시작하는 선택한 옵션의 서수 색인입니다.</target>
        </trans-unit>
        <trans-unit id="8be3279dece3c485957eab1b710071124228e9b0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the selected option, starting from 0. The value -1 is returned if no element is selected. If multiple options are selected, the index of the first selected option is returned.</source>
          <target state="translated">0부터 시작하는 선택된 옵션의 서수 색인. 요소를 선택하지 않으면 값 -1이 리턴됩니다. 여러 옵션을 선택한 경우 처음 선택한 옵션의 색인이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="828902195e00ef436aff70e49094916ecb581eee" translate="yes" xml:space="preserve">
          <source>The orientations are:</source>
          <target state="translated">방향은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2fbbc68a36c3656118ddcba9b24016a519952e2" translate="yes" xml:space="preserve">
          <source>The origin and dimensions are the same.</source>
          <target state="translated">원점과 치수는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="81d54722d0f9366f127e5a540eef57cf4be51315" translate="yes" xml:space="preserve">
          <source>The origin is at the bottom left of the paper with x running bottom to top and y running left to right.</source>
          <target state="translated">원점은 용지의 왼쪽 하단에 있으며 x는 아래에서 위로, y는 왼쪽에서 오른쪽으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="34aadd941b0e6c46830a2cf7051a8e604ce18ba2" translate="yes" xml:space="preserve">
          <source>The origin is at the bottom left of the paper with x running bottom to top and y running left to right. Note that this is not the Macintosh landscape but is the Window's and PostScript landscape.</source>
          <target state="translated">원점은 용지의 왼쪽 하단에 있으며 x는 아래에서 위로, y는 왼쪽에서 오른쪽으로 이어집니다. 이것은 매킨토시 풍경이 아니라 윈도우와 포스트 스크립트 풍경입니다.</target>
        </trans-unit>
        <trans-unit id="c72397f47fc72fd8faede6be39606ce7c37d8165" translate="yes" xml:space="preserve">
          <source>The origin is at the top left of the paper with x running to the right and y running down the paper.</source>
          <target state="translated">원점은 용지의 왼쪽 상단에 있으며 x는 오른쪽으로, y는 용지 아래로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="eb105468c81962a0b3b369302414b0041b7e6d52" translate="yes" xml:space="preserve">
          <source>The origin is at the top right of the paper with x running top to bottom and y running right to left.</source>
          <target state="translated">원점은 용지의 오른쪽 상단에 있으며 x는 위에서 아래로, y는 오른쪽에서 왼쪽으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="b915e1ffee25bb4cdc2df24182c61b8d2216ac89" translate="yes" xml:space="preserve">
          <source>The origin is at the top right of the paper with x running top to bottom and y running right to left. Note that this is the Macintosh landscape.</source>
          <target state="translated">원점은 용지의 오른쪽 상단에 있으며 x는 위에서 아래로, y는 오른쪽에서 왼쪽으로 이어집니다. 이것은 매킨토시 풍경입니다.</target>
        </trans-unit>
        <trans-unit id="e8ca3c4aef86396c5b74dd72923a67612e1f1e7b" translate="yes" xml:space="preserve">
          <source>The origin of the graphics context, its (&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;) coordinate point, is the top-left corner of this component. The clipping region of the graphics context is the bounding rectangle of this component.</source>
          <target state="translated">그래픽 컨텍스트의 원점 인 ( &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; ) 좌표 점은이 구성 요소의 왼쪽 상단 모서리입니다. 그래픽 컨텍스트의 클리핑 영역은이 구성 요소의 경계 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="e0ce8e8ef1bf8c243508ecd5bf030b1224183b7e" translate="yes" xml:space="preserve">
          <source>The origin point.</source>
          <target state="translated">원점.</target>
        </trans-unit>
        <trans-unit id="0a55863e7f795e02d36c068a0988bdb81b7439eb" translate="yes" xml:space="preserve">
          <source>The original Java type of this element as it appeared in the &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt; interface method that produced this &lt;code&gt;
 MBeanAttributeInfo&lt;/code&gt; (etc). For example, a method</source>
          <target state="translated">이 &lt;code&gt; MBeanAttributeInfo&lt;/code&gt; (etc) 를 생성 한 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 인터페이스 메소드에 나타난이 요소의 원래 Java 유형 . 예를 들어, 방법</target>
        </trans-unit>
        <trans-unit id="03642eebd1c6e8a163c4a73ff3af624d3fa4e141" translate="yes" xml:space="preserve">
          <source>The original Java type of this element as it appeared in the &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt; interface method that produced this &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; (etc). For example, a method</source>
          <target state="translated">이 &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; 를 생성 한 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 인터페이스 메소드에 나타난이 요소의 원래 Java 유형 등 . 예를 들어, 방법</target>
        </trans-unit>
        <trans-unit id="97dc8d04e670ae6bfa1055787149df83a7f92ead" translate="yes" xml:space="preserve">
          <source>The original ZIP file. May be null.</source>
          <target state="translated">원본 ZIP 파일. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb59fbab3a9585984429676a1e7522c7316fa111" translate="yes" xml:space="preserve">
          <source>The original diagnostic command name (not the operation name)</source>
          <target state="translated">원래 진단 명령 이름 (작업 이름 아님)</target>
        </trans-unit>
        <trans-unit id="1bb7eb8c45dbc81d8fd70bf5884b22ccd1f62cb9" translate="yes" xml:space="preserve">
          <source>The original object that was sealed can be recovered in two different ways:</source>
          <target state="translated">봉인 된 원본 개체는 두 가지 방법으로 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b954e893a1f95170dfb211c586d111b9c39c9144" translate="yes" xml:space="preserve">
          <source>The original raw name.</source>
          <target state="translated">원래의 원시 이름.</target>
        </trans-unit>
        <trans-unit id="1e848f08eb459ca9bd9f3d3751f204b11ef04d87" translate="yes" xml:space="preserve">
          <source>The original value for a &lt;code&gt;RowSet&lt;/code&gt; object is the value it had before the last synchronization with the underlying data source. If there have been no synchronizations, the original value will be the value with which the &lt;code&gt;RowSet&lt;/code&gt; object was populated. This method is called internally when an application calls the method &lt;code&gt;acceptChanges&lt;/code&gt; and the &lt;code&gt;SyncProvider&lt;/code&gt; object has been implemented to check for conflicts. If this is the case, the writer compares the original value with the value currently in the data source to check for conflicts.</source>
          <target state="translated">&lt;code&gt;RowSet&lt;/code&gt; 개체 의 원래 값 은 기본 데이터 소스와의 마지막 동기화 이전에 있었던 값입니다. 동기화가없는 경우 원래 값은 &lt;code&gt;RowSet&lt;/code&gt; 개체가 채워진 값이됩니다 . 이 메서드는 응용 프로그램이 &lt;code&gt;acceptChanges&lt;/code&gt; 메서드를 호출 하고 &lt;code&gt;SyncProvider&lt;/code&gt; 개체가 충돌을 확인하기 위해 구현 된 경우 내부적으로 호출 됩니다. 이 경우 작성기는 원래 값을 현재 데이터 소스에있는 값과 비교하여 충돌을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bd50ee8db6416b8715b2e6cbee3cc76bfde62e5b" translate="yes" xml:space="preserve">
          <source>The original version.</source>
          <target state="translated">원래 버전.</target>
        </trans-unit>
        <trans-unit id="506f78a81958986cbe8e40931c749b16889f1e47" translate="yes" xml:space="preserve">
          <source>The original version. The language described in</source>
          <target state="translated">원본 버전. 에 설명 된 언어</target>
        </trans-unit>
        <trans-unit id="9d75d36090eb242306d69c88b761090a66976467" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치 방법에 따라 작동합니다 . 이 경우 오프셋은 계산의 일부가 아니므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e747f59a3b61038baf891aa64aa8fe5a1fd4ec43" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. The zone is not part of the calculation and will be unchanged. When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치 방법에 따라 작동합니다 . 영역은 계산의 일부가 아니며 변경되지 않습니다. &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환 할 때 로컬 날짜-시간이 겹치는 경우 오프셋은 가능하면 유지되고 그렇지 않으면 이전 오프셋이 사용됩니다. 간격이있는 경우 로컬 날짜-시간은 간격의 길이만큼 앞으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="3bcf7353bed6c5b27e8d630d4c511ddeea17f3d5" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; LocalTime}. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; LocalTime} 의 일치 방법에 따라 작동합니다 . 이 경우 오프셋은 계산의 일부가 아니므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b3f2a40bb0908a20b25677701f7f3b90d224d0" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치하는 메소드에 따라 작동합니다 . 이 경우 오프셋은 계산에 포함되지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68ee463661f375d777c74d840458ef8c9dd98143" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; LocalTime}. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; LocalTime} 에서 일치하는 방법에 따라 동작합니다 . 이 경우 오프셋은 계산에 포함되지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="485d2eb713590b6bb807248ee4372d5241f39e32" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. The zone is not part of the calculation and will be unchanged. When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치하는 메소드에 따라 작동합니다 . 영역은 계산의 일부가 아니며 변경되지 않습니다. &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환 할 때 로컬 날짜-시간이 겹치는 경우 가능한 경우 오프셋이 유지되고, 그렇지 않으면 이전 오프셋이 사용됩니다. 간격이 있으면 현지 날짜-시간이 간격의 길이만큼 앞으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="731e6c57f9e5ae4ccf59a456cb37bb4538303681" translate="yes" xml:space="preserve">
          <source>The other approach initializes a parameter generator object using algorithm-specific semantics, which are represented by a set of algorithm-specific parameter generation values. To generate Diffie-Hellman system parameters, for example, the parameter generation values usually consist of the size of the prime modulus and the size of the random exponent, both specified in number of bits.</source>
          <target state="translated">다른 접근 방식은 알고리즘 별 시맨틱을 사용하여 매개 변수 생성기 객체를 초기화하며, 이는 알고리즘 별 매개 변수 생성 값 세트로 표시됩니다. 예를 들어, Diffie-Hellman 시스템 매개 변수를 생성하기 위해 매개 변수 생성 값은 일반적으로 비트 수로 지정된 소수 지수와 랜덤 지수의 크기로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="55d2cad5bd07439d3de3adc5deca101f2c106f10" translate="yes" xml:space="preserve">
          <source>The other syntaxes defined by RFC 2609 are not currently supported by this class.</source>
          <target state="translated">RFC 2609에 의해 정의 된 다른 구문은 현재이 클래스에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4fd3d8cfa50630b0e53099a212e26fef3d644784" translate="yes" xml:space="preserve">
          <source>The other techniques all use the following approach: if the &lt;code&gt;java.rmi.server.ignoreStubClasses&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt; (case insensitive) or if a static stub cannot be found, stubs are generated dynamically using &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; objects. Otherwise, static stubs are used.</source>
          <target state="translated">다른 기술은 모두 다음 접근 방식을 사용합니다. &lt;code&gt;java.rmi.server.ignoreStubClasses&lt;/code&gt; 속성이 &lt;code&gt;true&lt;/code&gt; (대소 문자 구분 안 함)이거나 정적 스텁을 찾을 수없는 경우 &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 개체를 사용하여 스텁이 동적으로 생성 됩니다. 그렇지 않으면 정적 스텁이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f670b4981f0a114b5c79dad80bac9bc5c125b90" translate="yes" xml:space="preserve">
          <source>The other type of pairs consists of those that create Java language Bindings, the values are usually represented in scripts by the corresponding keys or by decorated forms of them.</source>
          <target state="translated">다른 유형의 쌍은 Java 언어 바인딩을 작성하는 쌍으로 구성되며, 값은 일반적으로 해당 키 또는 장식 된 형식으로 스크립트에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57d3406bf2a697594830c4ab80c8c1b86765dcee" translate="yes" xml:space="preserve">
          <source>The other version of the &lt;code&gt;acceptChanges&lt;/code&gt; method is not passed a connection because it uses the &lt;code&gt;Connection&lt;/code&gt; object already defined within the &lt;code&gt;RowSet&lt;/code&gt; object, which is the connection used for populating it initially.</source>
          <target state="translated">&lt;code&gt;acceptChanges&lt;/code&gt; 메소드 의 다른 버전은 처음에이를 채우는 데 사용되는 연결 인 &lt;code&gt;RowSet&lt;/code&gt; 오브젝트 내에 이미 정의 된 &lt;code&gt;Connection&lt;/code&gt; 오브젝트를 사용하기 때문에 연결이 전달되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5b004cd696742da98b715116f439633a968fa96c" translate="yes" xml:space="preserve">
          <source>The other way to create a thread is to declare a class that implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can then be allocated, passed as an argument when creating &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other style looks like the following:</source>
          <target state="translated">스레드를 작성하는 다른 방법은 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스 를 구현하는 클래스를 선언하는 것 입니다. 그런 다음 해당 클래스는 &lt;code&gt;run&lt;/code&gt; 을 구현합니다. 메소드 . 그런 다음 클래스의 인스턴스를 할당하고 &lt;code&gt;Thread&lt;/code&gt; 를 만들 때 인수로 전달한 다음 시작할 수 있습니다. 이 다른 스타일의 동일한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="583eff28c5b619ca29d9ec50a582a7ac4826c09b" translate="yes" xml:space="preserve">
          <source>The outer range is &lt;code&gt;minimum,maximum&lt;/code&gt; and the inner range is &lt;code&gt;value,value+extent&lt;/code&gt;. The inner range must lie within the outer one, i.e. &lt;code&gt;value&lt;/code&gt; must be less than or equal to &lt;code&gt;maximum&lt;/code&gt; and &lt;code&gt;value+extent&lt;/code&gt; must greater than or equal to &lt;code&gt;minimum&lt;/code&gt;, and &lt;code&gt;maximum&lt;/code&gt; must be greater than or equal to &lt;code&gt;minimum&lt;/code&gt;. There are a few features of this model that one might find a little surprising. These quirks exist for the convenience of the Swing BoundedRangeModel clients, such as &lt;code&gt;Slider&lt;/code&gt; and &lt;code&gt;ScrollBar&lt;/code&gt;.</source>
          <target state="translated">외부 범위는 &lt;code&gt;minimum,maximum&lt;/code&gt; 이고 내부 범위는 &lt;code&gt;value,value+extent&lt;/code&gt; 입니다. 외측 하나에 내부 범위 필수 거짓말 즉 &lt;code&gt;value&lt;/code&gt; 미만이거나 동일해야 &lt;code&gt;maximum&lt;/code&gt; 및 &lt;code&gt;value+extent&lt;/code&gt; 보다 반드시 더 크거나 같은 &lt;code&gt;minimum&lt;/code&gt; 및 &lt;code&gt;maximum&lt;/code&gt; 보다 크거나 동일해야 &lt;code&gt;minimum&lt;/code&gt; . 이 모델에는 약간 놀라운 점이 몇 가지 있습니다. 이러한 단점은 &lt;code&gt;Slider&lt;/code&gt; 및 &lt;code&gt;ScrollBar&lt;/code&gt; 와 같은 Swing BoundedRangeModel 클라이언트의 편의를 위해 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="681df9280815be16ce85cad82cd9590490576412" translate="yes" xml:space="preserve">
          <source>The outgoing message info</source>
          <target state="translated">발신 메시지 정보</target>
        </trans-unit>
        <trans-unit id="f2bff297e85d996a4c78e24eb08ae10d924ada6b" translate="yes" xml:space="preserve">
          <source>The outline of the &lt;code&gt;Shape&lt;/code&gt; is extracted using the &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform)&quot;&gt;&lt;code&gt;getPathIterator&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Shape&lt;/code&gt;, which returns a &lt;a href=&quot;geom/pathiterator&quot;&gt;&lt;code&gt;PathIterator&lt;/code&gt;&lt;/a&gt; object that iterates along the boundary of the &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">의 윤곽 &lt;code&gt;Shape&lt;/code&gt; 은 USING 추출 &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform)&quot;&gt; &lt;code&gt;getPathIterator&lt;/code&gt; 의&lt;/a&gt; 방법 &lt;code&gt;Shape&lt;/code&gt; 반환 &lt;a href=&quot;geom/pathiterator&quot;&gt; &lt;code&gt;PathIterator&lt;/code&gt; &lt;/a&gt; 오브젝트를 그 경계를 따라 반복 &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c8adc64c31daab6de1a7235e69f69308c772876" translate="yes" xml:space="preserve">
          <source>The output IO stream is buffered, but is flushed after each &lt;code&gt;LogRecord&lt;/code&gt; is written.</source>
          <target state="translated">출력 IO 스트림은 버퍼링되지만 각각 후에 플러시됩니다. &lt;code&gt;LogRecord&lt;/code&gt; 가 작성된 됩니다.</target>
        </trans-unit>
        <trans-unit id="26459ea2edbcfd100c25cd1785eb8ab10711495d" translate="yes" xml:space="preserve">
          <source>The output device is marking media.</source>
          <target state="translated">출력 장치가 미디어를 표시하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eca022c3bb2070b54c1b4b8f2c8671145a20cab" translate="yes" xml:space="preserve">
          <source>The output device is marking media. This value is useful for printers which spend a great deal of time processing (1) when no marking is happening and then want to show that marking is now happening or (2) when the job is in the process of being canceled or aborted while the job remains in the &lt;code&gt;PROCESSING&lt;/code&gt; state, but the marking has not yet stopped so that impression or sheet counts are still increasing for the job.</source>
          <target state="translated">출력 장치가 미디어를 표시하고 있습니다. 이 값은 처리하는 데 많은 시간을 소비하는 프린터에 유용합니다. 작업은 &lt;code&gt;PROCESSING&lt;/code&gt; 상태로 유지 되지만 마킹이 아직 중지되지 않았으므로 작업에 대한 임프레션 또는 시트 수가 계속 증가합니다.</target>
        </trans-unit>
        <trans-unit id="84e58d292a5274ac7143c456712868ef9a668dc0" translate="yes" xml:space="preserve">
          <source>The output device is marking media. This value is useful for printers which spend a great deal of time processing (1) when no marking is happening and then want to show that marking is now happening or (2) when the job is in the process of being canceled or aborted while the job remains in the PROCESSING state, but the marking has not yet stopped so that impression or sheet counts are still increasing for the job.</source>
          <target state="translated">출력 장치가 미디어를 표시하고 있습니다. 이 값은 (1) 마킹이 발생하지 않았을 때 마킹이 진행 중이거나 (2) 작업이 취소 또는 중단되는 중일 때 표시하는 데 많은 시간을 소비하는 프린터에 유용합니다. 작업이 처리 중 상태로 유지되지만 표시가 아직 중지되지 않아 작업에 대한 인상 또는 시트 수가 계속 증가합니다.</target>
        </trans-unit>
        <trans-unit id="688afe174c47eb9329383daa0efbfa513f94d552" translate="yes" xml:space="preserve">
          <source>The output is right-justified within the &lt;code&gt;width&lt;/code&gt;</source>
          <target state="translated">출력은 &lt;code&gt;width&lt;/code&gt; 내에서 오른쪽으로 정렬됩니다</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="804ab937140ab8aceea397468da48794c9e5c156" translate="yes" xml:space="preserve">
          <source>The output must have been set beforehand using either the &lt;code&gt;setOutput&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;setOutput&lt;/code&gt; 메소드를 사용하여 출력을 미리 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5834d251964586e73d7e57cd4080802c92b44a58" translate="yes" xml:space="preserve">
          <source>The output must have been set beforehand using the &lt;code&gt;setOutput&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;setOutput&lt;/code&gt; 메소드를 사용하여 출력을 미리 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f7bcdd198ccdce248e7f31e3c4dc8fb9ab43140" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling &lt;a href=&quot;#optionalStart()&quot;&gt;&lt;code&gt;optionalStart()&lt;/code&gt;&lt;/a&gt; and ended using this method (or at the end of the builder).</source>
          <target state="translated">서식 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은 &lt;a href=&quot;#optionalStart()&quot;&gt; &lt;code&gt;optionalStart()&lt;/code&gt; &lt;/a&gt; 를 호출하여 시작 되고이 메소드를 사용하여 종료됩니다 (또는 빌더의 끝에서).</target>
        </trans-unit>
        <trans-unit id="0c137f9ad4568084e0eada82e7dc19a7e9d63517" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt;&lt;code&gt;optionalStart()&lt;/code&gt;&lt;/a&gt; and ended using this method (or at the end of the builder).</source>
          <target state="translated">서식의 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은 &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt; &lt;code&gt;optionalStart()&lt;/code&gt; &lt;/a&gt; 를 호출하여 시작 되고이 메소드 (또는 빌더의 끝)를 사용하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="30bee059122c0e2413c350a5135e567ef038d6df" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling this method and ended by calling &lt;a href=&quot;#optionalEnd()&quot;&gt;&lt;code&gt;optionalEnd()&lt;/code&gt;&lt;/a&gt; or by ending the build process.</source>
          <target state="translated">서식 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은이 메서드를 호출하여 시작되고 &lt;a href=&quot;#optionalEnd()&quot;&gt; &lt;code&gt;optionalEnd()&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 빌드 프로세스를 종료하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4ace7699a2d9bc0b73e1579908c8e14ceff6a861" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling this method and ended by calling &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt;&lt;code&gt;optionalEnd()&lt;/code&gt;&lt;/a&gt; or by ending the build process.</source>
          <target state="translated">서식의 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은이 메소드를 호출하여 시작하고 &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt; &lt;code&gt;optionalEnd()&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 빌드 프로세스를 종료하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b15ced407c23c236dd27a5b8940ab033961526" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a custom mapped user-defined type (UDT) back to the database. The driver uses this interface internally, and its methods are never directly invoked by an application programmer.</source>
          <target state="translated">사용자 지정 매핑 된 사용자 정의 형식 (UDT)의 특성을 다시 데이터베이스에 쓰기위한 출력 스트림입니다. 드라이버는이 인터페이스를 내부적으로 사용하며 해당 메서드는 응용 프로그램 프로그래머가 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2644bde300cd9bee2aafe476022bed0d8f7f809" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a custom-mapped user-defined type (UDT) back to the database.</source>
          <target state="translated">사용자 지정 매핑 된 UDT (사용자 정의 형식)의 특성을 다시 데이터베이스에 쓰기위한 출력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="5291fc4ff823e118140880807207e4a84cdb270e" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a custom-mapped user-defined type (UDT) back to the database. The driver uses this interface internally, and its methods are never directly invoked by an application programmer.</source>
          <target state="translated">사용자 지정 매핑 된 UDT (사용자 정의 형식)의 특성을 다시 데이터베이스에 쓰기위한 출력 스트림입니다. 드라이버는이 인터페이스를 내부적으로 사용하며 해당 메서드는 응용 프로그램 프로그래머가 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c5cc4efa6ae535ea715a0ada32fc5dd1b98a681" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a user-defined type back to the database.</source>
          <target state="translated">사용자 정의 유형의 속성을 데이터베이스에 다시 쓰기위한 출력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="bf44ebf553c6d8e04b4e02abdc3300d8ca5d0e43" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a user-defined type back to the database. This interface, used only for custom mapping, is used by the driver, and its methods are never directly invoked by a programmer.</source>
          <target state="translated">사용자 정의 유형의 속성을 데이터베이스에 다시 쓰기위한 출력 스트림입니다. 사용자 지정 매핑에만 사용되는이 인터페이스는 드라이버에서 사용되며 해당 메서드는 프로그래머가 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c86979c68dfa75a5ea8a4fa4ebc1ad3a84cf42c6" translate="yes" xml:space="preserve">
          <source>The output will be in the ISO-8601 format &lt;code&gt;uuuu-MM-dd&lt;/code&gt;.</source>
          <target state="translated">출력은 ISO-8601 형식 &lt;code&gt;uuuu-MM-dd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b633ef40153b0f7e5fd9c57a4eaf98a09ebc8bd" translate="yes" xml:space="preserve">
          <source>The output will be in the ISO-8601 period format. A zero period will be represented as zero days, 'P0D'.</source>
          <target state="translated">출력은 ISO-8601 기간 형식입니다. 0 기간은 0 일 'P0D'로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="68588c3b93830eb7b05eaa2a32bd88e2e6401d4a" translate="yes" xml:space="preserve">
          <source>The output will be in the format &lt;code&gt;--MM-dd&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;--MM-dd&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="bdf3023f62cba73bbd1a514729bd330ebd38319c" translate="yes" xml:space="preserve">
          <source>The output will be in the format &lt;code&gt;uuuu-MM&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;uuuu-MM&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="dd014c7d6b437b473d734099818c5531d372f334" translate="yes" xml:space="preserve">
          <source>The output will be one of the following ISO-8601 formats:</source>
          <target state="translated">출력은 다음 ISO-8601 형식 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="705acc7715ef6cf8f5d79566a8f63147ba3837f5" translate="yes" xml:space="preserve">
          <source>The output will include the full local date-time.</source>
          <target state="translated">출력에는 전체 현지 날짜-시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2e50f340847768af08514b08ccbbc3cfbeecb6" translate="yes" xml:space="preserve">
          <source>The output will include the full local date.</source>
          <target state="translated">출력에는 전체 현지 날짜가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="569b52322e6eb839ec665dce679a13d3f5ed0afe" translate="yes" xml:space="preserve">
          <source>The output will include the full zoned date-time.</source>
          <target state="translated">출력에는 전체 영역 날짜-시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc58e9e7951c47f5031287fcfab530275c088ee0" translate="yes" xml:space="preserve">
          <source>The output will include the period amounts and chronology.</source>
          <target state="translated">출력에는 기간과 연대기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="234157b711ff9b8171f42b7b203bce27d2d2b18a" translate="yes" xml:space="preserve">
          <source>The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fileCount&lt;/code&gt; 에 다른 값을 가진 출력 :</target>
        </trans-unit>
        <trans-unit id="e695466f61d86736de0f15cfe8d369fc29207abf" translate="yes" xml:space="preserve">
          <source>The outside border.</source>
          <target state="translated">바깥 쪽 경계.</target>
        </trans-unit>
        <trans-unit id="7efda311ebc629dc550cc733ff5c1932095ad7e5" translate="yes" xml:space="preserve">
          <source>The oval covers an area that is &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels wide and &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels tall.</source>
          <target state="translated">타원은 &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 너비 및 &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 높이 의 영역을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="a40c1fc8cccf601ed7cf89f2562ee058faba7bf0" translate="yes" xml:space="preserve">
          <source>The overall authentication succeeds only if all</source>
          <target state="translated">전체 인증은 모든 경우에만 성공</target>
        </trans-unit>
        <trans-unit id="afc837de431bba096268be7bd23f007fce85a68b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars(int)&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;#append(char%5B%5D)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 정확히 인수가 &lt;a href=&quot;character#toChars(int)&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 되고 해당 배열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(char%5B%5D)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f59ea59df05be113fd52c10e956f63fb5a862338" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars-int-&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;stringbuffer#append-char:A-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;character#toChars-int-&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 인수를 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 한 다음 해당 배열의 문자 를이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-char:A-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be6d5695ee207edc76227a4e67c6ab0ba325ae3c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars-int-&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;stringbuilder#append-char:A-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;character#toChars-int-&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 인수를 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 한 다음 해당 배열의 문자 를이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-char:A-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63d704d3e8a8db51d045134a1bf4500866ab995c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c418496e1ac731b49fd8cb836ebff68932a9ef" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a3d22124f42c4fcc9202445b436eaf6b2b6492d0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="79d6f9eea850114d7a9b202fc0b8b89d51b84cf8" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c9906a666b00f6a09e068c9e5c534ed752c25f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char)&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(char)&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같고 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b406a14172d286cf69abb34f348310597e5b2f0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="19c75e21f2598dc94c7d1497d11bff7a1f046139" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae21a031715b312101629e3479ceb9126981d40" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 그 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="4ae62dc7765790bf27db11bfb64a8630bd77f4bb" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="57ade25be47848fe9b0e40fbb734bc54e132b32e" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 그 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="648556c8e68f153f15818f90033112d47cf3b47d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="310cb9a994c29cdc77dae7305d38d1b15d9afe1f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(float)&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(float)&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1d6aa9e36873bbad4c0d33292b2e0cafa71c5e92" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(int)&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(int)&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8cae7457cdd163d073210668c444483abb9018f0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="46b4af2589cb8859e8c23006e8d86372909b6580" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e107f2f3b6c5daae645f36d7c1aef0539272701e" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(long)&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(long)&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="57cba855e92025ba54d5320f086b0dbf8cfec25b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7df0f951a6156117783dfb422bf5ed58fb06623" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="845b434e13a8aaf2c9d866bceb0cd542c9f36bae" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07f151c65ac0110f86fef11dd3f3f19d05c7cbc5" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4fdc466e4bb623ea414c11f74ab2ab2710302ca" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="157765951de65cc003ce1491b4ef26e8c342399d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c95847b7e89b7021cc6b64b5b06284de479600b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e4e8c68ad219b2ca4384b64637aee75cfb33a09" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="047be1cada456ef70fd59c3ee3f044b4b3346662" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5533d40c6ced212dd75bac0fd6a34c6fac9422b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55f999bd369940307c24bebb765ca5b872fb76b7" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b879652398b41d309d1476f2c2e969058129bf6" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27d2cb16c3fe6c766ce861a61273f35f95a4220f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f3315b830429e7a9bc3e205fa95bae92504588c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5885c63fcfaae322b7ea095a9fac9b6f29e099cc" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7336e95827ca7bca837791a580e9cd1b62d7c706" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e1c324e343a3702507d78ac2247b82a2b6c6bd4" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D,int,int)&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(char%5B%5D,int,int)&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환되고 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="a84a40cce8885c87e5333813410de7216e2a669b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D,int,int)&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(char%5B%5D,int,int)&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;appendable#append(java.lang.CharSequence)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="6f590370647a03195ad36ca13c3dafc9d17830de" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="667446b3ce7a38fb13fed317aa887df961ff9edc" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="2c9fa9ac27b9581edc1bbe2ca820bbe9560c4ae9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3431e2061cfa7271649a78b90242cab86e4bea3" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="716fe619a79cc3f3409b762c7f20428af3b07c46" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 마치 두 번째 인수가 &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9046f217f1dadf54f1e0afa4a10e802011cf9b14" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c3a3f0eefdc6cd0623ccb4427387514024d89d5" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char)&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(char)&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="d7b361b4885492c0840c3b0b07aed1652fb821c9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a397fdc01f4a35195fc8f993ab704964197f4af" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c70945df54158f189337be144bc0908fcb472348" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="78752bca97244ec67e6ffcc0d5be846b93eee961" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="0344a438f1f77d2d0b3423fdd01a5320939d98e5" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="038665001103d37a0d8c60d862e1f0fb47f8a2f0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="56b66fbd5988862f4b6fb8d4aa435376a0f89711" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(float)&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(float)&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="245c9230d35217221e075ed545abf2fbc8278dc0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(int)&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(int)&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7fab1f7ef32442fb3c1aec6dae00f743da5819c7" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 마치 두 번째 인수가 &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.CharSequence)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a313be5db64537c2a2628855eb4e85e00683feb9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="59d643a3df0c9b21da2bb822cd6057390f54e373" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(long)&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(long)&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e3ad882f1370e6a19c92030d372ebea043ac08c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7af047a811aea03c7cfb551fb7745eca0c8286b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5d50176eafd06dde20c9510416b4ea1abd05817" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="99669c326a383e25b074e12ce49230f42dee9d3d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="73138bb845b641098da27eae98dd3fcc96960e8a" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c64220b96dbb589d7148353f7e1cfad95e5e608f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="2e313b4e5bbaa022d9225aca73fc6c42986754cf" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="cce5181b8ce0af8aa47d1fcfeb79ba05fe223d1d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="324cc7be6c9dedfbe10fe3f90387bf61ecd27c01" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="db08c56eaebf244ff3142963ce2d28f1d66ab880" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="38951459bdb968fe8d267a2144f2daab8015b7ff" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5fc542b259600a887b19200ae27aaaa00be8b9a0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f58159ca31b8acb9ea067910b0f31bafe22b3cbe" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f522c3927d765d22340b0bebf81d5e0e71e191d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="01523b80576e2b49f83dc67247fbc3f9819c22d9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b87b84c4a13dc2c6e5e702e25ec10a27e27371fe" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="31f8064daed292501f356d518545df44d51455b3" translate="yes" xml:space="preserve">
          <source>The overall effect is that the total size moves that same percentage, k, towards the total minimum or maximum and that percentage guarantees accommodation of the required space, DELTA.</source>
          <target state="translated">전체적인 효과는 전체 크기가 동일한 백분율 k를 총 최소값 또는 최대 값으로 이동하고 해당 백분율이 필요한 공간 DELTA의 수용을 보장한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f770b2501486fad821354a61f138150a2a3b6c92" translate="yes" xml:space="preserve">
          <source>The overall effect is to force all future readers of each call site's target to accept the most recently stored value. (&quot;Most recently&quot; is reckoned relative to the &lt;code&gt;syncAll&lt;/code&gt; itself.) Conversely, the &lt;code&gt;syncAll&lt;/code&gt; call may block until all readers have (somehow) decached all previous versions of each call site's target.</source>
          <target state="translated">전반적인 효과는 각 콜 사이트 대상의 미래의 모든 독자가 가장 최근에 저장된 값을 수락하도록하는 것입니다. ( &quot;가장 최근&quot;은 &lt;code&gt;syncAll&lt;/code&gt; 자체 와 관련하여 계산 됩니다.) 반대로, &lt;code&gt;syncAll&lt;/code&gt; 호출은 모든 독자가 각 호출 사이트 대상의 이전 버전을 모두 캐시 해제 할 때까지 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a597f7fe2186deb83b3832d157681941badccc8" translate="yes" xml:space="preserve">
          <source>The overall height of the &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ellipse2D&lt;/code&gt; 의 전체 높이 입니다 .</target>
        </trans-unit>
        <trans-unit id="c51d680650336bbcd98a1a70650e114d30b07a9f" translate="yes" xml:space="preserve">
          <source>The overall height of the full ellipse of which this arc is a partial section (not considering the angular extents).</source>
          <target state="translated">이 호가 부분 단면 인 전체 타원의 전체 높이입니다 (각도 범위는 고려하지 않음).</target>
        </trans-unit>
        <trans-unit id="08d345304e88691848ec39f0e8e15128680f7442" translate="yes" xml:space="preserve">
          <source>The overall height of this &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Ellipse2D&lt;/code&gt; 의 전체 높이 입니다 .</target>
        </trans-unit>
        <trans-unit id="3870ccb10e3ab8d6ce4a4e513b761343c57f1158" translate="yes" xml:space="preserve">
          <source>The overall orientation of the grid depends on the container's &lt;a href=&quot;componentorientation&quot;&gt;&lt;code&gt;ComponentOrientation&lt;/code&gt;&lt;/a&gt; property. For horizontal left-to-right orientations, grid coordinate (0,0) is in the upper left corner of the container with x increasing to the right and y increasing downward. For horizontal right-to-left orientations, grid coordinate (0,0) is in the upper right corner of the container with x increasing to the left and y increasing downward.</source>
          <target state="translated">그리드의 전체 방향은 컨테이너의 &lt;a href=&quot;componentorientation&quot;&gt; &lt;code&gt;ComponentOrientation&lt;/code&gt; &lt;/a&gt; 속성 에 따라 다릅니다 . 수평 왼쪽에서 오른쪽 방향의 경우 그리드 좌표 (0,0)는 컨테이너의 왼쪽 상단 모서리에 있으며 x는 오른쪽으로 증가하고 y는 아래로 증가합니다. 수평 오른쪽에서 왼쪽 방향의 경우 그리드 좌표 (0,0)는 컨테이너의 오른쪽 위 모서리에 있으며 x는 왼쪽으로 증가하고 y는 아래로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="7129641fb17ee86ae98bd9910e56b0d7e0292b8b" translate="yes" xml:space="preserve">
          <source>The overall width of the full ellipse of which this arc is a partial section (not considering the angular extents).</source>
          <target state="translated">이 호가 부분 단면 인 전체 타원의 전체 폭입니다 (각도 범위는 고려하지 않음).</target>
        </trans-unit>
        <trans-unit id="3fa89a83d7b23289a758aae24c69fb19d0825627" translate="yes" xml:space="preserve">
          <source>The overall width of this &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Ellipse2D&lt;/code&gt; 의 전체 너비 입니다 .</target>
        </trans-unit>
        <trans-unit id="b81d6288655d85e74abf1180320ee72013eb469e" translate="yes" xml:space="preserve">
          <source>The overloads that accept &lt;code&gt;Name&lt;/code&gt; are useful for applications that need to manipulate names: composing them, comparing components, and so on. The overloads that accept string names are likely to be more useful for simple applications, such as those that simply read in a name and look up the corresponding object.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 을 허용하는 오버로드는 이름을 구성하고 구성 요소를 비교하는 등의 이름을 조작해야하는 응용 프로그램에 유용합니다. 문자열 이름을 허용하는 오버로드는 단순히 이름을 읽고 해당 객체를 찾는 것과 같은 간단한 응용 프로그램에 더 유용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b16057ee984ca30b3a09e33dd099c7a289d1e4e6" translate="yes" xml:space="preserve">
          <source>The override style declaration.</source>
          <target state="translated">재정의 스타일 선언입니다.</target>
        </trans-unit>
        <trans-unit id="1f3afd76a6a4ce3c69d50d9e42513b3e98bae449" translate="yes" xml:space="preserve">
          <source>The owner of the clipboard.</source>
          <target state="translated">클립 보드의 소유자입니다.</target>
        </trans-unit>
        <trans-unit id="cf7fb65cedad5b648dd187476b8ae459f6736b04" translate="yes" xml:space="preserve">
          <source>The owner of this decoder.</source>
          <target state="translated">이 디코더의 소유자</target>
        </trans-unit>
        <trans-unit id="960d60a6630ecd199aafa78b55469fbc9767c71b" translate="yes" xml:space="preserve">
          <source>The owner of this encoder.</source>
          <target state="translated">이 인코더의 소유자</target>
        </trans-unit>
        <trans-unit id="fc34151ce94888d998373a80767db73331183bd7" translate="yes" xml:space="preserve">
          <source>The pack engine is initialized to an initial state as described by their properties below. The initial state can be manipulated by getting the engine properties (using &lt;a href=&quot;#properties()&quot;&gt;&lt;code&gt;properties()&lt;/code&gt;&lt;/a&gt;) and storing the modified properties on the map. The resource files will be passed through with no changes at all. The class files will not contain identical bytes, since the unpacker is free to change minor class file features such as constant pool order. However, the class files will be semantically identical, as specified in</source>
          <target state="translated">팩 엔진은 아래 속성에 설명 된대로 초기 상태로 초기화됩니다. 초기 상태는 엔진 속성을 가져오고 ( &lt;a href=&quot;#properties()&quot;&gt; &lt;code&gt;properties()&lt;/code&gt; &lt;/a&gt; 사용하여 ) 수정 된 속성을지도에 저장 하여 조작 할 수 있습니다 . 리소스 파일은 변경없이 전달됩니다. 언 패커는 상수 풀 순서와 같은 부 클래스 파일 기능을 자유롭게 변경할 수 있으므로 클래스 파일에는 동일한 바이트가 포함되지 않습니다. 그러나 클래스 파일은 다음과 같이 의미 상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1f5a4430fc7ac0d6794758f4e8205b46eb2301e9" translate="yes" xml:space="preserve">
          <source>The pack engine is initialized to an initial state as described by their properties below. The initial state can be manipulated by getting the engine properties (using &lt;a href=&quot;pack200.packer#properties--&quot;&gt;&lt;code&gt;properties()&lt;/code&gt;&lt;/a&gt;) and storing the modified properties on the map. The resource files will be passed through with no changes at all. The class files will not contain identical bytes, since the unpacker is free to change minor class file features such as constant pool order. However, the class files will be semantically identical, as specified in</source>
          <target state="translated">팩 엔진은 아래 속성에 설명 된대로 초기 상태로 초기화됩니다. 엔진 속성을 가져오고 ( &lt;a href=&quot;pack200.packer#properties--&quot;&gt; &lt;code&gt;properties()&lt;/code&gt; &lt;/a&gt; ) 수정 된 속성을 맵에 저장하여 초기 상태를 조작 할 수 있습니다 . 리소스 파일은 전혀 변경되지 않고 전달됩니다. 언 패커는 상수 풀 순서와 같은 부 클래스 파일 기능을 자유롭게 변경할 수 있으므로 클래스 파일에는 동일한 바이트가 포함되지 않습니다. 그러나 클래스 파일은 다음과 같이 의미 상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="63b42ec2ae764de42f4fa6aaac0f55d562803652" translate="yes" xml:space="preserve">
          <source>The package and module in which a proxy class is defined is specified &lt;a href=&quot;#membership&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">프록시 클래스가 정의 된 패키지 및 모듈은 다음 &lt;a href=&quot;#membership&quot;&gt;과 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17e0bdff2945c2edfc2026d2ce087b6253e4a1f0" translate="yes" xml:space="preserve">
          <source>The package and module to which a proxy class belongs are chosen such that the accessibility of the proxy class is in line with the accessibility of the proxy interfaces. Specifically, the package and the module membership of a proxy class defined via the &lt;a href=&quot;#getProxyClass(java.lang.ClassLoader,java.lang.Class...)&quot;&gt;&lt;code&gt;getProxyClass(ClassLoader, Class[])&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt;&lt;code&gt;newProxyInstance(ClassLoader, Class[], InvocationHandler)&lt;/code&gt;&lt;/a&gt; methods is specified as follows:</source>
          <target state="translated">프록시 클래스가 속한 패키지 및 모듈은 프록시 클래스의 액세스 가능성이 프록시 인터페이스의 액세스 가능성과 일치하도록 선택됩니다. 특히 &lt;a href=&quot;#getProxyClass(java.lang.ClassLoader,java.lang.Class...)&quot;&gt; &lt;code&gt;getProxyClass(ClassLoader, Class[])&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt; &lt;code&gt;newProxyInstance(ClassLoader, Class[], InvocationHandler)&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 정의 된 프록시 클래스의 패키지 및 모듈 멤버십은 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="cf2c096bf56c3be8d88ff1f521bec6265e7d4dd6" translate="yes" xml:space="preserve">
          <source>The package is not sealed.</source>
          <target state="translated">패키지가 밀봉되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="872f4daa7a794af63f1ae3e925cc2ccdb7956cff" translate="yes" xml:space="preserve">
          <source>The package is sealed with the &lt;a href=&quot;module/modulereference#location()&quot;&gt;module location&lt;/a&gt; as the code source, if known.</source>
          <target state="translated">패키지는 알려진 경우 코드 소스로 &lt;a href=&quot;module/modulereference#location()&quot;&gt;모듈 위치&lt;/a&gt; 로 봉인됩니다 .</target>
        </trans-unit>
        <trans-unit id="fbcd298d448956ef76e9c32f1274449606412ec1" translate="yes" xml:space="preserve">
          <source>The package name</source>
          <target state="translated">패키지 이름</target>
        </trans-unit>
        <trans-unit id="a6f33a2d9b883f2e9494c80ac5a2a02df51ac287" translate="yes" xml:space="preserve">
          <source>The package names that are parameters or returned by methods defined in this class are the fully-qualified names of the packages as defined in section 6.5.3 of</source>
          <target state="translated">매개 변수이거나이 클래스에 정의 된 메서드에 의해 반환되는 패키지 이름은 섹션 6.5.3에 정의 된 패키지의 정규화 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d825e3d7dabee111214c86ef931cdc1b54776a9a" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기로 압축 가능한 압축 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aa7b79f15d60b49360866c20e996ad65f58d66e0" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newPacker()&quot;&gt;&lt;code&gt;Pack200.newPacker()&lt;/code&gt;&lt;/a&gt;. The high degree of compression is achieved by using a number of techniques described in the JSR 200 specification. Some of the techniques are sorting, re-ordering and co-location of the constant pool.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기를 통해 팩 스트림을 압축 할 수 있도록합니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newPacker()&quot;&gt; &lt;code&gt;Pack200.newPacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 . 높은 수준의 압축은 JSR 200 사양에 설명 된 여러 기술을 사용하여 달성됩니다. 기술 중 일부는 상수 풀의 정렬, 재정렬 및 ​​공동 배치입니다.</target>
        </trans-unit>
        <trans-unit id="e60248a43a81f58023b88492a2d08616c29b5dfb" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newPacker--&quot;&gt;&lt;code&gt;Pack200.newPacker()&lt;/code&gt;&lt;/a&gt;. The high degree of compression is achieved by using a number of techniques described in the JSR 200 specification. Some of the techniques are sorting, re-ordering and co-location of the constant pool.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기로 압축 가능한 압축 스트림을 만듭니다. 엔진의 인스턴스를 이용하여 얻을 수있다 &lt;a href=&quot;pack200#newPacker--&quot;&gt; &lt;code&gt;Pack200.newPacker()&lt;/code&gt; &lt;/a&gt; . 높은 압축률은 JSR 200 사양에 설명 된 여러 기술을 사용하여 달성됩니다. 기술 중 일부는 상수 풀의 정렬, 재정렬 및 ​​배치입니다.</target>
        </trans-unit>
        <trans-unit id="30ee921e8de863d2bf5c9f554ad216859c719f2f" translate="yes" xml:space="preserve">
          <source>The packer's progress as a percentage, as periodically updated by the packer.</source>
          <target state="translated">패커가 주기적으로 업데이트하는 패커의 진행률 (백분율)입니다.</target>
        </trans-unit>
        <trans-unit id="821c9b2be3513399d24ae8026376ff5c4cd964d7" translate="yes" xml:space="preserve">
          <source>The packer's progress as a percentage, as periodically updated by the packer. Values of 0 - 100 are normal, and -1 indicates a stall. Progress can be monitored by polling the value of this property.</source>
          <target state="translated">패커가 주기적으로 업데이트하는 패커의 진행률 (백분율)입니다. 0-100의 값은 정상이고 -1은 중단을 나타냅니다. 이 속성 값을 폴링하여 진행 상황을 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b7835d6c2897bc03547bef50d2e8ccef489fee5" translate="yes" xml:space="preserve">
          <source>The padding value.</source>
          <target state="translated">패딩 값입니다.</target>
        </trans-unit>
        <trans-unit id="5254cf384974df4bf22cb621e6eb98fe1516e0c5" translate="yes" xml:space="preserve">
          <source>The paged-results control's assigned object identifier is 1.2.840.113556.1.4.319.</source>
          <target state="translated">페이징 제어 - 결과의 할당 객체 식별자 1.2.840.113556.1.4.319이다.</target>
        </trans-unit>
        <trans-unit id="866b80818a098f96114ee08abb23a44885090886" translate="yes" xml:space="preserve">
          <source>The paged-results response control's assigned object identifier is 1.2.840.113556.1.4.319.</source>
          <target state="translated">페이징 된 결과 응답 컨트롤의 할당 된 개체 식별자는 1.2.840.113556.1.4.319입니다.</target>
        </trans-unit>
        <trans-unit id="b266460db97939c24d673ede02a200ebb6755934" translate="yes" xml:space="preserve">
          <source>The paint event type.</source>
          <target state="translated">페인트 이벤트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="67aa960c4b671a24ef5b1e0c2ea9ff270cfe200e" translate="yes" xml:space="preserve">
          <source>The painting architecture of Swing requires an opaque &lt;code&gt;JComponent&lt;/code&gt; to exist in the containment hierarchy above all other components. This is typically provided by way of the content pane. If you replace the content pane, it is recommended that you make the content pane opaque by way of &lt;code&gt;setOpaque(true)&lt;/code&gt;. Additionally, if the content pane overrides &lt;code&gt;paintComponent&lt;/code&gt;, it will need to completely fill in the background in an opaque color in &lt;code&gt;paintComponent&lt;/code&gt;.</source>
          <target state="translated">Swing의 페인팅 아키텍처는 다른 모든 구성 요소 위에 포함 계층 구조에 존재 하는 불투명 &lt;code&gt;JComponent&lt;/code&gt; 가 필요합니다 . 이는 일반적으로 콘텐츠 창을 통해 제공됩니다. 콘텐츠 창을 교체하는 경우 &lt;code&gt;setOpaque(true)&lt;/code&gt; 통해 콘텐츠 창을 불투명하게 만드는 것이 좋습니다 . 내용 창에 우선하는 경우 또한, &lt;code&gt;paintComponent&lt;/code&gt; 완전히에서 불투명 한 색으로 배경을 작성하기 위해서는 필요합니다 &lt;code&gt;paintComponent&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="49dbe49dc69592f6524d7ca2b444c01fc630b182" translate="yes" xml:space="preserve">
          <source>The palette close icon.</source>
          <target state="translated">팔레트 닫기 아이콘.</target>
        </trans-unit>
        <trans-unit id="1b15c609d33b642b1ba463e5d2a1471d0d9df721" translate="yes" xml:space="preserve">
          <source>The palette layer sits over the default layer. Useful for floating toolbars and palettes, so they can be positioned above other components.</source>
          <target state="translated">팔레트 레이어는 기본 레이어 위에 있습니다. 부동 도구 모음 및 팔레트에 유용하므로 다른 구성 요소 위에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a054a114f906605bc80876fd63d7712ff1b761b8" translate="yes" xml:space="preserve">
          <source>The paragraph attributes form the definition of a paragraph to be rendered. All sizes are specified in points (such as found in postscript), a device independent measure.</source>
          <target state="translated">단락 속성은 렌더링 할 단락의 정의를 형성합니다. 모든 크기는 장치 독립적 측정 인 포인트 (예 : 포스트 스크립트에 있음)로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4707bb85a1366f3abad509af71baadf574140ddd" translate="yes" xml:space="preserve">
          <source>The paragraph left indent action identifier</source>
          <target state="translated">단락 왼쪽 들여 쓰기 작업 식별자</target>
        </trans-unit>
        <trans-unit id="16cfceed724273e5b7e0f3fabbd803cacb348ced" translate="yes" xml:space="preserve">
          <source>The paragraph right indent action identifier</source>
          <target state="translated">단락 오른쪽 들여 쓰기 작업 식별자</target>
        </trans-unit>
        <trans-unit id="7b4511c60fee63fc5dd606de36079b10244d82e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;item&lt;/code&gt; represents the context the XPath expression will be operated on. The type of the context is implementation-dependent. If the value is &lt;code&gt;null&lt;/code&gt;, the operation must have no dependency on the context, otherwise an XPathExpressionException will be thrown.</source>
          <target state="translated">매개 변수 &lt;code&gt;item&lt;/code&gt; 은 XPath 표현식이 작동 할 컨텍스트를 나타냅니다. 컨텍스트 유형은 구현에 따라 다릅니다. 값이 &lt;code&gt;null&lt;/code&gt; 이면 작업에 컨텍스트에 대한 종속성이 없어야합니다. 그렇지 않으면 XPathExpressionException이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="50af5226ec29660988fc56fada491b71c9083bd4" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;n&lt;/code&gt; must be in the range 0 through 999999999, inclusive. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; returns &lt;a href=&quot;#ONE&quot;&gt;&lt;code&gt;ONE&lt;/code&gt;&lt;/a&gt;. Note that future releases may expand the allowable exponent range of this method.</source>
          <target state="translated">매개 변수 &lt;code&gt;n&lt;/code&gt; 은 0-999999999 범위에 있어야합니다. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; 은 &lt;a href=&quot;#ONE&quot;&gt; &lt;code&gt;ONE&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 향후 릴리스에서는이 방법의 허용 가능한 지수 범위가 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24552a8980b41276ccd5905a6aaeeb53f392d59d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;n&lt;/code&gt; must be in the range 0 through 999999999, inclusive. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; returns &lt;a href=&quot;bigdecimal#ONE&quot;&gt;&lt;code&gt;ONE&lt;/code&gt;&lt;/a&gt;. Note that future releases may expand the allowable exponent range of this method.</source>
          <target state="translated">매개 변수 &lt;code&gt;n&lt;/code&gt; 은 0-999999999 범위에 있어야합니다. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; 은 &lt;a href=&quot;bigdecimal#ONE&quot;&gt; &lt;code&gt;ONE&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 향후 릴리스에서는이 방법의 허용 가능한 지수 범위가 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="225f6eef89aa234e726279199c17142bb293790d" translate="yes" xml:space="preserve">
          <source>The parameter count in &lt;code&gt;concatType&lt;/code&gt; equals to number of \1 tags in &lt;code&gt;recipe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;concatType&lt;/code&gt; 의 매개 변수 개수 는 &lt;code&gt;recipe&lt;/code&gt; 의 \ 1 태그 수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="10e5bbcde45ca10f7347abac26ef33398c3b889b" translate="yes" xml:space="preserve">
          <source>The parameter count in &lt;code&gt;concatType&lt;/code&gt; is equal to number of \1 tags in &lt;code&gt;recipe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;concatType&lt;/code&gt; 의 매개 변수 수 는 &lt;code&gt;recipe&lt;/code&gt; 의 \ 1 태그 수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfa4a1bf9d4f2c697535f0da6a4485f9445b8e53" translate="yes" xml:space="preserve">
          <source>The parameter description</source>
          <target state="translated">매개 변수 설명</target>
        </trans-unit>
        <trans-unit id="d5ec5b0fc9d2ee85f8e3be945c5875b1eb128c88" translate="yes" xml:space="preserve">
          <source>The parameter factoryId defined here is inconsistent with that of other JAXP factories where the first parameter is fully qualified factory class name that provides implementation of the factory.</source>
          <target state="translated">여기에 정의 된 매개 변수 factoryId는 첫 번째 매개 변수가 팩토리 구현을 제공하는 완전한 팩토리 클래스 이름 인 다른 JAXP 팩토리의 매개 변수와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06f41071ad9d7621be55ce2931fc7d18a329dcd8" translate="yes" xml:space="preserve">
          <source>The parameter list &lt;code&gt;(V A...)&lt;/code&gt; of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;. It will constrain the parameter lists of the other loop parts.</source>
          <target state="translated">본문 의 매개 변수 목록 &lt;code&gt;(V A...)&lt;/code&gt; 을 &lt;em&gt;내부 매개 변수 목록&lt;/em&gt; 이라고합니다 . 다른 루프 파트의 매개 변수 목록을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="7fd62c7a8f8c15bfb268fbf63a8a0194acc8a533" translate="yes" xml:space="preserve">
          <source>The parameter list &lt;code&gt;(V I A...)&lt;/code&gt; of the body contributes to a list of types called the &lt;em&gt;internal parameter list&lt;/em&gt;. It will constrain the parameter lists of the other loop parts.</source>
          <target state="translated">본문 의 매개 변수 목록 &lt;code&gt;(V I A...)&lt;/code&gt; 은 &lt;em&gt;내부 매개 변수 목록&lt;/em&gt; 이라는 유형 목록에 기여 &lt;em&gt;합니다&lt;/em&gt; . 다른 루프 파트의 매개 변수 목록을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="e58b0b6e022c4ee1aa6339bb336b514c909a5f9d" translate="yes" xml:space="preserve">
          <source>The parameter list &lt;code&gt;(V T A...)&lt;/code&gt; of the body contributes to a list of types called the &lt;em&gt;internal parameter list&lt;/em&gt;. It will constrain the parameter lists of the other loop parts.</source>
          <target state="translated">본문 의 매개 변수 목록 &lt;code&gt;(V T A...)&lt;/code&gt; 은 &lt;em&gt;내부 매개 변수 목록&lt;/em&gt; 이라는 유형 목록에 기여 &lt;em&gt;합니다&lt;/em&gt; . 다른 루프 파트의 매개 변수 목록을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="474a5af5a3f8d227ed70f57da563f8b86bc54e3c" translate="yes" xml:space="preserve">
          <source>The parameter list for every non-omitted, non-init (step, pred, and fini) function must be effectively identical to the internal parameter list &lt;code&gt;(V... A...)&lt;/code&gt;.</source>
          <target state="translated">모든 생략되지 않고 초기화되지 않은 (step, pred 및 fini) 함수에 대한 매개 변수 목록은 내부 매개 변수 목록 &lt;code&gt;(V... A...)&lt;/code&gt; 과 사실상 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="53432ad7282ec815dfa60a54e056f22aa428efcb" translate="yes" xml:space="preserve">
          <source>The parameter list for init functions will be adjusted to the external parameter list. (Note that their parameter lists are already effectively identical to this list.)</source>
          <target state="translated">초기화 기능에 대한 매개 변수 목록은 외부 매개 변수 목록에 맞게 조정됩니다. (매개 변수 목록은 이미이 목록과 사실상 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="8e16a7cb9882736edeb02f61ab4586e18b7cca61" translate="yes" xml:space="preserve">
          <source>The parameter list for the resulting loop handle will be the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">결과 루프 핸들의 매개 변수 목록은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b118da091f6db3ab3ac720df6e05ded63f2e75c7" translate="yes" xml:space="preserve">
          <source>The parameter list of &lt;code&gt;iterations&lt;/code&gt; (of some form &lt;code&gt;(A*)&lt;/code&gt;) must be effectively identical to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(A*)&lt;/code&gt; 형식 의 &lt;code&gt;iterations&lt;/code&gt; 매개 변수 목록은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 과 효과적으로 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="30a082bbd95089d21ab808594316f3f108f9a062" translate="yes" xml:space="preserve">
          <source>The parameter list of &lt;code&gt;start&lt;/code&gt; (of some form &lt;code&gt;(A*)&lt;/code&gt;) must be effectively identical to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 의 매개 변수 목록 (일부 형식 &lt;code&gt;(A*)&lt;/code&gt; )은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 과 사실상 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9d60d133de9d4d6e4fd09cf41a4b92be03c10f9" translate="yes" xml:space="preserve">
          <source>The parameter list of an &lt;code&gt;iterator&lt;/code&gt; that is non-&lt;code&gt;null&lt;/code&gt; (of some form &lt;code&gt;(A*)&lt;/code&gt;) must be effectively identical to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 아닌 (일부 형식 &lt;code&gt;(A*)&lt;/code&gt; ) &lt;code&gt;iterator&lt;/code&gt; 의 매개 변수 목록은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; 과 효과적으로 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c4b12867b1f840ab46a64f2a284a7b84dba7590" translate="yes" xml:space="preserve">
          <source>The parameter names used by the &lt;code&gt;DOMConfiguration&lt;/code&gt; object are defined throughout the DOM Level 3 specifications. Names are case-insensitive. To avoid possible conflicts, as a convention, names referring to parameters defined outside the DOM specification should be made unique. Because parameters are exposed as properties in names are recommended to follow the section 5.16 Identifiers of [Unicode] with the addition of the character '-' (HYPHEN-MINUS) but it is not enforced by the DOM implementation. DOM Level 3 Core Implementations are required to recognize all parameters defined in this specification. Some parameter values may also be required to be supported by the implementation. Refer to the definition of the parameter to know if a value must be supported or not.</source>
          <target state="translated">&lt;code&gt;DOMConfiguration&lt;/code&gt; 객체에서 사용하는 매개 변수 이름 은 DOM 레벨 3 사양 전체에서 정의됩니다. 이름은 대소 문자를 구분하지 않습니다. 충돌 가능성을 피하기 위해 규칙으로 DOM 사양 외부에 정의 된 매개 변수를 참조하는 이름은 고유해야합니다. 매개 변수는 이름의 속성으로 노출되기 때문에 문자 '-'(HYPHEN-MINUS)를 추가하여 5.16 [Unicode] 식별자 섹션을 따르는 것이 좋지만 DOM 구현에 의해 강제되지는 않습니다. DOM 레벨 3 핵심 구현은이 사양에 정의 된 모든 매개 변수를 인식하는 데 필요합니다. 일부 매개 변수 값은 구현에서 지원해야 할 수도 있습니다. 값이 지원되어야하는지 여부를 알려면 매개 변수 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcdb80d85de039f3e18bb3b5fc1d902bb8edad88" translate="yes" xml:space="preserve">
          <source>The parameter of this method is the number of invocations being requested from this WebSocket to the associated listener, not the number of messages. Sometimes a message may be delivered to the listener in a single invocation, but not always. For example, Ping, Pong and Close messages are delivered in a single invocation of &lt;code&gt;onPing&lt;/code&gt;, &lt;code&gt;onPong&lt;/code&gt; and &lt;code&gt;onClose&lt;/code&gt; methods respectively. However, whether or not Text and Binary messages are delivered in a single invocation of &lt;code&gt;onText&lt;/code&gt; and &lt;code&gt;onBinary&lt;/code&gt; methods depends on the boolean argument (&lt;code&gt;last&lt;/code&gt;) of these methods. If &lt;code&gt;last&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then there is more to a message than has been delivered to the invocation.</source>
          <target state="translated">이 메소드의 매개 변수는 메시지 수가 아니라이 WebSocket에서 연관된 리스너로 요청되는 호출 수입니다. 때로는 메시지가 단일 호출로 리스너에게 전달 될 수 있지만 항상 그런 것은 아닙니다. 예를 들어, Ping, Pong 및 Close 메시지는 각각 &lt;code&gt;onPing&lt;/code&gt; , &lt;code&gt;onPong&lt;/code&gt; 및 &lt;code&gt;onClose&lt;/code&gt; 메소드 의 단일 호출로 전달 됩니다. 그러나 Text 및 Binary 메시지가 &lt;code&gt;onText&lt;/code&gt; 및 &lt;code&gt;onBinary&lt;/code&gt; 메서드 의 단일 호출로 전달되는지 여부 는 이러한 메서드 의 부울 인수 ( &lt;code&gt;last&lt;/code&gt; )에 따라 다릅니다 . &lt;code&gt;last&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 이면이면 호출에 전달 된 것보다 더 많은 메시지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="44e6fab6d9ac4719240ec0b3727c954e51d89ce9" translate="yes" xml:space="preserve">
          <source>The parameter types &lt;code&gt;Vn&lt;/code&gt; will be interpreted as loop-local state elements &lt;code&gt;(V...)&lt;/code&gt;.</source>
          <target state="translated">매개 변수 유형 &lt;code&gt;Vn&lt;/code&gt; 은 루프 로컬 상태 요소 &lt;code&gt;(V...)&lt;/code&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e373695ec6d41c303c83799483b80fd014fe746" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setUnicodeStream&lt;/code&gt; has been called will return an array containing the parameter values that have been set. In that array, the element that represents the values set with this method will itself be an array. The first element of that array is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The second element is the value set for</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;setUnicodeStream&lt;/code&gt; 이 호출 된 후 &lt;code&gt;getParams&lt;/code&gt; 메소드를 호출하면 설정된 매개 변수 값이 포함 된 배열이 리턴됩니다. 이 배열에서이 메서드로 설정된 값을 나타내는 요소 자체가 배열이됩니다. 그 배열의 첫 번째 요소는 주어진 &lt;code&gt;java.io.InputStream&lt;/code&gt; 객체입니다. 두 번째 요소는 다음에 대해 설정된 값입니다.</target>
        </trans-unit>
        <trans-unit id="5b1d686a30e89e20a67cce69f88fe14f6a1d46c4" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be provided in any class that extends this class and implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;execute&lt;/code&gt; 및 &lt;code&gt;populate&lt;/code&gt; 와 같은 메소드 는이 클래스를 확장하고 표준 JSR-114 &lt;code&gt;RowSet&lt;/code&gt; 인터페이스 중 하나 이상을 구현하는 모든 클래스에서 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfb052ee0c1e5966878d2245fe418bfa8a8bdef9" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be provided in any class that extends this class and implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces. NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method as it is undefined in this class.</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;execute&lt;/code&gt; 및 &lt;code&gt;populate&lt;/code&gt; 와 같은 메소드 는이 클래스를 확장하고 표준 JSR-114 &lt;code&gt;RowSet&lt;/code&gt; 인터페이스 중 하나 이상을 구현하는 모든 클래스에서 제공되어야합니다 . 참고 : &lt;code&gt;JdbcRowSet&lt;/code&gt; 은이 클래스에서 정의 되지 않았기 때문에 &lt;code&gt;populate&lt;/code&gt; 메서드가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="305a02d1aa1ebc36991c6f5311b0ec8b4872c30b" translate="yes" xml:space="preserve">
          <source>The parameter value set by this method is stored internally and will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt; object's command when the method &lt;code&gt;execute&lt;/code&gt; is called. Methods such as &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt; must be provided in any class that extends this class and implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.</source>
          <target state="translated">이 메소드에 의해 설정된 매개 변수 값은 내부적으로 저장 되며 메소드 &lt;code&gt;execute&lt;/code&gt; 이 호출 될 때이 &lt;code&gt;RowSet&lt;/code&gt; 객체의 명령 에 적절한 매개 변수로 제공됩니다 . &lt;code&gt;execute&lt;/code&gt; , &lt;code&gt;populate&lt;/code&gt; 와 같은 메소드 는이 클래스를 확장하고 표준 JSR-114 &lt;code&gt;RowSet&lt;/code&gt; 인터페이스 중 하나 이상을 구현하는 모든 클래스에서 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b8ef4f0e5646bef0741f18b4f02a8cea83921ea8" translate="yes" xml:space="preserve">
          <source>The parameter values retain their original case, except a charset parameter value for a text media type is converted to lowercase.</source>
          <target state="translated">텍스트 매체 유형의 문자 세트 매개 변수 값이 소문자로 변환되는 것을 제외하고 매개 변수 값은 원래 대소 문자를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bb39ffff0d8075952f90c8c237468e1f45f1c684" translate="yes" xml:space="preserve">
          <source>The parameters are arranged in ascending order of parameter name.</source>
          <target state="translated">매개 변수는 매개 변수 이름의 오름차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="11e0d4edf362f7c76332fc4450bc63049b256eb3" translate="yes" xml:space="preserve">
          <source>The parameters are not authenticated by the &lt;code&gt;SSLEngine&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &lt;code&gt;SSLEngine&lt;/code&gt; 에 의해 인증되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb65f692e7e1455e31c885605739ad78cecb430f" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 addSelectionInterval(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;addSelectionInterval(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; addSelectionInterval(x, y)&lt;/code&gt; 는 &lt;code&gt;addSelectionInterval(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1f7d66b2c4cec0965399997b2bce2a3097afb6c1" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 getPathBetweenRows(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;getPathBetweenRows(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; getPathBetweenRows(x, y)&lt;/code&gt; 는 &lt;code&gt;getPathBetweenRows(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="71fdccbc419bc28fc08830c8d380f76d2f332f40" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 removeSelectionInterval(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;removeSelectionInterval(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; removeSelectionInterval(x, y)&lt;/code&gt; 는 &lt;code&gt;removeSelectionInterval(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8392c9e26a22dc79ccde9fbc210a6e58f6f0e6de" translate="yes" xml:space="preserve">
          <source>The parameters are not order dependent. That is, &lt;code&gt;
 setSelectionInterval(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;setSelectionInterval(y, x)&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 순서에 따라 달라지지 않습니다. 즉, &lt;code&gt; setSelectionInterval(x, y)&lt;/code&gt; 는 &lt;code&gt;setSelectionInterval(y, x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="aff2143fd57f0fff307229e418484b901b5de2b1" translate="yes" xml:space="preserve">
          <source>The parameters consist of a 12-byte nonce and an initial counter value expressed as a 32-bit integer.</source>
          <target state="translated">매개 변수는 12 바이트 nonce와 32 비트 정수로 표현되는 초기 카운터 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ae335f84321e13f212ee4b121568c174875cb3" translate="yes" xml:space="preserve">
          <source>The parameters consist of a version number, a rounds count, a word size, and optionally an initialization vector (IV) (only in feedback mode).</source>
          <target state="translated">매개 변수는 버전 번호, 반올림 횟수, 단어 크기 및 선택적으로 초기화 벡터 (IV) (피드백 모드에서만)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f8d6f3c8b03d8da1385862cfad5502762462d5" translate="yes" xml:space="preserve">
          <source>The parameters consist of an effective key size and optionally an 8-byte initialization vector (IV) (only in feedback mode).</source>
          <target state="translated">매개 변수는 유효 키 크기와 선택적으로 8 바이트 IV (IV)로 구성됩니다 (피드백 모드에서만).</target>
        </trans-unit>
        <trans-unit id="0b947091ed01239ac2c63710914b838d30a607d9" translate="yes" xml:space="preserve">
          <source>The parameters of the underlying executable do not necessarily have unique names, or names that are legal identifiers in the Java programming language (JLS 3.8).</source>
          <target state="translated">기본 실행 파일의 매개 변수에 고유 이름 또는 Java 프로그래밍 언어 (JLS 3.8)의 유효한 식별자 인 이름이 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76d53ff74b412d6d37047d16013d75e50df36de2" translate="yes" xml:space="preserve">
          <source>The parameters represent the two parts of a phrase like '6 Hours'. For example:</source>
          <target state="translated">매개 변수는 '6 Hours'와 같은 문구의 두 부분을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad7182414b3d2ec2fdd16dc0fcb2c6566049a62c" translate="yes" xml:space="preserve">
          <source>The parameters specified by an &lt;code&gt;ImageReadParam&lt;/code&gt; are applied to an image as follows. First, if a rendering size has been set by &lt;code&gt;setSourceRenderSize&lt;/code&gt;, the entire decoded image is rendered at the size given by &lt;code&gt;getSourceRenderSize&lt;/code&gt;. Otherwise, the image has its natural size given by &lt;code&gt;ImageReader.getWidth&lt;/code&gt; and &lt;code&gt;ImageReader.getHeight&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ImageReadParam&lt;/code&gt; 에 의해 지정된 매개 변수 는 다음과 같이 이미지에 적용됩니다. 먼저, 렌더링 크기가 &lt;code&gt;setSourceRenderSize&lt;/code&gt; 에 의해 설정된 경우 , 디코딩 된 전체 이미지는 &lt;code&gt;getSourceRenderSize&lt;/code&gt; 가 제공 한 크기로 렌더링됩니다 . 그렇지 않으면 이미지는 &lt;code&gt;ImageReader.getWidth&lt;/code&gt; 및 &lt;code&gt;ImageReader.getHeight&lt;/code&gt; 에 의해 주어진 자연 크기를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="71e0836126bfdf6c19dabd14a10861299a8d46d0" translate="yes" xml:space="preserve">
          <source>The parameters supplied to this constructor are subject to the constraints described in &lt;a href=&quot;#setValues(int,int,int,int)&quot;&gt;&lt;code&gt;setValues(int, int, int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 생성자에 제공된 매개 변수에는 &lt;a href=&quot;#setValues(int,int,int,int)&quot;&gt; &lt;code&gt;setValues(int, int, int, int)&lt;/code&gt; &lt;/a&gt; 설명 된 제약 조건이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0eb52dcb0a07ffe222d0a4187fb174042c35c23" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;Printable.print(..)&lt;/code&gt; include a &lt;code&gt;PageFormat&lt;/code&gt; which describes the printable area of the page, needed for calculating the contents that will fit the page, and the page index, which specifies the zero-based print stream index of the requested page.</source>
          <target state="translated">&lt;code&gt;Printable.print(..)&lt;/code&gt; 대한 매개 변수 에는 페이지에 맞는 내용을 계산하는 데 필요한 페이지의 인쇄 가능 영역을 설명 하는 &lt;code&gt;PageFormat&lt;/code&gt; 과 요청 된 항목의 0부터 시작하는 인쇄 스트림 인덱스를 지정하는 페이지 인덱스가 포함됩니다. 페이지.</target>
        </trans-unit>
        <trans-unit id="adce7a8e02b2dbab7543097404b50ae2e2f2c0d3" translate="yes" xml:space="preserve">
          <source>The parameters to these methods follow consistent patterns:</source>
          <target state="translated">이러한 메서드에 대한 매개 변수는 일관된 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="64f3c4e11f9c88a8f6edb02c85c8a7f5a133e45c" translate="yes" xml:space="preserve">
          <source>The parameters used to construct the common pool may be controlled by setting the following &lt;a href=&quot;../../lang/system#getProperty(java.lang.String)&quot;&gt;system properties&lt;/a&gt;:</source>
          <target state="translated">공통 풀을 구성하는 데 사용되는 매개 변수는 다음 &lt;a href=&quot;../../lang/system#getProperty(java.lang.String)&quot;&gt;시스템 속성&lt;/a&gt; 을 설정하여 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbf95408183e18e8026be8d135af97a9475df373" translate="yes" xml:space="preserve">
          <source>The parameters will always have the ciphersuite and protocols arrays set to non-null values.</source>
          <target state="translated">매개 변수는 항상 ciphersuite 및 protocols 배열이 널이 아닌 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b52384d72a0f4af8de4f042358cf9996bbe18cf1" translate="yes" xml:space="preserve">
          <source>The parameters will always have the ciphersuites and protocols arrays set to non-null values.</source>
          <target state="translated">매개 변수는 항상 암호 스위트 및 프로토콜 배열이 널이 아닌 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc871c3368e0f342532a2f5e48a852376491cab" translate="yes" xml:space="preserve">
          <source>The parent &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">부모 &lt;code&gt;ClassLoader&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0f70c146a15a9633f15da82c69e002a0f572e9c" translate="yes" xml:space="preserve">
          <source>The parent &lt;code&gt;TIFFTag&lt;/code&gt; of this &lt;code&gt;TIFFDiectory&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">부모 &lt;code&gt;TIFFTag&lt;/code&gt; 이의 &lt;code&gt;TIFFDiectory&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d74755cef612aee13f4b446f05e5c5a94e3a7a37" translate="yes" xml:space="preserve">
          <source>The parent Preferences node whose child was added or removed</source>
          <target state="translated">자식이 추가 또는 제거 된 부모 기본 설정 노드</target>
        </trans-unit>
        <trans-unit id="33ac4d46f58c647e6c28b3a88eaca5814b56ebef" translate="yes" xml:space="preserve">
          <source>The parent XML reader, or null if none is set.</source>
          <target state="translated">부모 XML 판독기 또는 설정되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="cd9fa36300939772a8d4ba38942d9a6d934d8ad7" translate="yes" xml:space="preserve">
          <source>The parent bundle of this bundle.</source>
          <target state="translated">이 번들의 상위 번들입니다.</target>
        </trans-unit>
        <trans-unit id="e7f2fe8682b735add36e45bdef4d5db06770add9" translate="yes" xml:space="preserve">
          <source>The parent bundle of this bundle. The parent bundle is searched by &lt;a href=&quot;#getObject(java.lang.String)&quot;&gt;&lt;code&gt;getObject&lt;/code&gt;&lt;/a&gt; when this bundle does not contain a particular resource.</source>
          <target state="translated">이 번들의 상위 번들입니다. 이 번들에 특정 자원이 포함되지 않은 경우 &lt;a href=&quot;#getObject(java.lang.String)&quot;&gt; &lt;code&gt;getObject&lt;/code&gt; &lt;/a&gt; 가 상위 번들을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="f994dff1510a6e8c2918e9b6d01ec794ebf2150e" translate="yes" xml:space="preserve">
          <source>The parent bundle of this bundle. The parent bundle is searched by &lt;a href=&quot;resourcebundle#getObject-java.lang.String-&quot;&gt;&lt;code&gt;getObject&lt;/code&gt;&lt;/a&gt; when this bundle does not contain a particular resource.</source>
          <target state="translated">이 번들의 상위 번들입니다. 이 번들에 특정 자원이없는 경우 &lt;a href=&quot;resourcebundle#getObject-java.lang.String-&quot;&gt; &lt;code&gt;getObject&lt;/code&gt; &lt;/a&gt; 가 상위 번들을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="1a8a8c799fe8db426e27940a42162ee878964a8c" translate="yes" xml:space="preserve">
          <source>The parent filter, or null if none has been set.</source>
          <target state="translated">상위 필터 또는 설정되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="2ad67599d600504152ce7c1281d25a4bda96e309" translate="yes" xml:space="preserve">
          <source>The parent of this Raster, or null.</source>
          <target state="translated">이 Raster의 부모 또는 null입니다.</target>
        </trans-unit>
        <trans-unit id="6ead187d94bbfc9668d1eb5e36e9dd0eef0b1804" translate="yes" xml:space="preserve">
          <source>The parent of this node.</source>
          <target state="translated">이 노드의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="cc6d14ed40ff1babb894dcdc578652bb681cdd1e" translate="yes" xml:space="preserve">
          <source>The parent of this node. All nodes, except &lt;code&gt;Attr&lt;/code&gt;, &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentFragment&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt;, and &lt;code&gt;Notation&lt;/code&gt; may have a parent. However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 노드의 부모입니다. &lt;code&gt;Attr&lt;/code&gt; , &lt;code&gt;Document&lt;/code&gt; , &lt;code&gt;DocumentFragment&lt;/code&gt; , &lt;code&gt;Entity&lt;/code&gt; 및 &lt;code&gt;Notation&lt;/code&gt; 을 제외한 모든 노드 에는 부모가있을 수 있습니다. 그러나 노드가 방금 생성되었고 아직 트리에 추가되지 않았거나 트리에서 제거 된 경우 이것은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33e9e67cecfddb7bcbfe15f096f52a88a0f4abac" translate="yes" xml:space="preserve">
          <source>The parent of this path object consists of this path's root component, if any, and each element in the path except for the &lt;em&gt;farthest&lt;/em&gt; from the root in the directory hierarchy. This method does not access the file system; the path or its parent may not exist. Furthermore, this method does not eliminate special names such as &quot;.&quot; and &quot;..&quot; that may be used in some implementations. On UNIX for example, the parent of &quot;&lt;code&gt;/a/b/c&lt;/code&gt;&quot; is &quot;&lt;code&gt;/a/b&lt;/code&gt;&quot;, and the parent of &lt;code&gt;&quot;x/y/.&lt;/code&gt;&quot; is &quot;&lt;code&gt;x/y&lt;/code&gt;&quot;. This method may be used with the &lt;a href=&quot;#normalize()&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; method, to eliminate redundant names, for cases where &lt;em&gt;shell-like&lt;/em&gt; navigation is required.</source>
          <target state="translated">이 경로 개체의 부모는이 경로의 루트 구성 요소 (있는 경우)와 디렉터리 계층 구조의 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 것을 제외하고 경로의 각 요소로 구성됩니다 . 이 방법은 파일 시스템에 액세스하지 않습니다. 경로 또는 부모가 존재하지 않을 수 있습니다. 또한이 방법은 &quot;.&quot;와 같은 특수 이름을 제거하지 않습니다. 일부 구현에서 사용될 수있는 &quot;..&quot; 예를 들어 UNIX에서 &quot; &lt;code&gt;/a/b/c&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;/a/b&lt;/code&gt; &quot;이고 &lt;code&gt;&quot;x/y/.&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;x/y&lt;/code&gt; &quot;입니다. 이 메서드는 &lt;a href=&quot;#normalize()&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 메서드 와 함께 사용하여 &lt;em&gt;셸과 같은&lt;/em&gt; 탐색이 필요한 경우 중복 된 이름을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ecda3b1f4f94be292091c923d129f7d53c68915" translate="yes" xml:space="preserve">
          <source>The parent of this path object consists of this path's root component, if any, and each element in the path except for the &lt;em&gt;farthest&lt;/em&gt; from the root in the directory hierarchy. This method does not access the file system; the path or its parent may not exist. Furthermore, this method does not eliminate special names such as &quot;.&quot; and &quot;..&quot; that may be used in some implementations. On UNIX for example, the parent of &quot;&lt;code&gt;/a/b/c&lt;/code&gt;&quot; is &quot;&lt;code&gt;/a/b&lt;/code&gt;&quot;, and the parent of &lt;code&gt;&quot;x/y/.&lt;/code&gt;&quot; is &quot;&lt;code&gt;x/y&lt;/code&gt;&quot;. This method may be used with the &lt;a href=&quot;path#normalize--&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; method, to eliminate redundant names, for cases where &lt;em&gt;shell-like&lt;/em&gt; navigation is required.</source>
          <target state="translated">이 경로 객체의 부모는이 경로의 루트 구성 요소 (있는 경우)와 디렉토리 계층의 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 것을 제외하고 경로의 각 요소로 구성됩니다 . 이 방법은 파일 시스템에 액세스하지 않습니다. 경로 나 그 부모가 존재하지 않을 수 있습니다. 또한이 방법은 &quot;.&quot;와 같은 특수 이름을 제거하지 않습니다. 및 일부 구현에 사용될 수있는 &quot;..&quot; 예를 들어 UNIX에서 &quot; &lt;code&gt;/a/b/c&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;/a/b&lt;/code&gt; &quot;이고 &lt;code&gt;&quot;x/y/.&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;x/y&lt;/code&gt; &quot;입니다. &lt;em&gt;쉘과 같은&lt;/em&gt; 탐색이 필요한 경우 중복 이름을 제거하기 &lt;a href=&quot;path#normalize--&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 방법을 normalize 방법 과 함께 사용할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8eec86ed61bb41b453fe46f696b36fc01364efd8" translate="yes" xml:space="preserve">
          <source>The parentX, parentY, width and height parameters form a Rectangle in this Raster's coordinate space, indicating the area of pixels to be shared. An error will be thrown if this Rectangle is not contained with the bounds of the current Raster.</source>
          <target state="translated">parentX, parentY, width 및 height 매개 변수는이 Raster의 좌표 공간에서 Rectangle을 형성하여 공유 할 픽셀 영역을 나타냅니다. 이 Rectangle이 현재 Raster의 경계에 포함되어 있지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a015d5afd091b8ea8039b136a7b37b297cf71397" translate="yes" xml:space="preserve">
          <source>The parentX, parentY, width and height parameters form a Rectangle in this WritableRaster's coordinate space, indicating the area of pixels to be shared. An error will be thrown if this Rectangle is not contained with the bounds of the current WritableRaster.</source>
          <target state="translated">parentX, parentY, width 및 height 매개 변수는이 WritableRaster의 좌표 공간에서 Rectangle을 형성하여 공유 할 픽셀 영역을 나타냅니다. 이 Rectangle이 현재 WritableRaster의 경계에 포함되어 있지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c36a2eb88cb58395a7ce0b4cce65815d955a82d4" translate="yes" xml:space="preserve">
          <source>The parsable textual representation of the declaration block (excluding the surrounding curly braces).</source>
          <target state="translated">선언 블록의 구문 분석 가능한 텍스트 표현입니다 (둘러싸는 중괄호 제외).</target>
        </trans-unit>
        <trans-unit id="d5475591c3ffc90e6e8a0c88b14ba8460d5953d4" translate="yes" xml:space="preserve">
          <source>The parsable textual representation of the declaration block (excluding the surrounding curly braces). Setting this attribute will result in the parsing of the new value and resetting of all the properties in the declaration block including the removal or addition of properties.</source>
          <target state="translated">선언 블록의 구문 분석 가능한 텍스트 표현입니다 (둘러싸는 중괄호 제외). 이 속성을 설정하면 새 값이 구문 분석되고 속성 제거 또는 추가를 포함하여 선언 블록의 모든 속성이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f344b8a3dae0b9a2ed9e7339cb6b96e27180e7ff" translate="yes" xml:space="preserve">
          <source>The parsable textual representation of the media list.</source>
          <target state="translated">미디어 목록의 구문 분석 가능한 텍스트 표현입니다.</target>
        </trans-unit>
        <trans-unit id="6847d7815246c2dffbbfce713fe44482b4d6e66f" translate="yes" xml:space="preserve">
          <source>The parsable textual representation of the media list. This is a comma-separated list of media.</source>
          <target state="translated">미디어 목록의 구문 분석 가능한 텍스트 표현입니다. 쉼표로 구분 된 미디어 목록입니다.</target>
        </trans-unit>
        <trans-unit id="16ff572ddaacf237b4fddf4460a1245ae5ba39f8" translate="yes" xml:space="preserve">
          <source>The parsable textual representation of the page selector for the rule.</source>
          <target state="translated">규칙에 대한 페이지 선택기의 구문 분석 가능한 텍스트 표현입니다.</target>
        </trans-unit>
        <trans-unit id="2c2ce014def84eab302481930994a5adcb82e900" translate="yes" xml:space="preserve">
          <source>The parsable textual representation of the rule.</source>
          <target state="translated">규칙의 구문 분석 가능한 텍스트 표현입니다.</target>
        </trans-unit>
        <trans-unit id="f633c2fa350868719d81450ea8eac37449681437" translate="yes" xml:space="preserve">
          <source>The parsable textual representation of the rule. This reflects the current state of the rule and not its initial value.</source>
          <target state="translated">규칙의 구문 분석 가능한 텍스트 표현입니다. 이는 초기 값이 아니라 규칙의 현재 상태를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="a34ccef159a0d71e1f63c70bb6fe8aedb77a7a54" translate="yes" xml:space="preserve">
          <source>The parsed value. Passing an integer that corresponds to a known name (e.g., 700) will return the associated name (e.g., &lt;code&gt;CONFIG&lt;/code&gt;). Passing an integer that does not (e.g., 1) will return a new level name initialized to that value.</source>
          <target state="translated">파싱 ​​된 값입니다. 알려진 이름 (예 : 700)에 해당하는 정수를 전달하면 관련 이름 (예 : &lt;code&gt;CONFIG&lt;/code&gt; ) 이 반환됩니다 . 그렇지 않은 정수 (예 : 1)를 전달하면 해당 값으로 초기화 된 새 수준 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c80c4671a6882e49c3c95f5d8d0a916dc52dfeed" translate="yes" xml:space="preserve">
          <source>The parser drives the ParserCallback, which is provided by HTMLDocument. To change the callback, subclass HTMLDocument and reimplement the createDefaultDocument method to return document that produces a different reader. The reader controls how the document is structured. Although the Document provides HTML support by default, there is nothing preventing support of non-HTML tags that result in alternative element structures.</source>
          <target state="translated">파서는 HTMLDocument에서 제공하는 ParserCallback을 구동합니다. 콜백을 변경하려면 HTMLDocument를 하위 클래스로 만들고 createDefaultDocument 메서드를 다시 구현하여 다른 판독기를 생성하는 문서를 반환합니다. 독자는 문서의 구조를 제어합니다. 문서는 기본적으로 HTML 지원을 제공하지만 대체 요소 구조를 생성하는 비 HTML 태그의 지원을 방해하는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="0958e538d194ee775ec5a4fae0f7ef159a0e04df" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 탐욕스럽게 작동하여 가능한 한 많은 숫자를받습니다. 이 동작은 '인접 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="21ff5f3cdc66539833c1fbafaf60db7a54685bb2" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 최대한 많은 자릿수를 허용하면서 탐욕스럽게 동작합니다. 이 동작은 '인접한 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c09eecf6e6b5152ce4eaa50a2e9cb6e5669cb3d" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, requiring one digit, but accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 탐욕스럽게 작동하여 한 자리가 필요하지만 가능한 한 많은 자리를 허용합니다. 이 동작은 '인접 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f6b73693478a0455ddabfd20c4e13a83419854e" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, requiring one digit, but accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 탐욕스럽게 동작하며 한 자리를 요구하지만 가능한 한 많은 자리를 받아들입니다. 이 동작은 '인접한 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b2566f1d573d8a0c323846050643ae43f48e34c" translate="yes" xml:space="preserve">
          <source>The parser is replaceable. The default parser is the Hot Java parser which is DTD based. A different DTD can be used, or an entirely different parser can be used. To change the parser, reimplement the getParser method. The default parser is dynamically loaded when first asked for, so the class files will never be loaded if an alternative parser is used. The default parser is in a separate package called parser below this package.</source>
          <target state="translated">파서는 교체 가능합니다. 기본 구문 분석기는 DTD 기반의 Hot Java 구문 분석기입니다. 다른 DTD를 사용하거나 완전히 다른 파서를 사용할 수 있습니다. 파서를 변경하려면 getParser 메서드를 다시 구현하십시오. 기본 구문 분석기는 처음 요청할 때 동적으로로드되므로 대체 구문 분석기가 사용되는 경우 클래스 파일이로드되지 않습니다. 기본 구문 분석기는이 패키지 아래의 구문 분석기라는 별도의 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db896e88ea1524b86eec66607087c03e131c1fe" translate="yes" xml:space="preserve">
          <source>The parser treats \r and \r\n as \n. Newlines after starttags and before end tags are ignored just as specified in the SGML/HTML specification.</source>
          <target state="translated">파서는 \ r 및 \ r \ n을 \ n으로 취급합니다. 시작 태그 뒤와 끝 태그 앞의 줄 바꿈은 SGML / HTML 사양에 지정된대로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f79566e8db3ace95b06a78c81cfb5c3a069df4ea" translate="yes" xml:space="preserve">
          <source>The parser will call this method after each &lt;code&gt;Element&lt;/code&gt; start tag has been scanned, but before the remainder of the &lt;code&gt;Element&lt;/code&gt; is processed.</source>
          <target state="translated">파서는 각 &lt;code&gt;Element&lt;/code&gt; 시작 태그를 스캔 한 후 나머지 &lt;code&gt;Element&lt;/code&gt; 가 처리 되기 전에이 메서드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="89bb0dda1c5e645ee858d42db8076dbafa59d5c5" translate="yes" xml:space="preserve">
          <source>The parser will call this method after each &lt;code&gt;Element&lt;/code&gt; start tag has been scanned, but before the remainder of the &lt;code&gt;Element&lt;/code&gt; is processed. The intent is to allow the element, including any children, to be efficiently skipped. Note that only element nodes are passed to the &lt;code&gt;startElement&lt;/code&gt; function.</source>
          <target state="translated">파서는 각 &lt;code&gt;Element&lt;/code&gt; 시작 태그를 스캔 한 후 나머지 &lt;code&gt;Element&lt;/code&gt; 가 처리 되기 전에이 메서드를 호출 합니다. 의도는 모든 자식을 포함하여 요소를 효율적으로 건너 뛸 수 있도록하는 것입니다. 요소 노드 만 &lt;code&gt;startElement&lt;/code&gt; 함수에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="25bb83472b4f57122efa4cb36da17a7150c525d7" translate="yes" xml:space="preserve">
          <source>The parser will call this method before opening any external entity except the top-level document entity. Such entities include the external DTD subset and external parameter entities referenced within the DTD (in either case, only if the parser reads external parameter entities), and external general entities referenced within the document element (if the parser reads external general entities). The application may request that the parser locate the entity itself, that it use an alternative URI, or that it use data provided by the application (as a character or byte input stream).</source>
          <target state="translated">파서는 최상위 문서 엔터티를 제외한 외부 엔터티를 열기 전에이 메서드를 호출합니다. 이러한 엔터티에는 DTD 내에서 참조되는 외부 DTD 하위 집합 및 외부 매개 변수 엔터티 (두 경우 모두 파서가 외부 매개 변수 엔터티를 읽는 경우에만 해당) 및 문서 요소 내에서 참조되는 외부 일반 엔터티 (파서가 외부 일반 엔터티를 읽는 경우)가 포함됩니다. 응용 프로그램은 파서가 엔티티 자체를 찾거나 대체 URI를 사용하거나 응용 프로그램에서 제공하는 데이터 (문자 또는 바이트 입력 스트림)를 사용하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ee7fce3ce38754400a5fb2ffa707a2159a2a86a" translate="yes" xml:space="preserve">
          <source>The parsing and conversion to a path object is inherently implementation dependent. In the simplest case, the path string is rejected, and &lt;a href=&quot;invalidpathexception&quot;&gt;&lt;code&gt;InvalidPathException&lt;/code&gt;&lt;/a&gt; thrown, if the path string contains characters that cannot be converted to characters that are &lt;em&gt;legal&lt;/em&gt; to the file store. For example, on UNIX systems, the NUL (\u0000) character is not allowed to be present in a path. An implementation may choose to reject path strings that contain names that are longer than those allowed by any file store, and where an implementation supports a complex path syntax, it may choose to reject path strings that are &lt;em&gt;badly formed&lt;/em&gt;.</source>
          <target state="translated">경로 객체에 대한 구문 분석 및 변환은 본질적으로 구현에 따라 다릅니다. 가장 간단한 경우, 경로 문자열 에 파일 저장소에 &lt;em&gt;적합한&lt;/em&gt; 문자로 변환 할 수없는 문자가 포함 된 경우 경로 문자열이 거부되고 &lt;a href=&quot;invalidpathexception&quot;&gt; &lt;code&gt;InvalidPathException&lt;/code&gt; 이&lt;/a&gt; 발생 합니다. 예를 들어, UNIX 시스템에서 NUL (\ u0000) 문자는 경로에 존재할 수 없습니다. 구현은 파일 저장소가 허용하는 것보다 긴 이름을 포함하는 경로 문자열을 거부하도록 선택할 수 있으며 구현이 복잡한 경로 구문을 지원하는 경우 &lt;em&gt;잘못 구성된&lt;/em&gt; 경로 문자열을 거부하도록 선택할 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58366cc3fc3392a36ac4de8d54ae2345f03badf0" translate="yes" xml:space="preserve">
          <source>The parsing is done field by field so that the following holds for any lexically correct String x:</source>
          <target state="translated">구문 분석은 필드별로 수행되므로 어휘 적으로 올바른 문자열 x에 대해 다음이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="70a1b9684ff0e071a82a4339efad58504e82add3" translate="yes" xml:space="preserve">
          <source>The part of the destination lying inside of the source is composited over the source and replaces the destination (Porter-Duff Destination Atop Source rule).</source>
          <target state="translated">소스 내부에있는 대상 부분은 소스 위에 합성되어 대상을 대체합니다 (Porter-Duff Destination Atop Source 규칙).</target>
        </trans-unit>
        <trans-unit id="1da589b57f7260e6e37c7640ceeaac089943225b" translate="yes" xml:space="preserve">
          <source>The part of the destination lying inside of the source replaces the destination (Porter-Duff Destination In Source rule).</source>
          <target state="translated">소스 내부에있는 대상 부분이 대상을 대체합니다 (소스의 Porter-Duff 대상 규칙).</target>
        </trans-unit>
        <trans-unit id="dcfe0a22ae97cb137aea5a3bbe6c1a59738245d0" translate="yes" xml:space="preserve">
          <source>The part of the destination lying outside of the source replaces the destination (Porter-Duff Destination Held Out By Source rule).</source>
          <target state="translated">소스 외부에있는 대상 부분이 대상을 대체합니다 (소스에 의해 보관 된 Porter-Duff 대상 규칙).</target>
        </trans-unit>
        <trans-unit id="0514c11ef515545f2db88b599f4ee46a343c496c" translate="yes" xml:space="preserve">
          <source>The part of the link name that has not been resolved. It is a composite name. It can be null, which means the link remaining name field has not been set.</source>
          <target state="translated">해결되지 않은 링크 이름 부분. 합성 이름입니다. 널 (null) 일 수 있으며, 이는 링크 나머지 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="47baf3ca1b3134d4434d6cb4c6eec321ec81a768" translate="yes" xml:space="preserve">
          <source>The part of the link name that was resolved successfully. It is a composite name. It can be null, which means the link resolved name field has not been set.</source>
          <target state="translated">성공적으로 해결 된 링크 이름 부분. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 링크 해석 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="32726d1c2037f095bb11ef491521f5e2b8d6ac95" translate="yes" xml:space="preserve">
          <source>The part of the name that has not been resolved. It is a composite name. It can be null, which means the remaining name field has not been set.</source>
          <target state="translated">확인되지 않은 이름의 일부입니다. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 나머지 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ec9433b1d02006377972147afe60dd9073ccb8e0" translate="yes" xml:space="preserve">
          <source>The part of the name that was resolved successfully. It is a composite name. It can be null, which means the resolved name field has not been set.</source>
          <target state="translated">성공적으로 해결 된 이름의 일부입니다. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 해석 된 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6d1c09fb04aadbb62a7a9fde5b33cff4c271e44c" translate="yes" xml:space="preserve">
          <source>The part of the source lying inside of the destination is composited onto the destination (Porter-Duff Source Atop Destination rule).</source>
          <target state="translated">목적지 내부에있는 소스의 일부는 목적지에 합성됩니다 (Porter-Duff Source Atop Destination 규칙).</target>
        </trans-unit>
        <trans-unit id="40baec417b1738d9f463750ccea01809d5a85bba" translate="yes" xml:space="preserve">
          <source>The part of the source lying inside of the destination replaces the destination (Porter-Duff Source In Destination rule).</source>
          <target state="translated">목적지 내부에있는 소스 부분이 목적지를 대체합니다 (Porter-Duff Source In Destination 규칙).</target>
        </trans-unit>
        <trans-unit id="0edd66952700232dfab5dd336b9d5a21df59003b" translate="yes" xml:space="preserve">
          <source>The part of the source lying outside of the destination replaces the destination (Porter-Duff Source Held Out By Destination rule).</source>
          <target state="translated">대상 외부에있는 원본 부분이 대상을 대체합니다 (대상에 의해 보관 된 Porter-Duff 원본 규칙).</target>
        </trans-unit>
        <trans-unit id="76bc3c459fb6e604ce60cb4e6b1d79dd10a65b80" translate="yes" xml:space="preserve">
          <source>The part of the source that lies outside of the destination is combined with the part of the destination that lies outside of the source (Porter-Duff Source Xor Destination rule).</source>
          <target state="translated">대상 외부에있는 원본 부분은 원본 외부에있는 대상 부분과 결합됩니다 (Porter-Duff Source Xor 대상 규칙).</target>
        </trans-unit>
        <trans-unit id="a0ccdd4edd6b9daa6601aef32f68b66801d49f2d" translate="yes" xml:space="preserve">
          <source>The particular &lt;code&gt;ImageReader&lt;/code&gt; implementation may choose how often to provide updates. Each update specifies that a given region of the image has been updated since the last update. A region is described by its spatial bounding box (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt;); X and Y subsampling factors (&lt;code&gt;periodX&lt;/code&gt; and &lt;code&gt;periodY&lt;/code&gt;); and a set of updated bands (&lt;code&gt;bands&lt;/code&gt;). For example, the update:</source>
          <target state="translated">특정 &lt;code&gt;ImageReader&lt;/code&gt; 구현은 업데이트를 제공하는 빈도를 선택할 수 있습니다. 각 업데이트는 마지막 업데이트 이후 이미지의 특정 영역이 업데이트되었음을 ​​지정합니다. 영역은 공간 경계 상자 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; )로 설명됩니다. X 및 Y 서브 샘플링 인자 ( &lt;code&gt;periodX&lt;/code&gt; 및 &lt;code&gt;periodY&lt;/code&gt; ); 및 업데이트 된 밴드 세트 ( &lt;code&gt;bands&lt;/code&gt; ). 예를 들어, 업데이트 :</target>
        </trans-unit>
        <trans-unit id="2d05bd905575708b902adb79797980be7e49876a" translate="yes" xml:space="preserve">
          <source>The particular compression scheme to be used can be specified by using the &lt;code&gt;setCompressionType()&lt;/code&gt; method with the appropriate type string. The compression scheme specified will be honored if and only if it is compatible with the type of image being written. If the specified compression scheme is not compatible with the type of image being written then the &lt;code&gt;IOException&lt;/code&gt; will be thrown by the BMP image writer. If the compression type is not set explicitly then &lt;code&gt;getCompressionType()&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;. In this case the BMP image writer will select a compression type that supports encoding of the given image without loss of the color resolution.</source>
          <target state="translated">사용되는 특정 압축 체계 는 적절한 유형 문자열과 함께 &lt;code&gt;setCompressionType()&lt;/code&gt; 메소드를 사용하여 지정할 수 있습니다 . 지정된 압축 방식은 작성중인 이미지 유형과 호환되는 경우에만 적용됩니다. 지정된 압축 방식이 기록중인 이미지 유형과 호환되지 않으면 BMP 이미지 기록기에 의해 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다. 압축 유형이 명시 적으로 설정되지 않은 경우 &lt;code&gt;getCompressionType()&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 이 경우 BMP 이미지 기록기는 색상 해상도 손실없이 지정된 이미지의 인코딩을 지원하는 압축 유형을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d678e3b47db28315a51c9392f3290d72efd52628" translate="yes" xml:space="preserve">
          <source>The passed in &lt;code&gt;Graphics&lt;/code&gt; object might have a transform other than the identify transform installed on it. In this case, you might get unexpected results if you cumulatively apply another transform.</source>
          <target state="translated">전달 된 &lt;code&gt;Graphics&lt;/code&gt; 객체에 식별 변환이 아닌 다른 변환이 설치되어있을 수 있습니다. 이 경우 다른 변환을 누적 적용하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8241d354a88f83dd6e313eef3dc68fb3e944175" translate="yes" xml:space="preserve">
          <source>The password can be viewed as some kind of raw key material, from which the encryption mechanism that uses it derives a cryptographic key.</source>
          <target state="translated">암호는 일종의 원시 키 자료로 볼 수 있으며,이를 사용하는 암호화 메커니즘은 암호 키를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="820e2577f359bf6935013e53ac3bf2a5b32541fa" translate="yes" xml:space="preserve">
          <source>The past notifications sending on/off flag value.</source>
          <target state="translated">과거 / 이전 알림 전송 / 해제 플래그 값.</target>
        </trans-unit>
        <trans-unit id="2dff58ea6e8968b95e225bc5373e375d5474c33c" translate="yes" xml:space="preserve">
          <source>The path</source>
          <target state="translated">경로</target>
        </trans-unit>
        <trans-unit id="34dc364ae2dbeed42a8b0e59b6b7f50e29642280" translate="yes" xml:space="preserve">
          <source>The path component of a URI, if defined, only contains the slash character (&lt;code&gt;'/'&lt;/code&gt;), the commercial-at character (&lt;code&gt;'@'&lt;/code&gt;), and characters in the</source>
          <target state="translated">URI의 경로 구성 요소에는 정의 된 경우 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; ), 상업 문자 ( &lt;code&gt;'@'&lt;/code&gt; ) 및</target>
        </trans-unit>
        <trans-unit id="ce374624d095692df597972be967a92da604ae1f" translate="yes" xml:space="preserve">
          <source>The path component of a hierarchical URI is itself said to be absolute if it begins with a slash character (&lt;code&gt;'/'&lt;/code&gt;); otherwise it is relative. The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.</source>
          <target state="translated">계층 적 URI의 경로 구성 요소는 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작하는 경우 절대적이라고합니다 . 그렇지 않으면 상대적입니다. 절대적이거나 권한을 지정하는 계층 적 URI의 경로는 항상 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="984a1006edcb13d7a44e0aa4a2152ea60b272a92" translate="yes" xml:space="preserve">
          <source>The path component of this URI, or &lt;code&gt;null&lt;/code&gt; if the path is undefined</source>
          <target state="translated">이 URI의 패스 컴퍼넌트 . 패스가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a70f79521a69bb3942223fa682e3262fee7ae26f" translate="yes" xml:space="preserve">
          <source>The path length constraint has been violated.</source>
          <target state="translated">경로 길이 제약 조건을 위반했습니다.</target>
        </trans-unit>
        <trans-unit id="9c2f7c86fc8f01ff7e4a59e3bc63da50bbfde30a" translate="yes" xml:space="preserve">
          <source>The path should generally, but is not required to, end with '/'. If the path does not end with '/', eg such as with &lt;code&gt;&quot;/foo&quot;&lt;/code&gt; then this would match requests with a path of &lt;code&gt;&quot;/foobar&quot;&lt;/code&gt; or &lt;code&gt;&quot;/foo/bar&quot;&lt;/code&gt;.</source>
          <target state="translated">경로는 일반적으로 '/'로 끝나야하지만 필수는 아닙니다. 예를 들어 &lt;code&gt;&quot;/foo&quot;&lt;/code&gt; 와 같이 경로가 '/'로 끝나지 않으면 경로가 &lt;code&gt;&quot;/foobar&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;/foo/bar&quot;&lt;/code&gt; 인 요청과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="79852855fbcc34d332e59a024d37902ef3399008" translate="yes" xml:space="preserve">
          <source>The path specifies the root URI path for this context. The first character of path must be '/'.</source>
          <target state="translated">경로는이 컨텍스트의 루트 URI 경로를 지정합니다. 경로의 첫 번째 문자는 '/'여야합니다.</target>
        </trans-unit>
        <trans-unit id="5c2d067f7af76e2b06945d71f3ec990142c7f99d" translate="yes" xml:space="preserve">
          <source>The pathname string of the parent directory named by this abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent</source>
          <target state="translated">이 추상 패스 명이 가리키는 친 디렉토리의 패스 명 문자열.이 패스 명이 부모를 나타내지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36815dfa099a2085beea9c4219c1336efe128f00" translate="yes" xml:space="preserve">
          <source>The paths returned from &lt;code&gt;getSelectionPaths&lt;/code&gt; are in the same order as those supplied to this method.</source>
          <target state="translated">&lt;code&gt;getSelectionPaths&lt;/code&gt; 에서 반환 된 경로는 이 메서드에 제공된 경로 와 동일한 순서입니다.</target>
        </trans-unit>
        <trans-unit id="44bfbe0740e4812ab2ebef01403857fd4763cbc0" translate="yes" xml:space="preserve">
          <source>The pattern for which this matcher was created</source>
          <target state="translated">이 매 처가 작성된 패턴</target>
        </trans-unit>
        <trans-unit id="36288d456902db8f2b6812d0fa34109886d1b2c0" translate="yes" xml:space="preserve">
          <source>The peer address</source>
          <target state="translated">피어 주소</target>
        </trans-unit>
        <trans-unit id="8d2c3487039ef25eb5545370e934fa95e28b34f7" translate="yes" xml:space="preserve">
          <source>The peer primary address of the association or the address that the message was sent to</source>
          <target state="translated">연결의 피어 기본 주소 또는 메시지가 전송 된 주소</target>
        </trans-unit>
        <trans-unit id="df695ca495032754cb1e1d72664b6f7e2ce057b1" translate="yes" xml:space="preserve">
          <source>The pen width, measured perpendicularly to the pen trajectory.</source>
          <target state="translated">펜 궤적에 수직으로 측정 된 펜 너비입니다.</target>
        </trans-unit>
        <trans-unit id="8070624d401231b6bc6ba43c5cd26c92a8154972" translate="yes" xml:space="preserve">
          <source>The performance of the programs can depend on your choice of the class to represent call sites. The above example used &lt;a href=&quot;support/simplerelinkablecallsite&quot;&gt;&lt;code&gt;SimpleRelinkableCallSite&lt;/code&gt;&lt;/a&gt;, but you might want to use &lt;a href=&quot;support/chainedcallsite&quot;&gt;&lt;code&gt;ChainedCallSite&lt;/code&gt;&lt;/a&gt; instead. You'll need to experiment and decide what fits your runtime the best. You can further subclass either of these or implement your own.</source>
          <target state="translated">프로그램의 성능은 호출 사이트를 나타내는 클래스 선택에 따라 달라질 수 있습니다. 위의 예에서는 &lt;a href=&quot;support/simplerelinkablecallsite&quot;&gt; &lt;code&gt;SimpleRelinkableCallSite&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;support/chainedcallsite&quot;&gt; &lt;code&gt;ChainedCallSite&lt;/code&gt; &lt;/a&gt; 대신 ChainedCallSite 를 사용할 수도 있습니다 . 런타임에 가장 적합한 것이 무엇인지 실험하고 결정해야합니다. 이들 중 하나를 추가로 서브 클래스하거나 직접 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="228163f26ece9e76769fe19d43640bb8467f3d60" translate="yes" xml:space="preserve">
          <source>The period added is a multiple of this unit. For example, this method could be used to add &quot;3 days&quot; to a date by calling this method on the instance representing &quot;days&quot;, passing the date and the period &quot;3&quot;. The period to be added may be negative, which is equivalent to subtraction.</source>
          <target state="translated">추가 된 기간은이 단위의 배수입니다. 예를 들어, &quot;days&quot;를 나타내는 인스턴스에서이 메소드를 호출하고 날짜와 기간을 &quot;3&quot;으로 전달하여이 메소드를 사용하여 날짜에 &quot;3 일&quot;을 추가 할 수 있습니다. 더해지는주기는 음수 일 수 있으며, 이는 빼기와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fdc88c8af0c7b558ba1c4c23f7e65140ebfa762" translate="yes" xml:space="preserve">
          <source>The period character &lt;code&gt;'.'&lt;/code&gt; (&lt;code&gt;'\u002e'&lt;/code&gt;, &lt;small&gt;FULL STOP&lt;/small&gt;),</source>
          <target state="translated">마침표 문자 &lt;code&gt;'.'&lt;/code&gt; ( &lt;code&gt;'\u002e'&lt;/code&gt; , 완전 &lt;small&gt;정지&lt;/small&gt; ),</target>
        </trans-unit>
        <trans-unit id="8a43a4749a0092ff01f681602eba4d1752639395" translate="yes" xml:space="preserve">
          <source>The period is defined by the chronology. It controls the supported units and restricts addition/subtraction to &lt;code&gt;ChronoLocalDate&lt;/code&gt; instances of the same chronology.</source>
          <target state="translated">기간은 연대기에 의해 정의됩니다. 지원되는 단위를 제어하고 같은 연대기의 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 인스턴스에 더하기 / 빼기를 ​​제한 합니다.</target>
        </trans-unit>
        <trans-unit id="1a70990b9e6545d7eddd1d2d67af5b8ba6080247" translate="yes" xml:space="preserve">
          <source>The period is modeled as a directed amount of time, meaning that individual parts of the period may be negative.</source>
          <target state="translated">기간은 지정된 시간으로 모델링되므로 기간의 개별 부분이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582b9e9609272bc13dc68aa8a72ae7a31ac8a03b" translate="yes" xml:space="preserve">
          <source>The permission for which the &lt;code&gt;SecurityManager&lt;/code&gt; will check when code that is running an application with a &lt;code&gt;SecurityManager&lt;/code&gt; enabled, calls the &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; (deprecated) method, &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; method, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; method, &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; method, or the &lt;code&gt;Connection.abort&lt;/code&gt; method.</source>
          <target state="translated">있는 권한 &lt;code&gt;SecurityManager&lt;/code&gt; A의 응용 프로그램 실행시 코드를 확인합니다 &lt;code&gt;SecurityManager&lt;/code&gt; 사용할 수는 호출 &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; 메소드 (추천되지 않는다), &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; 의 방법, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; 의 , 방법을 &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; 메서드 또는 &lt;code&gt;Connection.abort&lt;/code&gt; 메서드.</target>
        </trans-unit>
        <trans-unit id="7596472c88903a656ba2e77a47db428db58c9b86" translate="yes" xml:space="preserve">
          <source>The permission for which the &lt;code&gt;SecurityManager&lt;/code&gt; will check when code that is running an application with a &lt;code&gt;SecurityManager&lt;/code&gt; enabled, calls the &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; method, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; (deprecated) method, &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; method, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; method, &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; method, or the &lt;code&gt;Connection.abort&lt;/code&gt; method. If there is no &lt;code&gt;SQLPermission&lt;/code&gt; object, these methods throw a &lt;code&gt;java.lang.SecurityException&lt;/code&gt; as a runtime exception.</source>
          <target state="translated">있는 권한 &lt;code&gt;SecurityManager&lt;/code&gt; A의 응용 프로그램 실행시 코드를 확인합니다 &lt;code&gt;SecurityManager&lt;/code&gt; 사용할 수는 호출 &lt;code&gt;DriverManager.deregisterDriver&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogWriter&lt;/code&gt; 의 방법, &lt;code&gt;DriverManager.setLogStream&lt;/code&gt; 메소드 (추천되지 않는다), &lt;code&gt;SyncFactory.setJNDIContext&lt;/code&gt; 의 방법, &lt;code&gt;SyncFactory.setLogger&lt;/code&gt; 의 , 방법을 &lt;code&gt;Connection.setNetworkTimeout&lt;/code&gt; 메서드 또는 &lt;code&gt;Connection.abort&lt;/code&gt; 메서드. &lt;code&gt;SQLPermission&lt;/code&gt; 오브젝트 가없는 경우 이러한 메소드 는 런타임 예외로 &lt;code&gt;java.lang.SecurityException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="905e0e83c9c4d3f7868b0477d055820ab11f5e8d" translate="yes" xml:space="preserve">
          <source>The permission returned may dependent upon the state of the connection. For example, the permission before connecting may be different from that after connecting. For example, an HTTP sever, say foo.com, may redirect the connection to a different host, say bar.com. Before connecting the permission returned by the connection will represent the permission needed to connect to foo.com, while the permission returned after connecting will be to bar.com.</source>
          <target state="translated">반환 된 권한은 연결 상태에 따라 달라질 수 있습니다. 예를 들어 연결 전의 권한이 연결 후의 권한과 다를 수 있습니다. 예를 들어 foo.com과 같은 HTTP 서버는 다른 호스트 (예 : bar.com)로 연결을 리디렉션 할 수 있습니다. 연결 전에 반환 된 권한은 foo.com에 연결하는 데 필요한 권한을 나타내며 연결 후 반환 된 권한은 bar.com입니다.</target>
        </trans-unit>
        <trans-unit id="9aec82e1b8e6d992b0690a908ac3aedc9b31e177" translate="yes" xml:space="preserve">
          <source>The permission which the SecurityManager will check when code that is running with a SecurityManager calls methods defined in the management interface for the Java platform.</source>
          <target state="translated">SecurityManager로 실행되는 코드가 Java 플랫폼의 관리 인터페이스에 정의 된 메소드를 호출 할 때 SecurityManager가 확인하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="e5faa7a6949030f63d05138d5d40aa6ac04a730d" translate="yes" xml:space="preserve">
          <source>The permission which the SecurityManager will check when code that is running with a SecurityManager calls one of the logging control methods (such as Logger.setLevel).</source>
          <target state="translated">SecurityManager로 실행중인 코드가 로깅 제어 방법 중 하나 (예 : Logger.setLevel)를 호출 할 때 SecurityManager가 확인하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="67f61541f09f163aad875955ec40973cb856f479" translate="yes" xml:space="preserve">
          <source>The permissions granted to this domain are dynamic, i.e. invoking the &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt;&lt;code&gt;staticPermissionsOnly()&lt;/code&gt;&lt;/a&gt; method returns false. They include both the static permissions passed to this constructor, and any permissions granted to this domain by the current Policy at the time a permission is checked.</source>
          <target state="translated">이 도메인에 부여 된 권한은 동적입니다. 즉, &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt; &lt;code&gt;staticPermissionsOnly()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하면 false가 반환됩니다. 여기에는이 생성자에 전달 된 정적 권한과 권한을 확인할 때 현재 정책에서이 도메인에 부여한 모든 권한이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c63c09e1919a0b385305981a2835a097860b9eda" translate="yes" xml:space="preserve">
          <source>The permissions granted to this domain are static, i.e. invoking the &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt;&lt;code&gt;staticPermissionsOnly()&lt;/code&gt;&lt;/a&gt; method returns true. They contain only the ones passed to this constructor and the current Policy will not be consulted.</source>
          <target state="translated">이 도메인에 부여 된 권한은 정적입니다. 즉, &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt; &lt;code&gt;staticPermissionsOnly()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하면 true가 반환됩니다. 여기에는이 생성자에 전달 된 항목 만 포함되며 현재 정책은 참조되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89058a6566fae0c8d5c5fdda2b2372f796569fb3" translate="yes" xml:space="preserve">
          <source>The physical connection is not closed until the connection pool manager calls the &lt;code&gt;PooledConnection&lt;/code&gt; method &lt;code&gt;close&lt;/code&gt;. This method is generally called to have an orderly shutdown of the server or if a fatal error has made the connection unusable.</source>
          <target state="translated">연결 풀 관리자가 &lt;code&gt;PooledConnection&lt;/code&gt; 메소드 &lt;code&gt;close&lt;/code&gt; 를 호출 할 때까지 물리적 연결은 닫히지 않습니다 . 이 메서드는 일반적으로 서버를 순서대로 종료하거나 치명적인 오류로 인해 연결을 사용할 수 없게 된 경우 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63cef99a21c3ce784ef3880657559d49f21aea55" translate="yes" xml:space="preserve">
          <source>The pixel (0, 0) in the coordinate space of the graphics context corresponds to the origin of the splash screen native window bounds (see &lt;a href=&quot;#getBounds()&quot;&gt;&lt;code&gt;getBounds()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">그래픽 컨텍스트의 좌표 공간에있는 픽셀 (0, 0)은 스플래시 화면 기본 창 경계의 원점에 해당합니다 ( &lt;a href=&quot;#getBounds()&quot;&gt; &lt;code&gt;getBounds()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="500d2293e97237119e1983a5c3e9a605e180c0c9" translate="yes" xml:space="preserve">
          <source>The pixels of the image are delivered using one or more calls to the setPixels method.</source>
          <target state="translated">이미지의 픽셀은 setPixels 메소드에 대한 하나 이상의 호출을 사용하여 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b32a76182c825641c5cc61b6489eb4335615b5b4" translate="yes" xml:space="preserve">
          <source>The pixels of the image are delivered using one or more calls to the setPixels method. Each call specifies the location and size of the rectangle of source pixels that are contained in the array of pixels. The specified ColorModel object should be used to convert the pixels into their corresponding color and alpha components. Pixel (m,n) is stored in the pixels array at index (n * scansize + m + off). The pixels delivered using this method are all stored as ints. this method are all stored as ints.</source>
          <target state="translated">이미지의 픽셀은 setPixels 메소드에 대한 하나 이상의 호출을 사용하여 전달됩니다. 각 호출은 픽셀 배열에 포함 된 소스 픽셀 사각형의 위치와 크기를 지정합니다. 지정된 ColorModel 객체를 사용하여 픽셀을 해당 색상 및 알파 구성 요소로 변환해야합니다. 픽셀 (m, n)은 인덱스 (n * scansize + m + off)에서 픽셀 배열에 저장됩니다. 이 방법을 사용하여 전달 된 픽셀은 모두 int로 저장됩니다. 이 메서드는 모두 int로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f611275393252bc802d72fdd641a2615171a85f6" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in (multiples of) complete scanlines at a time.</source>
          <target state="translated">픽셀은 한 번에 (여러 개의) 완전한 스캔 라인으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2fece7997ef4b9cf1e323d0a1efd50cb013153b0" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a random order.</source>
          <target state="translated">The pixels will be delivered in a random order.</target>
        </trans-unit>
        <trans-unit id="cf16e6291c890f1d381931538f7295e2f5706d87" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a random order. This tells the ImageConsumer not to use any optimizations that depend on the order of pixel delivery, which should be the default assumption in the absence of any call to the setHints method.</source>
          <target state="translated">The pixels will be delivered in a random order. This tells the ImageConsumer not to use any optimizations that depend on the order of pixel delivery, which should be the default assumption in the absence of any call to the setHints method.</target>
        </trans-unit>
        <trans-unit id="9c2099a9c74f962fd6a4d8576f2e1d315893b01f" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a single pass.</source>
          <target state="translated">The pixels will be delivered in a single pass.</target>
        </trans-unit>
        <trans-unit id="92bb6ee63ae68c3bc426e959c05f0f0b4310d5a1" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in a single pass. Each pixel will appear in only one call to any of the setPixels methods. An example of an image format which does not meet this criterion is a progressive JPEG image which defines pixels in multiple passes, each more refined than the previous.</source>
          <target state="translated">The pixels will be delivered in a single pass. Each pixel will appear in only one call to any of the setPixels methods. An example of an image format which does not meet this criterion is a progressive JPEG image which defines pixels in multiple passes, each more refined than the previous.</target>
        </trans-unit>
        <trans-unit id="6310f53f396133fc271c197615afe20c6a96988b" translate="yes" xml:space="preserve">
          <source>The pixels will be delivered in top-down, left-to-right order.</source>
          <target state="translated">The pixels will be delivered in top-down, left-to-right order.</target>
        </trans-unit>
        <trans-unit id="9d90b3b0c7f4fd76e2cdd5db2a7c785664e9f012" translate="yes" xml:space="preserve">
          <source>The placeholder parameters set with the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods are stored as objects in an internal &lt;code&gt;Hashtable&lt;/code&gt; object. Primitives are stored as their &lt;code&gt;Object&lt;/code&gt; type. For example, &lt;code&gt;byte&lt;/code&gt; is stored as &lt;code&gt;Byte&lt;/code&gt; object, and &lt;code&gt;int&lt;/code&gt; is stored as an &lt;code&gt;Integer&lt;/code&gt; object. When the method &lt;code&gt;execute&lt;/code&gt; is called, the values in the &lt;code&gt;Hashtable&lt;/code&gt; object are substituted for the appropriate placeholder parameters in the command.</source>
          <target state="translated">The placeholder parameters set with the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods are stored as objects in an internal &lt;code&gt;Hashtable&lt;/code&gt; object. Primitives are stored as their &lt;code&gt;Object&lt;/code&gt; type. For example, &lt;code&gt;byte&lt;/code&gt; is stored as &lt;code&gt;Byte&lt;/code&gt; object, and &lt;code&gt;int&lt;/code&gt; is stored as an &lt;code&gt;Integer&lt;/code&gt; object. When the method &lt;code&gt;execute&lt;/code&gt; is called, the values in the &lt;code&gt;Hashtable&lt;/code&gt; object are substituted for the appropriate placeholder parameters in the command.</target>
        </trans-unit>
        <trans-unit id="a342a1ca910ba03ac856dd3cb6b496330e72e4ed" translate="yes" xml:space="preserve">
          <source>The placement of the scrollbars is controlled by platform-specific properties set by the user outside of the program.</source>
          <target state="translated">The placement of the scrollbars is controlled by platform-specific properties set by the user outside of the program.</target>
        </trans-unit>
        <trans-unit id="75c5e59d7fc130499537b22ca3f6a19ddfdef68a" translate="yes" xml:space="preserve">
          <source>The plain style constant.</source>
          <target state="translated">The plain style constant.</target>
        </trans-unit>
        <trans-unit id="5a84f21cac12242c01031819d62ec386192e9637" translate="yes" xml:space="preserve">
          <source>The platform &lt;code&gt;ClassLoader&lt;/code&gt;.</source>
          <target state="translated">The platform &lt;code&gt;ClassLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc9ede0436d0d5baf4766a8ab07e168116dd1bc" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, &lt;code&gt;toIntExact&lt;/code&gt;, &lt;code&gt;incrementExact&lt;/code&gt;, &lt;code&gt;decrementExact&lt;/code&gt; and &lt;code&gt;negateExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For the arithmetic operations divide and absolute value, overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">플랫폼은 int 및 long 프리미티브 유형이있는 부호있는 2의 보수 정수 산술을 사용합니다. 개발자는 산술 연산이 일관되게 올바른 결과를 생성하도록 기본 유형을 선택해야합니다. 이는 경우에 따라 연산이 연산 값의 범위를 오버플로하지 않음을 의미합니다. 가장 좋은 방법은 오버플로를 방지하기 위해 기본 유형과 알고리즘을 선택하는 것입니다. 크기가 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 이고 오버플로 오류를 감지해야하는 경우 &lt;code&gt;addExact&lt;/code&gt; , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; , &lt;code&gt;toIntExact&lt;/code&gt; , &lt;code&gt;incrementExact&lt;/code&gt; , &lt;code&gt;decrementExact&lt;/code&gt; 및 &lt;code&gt;negateExact&lt;/code&gt; 메서드 는 &lt;code&gt;ArithmeticException&lt;/code&gt; 결과가 오버플로되는 경우 ArithmeticException 입니다. 산술 연산 나누기 및 절대 값의 경우 특정 최소값 또는 최대 값에서만 오버플로가 발생하며 적절한 최소값 또는 최대 값과 비교하여 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d191e3661c045abc37d149ffba48109cff4ab5bb" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt; , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; , and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</target>
        </trans-unit>
        <trans-unit id="2ceb5ca739bd037a631c6a8df267fc3ed5ce1040" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation, overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt; , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; , and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment by one, decrement by one, and negation, overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</target>
        </trans-unit>
        <trans-unit id="3ddf2138bdbeea3a72c2017234d8cedbfdba2c4d" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment, decrement, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">이 플랫폼은 int 및 long 기본 유형의 부호있는 2의 보수 정수 산술을 사용합니다. 개발자는 산술 연산이 일관되게 올바른 결과를 생성 할 수 있도록 기본 유형을 선택해야합니다. 어떤 경우에는 연산이 계산의 값 범위를 오버플로하지 않습니다. 가장 좋은 방법은 오버플로를 피하기 위해 기본 유형과 알고리즘을 선택하는 것입니다. 크기가 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 이고 오버플로 오류를 감지 &lt;code&gt;addExact&lt;/code&gt; 경우 addExact , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; 및 &lt;code&gt;toIntExact&lt;/code&gt; 메소드 에서 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생합니다.결과가 오버플로 될 때 나누기, 절대 값, 증분, 감소 및 부정 오버플로와 같은 다른 산술 연산의 경우 특정 최소값 또는 최대 값으로 만 발생하며, 최소값 또는 최대 값에 대해 적절하게 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7521e50eec810dafda8ec390ca964f1fb534790" translate="yes" xml:space="preserve">
          <source>The plus character &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;, &lt;small&gt;PLUS SIGN&lt;/small&gt;),</source>
          <target state="translated">더하기 문자 &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;'\u002b'&lt;/code&gt; , &lt;small&gt;PLUS SIGN&lt;/small&gt; ),</target>
        </trans-unit>
        <trans-unit id="8de422a879c63cd1d08f600a6e2474b68479ffa1" translate="yes" xml:space="preserve">
          <source>The plus sign &quot;&lt;code&gt;+&lt;/code&gt;&quot; is converted into a space character &quot; &quot; .</source>
          <target state="translated">더하기 부호 &quot; &lt;code&gt;+&lt;/code&gt; &quot;는 공백 문자 &quot;&quot;로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e85f9897d05dda5c28cb4704b1031cfc583d8bdb" translate="yes" xml:space="preserve">
          <source>The point size of this &lt;code&gt;Font&lt;/code&gt; in &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">The point size of this &lt;code&gt;Font&lt;/code&gt; in &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e05bc968c4e3e94ec2209d4abaf443fe21787fa" translate="yes" xml:space="preserve">
          <source>The point size of this &lt;code&gt;Font&lt;/code&gt;, rounded to integer.</source>
          <target state="translated">The point size of this &lt;code&gt;Font&lt;/code&gt; , rounded to integer.</target>
        </trans-unit>
        <trans-unit id="770068703e30a0ae5899254519c58354757383e7" translate="yes" xml:space="preserve">
          <source>The policies can be certificate-based or may depend on other authentication schemes.</source>
          <target state="translated">정책은 인증서 기반이거나 다른 인증 체계에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9410b63b7333b991d16e974b0ea1ae55586212" translate="yes" xml:space="preserve">
          <source>The policy constraints have been violated.</source>
          <target state="translated">정책 제약 조건이 위반되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b63ad61faf90a50a857b840faad61a57d9a475d" translate="yes" xml:space="preserve">
          <source>The policy for a Java runtime (specifying which permissions are available for code from various principals) is represented by a Policy object. Whenever a Policy is initialized or refreshed, Permission objects of appropriate classes are created for all permissions allowed by the Policy.</source>
          <target state="translated">Java 런타임에 대한 정책 (다양한 주체의 코드에 사용 가능한 권한 지정)은 Policy 개체로 표시됩니다. 정책을 초기화하거나 새로 고칠 때마다 정책에서 허용하는 모든 권한에 대해 적절한 클래스의 권한 개체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="744c3ae06df1c4965a33f02db62c6df02c922313" translate="yes" xml:space="preserve">
          <source>The poolable value of a statement is applicable to both internal statement caches implemented by the driver and external statement caches implemented by application servers and other applications.</source>
          <target state="translated">The poolable value of a statement is applicable to both internal statement caches implemented by the driver and external statement caches implemented by application servers and other applications.</target>
        </trans-unit>
        <trans-unit id="82fae92e0d4dd371e91f2864a390bac7d0eb3216" translate="yes" xml:space="preserve">
          <source>The pooled connection closed by the application</source>
          <target state="translated">The pooled connection closed by the application</target>
        </trans-unit>
        <trans-unit id="dfaf71328abec9e71a671eccc845d3121c2b0845" translate="yes" xml:space="preserve">
          <source>The pooling manager does not need to call &lt;code&gt;beginRequest&lt;/code&gt; if:</source>
          <target state="translated">The pooling manager does not need to call &lt;code&gt;beginRequest&lt;/code&gt; if:</target>
        </trans-unit>
        <trans-unit id="92fa2d336d7c8160e103bf987c4391a790f21b4b" translate="yes" xml:space="preserve">
          <source>The pooling manager does not need to call &lt;code&gt;endRequest&lt;/code&gt; if:</source>
          <target state="translated">The pooling manager does not need to call &lt;code&gt;endRequest&lt;/code&gt; if:</target>
        </trans-unit>
        <trans-unit id="e90b45718cda98d6bea32baefe82cd6640d8dea0" translate="yes" xml:space="preserve">
          <source>The pooling manager should call &lt;code&gt;beginRequest&lt;/code&gt; on the underlying connection prior to returning a connection to the caller.</source>
          <target state="translated">The pooling manager should call &lt;code&gt;beginRequest&lt;/code&gt; on the underlying connection prior to returning a connection to the caller.</target>
        </trans-unit>
        <trans-unit id="167dc5ab45ec38b0cd73d7df03608399509bba35" translate="yes" xml:space="preserve">
          <source>The pooling manager should call &lt;code&gt;endRequest&lt;/code&gt; on the underlying connection when the applications returns the connection back to the connection pool.</source>
          <target state="translated">The pooling manager should call &lt;code&gt;endRequest&lt;/code&gt; on the underlying connection when the applications returns the connection back to the connection pool.</target>
        </trans-unit>
        <trans-unit id="6926313f48d16c7d56d1e2313f5a4569737b892b" translate="yes" xml:space="preserve">
          <source>The popup layer displays above dialogs. That way, the popup windows associated with combo boxes, tooltips, and other help text will appear above the component, palette, or dialog that generated them.</source>
          <target state="translated">The popup layer displays above dialogs. That way, the popup windows associated with combo boxes, tooltips, and other help text will appear above the component, palette, or dialog that generated them.</target>
        </trans-unit>
        <trans-unit id="2fdaf80d95e0f5e31151be71383e818b9ccadd36" translate="yes" xml:space="preserve">
          <source>The port component of a URI, if defined, is a non-negative integer.</source>
          <target state="translated">URI의 포트 구성 요소는 정의 된 경우 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="465e20b5e3d6b616ff936762b108d3831a17ee64" translate="yes" xml:space="preserve">
          <source>The port component of this URI, or &lt;code&gt;-1&lt;/code&gt; if the port is undefined</source>
          <target state="translated">이 URI의 포트 컴퍼넌트 . 포트가 정의되어 있지 않은 경우는 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2770c496726c2c6a1fb08bb232925adc856e5e7f" translate="yes" xml:space="preserve">
          <source>The port number on the remote host to which this socket is connected.</source>
          <target state="translated">이 소켓이 연결된 원격 호스트의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="771f8b79eb7ead72cd42f8874261ce51d5e9642c" translate="yes" xml:space="preserve">
          <source>The port of the Service URL.</source>
          <target state="translated">The port of the Service URL.</target>
        </trans-unit>
        <trans-unit id="17cb13d2105c7d415ffa295626d4a87fddb85329" translate="yes" xml:space="preserve">
          <source>The port of the Service URL. If no port was specified, the returned value is 0.</source>
          <target state="translated">서비스 URL의 포트입니다. 포트가 지정되지 않은 경우 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="356c1293f756ffbef5fc572bed0d988e81455650" translate="yes" xml:space="preserve">
          <source>The port or portrange is optional. A port specification of the form &quot;N-&quot;, where</source>
          <target state="translated">포트 또는 포트 범위는 선택 사항입니다. &quot;N-&quot;형식의 포트 사양. 여기서</target>
        </trans-unit>
        <trans-unit id="f7a3255c4428117efb808f78d07d1a509a065fee" translate="yes" xml:space="preserve">
          <source>The port to lookup the activation system.</source>
          <target state="translated">The port to lookup the activation system.</target>
        </trans-unit>
        <trans-unit id="a50d6c96a3e4d969a207bbe35ece3c77d64fdbff" translate="yes" xml:space="preserve">
          <source>The portion of a private use subtag prefixed by &quot;lvariant&quot;, if any, is removed and appended to the variant field in the result locale (without case normalization). If it is then empty, the private use subtag is discarded:</source>
          <target state="translated">접두사 &quot;lvariant&quot;가있는 개인용 사용 서브 태그의 부분 (있는 경우)이 제거되고 결과 로케일의 변형 필드에 추가됩니다 (사례 정규화없이). 비어있는 경우 개인용 하위 태그는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dade22179ed59dcfbad33f06553c3e366962e9c8" translate="yes" xml:space="preserve">
          <source>The position</source>
          <target state="translated">위치</target>
        </trans-unit>
        <trans-unit id="be4c1197eaffc124cfb0f83a9e8a33d8b6aa4a29" translate="yes" xml:space="preserve">
          <source>The position argument will indicate the start of the tag, comment or text. Similar to arrays, the first character in the stream has a position of 0. For tags that are implied the position will indicate the location of the next encountered tag. In the first example, the implied start body and html tags will have the same position as the p tag, and the implied end p, html and body tags will all have the same position.</source>
          <target state="translated">The position argument will indicate the start of the tag, comment or text. Similar to arrays, the first character in the stream has a position of 0. For tags that are implied the position will indicate the location of the next encountered tag. In the first example, the implied start body and html tags will have the same position as the p tag, and the implied end p, html and body tags will all have the same position.</target>
        </trans-unit>
        <trans-unit id="e928e79ce165a52965e64d8e1b2549cc6465990b" translate="yes" xml:space="preserve">
          <source>The position for the title.</source>
          <target state="translated">The position for the title.</target>
        </trans-unit>
        <trans-unit id="9d1f5a30624f167466c9de353c1c87fe46188eb5" translate="yes" xml:space="preserve">
          <source>The position of a component within a layer can also be specified directly. Valid positions range from 0 up to one less than the number of components in that layer. A value of -1 indicates the bottommost position. A value of 0 indicates the topmost position. Unlike layer numbers, higher position values are</source>
          <target state="translated">The position of a component within a layer can also be specified directly. Valid positions range from 0 up to one less than the number of components in that layer. A value of -1 indicates the bottommost position. A value of 0 indicates the topmost position. Unlike layer numbers, higher position values are</target>
        </trans-unit>
        <trans-unit id="9aa972c882e959af5cfa74686b743fa2cca90fbe" translate="yes" xml:space="preserve">
          <source>The position of mark in buffer.</source>
          <target state="translated">버퍼에서 마크의 위치.</target>
        </trans-unit>
        <trans-unit id="52e63aae911feb5735dffb853de1c4d06a2d4958" translate="yes" xml:space="preserve">
          <source>The position of the first mismatched byte, or</source>
          <target state="translated">일치하지 않는 첫 번째 바이트의 위치 또는</target>
        </trans-unit>
        <trans-unit id="5a10a32b9ba1b850952eb01a2dac5b8e40ece025" translate="yes" xml:space="preserve">
          <source>The position of this buffer</source>
          <target state="translated">이 버퍼의 위치</target>
        </trans-unit>
        <trans-unit id="e14f14e3eeac65815857675924c0f85fa97086c5" translate="yes" xml:space="preserve">
          <source>The position prior to which data may be discarded.</source>
          <target state="translated">The position prior to which data may be discarded.</target>
        </trans-unit>
        <trans-unit id="c4ecb0a7945551375751ca2e25e871a33f35f2b7" translate="yes" xml:space="preserve">
          <source>The position prior to which data may be discarded. Seeking to a smaller position is not allowed. &lt;code&gt;flushedPos&lt;/code&gt; will always be &amp;gt;= 0.</source>
          <target state="translated">데이터를 버릴 수있는 위치입니다. 더 작은 위치를 찾는 것은 허용되지 않습니다. &lt;code&gt;flushedPos&lt;/code&gt; 는 항상&amp;gt; = 0입니다.</target>
        </trans-unit>
        <trans-unit id="b019f8134a25cd17d205f23f036ec08fa24eb150" translate="yes" xml:space="preserve">
          <source>The position within the pushback buffer from which the next byte will be read.</source>
          <target state="translated">The position within the pushback buffer from which the next byte will be read.</target>
        </trans-unit>
        <trans-unit id="ce0957d483aceb3b45553d641f8c629ba289ca24" translate="yes" xml:space="preserve">
          <source>The position within the pushback buffer from which the next byte will be read. When the buffer is empty, &lt;code&gt;pos&lt;/code&gt; is equal to &lt;code&gt;buf.length&lt;/code&gt;; when the buffer is full, &lt;code&gt;pos&lt;/code&gt; is equal to zero.</source>
          <target state="translated">다음 바이트를 읽을 푸시 백 버퍼 내의 위치입니다. 버퍼가 비어 있으면 &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;buf.length&lt;/code&gt; 와 같습니다 . 버퍼가 가득 차면 &lt;code&gt;pos&lt;/code&gt; 는 0과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2697068a8ce2370b45252b0381024224e1a033b6" translate="yes" xml:space="preserve">
          <source>The positions tracking change are also generally cheap to maintain. The Position implementations (marks) store the array index and can easily calculate the sequential position from the current gap location. Changes only require update to the the marks between the old and new gap boundaries when the gap is moved, so generally updating the marks is pretty cheap. The marks are stored sorted so they can be located quickly with a binary search. This increases the cost of adding a mark, and decreases the cost of keeping the mark updated.</source>
          <target state="translated">The positions tracking change are also generally cheap to maintain. The Position implementations (marks) store the array index and can easily calculate the sequential position from the current gap location. Changes only require update to the the marks between the old and new gap boundaries when the gap is moved, so generally updating the marks is pretty cheap. The marks are stored sorted so they can be located quickly with a binary search. This increases the cost of adding a mark, and decreases the cost of keeping the mark updated.</target>
        </trans-unit>
        <trans-unit id="7548ff65d5ee10f38621f470acbd0447c4140b54" translate="yes" xml:space="preserve">
          <source>The possible actions are these:</source>
          <target state="translated">가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30057bbd133f892768abece91c4328fc6c016d37" translate="yes" xml:space="preserve">
          <source>The possible actions are:</source>
          <target state="translated">가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07e57a756aabf195e2b55eca8c76dad211c93a86" translate="yes" xml:space="preserve">
          <source>The possible attribute values</source>
          <target state="translated">The possible attribute values</target>
        </trans-unit>
        <trans-unit id="cf6fa0c1ab6538a58254ad393e6c38d337097a65" translate="yes" xml:space="preserve">
          <source>The possible constraints objects (Strings) are:</source>
          <target state="translated">The possible constraints objects (Strings) are:</target>
        </trans-unit>
        <trans-unit id="35dfa121a2fd6c8bb8d45be45d834b7cd54ad632" translate="yes" xml:space="preserve">
          <source>The possible implementations and return values have been modified in the Java 2 SDK, Standard Edition, version 1.3 to accommodate the option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</source>
          <target state="translated">The possible implementations and return values have been modified in the Java 2 SDK, Standard Edition, version 1.3 to accommodate the option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</target>
        </trans-unit>
        <trans-unit id="b36238ad8a3ea91b1260f9601a23cb5d54279a3f" translate="yes" xml:space="preserve">
          <source>The possible return values for this method were modified for the Java 2 SDK, Standard Edition, version 1.3. This was done to accommodate the new option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</source>
          <target state="translated">The possible return values for this method were modified for the Java 2 SDK, Standard Edition, version 1.3. This was done to accommodate the new option of continuing to process commands in a batch update after a &lt;code&gt;BatchUpdateException&lt;/code&gt; object has been thrown.</target>
        </trans-unit>
        <trans-unit id="7b7bd960ee00d4b00678a55c5cbb406785c27c39" translate="yes" xml:space="preserve">
          <source>The possible target names for an Authentication Permission are:</source>
          <target state="translated">인증 권한의 가능한 대상 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a3e78cdd39c4f87760b3390e7efcd189cdc7308" translate="yes" xml:space="preserve">
          <source>The possible ways to connect to the host are</source>
          <target state="translated">호스트에 연결하는 가능한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="080f48b0aa6b32cedd5af01121bd7b1bfc958102" translate="yes" xml:space="preserve">
          <source>The possibly null ID of the bad attribute.</source>
          <target state="translated">잘못된 속성의 null ID 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b7991f6067c19c449119e08d159087dc4972217" translate="yes" xml:space="preserve">
          <source>The possibly null address contents.</source>
          <target state="translated">가능한 null 주소 내용.</target>
        </trans-unit>
        <trans-unit id="4ed5af77681adda9a6ccec629fa59a1a47e0566d" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index &lt;code&gt;ix&lt;/code&gt; that was removed; null if the attribute value is null.</source>
          <target state="translated">인덱스 &lt;code&gt;ix&lt;/code&gt; 에서 제거 되었을 가능성이있는 속성 값입니다 . 속성 값이 null의 경우는 null</target>
        </trans-unit>
        <trans-unit id="75e1e093b3b31beab3f725db1a7a97f735291ed2" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index &lt;code&gt;ix&lt;/code&gt;; null if the attribute value is null.</source>
          <target state="translated">인덱스 &lt;code&gt;ix&lt;/code&gt; 의 null 가능성이있는 속성치 . 속성 값이 null의 경우는 null</target>
        </trans-unit>
        <trans-unit id="01e53a4583b8b632e31e23e545835d7fb151953e" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index ix that was replaced. Null if the attribute value was null.</source>
          <target state="translated">대체 된 인덱스 ix의 null 속성 값입니다. 속성 값이 null 인 경우는 null</target>
        </trans-unit>
        <trans-unit id="77bb1fce5266fd4ed13f0e3a64b2e033cc88d05b" translate="yes" xml:space="preserve">
          <source>The possibly null attributes to be bound.</source>
          <target state="translated">바인딩 가능한 null 속성입니다.</target>
        </trans-unit>
        <trans-unit id="71f9a1ed0e575411b69d0a23112e14cf08307845" translate="yes" xml:space="preserve">
          <source>The possibly null binding of the object after the change.</source>
          <target state="translated">변경 후 객체의 null 바인딩 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="303282c69dc7d698ff760f2ed06dfbbad81206cb" translate="yes" xml:space="preserve">
          <source>The possibly null binding of the object before the change.</source>
          <target state="translated">변경 전 객체의 null 바인딩 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be200430acab3902acee3be25723c5883a236b4b" translate="yes" xml:space="preserve">
          <source>The possibly null challenge to send to the client. It is null if the authentication has succeeded and there is no more challenge data to be sent to the client.</source>
          <target state="translated">클라이언트에게 보낼 가능성이있는 챌린지. 인증에 성공하고 클라이언트에 전송할 챌린지 데이터가 더 이상 없으면 널입니다.</target>
        </trans-unit>
        <trans-unit id="288430f98d1d8dc902d6cd0f841e573864bef168" translate="yes" xml:space="preserve">
          <source>The possibly null change information of this event.</source>
          <target state="translated">이 이벤트의 null 가능성이있는 정보</target>
        </trans-unit>
        <trans-unit id="ef5328e9a2c12269fc3c9790ffb3bdf7b904c77d" translate="yes" xml:space="preserve">
          <source>The possibly null class name of object bound. It is null if the object bound is null.</source>
          <target state="translated">바인딩 된 개체의 null 클래스 이름입니다. 바인드 된 오브젝트가 널인 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="ffd8994818808e7044f5a7bd47401c36f2d57625" translate="yes" xml:space="preserve">
          <source>The possibly null detail string explaining more about the problem with resolving a link. If null, it means there is no link detail message for this exception.</source>
          <target state="translated">링크를 해결하는 데 대한 문제점에 대해 자세히 설명하는 가능한 상세 문자열입니다. null의 경우,이 예외에 대한 링크 상세 메세지가없는 것을 의미한다</target>
        </trans-unit>
        <trans-unit id="67a7663ef453f501bcf8141dc78d296c77c8d264" translate="yes" xml:space="preserve">
          <source>The possibly null detail string explaining more about this exception. If null, it means there is no detail message for this exception.</source>
          <target state="translated">이 예외에 대해 더 설명하는 null 가능성이있는 문자열입니다. null의 경우,이 예외에 관한 상세 메세지가없는 것을 의미한다</target>
        </trans-unit>
        <trans-unit id="2dbbcea44ff699506e27e77c0ad6dc0d7cd34a86" translate="yes" xml:space="preserve">
          <source>The possibly null element in the enumeration. null is only valid for enumerations that can return null (e.g. Attribute.getAll() returns an enumeration of attribute values, and an attribute value can be null).</source>
          <target state="translated">열거에서 가능한 null 요소입니다. null은 null을 반환 할 수있는 열거에만 유효합니다 (예 : Attribute.getAll ()은 속성 값의 열거를 반환하고 속성 값은 null 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="50e6ea1bbf4d3d242e0442515defbd02966a7734" translate="yes" xml:space="preserve">
          <source>The possibly null exception that caused this naming exception. If null, it means no root cause has been set for this naming exception.</source>
          <target state="translated">이 이름 지정 예외의 원인이 된 null 예외입니다. null의 경우,이 네이밍 예외에 근본 원인이 설정되어 있지 않은 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ce85339be4b00e60548e7a67ece14ecc99dfce86" translate="yes" xml:space="preserve">
          <source>The possibly null fully-qualified class name of the factory. (e.g. &quot;java.lang.String&quot;)</source>
          <target state="translated">팩토리의 null 정규화 클래스 명일 가능성이 있습니다. (예 : &quot;java.lang.String&quot;)</target>
        </trans-unit>
        <trans-unit id="53819d8f2ff0666381a9127d62f2914f015d222f" translate="yes" xml:space="preserve">
          <source>The possibly null matching rule ID. If null then the ordering matching rule defined for the sort key attribute is used.</source>
          <target state="translated">가능한 null 일치 규칙 ID입니다. null의 경우, 소트 키 속성으로 정의 된 순서 일치 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7693eebba3b1d8e8aed9065f755c90ca9438ca" translate="yes" xml:space="preserve">
          <source>The possibly null object that was resolved so far. If null, it means the link resolved object field has not been set.</source>
          <target state="translated">지금까지 해결 된 null 가능성이있는 개체입니다. 널인 경우, 링크 분석 오브젝트 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="97169d9b8c4d89f8a301ca6eb28fad9af6f33b5c" translate="yes" xml:space="preserve">
          <source>The possibly null object that was resolved so far. null means that the resolved object field has not been set.</source>
          <target state="translated">지금까지 해결 된 null 가능성이있는 개체입니다. null은 확인 된 개체 필드가 ​​설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2ce6afd310045ea10e313ef96d7542591a1cd218" translate="yes" xml:space="preserve">
          <source>The possibly null object to be bound.</source>
          <target state="translated">바인딩 가능한 null 개체입니다.</target>
        </trans-unit>
        <trans-unit id="644a895b0ec7420afe1f7206497a62be42cccfd6" translate="yes" xml:space="preserve">
          <source>The possibly null part of the new name that has not been resolved. It is a composite name. It can be null, which means the remaining new name field has not been set.</source>
          <target state="translated">해결되지 않은 새 이름의 null 부분 일 수 있습니다. 합성 이름입니다. 널일 수 있으며, 이는 나머지 새 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="227b72d26062a0a4a65406d6b2400d858977938f" translate="yes" xml:space="preserve">
          <source>The possibly null response of the operation. null means the operation did not generate any response.</source>
          <target state="translated">작업의 null 응답 일 수 있습니다. null은 작업이 응답을 생성하지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="95751c0e2100386276d5fbab10fec9eadc434b68" translate="yes" xml:space="preserve">
          <source>The possibly null response to send to the server. It is null if the challenge accompanied a &quot;SUCCESS&quot; status and the challenge only contains data for the client to update its state and no response needs to be sent to the server. The response is a zero-length byte array if the client is to send a response with no data.</source>
          <target state="translated">서버에 보낼 수있는 null 응답 일 수 있습니다. 챌린지에 &quot;SUCCESS&quot;상태가 수반되고 챌린지에 클라이언트가 상태를 업데이트 할 수있는 데이터 만 포함되어 있고 응답을 서버로 보낼 필요가없는 경우 null입니다. 클라이언트가 데이터없이 응답을 보내야하는 경우 응답은 길이가 0 인 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a9f4959d404525b8010782edbbb82d1a4a73f2c7" translate="yes" xml:space="preserve">
          <source>The possibly null string containing the location for loading in the factory's class.</source>
          <target state="translated">팩토리 클래스에서로드 할 위치가 포함 된 null 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="598464a1b17e0cdd4775fa1d87fe9e6f6f313e36" translate="yes" xml:space="preserve">
          <source>The possibly null unexecuted modification list.</source>
          <target state="translated">실행되지 않은 null 수정 목록입니다.</target>
        </trans-unit>
        <trans-unit id="594289587491331d8018893d276e66cdd5175334" translate="yes" xml:space="preserve">
          <source>The possibly-empty unmodifiable set of the services that this module provides</source>
          <target state="translated">The possibly-empty unmodifiable set of the services that this module provides</target>
        </trans-unit>
        <trans-unit id="701dd4005bf758fa7ad450f4118b0095191d7b33" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by &lt;code&gt;combiner&lt;/code&gt;, a second method handle. Of the arguments passed to the adapter, the first &lt;code&gt;N&lt;/code&gt; arguments are copied to the combiner, which is then called. (Here, &lt;code&gt;N&lt;/code&gt; is defined as the parameter count of the combiner.) After this, control passes to the target, with any result from the combiner inserted before the original &lt;code&gt;N&lt;/code&gt; incoming arguments.</source>
          <target state="translated">전처리 는 제 2 방법 핸들 인 &lt;code&gt;combiner&lt;/code&gt; 에 의해 수행된다 . 어댑터에 전달 된 인수 중 첫 번째 &lt;code&gt;N&lt;/code&gt; 인수가 결합기에 복사 된 후 호출됩니다. (여기서 &lt;code&gt;N&lt;/code&gt; 은 컴 바이 너의 매개 변수 수로 정의됩니다.)이 후 제어는 대상에 전달되고 컴 바이 너의 결과는 원래 &lt;code&gt;N&lt;/code&gt; 개의 수신 인수 앞에 삽입 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c240ae7a898a6847f515e8d7157c3336476bbff" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by one or more method handles, specified in the elements of the &lt;code&gt;filters&lt;/code&gt; array. The first element of the filter array corresponds to the &lt;code&gt;pos&lt;/code&gt; argument of the target, and so on in sequence.</source>
          <target state="translated">사전 처리는 &lt;code&gt;filters&lt;/code&gt; 배열 의 요소에 지정된 하나 이상의 메소드 핸들로 수행됩니다 . 필터 배열의 첫 번째 요소 는 대상 의 &lt;code&gt;pos&lt;/code&gt; 인수 등에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="0c8d7cd21b52b86ec589875400da932885d18951" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by one or more method handles, specified in the elements of the &lt;code&gt;filters&lt;/code&gt; array. The first element of the filter array corresponds to the &lt;code&gt;pos&lt;/code&gt; argument of the target, and so on in sequence. The filter functions are invoked in left to right order.</source>
          <target state="translated">The pre-processing is performed by one or more method handles, specified in the elements of the &lt;code&gt;filters&lt;/code&gt; array. The first element of the filter array corresponds to the &lt;code&gt;pos&lt;/code&gt; argument of the target, and so on in sequence. The filter functions are invoked in left to right order.</target>
        </trans-unit>
        <trans-unit id="54fba175e25513934ae6e0c928d834995d59017b" translate="yes" xml:space="preserve">
          <source>The precedence of character-class operators is as follows, from highest to lowest:</source>
          <target state="translated">문자 클래스 연산자의 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a932d6aca64396e330c14caa731cd2e97c2efee4" translate="yes" xml:space="preserve">
          <source>The preceding code fragments give an idea of what goes on behind the scenes; they would not appear in an application, which would not invoke methods like &lt;code&gt;readData&lt;/code&gt; and &lt;code&gt;decodeParams&lt;/code&gt;. In contrast, the following code fragment shows what an application might do. It sets the rowset's command, sets the command's parameters, and executes the command. Simply by calling the &lt;code&gt;execute&lt;/code&gt; method, &lt;code&gt;crs&lt;/code&gt; populates itself with the requested data from the table &lt;code&gt;CUSTOMERS&lt;/code&gt;.</source>
          <target state="translated">The preceding code fragments give an idea of what goes on behind the scenes; they would not appear in an application, which would not invoke methods like &lt;code&gt;readData&lt;/code&gt; and &lt;code&gt;decodeParams&lt;/code&gt; . In contrast, the following code fragment shows what an application might do. It sets the rowset's command, sets the command's parameters, and executes the command. Simply by calling the &lt;code&gt;execute&lt;/code&gt; method, &lt;code&gt;crs&lt;/code&gt; populates itself with the requested data from the table &lt;code&gt;CUSTOMERS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b22a75a19cc8184d8d42eb3e0cea459d833bd7" translate="yes" xml:space="preserve">
          <source>The preceding element or null if &lt;code&gt;value&lt;/code&gt; is the first element of the sequence.</source>
          <target state="translated">The preceding element or null if &lt;code&gt;value&lt;/code&gt; is the first element of the sequence.</target>
        </trans-unit>
        <trans-unit id="1662793d099b9cf5e31bcba731e92de7d3a9c837" translate="yes" xml:space="preserve">
          <source>The precise definition of &quot;equality&quot; used in comparing attribute values is defined by the underlying directory service. It might use the &lt;code&gt;Object.equals&lt;/code&gt; method, for example, or might use a schema to specify a different equality operation. For matching based on operations other than equality (such as substring comparison) use the version of the &lt;code&gt;search&lt;/code&gt; method that takes a filter argument.</source>
          <target state="translated">속성 값을 비교하는 데 사용되는 &quot;평등&quot;의 정확한 정의는 기본 디렉토리 서비스에 의해 정의됩니다. 그것은 사용할 수 있습니다 &lt;code&gt;Object.equals&lt;/code&gt; 예를 들어, 방법, 또는 다른 동등 조작을 지정하는 스키마를 사용할 수 있습니다. 등호 이외의 연산 (예 : 하위 문자열 비교)을 기준으로 일치 시키려면 필터 인수를 사용하는 &lt;code&gt;search&lt;/code&gt; 메소드 버전을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb4614fd577d896554af4208ae33226e3eddd8ad" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, a path that does not contain &lt;em&gt;redundant&lt;/em&gt; name elements. In many file systems, the &quot;&lt;code&gt;.&lt;/code&gt;&quot; and &quot;&lt;code&gt;..&lt;/code&gt;&quot; are special names used to indicate the current directory and parent directory. In such file systems all occurrences of &quot;&lt;code&gt;.&lt;/code&gt;&quot; are considered redundant. If a &quot;&lt;code&gt;..&lt;/code&gt;&quot; is preceded by a non-&quot;&lt;code&gt;..&lt;/code&gt;&quot; name then both names are considered redundant (the process to identify such names is repeated until it is no longer applicable).</source>
          <target state="translated">이 방법의 정확한 정의는 구현에 따라 다르지만 일반적으로 &lt;em&gt;중복&lt;/em&gt; 이름 요소를 포함하지 않는 경로 인이 경로에서 파생됩니다 . 많은 파일 시스템에서 &quot; &lt;code&gt;.&lt;/code&gt; &quot;및 &quot; &lt;code&gt;..&lt;/code&gt; &quot;은 현재 디렉토리 및 상위 디렉토리를 나타내는 데 사용되는 특수 이름입니다. 이러한 파일 시스템에서 &quot; &lt;code&gt;.&lt;/code&gt; &quot;은 모두 중복 된 것으로 간주됩니다. 는 &quot;경우 &lt;code&gt;..&lt;/code&gt; &quot;비 &quot;로 시작됩니다 &lt;code&gt;..&lt;/code&gt; &quot;이름을 다음 두 이름이 고려 중복 (더 이상 적용 할 때까지 같은 이름을 식별 할 수있는 프로세스가 반복되지 않는다).</target>
        </trans-unit>
        <trans-unit id="29fe6f024b67a56fd1534c416c02d84229593b97" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, an &lt;a href=&quot;#isAbsolute()&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path that locates the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed.</source>
          <target state="translated">The precise definition of this method is implementation dependent but in general it derives from this path, an &lt;a href=&quot;#isAbsolute()&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; path that locates the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed.</target>
        </trans-unit>
        <trans-unit id="f156f4742b28783fc176e2435a927cffa5913867" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path that locates the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed.</source>
          <target state="translated">이 메소드의 정확한 정의는 구현에 따라 다르지만 일반적으로이 경로 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; 파일 을 찾는 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로 인 이 경로에서 파생 되지만 디렉토리 및 파일의 실제 이름을 나타내는 이름 요소가 있습니다. 예를 들어, 파일 시스템에서 파일 이름 비교가 대소 문자를 구분하지 않는 경우 name 요소는 실제 대소 문자 이름을 나타냅니다. 또한 결과 경로에 중복 이름 요소가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="f29514735dff4eb9875c567e3c77c10d0798a36a" translate="yes" xml:space="preserve">
          <source>The precise meaning of &quot;copy&quot; may depend on the class of the &lt;code&gt;CertStoreParameters&lt;/code&gt; object. A typical implementation performs a &quot;deep copy&quot; of this object, but this is not an absolute requirement. Some implementations may perform a &quot;shallow copy&quot; of some or all of the fields of this object.</source>
          <target state="translated">&quot;복사&quot;의 정확한 의미는 &lt;code&gt;CertStoreParameters&lt;/code&gt; 객체 의 클래스에 따라 달라질 수 있습니다 . 일반적인 구현은이 객체의 &quot;딥 카피&quot;를 수행하지만 반드시 필요한 것은 아닙니다. 일부 구현은이 객체의 일부 또는 모든 필드의 &quot;얕은 복사&quot;를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a518f78db20ec1e8e63802d6b81b3e5afc2d6f" translate="yes" xml:space="preserve">
          <source>The precise string returned is unspecified, although the following example can be considered typical:</source>
          <target state="translated">다음 예제는 일반적인 것으로 간주 될 수 있지만 반환 된 정확한 문자열은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc7760cf2ead29811d5a4f7919c808536944042d" translate="yes" xml:space="preserve">
          <source>The precision</source>
          <target state="translated">정밀도</target>
        </trans-unit>
        <trans-unit id="7f3d6ffd25563b48e926ec811735bc2c49c338dd" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If precision is specified then an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b627f68a8d6aaaef844dc471dec6b871f7b4415" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If the precision is specified an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73c2e0008148d7f138652dae3090ecc94203eec5" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If the precision is specified then an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f948c10e382d2f7768291cb8552af2625096c3e" translate="yes" xml:space="preserve">
          <source>The precision is the maximum number of characters to be written to the output. The precision is applied before the width, thus the output will be truncated to &lt;code&gt;precision&lt;/code&gt; characters even if the width is greater than the precision. If the precision is not specified then there is no explicit limit on the number of characters.</source>
          <target state="translated">정밀도는 출력에 쓸 수있는 최대 문자 수입니다. 너비보다 정밀도가 적용되므로 너비가 정밀도보다 큰 경우에도 출력이 &lt;code&gt;precision&lt;/code&gt; 문자 로 잘립니다 . 정밀도를 지정하지 않으면 문자 수에 대한 명시적인 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b1e32fea1577f6299edbb4af566a671877a6a6c" translate="yes" xml:space="preserve">
          <source>The precision of a Timestamp object is calculated to be either:</source>
          <target state="translated">The precision of a Timestamp object is calculated to be either:</target>
        </trans-unit>
        <trans-unit id="011a0b906162939e49578d08e8c1662e56c9f51a" translate="yes" xml:space="preserve">
          <source>The precision of a zero value is 1.</source>
          <target state="translated">0 값의 정밀도는 1입니다.</target>
        </trans-unit>
        <trans-unit id="7e82e7810d2a873bd46b845642c3dcb0365960ec" translate="yes" xml:space="preserve">
          <source>The predicate set on a &lt;code&gt;FilteredRowSet&lt;/code&gt; object applies a criterion on all rows in a &lt;code&gt;RowSet&lt;/code&gt; object to manage a subset of rows in a &lt;code&gt;RowSet&lt;/code&gt; object. This criterion governs the subset of rows that are visible and also defines which rows can be modified, deleted or inserted.</source>
          <target state="translated">The predicate set on a &lt;code&gt;FilteredRowSet&lt;/code&gt; object applies a criterion on all rows in a &lt;code&gt;RowSet&lt;/code&gt; object to manage a subset of rows in a &lt;code&gt;RowSet&lt;/code&gt; object. This criterion governs the subset of rows that are visible and also defines which rows can be modified, deleted or inserted.</target>
        </trans-unit>
        <trans-unit id="fa7e902fc875b9d16b011208a78c742ef3d3df14" translate="yes" xml:space="preserve">
          <source>The predicate which can be used for finding a match on a subsequence of a string</source>
          <target state="translated">The predicate which can be used for finding a match on a subsequence of a string</target>
        </trans-unit>
        <trans-unit id="17aa8f7febdaa3dd39b9259abe1f54bf9f0bebab" translate="yes" xml:space="preserve">
          <source>The predicate which can be used for matching an input string against this pattern.</source>
          <target state="translated">The predicate which can be used for matching an input string against this pattern.</target>
        </trans-unit>
        <trans-unit id="4f4b2728c2d9fd894664edd48acbeb413a1af02a" translate="yes" xml:space="preserve">
          <source>The predicate which can be used for matching on a string</source>
          <target state="translated">문자열에서 일치시키는 데 사용할 수있는 술어</target>
        </trans-unit>
        <trans-unit id="93d5400fe79116558dbb225fbe571b21c4ae79c8" translate="yes" xml:space="preserve">
          <source>The preference node that emitted the event.</source>
          <target state="translated">이벤트를 생성 한 환경 설정 노드.</target>
        </trans-unit>
        <trans-unit id="01203bc40cdd0fc728a1cb94001dc99438b063b0" translate="yes" xml:space="preserve">
          <source>The preferred (natural) size.</source>
          <target state="translated">The preferred (natural) size.</target>
        </trans-unit>
        <trans-unit id="668f70b2a4daaa09d8171ffcd2d7649a4140024b" translate="yes" xml:space="preserve">
          <source>The preferred (natural) size. For a component &lt;code&gt;comp&lt;/code&gt;, this should be equal to either &lt;code&gt;comp.getPreferredSize().width&lt;/code&gt; or &lt;code&gt;comp.getPreferredSize().height&lt;/code&gt;.</source>
          <target state="translated">The preferred (natural) size. For a component &lt;code&gt;comp&lt;/code&gt; , this should be equal to either &lt;code&gt;comp.getPreferredSize().width&lt;/code&gt; or &lt;code&gt;comp.getPreferredSize().height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bee2604a2c9080ffc366e1be25ae9500c7ea3565" translate="yes" xml:space="preserve">
          <source>The preferred alternative to this method is &lt;a href=&quot;#orElseThrow()&quot;&gt;&lt;code&gt;orElseThrow()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The preferred alternative to this method is &lt;a href=&quot;#orElseThrow()&quot;&gt; &lt;code&gt;orElseThrow()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6e11d6aa454b661b4e798d0b01d95991a0663d3" translate="yes" xml:space="preserve">
          <source>The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding. A &lt;code&gt;CharSet&lt;/code&gt; which corresponds to this and is suitable for use in a mime-type for a &lt;code&gt;DocFlavor&lt;/code&gt; can be obtained from &lt;a href=&quot;#hostEncoding&quot;&gt;&lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt;&lt;/a&gt; This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST &lt;code&gt;DocFlavors&lt;/code&gt; may be used.</source>
          <target state="translated">The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding. A &lt;code&gt;CharSet&lt;/code&gt; which corresponds to this and is suitable for use in a mime-type for a &lt;code&gt;DocFlavor&lt;/code&gt; can be obtained from &lt;a href=&quot;#hostEncoding&quot;&gt; &lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt; &lt;/a&gt; This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST &lt;code&gt;DocFlavors&lt;/code&gt; may be used.</target>
        </trans-unit>
        <trans-unit id="795459da550b399518e8f16108cfa6f315f51f3c" translate="yes" xml:space="preserve">
          <source>The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding. A CharSet which corresponds to this and is suitable for use in a mime-type for a DocFlavor can be obtained from &lt;a href=&quot;docflavor#hostEncoding&quot;&gt;&lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt;&lt;/a&gt; This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST DocFlavors may be used.</source>
          <target state="translated">선호되는 형식은 인코딩의 공식 IANA 기본 이름입니다. 텍스트 데이터를 스트리밍하는 응용 프로그램은 항상 MIME 유형으로 문자 집합을 지정해야하며, 이로 인해 해당 플랫폼의 인코딩에 저장된 데이터 (예 : 파일)에 대한 호스트 플랫폼의 인코딩이 필요합니다. 이에 대응로부터 얻어 질 수 DocFlavor에 대한 마임 타입에서의 사용에 적절한 CharSet &lt;a href=&quot;docflavor#hostEncoding&quot;&gt; &lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt; &lt;/a&gt; 항상 주 IANA 이름 않을 수도 있지만,이 VM에 의해 이해 될 것이 보장된다. 일반적인 풍미의 경우 사전 정의 된 * HOST DocFlavors를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d4fefc085f821e9d3a5fbae52dac81c3effbc7e" translate="yes" xml:space="preserve">
          <source>The preferred grid size that can be laid out by the grid bag layout.</source>
          <target state="translated">The preferred grid size that can be laid out by the grid bag layout.</target>
        </trans-unit>
        <trans-unit id="05d8afb011f2d6aa97450b5eeed5331327e17a1b" translate="yes" xml:space="preserve">
          <source>The preferred height of a grid layout is the largest preferred height of all of the components in the container times the number of rows, plus the vertical padding times the number of rows minus one, plus the top and bottom insets of the target container.</source>
          <target state="translated">The preferred height of a grid layout is the largest preferred height of all of the components in the container times the number of rows, plus the vertical padding times the number of rows minus one, plus the top and bottom insets of the target container.</target>
        </trans-unit>
        <trans-unit id="c8a8514ae55eb27d43368a36b34b29a4a95ecea4" translate="yes" xml:space="preserve">
          <source>The preferred scale of the returned result is equal to &lt;code&gt;this.scale()/2&lt;/code&gt;. The value of the returned result is always within one ulp of the exact decimal value for the precision in question. If the rounding mode is &lt;a href=&quot;roundingmode#HALF_UP&quot;&gt;&lt;code&gt;HALF_UP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;roundingmode#HALF_DOWN&quot;&gt;&lt;code&gt;HALF_DOWN&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;roundingmode#HALF_EVEN&quot;&gt;&lt;code&gt;HALF_EVEN&lt;/code&gt;&lt;/a&gt;, the result is within one half an ulp of the exact decimal value.</source>
          <target state="translated">The preferred scale of the returned result is equal to &lt;code&gt;this.scale()/2&lt;/code&gt; . The value of the returned result is always within one ulp of the exact decimal value for the precision in question. If the rounding mode is &lt;a href=&quot;roundingmode#HALF_UP&quot;&gt; &lt;code&gt;HALF_UP&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;roundingmode#HALF_DOWN&quot;&gt; &lt;code&gt;HALF_DOWN&lt;/code&gt; &lt;/a&gt;, or &lt;a href=&quot;roundingmode#HALF_EVEN&quot;&gt; &lt;code&gt;HALF_EVEN&lt;/code&gt; &lt;/a&gt;, the result is within one half an ulp of the exact decimal value.</target>
        </trans-unit>
        <trans-unit id="97d21f85809a776457475782a29383e91f9fd0e0" translate="yes" xml:space="preserve">
          <source>The preferred size of a &lt;code&gt;ScrollPane&lt;/code&gt; is the size of the insets, plus the preferred size of the viewport, plus the preferred size of the visible headers, plus the preferred size of the scrollbars that will appear given the current view and the current scrollbar displayPolicies.</source>
          <target state="translated">The preferred size of a &lt;code&gt;ScrollPane&lt;/code&gt; is the size of the insets, plus the preferred size of the viewport, plus the preferred size of the visible headers, plus the preferred size of the scrollbars that will appear given the current view and the current scrollbar displayPolicies.</target>
        </trans-unit>
        <trans-unit id="7e0c9711b77e17c2c4489dd5f3a52974aebe48d6" translate="yes" xml:space="preserve">
          <source>The preferred size of the radio button</source>
          <target state="translated">The preferred size of the radio button</target>
        </trans-unit>
        <trans-unit id="5e6038f90eeaa8ca2ee7e55f1a245305b2c41a38" translate="yes" xml:space="preserve">
          <source>The preferred way to listen for changes in list selection is to add &lt;code&gt;ListSelectionListener&lt;/code&gt;s directly to the &lt;code&gt;JList&lt;/code&gt;. &lt;code&gt;JList&lt;/code&gt; then takes care of listening to the selection model and notifying your listeners of change.</source>
          <target state="translated">The preferred way to listen for changes in list selection is to add &lt;code&gt;ListSelectionListener&lt;/code&gt; s directly to the &lt;code&gt;JList&lt;/code&gt; . &lt;code&gt;JList&lt;/code&gt; then takes care of listening to the selection model and notifying your listeners of change.</target>
        </trans-unit>
        <trans-unit id="48639e84ad6bcbf4597e147d7f6d16619a7c0136" translate="yes" xml:space="preserve">
          <source>The preferred width of a grid layout is the largest preferred width of all of the components in the container times the number of columns, plus the horizontal padding times the number of columns minus one, plus the left and right insets of the target container.</source>
          <target state="translated">The preferred width of a grid layout is the largest preferred width of all of the components in the container times the number of columns, plus the horizontal padding times the number of columns minus one, plus the left and right insets of the target container.</target>
        </trans-unit>
        <trans-unit id="b2b470a8c702b5603e9fd56840aa453b3eb2223e" translate="yes" xml:space="preserve">
          <source>The preferredSize of a JViewport whose view is this Scrollable.</source>
          <target state="translated">The preferredSize of a JViewport whose view is this Scrollable.</target>
        </trans-unit>
        <trans-unit id="0845b5b36ca2d4a9b8425c1235452d096e88e50c" translate="yes" xml:space="preserve">
          <source>The preferredSize of the list depends upon the layout orientation.</source>
          <target state="translated">The preferredSize of the list depends upon the layout orientation.</target>
        </trans-unit>
        <trans-unit id="9f1ee0aa7a4e77fdaf06191164b7988a841284af" translate="yes" xml:space="preserve">
          <source>The preferredSize of the list is total height of the rows and the maximum width of the cells. If JList.fixedCellHeight is specified then the total height of the rows is just (cellVerticalMargins + fixedCellHeight) * model.getSize() where rowVerticalMargins is the space we allocate for drawing the yellow focus outline. Similarly if fixedCellWidth is specified then we just use that.</source>
          <target state="translated">The preferredSize of the list is total height of the rows and the maximum width of the cells. If JList.fixedCellHeight is specified then the total height of the rows is just (cellVerticalMargins + fixedCellHeight) * model.getSize() where rowVerticalMargins is the space we allocate for drawing the yellow focus outline. Similarly if fixedCellWidth is specified then we just use that.</target>
        </trans-unit>
        <trans-unit id="4eac60dfdfde299257ae10fdc0b835ebccd24913" translate="yes" xml:space="preserve">
          <source>The prefix assigned to a &lt;code&gt;QName&lt;/code&gt; might &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; be valid in a different context. For example, a &lt;code&gt;QName&lt;/code&gt; may be assigned a prefix in the context of parsing a document but that prefix may be invalid in the context of a different document.</source>
          <target state="translated">The prefix assigned to a &lt;code&gt;QName&lt;/code&gt; might &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; be valid in a different context. For example, a &lt;code&gt;QName&lt;/code&gt; may be assigned a prefix in the context of parsing a document but that prefix may be invalid in the context of a different document.</target>
        </trans-unit>
        <trans-unit id="1623642ae83456ebc262cddb280ef298b22cf43d" translate="yes" xml:space="preserve">
          <source>The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows:</source>
          <target state="translated">접두사 개념은 다음과 같이 UNIX 플랫폼에서 루트 디렉토리를 처리하고 Microsoft Windows 플랫폼에서 지정자, 루트 디렉토리 및 UNC 경로 이름을 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83c74b98c1c103adeb72e47f23638fe0c6b5dd97" translate="yes" xml:space="preserve">
          <source>The prefix is included in &lt;code&gt;QName&lt;/code&gt; to retain lexical information &lt;strong&gt;&lt;em&gt;when present&lt;/em&gt;&lt;/strong&gt; in an &lt;a href=&quot;../transform/source&quot;&gt;&lt;code&gt;XML input source&lt;/code&gt;&lt;/a&gt;. The prefix is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; used in &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;QName.equals(Object)&lt;/code&gt;&lt;/a&gt; or to compute the &lt;a href=&quot;#hashCode()&quot;&gt;&lt;code&gt;QName.hashCode()&lt;/code&gt;&lt;/a&gt;. Equality and the hash code are defined using &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; the Namespace URI and local part.</source>
          <target state="translated">The prefix is included in &lt;code&gt;QName&lt;/code&gt; to retain lexical information &lt;strong&gt;&lt;em&gt;when present&lt;/em&gt;&lt;/strong&gt; in an &lt;a href=&quot;../transform/source&quot;&gt; &lt;code&gt;XML input source&lt;/code&gt; &lt;/a&gt;. The prefix is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; used in &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;QName.equals(Object)&lt;/code&gt; &lt;/a&gt; or to compute the &lt;a href=&quot;#hashCode()&quot;&gt; &lt;code&gt;QName.hashCode()&lt;/code&gt; &lt;/a&gt;. Equality and the hash code are defined using &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; the Namespace URI and local part.</target>
        </trans-unit>
        <trans-unit id="3f0a33b763f461c55c714ee683f971a7242fb300" translate="yes" xml:space="preserve">
          <source>The prefix value &lt;strong&gt;&lt;em&gt;CANNOT&lt;/em&gt;&lt;/strong&gt; be represented in the &lt;code&gt;String&lt;/code&gt; and will be set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The prefix value &lt;strong&gt;&lt;em&gt;CANNOT&lt;/em&gt;&lt;/strong&gt; be represented in the &lt;code&gt;String&lt;/code&gt; and will be set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f09b6b3f056a1320123b826245334165f48ccf20" translate="yes" xml:space="preserve">
          <source>The prefixes, suffixes, and various symbols used for infinity, digits, grouping separators, decimal separators, etc. may be set to arbitrary values, and they will appear properly during formatting. However, care must be taken that the symbols and strings do not conflict, or parsing will be unreliable. For example, either the positive and negative prefixes or the suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able to distinguish positive from negative values. (If they are identical, then &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was specified.) Another example is that the decimal separator and grouping separator should be distinct characters, or parsing will be impossible.</source>
          <target state="translated">무한대, 숫자, 그룹화 구분 기호, 소수 구분 기호 등에 사용되는 접두사, 접미사 및 다양한 기호는 임의의 값으로 설정 될 수 있으며 서식 지정 중에 제대로 표시됩니다. 그러나 기호와 문자열이 충돌하지 않도록주의해야합니다. 그렇지 않으면 구문 분석이 신뢰할 수 없습니다. 예를 들어 &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; 에서 양수와 음수 값을 구별 할 수 있으려면 양수 및 음수 접두사 또는 접미사가 구별되어야 합니다. (동일한 경우 &lt;code&gt;DecimalFormat&lt;/code&gt; 은 음의 하위 패턴이 지정되지 않은 것처럼 작동합니다.) 또 다른 예는 소수 구분 기호와 그룹 구분 기호가 별개의 문자 여야한다는 것입니다. 그렇지 않으면 구문 분석이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e1c1be1011e46771e6c940b6b8fa6d5e62a87e1" translate="yes" xml:space="preserve">
          <source>The prefixes, suffixes, and various symbols used for infinity, digits, thousands separators, decimal separators, etc. may be set to arbitrary values, and they will appear properly during formatting. However, care must be taken that the symbols and strings do not conflict, or parsing will be unreliable. For example, either the positive and negative prefixes or the suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able to distinguish positive from negative values. (If they are identical, then &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was specified.) Another example is that the decimal separator and thousands separator should be distinct characters, or parsing will be impossible.</source>
          <target state="translated">무한대, 숫자, 천 단위 구분 기호, 소수점 구분 기호 등에 사용되는 접두사, 접미사 및 다양한 기호는 임의의 값으로 설정 될 수 있으며 서식을 지정할 때 올바르게 나타납니다. 그러나 기호와 문자열이 충돌하지 않거나 구문 분석을 신뢰할 수 없도록주의해야합니다. 예를 들어 &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; 에서 양수와 음수를 구분 하려면 양수와 음수 접두사 또는 접미사를 구분해야 합니다. (동일한 경우 &lt;code&gt;DecimalFormat&lt;/code&gt; 은 음의 하위 패턴이 지정되지 않은 것처럼 작동합니다.) 또 다른 예는 소수점 구분 기호와 천 단위 구분 기호가 고유 한 문자이거나 구문 분석이 불가능하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfe9500d76701215dda5f0694197cf9ce7cabc59" translate="yes" xml:space="preserve">
          <source>The preprocessing operations &lt;code&gt;\l&lt;/code&gt;&lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt;.</source>
          <target state="translated">전처리 작업 &lt;code&gt;\l&lt;/code&gt; &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c9b0afc43dff8f62f02bd5e510a84044b62add" translate="yes" xml:space="preserve">
          <source>The presence of a &quot;throws TooManyListenersException&quot; clause on any given concrete implementation of the normally multicast &quot;void addXyzEventListener&quot; event listener registration pattern is used to annotate that interface as implementing a unicast Listener special case, that is, that one and only one Listener may be registered on the particular event listener source concurrently.</source>
          <target state="translated">일반적으로 멀티 캐스트 &quot;void addXyzEventListener&quot;이벤트 리스너 등록 패턴의 특정 구현에 &quot;throws TooManyListenersException&quot;절이 존재하면 해당 인터페이스에 유니 캐스트 리스너 특수 케이스를 구현하는 것으로 즉, 하나의 리스너 만 구현할 수 있습니다. 특정 이벤트 리스너 소스에 동시에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="bcfe2fa218fb85c049078854e31cba9eb33712aa" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;setProduct&lt;/code&gt; method now means that the &lt;code&gt;Product&lt;/code&gt; attribute is read/write. As before, the value of this attribute is an &lt;code&gt;ObjectName&lt;/code&gt;. When the attribute is set, the &lt;code&gt;ObjectName&lt;/code&gt; must be converted into the &lt;code&gt;ProductMXBean&lt;/code&gt; object that the &lt;code&gt;setProduct&lt;/code&gt; method expects. This object will be an MXBean proxy for the given &lt;code&gt;ObjectName&lt;/code&gt; in the same MBean Server.</source>
          <target state="translated">&lt;code&gt;setProduct&lt;/code&gt; 메소드가 존재 한다는 것은 이제 &lt;code&gt;Product&lt;/code&gt; 속성이 읽기 / 쓰기 임을 의미합니다 . 이전과 &lt;code&gt;ObjectName&lt;/code&gt; 속성의 값은 ObjectName 입니다. 속성이 설정되면 &lt;code&gt;ObjectName&lt;/code&gt; 이 &lt;code&gt;setProduct&lt;/code&gt; 메소드가 예상 하는 &lt;code&gt;ProductMXBean&lt;/code&gt; 오브젝트 로 변환되어야합니다 . 이 객체는 같은 MBean Server 내의 지정된 &lt;code&gt;ObjectName&lt;/code&gt; 의 MXBean 프록시가 됩니다.</target>
        </trans-unit>
        <trans-unit id="95fd8050fdd45b3295eab4ae02a17e8850afef7c" translate="yes" xml:space="preserve">
          <source>The preview panel property name.</source>
          <target state="translated">The preview panel property name.</target>
        </trans-unit>
        <trans-unit id="81e03839989ac27ea315697726bbbcb23a717c1b" translate="yes" xml:space="preserve">
          <source>The previous 2 requirements also apply to &lt;code&gt;URIDereferencer&lt;/code&gt;s returned by the &lt;code&gt;getURIDereferencer&lt;/code&gt; method of &lt;code&gt;
 XMLSignatureFactory&lt;/code&gt; and &lt;code&gt;KeyInfoFactory&lt;/code&gt;.</source>
          <target state="translated">이전 2 개의 요구 사항 은 &lt;code&gt; XMLSignatureFactory&lt;/code&gt; 및 &lt;code&gt;KeyInfoFactory&lt;/code&gt; 의 &lt;code&gt;getURIDereferencer&lt;/code&gt; 메소드에 의해 리턴 된 &lt;code&gt;URIDereferencer&lt;/code&gt; 에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3c1a6d5e06c70c525e18d6c292218418c439f71" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.</source>
          <target state="translated">The previous &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.</target>
        </trans-unit>
        <trans-unit id="6099ffaa8e5a95edca2a939c252763b26b2f5933" translate="yes" xml:space="preserve">
          <source>The previous example assumes you have not enabled filtering. If you have enabled filtering &lt;code&gt;convertRowIndexToView&lt;/code&gt; will return -1 for locations that are not visible in the view.</source>
          <target state="translated">The previous example assumes you have not enabled filtering. If you have enabled filtering &lt;code&gt;convertRowIndexToView&lt;/code&gt; will return -1 for locations that are not visible in the view.</target>
        </trans-unit>
        <trans-unit id="70c0c9bb4cb63f228dd9dcd36da40d2bf9a2afb1" translate="yes" xml:space="preserve">
          <source>The previous interest set</source>
          <target state="translated">The previous interest set</target>
        </trans-unit>
        <trans-unit id="f7113d8eb1505536f0ceef50cb4ab773d8857fa3" translate="yes" xml:space="preserve">
          <source>The previously-attached object, if any, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">이전에 연결된 객체 (있는 경우), 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3eace7397efd4ce2c5bc4bde921c89ec3d4523a0" translate="yes" xml:space="preserve">
          <source>The primary API of interest in this class for 3rd party component authors are the three methods which retrieve painters: #getBackgroundPainter, #getForegroundPainter, and #getBorderPainter.</source>
          <target state="translated">The primary API of interest in this class for 3rd party component authors are the three methods which retrieve painters: #getBackgroundPainter, #getForegroundPainter, and #getBorderPainter.</target>
        </trans-unit>
        <trans-unit id="3ab68026a150f7949b7b1dc414949fb8e8e07d81" translate="yes" xml:space="preserve">
          <source>The primary alternative to using this interface throughout your application is as follows.</source>
          <target state="translated">응용 프로그램 전체에서이 인터페이스를 사용하는 주요 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf540bb867becf7faa8d8a8f6a3aafda966d70ed" translate="yes" xml:space="preserve">
          <source>The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking-boolean-&quot;&gt;&lt;code&gt;non-blocking I/O (polling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt;&lt;code&gt;selectable non-blocking I/O&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffers&lt;/code&gt;&lt;/a&gt; or byte arrays, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 의 주요 차이점은 전송 메커니즘과 무관하게 인바운드 및 아웃 바운드 바이트 스트림에서 작동한다는 것입니다. 피어로의 안정적인 I / O 전송을 준비 하는 것은 &lt;code&gt;SSLEngine&lt;/code&gt; 사용자 의 책임입니다 . SSL / TLS 추상화를 I / O 전송 메커니즘에서 분리함으로써 &lt;code&gt;SSLEngine&lt;/code&gt; 은 &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking-boolean-&quot;&gt; &lt;code&gt;non-blocking I/O (polling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt; &lt;code&gt;selectable non-blocking I/O&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../java/net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 및 기존 입력 / 출력 스트림, 로컬 &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffers&lt;/code&gt; &lt;/a&gt; 또는 바이트 배열, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt;향후 비동기 I / O 모델&lt;/a&gt; 등</target>
        </trans-unit>
        <trans-unit id="f9ee17cce91342ad50a57f1b7253427e39e222db" translate="yes" xml:space="preserve">
          <source>The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS/DTLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking(boolean)&quot;&gt;&lt;code&gt;non-blocking I/O (polling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt;&lt;code&gt;selectable non-blocking I/O&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffers&lt;/code&gt;&lt;/a&gt; or byte arrays, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</source>
          <target state="translated">The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS/DTLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking(boolean)&quot;&gt; &lt;code&gt;non-blocking I/O (polling)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt; &lt;code&gt;selectable non-blocking I/O&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffers&lt;/code&gt; &lt;/a&gt; or byte arrays, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</target>
        </trans-unit>
        <trans-unit id="85593e45877e5841c29232741b0ac453fc6b1e46" translate="yes" xml:space="preserve">
          <source>The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS/DTLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking(boolean)&quot;&gt;&lt;code&gt;non-blocking I/O (polling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt;&lt;code&gt;selectable non-blocking I/O&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffers&lt;/code&gt;&lt;/a&gt; or byte arrays, &lt;a href=&quot;https://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 의 주요 차이점은 전송 메커니즘과 관계없이 인바운드 및 아웃 바운드 바이트 스트림에서 작동한다는 것입니다. 신뢰할 수있는 I / O 전송을 피어로 조정 하는 것은 &lt;code&gt;SSLEngine&lt;/code&gt; 사용자 의 책임입니다 . SSL / TLS / DTLS 추상화를 I / O 전송 메커니즘에서 분리함으로써 &lt;code&gt;SSLEngine&lt;/code&gt; 은 &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking(boolean)&quot;&gt; &lt;code&gt;non-blocking I/O (polling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt; &lt;code&gt;selectable non-blocking I/O&lt;/code&gt; &lt;/a&gt;차단 I / 와 같은 다양한 I / O 유형에 사용할 수 있습니다. O , &lt;a href=&quot;../../../java/net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 및 기존 입력 / 출력 스트림, 로컬 &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffers&lt;/code&gt; &lt;/a&gt; 또는 바이트 배열, &lt;a href=&quot;https://www.jcp.org/en/jsr/detail?id=203&quot;&gt;미래의 비동기 I / O 모델&lt;/a&gt; 등.</target>
        </trans-unit>
        <trans-unit id="5ca999a61a413f3228e3e710618f31b417d296f9" translate="yes" xml:space="preserve">
          <source>The primary entry point for HTML View implementations to get their attributes is the &lt;a href=&quot;#getViewAttributes(javax.swing.text.View)&quot;&gt;&lt;code&gt;getViewAttributes&lt;/code&gt;&lt;/a&gt; method. This should be implemented to establish the desired policy used to associate attributes with the view. Each HTMLEditorKit (i.e. and therefore each associated JEditorPane) can have its own StyleSheet, but by default one sheet will be shared by all of the HTMLEditorKit instances. HTMLDocument instance can also have a StyleSheet, which holds the document-specific CSS specifications.</source>
          <target state="translated">The primary entry point for HTML View implementations to get their attributes is the &lt;a href=&quot;#getViewAttributes(javax.swing.text.View)&quot;&gt; &lt;code&gt;getViewAttributes&lt;/code&gt; &lt;/a&gt; method. This should be implemented to establish the desired policy used to associate attributes with the view. Each HTMLEditorKit (i.e. and therefore each associated JEditorPane) can have its own StyleSheet, but by default one sheet will be shared by all of the HTMLEditorKit instances. HTMLDocument instance can also have a StyleSheet, which holds the document-specific CSS specifications.</target>
        </trans-unit>
        <trans-unit id="853c2b2cc138799245561165af6aeca2d462a6c9" translate="yes" xml:space="preserve">
          <source>The primary intent is to support scaling and skewing, though other effects are possible.</source>
          <target state="translated">The primary intent is to support scaling and skewing, though other effects are possible.</target>
        </trans-unit>
        <trans-unit id="4616eb214fb3d1763d1d2d39382e94401c0c6dd6" translate="yes" xml:space="preserve">
          <source>The primary method for awaiting completion and extracting results of a task is &lt;a href=&quot;#join()&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, but there are several variants: The &lt;a href=&quot;future#get()&quot;&gt;&lt;code&gt;Future.get()&lt;/code&gt;&lt;/a&gt; methods support interruptible and/or timed waits for completion and report results using &lt;code&gt;Future&lt;/code&gt; conventions. Method &lt;a href=&quot;#invoke()&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt;&lt;/a&gt; is semantically equivalent to &lt;code&gt;fork(); join()&lt;/code&gt; but always attempts to begin execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method &lt;code&gt;invokeAll&lt;/code&gt; (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.</source>
          <target state="translated">The primary method for awaiting completion and extracting results of a task is &lt;a href=&quot;#join()&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;, but there are several variants: The &lt;a href=&quot;future#get()&quot;&gt; &lt;code&gt;Future.get()&lt;/code&gt; &lt;/a&gt; methods support interruptible and/or timed waits for completion and report results using &lt;code&gt;Future&lt;/code&gt; conventions. Method &lt;a href=&quot;#invoke()&quot;&gt; &lt;code&gt;invoke()&lt;/code&gt; &lt;/a&gt; is semantically equivalent to &lt;code&gt;fork(); join()&lt;/code&gt; but always attempts to begin execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method &lt;code&gt;invokeAll&lt;/code&gt; (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.</target>
        </trans-unit>
        <trans-unit id="5aa8250cbbb0c762aa091de1f6729c7a726f2772" translate="yes" xml:space="preserve">
          <source>The primary method for awaiting completion and extracting results of a task is &lt;a href=&quot;forkjointask#join--&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, but there are several variants: The &lt;a href=&quot;future#get--&quot;&gt;&lt;code&gt;Future.get()&lt;/code&gt;&lt;/a&gt; methods support interruptible and/or timed waits for completion and report results using &lt;code&gt;Future&lt;/code&gt; conventions. Method &lt;a href=&quot;forkjointask#invoke--&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt;&lt;/a&gt; is semantically equivalent to &lt;code&gt;fork(); join()&lt;/code&gt; but always attempts to begin execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method &lt;code&gt;invokeAll&lt;/code&gt; (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.</source>
          <target state="translated">완료를 기다리고 작업의 결과를 추출하는 기본 방법은 &lt;a href=&quot;forkjointask#join--&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 이지만 몇 가지 변형이 있습니다. &lt;a href=&quot;future#get--&quot;&gt; &lt;code&gt;Future.get()&lt;/code&gt; &lt;/a&gt; 메서드는 인터럽트 가능 및 / 또는 시간 초과 된 대기를 지원하고 &lt;code&gt;Future&lt;/code&gt; 규칙을 사용하여 결과를보고합니다 . &lt;a href=&quot;forkjointask#invoke--&quot;&gt; &lt;code&gt;invoke()&lt;/code&gt; &lt;/a&gt; 메소드 는 의미 적으로 &lt;code&gt;fork(); join()&lt;/code&gt; 와 같습니다 . join () 이지만 항상 현재 스레드에서 실행을 시작하려고합니다. 이러한 메소드 의 &quot; &lt;em&gt;조용한&lt;/em&gt; &quot;형식은 결과를 추출하거나 예외를보고하지 않습니다. 이는 일련의 작업이 실행될 때 유용 할 수 있으며 모든 작업이 완료 될 때까지 결과 또는 예외 처리를 지연시켜야합니다. 메소드 &lt;code&gt;invokeAll&lt;/code&gt; (여러 버전에서 사용 가능) 가장 일반적인 형태의 병렬 호출을 수행합니다. 일련의 작업을 분기하고 모든 작업을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="00886361fc8e5debb687daae7baa2873e040b957" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is for testing frameworks. Per-request headers can be set through one of the &lt;code&gt;HttpRequest&lt;/code&gt;&lt;a href=&quot;httprequest.builder#header(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">The primary purpose of this method is for testing frameworks. Per-request headers can be set through one of the &lt;code&gt;HttpRequest&lt;/code&gt; &lt;a href=&quot;httprequest.builder#header(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; methods.</target>
        </trans-unit>
        <trans-unit id="e7ff3a60b668a9b4f8ca3f3d80ba5d198b1e81f9" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제는 클래스 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99d4de701d15e3c0f3d5abd8f5d765bb2d14afb5" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description of &lt;code&gt;CertPathBuilder&lt;/code&gt; for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제 는 &lt;code&gt;CertPathBuilder&lt;/code&gt; 의 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bfe43c7ad82b7b062c6a1e827670b3dcd56247c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description of &lt;code&gt;CertPathValidator&lt;/code&gt; for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제 는 &lt;code&gt;CertPathValidator&lt;/code&gt; 의 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f3e653a9912f2fb83d0c6901343dcf8706cee3d" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow programmatic examination of the reasons behind the failure of the opening handshake. Some of these reasons might allow recovery.</source>
          <target state="translated">The primary purpose of this method is to allow programmatic examination of the reasons behind the failure of the opening handshake. Some of these reasons might allow recovery.</target>
        </trans-unit>
        <trans-unit id="8fe693196ff316383da883ba4c0bb6bb52e8167c" translate="yes" xml:space="preserve">
          <source>The primary reasons to provide an explicit declaration for the canonical constructor or accessor methods are to validate constructor arguments, perform defensive copies on mutable components, or normalize groups of components (such as reducing a rational number to lowest terms.)</source>
          <target state="translated">표준 생성자 또는 접근 자 메서드에 대한 명시 적 선언을 제공하는 주된 이유는 생성자 인수의 유효성을 검사하고, 변경 가능한 구성 요소에 대해 방어적인 복사본을 수행하거나, 구성 요소 그룹을 정규화 (예 : 합리적 수를 최저 조건으로 줄임)하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f492c04efa6c01604221d247f621ebc339b6f64" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83fc8baed5ef78ca23821a13e04a9d8ddd10f762" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">프리미티브 유형 &lt;code&gt;byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f471c30cb2c84f70470f03c585738bdc64b599e" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">원시 형 &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e44aee72206b87354d815ff88a92f784a937e888" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">원시 타입은 &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd515036f97bf6ba858fdf01810f65a40a4f0c9c" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3a71348ea0fed210633648dce17501818f0109" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dbfb61247c4fbf66782c11b9ea7234fee3f4c1e" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">기본 유형은 &lt;code&gt;long&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbd45dce2a86e7713945fe9ae4375a42101fb99a" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">기본 유형 &lt;code&gt;short&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13f1d1c5a513be9280a101289705bc830feffc07" translate="yes" xml:space="preserve">
          <source>The principal methods are defined to allow the throwing of an exception. In normal use, no exceptions will be thrown, however one possible implementation would be to obtain the time from a central time server across the network. Obviously, in this case the lookup could fail, and so the method is permitted to throw an exception.</source>
          <target state="translated">주요 메소드는 예외 발생을 허용하도록 정의됩니다. 정상적인 사용에서는 예외가 발생하지 않지만 네트워크를 통해 중앙 시간 서버에서 시간을 얻는 것이 가능합니다. 분명히이 경우 조회가 실패 할 수 있으므로 메소드에서 예외가 발생하도록 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e475d06aeb71dedfae8b203b7c5051f7f55447ac" translate="yes" xml:space="preserve">
          <source>The principal name can be specified in the configuration entry by using the option &lt;code&gt;principal&lt;/code&gt;. The principal name can either be a simple user name, a service name such as &lt;code&gt;host/mission.eng.sun.com&lt;/code&gt;, or &quot;*&quot;. The principal can also be set using the system property &lt;code&gt;&lt;span id=&quot;sun.security.krb5.principal&quot;&gt;sun.security.krb5.principal&lt;/span&gt;&lt;/code&gt;. This property is checked during login. If this property is not set, then the principal name from the configuration is used. In the case where the principal property is not set and the principal entry also does not exist, the user is prompted for the name. When this property of entry is set, and &lt;code&gt;useTicketCache&lt;/code&gt; is set to true, only TGT belonging to this principal is used.</source>
          <target state="translated">주요 이름이 옵션을 사용하여 구성 항목을 지정할 수 있습니다 &lt;code&gt;principal&lt;/code&gt; . 주요 이름은 간단한 사용자 이름, &lt;code&gt;host/mission.eng.sun.com&lt;/code&gt; 과 같은 서비스 이름 또는 &quot;*&quot;일 수 있습니다. 주체는 시스템 등록 정보 &lt;code&gt;&lt;span id=&quot;sun.security.krb5.principal&quot;&gt;sun.security.krb5.principal&lt;/span&gt;&lt;/code&gt; 을 사용하여 설정할 수도 있습니다 . 이 속성은 로그인 중에 확인됩니다. 이 속성이 설정되지 않은 경우 구성의 주체 이름이 사용됩니다. 주체 속성이 설정되어 있지 않고 주체 항목도없는 경우 사용자에게 이름을 입력하라는 메시지가 표시됩니다. 이 항목 속성이 설정되고 &lt;code&gt;useTicketCache&lt;/code&gt; 가 true로 설정되면이 주체에 속한 TGT 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="00414fce4c7455a893959b39576e22c2ae5eafaa" translate="yes" xml:space="preserve">
          <source>The principal operations on a &lt;code&gt;StringBuffer&lt;/code&gt; are the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;insert&lt;/code&gt; methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string buffer. The &lt;code&gt;append&lt;/code&gt; method always adds these characters at the end of the buffer; the &lt;code&gt;insert&lt;/code&gt; method adds the characters at a specified point.</source>
          <target state="translated">&lt;code&gt;StringBuffer&lt;/code&gt; 의 주요 작업 은 &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 방법이며, 모든 유형의 데이터를 허용하도록 오버로드됩니다. 각각은 주어진 데이텀을 효과적으로 문자열로 변환 한 다음 해당 문자열의 문자를 문자열 버퍼에 추가하거나 삽입합니다. &lt;code&gt;append&lt;/code&gt; 방법은 항상 버퍼의 끝에서 이러한 문자를 추가; &lt;code&gt;insert&lt;/code&gt; 방법은 지정된 지점에 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8d9eb8cbf18b97db213dc84e3622468146efcc16" translate="yes" xml:space="preserve">
          <source>The principal operations on a &lt;code&gt;StringBuilder&lt;/code&gt; are the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;insert&lt;/code&gt; methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string builder. The &lt;code&gt;append&lt;/code&gt; method always adds these characters at the end of the builder; the &lt;code&gt;insert&lt;/code&gt; method adds the characters at a specified point.</source>
          <target state="translated">&lt;code&gt;StringBuilder&lt;/code&gt; 의 주요 작업 은 &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 방법으로, 모든 유형의 데이터를 허용하도록 오버로드됩니다. 각각은 주어진 데이텀을 효과적으로 문자열로 변환 한 다음 해당 문자열의 문자를 문자열 빌더에 추가하거나 삽입합니다. &lt;code&gt;append&lt;/code&gt; 방법은 항상 빌더의 끝 부분에 이러한 문자를 추가; &lt;code&gt;insert&lt;/code&gt; 방법은 지정된 지점에 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cdd711677992dcb1524f6e2386709d058ae3ac67" translate="yes" xml:space="preserve">
          <source>The principal purpose of these additions is to allow the specification of tables to use in encoding abbreviated streams. The built-in JPEG writer will also accept an ordinary &lt;code&gt;ImageWriteParam&lt;/code&gt;, in which case the writer will construct the necessary tables internally.</source>
          <target state="translated">이러한 추가의 주요 목적은 테이블 지정이 축약 된 스트림을 인코딩하는 데 사용할 수 있도록하는 것입니다. 내장 JPEG 라이터는 일반적인 &lt;code&gt;ImageWriteParam&lt;/code&gt; 을 수용하며 ,이 경우 라이터는 필요한 테이블을 내부적으로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="afec8d4b049429203a01c98d5a3e84b26efa406b" translate="yes" xml:space="preserve">
          <source>The principal's hash code.</source>
          <target state="translated">보안 주체의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="99b62f8c1f2db55b89f9c40aba475d2a194e0285" translate="yes" xml:space="preserve">
          <source>The principal's name.</source>
          <target state="translated">교장의 이름.</target>
        </trans-unit>
        <trans-unit id="5135ad9a2bb1192cebdf1c42bbd61662695e861a" translate="yes" xml:space="preserve">
          <source>The principal's string name.</source>
          <target state="translated">보안 주체의 문자열 이름입니다.</target>
        </trans-unit>
        <trans-unit id="79e1de7f953be5214dc8046cee3435b263a6bc9b" translate="yes" xml:space="preserve">
          <source>The print data and the processing instructions are separate entities. This means that:</source>
          <target state="translated">인쇄 데이터와 처리 지침은 별도의 엔터티입니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="87fa994137d2af295902c75d6d1e468277e6adf3" translate="yes" xml:space="preserve">
          <source>The print data format is unspecified (just an octet stream)</source>
          <target state="translated">인쇄 데이터 형식이 지정되지 않았습니다 (옥텟 스트림 만).</target>
        </trans-unit>
        <trans-unit id="2887ef4584b4a46b117c104e5d5bafd49277b4db" translate="yes" xml:space="preserve">
          <source>The print service indicates that a - possibly transient - problem may require external intervention before the print service can continue.</source>
          <target state="translated">The print service indicates that a - possibly transient - problem may require external intervention before the print service can continue.</target>
        </trans-unit>
        <trans-unit id="87d74c41b031f63a36b535b9f8f87b980e7f4993" translate="yes" xml:space="preserve">
          <source>The print service indicates that a - possibly transient - problem may require external intervention before the print service can continue. One example of an event that can generate this message is when the printer runs out of paper.</source>
          <target state="translated">인쇄 서비스는 일시적인 문제로 인해 인쇄 서비스를 계속하기 전에 외부 개입이 필요할 수 있음을 나타냅니다. 이 메시지를 생성 할 수있는 이벤트의 한 예는 프린터에 용지가 부족한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="8c9efeedc8343f07e9cac56c5db7dfd99892ddd9" translate="yes" xml:space="preserve">
          <source>The print service reports that the job cannot be completed.</source>
          <target state="translated">The print service reports that the job cannot be completed.</target>
        </trans-unit>
        <trans-unit id="6ffca2a80baec343c1fe37408ec848806e832a04" translate="yes" xml:space="preserve">
          <source>The print service reports that the job cannot be completed. The application must resubmit the job.</source>
          <target state="translated">인쇄 서비스에서 작업을 완료 할 수 없다고보고합니다. 응용 프로그램은 작업을 다시 제출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee3379a27f4d6bd5aea086e7d040f37f1b4e28e0" translate="yes" xml:space="preserve">
          <source>The printable area is specified to be a rectangle, within the overall dimensions of a media.</source>
          <target state="translated">인쇄 가능한 영역은 용지의 전체 크기 내에서 사각형으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a424ad159a01af0ae87f7797a6b6f5420eea6d5" translate="yes" xml:space="preserve">
          <source>The printer attempts to make the external job attribute values take precedence over embedded instructions in the documents' print data, however there is no guarantee.</source>
          <target state="translated">프린터가 외부 작업 속성 값을 문서의 인쇄 데이터에 포함 된 지시 사항보다 우선하게하려고하지만 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c845bc5a10dc5d6856a87ec303fc2db4c49089d3" translate="yes" xml:space="preserve">
          <source>The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="481ecce0067802bcb30b2bcd366ca961b211a6bb" translate="yes" xml:space="preserve">
          <source>The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt;). This reason is intended to cover any file access problem,including file does not exist and access denied because of an access control problem. Whether the printer aborts the job and moves the job to the &lt;code&gt;ABORTED&lt;/code&gt; job state or prints all documents that are accessible and moves the job to the &lt;code&gt;COMPLETED&lt;/code&gt; job state and adds the &lt;code&gt;COMPLETED_WITH_ERRORS&lt;/code&gt; reason to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute depends on implementation and/or site policy. This value should be supported if the printer supports doc flavors with &lt;code&gt;URL&lt;/code&gt; print data representation objects.</source>
          <target state="translated">The printer could not access one or more documents passed by reference (i.e., the print data representation object is a &lt;code&gt;URL&lt;/code&gt; ). This reason is intended to cover any file access problem,including file does not exist and access denied because of an access control problem. Whether the printer aborts the job and moves the job to the &lt;code&gt;ABORTED&lt;/code&gt; job state or prints all documents that are accessible and moves the job to the &lt;code&gt;COMPLETED&lt;/code&gt; job state and adds the &lt;code&gt;COMPLETED_WITH_ERRORS&lt;/code&gt; reason to the job's &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; attribute depends on implementation and/or site policy. This value should be supported if the printer supports doc flavors with &lt;code&gt;URL&lt;/code&gt; print data representation objects.</target>
        </trans-unit>
        <trans-unit id="22182d19201ff4051207c19a5ee208fd4a5a1b2f" translate="yes" xml:space="preserve">
          <source>The printer decides how to interpret the print data; the way this &quot;autosensing&quot; works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt;, &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">The printer decides how to interpret the print data; the way this &quot;autosensing&quot; works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt; , &lt;code&gt;URL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="420689a193f1513253aa8f7350cd70790dfdb9dd" translate="yes" xml:space="preserve">
          <source>The printer decides how to interpret the print data; the way this &quot;autosensing&quot; works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">프린터는 인쇄 데이터 해석 방법을 결정합니다. 이 &quot;자동 감지&quot;작동 방식은 구현에 따라 다릅니다. 일반적으로 미리 포맷 된 자동 감지 인쇄 데이터는 바이트 지향 표현 클래스 (바이트 배열, InputStream, URL)로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d27c6ece8fd59adc7c9db5b4829fd7026afa41" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer has not finished accessing or accepting all the print data yet.</source>
          <target state="translated">프린터가 인쇄 작업을 만들었지 만 프린터가 아직 모든 인쇄 데이터에 액세스하거나 수락하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5b838c048d7373b6f5fece71927c2c6d92736461" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state.</source>
          <target state="translated">The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state.</target>
        </trans-unit>
        <trans-unit id="f5116fa6c6a863806c7589febab48774aa25fcd4" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state. If a printer starts processing before it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; reason, but the &lt;code&gt;JOB_INCOMING&lt;/code&gt; reason remains. If a printer starts processing after it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; and &lt;code&gt;JOB_INCOMING&lt;/code&gt; reasons at the same time.</source>
          <target state="translated">The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the &lt;code&gt;PROCESSING&lt;/code&gt; state. If a printer starts processing before it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; reason, but the &lt;code&gt;JOB_INCOMING&lt;/code&gt; reason remains. If a printer starts processing after it has received all data, the printer removes the &lt;code&gt;JOB_DATA_INSUFFICIENT&lt;/code&gt; and &lt;code&gt;JOB_INCOMING&lt;/code&gt; reasons at the same time.</target>
        </trans-unit>
        <trans-unit id="2c6e9c3b42f4bb17ba7645de0aa8f126f95272d5" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the PROCESSING state. If a printer starts processing before it has received all data, the printer removes the JOB_DATA_INSUFFICIENT reason, but the JOB_INCOMING reason remains. If a printer starts processing after it has received all data, the printer removes the JOB_DATA_INSUFFICIENT and JOB_INCOMING reasons at the same time.</source>
          <target state="translated">프린터가 인쇄 작업을 생성했지만 프린터가 작업을 처리 중 상태로 옮기기 전에 추가 인쇄 데이터가 필요합니다. 프린터가 모든 데이터를 받기 전에 처리를 시작하면 프린터는 JOB_DATA_INSUFFICIENT 이유를 제거하지만 JOB_INCOMING 이유는 남아 있습니다. 프린터가 모든 데이터를 수신 한 후 처리를 시작하면 프린터는 JOB_DATA_INSUFFICIENT 및 JOB_INCOMING 이유를 동시에 제거합니다.</target>
        </trans-unit>
        <trans-unit id="26f86c1fd10f95e2e1ce6d73964c40d138b16512" translate="yes" xml:space="preserve">
          <source>The printer has detected an error other than ones listed below.</source>
          <target state="translated">프린터가 아래 나열된 오류 이외의 오류를 감지했습니다.</target>
        </trans-unit>
        <trans-unit id="ee4d72184cd18cc72c7888278ace0c6fd62b60fb" translate="yes" xml:space="preserve">
          <source>The printer has made the job ready for printing, but the output device is not yet printing it, either because the job hasn't reached the output device or because the job is queued in the output device or some other spooler, awaiting the output device to print it.</source>
          <target state="translated">프린터가 작업을 인쇄 준비 상태로 만들었지 만 작업이 출력 장치에 도달하지 않았거나 출력 장치 또는 다른 스풀러에서 작업이 대기하여 출력 장치를 대기 중이기 때문에 출력 장치가 아직 인쇄하지 않습니다 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bb06ac1489baa54ea2bee8733b418deb9986e56c" translate="yes" xml:space="preserve">
          <source>The printer has scheduled a job on the output device and is in the process of connecting to a shared network output device (and might not be able to actually start printing the job for an arbitrarily long time depending on the usage of the output device by other servers on the network).</source>
          <target state="translated">프린터가 출력 장치에서 작업을 예약했으며 공유 네트워크 출력 장치에 연결하는 중입니다 (다른 장치의 출력 장치 사용에 따라 실제로 장시간 인쇄 작업을 시작하지 못할 수 있음) 네트워크상의 서버).</target>
        </trans-unit>
        <trans-unit id="8e0bf3607b8e2970cff88cf552730d6f2d8d625d" translate="yes" xml:space="preserve">
          <source>The printer is capable of some type of color printing, such as highlight color or full process color.</source>
          <target state="translated">프린터는 밝은 색상 또는 전체 프로세스 색상과 같은 일부 유형의 컬러 인쇄가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c005cdea131511c73720a6f53d9a8366cf1ca01d" translate="yes" xml:space="preserve">
          <source>The printer is currently accepting jobs.</source>
          <target state="translated">프린터가 현재 작업을 수락하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c387e9c6647fb266c1648f1dc120f6cc016ad4" translate="yes" xml:space="preserve">
          <source>The printer is currently rejecting any jobs sent to it.</source>
          <target state="translated">프린터가 현재 전송 된 작업을 거부하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="05b2fabb7aa801e323b9d634f91b48efaabae0c1" translate="yes" xml:space="preserve">
          <source>The printer is in the process of stopping the device and will be stopped in a while.</source>
          <target state="translated">The printer is in the process of stopping the device and will be stopped in a while.</target>
        </trans-unit>
        <trans-unit id="a53658e3838a5dc4333bc6672baea14965848810" translate="yes" xml:space="preserve">
          <source>The printer is in the process of stopping the device and will be stopped in a while. When the device is stopped, the printer will change the &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;STOPPED&lt;/code&gt;. The &lt;code&gt;STOPPING&lt;/code&gt; reason is never an error, even for a printer with a single output device. When an output device ceases accepting jobs, the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; will have this reason while the output device completes printing.</source>
          <target state="translated">The printer is in the process of stopping the device and will be stopped in a while. When the device is stopped, the printer will change the &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; to &lt;code&gt;STOPPED&lt;/code&gt; . The &lt;code&gt;STOPPING&lt;/code&gt; reason is never an error, even for a printer with a single output device. When an output device ceases accepting jobs, the printer's &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; will have this reason while the output device completes printing.</target>
        </trans-unit>
        <trans-unit id="c8b0ff98c2f13c970471be7702bd134d6dbdc6cc" translate="yes" xml:space="preserve">
          <source>The printer is in the process of stopping the device and will be stopped in a while. When the device is stopped, the printer will change the &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; to STOPPED. The STOPPING reason is never an error, even for a printer with a single output device. When an output device ceases accepting jobs, the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; will have this reason while the output device completes printing.</source>
          <target state="translated">프린터가 장치를 중지하는 중이며 잠시 후에 중지됩니다. 장치가 중지되면 프린터는 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 를 STOPPED로 변경합니다 . 단일 출력 장치가있는 프린터의 경우에도 STOPPING 이유는 오류가 아닙니다. 출력 장치가 작업 수락을 중단 하면 출력 장치가 인쇄를 완료하는 동안 프린터의 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 에이 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="54f62f72799c6d5e9a37cf0c00f4e1b535987780" translate="yes" xml:space="preserve">
          <source>The printer is not capable of any type of color printing.</source>
          <target state="translated">프린터는 어떤 유형의 컬러 인쇄도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b38e5fa5b8409dddee614ca089cd0362c79f47f" translate="yes" xml:space="preserve">
          <source>The printer is off-line and accepting no jobs.</source>
          <target state="translated">The printer is off-line and accepting no jobs.</target>
        </trans-unit>
        <trans-unit id="1afe6d85c12a8a8b5a7f1edd564ce3193ddf2261" translate="yes" xml:space="preserve">
          <source>The printer is off-line and accepting no jobs. All &lt;code&gt;PENDING&lt;/code&gt; jobs are put into the &lt;code&gt;PENDING_HELD&lt;/code&gt; state. This situation could be true if the service's or document transform's input is impaired or broken.</source>
          <target state="translated">The printer is off-line and accepting no jobs. All &lt;code&gt;PENDING&lt;/code&gt; jobs are put into the &lt;code&gt;PENDING_HELD&lt;/code&gt; state. This situation could be true if the service's or document transform's input is impaired or broken.</target>
        </trans-unit>
        <trans-unit id="a76ccbd08fd7ed213da23153a2832c1f11f3ddb7" translate="yes" xml:space="preserve">
          <source>The printer is off-line and accepting no jobs. All PENDING jobs are put into the PENDING_HELD state. This situation could be true if the service's or document transform's input is impaired or broken.</source>
          <target state="translated">프린터가 오프라인 상태이며 작업을 수락하지 않습니다. 모든 PENDING 작업은 PENDING_HELD 상태가됩니다. 서비스 또는 문서 변환의 입력이 손상되었거나 손상된 경우이 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ea5b5a51cabfc6ce87f4bba805d145bf23c69d" translate="yes" xml:space="preserve">
          <source>The printer is transmitting the job to the output device.</source>
          <target state="translated">프린터가 작업을 출력 장치로 전송하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1b431e7082d79aa73c78295a787c0420e076b7" translate="yes" xml:space="preserve">
          <source>The printer makes no attempt to make the external job attribute values take precedence over embedded instructions in the documents' print data.</source>
          <target state="translated">프린터는 문서의 인쇄 데이터에 포함 된 지시 사항보다 외부 작업 속성 값을 우선시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc15b2e767f5374c6b094a0dfd57a256c58156f6" translate="yes" xml:space="preserve">
          <source>The printer should make reasonable attempts to print the job, even if it cannot print it exactly as specified.</source>
          <target state="translated">프린터는 지정된대로 정확하게 인쇄 할 수 없더라도 작업 인쇄를 합리적으로 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="e18a8686bb628a68a2eaf4c30403e4349bfe5fcd" translate="yes" xml:space="preserve">
          <source>The printer state is unknown.</source>
          <target state="translated">프린터 상태를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95f20fd944e4a43232c41915ad9d367576e3c214" translate="yes" xml:space="preserve">
          <source>The printing system may request a page index more than once. On each occasion equal PageFormat parameters will be supplied.</source>
          <target state="translated">The printing system may request a page index more than once. On each occasion equal PageFormat parameters will be supplied.</target>
        </trans-unit>
        <trans-unit id="63d426c5363736a80887b7073605a6606087a1b4" translate="yes" xml:space="preserve">
          <source>The printing system will call &lt;code&gt;Printable.print(..)&lt;/code&gt; with page indexes which increase monotonically, although as noted above, the &lt;code&gt;Printable&lt;/code&gt; should expect multiple calls for a page index and that page indexes may be skipped, when page ranges are specified by the client, or by a user through a print dialog.</source>
          <target state="translated">The printing system will call &lt;code&gt;Printable.print(..)&lt;/code&gt; with page indexes which increase monotonically, although as noted above, the &lt;code&gt;Printable&lt;/code&gt; should expect multiple calls for a page index and that page indexes may be skipped, when page ranges are specified by the client, or by a user through a print dialog.</target>
        </trans-unit>
        <trans-unit id="08bc056d9ef081c3233d58a84e37a59beef78d75" translate="yes" xml:space="preserve">
          <source>The printwriter associated with this console</source>
          <target state="translated">이 콘솔과 관련된 인쇄기</target>
        </trans-unit>
        <trans-unit id="42f954696c5f60bbc139b566f392ccb1636872f4" translate="yes" xml:space="preserve">
          <source>The priority level of this glyph as it is growing.</source>
          <target state="translated">The priority level of this glyph as it is growing.</target>
        </trans-unit>
        <trans-unit id="628a678ead91170d2283b79dc824cb7b5316e893" translate="yes" xml:space="preserve">
          <source>The priority level of this glyph as it is shrinking.</source>
          <target state="translated">The priority level of this glyph as it is shrinking.</target>
        </trans-unit>
        <trans-unit id="6701aac4c822d072a47e34f47ed4c1b355734957" translate="yes" xml:space="preserve">
          <source>The priority of the newly created thread is set equal to the priority of the thread creating it, that is, the currently running thread. The method &lt;a href=&quot;#setPriority(int)&quot;&gt;setPriority&lt;/a&gt; may be used to change the priority to a new value.</source>
          <target state="translated">The priority of the newly created thread is set equal to the priority of the thread creating it, that is, the currently running thread. The method &lt;a href=&quot;#setPriority(int)&quot;&gt;setPriority&lt;/a&gt; may be used to change the priority to a new value.</target>
        </trans-unit>
        <trans-unit id="97a7ef6f1e3cb3a0aaedfb170ff09b511361e6da" translate="yes" xml:space="preserve">
          <source>The priority of the newly created thread is set equal to the priority of the thread creating it, that is, the currently running thread. The method &lt;a href=&quot;thread#setPriority-int-&quot;&gt;setPriority&lt;/a&gt; may be used to change the priority to a new value.</source>
          <target state="translated">새로 작성된 스레드의 우선 순위는 스레드를 작성하는 스레드의 우선 순위, 즉 현재 실행중인 스레드와 동일하게 설정됩니다. &lt;a href=&quot;thread#setPriority-int-&quot;&gt;setPriority&lt;/a&gt; 메소드 는 우선 순위를 새로운 값으로 변경하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad67cfc9e7ec6a73ea73ab912679bd94c7119e41" translate="yes" xml:space="preserve">
          <source>The priority of the thread associated with this &lt;code&gt;ThreadInfo&lt;/code&gt;.</source>
          <target state="translated">The priority of the thread associated with this &lt;code&gt;ThreadInfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c66994c2e5565d62182013ffae28875f5cf6f391" translate="yes" xml:space="preserve">
          <source>The probe result is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string must be parsable according to the grammar in the RFC 2045.</source>
          <target state="translated">프로브 결과는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 컨텐츠 유형 값의 문자열 형식입니다 . RFC 2045의 문법에 따라 문자열을 구문 분석 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="de3f9f0af3ad65a2fa21912e8d0d887a5b5a28c3" translate="yes" xml:space="preserve">
          <source>The probe result is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string must be parsable according to the grammar in the RFC 2045.</source>
          <target state="translated">검사 결과는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) Part One : Format of Internet Message Bodies에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 콘텐츠 유형 값의 문자열 형식입니다 . 문자열은 RFC 2045의 문법에 따라 구문 분석 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2212334559e7a887fc928254facb62421de92a5a" translate="yes" xml:space="preserve">
          <source>The process is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the process continues executing asynchronously.</source>
          <target state="translated">The process is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the process continues executing asynchronously.</target>
        </trans-unit>
        <trans-unit id="b41ea041545c20c101d2c5766605f8c26aba0a1d" translate="yes" xml:space="preserve">
          <source>The process may be observed to have terminated with &lt;a href=&quot;#isAlive()&quot;&gt;&lt;code&gt;isAlive()&lt;/code&gt;&lt;/a&gt; before the ComputableFuture is completed and dependent actions are invoked.</source>
          <target state="translated">The process may be observed to have terminated with &lt;a href=&quot;#isAlive()&quot;&gt; &lt;code&gt;isAlive()&lt;/code&gt; &lt;/a&gt; before the ComputableFuture is completed and dependent actions are invoked.</target>
        </trans-unit>
        <trans-unit id="006b08040b73f5d34fb2e71fc14a1d7d47de63f1" translate="yes" xml:space="preserve">
          <source>The process may not terminate immediately. i.e. &lt;code&gt;isAlive()&lt;/code&gt; may return true for a brief period after &lt;code&gt;destroyForcibly()&lt;/code&gt; is called. This method may be chained to &lt;code&gt;waitFor()&lt;/code&gt; if needed.</source>
          <target state="translated">The process may not terminate immediately. i.e. &lt;code&gt;isAlive()&lt;/code&gt; may return true for a brief period after &lt;code&gt;destroyForcibly()&lt;/code&gt; is called. This method may be chained to &lt;code&gt;waitFor()&lt;/code&gt; if needed.</target>
        </trans-unit>
        <trans-unit id="880dec8515b711c27c013e6c9697d99218ffed43" translate="yes" xml:space="preserve">
          <source>The process of implementing a set by extending this class is identical to that of implementing a Collection by extending AbstractCollection, except that all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the &lt;code&gt;Set&lt;/code&gt; interface (for instance, the add method must not permit addition of multiple instances of an object to a set).</source>
          <target state="translated">이 클래스를 확장하여 세트를 구현하는 프로세스는이 클래스의 서브 클래스에있는 모든 메소드 및 생성자가 &lt;code&gt;Set&lt;/code&gt; 인터페이스 에 의해 부과 된 추가 제한 조건을 준수해야한다는 점을 제외하면 AbstractCollection을 확장하여 Collection을 구현하는 프로세스와 동일합니다 . add 메소드는 오브젝트의 여러 인스턴스를 세트에 추가 할 수 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="e1ec3b94c22e460ebbbb042de3db1027d96793ab" translate="yes" xml:space="preserve">
          <source>The process of normalization is specific to each calendar system. For example, in the ISO calendar system, the years and months are normalized but the days are not, such that &quot;15 months&quot; would be normalized to &quot;1 year and 3 months&quot;.</source>
          <target state="translated">정규화 프로세스는 각 달력 시스템에 따라 다릅니다. 예를 들어, ISO 달력 시스템에서 연도와 월은 정규화되지만 요일은 그렇지 않으므로 &quot;15 개월&quot;은 &quot;1 년 3 개월&quot;로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a0880060c6bd165f58bb9740e5b98b10e7366b11" translate="yes" xml:space="preserve">
          <source>The process of writing changes in a &lt;code&gt;RowSet&lt;/code&gt; object to its data source is known as</source>
          <target state="translated">The process of writing changes in a &lt;code&gt;RowSet&lt;/code&gt; object to its data source is known as</target>
        </trans-unit>
        <trans-unit id="cf7301191430bba9ec8368d5ffbc647fac0cf73d" translate="yes" xml:space="preserve">
          <source>The process that looks for a class name in the &lt;code&gt;META-INF/services/org.xml.sax.driver&lt;/code&gt; file in a jar file does not conform to the specification of the service-provider loading facility as defined in &lt;a href=&quot;../../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; and therefore does not support modularization. It is deprecated as of Java SE 9 and subject to removal in a future release.</source>
          <target state="translated">The process that looks for a class name in the &lt;code&gt;META-INF/services/org.xml.sax.driver&lt;/code&gt; file in a jar file does not conform to the specification of the service-provider loading facility as defined in &lt;a href=&quot;../../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; and therefore does not support modularization. It is deprecated as of Java SE 9 and subject to removal in a future release.</target>
        </trans-unit>
        <trans-unit id="455f1746aa3e2b37c23f02cccc11f1194c2bd1f7" translate="yes" xml:space="preserve">
          <source>The processing instruction does not specify how the print job processes the request; each processing instruction is only a description of the results of a print job. The print job determines the manner in which it achieves the results specified by the processing instructions. Representing processing instructions as descriptive items provides more flexibility for implementing print jobs.</source>
          <target state="translated">처리 명령은 인쇄 작업이 요청을 처리하는 방법을 지정하지 않습니다. 각 처리 명령은 인쇄 작업 결과에 대한 설명 일뿐입니다. 인쇄 작업에 따라 처리 지침에 지정된 결과를 얻는 방식이 결정됩니다. 처리 지침을 설명 항목으로 표시하면 인쇄 작업을보다 유연하게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21c5292c5f0f85748710a360b9fb4d2c8ebb894" translate="yes" xml:space="preserve">
          <source>The processor may choose to continue, but will not normally proceed to a successful completion.</source>
          <target state="translated">The processor may choose to continue, but will not normally proceed to a successful completion.</target>
        </trans-unit>
        <trans-unit id="6f696f02deb8ba447238e7b0ba963cade3056181" translate="yes" xml:space="preserve">
          <source>The profile includes the &lt;code&gt;redColorantTag&lt;/code&gt;, &lt;code&gt;greenColorantTag&lt;/code&gt;, &lt;code&gt;blueColorantTag&lt;/code&gt;, &lt;code&gt;redTRCTag&lt;/code&gt;, &lt;code&gt;greenTRCTag&lt;/code&gt;, &lt;code&gt;blueTRCTag&lt;/code&gt;, and &lt;code&gt;mediaWhitePointTag&lt;/code&gt; tags.</source>
          <target state="translated">The profile includes the &lt;code&gt;redColorantTag&lt;/code&gt; , &lt;code&gt;greenColorantTag&lt;/code&gt; , &lt;code&gt;blueColorantTag&lt;/code&gt; , &lt;code&gt;redTRCTag&lt;/code&gt; , &lt;code&gt;greenTRCTag&lt;/code&gt; , &lt;code&gt;blueTRCTag&lt;/code&gt; , and &lt;code&gt;mediaWhitePointTag&lt;/code&gt; tags.</target>
        </trans-unit>
        <trans-unit id="fd8dfde5161913039fba723df9c9b90bc3017769" translate="yes" xml:space="preserve">
          <source>The profile's color space type is RGB.</source>
          <target state="translated">The profile's color space type is RGB.</target>
        </trans-unit>
        <trans-unit id="b21468901598e18762161fbe3cf811efedaec007" translate="yes" xml:space="preserve">
          <source>The program</source>
          <target state="translated">프로그램</target>
        </trans-unit>
        <trans-unit id="345c1d3616f08664463e96baa7a67e8da0786160" translate="yes" xml:space="preserve">
          <source>The program number is zero-based (expressed from 0 to 127). Note that MIDI hardware displays and literature about MIDI typically use the range 1 to 128 instead.</source>
          <target state="translated">The program number is zero-based (expressed from 0 to 127). Note that MIDI hardware displays and literature about MIDI typically use the range 1 to 128 instead.</target>
        </trans-unit>
        <trans-unit id="76dfc7088829bdbf1569fb6f72d786a2251045f0" translate="yes" xml:space="preserve">
          <source>The program number is zero-based (expressed from 0 to 127). Note that MIDI hardware displays and literature about MIDI typically use the range 1 to 128 instead. It is possible that the underlying synthesizer does not support a specific program. In order to verify that a call to &lt;code&gt;programChange&lt;/code&gt; was successful, use &lt;code&gt;getProgram&lt;/code&gt;.</source>
          <target state="translated">프로그램 번호는 0부터 시작합니다 (0에서 127까지 표시). MIDI에 대한 MIDI 하드웨어 디스플레이 및 문헌은 일반적으로 1-128 범위를 사용합니다. 기본 신디사이저가 특정 프로그램을 지원하지 않을 수 있습니다. &lt;code&gt;programChange&lt;/code&gt; 호출 이 성공 했는지 확인 하려면 &lt;code&gt;getProgram&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="962e35562a0df5666bf7aad07b776ace67ab18a8" translate="yes" xml:space="preserve">
          <source>The program number of the instrument that this voice is currently using.</source>
          <target state="translated">The program number of the instrument that this voice is currently using.</target>
        </trans-unit>
        <trans-unit id="4155d56e171215de9c7037e45d7bce8a1282da2c" translate="yes" xml:space="preserve">
          <source>The program number of the instrument that this voice is currently using. The value ranges from 0 to 127 if the voice is active, and is unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 현재 사용중인 악기의 프로그램 번호입니다. 음성이 활성화 된 경우 값의 범위는 0-127이며 음성이 비활성화 된 경우 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1be1f5399b975af8c707420333db180e0981d19" translate="yes" xml:space="preserve">
          <source>The programmatic name of the property that was changed. May be null if multiple properties have changed.</source>
          <target state="translated">변경된 속성의 프로그래밍 방식 이름입니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad93de22f765c96c57d8527107c09122268deb2d" translate="yes" xml:space="preserve">
          <source>The programmatic name of the property/method/event</source>
          <target state="translated">속성 / 방법 / 이벤트의 프로그래밍 이름</target>
        </trans-unit>
        <trans-unit id="4a4ca8c0566e76e0bda81fc2154a3dd169f21dfd" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and &lt;code&gt;Collection&lt;/code&gt; constructor, as per the recommendation in the &lt;code&gt;Collection&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 &lt;code&gt;Collection&lt;/code&gt; 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="61075cdab1eeb6f09db5bfab67efc96a9fe1b4d1" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 컬렉션 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="37e4fc3e466260a434320ff485db7412afec1305" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the &lt;code&gt;Collection&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 컬렉션 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92e053e057575398190a0ac956a5817f3e0304d3" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the &lt;code&gt;Map&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Map&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 맵 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f01bb378f182b23e8ed67c381eb92c51c702d451" translate="yes" xml:space="preserve">
          <source>The progress bar changes to determinate</source>
          <target state="translated">The progress bar changes to determinate</target>
        </trans-unit>
        <trans-unit id="4b5b62e95c0464429469a4601f4eedbff960af77" translate="yes" xml:space="preserve">
          <source>The progress bar is determinate and becomes displayable</source>
          <target state="translated">The progress bar is determinate and becomes displayable</target>
        </trans-unit>
        <trans-unit id="e367352ef18d207387d0a16384a607086a84bf3e" translate="yes" xml:space="preserve">
          <source>The progress bar is displayable and becomes determinate</source>
          <target state="translated">The progress bar is displayable and becomes determinate</target>
        </trans-unit>
        <trans-unit id="ff7b207dcad61e50dde5ee3a8d51e2a89562a740" translate="yes" xml:space="preserve">
          <source>The progress bar is displayable and determinate and this UI is installed</source>
          <target state="translated">The progress bar is displayable and determinate and this UI is installed</target>
        </trans-unit>
        <trans-unit id="0b58ada95969c7cc2b96e1fd97a909c42b180449" translate="yes" xml:space="preserve">
          <source>The progress bar is no longer part of a displayable hierarchy</source>
          <target state="translated">진행률 표시 줄은 더 이상 표시 가능한 계층의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7db88831546fb954fc3d5d9710f6e0ab2f4739c8" translate="yes" xml:space="preserve">
          <source>The progress indicator displays activity without specifying what proportion of the progress is complete.</source>
          <target state="translated">진행률 표시기는 완료된 진행률을 지정하지 않고 활동을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="26c5212b411b32f2f4fb4ac337ae0a4ad3976b99" translate="yes" xml:space="preserve">
          <source>The progress indicator displays with normal color and determinate mode.</source>
          <target state="translated">진행률 표시기는 일반 색상 및 결정 모드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f47f32edf9816a4f888b251afa36f949fce0846c" translate="yes" xml:space="preserve">
          <source>The progress string is painted only if the &lt;code&gt;isStringPainted&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">진행률 문자열은 &lt;code&gt;isStringPainted&lt;/code&gt; 메서드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 경우에만 그려 집니다.</target>
        </trans-unit>
        <trans-unit id="391c694a427ff64d8dedbc35ef6300a0d16bfa8a" translate="yes" xml:space="preserve">
          <source>The proleptic year, such as 2012.</source>
          <target state="translated">2012 년과 같은 다산의 해.</target>
        </trans-unit>
        <trans-unit id="2f8941a3eade121ced3151a4fbe9a184aa501fb3" translate="yes" xml:space="preserve">
          <source>The proleptic-month based, counting months sequentially from year 0.</source>
          <target state="translated">0 년부터 순차적으로 월을 계산하는 proleptic-month based.</target>
        </trans-unit>
        <trans-unit id="185505c1591ee22f4c8919b7761eb6109bcd3be2" translate="yes" xml:space="preserve">
          <source>The prompt message.</source>
          <target state="translated">프롬프트 메시지.</target>
        </trans-unit>
        <trans-unit id="4f41482df910d2f5aab39d869a803af9046ad93d" translate="yes" xml:space="preserve">
          <source>The prompt message. See the prompt attribute definition in HTML 4.0. This attribute is deprecated in HTML 4.0.</source>
          <target state="translated">프롬프트 메시지. HTML 4.0의 프롬프트 속성 정의를 참조하십시오. 이 속성은 HTML 4.0에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a56a02d5a817b1dc30304481e16ea69bcff2062" translate="yes" xml:space="preserve">
          <source>The properties for loggers and Handlers will have names starting with the dot-separated name for the handler or logger.</source>
          <target state="translated">로거 및 핸들러의 특성은 이름이 핸들러 또는 로거의 점으로 구분 된 이름으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="53b4cc1bbc02ad93af5b4e56711266aa46d88a87" translate="yes" xml:space="preserve">
          <source>The properties returned should contain properties set by the stylesheet, and these properties are &quot;defaulted&quot; by default properties specified by &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;section 16 of the XSL Transformations (XSLT) W3C Recommendation&lt;/a&gt;. The properties that were specifically set by the stylesheet should be in the base Properties list, while the XSLT default properties that were not specifically set should be in the &quot;default&quot; Properties list. Thus, getOutputProperties().getProperty(String key) will obtain any property in that was set by the stylesheet, &lt;em&gt;or&lt;/em&gt; the default properties, while getOutputProperties().get(String key) will only retrieve properties that were explicitly set in the stylesheet.</source>
          <target state="translated">반환 된 속성에는 스타일 시트에서 설정 한 속성이 포함되어야하며 이러한 속성은 &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;XSL 변환 (XSLT) W3C 권장 사항의 섹션 16에&lt;/a&gt; 지정된 기본 속성으로 &quot;기본값&quot; 입니다. 스타일 시트에서 특별히 설정 한 속성은 기본 속성 목록에 있어야하며 특별히 설정되지 않은 XSLT 기본 속성은 &quot;기본&quot;속성 목록에 있어야합니다. 따라서 getOutputProperties (). getProperty (String key)는 스타일 시트에 의해 설정된 속성 &lt;em&gt;또는&lt;/em&gt; 기본 속성을 가져 오는 반면 getOutputProperties (). get (String key)는 스타일 시트에 명시 적으로 설정된 속성 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f87075d599da93b17f19b11d041569e97b3e1ab8" translate="yes" xml:space="preserve">
          <source>The properties returned should contain properties set by the stylesheet, and these properties are &quot;defaulted&quot; by default properties specified by &lt;a href=&quot;https://www.w3.org/TR/xslt#output&quot;&gt;section 16 of the XSL Transformations (XSLT) W3C Recommendation&lt;/a&gt;. The properties that were specifically set by the stylesheet should be in the base Properties list, while the XSLT default properties that were not specifically set should be in the &quot;default&quot; Properties list. Thus, getOutputProperties().getProperty(String key) will obtain any property in that was set by the stylesheet, &lt;em&gt;or&lt;/em&gt; the default properties, while getOutputProperties().get(String key) will only retrieve properties that were explicitly set in the stylesheet.</source>
          <target state="translated">반환 된 속성에는 스타일 시트에서 설정 한 속성이 포함되어야하며 이러한 속성은 &lt;a href=&quot;https://www.w3.org/TR/xslt#output&quot;&gt;XSL 변환 (XSLT) W3C 권장 사항의 섹션 16에&lt;/a&gt; 지정된 기본 속성으로 &quot;기본값&quot; 입니다. 스타일 시트에 의해 특별히 설정된 속성은 기본 속성 목록에 있어야하며 특별히 설정되지 않은 XSLT 기본 속성은 &quot;기본&quot;속성 목록에 있어야합니다. 따라서 getOutputProperties (). getProperty (String key)는 스타일 시트에 의해 설정된 속성 &lt;em&gt;또는&lt;/em&gt; 기본 속성을 가져 오는 반면 getOutputProperties (). get (String key)는 스타일 시트에 명시 적으로 설정된 속성 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="924030f16e4e6790ddf29e1281d8ffc937efbad3" translate="yes" xml:space="preserve">
          <source>The properties returned should contain properties set by the user, and properties set by the stylesheet, and these properties are &quot;defaulted&quot; by default properties specified by &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;section 16 of the XSL Transformations (XSLT) W3C Recommendation&lt;/a&gt;. The properties that were specifically set by the user or the stylesheet should be in the base Properties list, while the XSLT default properties that were not specifically set should be the default Properties list. Thus, getOutputProperties().getProperty(String key) will obtain any property in that was set by &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt;, in the stylesheet, &lt;em&gt;or&lt;/em&gt; the default properties, while getOutputProperties().get(String key) will only retrieve properties that were explicitly set by &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt;, or in the stylesheet.</source>
          <target state="translated">반환 된 속성에는 사용자가 설정 한 속성과 스타일 시트가 설정 한 속성이 포함되어야하며 이러한 속성은 &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;XSL 변환 (XSLT) W3C 권장 사항의 섹션 16에&lt;/a&gt; 지정된 기본 속성으로 &quot;기본값&quot; 입니다. 사용자 또는 스타일 시트가 특별히 설정 한 속성은 기본 속성 목록에 있어야하며 특별히 설정되지 않은 XSLT 기본 속성은 기본 속성 목록이어야합니다. 따라서 getOutputProperties는 (). getProperty에은 (문자열 키) 그 의해 설정된 임의의 속성을 획득 할 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 스타일 시트, &lt;em&gt;또는&lt;/em&gt;기본 속성이지만 getOutputProperties (). get (String key)는 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 의해 명시 적으로 설정된 속성 만 검색합니다 . 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="8ba944ea3e8ea683f7d2f0bdb9647fb3d115acc6" translate="yes" xml:space="preserve">
          <source>The properties returned should contain properties set by the user, and properties set by the stylesheet, and these properties are &quot;defaulted&quot; by default properties specified by &lt;a href=&quot;https://www.w3.org/TR/xslt#output&quot;&gt;section 16 of the XSL Transformations (XSLT) W3C Recommendation&lt;/a&gt;. The properties that were specifically set by the user or the stylesheet should be in the base Properties list, while the XSLT default properties that were not specifically set should be the default Properties list. Thus, getOutputProperties().getProperty(String key) will obtain any property in that was set by &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt;, in the stylesheet, &lt;em&gt;or&lt;/em&gt; the default properties, while getOutputProperties().get(String key) will only retrieve properties that were explicitly set by &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt;, or in the stylesheet.</source>
          <target state="translated">반환 된 속성에는 사용자가 설정 한 속성과 스타일 시트가 설정 한 속성이 포함되어야하며 이러한 속성은 &lt;a href=&quot;https://www.w3.org/TR/xslt#output&quot;&gt;XSL 변환 (XSLT) W3C 권장 사항의 섹션 16에&lt;/a&gt; 지정된 기본 속성으로 &quot;기본값&quot;으로 설정됩니다 . 사용자 또는 스타일 시트가 특별히 설정 한 속성은 기본 속성 목록에 있어야하며 특별히 설정되지 않은 XSLT 기본 속성은 기본 속성 목록이어야합니다. 따라서 getOutputProperties는 (). getProperty에은 (문자열 키) 그 의해 설정된 임의의 속성을 획득 할 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 스타일 시트, &lt;em&gt;또는&lt;/em&gt;getOutputProperties (). get (String key)는 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 또는 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="27f833fe6fa37acd5e76ba0606a69897f0ed235c" translate="yes" xml:space="preserve">
          <source>The properties-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; 를 포함하는 속성 전용 형식 &lt;code&gt;List&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="daa8bdb84e81154bc80370cc5e9727f554ff3e32" translate="yes" xml:space="preserve">
          <source>The properties-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;unmodifiable&lt;/a&gt;.</source>
          <target state="translated">속성은 전용 형식 &lt;code&gt;List&lt;/code&gt; 포함 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; . 이 &lt;code&gt;List&lt;/code&gt; 은 &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;수정할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d2cff9c6617a0baba314ee31c1929597466d86" translate="yes" xml:space="preserve">
          <source>The properties-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</source>
          <target state="translated">&lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; 를 포함하는 속성 전용 형식 &lt;code&gt;List&lt;/code&gt; 입니다. 이 &lt;code&gt;List&lt;/code&gt; 은 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="edbaf52dc9114c17a17b8e7f6f915d29977216eb" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;JInternalFrame.isPalette&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JInternalFrame.isPalette&lt;/code&gt; 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="cf5373aab850e2de634fb8554a90fb179e5380fa" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;JScrollBar.isFreeStanding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JScrollBar.isFreeStanding&lt;/code&gt; 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="be6722df6ec5a2e75cae3fda33dde1100cbb76cd" translate="yes" xml:space="preserve">
          <source>The property can be set with the following code line: &lt;code&gt;setProperty(&quot;javax.xml.stream.isRepairingNamespaces&quot;, new Boolean(true|false));&lt;/code&gt;</source>
          <target state="translated">속성은 다음 코드 줄을 사용하여 설정할 수 있습니다. &lt;code&gt;setProperty(&quot;javax.xml.stream.isRepairingNamespaces&quot;, new Boolean(true|false));&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90ef13d5a715c58badd6aeb3009b5ac9131a03a4" translate="yes" xml:space="preserve">
          <source>The property map may contain pre-defined implementation specific and default properties. Users are encouraged to read the information and fully understand the implications, before modifying pre-existing properties.</source>
          <target state="translated">특성 맵에는 사전 정의 된 구현 특정 및 기본 특성이 포함될 수 있습니다. 기존 속성을 수정하기 전에 정보를 읽고 그 의미를 완전히 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="216631b6a2b26fcac5c37473e2eaf40759dbb441" translate="yes" xml:space="preserve">
          <source>The property name &lt;code&gt;&quot;comment&quot;&lt;/code&gt; should be used to store an optional comment which can be presented to the application as a description of the image, its source, or its author.</source>
          <target state="translated">속성 이름 &lt;code&gt;&quot;comment&quot;&lt;/code&gt; 는 이미지, 소스 또는 작성자에 대한 설명으로 응용 프로그램에 표시 될 수있는 선택적 주석을 저장하는 데 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="05614fb918268cb256ef8ff9c79e7c509c6ff6a3" translate="yes" xml:space="preserve">
          <source>The property name for the description of the stream used to initialize the document.</source>
          <target state="translated">문서를 초기화하는 데 사용되는 스트림 설명의 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="65d307effbfb6738fbc49652b7df00c768e32304" translate="yes" xml:space="preserve">
          <source>The property name for the description of the stream used to initialize the document. This should be used if the document was initialized from a stream and anything is known about the stream.</source>
          <target state="translated">문서를 초기화하는 데 사용되는 스트림 설명의 속성 이름입니다. 문서가 스트림에서 초기화되고 스트림에 대해 알려진 경우에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55766c1c4623c812c3048cdf08c9f6f33926a54f" translate="yes" xml:space="preserve">
          <source>The property name for the title of the document, if there is one.</source>
          <target state="translated">문서 제목 (있는 경우)의 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="491a849b11e4c2c0acd318273c6a61f63270a3d9" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; to recognize a property name but temporarily be unable to return its value.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; 를이&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 일시적으로 그 값을 돌려 줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b04117b905a55eae82549e4e3a2b723556877a5c" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; to recognize a property name but to be unable to change the current value.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; 를이&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 현재의 값을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="765dd3a32bda74de713a08c9e42bf1083b24e6ca" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; to recognize a property name but temporarily be unable to return its value. Some property values may be available only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능 &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 일시적으로 그 값을 돌려 줄 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6fa366af3cd654c1c35b4f151e2781b11c57e03" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; to recognize a property name but to be unable to change the current value. Some property values may be immutable or mutable only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능 &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 현재의 값을 변경할 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 변경할 수 없거나 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9efd0eeaa6302fa4fd979a20db22dc2dc37765c" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; to recognize a property name but temporarily be unable to return its value. Some property values may be available only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; 로는&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 일시적으로 그 값을 돌려 줄 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c26b08882aefe98ea2b359c6337181f87d358da5" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; to recognize a property name but to be unable to change the current value. Some property values may be immutable or mutable only in specific contexts, such as before, during, or after a validation.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. A에 대한 것이 가능하다 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; 로는&lt;/a&gt; 속성 이름을 인식 할 수 있습니다 만, 현재의 값을 변경할 수 없습니다. 일부 속성 값은 유효성 검사 전, 도중 또는 후와 같은 특정 컨텍스트에서만 변경할 수 없거나 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f21d91a82fc4c162b2dfd34fcdb2d44e94f0d92" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for an XMLReader to recognize a property name but temporarily be unable to return its value. Some property values may be available only in specific contexts, such as before, during, or after a parse.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. XMLReader가 속성 이름을 인식 할 수 있지만 일시적으로 해당 값을 반환 할 수 없습니다. 일부 속성 값은 구문 분석 전, 도중 또는 후와 같은 특정 컨텍스트에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7593858905d16bae87d6ea5c763c7dd7603e0f00" translate="yes" xml:space="preserve">
          <source>The property name is any fully-qualified URI. It is possible for an XMLReader to recognize a property name but to be unable to change the current value. Some property values may be immutable or mutable only in specific contexts, such as before, during, or after a parse.</source>
          <target state="translated">속성 이름은 정규화 된 URI입니다. XMLReader가 속성 이름을 인식 할 수 있지만 현재 값을 변경할 수는 없습니다. 일부 속성 값은 구문 분석 전, 도중 또는 후와 같은 특정 컨텍스트에서만 변경 불가능하거나 변경 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a44166bbcf01d577f1354b0551d5aad5a3ef464" translate="yes" xml:space="preserve">
          <source>The property resource defining the &lt;code&gt;{ID}&lt;/code&gt; variant</source>
          <target state="translated">&lt;code&gt;{ID}&lt;/code&gt; 변형을 정의하는 특성 자원</target>
        </trans-unit>
        <trans-unit id="af5b082804d7c2dde6ea05c46a90e42cc6381e7f" translate="yes" xml:space="preserve">
          <source>The property resource is located with the &lt;code&gt;calendars.properties&lt;/code&gt; file</source>
          <target state="translated">등록 정보 자원은 &lt;code&gt;calendars.properties&lt;/code&gt; 파일 과 함께 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f758999ea110228277da4c8ec83f3970f50ce67" translate="yes" xml:space="preserve">
          <source>The property that requires the parser to coalesce adjacent character data sections</source>
          <target state="translated">파서가 인접한 문자 데이터 섹션을 병합해야하는 속성</target>
        </trans-unit>
        <trans-unit id="e265780daa42ecc2e0802b3158af0dcc9a3d2876" translate="yes" xml:space="preserve">
          <source>The property that requires the parser to resolve external parsed entities</source>
          <target state="translated">파서가 외부 파싱 된 엔터티를 확인해야하는 속성</target>
        </trans-unit>
        <trans-unit id="13afb556feceeb83a36d49a0460475a7e85ddb79" translate="yes" xml:space="preserve">
          <source>The property that requires the parser to support DTDs</source>
          <target state="translated">DTD를 지원하기 위해 파서가 필요한 속성</target>
        </trans-unit>
        <trans-unit id="f462c466c77ecb8aecc01f7fc097bd0ef7bee433" translate="yes" xml:space="preserve">
          <source>The property used to set/get the implementation of the XMLReporter interface</source>
          <target state="translated">XMLReporter 인터페이스의 구현을 설정 / 가져 오는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="4325235510b04660062df652bfe8ef53233412c5" translate="yes" xml:space="preserve">
          <source>The property used to set/get the implementation of the XMLResolver</source>
          <target state="translated">XMLResolver의 구현을 설정 / 가져 오는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="50c756a437d7d9476e61751578d130ff92ae44bf" translate="yes" xml:space="preserve">
          <source>The property used to set/get the implementation of the allocator</source>
          <target state="translated">할당 자의 구현을 설정 / 가져 오는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="99399b40e8299eb71e8be6c59cb3bbd8473d04ed" translate="yes" xml:space="preserve">
          <source>The property used to turn on/off implementation specific validation</source>
          <target state="translated">구현 별 유효성 검사를 설정 / 해제하는 데 사용되는 속성</target>
        </trans-unit>
        <trans-unit id="df5033615f0d4c5aa6046366f6f557d55da8ce89" translate="yes" xml:space="preserve">
          <source>The property used to turn on/off namespace support, this is to support XML 1.0 documents, only the true setting must be supported</source>
          <target state="translated">네임 스페이스 지원을 켜고 끄는 데 사용되는 속성입니다. 이것은 XML 1.0 문서를 지원하기위한 것입니다. true 설정 만 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb305a13af061bdafc684dce06c7fea083824a3c" translate="yes" xml:space="preserve">
          <source>The property value as a human editable string.</source>
          <target state="translated">사람이 편집 할 수있는 문자열 인 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="928506a8e906ccfdc133220356a75d90280830ec" translate="yes" xml:space="preserve">
          <source>The property value as a string suitable for presentation to a human to edit.</source>
          <target state="translated">사람이 편집 할 수 있도록 적합한 문자열 인 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="73101b28e30a36efb57859ac5d834112bb90605f" translate="yes" xml:space="preserve">
          <source>The property value consists of the provider class name and the device name, separated by the hash mark (&quot;#&quot;). The provider class name is the fully-qualified name of a concrete &lt;a href=&quot;spi/midideviceprovider&quot;&gt;&lt;code&gt;MIDI device provider&lt;/code&gt;&lt;/a&gt; class. The device name is matched against the &lt;code&gt;String&lt;/code&gt; returned by the &lt;code&gt;getName&lt;/code&gt; method of &lt;code&gt;MidiDevice.Info&lt;/code&gt;. Either the class name, or the device name may be omitted. If only the class name is specified, the trailing hash mark is optional.</source>
          <target state="translated">속성 값은 공급자 클래스 이름과 장치 이름으로 구성되며 해시 표시 ( &quot;#&quot;)로 구분됩니다. 프로 바이더 클래스 이름은 구체적인 &lt;a href=&quot;spi/midideviceprovider&quot;&gt; &lt;code&gt;MIDI device provider&lt;/code&gt; &lt;/a&gt; 클래스 의 정규화 된 이름입니다 . 장치 이름은 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 의 &lt;code&gt;getName&lt;/code&gt; 메소드가 리턴 한 &lt;code&gt;String&lt;/code&gt; 과 일치 합니다 . 클래스 이름 또는 장치 이름이 생략 될 수 있습니다. 클래스 이름 만 지정하면 후미 해시 마크는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="0fda51bd535de894365d52df1f5e4d52b33dd40e" translate="yes" xml:space="preserve">
          <source>The property value consists of the provider class name and the mixer name, separated by the hash mark (&quot;#&quot;). The provider class name is the fully-qualified name of a concrete &lt;a href=&quot;spi/mixerprovider&quot;&gt;&lt;code&gt;mixer provider&lt;/code&gt;&lt;/a&gt; class. The mixer name is matched against the &lt;code&gt;String&lt;/code&gt; returned by the &lt;code&gt;getName&lt;/code&gt; method of &lt;code&gt;Mixer.Info&lt;/code&gt;. Either the class name, or the mixer name may be omitted. If only the class name is specified, the trailing hash mark is optional.</source>
          <target state="translated">속성 값은 공급자 클래스 이름과 믹서 이름으로 구성되며 해시 표시 ( &quot;#&quot;)로 구분됩니다. 제공자 클래스 이름은 콘크리트 &lt;a href=&quot;spi/mixerprovider&quot;&gt; &lt;code&gt;mixer provider&lt;/code&gt; &lt;/a&gt; 클래스 의 완전한 이름입니다 . 믹서 이름은 &lt;code&gt;Mixer.Info&lt;/code&gt; 의 &lt;code&gt;getName&lt;/code&gt; 메소드가 리턴 한 &lt;code&gt;String&lt;/code&gt; 과 일치합니다 . 클래스 이름 또는 믹서 이름을 생략 할 수 있습니다. 클래스 이름 만 지정하면 후미 해시 마크는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="839344a2affd2c29010b14b6d381310744ba6f63" translate="yes" xml:space="preserve">
          <source>The property value should be one of the forms accepted by &lt;code&gt;Font.decode(String)&lt;/code&gt; If the specified property is not found, or the executing code does not have permission to read the property, the &lt;code&gt;font&lt;/code&gt; argument is returned instead.</source>
          <target state="translated">속성 값은 &lt;code&gt;Font.decode(String)&lt;/code&gt; 허용하는 형식 중 하나 여야합니다 . 지정된 속성을 찾을 수 없거나 실행중인 코드에 속성을 읽을 수있는 권한이없는 경우 &lt;code&gt;font&lt;/code&gt; 인수가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="253fede9392a1c0b18e0b9824d151fca7a0e3b9d" translate="yes" xml:space="preserve">
          <source>The property value.</source>
          <target state="translated">속성 값</target>
        </trans-unit>
        <trans-unit id="a934d82554d845420400459f6c0dabc8ba77a442" translate="yes" xml:space="preserve">
          <source>The protected &lt;code&gt;EditorDelegate&lt;/code&gt; class.</source>
          <target state="translated">보호 된 &lt;code&gt;EditorDelegate&lt;/code&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="374ba4813aef129e3eb1f2074ac73df714237dfe" translate="yes" xml:space="preserve">
          <source>The protocol handler calls this method after a resource has been retrieved, and the ResponseCache must decide whether or not to store the resource in its cache.</source>
          <target state="translated">프로토콜 처리기는 리소스가 검색된 후이 메서드를 호출하고 ResponseCache는 리소스를 캐시에 저장할지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bca8021794336ac922184238ff13cedd04b4c6c" translate="yes" xml:space="preserve">
          <source>The protocol handler calls this method after a resource has been retrieved, and the ResponseCache must decide whether or not to store the resource in its cache. If the resource is to be cached, then put() must return a CacheRequest object which contains an OutputStream that the protocol handler will use to write the resource into the cache. If the resource is not to be cached, then put must return null.</source>
          <target state="translated">프로토콜 핸들러는 리소스가 검색된 후이 메소드를 호출하며 ResponseCache는 리소스를 캐시에 저장할지 여부를 결정해야합니다. 자원을 캐시하려면 put ()은 프로토콜 핸들러가 자원을 캐시에 쓰는 데 사용할 OutputStream을 포함하는 CacheRequest 객체를 반환해야합니다. 자원이 캐시되지 않으면 put은 널을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="4be2401bbc033d02d77ae8d018dde89f5a6c5180" translate="yes" xml:space="preserve">
          <source>The protocol part of the Service URL.</source>
          <target state="translated">서비스 URL의 프로토콜 부분.</target>
        </trans-unit>
        <trans-unit id="a28e98c099c58a5bda5e715045862d609dda783c" translate="yes" xml:space="preserve">
          <source>The protocol-specific requirements are defined in the &lt;a href=&quot;https://tools.ietf.org/html/rfc7540&quot;&gt;Hypertext Transfer Protocol Version 2 (HTTP/2)&lt;/a&gt;, the &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt; Hypertext Transfer Protocol (HTTP/1.1)&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;The WebSocket Protocol&lt;/a&gt;.</source>
          <target state="translated">프로토콜 별 요구 사항은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7540&quot;&gt;HTTP / 2 (Hypertext Transfer Protocol Version 2)&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;HTTP / 1.1 (Hypertext Transfer Protocol)&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;WebSocket 프로토콜에 정의되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c5465d2ff8a6fe16f37629d0bc86289e7d279a" translate="yes" xml:space="preserve">
          <source>The protocols must have been listed by &lt;code&gt;getSupportedProtocols()&lt;/code&gt; as being supported. Following a successful call to this method, only protocols listed in the &lt;code&gt;protocols&lt;/code&gt; parameter are enabled for use.</source>
          <target state="translated">프로토콜은 &lt;code&gt;getSupportedProtocols()&lt;/code&gt; 에 의해 지원되는 것으로 나열되어 있어야합니다 . 이 메소드를 성공적으로 호출하면 &lt;code&gt;protocols&lt;/code&gt; 매개 변수에 나열된 프로토콜 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ceb4dc01f774ca073a268387a29e005c274c187" translate="yes" xml:space="preserve">
          <source>The protocols must have been listed by getSupportedProtocols() as being supported. Following a successful call to this method, only protocols listed in the &lt;code&gt;protocols&lt;/code&gt; parameter are enabled for use.</source>
          <target state="translated">프로토콜은 getSupportedProtocols ()에 의해 지원되는 것으로 나열되어 있어야합니다. 이 메소드를 성공적으로 호출하면 &lt;code&gt;protocols&lt;/code&gt; 매개 변수에 나열된 프로토콜 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9210c3071d14625b46a43f122fc15299c196c44c" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;LocalDate&lt;/code&gt; is interpreted as the local date in the local time zone.</source>
          <target state="translated">제공된 &lt;code&gt;LocalDate&lt;/code&gt; 는 현지 시간대의 현지 날짜로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="276032490e07e1dda2172dc0392e83bfa40a5cb8" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;LocalDateTime&lt;/code&gt; is interpreted as the local date-time in the local time zone.</source>
          <target state="translated">제공된 &lt;code&gt;LocalDateTime&lt;/code&gt; 은 현지 시간대의 현지 날짜-시간으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="39ea298e1ed9cecc5248c7addf960c07d300fb1e" translate="yes" xml:space="preserve">
          <source>The provider class must be visible to the class loader.</source>
          <target state="translated">공급자 클래스는 클래스 로더에 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="01842d144548af6e56891138f0f22f5b69c75250" translate="yes" xml:space="preserve">
          <source>The provider configuration file lists the full-qualified class name of the AttachProvider implementation.</source>
          <target state="translated">공급자 구성 파일에는 AttachProvider 구현의 정규화 된 클래스 이름이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="b819aa1e87112cebc844a816e2d9cca7e54bfec7" translate="yes" xml:space="preserve">
          <source>The provider package list is a string that is interpreted as a list of non-empty Java package names separated by vertical bars (&lt;code&gt;|&lt;/code&gt;). If the string is empty, then so is the provider package list. If the provider package list is not a String, or if it contains an element that is an empty string, a &lt;a href=&quot;jmxproviderexception&quot;&gt;&lt;code&gt;JMXProviderException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">제공자 패키지 목록은 비어 있지 않은 Java 패키지 이름의 목록으로 해석되는 문자열이며 세로 막대 ( &lt;code&gt;|&lt;/code&gt; )로 구분됩니다 . 문자열이 비어 있으면 공급자 패키지 목록도 비어 있습니다. 프로 바이더 패키지리스트가 String가 아닌 경우, 또는 비어있는 캐릭터 라인의 요소가 포함되어있는 경우, &lt;a href=&quot;jmxproviderexception&quot;&gt; &lt;code&gt;JMXProviderException&lt;/code&gt; &lt;/a&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="81ff5f0c2ed16bdcde6df10f629ec05f4f76b747" translate="yes" xml:space="preserve">
          <source>The provider properties each specify the name and location of a particular service implemented by the provider. By granting this permission, you let code replace the service specification with another one, thereby specifying a different implementation.</source>
          <target state="translated">공급자 속성은 각각 공급자가 구현 한 특정 서비스의 이름과 위치를 지정합니다. 이 권한을 부여하면 코드가 서비스 스펙을 다른 것으로 바꾸도록하여 다른 구현을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfdec86c531152b897fae56fc5431156beb1192" translate="yes" xml:space="preserve">
          <source>The provider relies on a &lt;code&gt;CallbackHandler&lt;/code&gt; to obtain authentication information from the caller (a PIN, for example). If the caller passes a &lt;code&gt;null&lt;/code&gt; handler to this method, the provider uses the handler set in the &lt;code&gt;setCallbackHandler&lt;/code&gt; method. If no handler was set in that method, the provider queries the</source>
          <target state="translated">공급자는 &lt;code&gt;CallbackHandler&lt;/code&gt; 를 사용하여 발신자 (예 : PIN)로부터 인증 정보를 얻습니다. 호출자 가이 메소드에 &lt;code&gt;null&lt;/code&gt; 핸들러를 전달 하면 제공자는 &lt;code&gt;setCallbackHandler&lt;/code&gt; 메소드에 설정된 핸들러를 사용합니다 . 해당 메소드에 핸들러가 설정되지 않은 경우 제공자는</target>
        </trans-unit>
        <trans-unit id="1c17253044a3e06989e7d90ee41703431073eb01" translate="yes" xml:space="preserve">
          <source>The provider resource file (&lt;code&gt;jndiprovider.properties&lt;/code&gt;) for the context being operated on.</source>
          <target state="translated">작동중인 컨텍스트에 대한 제공자 자원 파일 ( &lt;code&gt;jndiprovider.properties&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e7c1d350031806c332b9c24a137dd3c90b8b811" translate="yes" xml:space="preserve">
          <source>The provider that created this channel</source>
          <target state="translated">이 채널을 만든 제공 업체</target>
        </trans-unit>
        <trans-unit id="77a39cfcc4e9fe4e8ca3afc28026bfc41ca77e69" translate="yes" xml:space="preserve">
          <source>The provider that created this channel group</source>
          <target state="translated">이 채널 그룹을 만든 공급자</target>
        </trans-unit>
        <trans-unit id="bd0273ec6d54c15dbfb4d880d2bc546ddaf6772d" translate="yes" xml:space="preserve">
          <source>The provider that created this file system.</source>
          <target state="translated">이 파일 시스템을 만든 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="caffc9ea416d37a1e2711f50ba819549314a7e56" translate="yes" xml:space="preserve">
          <source>The provider that created this virtual machine.</source>
          <target state="translated">이 가상 머신을 생성 한 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="1d3d88e815a75e16ffb4c1ab7a620700614562f3" translate="yes" xml:space="preserve">
          <source>The provider type</source>
          <target state="translated">공급자 유형</target>
        </trans-unit>
        <trans-unit id="e97bc8d34251d21b62200936e722253994322277" translate="yes" xml:space="preserve">
          <source>The provider typically uses a KeyStore as a basis for making trust decisions.</source>
          <target state="translated">제공자는 일반적으로 신뢰 결정을 내리기위한 기준으로 KeyStore를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8eb1ab0ca4032f625e2e248a88d341a2ea149e6e" translate="yes" xml:space="preserve">
          <source>The provider typically uses a KeyStore for obtaining key material for use during secure socket negotiations. The KeyStore is generally password-protected.</source>
          <target state="translated">공급자는 일반적으로 보안 소켓 협상 중에 사용할 키 자료를 얻기 위해 KeyStore를 사용합니다. KeyStore는 일반적으로 비밀번호로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="9346f15ca94e3e6d74fbf4bbfdeeea05816f74fe" translate="yes" xml:space="preserve">
          <source>The provider used by JShell to generate the execution engine needed to evaluate Snippets.</source>
          <target state="translated">Snippet을 평가하는 데 필요한 실행 엔진을 생성하기 위해 JShell에서 사용하는 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="22fa7c2a853bf7c659d1bad19161a472dd7cca7e" translate="yes" xml:space="preserve">
          <source>The provider used by JShell to generate the execution engine needed to evaluate Snippets. Alternate execution engines can be created by implementing this interface, then configuring JShell with the provider or the providers name and parameter specifier.</source>
          <target state="translated">Snippet을 평가하는 데 필요한 실행 엔진을 생성하기 위해 JShell에서 사용하는 공급자입니다. 이 인터페이스를 구현 한 다음 공급자 또는 공급자 이름 및 매개 변수 지정자로 JShell을 구성하여 대체 실행 엔진을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6ee7c51b3de3d00b80da9b5d57be36f861ae7af" translate="yes" xml:space="preserve">
          <source>The provider uses this handler if one is not passed to the &lt;code&gt;login&lt;/code&gt; method. The provider also uses this handler if it invokes &lt;code&gt;login&lt;/code&gt; on behalf of callers. In either case if a handler is not set via this method, the provider queries the</source>
          <target state="translated">프로 바이더가 &lt;code&gt;login&lt;/code&gt; 메소드에 전달되지 않으면이 핸들러를 사용합니다 . 공급자는 발신자를 대신하여 &lt;code&gt;login&lt;/code&gt; 을 호출하는 경우에도이 핸들러를 사용합니다 . 두 경우 모두 핸들러가이 메소드를 통해 설정되지 않은 경우 제공자는</target>
        </trans-unit>
        <trans-unit id="9a14653f68a78cf5317ff6c4d28abc9bf7e7ffec" translate="yes" xml:space="preserve">
          <source>The proxy forwards all requests to the encapsulated transferable and automatically performs additional conversion on the data returned by the encapsulated transferable in case of local transfer.</source>
          <target state="translated">프록시는 모든 요청을 캡슐화 된 전송 가능 항목으로 전달하고 로컬 전송의 경우 캡슐화 된 전송 가능 항목에서 반환 된 데이터에 대해 추가 변환을 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b50d88e8c90fab7f40e58f79439f226bc1b3f211" translate="yes" xml:space="preserve">
          <source>The proxy implements all the remote interfaces implemented by the remote object's class.</source>
          <target state="translated">프록시는 원격 객체의 클래스에 의해 구현 된 모든 원격 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5fb92df931a046e4e96ec8a961568a0710597d9c" translate="yes" xml:space="preserve">
          <source>The proxy's class is defined according to the specifications for the &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy#membership&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; class, using the class loader of the remote object's class.</source>
          <target state="translated">프록시의 클래스는 원격 개체 클래스의 클래스 로더를 사용하여 &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy#membership&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 클래스 의 사양에 따라 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="09deea942a6e744cdc803da8c6c2dfa4a09a0e5d" translate="yes" xml:space="preserve">
          <source>The proxy's invocation handler is a &lt;a href=&quot;remoteobjectinvocationhandler&quot;&gt;&lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;&lt;/a&gt; instance constructed with a &lt;a href=&quot;remoteref&quot;&gt;&lt;code&gt;RemoteRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프록시의 호출 핸들러는 &lt;a href=&quot;remoteref&quot;&gt; &lt;code&gt;RemoteRef&lt;/code&gt; 로&lt;/a&gt; 구성된 &lt;a href=&quot;remoteobjectinvocationhandler&quot;&gt; &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt; &lt;/a&gt; 인스턴스 입니다.</target>
        </trans-unit>
        <trans-unit id="b083456a4a9c6284da1cf31e08008817ef68ed33" translate="yes" xml:space="preserve">
          <source>The pseudo code for the rescaling operation is as follows:</source>
          <target state="translated">크기 조정 작업을위한 의사 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cbb75c3c1cc6c2af9021f9f5e045df931d8ccd5" translate="yes" xml:space="preserve">
          <source>The pseudo-type corresponding to the keyword &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;void&lt;/code&gt; 에 해당하는 의사 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="94f0a25ea40a5d8f1223e160a1f04a7a4b183b85" translate="yes" xml:space="preserve">
          <source>The pseudo/hidden column may only be used in a SELECT list.</source>
          <target state="translated">의사 / 숨겨진 열은 SELECT 목록에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca6478c62d3dc1f97483e29223ff3d12797f8b7c" translate="yes" xml:space="preserve">
          <source>The pseudo/hidden column may only be used in a WHERE clause.</source>
          <target state="translated">의사 / 숨겨진 열은 WHERE 절에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4812bd2f1ef82113d348414069707122f4719cd1" translate="yes" xml:space="preserve">
          <source>The pseudocode for the resulting adapter looks as follows. In the code, &lt;code&gt;V&lt;/code&gt; represents the result type of the &lt;code&gt;try/finally&lt;/code&gt; construct; &lt;code&gt;A&lt;/code&gt;/&lt;code&gt;a&lt;/code&gt;, the types and values of arguments to the resulting handle consumed by the cleanup; and &lt;code&gt;B&lt;/code&gt;/&lt;code&gt;b&lt;/code&gt;, those of arguments to the resulting handle discarded by the cleanup.</source>
          <target state="translated">결과 어댑터의 의사 코드는 다음과 같습니다. 코드에서 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;try/finally&lt;/code&gt; 구문 의 결과 유형을 나타냅니다 . &lt;code&gt;A&lt;/code&gt; / &lt;code&gt;a&lt;/code&gt; , 정리에 사용되는 결과 핸들에 대한 인수의 유형 및 값. 및 &lt;code&gt;B&lt;/code&gt; / &lt;code&gt;b&lt;/code&gt; , 정리에 의해 폐기 된 결과 핸들에 대한 인수입니다.</target>
        </trans-unit>
        <trans-unit id="f1c0bbc66bdb6ee141f8f29a8594a0f7f7c26d71" translate="yes" xml:space="preserve">
          <source>The public exponent-value F4 = 65537.</source>
          <target state="translated">공개 지수 값 F4 = 65537.</target>
        </trans-unit>
        <trans-unit id="889b7ac5748f9ffaedc89e0966ff01f02908492a" translate="yes" xml:space="preserve">
          <source>The public identifier and system identifier are &lt;code&gt;null&lt;/code&gt;, and byte and character stream are either &lt;code&gt;null&lt;/code&gt; or contain no byte or character.</source>
          <target state="translated">공용 식별자 및 시스템 식별자는 &lt;code&gt;null&lt;/code&gt; 이고 바이트 및 문자 스트림은 &lt;code&gt;null&lt;/code&gt; 이거나 바이트 또는 문자를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="607a67c14bf23bd75e74af63fd58a783d5e8e1e8" translate="yes" xml:space="preserve">
          <source>The public identifier as a string, or null if none is available.</source>
          <target state="translated">공용 식별자 (문자열) 또는 사용할 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="666d68a6bc57f9864e5a56565fbc5a900e031826" translate="yes" xml:space="preserve">
          <source>The public identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">엔티티와 연관된 공용 식별자 (지정된 경우), 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3641e2bf5da57b5d4d6f8981fd5ba25936de99d5" translate="yes" xml:space="preserve">
          <source>The public identifier for the XML Schema definition that defines the XML tags and their valid values for a &lt;code&gt;WebRowSet&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;WebRowSet&lt;/code&gt; 구현에 대한 XML 태그 및 유효한 값을 정의하는 XML 스키마 정의의 공용 식별자입니다 .</target>
        </trans-unit>
        <trans-unit id="6082fcf3b4787c7e3fa7e05f8cd01a60bcc96655" translate="yes" xml:space="preserve">
          <source>The public identifier for this input source.</source>
          <target state="translated">이 입력 소스의 공개 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="306fe0d5ecd3a197943ce9157ab37545b45833fc" translate="yes" xml:space="preserve">
          <source>The public identifier for this input source. This may be mapped to an input source using an implementation dependent mechanism (such as catalogues or other mappings). The public identifier, if specified, may also be reported as part of the location information when errors are reported.</source>
          <target state="translated">이 입력 소스의 공개 식별자입니다. 이는 구현 종속 메커니즘 (예 : 카탈로그 또는 기타 매핑)을 사용하여 입력 소스에 매핑 될 수 있습니다. 지정된 경우 공개 식별자는 오류가보고 될 때 위치 정보의 일부로보고 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8616cf097304d23ed9bdee5a10da665d66f611aa" translate="yes" xml:space="preserve">
          <source>The public identifier is always optional: if the application writer includes one, it will be provided as part of the location information.</source>
          <target state="translated">공개 식별자는 항상 선택 사항입니다. 응용 프로그램 작성자에 포함 된 경우 위치 정보의 일부로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="084fd15bde5749cac40870c17b4a07ccada3bfac" translate="yes" xml:space="preserve">
          <source>The public identifier of the external subset.</source>
          <target state="translated">외부 하위 집합의 공개 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="e59aa7e65372678aa563cfbbb9d944fcecc85ead" translate="yes" xml:space="preserve">
          <source>The public identifier of this notation.</source>
          <target state="translated">이 표기법의 공용 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="af89db99417a364a5ed02edd579e71607f09ad52" translate="yes" xml:space="preserve">
          <source>The public identifier of this notation. If the public identifier was not specified, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 표기법의 공용 식별자입니다. 공용 식별자가 지정되지 않은 경우 이것은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="452a322725b189c1bd9848c6035428fa8271f855" translate="yes" xml:space="preserve">
          <source>The public identifier that was set with setPublicId, or null if setPublicId was not called.</source>
          <target state="translated">setPublicId로 설정된 공용 식별자 또는 setPublicId가 호출되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="1d7f2c29e78db86abe70e3052b6a63ed7f102e04" translate="yes" xml:space="preserve">
          <source>The public identifier, or null if none was supplied.</source>
          <target state="translated">공용 식별자 또는 제공되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="f26be22251f1ffca01d91cc5cb358dc14cdbbb9d" translate="yes" xml:space="preserve">
          <source>The public key or the signature algorithm has been constrained.</source>
          <target state="translated">공개 키 또는 서명 알고리즘이 제한되었습니다.</target>
        </trans-unit>
        <trans-unit id="c28eb2aa6086a8572e42d5f820ee00606327026e" translate="yes" xml:space="preserve">
          <source>The public methods of all &lt;code&gt;CertStoreSpi&lt;/code&gt; objects must be thread-safe. That is, multiple threads may concurrently invoke these methods on a single &lt;code&gt;CertStoreSpi&lt;/code&gt; object (or more than one) with no ill effects. This allows a &lt;code&gt;CertPathBuilder&lt;/code&gt; to search for a CRL while simultaneously searching for further certificates, for instance.</source>
          <target state="translated">모든 &lt;code&gt;CertStoreSpi&lt;/code&gt; 객체 의 공개 메소드는 스레드로부터 안전해야합니다. 즉, 여러 스레드가 동시에 단일 &lt;code&gt;CertStoreSpi&lt;/code&gt; 객체 (또는 둘 이상)에서 이러한 효과를 발생시키지 않으면 서 이러한 메서드를 호출 할 수 있습니다 . 이를 통해 &lt;code&gt;CertPathBuilder&lt;/code&gt; 는 예를 들어 추가 인증서를 동시에 검색하면서 CRL을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a02308f567fb58540f6ccefee2675e6a72ad544b" translate="yes" xml:space="preserve">
          <source>The public-exponent value F0 = 3.</source>
          <target state="translated">공개 지수 값 F0 = 3</target>
        </trans-unit>
        <trans-unit id="ffd416e4ee6aca89b81f63e35d9c17c738fb2e7a" translate="yes" xml:space="preserve">
          <source>The publisher returned by the &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;body&lt;/code&gt;&lt;/a&gt; method can be subscribed to only once. The first subscriber will receive the body response bytes if successfully subscribed, or will cause the subscription to be cancelled otherwise. If more subscriptions are attempted, the subsequent subscribers will be immediately subscribed with an empty subscription and their &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber#onError(java.lang.Throwable)&quot;&gt;&lt;code&gt;onError&lt;/code&gt;&lt;/a&gt; method will be invoked with an &lt;code&gt;IllegalStateException&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;body&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 게시자는 한 번만 구독 할 수 있습니다. 첫 번째 구독자는 성공적으로 구독하면 본문 응답 바이트를 수신하고 그렇지 않으면 구독이 취소됩니다. 더 많은 구독이 시도되면 후속 구독자는 빈 구독으로 즉시 구독되며 &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber#onError(java.lang.Throwable)&quot;&gt; &lt;code&gt;onError&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;code&gt;IllegalStateException&lt;/code&gt; 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3c496c34577282d9b29830bb8f695bcbc9c40b3" translate="yes" xml:space="preserve">
          <source>The purported representation in &lt;code&gt;bytes&lt;/code&gt; must be a &lt;code&gt;ClassFile&lt;/code&gt; structure of a supported major and minor version. The major and minor version may differ from the &lt;code&gt;class&lt;/code&gt; file version of the lookup class of this &lt;code&gt;Lookup&lt;/code&gt;.</source>
          <target state="translated">의도 된 &lt;code&gt;bytes&lt;/code&gt; 표현은 지원되는 주 버전과 부 버전 의 &lt;code&gt;ClassFile&lt;/code&gt; 구조 여야합니다 . 주 버전과 부 버전은 이 &lt;code&gt;Lookup&lt;/code&gt; 조회 클래스의 &lt;code&gt;class&lt;/code&gt; 파일 버전 과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70b9b090e2e3af4d5dc6ecafb7583d4cc88b82f8" translate="yes" xml:space="preserve">
          <source>The purpose of the key that is to be selected.</source>
          <target state="translated">선택할 키의 목적입니다.</target>
        </trans-unit>
        <trans-unit id="a685b30cd56fd2fa8d25fa1008484df0ea6a7290" translate="yes" xml:space="preserve">
          <source>The purpose of the methods to transform to/from the well-defined CIEXYZ color space is to support conversions between any two color spaces at a reasonably high degree of accuracy. It is expected that particular implementations of subclasses of &lt;code&gt;ColorSpace&lt;/code&gt; (e.g. &lt;code&gt;ICC_ColorSpace&lt;/code&gt;) will support high performance conversion based on underlying platform color management systems.</source>
          <target state="translated">잘 정의 된 CIEXYZ 색상 공간으로 /에서 변환하는 방법의 목적은 상당히 높은 정확도로 두 색상 공간 간의 변환을 지원하는 것입니다. &lt;code&gt;ColorSpace&lt;/code&gt; 하위 클래스의 특정 구현 (예 : &lt;code&gt;ICC_ColorSpace&lt;/code&gt; )은 기본 플랫폼 색상 관리 시스템에 기반한 고성능 변환을 지원할 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a218ad17fd93df6b98634337c4e7514b88c3517" translate="yes" xml:space="preserve">
          <source>The purpose of the methods to transform to/from the well-defined CIEXYZ color space is to support conversions between any two color spaces at a reasonably high degree of accuracy. It is expected that particular implementations of subclasses of ColorSpace (e.g. ICC_ColorSpace) will support high performance conversion based on underlying platform color management systems.</source>
          <target state="translated">잘 정의 된 CIEXYZ 색상 공간으로 /에서 변환하는 방법의 목적은 상당히 높은 정확도로 두 색상 공간 간의 변환을 지원하는 것입니다. ColorSpace의 하위 클래스 (예 : ICC_ColorSpace)의 특정 구현은 기본 플랫폼 색상 관리 시스템을 기반으로하는 고성능 변환을 지원할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="58212aee8e35283834dfaea45dcaab9b066bc5e9" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all &lt;code&gt;CertStore&lt;/code&gt; parameter specifications. All &lt;code&gt;CertStore&lt;/code&gt; parameter specifications must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 &lt;code&gt;CertStore&lt;/code&gt; 파라미터 사양 을 그룹화 (및 형태 안전성을 제공)하는 것입니다. 모든 &lt;code&gt;CertStore&lt;/code&gt; 매개 변수 스펙은이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="497084f3740257fa01928dfab9f2a8bd92f16644" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all certification path validator results. All results returned by the &lt;a href=&quot;certpathvalidator#validate(java.security.cert.CertPath,java.security.cert.CertPathParameters)&quot;&gt;&lt;code&gt;CertPathValidator.validate&lt;/code&gt;&lt;/a&gt; method must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 인증 경로 유효성 검사기 결과를 그룹화하고 유형 안전성을 제공하는 것입니다. &lt;a href=&quot;certpathvalidator#validate(java.security.cert.CertPath,java.security.cert.CertPathParameters)&quot;&gt; &lt;code&gt;CertPathValidator.validate&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 모든 결과는 이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f81245615bb3902dc0ddd73189d74b0875c911f" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all certification path validator results. All results returned by the &lt;a href=&quot;certpathvalidator#validate-java.security.cert.CertPath-java.security.cert.CertPathParameters-&quot;&gt;&lt;code&gt;CertPathValidator.validate&lt;/code&gt;&lt;/a&gt; method must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 인증 경로 유효성 검사기 결과를 그룹화하고 형식 안전성을 제공하는 것입니다. &lt;a href=&quot;certpathvalidator#validate-java.security.cert.CertPath-java.security.cert.CertPathParameters-&quot;&gt; &lt;code&gt;CertPathValidator.validate&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 모든 결과는 이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="f40bfb04d6225f59e5f6ed15eef633d42be0d88d" translate="yes" xml:space="preserve">
          <source>The pushback buffer.</source>
          <target state="translated">푸시 백 버퍼.</target>
        </trans-unit>
        <trans-unit id="b5af8f1a618a38255f2c1f2534b78fc0e45ec2ab" translate="yes" xml:space="preserve">
          <source>The qualified name of the import.</source>
          <target state="translated">수입품의 규정 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c31d955d9efe36b1734a65da90b797845391d566" translate="yes" xml:space="preserve">
          <source>The qualified name of the import. For any imports (&lt;a href=&quot;snippet.subkind#TYPE_IMPORT_ON_DEMAND_SUBKIND&quot;&gt;&lt;code&gt;Snippet.SubKind.TYPE_IMPORT_ON_DEMAND_SUBKIND&lt;/code&gt;&lt;/a&gt;, (&lt;a href=&quot;snippet.subkind#STATIC_IMPORT_ON_DEMAND_SUBKIND&quot;&gt;&lt;code&gt;Snippet.SubKind.STATIC_IMPORT_ON_DEMAND_SUBKIND&lt;/code&gt;&lt;/a&gt;), (&lt;a href=&quot;snippet.subkind#SINGLE_TYPE_IMPORT_SUBKIND&quot;&gt;&lt;code&gt;Snippet.SubKind.SINGLE_TYPE_IMPORT_SUBKIND&lt;/code&gt;&lt;/a&gt; or (&lt;a href=&quot;snippet.subkind#SINGLE_STATIC_IMPORT_SUBKIND&quot;&gt;&lt;code&gt;Snippet.SubKind.SINGLE_STATIC_IMPORT_SUBKIND&lt;/code&gt;&lt;/a&gt;) that is the full specifier including any qualifiers and the asterisks.</source>
          <target state="translated">수입품의 규정 된 이름입니다. 모든 가져 오기의 경우 ( &lt;a href=&quot;snippet.subkind#TYPE_IMPORT_ON_DEMAND_SUBKIND&quot;&gt; &lt;code&gt;Snippet.SubKind.TYPE_IMPORT_ON_DEMAND_SUBKIND&lt;/code&gt; &lt;/a&gt; , ( &lt;a href=&quot;snippet.subkind#STATIC_IMPORT_ON_DEMAND_SUBKIND&quot;&gt; &lt;code&gt;Snippet.SubKind.STATIC_IMPORT_ON_DEMAND_SUBKIND&lt;/code&gt; &lt;/a&gt; ), ( &lt;a href=&quot;snippet.subkind#SINGLE_TYPE_IMPORT_SUBKIND&quot;&gt; &lt;code&gt;Snippet.SubKind.SINGLE_TYPE_IMPORT_SUBKIND&lt;/code&gt; &lt;/a&gt; 또는 ( &lt;a href=&quot;snippet.subkind#SINGLE_STATIC_IMPORT_SUBKIND&quot;&gt; &lt;code&gt;Snippet.SubKind.SINGLE_STATIC_IMPORT_SUBKIND&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4aab08f812dbdbd1e2f17d2f57df09ad2f9651a" translate="yes" xml:space="preserve">
          <source>The quality of implementation specifications concern two properties, accuracy of the returned result and monotonicity of the method. Accuracy of the floating-point &lt;code&gt;Math&lt;/code&gt; methods is measured in terms of</source>
          <target state="translated">구현 사양의 품질은 반환 된 결과의 정확성과 메서드의 단일성이라는 두 가지 속성과 관련됩니다. 부동 소수점 &lt;code&gt;Math&lt;/code&gt; 방법 의 정확도 는</target>
        </trans-unit>
        <trans-unit id="f5cb0e2e965fe133bfc4b502b0d3bcf943a71b82" translate="yes" xml:space="preserve">
          <source>The quarter-of-year can only be calculated if the month-of-year is available.</source>
          <target state="translated">해당 연도는 해당 월을 사용할 수있는 경우에만 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddac52873ee50d0b150f5774b33d3171bd12498" translate="yes" xml:space="preserve">
          <source>The query can be used as follows:</source>
          <target state="translated">쿼리는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70bb5883a481eb39ca30783c6a7918ebefc04d35" translate="yes" xml:space="preserve">
          <source>The query component of a URI, if defined, only contains legal URI characters.</source>
          <target state="translated">URI의 쿼리 구성 요소는 정의 된 경우 유효한 URI 문자 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e864d8346a749cfdd6a77c410e2c3f6c279670bc" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;LocalDate&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6043cc3fa8c882b0feedaeddf7526a1d1132efc5" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;LocalTime&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;LocalTime&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b5e706d8394f50472ebf16e28898a8a1e6a58887" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;ZoneOffset&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a9d533d67b796aabaca7323db73ec2da2a5567db" translate="yes" xml:space="preserve">
          <source>The query submitted by the driver to validate the connection shall be executed in the context of the current transaction.</source>
          <target state="translated">연결을 확인하기 위해 드라이버가 제출 한 쿼리는 현재 트랜잭션의 컨텍스트에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b701fffe515ad54c8901b8edcc958e95fc0863c4" translate="yes" xml:space="preserve">
          <source>The quotes surrounding a quoted value, and any backslashes within that value, are considered to be part of the value.</source>
          <target state="translated">따옴표로 묶은 따옴표와 해당 값 내의 백 슬래시는 값의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a7d974dd7e85a61e651a1f194908d0947c9c72a3" translate="yes" xml:space="preserve">
          <source>The radix is either smaller than &lt;a href=&quot;character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or larger than &lt;a href=&quot;character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기수는 하나보다 작은 &lt;a href=&quot;character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt; 보다 작거나 큰 &lt;a href=&quot;character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aff07d7777d5b73265b5ea3b6fd0d12004a2b97" translate="yes" xml:space="preserve">
          <source>The range is never null. For example, the 'Year' field is shorthand for 'YearOfForever'. It therefore has a unit of 'Years' and a range of 'Forever'.</source>
          <target state="translated">범위는 null이 아닙니다. 예를 들어 'Year'필드는 'YearOfForever'의 줄임말입니다. 따라서 '년'단위와 '영원히'범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c3676b410b66174f1db5ce3adf03537f612813" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This date is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 날짜는 반환 범위의 정확성을 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 인해 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3be0f1078a3bff28a13de38bf87eb44d5f6cfd7c" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This date-time is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 날짜-시간은 반환 된 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91574718820af02ba334ca5d2fcaa8ec6eaea0fc" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This day-of-week is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 요일은 반환 된 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49564c5fdd906eee0231c2e097092a4591ff74b8" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This era is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 시대는 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d7949501ac98f64cd52d82177d9b4791e0d319f3" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This instant is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 순간은 반환 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a75a30588e66efcb4e03e0edc195ee3a6dc4a14" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This month is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 달은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e107332e6198f288dc13a1a398312820086bba7b" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This month-day is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 달은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="014329a030e2ab6f6b560564601eb56834e5e981" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This offset is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 오프셋은 반환 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8e7e158ec4085c5caa0000a57a4cf2e6742dd0c" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This time is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 시간은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="735932a1888a19dccb3e713207eb70618d6c1110" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This year is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 올해는 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="461a26e4d72a556581a55b26af7476b03a89d671" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This year-month is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 올해의 월은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85b6f271b8e9dbcfec00b32e847d50024b09f127" translate="yes" xml:space="preserve">
          <source>The range of a duration requires the storage of a number larger than a &lt;code&gt;long&lt;/code&gt;. To achieve this, the class stores a &lt;code&gt;long&lt;/code&gt; representing seconds and an &lt;code&gt;int&lt;/code&gt; representing nanosecond-of-second, which will always be between 0 and 999,999,999. The model is of a directed duration, meaning that the duration may be negative.</source>
          <target state="translated">기간의 범위에는 &lt;code&gt;long&lt;/code&gt; 보다 큰 수의 저장이 필요합니다 . 이를 달성하기 위해 클래스는 &lt;code&gt;long&lt;/code&gt; 을 나타내는 초와 나노초를 나타내는 &lt;code&gt;int&lt;/code&gt; 를 저장하며 , 항상 0에서 999,999,999 사이입니다. 모델의 지속 시간은 지속 시간이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32e38d37e14ca58b0618d587028515e73e2533f4" translate="yes" xml:space="preserve">
          <source>The range of an instant requires the storage of a number larger than a &lt;code&gt;long&lt;/code&gt;. To achieve this, the class stores a &lt;code&gt;long&lt;/code&gt; representing epoch-seconds and an &lt;code&gt;int&lt;/code&gt; representing nanosecond-of-second, which will always be between 0 and 999,999,999. The epoch-seconds are measured from the standard Java epoch of &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; where instants after the epoch have positive values, and earlier instants have negative values. For both the epoch-second and nanosecond parts, a larger value is always later on the time-line than a smaller value.</source>
          <target state="translated">인스턴트의 범위에는 &lt;code&gt;long&lt;/code&gt; 보다 큰 수의 저장이 필요합니다 . 이를 달성하기 위해 클래스는 &lt;code&gt;long&lt;/code&gt; 을 나타내는 초 (epoch-seconds)와 &lt;code&gt;int&lt;/code&gt; ( 초)를 나타내며, 항상 0에서 999,999,999 사이입니다. 신기원 초는 신기원 이후의 순간은 양수 값을 가지며 초기 순간은 음수 값 을 갖는 표준 Java 신기원 &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; 에서 측정 됩니다. 에포크 초 및 나노초 부분 모두에 대해, 더 큰 값은 항상 더 작은 값보다 타임 라인에서 늦습니다.</target>
        </trans-unit>
        <trans-unit id="9c4be6accb9dad9be6efe2a2837d3150210f72f4" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;#getBaseUnit()&quot;&gt;&lt;code&gt;getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 달라지는 기간입니다. 예를 들어 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;#getBaseUnit()&quot;&gt; &lt;code&gt;getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="679d54d91b72b6e361f360707cfcab80ec107617" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt;&lt;code&gt;TemporalField.getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 변하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt; &lt;code&gt;TemporalField.getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d54476f03a91c05aa619016f50c3163119ec639" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt;&lt;code&gt;getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 변하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt; &lt;code&gt;getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb9262661e91ed7bef2f4dcc6a38ba0c83ed604f" translate="yes" xml:space="preserve">
          <source>The range of valid Japanese eras can change over time due to the nature of the Japanese calendar system.</source>
          <target state="translated">유효한 일본 시대의 범위는 일본 달력 시스템의 특성으로 인해 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bed82254a2488e57b5e72ee8db8066e750b8a42" translate="yes" xml:space="preserve">
          <source>The range of valid values for a date-time field.</source>
          <target state="translated">날짜-시간 필드에 유효한 값의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="f74c7503d6071b30c8c61a8b75f2f1ec45dd13e0" translate="yes" xml:space="preserve">
          <source>The raw authority component of this URI, or &lt;code&gt;null&lt;/code&gt; if the authority is undefined</source>
          <target state="translated">이 URI의 원시 권한 컴퍼넌트. 또는 권한이 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0f93a7d9b2a593cc73021049a4babe847f8e5a" translate="yes" xml:space="preserve">
          <source>The raw fragment component of this URI, or &lt;code&gt;null&lt;/code&gt; if the fragment is undefined</source>
          <target state="translated">이 URI의 raw fragment 컴퍼넌트 . 프래그먼트가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884bd03f88502ccbbb9691da661566c970592757" translate="yes" xml:space="preserve">
          <source>The raw long value associated to this memory address.</source>
          <target state="translated">이 메모리 주소와 연관된 원시 long 값입니다.</target>
        </trans-unit>
        <trans-unit id="08a189753abac31378f32795de3236540870ae3b" translate="yes" xml:space="preserve">
          <source>The raw query component of this URI, or &lt;code&gt;null&lt;/code&gt; if the query is undefined</source>
          <target state="translated">이 URI의 원시 쿼리 컴퍼넌트 . 쿼리가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05172f64d4d3b180d734e94e231efb1e5ba69223" translate="yes" xml:space="preserve">
          <source>The raw scheme-specific part of this URI (never &lt;code&gt;null&lt;/code&gt;)</source>
          <target state="translated">이 URI의 미가공 스킴 특정 부분 ( &lt;code&gt;null&lt;/code&gt; 은 아님)</target>
        </trans-unit>
        <trans-unit id="5e87c817a622606571e558fb125257b7d14ba713" translate="yes" xml:space="preserve">
          <source>The raw user-information component of this URI, or &lt;code&gt;null&lt;/code&gt; if the user information is undefined</source>
          <target state="translated">이 URI의 원시의 사용자 정보 컴퍼넌트 . 사용자 정보가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f41303d8fd6ce5aa0821756418e069b981b7b161" translate="yes" xml:space="preserve">
          <source>The read end of a pipe</source>
          <target state="translated">파이프의 읽기 끝</target>
        </trans-unit>
        <trans-unit id="2f625a725ca986b919f09071c8736ca180edd0b0" translate="yes" xml:space="preserve">
          <source>The read lock and write lock both support interruption during lock acquisition.</source>
          <target state="translated">읽기 잠금 및 쓰기 잠금은 잠금 획득 중 중단을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1910ace8ec568ce21c0234fca6b9fc966c9cfd9a" translate="yes" xml:space="preserve">
          <source>The read lock does not support a &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;readLock().newCondition()&lt;/code&gt; throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">읽기 잠금 장치가 지원하지 않는 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;readLock().newCondition()&lt;/code&gt; 발생 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가가 .</target>
        </trans-unit>
        <trans-unit id="2ef8ece400c68c93f9421b6ba44a9c57dd5cbaa4" translate="yes" xml:space="preserve">
          <source>The read lock is acquired by the current thread; or</source>
          <target state="translated">읽기 잠금은 현재 스레드에 의해 획득됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="c9ea905530375593b0c66214e6790341afceb692" translate="yes" xml:space="preserve">
          <source>The read operation may read up to</source>
          <target state="translated">읽기 작업은 최대</target>
        </trans-unit>
        <trans-unit id="2865a10b019911b5946864d5522b0a72162698af" translate="yes" xml:space="preserve">
          <source>The read position of the input stream is positioned to the next available byte after the encoded distinguished name.</source>
          <target state="translated">입력 스트림의 읽기 위치는 인코딩 된 식별 이름 다음에 사용 가능한 다음 바이트에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="634db75a4e5ec4659af37c3e0e8afa693c0276b7" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading and restoring the state of the object for its particular class using data written to the stream by the corresponding writeObject method. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object. Reading primitive data types is supported by DataInput.</source>
          <target state="translated">readObject 메소드는 해당 writeObject 메소드로 스트림에 기록 된 데이터를 사용하여 특정 클래스의 오브젝트 상태를 읽고 복원합니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. 개별 필드에 대한 ObjectInputStream에서 데이터를 읽고 오브젝트의 해당 필드에 지정하여 상태를 복원합니다. 기본 데이터 유형 읽기는 DataInput에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8520a1a1ecaa0cf4e920c8fe17c0f626c164c35d" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading from the stream and restoring the classes fields. It may call in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields. The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object. Reading primitive data types is supported by DataInput.</source>
          <target state="translated">readObject 메서드는 스트림에서 읽고 클래스 필드를 복원합니다. in.defaultReadObject를 호출하여 객체의 비 정적 및 비 일시적 필드를 복원하기위한 기본 메커니즘을 호출 할 수 있습니다. defaultReadObject 메서드는 스트림의 정보를 사용하여 스트림에 저장된 개체의 필드를 현재 개체의 해당 이름이 지정된 필드와 함께 할당합니다. 이것은 새로운 필드를 추가하기 위해 클래스가 진화 한 경우를 처리합니다. 이 메서드는 수퍼 클래스 나 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. 상태는 개별 필드에 대한 ObjectInputStream에서 데이터를 읽고 객체의 적절한 필드에 할당하여 복원됩니다. 기본 데이터 유형 읽기는 DataInput에서 지원됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
