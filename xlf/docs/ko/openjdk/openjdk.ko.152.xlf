<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="6d45a10a6e24eaa7c3cdfde29bd66f6b11f5bc37" translate="yes" xml:space="preserve">
          <source>The rules are loaded via &lt;a href=&quot;zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt; using a &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;. The same rules may be shared internally between multiple zone IDs.</source>
          <target state="translated">규칙은 &lt;a href=&quot;zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 를 통해로드됩니다 . 여러 구역 ID간에 ​​동일한 규칙이 내부적으로 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7d29710bebc6dfb854d9319d167bdaa66f76644" translate="yes" xml:space="preserve">
          <source>The rules are stored as named styles, and other information is stored to translate the context of an element to a rule quickly. The following code fragment will display the named styles, and therefore the CSS rules contained.</source>
          <target state="translated">규칙은 명명 된 스타일로 저장되고 다른 정보는 요소의 컨텍스트를 규칙으로 빠르게 변환하기 위해 저장됩니다. 다음 코드 조각은 명명 된 스타일을 표시하므로 CSS 규칙이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4c558d54ff2e89b5ae0559dc27450ddadbb740a9" translate="yes" xml:space="preserve">
          <source>The rules are supplied by &lt;a href=&quot;zone/zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt;. An advanced provider may support dynamic updates to the rules without restarting the Java Runtime. If so, then the result of this method may change over time. Each individual call will be still remain thread-safe.</source>
          <target state="translated">규칙은 &lt;a href=&quot;zone/zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; 에서&lt;/a&gt; 제공합니다 . 고급 공급자는 Java 런타임을 다시 시작하지 않고도 규칙에 대한 동적 업데이트를 지원할 수 있습니다. 그렇다면이 방법의 결과는 시간이 지남에 따라 변경 될 수 있습니다. 각 개별 통화는 여전히 스레드 안전 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1bccb89406bfb2d00bc457815b4e62d2470b7af9" translate="yes" xml:space="preserve">
          <source>The rules defining how the zone offset varies for a single time-zone.</source>
          <target state="translated">단일 시간대에 대한 영역 오프셋의 변화를 정의하는 규칙.</target>
        </trans-unit>
        <trans-unit id="1b49d1af7b23bfa9889a2696229a5d15447e0c34" translate="yes" xml:space="preserve">
          <source>The rules for &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; collectively define the notion of a &lt;em&gt;getter&lt;/em&gt;. The rule for &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; defines the notion of a &lt;em&gt;setter&lt;/em&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 하고 &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 집합 적 개념 정의 &lt;em&gt;게터를&lt;/em&gt; . 의 규칙 &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; a의 개념 정의 &lt;em&gt;세터&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="23679fbbad04df1e812f689c70ce1d6ec4726cea" translate="yes" xml:space="preserve">
          <source>The rules for addition add the number of week-based-years to the existing value for the week-based-year field retaining the week-of-week-based-year and day-of-week, unless the week number it too large for the target year. In that case, the week is set to the last week of the year with the same day-of-week.</source>
          <target state="translated">더하기 규칙은 주 번호가 너무 크지 않은 한 주별 요일 및 요일을 유지하는 주별 필드의 기존 값에 요일 수를 추가합니다. 목표 연도. 이 경우주는 같은 요일을 사용하여 마지막 주로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe755e8390c62eea10e1546677bdab04050afb0" translate="yes" xml:space="preserve">
          <source>The rules for addition add the number of week-based-years to the existing value for the week-based-year field. If the resulting week-based-year only has 52 weeks, then the date will be in week 1 of the following week-based-year.</source>
          <target state="translated">추가 규칙은 주별 연도 수를 주별 연도 필드의 기존 값에 추가합니다. 결과 주별 연도에 52 주만있는 경우 날짜는 다음 주 기반 연도의 1 주일입니다.</target>
        </trans-unit>
        <trans-unit id="b8227871731be6c3964a85ded8d67582566b32f1" translate="yes" xml:space="preserve">
          <source>The rules for using quotes within message format patterns unfortunately have shown to be somewhat confusing. In particular, it isn't always obvious to localizers whether single quotes need to be doubled or not. Make sure to inform localizers about the rules, and tell them (for example, by using comments in resource bundle source files) which strings will be processed by &lt;code&gt;MessageFormat&lt;/code&gt;. Note that localizers may need to use single quotes in translated strings where the original version doesn't have them.</source>
          <target state="translated">불행히도 메시지 형식 패턴 내에서 따옴표를 사용하는 규칙은 다소 혼란스러운 것으로 나타났습니다. 특히 작은 따옴표를 두 배로 늘릴 필요가 있는지 여부는 로컬 라이저에게 분명하지 않습니다. 로컬 라이저에게 규칙에 대해 알리고 (예를 들어, 자원 번들 소스 파일에 주석을 사용하여) &lt;code&gt;MessageFormat&lt;/code&gt; 에서 처리 할 문자열을 알려 주십시오. 로컬 라이저는 번역본에 작은 따옴표를 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38de80f84a46f228ca25c1f0d5e10459bf313f19" translate="yes" xml:space="preserve">
          <source>The rules model all the historic and future transitions for a time-zone. &lt;a href=&quot;zoneoffsettransition&quot;&gt;&lt;code&gt;ZoneOffsetTransition&lt;/code&gt;&lt;/a&gt; is used for known transitions, typically historic. &lt;a href=&quot;zoneoffsettransitionrule&quot;&gt;&lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt;&lt;/a&gt; is used for future transitions that are based on the result of an algorithm.</source>
          <target state="translated">규칙은 시간대에 대한 모든 과거 및 미래 전환을 모델링합니다. &lt;a href=&quot;zoneoffsettransition&quot;&gt; &lt;code&gt;ZoneOffsetTransition&lt;/code&gt; &lt;/a&gt; 은 일반적으로 기록 된 알려진 전환에 사용됩니다. &lt;a href=&quot;zoneoffsettransitionrule&quot;&gt; &lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt; &lt;/a&gt; 은 알고리즘 결과를 기반으로하는 향후 전환에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dca1ae5cccdb05f3a9c9df600b491c9af1bbd005" translate="yes" xml:space="preserve">
          <source>The rules on special characters and quoting apply regardless of which constructor is used to make an ObjectName.</source>
          <target state="translated">특수 문자 및 인용에 대한 규칙은 ObjectName을 만드는 데 사용되는 생성자에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1083994538afe151cee646e2eddf1109ecd48eef" translate="yes" xml:space="preserve">
          <source>The rules provide the functionality associated with a time-zone, such as finding the offset for a given instant or local date-time.</source>
          <target state="translated">규칙은 특정 인스턴트 또는 현지 날짜-시간의 오프셋 찾기와 같은 시간대와 관련된 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a48b9196407480649d1d001e180f9ae21afeae3" translate="yes" xml:space="preserve">
          <source>The rules used to interpret an &lt;code&gt;ObservedAttribute&lt;/code&gt; like &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; are as follows. Suppose the string is</source>
          <target state="translated">&lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; 와 같은 &lt;code&gt;ObservedAttribute&lt;/code&gt; 를 해석하는 데 사용되는 규칙 은 다음과 같습니다. 문자열이</target>
        </trans-unit>
        <trans-unit id="b9da9e1a0bb979727268d68de18fe949fd2aa76a" translate="yes" xml:space="preserve">
          <source>The rules will always return this offset when queried. The implementation class is immutable, thread-safe and serializable.</source>
          <target state="translated">규칙은 쿼리시 항상이 오프셋을 반환합니다. 구현 클래스는 변경 불가능하고 스레드로부터 안전하며 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3470726a7bfc514d0ba03c927d548da38eafa9b5" translate="yes" xml:space="preserve">
          <source>The runnable method for this class.</source>
          <target state="translated">이 클래스의 실행 가능 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="a744db65793d8a5bd6e364f10507f38a106bc516" translate="yes" xml:space="preserve">
          <source>The runnable method for this class. This will produce an image using the current RenderableImage and RenderContext and send it to all the ImageConsumer currently registered with this class.</source>
          <target state="translated">이 클래스의 실행 가능 메서드입니다. 그러면 현재 RenderableImage 및 RenderContext를 사용하여 이미지를 생성하고이 클래스에 현재 등록 된 모든 ImageConsumer로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="033cb38b43d17b8786bafc897bec4b3c4ae8e783" translate="yes" xml:space="preserve">
          <source>The sRGB color space defined at &lt;a href=&quot;http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html&quot;&gt; http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html &lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html&quot;&gt;http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html에&lt;/a&gt; 정의 된 sRGB 색 공간 .</target>
        </trans-unit>
        <trans-unit id="a0b7df0e9c02bba95c1b1a33d5e13601bd0ce3f8" translate="yes" xml:space="preserve">
          <source>The same call site may be used in several places at once.</source>
          <target state="translated">동일한 통화 사이트를 한 번에 여러 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfba385507e5c958ec5cdd390b4ae7ee0ff23620" translate="yes" xml:space="preserve">
          <source>The same conversions are allowed as for &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandle.asType&lt;/code&gt;&lt;/a&gt;, and some additional conversions are also applied if those conversions fail. Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied if possible, before or instead of any conversions done by &lt;code&gt;asType&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandle.asType&lt;/code&gt; &lt;/a&gt; 과 동일한 변환이 허용되며 이러한 변환이 실패 할 경우 일부 추가 변환도 적용됩니다. 유형 &lt;em&gt;T0&lt;/em&gt; , &lt;em&gt;T1이&lt;/em&gt; 주어지면 가능한 경우 &lt;code&gt;asType&lt;/code&gt; 에 의해 수행 된 변환 전이나 대신 다음 변환 중 하나가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="28bec6c576b1271de1ae3d70fc04df24e271a729" translate="yes" xml:space="preserve">
          <source>The same conversions are allowed as for &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;MethodHandle.asType&lt;/code&gt;&lt;/a&gt;, and some additional conversions are also applied if those conversions fail. Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied if possible, before or instead of any conversions done by &lt;code&gt;asType&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;MethodHandle.asType&lt;/code&gt; &lt;/a&gt; 과 동일한 변환이 허용되며 이러한 변환이 실패하면 일부 추가 변환도 적용됩니다. &lt;em&gt;T0&lt;/em&gt; , &lt;em&gt;T1&lt;/em&gt; 유형이 주어지면 가능한 경우 &lt;code&gt;asType&lt;/code&gt; 으로 수행되는 변환 전에 또는 대신 다음 변환 중 하나가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6ab80d33fa4b7f4a321447e169ab216836d5a87" translate="yes" xml:space="preserve">
          <source>The same example, dropping arguments and using combinators:</source>
          <target state="translated">동일한 예, 인수를 삭제하고 결합자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3156cf800cbaf487594e90d4f19f68e8ba277657" translate="yes" xml:space="preserve">
          <source>The same listener object may be added more than once, and will be called as many times as it is added. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is taken.</source>
          <target state="translated">동일한 리스너 객체는 두 번 이상 추가 될 수 있으며 추가 된 횟수만큼 호출됩니다. &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="791680086f6d9e78094100fb9300338027ea15fa" translate="yes" xml:space="preserve">
          <source>The same naming conventions are applied to the methods in an MXBean as in a Standard MBean:</source>
          <target state="translated">표준 MBean에서와 동일한 이름 지정 규칙이 MXBean의 메소드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="681f3cced20ba9e0fb93240854ee9634fa1a6146" translate="yes" xml:space="preserve">
          <source>The same output can be generated with this code, which uses a regular expression to parse all four tokens at once:</source>
          <target state="translated">이 코드를 사용하여 동일한 출력을 생성 할 수 있습니다. 정규식을 사용하여 4 개의 토큰을 한 번에 모두 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="1aca9034c5ce7f0103f2b633705ed622da3b779f" translate="yes" xml:space="preserve">
          <source>The same principle holds true for setting layout managers, removing components, listing children, etc. All these methods are invoked on the &lt;code&gt;contentPane&lt;/code&gt; instead of on the &lt;code&gt;JRootPane&lt;/code&gt;.</source>
          <target state="translated">레이아웃 관리자 설정, 구성 요소 제거, 자식 나열 등에 대해서도 동일한 원칙이 적용됩니다. 이러한 모든 메서드는 &lt;code&gt;JRootPane&lt;/code&gt; 대신 &lt;code&gt;contentPane&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7706c997f0206204d48e6784227fbc2dcd70a39c" translate="yes" xml:space="preserve">
          <source>The same rules are used for locating the configuration properties as are used at startup. So normally the logging properties will be re-read from the same file that was used at startup.</source>
          <target state="translated">시작시 사용되는 것과 동일한 규칙이 구성 특성을 찾는 데 사용됩니다. 따라서 일반적으로 로깅 특성은 시작시 사용한 동일한 파일에서 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="40c696d758a9065648ff0c79befb43bf73945edb" translate="yes" xml:space="preserve">
          <source>The same value</source>
          <target state="translated">같은 가치</target>
        </trans-unit>
        <trans-unit id="457dd191617eea60f8880ece3469c77e1ea4e638" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.1, with all elements divided by 2.</source>
          <target state="translated">모든 요소를 ​​2로 나눈 JPEG 사양 표 K.1에 제공된 샘플 색차 양자화 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="66abdaa3d456aeedbf328a69ececa50ab9fd015c" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.1, with all elements divided by 2. According to the specification, these values produce &quot;very good&quot; quality output. This is the table usually used for &quot;visually lossless&quot; encoding, and is the default chrominance table used if the default tables and quality settings are used.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 색차 양자화 테이블은 모든 요소를 ​​2로 나눈 값입니다. 사양에 따라이 값은 &quot;매우 우수한&quot;품질 출력을 생성합니다. 이 테이블은 일반적으로 &quot;시각적 손실없는&quot;인코딩에 사용되는 테이블이며 기본 테이블 및 품질 설정을 사용하는 경우 사용되는 기본 색차 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="b5e23252dc7982b61ec60d6fa4b1c02b4d854c18" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.2.</source>
          <target state="translated">JPEG 사양, 표 K.2에 제공된 샘플 색차 양자화 테이블.</target>
        </trans-unit>
        <trans-unit id="1cb7bb906bae31a02cfce6b8aa3fb45b84e3040c" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.2. According to the specification, these values produce &quot;good&quot; quality output.</source>
          <target state="translated">JPEG 사양, 표 K.2에 주어진 샘플 색차 양자화 테이블. 사양에 따르면이 값은 &quot;양호한&quot;품질 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="25c651e5098644d6cd24f42dc03c0a707b13d70d" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1, with all elements divided by 2.</source>
          <target state="translated">모든 요소를 ​​2로 나눈 JPEG 사양, 표 K.1에 제공된 샘플 휘도 양자화 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="e37dceb33c264c204dc116d8ce75114c90f4c7a3" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1, with all elements divided by 2. According to the specification, these values produce &quot;very good&quot; quality output. This is the table usually used for &quot;visually lossless&quot; encoding, and is the default luminance table used if the default tables and quality settings are used.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 휘도 양자화 테이블은 모든 요소를 ​​2로 나눈 값입니다. 사양에 따라이 값은 &quot;매우 우수한&quot;품질 출력을 생성합니다. 이 테이블은 일반적으로 &quot;시각적 손실없는&quot;인코딩에 사용되는 테이블이며 기본 테이블 및 품질 설정을 사용하는 경우 사용되는 기본 광도 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="d0b62fba0a5289bbc7385bf5f89b4ca6d49b2768" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1.</source>
          <target state="translated">JPEG 사양, 표 K.1에 제공된 샘플 휘도 양자화 표.</target>
        </trans-unit>
        <trans-unit id="41d6745b125ca8d196d6a79815800d21e82cdffb" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1. According to the specification, these values produce &quot;good&quot; quality output.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 휘도 양자화 테이블. 사양에 따르면이 값은 &quot;양호한&quot;품질 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b999ec10517f908ef6af8dfcfecb7806f54e48fb" translate="yes" xml:space="preserve">
          <source>The scale of the returned &lt;code&gt;BigDecimal&lt;/code&gt; will be the number of digits in the fraction, or zero if the string contains no decimal point, subject to adjustment for any exponent; if the string contains an exponent, the exponent is subtracted from the scale. The value of the resulting scale must lie between &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; and &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, inclusive.</source>
          <target state="translated">리턴 된 &lt;code&gt;BigDecimal&lt;/code&gt; 의 스케일은 분수의 자릿수이거나 문자열에 소수점이없는 경우 0이됩니다. 지수에 따라 조정됩니다. 문자열에 지수가 포함되어 있으면 지수에서 지수를 뺍니다. 결과 스케일의 값은 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; ~ &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 사이 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="7396cf813336a30d0a1bab52aed3246ae5a6aefb" translate="yes" xml:space="preserve">
          <source>The scanner can also use delimiters other than whitespace. This example reads several items in from a string:</source>
          <target state="translated">스캐너는 공백 이외의 구분 기호를 사용할 수도 있습니다. 이 예제는 문자열에서 여러 항목을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a4947ea8b0c611076ba187f044654968e3ab9ec3" translate="yes" xml:space="preserve">
          <source>The scheduling policy of StampedLock does not consistently prefer readers over writers or vice versa. All &quot;try&quot; methods are best-effort and do not necessarily conform to any scheduling or fairness policy. A zero return from any &quot;try&quot; method for acquiring or converting locks does not carry any information about the state of the lock; a subsequent invocation may succeed.</source>
          <target state="translated">StampedLock의 스케쥴링 정책은 독자보다 독자를 선호하지 않으며 그 반대도 마찬가지입니다. 모든 &quot;시도&quot;방법은 최선의 노력이며 일정이나 공정성 정책을 반드시 준수하지는 않습니다. 잠금을 획득하거나 변환하기위한 &quot;시도&quot;방법에서 0을 반환해도 잠금 상태에 대한 정보는 없습니다. 후속 호출이 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b03631e0a864ad17eff8a3140236f245127ccd24" translate="yes" xml:space="preserve">
          <source>The schema columns are:</source>
          <target state="translated">스키마 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e88c8d4c87637576e7f0f88b7eb8972efe2f3f6" translate="yes" xml:space="preserve">
          <source>The schema definition describes the internal data of a &lt;code&gt;RowSet&lt;/code&gt; object in three distinct areas:</source>
          <target state="translated">스키마 정의는 세 가지 영역에서 &lt;code&gt;RowSet&lt;/code&gt; 개체 의 내부 데이터를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="0bb86dfd7dd2cb7c7dabbe5b9afa0ca86ee85837" translate="yes" xml:space="preserve">
          <source>The scheme component of a URI cannot contain escaped octets, hence this method does not perform any decoding.</source>
          <target state="translated">URI의 스킴 구성 요소는 이스케이프 된 옥텟을 포함 할 수 없으므로이 메소드는 디코딩을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03f4421d79610120278b2b05c4ad70853ae92f0a" translate="yes" xml:space="preserve">
          <source>The scheme component of a URI, if defined, only contains characters in the</source>
          <target state="translated">URI의 스킴 구성 요소 (정의 된 경우)에는</target>
        </trans-unit>
        <trans-unit id="552a02db11e3a965b8192d8915eaba47a77bf1a7" translate="yes" xml:space="preserve">
          <source>The scheme component of this URI, or &lt;code&gt;null&lt;/code&gt; if the scheme is undefined</source>
          <target state="translated">이 URI 스킴 컴퍼넌트 . 스킴이 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347507e3914af1d8c1191601bb5aa53cb19b0fe4" translate="yes" xml:space="preserve">
          <source>The scheme-specific part of a URI only contains legal URI characters.</source>
          <target state="translated">URI의 체계 별 부분에는 유효한 URI 문자 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="786e33a9934f50290255272a6f6e5a002f9a8ca7" translate="yes" xml:space="preserve">
          <source>The scope that is printed out may be a filename, in which case it may convey local system information. For example, here's a sample printout of an identity named &quot;carol&quot;, who is marked not trusted in the user's identity database:</source>
          <target state="translated">인쇄되는 범위는 파일 이름 일 수 있으며,이 경우 로컬 시스템 정보를 전달할 수 있습니다. 예를 들어, 다음은 사용자의 신원 데이터베이스에서 신뢰할 수없는 것으로 표시된 &quot;carol&quot;이라는 신원의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="b44f515dc7972f5ec50a61a5a4b5d182cf8f1fa1" translate="yes" xml:space="preserve">
          <source>The scope, returningObj flag, and returningAttributes flag from the search controls &lt;code&gt;ctls&lt;/code&gt; are used to control the selection of objects that the listener is interested in, and determines what information is returned in the eventual &lt;code&gt;NamingEvent&lt;/code&gt; object. Note that the requested information to be returned might not be present in the &lt;code&gt;NamingEvent&lt;/code&gt; object if they are unavailable or could not be obtained by the service provider or service.</source>
          <target state="translated">검색 제어 &lt;code&gt;ctls&lt;/code&gt; 에서 scope, returningObj 플래그 및 returningAttributes 플래그 는 리스너가 관심있는 오브젝트의 선택을 제어하고 최종 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 리턴되는 정보를 판별하는 데 사용됩니다 . 요청 된 정보 가 사용 불가능하거나 서비스 제공 업체 또는 서비스에서 확보 할 수없는 경우 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e7ec0bc18757e2695eb1c71f854b0d45664eafa" translate="yes" xml:space="preserve">
          <source>The script code, or the empty string if none is defined.</source>
          <target state="translated">스크립트 코드 또는 정의되지 않은 경우 빈 문자열</target>
        </trans-unit>
        <trans-unit id="f9cd18270d845ffc1ce9a3c3c4df5a00249e7be6" translate="yes" xml:space="preserve">
          <source>The script names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid script names accepted and defined by &lt;a href=&quot;../../lang/character.unicodescript#forName(java.lang.String)&quot;&gt;&lt;code&gt;UnicodeScript.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에서 지원하는 스크립트 이름은 &lt;a href=&quot;../../lang/character.unicodescript#forName(java.lang.String)&quot;&gt; &lt;code&gt;UnicodeScript.forName&lt;/code&gt; 에서&lt;/a&gt; 허용하고 정의한 유효한 스크립트 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="ef23874ea1d91d27f386b1f20ccc288696d91d71" translate="yes" xml:space="preserve">
          <source>The script names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid script names accepted and defined by &lt;a href=&quot;../../lang/character.unicodescript#forName-java.lang.String-&quot;&gt;&lt;code&gt;UnicodeScript.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에서 지원하는 스크립트 이름은 &lt;a href=&quot;../../lang/character.unicodescript#forName-java.lang.String-&quot;&gt; &lt;code&gt;UnicodeScript.forName&lt;/code&gt; 에서&lt;/a&gt; 허용하고 정의한 유효한 스크립트 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="afafae7f294d0de7bc87bb9a26199785990e9648" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java &lt;sup&gt;TM&lt;/sup&gt; Scripting Engines and provides a framework for their use in Java applications.</source>
          <target state="translated">스크립팅 API는 Java &lt;sup&gt;TM&lt;/sup&gt; 스크립팅 엔진 을 정의 하고 Java 응용 프로그램에서 사용하기위한 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9c43eef002cb23064cdf0bd61ad8d93fd63d843" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java &lt;sup&gt;TM&lt;/sup&gt; Scripting Engines and provides a framework for their use in Java applications. This API is intended for use by application programmers who wish to execute programs written in scripting languages in their Java applications. The scripting language programs are usually provided by the end-users of the applications.</source>
          <target state="translated">스크립팅 API는 Java &lt;sup&gt;TM&lt;/sup&gt; 스크립팅 엔진 을 정의 하고 Java 응용 프로그램에서 사용하기위한 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다 . 이 API는 Java 응용 프로그램에서 스크립팅 언어로 작성된 프로그램을 실행하려는 응용 프로그램 프로그래머가 사용하기위한 것입니다. 스크립팅 언어 프로그램은 일반적으로 응용 프로그램의 최종 사용자가 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91a09023d6539d10b0c1f584fa294076db23ca2e" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java&amp;trade; Scripting Engines and provides a framework for their use in Java applications.</source>
          <target state="translated">스크립팅 API는 Java &amp;trade; 스크립팅 엔진을 정의하고 Java 애플리케이션에서 사용하기위한 프레임 워크를 제공하는 인터페이스 및 클래스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dbb04c3cbf16a517019ff0d16573062dacfefe7e" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java&amp;trade; Scripting Engines and provides a framework for their use in Java applications. This API is intended for use by application programmers who wish to execute programs written in scripting languages in their Java applications. The scripting language programs are usually provided by the end-users of the applications.</source>
          <target state="translated">스크립팅 API는 Java &amp;trade; 스크립팅 엔진을 정의하고 Java 애플리케이션에서 사용하기위한 프레임 워크를 제공하는 인터페이스 및 클래스로 구성됩니다. 이 API는 자바 애플리케이션에서 스크립팅 언어로 작성된 프로그램을 실행하려는 애플리케이션 프로그래머를위한 것입니다. 스크립팅 언어 프로그램은 일반적으로 응용 프로그램의 최종 사용자가 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1874cbc91889750bd4ed8944d7e77907c076a39f" translate="yes" xml:space="preserve">
          <source>The scroll bar's bubble may not be displayed when it is not moveable (e.g. when it takes up the entire length of the scroll bar's track, or when the scroll bar is disabled). Whether the bubble is displayed or not will not affect the value returned by &lt;code&gt;getVisibleAmount&lt;/code&gt;.</source>
          <target state="translated">스크롤 바의 버블은 움직일 수없는 경우 표시되지 않을 수 있습니다 (예 : 스크롤 바 트랙의 전체 길이를 차지하거나 스크롤 바가 비활성화 된 경우). 풍선이 표시되는지 여부는 &lt;code&gt;getVisibleAmount&lt;/code&gt; 가 반환하는 값에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="97033424809eec61b4328169ae2d5e8590d94a71" translate="yes" xml:space="preserve">
          <source>The scroll begin event.</source>
          <target state="translated">스크롤 시작 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="bbde2811daac4486a0d468cb8007d4cb47236d0e" translate="yes" xml:space="preserve">
          <source>The scroll end event.</source>
          <target state="translated">스크롤 종료 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="004e7fbf09f50fe4e8b7ac9e967dfbe4024d2b0c" translate="yes" xml:space="preserve">
          <source>The scrollbar is flexible along it's scrolling axis and rigid along the other axis.</source>
          <target state="translated">스크롤바는 스크롤 축을 따라 유연하고 다른 축을 따라 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="382eadecc4f037382eec5e741ad0ea680bcfcb6e" translate="yes" xml:space="preserve">
          <source>The scrollpane's horizontal scrollbar child.</source>
          <target state="translated">스크롤 창의 가로 스크롤바 자식입니다.</target>
        </trans-unit>
        <trans-unit id="1e11140820d076c7d796e1e85149749c745f6fe9" translate="yes" xml:space="preserve">
          <source>The scrollpane's horizontal scrollbar child. Default is a &lt;code&gt;JScrollBar&lt;/code&gt;.</source>
          <target state="translated">스크롤 창의 가로 스크롤바 자식입니다. 기본값은 &lt;code&gt;JScrollBar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c8de2f0f7fbe23e6af5b111099c0e258b48a689" translate="yes" xml:space="preserve">
          <source>The scrollpane's vertical scrollbar child.</source>
          <target state="translated">스크롤 창의 수직 스크롤바 자식입니다.</target>
        </trans-unit>
        <trans-unit id="9ede92af942aaedafaf8414479c489583940b562" translate="yes" xml:space="preserve">
          <source>The scrollpane's vertical scrollbar child. Default is a &lt;code&gt;JScrollBar&lt;/code&gt;.</source>
          <target state="translated">스크롤 창의 수직 스크롤바 자식입니다. 기본값은 &lt;code&gt;JScrollBar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed6800d98f16995f5770b6c60e908abcfe32f1d9" translate="yes" xml:space="preserve">
          <source>The scrollpane's viewport child.</source>
          <target state="translated">scrollpane의 뷰포트 자식입니다.</target>
        </trans-unit>
        <trans-unit id="0e686b1765e2793e43fa880f8aa01f46c51c762b" translate="yes" xml:space="preserve">
          <source>The scrollpane's viewport child. Default is an empty &lt;code&gt;JViewport&lt;/code&gt;.</source>
          <target state="translated">scrollpane의 뷰포트 자식입니다. 기본값은 빈 &lt;code&gt;JViewport&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1adc17dbde6a6617e4245b5f40d3e5c15d6310c1" translate="yes" xml:space="preserve">
          <source>The search is started in the current catalog. If a match is found, no further attempt will be made. Only if there is no match in the current catalog, will alternate catalogs including delegate and next catalogs be considered.</source>
          <target state="translated">현재 카탈로그에서 검색이 시작됩니다. 일치하는 항목이 있으면 더 이상 시도하지 않습니다. 현재 카탈로그에 일치하는 항목이없는 경우에만 대리인 및 다음 카탈로그를 포함한 대체 카탈로그가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="234d2029591ee11c919d4dd5c206f5910e43d339" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="81db3c5442cb31038e49ee8d70757fa89532101d" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;#getSystemResource(java.lang.String)&quot;&gt;&lt;code&gt;getSystemResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;#getSystemResource(java.lang.String)&quot;&gt; &lt;code&gt;getSystemResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5785d6097b7d16726e6bb2855b1f1eebb4a0faba" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;../lang/classloader#getResource(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;../lang/classloader#getResource(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbe5e391a79ef4fb56cc4fe90eb28db84ba088c" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a9f3a688129049dc155e8aa96211ff37a84c5a" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1a2e358f079002238a405e9b7e93cabc439a00" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;classloader#getSystemResource-java.lang.String-&quot;&gt;&lt;code&gt;getSystemResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;classloader#getSystemResource-java.lang.String-&quot;&gt; &lt;code&gt;getSystemResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ee7f2ec763cae105fa5de7897720ebb90d644f" translate="yes" xml:space="preserve">
          <source>The search order of locale sensitive services can be configured by using the &quot;java.locale.providers&quot; system property. This system property declares the user's preferred order for looking up the locale sensitive services separated by a comma. It is only read at the Java runtime startup, so the later call to System.setProperty() won't affect the order.</source>
          <target state="translated">로케일 감지 서비스의 검색 순서는 &quot;java.locale.providers&quot;시스템 특성을 사용하여 구성 할 수 있습니다. 이 시스템 속성은 쉼표로 구분 된 로케일에 민감한 서비스를 조회하기위한 사용자의 선호 순서를 선언합니다. Java 런타임 시작시에만 읽히므로 나중에 System.setProperty ()를 호출해도 순서에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a60b10d749f6decd1a4f3bf2354bd215518658a" translate="yes" xml:space="preserve">
          <source>The search scope of this SearchControls.</source>
          <target state="translated">이 SearchControls의 검색 범위입니다.</target>
        </trans-unit>
        <trans-unit id="8c894820daeb9009f19e3e0e441e8caf2831e1c8" translate="yes" xml:space="preserve">
          <source>The search will not cross naming system boundaries.</source>
          <target state="translated">검색은 이름 지정 시스템 경계를 넘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71dac0f2a283224db1975250180f8302d951ec94" translate="yes" xml:space="preserve">
          <source>The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.</source>
          <target state="translated">검색된 클래스 정의는 현재 실행중인 클래스가 컴파일 될 때 존재하지만 정의를 더 이상 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19f0094b2e54dfb70b25925659062cdceddabfdd" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. A &lt;code&gt;Long&lt;/code&gt; object that represents the value of the second argument is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or null.</source>
          <target state="translated">두 번째 인수는 기본값입니다. &lt;code&gt;Long&lt;/code&gt; 지정된 이름의 속성이없는 경우, 해당 건물이 적절한 수치 형식이 아닌 경우, 또는 지정된 이름이 공백 또는 null의 경우 두 번째 인수의 값을 나타내는 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6fd52e585e241819acf494d6ce4e0623d9e9bbc2" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. An &lt;code&gt;Integer&lt;/code&gt; object that represents the value of the second argument is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 기본값입니다. &lt;code&gt;Integer&lt;/code&gt; 지정된 이름의 속성이없는 경우, 해당 건물이 적절한 수치 형식이 아닌 경우, 또는 지정된 이름이 비어 있거나 경우 두 번째 인수의 값을 나타내는 개체가 반환됩니다 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f48b892ab5983e62a64c20f51aeb4852a6d40d4" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. The default value is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 기본값입니다. 지정된 이름의 속성이 없거나 속성에 올바른 숫자 형식이 없거나 지정된 이름이 비어 있거나 &lt;code&gt;null&lt;/code&gt; 인 경우 기본값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b41fe98f3d794287cf7faede901c217eb147c5f5" translate="yes" xml:space="preserve">
          <source>The second highest justification priority.</source>
          <target state="translated">두 번째로 높은 정당성 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="846dd73201fada82f56344da711130e328206130" translate="yes" xml:space="preserve">
          <source>The second is a completion signal that allows the driver to wait until all workers have completed.</source>
          <target state="translated">두 번째는 운전자가 모든 작업자가 완료 할 때까지 기다릴 수있는 완료 신호입니다.</target>
        </trans-unit>
        <trans-unit id="84e48120fa361c307626734228e297300ca0735a" translate="yes" xml:space="preserve">
          <source>The second lowest justification priority.</source>
          <target state="translated">두 번째로 낮은 정당성 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="9c74ca16e8df45ce54eac3795a7c789ada4f5436" translate="yes" xml:space="preserve">
          <source>The second model is that attributes are associated with a name (typically an atomic name) in a DirContext. In this model, an attribute operation on the named object is roughly equivalent to a lookup on the name of the parent DirContext of the named object, followed by the attribute operation invoked on the parent in which the caller supplies the terminal atomic name. The attributes can be viewed as being stored in the parent DirContext (again, this does not imply that the implementation must do so). Objects that are not DirContexts can have attributes, as long as their parents are DirContexts.</source>
          <target state="translated">두 번째 모델은 속성이 DirContext의 이름 (일반적으로 원자 이름)과 연관되어 있다는 것입니다. 이 모델에서, 명명 된 객체의 속성 연산은 명명 된 객체의 부모 DirContext의 이름을 조회 한 다음 호출자가 터미널 원자 이름을 제공하는 상위에서 호출 된 속성 연산과 거의 같습니다. 속성은 부모 DirContext에 저장된 것으로 볼 수 있습니다 (다시 말해 구현이 그렇게해야 함을 의미하지는 않습니다). DirContext가 아닌 객체는 부모가 DirContext 인 한 속성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08627207b7124af34d47a11be9d4eb35f89c3aa4" translate="yes" xml:space="preserve">
          <source>The second node precedes the reference node.</source>
          <target state="translated">두 번째 노드는 참조 노드 앞에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e114c9855232da640f7bcf88369ff012eb0d38ce" translate="yes" xml:space="preserve">
          <source>The second of minute of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;, from 0 to 59.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 초입니다 . 0부터 59까지입니다.</target>
        </trans-unit>
        <trans-unit id="a1a191dfba3988b37aebbbf772bf95fd6c7c5ef5" translate="yes" xml:space="preserve">
          <source>The second-of-day.</source>
          <target state="translated">둘째 날.</target>
        </trans-unit>
        <trans-unit id="0e870041b0c18ce21d4cc73d1cbae5e1e2aeb07b" translate="yes" xml:space="preserve">
          <source>The second-of-minute.</source>
          <target state="translated">두 번째 분.</target>
        </trans-unit>
        <trans-unit id="f6efcc10b579d40e24ab34cc216d6d80435a8d31" translate="yes" xml:space="preserve">
          <source>The seconds and nanoseconds are extracted from the specified milliseconds.</source>
          <target state="translated">지정된 밀리 초에서 초와 나노초가 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="23a2616566fd816bf2a993165e25281f4a18c7b6" translate="yes" xml:space="preserve">
          <source>The seconds and nanoseconds are extracted from the specified nanoseconds.</source>
          <target state="translated">지정된 나노초에서 초와 나노초가 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="7a0383fffb7779acd5ef652edbc25f76897e0327" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of a day, where each day is 86400 seconds which implies a 24 hour day. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 하루의 표준 정의에 따라 계산되며, 여기서 하루는 86400 초이며 24 시간의 하루를 의미합니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="18dafaf48750adbb9e664a9c182377f5852b8936" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of a minute, where each minute is 60 seconds. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 분의 표준 정의에 따라 계산되며, 각 분은 60 초입니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bdf17cabd8f715fb436e568230500a070a9d89b" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of an hour, where each hour is 3600 seconds. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 시간의 표준 정의에 따라 계산되며, 각 시간은 3600 초입니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a48467f35f4c20748fa3acc00c4bb7c44e6d23fb" translate="yes" xml:space="preserve">
          <source>The secure communications modes include:</source>
          <target state="translated">보안 통신 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb1ed30a436bf227420125540bd43fdab515b945" translate="yes" xml:space="preserve">
          <source>The security consideration is important with respect to internationalization domain name support. For example, English domain names may be</source>
          <target state="translated">국제화 도메인 이름 지원과 관련하여 보안 고려 사항이 중요합니다. 예를 들어 영어 도메인 이름은</target>
        </trans-unit>
        <trans-unit id="8754c4a5e5f52f313c5ec7c42a10eeb348a2de09" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5f541439356895d1a7b18c9420f1d7b1125db20e" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy. Granting the setSecurityManager permission would allow code to change which security manager is used by installing a different, possibly less restrictive security manager, thereby bypassing checks that would have been enforced by the original security manager.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다. setSecurityManager 권한을 부여하면 코드가 덜 제한적인 다른 보안 관리자를 설치하여 사용되는 보안 관리자를 변경하여 원래 보안 관리자가 시행 한 검사를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea632fc690ffe8730861707a2c56b33a9b6867d2" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy. It allows an application to determine, before performing a possibly unsafe or sensitive operation, what the operation is and whether it is being attempted in a security context that allows the operation to be performed. The application can allow or disallow the operation.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다. 응용 프로그램은 안전하지 않거나 민감한 작업을 수행하기 전에 작업이 무엇인지, 작업을 수행 할 수있는 보안 컨텍스트에서 작업이 시도되고 있는지 여부를 확인할 수 있습니다. 응용 프로그램은 작업을 허용하거나 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77cdd2014731846d35b1ae24ee942e1177ba673e" translate="yes" xml:space="preserve">
          <source>The security manager is thereby given an opportunity to prevent completion of the operation by throwing an exception. A security manager routine simply returns if the operation is permitted, but throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not permitted.</source>
          <target state="translated">보안 관리자는 예외를 발생시켜 작업 완료를 방지 할 수 있습니다. 보안 관리자 루틴은 작업이 허용되면 단순히 반환하지만 작업이 허용 되지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 을 throw합니다 .</target>
        </trans-unit>
        <trans-unit id="c0ed1fb6cefbd737d506d963693aa54fe70100ed" translate="yes" xml:space="preserve">
          <source>The security manager is thereby given an opportunity to prevent completion of the operation by throwing an exception. A security manager routine simply returns if the operation is permitted, but throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not permitted. The only exception to this convention is &lt;code&gt;checkTopLevelWindow&lt;/code&gt;, which returns a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">이로써 보안 관리자는 예외를 던져서 작업 완료를 막을 수있는 기회가 주어집니다. 보안 관리자 루틴은 조작이 허용되면 단순히 리턴하지만 조작이 허용 되지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 을 발생시킵니다. 이 규칙에 대한 유일한 예외는 &lt;code&gt;checkTopLevelWindow&lt;/code&gt; 이며 &lt;code&gt;boolean&lt;/code&gt; 값 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a67c38f887b66e32ea2617d5a99442f063242dfe" translate="yes" xml:space="preserve">
          <source>The security provider framework uses this method with some types of services to quickly exclude non-matching implementations for consideration. Applications will typically not need to call it.</source>
          <target state="translated">보안 제공자 프레임 워크는 일부 서비스 유형과 함께이 방법을 사용하여 일치하지 않는 구현을 신속하게 제외시킵니다. 응용 프로그램은 일반적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="741ac520b2873a175ac0092c4d1afb002e856fbf" translate="yes" xml:space="preserve">
          <source>The segment type constant for a point that specifies the end point of a line to be drawn from the most recently specified point.</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 선의 끝점을 지정하는 점에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="3973bcf55ac17cd3ee487605b4f605a51f7088ed" translate="yes" xml:space="preserve">
          <source>The segment type constant for a point that specifies the starting location for a new subpath.</source>
          <target state="translated">새 하위 경로의 시작 위치를 지정하는 지점에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="80aba145fc2824f9bd007706a9f479370c0b4eb2" translate="yes" xml:space="preserve">
          <source>The segment type constant for the pair of points that specify a quadratic parametric curve to be drawn from the most recently specified point.</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 2 차 파라 메트릭 곡선을 지정하는 점 쌍에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="c18a9968e10da3d03ea7eda9a64c42aeb83bb165" translate="yes" xml:space="preserve">
          <source>The segment type constant for the pair of points that specify a quadratic parametric curve to be drawn from the most recently specified point. The curve is interpolated by solving the parametric control equation in the range &lt;code&gt;(t=[0..1])&lt;/code&gt; using the most recently specified (current) point (CP), the first control point (P1), and the final interpolated control point (P2). The parametric control equation for this curve is:</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 2 차 파라 메트릭 곡선을 지정하는 점 쌍에 대한 세그먼트 유형 상수입니다. 곡선은 가장 최근에 지정된 (현재) 점 (CP), 첫 번째 제어점 (P1) 및 최종 보간 된 제어점을 사용하여 범위 &lt;code&gt;(t=[0..1])&lt;/code&gt; 의 매개 변수 제어 방정식을 풀어 보간됩니다. (P2). 이 곡선의 매개 변수 제어 방정식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87af03fe4753c3d0fd37c06a404fc52727178751" translate="yes" xml:space="preserve">
          <source>The segment type constant for the set of 3 points that specify a cubic parametric curve to be drawn from the most recently specified point.</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 3 차 파라 메트릭 곡선을 지정하는 3 개의 점 세트에 대한 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="0339b07d46a1df3c557c177f88fe1e9060e280d6" translate="yes" xml:space="preserve">
          <source>The segment type constant for the set of 3 points that specify a cubic parametric curve to be drawn from the most recently specified point. The curve is interpolated by solving the parametric control equation in the range &lt;code&gt;(t=[0..1])&lt;/code&gt; using the most recently specified (current) point (CP), the first control point (P1), the second control point (P2), and the final interpolated control point (P3). The parametric control equation for this curve is:</source>
          <target state="translated">가장 최근에 지정된 점에서 그릴 3 차 파라 메트릭 곡선을 지정하는 3 개의 점 세트에 대한 세그먼트 유형 상수입니다. 곡선은 가장 최근에 지정된 (현재) 점 (CP), 첫 번째 제어점 (P1), 두 번째 제어점 (P2 &lt;code&gt;(t=[0..1])&lt;/code&gt; 사용하여 범위 (t = [0..1]) 의 매개 변수 제어 방정식을 풀어 보간됩니다 . ) 및 최종 보간 된 제어점 (P3). 이 곡선의 매개 변수 제어 방정식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb56a94440f8726332fb64d2dd4609e5fa3a2ec8" translate="yes" xml:space="preserve">
          <source>The segment type constant that specifies that the preceding subpath should be closed by appending a line segment back to the point corresponding to the most recent SEG_MOVETO.</source>
          <target state="translated">가장 최근의 SEG_MOVETO에 해당하는 지점에 선 세그먼트를 다시 추가하여 이전 하위 경로를 닫아야 함을 지정하는 세그먼트 유형 상수입니다.</target>
        </trans-unit>
        <trans-unit id="f99f7b7b77b1d24238b1a7159cfaaf7109131828" translate="yes" xml:space="preserve">
          <source>The selected item may not necessarily be managed by the underlying &lt;code&gt;ListModel&lt;/code&gt;. This disjoint behavior allows for the temporary storage and retrieval of a selected item in the model.</source>
          <target state="translated">선택된 항목은 기본 &lt;code&gt;ListModel&lt;/code&gt; 에 의해 관리되지 않을 수도 있습니다 . 이 분리 된 동작은 모델에서 선택한 항목의 임시 저장 및 검색을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="72d6ad2310e85fb1d6829a4a5954408f8cdc0c95" translate="yes" xml:space="preserve">
          <source>The selected item or &lt;code&gt;null&lt;/code&gt; if there is no selection</source>
          <target state="translated">선택한 항목 또는 선택 항목 이없는 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="980a17db139f93c4be1dbeca6c1ec98c6a583f36" translate="yes" xml:space="preserve">
          <source>The selected-key set is &lt;a href=&quot;#ksc&quot;&gt;not thread-safe&lt;/a&gt;.</source>
          <target state="translated">선택한 키 세트는 &lt;a href=&quot;#ksc&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf5971d519d788492de5d5d81d0e5637fab2e9f3" translate="yes" xml:space="preserve">
          <source>The selected-key set is &lt;a href=&quot;#sksc&quot;&gt;not thread-safe&lt;/a&gt;.</source>
          <target state="translated">선택된 키 세트는 &lt;a href=&quot;#sksc&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2853e7255aa0a673fced6a6df84b0254f3157771" translate="yes" xml:space="preserve">
          <source>The selection can be discontiguous on lines with mixed-direction text. Only those characters in the logical range between start and limit appear selected. For example, consider the text 'ABCdef' where capital letters indicate right-to-left text, rendered on a right-to-left line, with a logical selection from 0 to 4 ('ABCd'). The text appears as follows, with bold standing in for the selection, and underlining for the extension:</source>
          <target state="translated">선택은 방향이 혼합 된 텍스트가있는 행에서 불연속적일 수 있습니다. 시작과 제한 사이의 논리적 범위에있는 문자 만 선택된 것으로 나타납니다. 예를 들어, 대문자가 오른쪽에서 왼쪽 줄에 렌더링 된 오른쪽에서 왼쪽 텍스트를 나타내는 'ABCdef'텍스트를 생각해보십시오. 논리적 선택은 0에서 4 ( 'ABCd')입니다. 텍스트는 선택 항목에 굵게 표시되고 확장에 밑줄이 표시되어 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ee377636b8b2866aeab5296e00c6c54b19e71ed5" translate="yes" xml:space="preserve">
          <source>The selection criteria are represented by a map. Each map entry represents a selection criterion. A provider is selected iff it satisfies all selection criteria. The key for any entry in such a map must be in one of the following two formats:</source>
          <target state="translated">선택 기준은지도로 표시됩니다. 각 맵 항목은 선택 기준을 나타냅니다. 모든 선택 기준을 충족하면 제공자가 선택됩니다. 이러한 맵에서 항목의 키는 다음 두 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e44ffedc1f376eadaacdab4f99049fa47e9e98b9" translate="yes" xml:space="preserve">
          <source>The selection criterion must be specified in one of the following two formats:</source>
          <target state="translated">선택 기준은 다음 두 형식 중 하나로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="74c7112680921edb20e3d4d4f9eaa109f3c9a083" translate="yes" xml:space="preserve">
          <source>The selection is discontiguous because the selected characters are visually discontiguous. Also note that since the range includes the first logical character (A), the selection is extended to the portion of the &lt;code&gt;bounds&lt;/code&gt; before the start of the layout, which in this case (a right-to-left line) is the right portion of the &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">선택한 문자가 시각적으로 불연속 적이기 때문에 선택이 불 연속적입니다. 또한 범위에 첫 번째 논리 문자 (A)가 포함되어 있으므로 선택은 레이아웃 시작 전 &lt;code&gt;bounds&lt;/code&gt; 부분으로 확장됩니다. 이 경우 (오른쪽에서 왼쪽 줄) &lt;code&gt;bounds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8f3e58fee457f743d90cb3a11b275bb0e5c734" translate="yes" xml:space="preserve">
          <source>The selection model property name.</source>
          <target state="translated">선택 모델 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5b8e52c4dc1170658ac68079e913b9282a57c2c8" translate="yes" xml:space="preserve">
          <source>The selection operations synchronize on the selector itself, on the key set, and on the selected-key set, in that order. They also synchronize on the cancelled-key set during steps (1) and (3) above.</source>
          <target state="translated">선택 작업은 선택기 자체, 키 세트 및 선택한 키 세트에서 순서대로 동기화됩니다. 또한 위의 1 단계와 3 단계에서 취소 된 키 세트를 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="a904ff842ccfcf481664d94ff854e457ba5bfb75" translate="yes" xml:space="preserve">
          <source>The selection operations synchronize on the selector itself, on the selected-key set, in that order. They also synchronize on the cancelled-key set during steps (1) and (3) above.</source>
          <target state="translated">선택 작업은 선택기 자체에서 선택한 키 세트의 순서대로 동기화됩니다. 또한 위의 단계 (1) 및 (3)에서 설정 한 취소 된 키에서 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f0fdc28581457a5d51859c43f5da1f56889794b2" translate="yes" xml:space="preserve">
          <source>The selection state of a &lt;code&gt;JList&lt;/code&gt; is managed by another separate model, an instance of &lt;code&gt;ListSelectionModel&lt;/code&gt;. &lt;code&gt;JList&lt;/code&gt; is initialized with a selection model on construction, and also contains methods to query or set this selection model. Additionally, &lt;code&gt;JList&lt;/code&gt; provides convenient methods for easily managing the selection. These methods, such as &lt;code&gt;setSelectedIndex&lt;/code&gt; and &lt;code&gt;getSelectedValue&lt;/code&gt;, are cover methods that take care of the details of interacting with the selection model. By default, &lt;code&gt;JList&lt;/code&gt;'s selection model is configured to allow any combination of items to be selected at a time; selection mode &lt;code&gt;MULTIPLE_INTERVAL_SELECTION&lt;/code&gt;. The selection mode can be changed on the selection model directly, or via &lt;code&gt;JList&lt;/code&gt;'s cover method. Responsibility for updating the selection model in response to user gestures lies with the list's &lt;code&gt;ListUI&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JList&lt;/code&gt; 의 선택 상태는 다른 별도의 모델 인 &lt;code&gt;ListSelectionModel&lt;/code&gt; 인스턴스에서 관리합니다 . &lt;code&gt;JList&lt;/code&gt; 는 생성시 선택 모델로 초기화 되며이 선택 모델을 쿼리하거나 설정하는 메서드도 포함되어 있습니다. 또한 &lt;code&gt;JList&lt;/code&gt; 는 선택을 쉽게 관리 할 수있는 편리한 방법을 제공합니다. &lt;code&gt;setSelectedIndex&lt;/code&gt; 및 &lt;code&gt;getSelectedValue&lt;/code&gt; 와 같은 이러한 메소드 는 선택 모델과 상호 작용하는 세부 사항을 처리하는 커버 메소드입니다. 기본적으로 &lt;code&gt;JList&lt;/code&gt; 의 선택 모델은 한 번에 모든 항목 조합을 선택할 수 있도록 구성됩니다. 선택 모드 &lt;code&gt;MULTIPLE_INTERVAL_SELECTION&lt;/code&gt; . 선택 모드는 선택 모델에서 직접 변경하거나 &lt;code&gt;JList&lt;/code&gt; 의 커버 방법을 통해 변경할 수 있습니다 . 사용자 제스처에 대한 응답으로 선택 모델을 업데이트하는 책임은 목록의 &lt;code&gt;ListUI&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9f90ca688127c456774524ecd9188f16470783" translate="yes" xml:space="preserve">
          <source>The semantics for when a CSS style should overide visual attributes defined by an element are not well defined. For example, the html &lt;code&gt;&amp;lt;body bgcolor=red&amp;gt;&lt;/code&gt; makes the body have a red background. But if the html file also contains the CSS rule &lt;code&gt;body { background: blue }&lt;/code&gt; it becomes less clear as to what color the background of the body should be. The current implementation gives visual attributes defined in the element the highest precedence, that is they are always checked before any styles. Therefore, in the previous example the background would have a red color as the body element defines the background color to be red.</source>
          <target state="translated">CSS 스타일이 요소에 의해 정의 된 시각적 속성을 재정의해야하는 경우에 대한 의미가 제대로 정의되지 않았습니다. 예를 들어, html &lt;code&gt;&amp;lt;body bgcolor=red&amp;gt;&lt;/code&gt; 는 본문을 빨간색 배경으로 만듭니다. 그러나 html 파일에 CSS 규칙 &lt;code&gt;body { background: blue }&lt;/code&gt; 도 포함되어 있으면 본문 의 배경 색상이 명확하지 않게됩니다. 현재 구현에서는 요소에 정의 된 시각적 속성에 가장 높은 우선 순위를 부여합니다. 즉, 항상 스타일보다 먼저 확인됩니다. 따라서 이전 예제에서 body 요소가 배경색을 빨간색으로 정의하므로 배경이 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="95202ca438f08b9e0031b9c4bfdeb9b4df852c33" translate="yes" xml:space="preserve">
          <source>The semantics of the List returned by this method become undefined if the backing list (i.e., this List) is</source>
          <target state="translated">지원 목록 (즉,이 목록)이 다음과 같은 경우이 메소드가 리턴 한 목록의 의미가 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="453d2ffd1b3b134c5fd9217f7532df9b822182d8" translate="yes" xml:space="preserve">
          <source>The semantics of the beanName parameter are defined by java.beans.Beans.instantiate.</source>
          <target state="translated">beanName 매개 변수의 의미는 java.beans.Beans.instantiate에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="384632fa38dae55d93e0e907e62e3a2804bb5387" translate="yes" xml:space="preserve">
          <source>The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is</source>
          <target state="translated">지원 목록 (즉,이 목록)이 다음과 같은 경우이 메소드가 리턴 한 목록의 의미가 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="6eb76390f1c14aef2312c3b26cdfb1a9faf1c0d3" translate="yes" xml:space="preserve">
          <source>The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is modified in any way other than via the returned list.</source>
          <target state="translated">지원 목록 (즉,이 목록)이 반환 된 목록을 통하지 않고 다른 방식으로 수정되면이 메소드가 반환 한 목록의 의미가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d20ea275f88276269e77c1a6a3f0a0a12013fb0a" translate="yes" xml:space="preserve">
          <source>The semantics of this method are unspecified if the arguments could not have been produced by an instance of some valid dynamic proxy class containing this invocation handler.</source>
          <target state="translated">이 호출 핸들러를 포함하는 일부 유효한 동적 프록시 클래스의 인스턴스에 의해 인수가 생성 될 수없는 경우이 메소드의 의미는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8513f09b48ac39c6481ad6003d15d1ff8cbf1f1" translate="yes" xml:space="preserve">
          <source>The semantics of this method may differ from those of the other &lt;code&gt;read&lt;/code&gt; methods in several ways. First, any destination image and/or image type set in the &lt;code&gt;ImageReadParam&lt;/code&gt; may be ignored. Second, the usual listener calls are not guaranteed to be made, or to be meaningful if they are. This is because the returned image may not be fully populated with pixel data at the time it is returned, or indeed at any time.</source>
          <target state="translated">이 방법의 의미는 몇 가지면에서 다른 &lt;code&gt;read&lt;/code&gt; 방법 의 의미와 다를 수 있습니다 . 먼저 &lt;code&gt;ImageReadParam&lt;/code&gt; 에 설정된 대상 이미지 및 / 또는 이미지 유형 이 무시 될 수 있습니다. 둘째, 일반적인 청취자 호출이 이루어 지거나 의미가있는 것은 아닙니다. 반환 된 이미지가 반환 될 때나 실제로는 픽셀 데이터로 완전히 채워지지 않을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1cc6107a3ab38aa44b20de1eca06580ad330b25d" translate="yes" xml:space="preserve">
          <source>The sentinel value is chosen so that reflective queries can be made directly against the result value. The sentinel value cannot be confused with a real parameter, since &lt;code&gt;void&lt;/code&gt; is never acceptable as a parameter type. For variable arity invocation modes, the expression &lt;a href=&quot;../class#getComponentType()&quot;&gt;&lt;code&gt;lastParameterType().getComponentType()&lt;/code&gt;&lt;/a&gt; is useful to query the type of the &quot;varargs&quot; parameter.</source>
          <target state="translated">센티넬 값은 결과 값에 대해 직접 반사 쿼리를 만들 수 있도록 선택됩니다. &lt;code&gt;void&lt;/code&gt; 는 매개 변수 유형으로 허용 되지 않으므로 sentinel 값을 실제 매개 변수와 혼동 할 수 없습니다 . 가변 arity 호출 모드의 경우 &lt;a href=&quot;../class#getComponentType()&quot;&gt; &lt;code&gt;lastParameterType().getComponentType()&lt;/code&gt; &lt;/a&gt; 표현식 은 &quot;varargs&quot;매개 변수의 유형을 쿼리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="161693ca410ae026e19d3b93be91d521d736f95e" translate="yes" xml:space="preserve">
          <source>The separator between a keystore name prefix and an entry name. When specified, it applies to all the entries in a domain. Its default value is a space.</source>
          <target state="translated">키 저장소 이름 접 두부와 항목 이름 사이의 구분 기호입니다. 지정하면 도메인의 모든 항목에 적용됩니다. 기본값은 공백입니다.</target>
        </trans-unit>
        <trans-unit id="c33bef4fc18f12b61dd742c406adeaac8d64a82d" translate="yes" xml:space="preserve">
          <source>The sequence may be of arbitrary length but the first four elements are assigned specific meanings, as follows:</source>
          <target state="translated">시퀀스는 임의의 길이 일 수 있지만 처음 4 개 요소에는 다음과 같이 특정 의미가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="fddaff8ebac1c2c5c7b43da5bf7781d174bd01f1" translate="yes" xml:space="preserve">
          <source>The sequence number of the earliest notification still in the buffer.</source>
          <target state="translated">버퍼에 여전히 가장 빠른 알림의 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a4b01bb88787366b6d9e829887a4ae25a588e430" translate="yes" xml:space="preserve">
          <source>The sequence number of the next notification available for querying. This will be the starting sequence number for the next notification query.</source>
          <target state="translated">쿼리에 사용할 수있는 다음 알림의 시퀀스 번호입니다. 다음 알림 쿼리의 시작 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="bf0008ac9d1317707e44c068d027348ed859c00f" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Byte.parseByte&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Byte.parseByte&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="04a5cebfd92c347160af912e87639fade424841a" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Integer.parseInt&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;
 String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음의 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Integer.parseInt&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt; String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f47a3f697e9bed49511091c71b4c3caa8900d5a" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Long.parseLong&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Long.parseLong&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9a8c9c139a21299d680c43bec3c9a7c26de6811f" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;
 Short.parseShort&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;
 String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음의 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt; Short.parseShort&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 시퀀스는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt; String&lt;/code&gt; 의 첫 번째 문자 가 마이너스 부호 이면 결과는 부정됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ed0c9428f6e0126963f745de2465f141332a6026" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Byte.parseByte&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 나오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Byte.parseByte&lt;/code&gt; 메서드로 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c063e5411741f160ae6a46bec35b7a73c1e07d1" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Integer.parseInt&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Integer.parseInt&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7ce5c427a4177226515b1b8cfab424168d32e788" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Long.parseLong&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 &lt;code&gt;Long.parseLong&lt;/code&gt; 메소드에 의해 표시된 기수 (10, 16 또는 8 )로 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4974fa4ef44b513af1028ff49c4b453f94609bd" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Short.parseShort&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 뒤에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Short.parseShort&lt;/code&gt; 메소드에 의해 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="405b55aaa46e13a89f534b404603b82ce083cf31" translate="yes" xml:space="preserve">
          <source>The sequence of numerals in a version number is compared to another such sequence in numerical, pointwise fashion; &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;
 10.0.4&lt;/code&gt; is less than &lt;code&gt;10.1.2&lt;/code&gt;. If one sequence is shorter than another then the missing elements of the shorter sequence are considered to be less than the corresponding elements of the longer sequence; &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;10.0.2&lt;/code&gt; is less than &lt;code&gt;10.0.2.1&lt;/code&gt;.</source>
          <target state="translated">버전 번호의 숫자 시퀀스는 숫자, 포인트 방식으로 다른 시퀀스와 비교됩니다. &lt;em&gt;예를 들어&lt;/em&gt; , &lt;code&gt; 10.0.4&lt;/code&gt; 는 미만이다 &lt;code&gt;10.1.2&lt;/code&gt; . 한 시퀀스가 ​​다른 시퀀스보다 짧으면 더 짧은 시퀀스의 누락 된 요소는 긴 시퀀스의 해당 요소보다 작은 것으로 간주됩니다. &lt;em&gt;예를 들어&lt;/em&gt; , &lt;code&gt;10.0.2&lt;/code&gt; 이 적은보다 &lt;code&gt;10.0.2.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b7e641ecc2ddbeb716b792bb33db3785fdea384" translate="yes" xml:space="preserve">
          <source>The sequence of task executions continues indefinitely until one of the following exceptional completions occur:</source>
          <target state="translated">작업 실행 순서는 다음과 같은 예외적 인 완료 중 하나가 발생할 때까지 무기한 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="e434dd3150cc80ca7cae2f8b8eaeb4038c9e904c" translate="yes" xml:space="preserve">
          <source>The sequence of the candidate locales also corresponds to the runtime resource lookup path (also known as the</source>
          <target state="translated">후보 로케일의 순서는 또한 런타임 자원 검색 경로 (</target>
        </trans-unit>
        <trans-unit id="f7e487534567beaaaf886a79c2a34b214dbcb31b" translate="yes" xml:space="preserve">
          <source>The sequence property will be initialized with a new unique value. These sequence values are allocated in increasing order within a VM.</source>
          <target state="translated">시퀀스 속성은 새로운 고유 값으로 초기화됩니다. 이 시퀀스 값은 VM 내에서 순서대로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="a7cd757d66959c5ea95a29c3e377f5ce005f6f9a" translate="yes" xml:space="preserve">
          <source>The sequential group along the horizontal axis is rendered as a solid blue line. Notice the sequential group is the sum of the children elements it contains.</source>
          <target state="translated">수평 축을 따라 순차적 인 그룹이 파란색 실선으로 렌더링됩니다. 순차 그룹은 포함 된 하위 요소의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="c00ff75511a0de0a28d3c3e6f1b65b2b2cd9a528" translate="yes" xml:space="preserve">
          <source>The serial version of the class does not match that of the class descriptor read from the stream</source>
          <target state="translated">클래스의 직렬 버전이 스트림에서 읽은 클래스 디스크립터의 버전과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb17ac47a0c237bc15ecd3f6d7915bd46810b1f" translate="yes" xml:space="preserve">
          <source>The serialization filter is initialized to the value of &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;&lt;code&gt;ObjectInputFilter.Config.getSerialFilter&lt;/code&gt;&lt;/a&gt; when the &lt;code&gt; ObjectInputStream&lt;/code&gt; is constructed and can be set to a custom filter only once.</source>
          <target state="translated">직렬화 필터는 &lt;code&gt; ObjectInputStream&lt;/code&gt; 이 구성 될 때 &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt; &lt;code&gt;ObjectInputFilter.Config.getSerialFilter&lt;/code&gt; &lt;/a&gt; 의 값으로 초기화되며 사용자 정의 필터로 한 번만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b47e4393e9fad0dd6a3358b5377e4c805ad3c8" translate="yes" xml:space="preserve">
          <source>The serialization filter is initialized to the value of &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;the process-wide filter&lt;/a&gt;.</source>
          <target state="translated">직렬화 필터는 &lt;a href=&quot;objectinputfilter.config#getSerialFilter()&quot;&gt;프로세스 전체 필터&lt;/a&gt; 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d3a14fa4f45c6e41704c2ee36ac6cb02bf7a515" translate="yes" xml:space="preserve">
          <source>The serialization filter, when not &lt;code&gt;null&lt;/code&gt;, is invoked for each object (regular or class) read to reconstruct the root object. See &lt;a href=&quot;#setObjectInputFilter(java.io.ObjectInputFilter)&quot;&gt;&lt;code&gt;setObjectInputFilter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 아닌 경우 직렬화 필터 는 루트 객체를 재구성하기 위해 읽은 각 객체 (일반 또는 클래스)에 대해 호출됩니다. 자세한 내용은 &lt;a href=&quot;#setObjectInputFilter(java.io.ObjectInputFilter)&quot;&gt; &lt;code&gt;setObjectInputFilter&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd73bf37e348582139983df9cefa4606f813c326" translate="yes" xml:space="preserve">
          <source>The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an &lt;a href=&quot;invalidclassexception&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;. A serializable class can declare its own serialVersionUID explicitly by declaring a field named &lt;code&gt;&quot;serialVersionUID&quot;&lt;/code&gt; that must be static, final, and of type &lt;code&gt;long&lt;/code&gt;:</source>
          <target state="translated">직렬화 런타임은 직렬화 가능 오브젝트의 송신자 및 수신자가 직렬화와 호환되는 해당 오브젝트에 대해 클래스를로드했는지 검증하기 위해 직렬화 해제 중에 사용되는 직렬 버전 UID라고하는 버전 번호를 각 직렬화 가능 클래스와 연관시킵니다. 수신자가 해당 송신자의 클래스와 다른 serialVersionUID를 가진 객체에 대한 클래스를로드 한 경우 역 직렬화로 인해 &lt;a href=&quot;invalidclassexception&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; &lt;/a&gt; 이 발생합니다 . 직렬화 가능 클래스는 정적, 최종 및 &lt;code&gt;long&lt;/code&gt; 유형이어야하는 &lt;code&gt;&quot;serialVersionUID&quot;&lt;/code&gt; 라는 필드를 선언하여 고유 한 serialVersionUID를 명시 적으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae097a868679cbc698e55bf19085a91cd00d50c7" translate="yes" xml:space="preserve">
          <source>The serialver tool</source>
          <target state="translated">시리얼 버 도구</target>
        </trans-unit>
        <trans-unit id="72c82fbb03fb7e60a420ba06895a6063d87792bd" translate="yes" xml:space="preserve">
          <source>The server side might use the following variation of this source:</source>
          <target state="translated">서버 측은이 소스의 다음 변형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b7ba8d6780756feb02181d1f3b8e6bc1232ed3" translate="yes" xml:space="preserve">
          <source>The server was able to connect to the output device (or is always connected), but was unable to get a response from the output device.</source>
          <target state="translated">서버가 출력 장치에 연결할 수 있었거나 항상 연결되어 있었지만 출력 장치에서 응답을받을 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="7fc00d2c6bd145d9268cc5b5645d6faef5160f5c" translate="yes" xml:space="preserve">
          <source>The server-side sort control's assigned object identifier is 1.2.840.113556.1.4.473.</source>
          <target state="translated">서버 측 정렬 컨트롤의 할당 된 개체 식별자는 1.2.840.113556.1.4.473입니다.</target>
        </trans-unit>
        <trans-unit id="683960c5bca78c73afa4105fa8def718cb10bbd7" translate="yes" xml:space="preserve">
          <source>The server-side sort response control's assigned object identifier is 1.2.840.113556.1.4.474.</source>
          <target state="translated">서버 측 정렬 응답 제어의 지정된 오브젝트 ID는 1.2.840.113556.1.4.474입니다.</target>
        </trans-unit>
        <trans-unit id="99ea3539e9368c270061c3ac165425c2cc085eda" translate="yes" xml:space="preserve">
          <source>The service class must be one of the service types listed in the class specification. If it is not, &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">서비스 클래스는 클래스 사양에 나열된 서비스 유형 중 하나 여야합니다. 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="339bce1745ff0ddf550af41337f79c273e458f7f" translate="yes" xml:space="preserve">
          <source>The service named has been registered. getService requests for this service may now be made.</source>
          <target state="translated">이름이 지정된 서비스가 등록되었습니다. 이 서비스에 대한 getService 요청이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df31dfe1040963f739d9dbd1f8945217536f695" translate="yes" xml:space="preserve">
          <source>The service named has been revoked. getService requests for this service will no longer be satisfied.</source>
          <target state="translated">이름이 지정된 서비스가 취소되었습니다. 이 서비스에 대한 getService 요청은 더 이상 충족되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2312f997c09c219c1c3cc983985a51f259efd5c0" translate="yes" xml:space="preserve">
          <source>The service principal name is the canonical name of the &lt;code&gt;KerberosPrincipal&lt;/code&gt; supplying the service, that is the KerberosPrincipal represents a Kerberos service principal. This name is treated in a case sensitive manner. An asterisk may appear by itself, to signify any service principal.</source>
          <target state="translated">서비스 주체 이름은 서비스를 제공하는 &lt;code&gt;KerberosPrincipal&lt;/code&gt; 의 정식 이름입니다. 즉, KerberosPrincipal은 Kerberos 서비스 주체를 나타냅니다. 이 이름은 대소 문자를 구분하여 처리됩니다. 서비스 주체를 나타 내기 위해 별표 만 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb5c3ef3ec84e9aaec370cd0ee1bf641ca69144" translate="yes" xml:space="preserve">
          <source>The service provider cannot be loaded.</source>
          <target state="translated">서비스 제공 업체를로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82991bdbc004754a76d1b3ab1788eba153946852" translate="yes" xml:space="preserve">
          <source>The service provider class file has more than one public static no-args method named &quot;&lt;code&gt;provider&lt;/code&gt;&quot;.</source>
          <target state="translated">서비스 공급자 클래스 파일에 &quot; &lt;code&gt;provider&lt;/code&gt; &quot; 라는 공용 정적 인수 없음 메서드가 두 개 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="6747b4a2a337f04bdc6c20288be6a874d897923c" translate="yes" xml:space="preserve">
          <source>The service provider classes are intended to be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code.</source>
          <target state="translated">서비스 제공 업체 클래스는 가볍고 빠르게로드 할 수 있도록 고안되었습니다. 이러한 인터페이스의 구현은 다른 클래스와 기본 코드에 대한 복잡한 종속성을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3138211b8863e1d6bc3cf853dd276be24d5ca1e" translate="yes" xml:space="preserve">
          <source>The service provider classes should be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code. The usual pattern for more complex services is to register a lightweight proxy for the heavyweight service.</source>
          <target state="translated">서비스 공급자 클래스는 가볍고 빠르게로드되어야합니다. 이러한 인터페이스의 구현은 다른 클래스와 네이티브 코드에 대한 복잡한 종속성을 피해야합니다. 더 복잡한 서비스의 일반적인 패턴은 무거운 서비스에 대해 경량 프록시를 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f444b1559da4e9d86d6d648069e2d0a6eeb225b7" translate="yes" xml:space="preserve">
          <source>The service provider classes should be to be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code. The usual pattern for more complex services is to register a lightweight proxy for the heavyweight service.</source>
          <target state="translated">서비스 제공 업체 클래스는 가볍고 빠르게로드되어야합니다. 이러한 인터페이스의 구현은 다른 클래스와 기본 코드에 대한 복잡한 종속성을 피해야합니다. 보다 복잡한 서비스의 일반적인 패턴은 헤비급 서비스를위한 경량 프록시를 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="608ee288ee27216e454b0a3a685e8712eeefa3ae" translate="yes" xml:space="preserve">
          <source>The service provider declares a provider method and it fails by returning &lt;code&gt;null&lt;/code&gt; or throwing an exception.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하고 &lt;code&gt;null&lt;/code&gt; 을 반환 하거나 예외를 throw하여 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="76904639c98eb74089f8e96e6ac7feed61ec1c9f" translate="yes" xml:space="preserve">
          <source>The service provider declares a public static no-args method named &quot;provider&quot; with a return type that is not assignable to the service's interface or class.</source>
          <target state="translated">서비스 공급자는 서비스의 인터페이스 또는 클래스에 할당 할 수없는 반환 유형을 사용하여 &quot;provider&quot;라는 공용 정적 인수 없음 메서드를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="e899262ca235e8c71b29084806db99b3aa3bd13b" translate="yes" xml:space="preserve">
          <source>The service provider does not declare a provider method, and either it is not assignable to the service's interface/class or does not have a provider constructor.</source>
          <target state="translated">서비스 공급자는 공급자 메서드를 선언하지 않으며 서비스의 인터페이스 / 클래스에 할당 할 수 없거나 공급자 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cd0a169a020016b59c9011b24d88a2afce8a08a" translate="yes" xml:space="preserve">
          <source>The service provider does not declare a provider method, and its provider constructor fails by throwing an exception.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하지 않고 공급자 생성자가 예외를 throw하여 실패합니다.</target>
        </trans-unit>
        <trans-unit id="39722a75ad6a5d7f9c535e0c0bae2bb029dadcb9" translate="yes" xml:space="preserve">
          <source>The service provider for &lt;code&gt;ctx&lt;/code&gt; uses a state factory to obtain the state of &lt;code&gt;printer&lt;/code&gt; for binding into its namespace. A state factory for the &lt;code&gt;Printer&lt;/code&gt; type object might return a more compact object for storage in the naming system.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 의 서비스 공급자 는 상태 팩토리를 사용하여 네임 스페이스에 바인딩하기위한 &lt;code&gt;printer&lt;/code&gt; 상태를 얻습니다 . &lt;code&gt;Printer&lt;/code&gt; 유형 개체 의 상태 팩토리 는 이름 지정 시스템에 저장하기 위해 더 컴팩트 한 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2f45b96a8af4cfac898c3be7b94db00df1c82f" translate="yes" xml:space="preserve">
          <source>The service provider instance is chosen as follows:</source>
          <target state="translated">서비스 공급자 인스턴스는 다음과 같이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="38127cd4aa0815400585c455d9b08bc1a04388ab" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageInputStream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageInputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 .</target>
        </trans-unit>
        <trans-unit id="1f43b817f684f623aff5dad130484f2da8b725fa" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageInputStream&lt;/code&gt;s. For more information on service provider interfaces, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageInputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 . 서비스 제공자 인터페이스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a256fe03be1948fb7463bd5c25f91b70d8bb367" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageOutputStream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageOutputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 .</target>
        </trans-unit>
        <trans-unit id="baa871f87fb50e99d06890cf145ed5a968d9d468" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageOutputStream&lt;/code&gt;s. For more information on service provider interfaces, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageOutputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 . 서비스 제공자 인터페이스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="237770f3170d2d602f3c067509f29ea8083b1e81" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageReader&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageReader&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)</target>
        </trans-unit>
        <trans-unit id="45ed743b0330766c9e4bf1587f45b4bca8c763dd" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageReader&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageReader&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI) 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdf130a89b8ecdd0fc56c8841a6256d234f7b1d5" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageTranscoder&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageTranscoder&lt;/code&gt; 의 SPI (Service Provider Interface)입니다 .</target>
        </trans-unit>
        <trans-unit id="4e56bbbc7919ab4d22d10e83ee3380885f3821d8" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageTranscoder&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageTranscoder&lt;/code&gt; 의 SPI (Service Provider Interface)입니다 . 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="967704522c5f16add19f7f3f928885832f2dc066" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageWriter&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageWriter&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)</target>
        </trans-unit>
        <trans-unit id="59d3345b89b02c0a3b5eb368b40b37277fb4680d" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageWriter&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageWriter&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI) 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d312587539e81ed58f42177944ea87bb18494524" translate="yes" xml:space="preserve">
          <source>The service provider package allows different implementations to be plugged in dynamically. These different implementations include those for the &lt;em&gt;initial context&lt;/em&gt;, and implementations for contexts that can be reached from the initial context.</source>
          <target state="translated">서비스 제공자 패키지를 사용하면 다양한 구현을 동적으로 연결할 수 있습니다. 이러한 다른 구현에는 &lt;em&gt;초기 컨텍스트에&lt;/em&gt; 대한 구현과 &lt;em&gt;초기 컨텍스트&lt;/em&gt; 에서 도달 할 수있는 &lt;em&gt;컨텍스트에&lt;/em&gt; 대한 구현이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a98e2ef3c24a3f8bc1edb7be60c8b0ba1c2ff65d" translate="yes" xml:space="preserve">
          <source>The service provider package provides support for implementors of the &lt;code&gt;javax.naming.Context.lookup()&lt;/code&gt; method and related methods to return Java objects that are natural and intuitive for the Java programmer. For example, when looking up a printer name from the directory, it is natural for you to expect to get back a printer object on which to operate.</source>
          <target state="translated">서비스 제공자 패키지는 &lt;code&gt;javax.naming.Context.lookup()&lt;/code&gt; 메소드 의 구현 자 및 관련 메소드를 지원하여 Java 프로그래머에게 자연스럽고 직관적 인 Java 오브젝트를 리턴합니다. 예를 들어, 디렉토리에서 프린터 이름을 검색 할 때 작동 할 프린터 개체를 되 찾을 것으로 예상하는 것은 당연합니다.</target>
        </trans-unit>
        <trans-unit id="81e08ce13e4bc1e787c03d053631be4ab8564f41" translate="yes" xml:space="preserve">
          <source>The service provider.</source>
          <target state="translated">서비스 제공자.</target>
        </trans-unit>
        <trans-unit id="37af36e76b9cf4fce8d917861e80abd5df5d0dad" translate="yes" xml:space="preserve">
          <source>The service type &lt;code&gt;Provider&lt;/code&gt; is reserved for use by the security framework. Services of this type cannot be added, removed, or modified by applications. The following attributes are automatically placed in each Provider object:</source>
          <target state="translated">서비스 유형 &lt;code&gt;Provider&lt;/code&gt; 는 보안 프레임 워크에서 사용하도록 예약되어 있습니다. 이 유형의 서비스는 응용 프로그램에서 추가, 제거 또는 수정할 수 없습니다. 다음 속성은 각 제공자 오브젝트에 자동으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="b78ad8bf21cd550da7623c37d70d45b0515dd961" translate="yes" xml:space="preserve">
          <source>The service type is in a &lt;code&gt;spi&lt;/code&gt; subpackage as it may be packaged in a module separate from the resource bundle providers. For example, the service for a resource bundle named &lt;code&gt;com.example.app.MyResources&lt;/code&gt; must be &lt;code&gt;com.example.app.spi.MyResourcesProvider&lt;/code&gt;:</source>
          <target state="translated">서비스 유형은 리소스 번들 공급자와는 별도의 모듈로 패키지화 될 수 있으므로 &lt;code&gt;spi&lt;/code&gt; 하위 패키지에 있습니다. 예를 들어, 자원 번들의 이름에 대한 서비스 &lt;code&gt;com.example.app.MyResources&lt;/code&gt; 는 해야 &lt;code&gt;com.example.app.spi.MyResourcesProvider&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="462d23cf2b980e00ea9308bfd5172025ae0208b0" translate="yes" xml:space="preserve">
          <source>The service will throw a &lt;code&gt;PrintException&lt;/code&gt; if the cancellation did not succeed. A job which has not yet been submitted for printing should throw this exception. Cancelling an already successfully cancelled Print Job is not considered an error and will always succeed.</source>
          <target state="translated">취소가 성공하지 못한 경우 서비스는 &lt;code&gt;PrintException&lt;/code&gt; 을 발생시킵니다. 아직 인쇄를 위해 제출되지 않은 작업은이 예외를 발생시켜야합니다. 이미 성공적으로 취소 된 인쇄 작업을 취소하는 것은 오류로 간주되지 않으며 항상 성공합니다.</target>
        </trans-unit>
        <trans-unit id="3e064776c20c4d1bdfca5a291b86a1d978043bc3" translate="yes" xml:space="preserve">
          <source>The service will throw a PrintException if the cancellation did not succeed. A job which has not yet been submitted for printing should throw this exception. Cancelling an already successfully cancelled Print Job is not considered an error and will always succeed.</source>
          <target state="translated">취소에 실패하면 서비스에서 PrintException이 발생합니다. 아직 인쇄를 위해 제출되지 않은 작업은이 예외를 발생시켜야합니다. 이미 성공적으로 취소 된 인쇄 작업을 취소하는 것은 오류로 간주되지 않으며 항상 성공합니다.</target>
        </trans-unit>
        <trans-unit id="7d9cc09e14462c6647d9a6c4a38c382e9755d701" translate="yes" xml:space="preserve">
          <source>The session has been locked/unlocked.</source>
          <target state="translated">세션이 잠금 / 잠금 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="00fd623a86061c4531c2be6803ace8d3954aef8e" translate="yes" xml:space="preserve">
          <source>The session was connected/disconnected to the console terminal.</source>
          <target state="translated">세션이 콘솔 터미널에 연결 / 연결 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3cfa1527f162db4e68a86de541d7adab335ef3f" translate="yes" xml:space="preserve">
          <source>The session was connected/disconnected to the remote terminal.</source>
          <target state="translated">세션이 원격 터미널에 연결 / 연결 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="5c8bbfd75efcc20ccff9db728df43aa79026640f" translate="yes" xml:space="preserve">
          <source>The set includes a dependency on &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; when this module is not named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;. If this module is an automatic module then it does not have a dependency on any module other than &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;.</source>
          <target state="translated">이 모듈의 이름이 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 가 아닌 경우 세트에는 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 에 대한 종속성이 포함됩니다 . 이 모듈이 자동 모듈 인 경우 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 이외의 모듈에 대한 종속성이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b64d278b964f5fb0f174b56402a1688783011c63" translate="yes" xml:space="preserve">
          <source>The set is &lt;a href=&quot;#ksc&quot;&gt;safe&lt;/a&gt; for use by multiple concurrent threads.</source>
          <target state="translated">이 집합은 여러 동시 스레드에서 사용하기에 &lt;a href=&quot;#ksc&quot;&gt;안전&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="939369237a0093ae8b76203fbafeae8ecee1df1c" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own &lt;code&gt;remove&lt;/code&gt; operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt;, and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 반복자 자신의 &lt;code&gt;remove&lt;/code&gt; 작업을 제외하고 집합에 대한 반복이 진행되는 동안 맵이 수정되면 반복 결과는 정의되지 않습니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 오퍼레이션을 통해 맵에서 해당 맵핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="08401de134cf52abcaf1f8af2a1683d7c74313a4" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own &lt;code&gt;remove&lt;/code&gt; operation, or through the &lt;code&gt;setValue&lt;/code&gt; operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 반복자 자신의 &lt;code&gt;remove&lt;/code&gt; 작업 또는 반복자가 반환 한 맵 항목 의 &lt;code&gt;setValue&lt;/code&gt; 작업을 제외하고 집합에 대한 반복이 진행되는 동안 맵이 수정되면 반복 결과가 정의되지 않습니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 작업을 통해 맵에서 해당 매핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="852ef9de08250d48c0d0fc367b3fbed7a9bf4099" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 작업을 통해 맵에서 해당 매핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="335b178dce95c35bddb6f9a6dfbb5dbd684f0d11" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt;, and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 오퍼레이션을 통해 맵에서 해당 맵핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6f4f2cfd47ef65402bf2cd171ee3694a2946949e" translate="yes" xml:space="preserve">
          <source>The set is created the first time this method is called, and returned in response to all subsequent calls. No synchronization is performed, so there is a slight chance that multiple calls to this method will not all return the same set.</source>
          <target state="translated">이 메소드는이 메소드가 처음 호출 될 때 작성되며 모든 후속 호출에 대한 응답으로 리턴됩니다. 동기화가 수행되지 않으므로이 메소드에 대한 여러 호출이 모두 동일한 세트를 리턴하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c6dbb0140fcb03f42d68d9b039f3ccf70fab2f5" translate="yes" xml:space="preserve">
          <source>The set of Unicode locale keys, or the empty set if this locale has no Unicode locale keywords.</source>
          <target state="translated">유니 코드 로캘 키 집합이거나이 로캘에 유니 코드 로캘 키워드가없는 경우 빈 집합입니다.</target>
        </trans-unit>
        <trans-unit id="420b44f1196d7d8713b274baff300cd1830c3000" translate="yes" xml:space="preserve">
          <source>The set of access modes that specify how a variable, referenced by a VarHandle, is accessed.</source>
          <target state="translated">VarHandle에서 참조하는 변수에 액세스하는 방법을 지정하는 액세스 모드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="03d9f1bf0b7313c94bfc617aaf5a0c81cfb6185f" translate="yes" xml:space="preserve">
          <source>The set of all legal URI characters consists of the</source>
          <target state="translated">모든 유효한 URI 문자 세트는</target>
        </trans-unit>
        <trans-unit id="6452b41f9aa8aa9467f2200dc381d1cdeab705b6" translate="yes" xml:space="preserve">
          <source>The set of all module references that this finder locates</source>
          <target state="translated">이 파인더가 찾는 모든 모듈 참조 세트</target>
        </trans-unit>
        <trans-unit id="621a29c69b103747e0b5a4f9c4564c47401600b9" translate="yes" xml:space="preserve">
          <source>The set of attributes.</source>
          <target state="translated">속성 세트</target>
        </trans-unit>
        <trans-unit id="3f9639f8c60c46f82dff9817fb5e46940cb7b600" translate="yes" xml:space="preserve">
          <source>The set of available chronologies can be extended by applications. Adding a new calendar system requires the writing of an implementation of &lt;code&gt;Chronology&lt;/code&gt;, &lt;code&gt;ChronoLocalDate&lt;/code&gt; and &lt;code&gt;Era&lt;/code&gt;. The majority of the logic specific to the calendar system will be in the &lt;code&gt;ChronoLocalDate&lt;/code&gt; implementation. The &lt;code&gt;Chronology&lt;/code&gt; implementation acts as a factory.</source>
          <target state="translated">사용 가능한 연대기 세트는 애플리케이션에 의해 확장 될 수 있습니다. 새 달력 시스템을 추가하려면 &lt;code&gt;Chronology&lt;/code&gt; , &lt;code&gt;ChronoLocalDate&lt;/code&gt; 및 &lt;code&gt;Era&lt;/code&gt; 를 구현해야합니다 . 달력 시스템과 관련된 대부분의 논리는 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 구현에 있습니다. &lt;code&gt;Chronology&lt;/code&gt; 구현은 공장 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="f2e9447eb9ee970654c805a676dce29fdcfb735b" translate="yes" xml:space="preserve">
          <source>The set of bindings used to create the keymap is fetched from the UIManager using a key formed by combining the &lt;a href=&quot;#getPropertyPrefix()&quot;&gt;&lt;code&gt;getPropertyPrefix()&lt;/code&gt;&lt;/a&gt; method and the string &lt;code&gt;.keyBindings&lt;/code&gt;. The type is expected to be &lt;code&gt;JTextComponent.KeyBinding[]&lt;/code&gt;.</source>
          <target state="translated">키맵을 만드는 데 사용되는 바인딩 집합은 &lt;a href=&quot;#getPropertyPrefix()&quot;&gt; &lt;code&gt;getPropertyPrefix()&lt;/code&gt; &lt;/a&gt; 메서드와 문자열 &lt;code&gt;.keyBindings&lt;/code&gt; 를 결합하여 형성된 키를 사용하여 UIManager에서 가져옵니다 . 유형은 &lt;code&gt;JTextComponent.KeyBinding[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="681a49f0545cead8f88402e7d9a0b8bf02da8310" translate="yes" xml:space="preserve">
          <source>The set of categories supported by this class is limited to the following standard Image I/O service types:</source>
          <target state="translated">이 클래스에서 지원하는 범주 집합은 다음 표준 이미지 I / O 서비스 유형으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b989013791c04777bdc8434807fe06cb2e6445b2" translate="yes" xml:space="preserve">
          <source>The set of classes that make up the package may implement a particular specification and if so the specification title, version number, and vendor strings identify that specification. An application can ask if the package is compatible with a particular version, see the &lt;a href=&quot;package#isCompatibleWith-java.lang.String-&quot;&gt;&lt;code&gt;isCompatibleWith&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">패키지를 구성하는 클래스 세트는 특정 사양을 구현할 수 있으므로 사양 제목, 버전 번호 및 공급 업체 문자열이 해당 사양을 식별합니다. 응용 프로그램은 패키지가 특정 버전과 호환되는지 묻습니다 . 자세한 내용은 &lt;a href=&quot;package#isCompatibleWith-java.lang.String-&quot;&gt; &lt;code&gt;isCompatibleWith&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e76b0b3c09cccc2eda6d0f3d42ddad87d8c8d18" translate="yes" xml:space="preserve">
          <source>The set of classes that make up the run-time package may implement a particular specification. The specification title, version, and vendor (indicating the owner/maintainer of the specification) can be provided when the &lt;code&gt;Package&lt;/code&gt; is defined. An application can ask if the &lt;code&gt;Package&lt;/code&gt; is compatible with a particular specification version by using the &lt;a href=&quot;#isCompatibleWith(java.lang.String)&quot;&gt;&lt;code&gt;Package.isCompatibleWith(String)&lt;/code&gt;&lt;/a&gt; method. In addition, information about the actual classes that make up the run-time package can be provided when the Package is defined. This information consists of an implementation title, version, and vendor (indicating the supplier of the classes).</source>
          <target state="translated">런타임 패키지를 구성하는 클래스 집합은 특정 사양을 구현할 수 있습니다. &lt;code&gt;Package&lt;/code&gt; 를 정의 할 때 사양 제목, 버전 및 공급 업체 (사양의 소유자 / 관리자를 나타냄)를 제공 할 수 있습니다 . 애플리케이션은 &lt;a href=&quot;#isCompatibleWith(java.lang.String)&quot;&gt; &lt;code&gt;Package.isCompatibleWith(String)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 &lt;code&gt;Package&lt;/code&gt; 가 특정 사양 버전과 호환되는지 물어볼 수 있습니다 . 또한 패키지 정의시 런타임 패키지를 구성하는 실제 클래스에 대한 정보를 제공 할 수 있습니다. 이 정보는 구현 제목, 버전 및 공급 업체 (클래스 공급자를 나타냄)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd487059260b770e35e4c25b3c8267f64420d5bc" translate="yes" xml:space="preserve">
          <source>The set of defaults a particular look and feel supports is defined and documented by that look and feel. In addition, each look and feel, or &lt;code&gt;ComponentUI&lt;/code&gt; provided by a look and feel, may access the defaults at different times in their life cycle. Some look and feels may aggressively look up defaults, so that changing a default may not have an effect after installing the look and feel. Other look and feels may lazily access defaults so that a change to the defaults may effect an existing look and feel. Finally, other look and feels might not configure themselves from the defaults table in any way. None-the-less it is usually the case that a look and feel expects certain defaults, so that in general a &lt;code&gt;ComponentUI&lt;/code&gt; provided by one look and feel will not work with another look and feel.</source>
          <target state="translated">특정 룩앤필이 지원하는 기본값 세트는 해당 룩앤필에 의해 정의되고 문서화됩니다. 또한 각 룩앤필 또는 룩앤필에서 제공하는 &lt;code&gt;ComponentUI&lt;/code&gt; 는 수명주기의 다른 시간에 기본값에 액세스 할 수 있습니다. 일부 룩앤필은 기본값을 적극적으로 조회 할 수 있으므로 룩앤필을 설치 한 후 기본값을 변경해도 효과가 없을 수 있습니다. 다른 모양과 느낌은 기본값에 느리게 액세스 할 수 있으므로 기본값을 변경하면 기존 모양과 느낌에 영향을 미칠 수 있습니다. 마지막으로, 다른 룩앤필은 어떤 방식 으로든 기본값 테이블에서 자체적으로 구성되지 않을 수 있습니다. 그럼에도 불구하고 일반적으로 룩앤필은 특정 기본값을 예상하므로 일반적 으로 한 룩앤필에서 제공 하는 &lt;code&gt;ComponentUI&lt;/code&gt; 는 다른 룩앤필에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8566d5bad5a6af80ccaae4ebc526f12877ada443" translate="yes" xml:space="preserve">
          <source>The set of delimiters (the characters that separate tokens) may be specified either at creation time or on a per-token basis.</source>
          <target state="translated">구분자 세트 (토큰을 분리하는 문자)는 작성시 또는 토큰별로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cfc5f58aa65a6eb138573039e7e6c8ed576bdaf" translate="yes" xml:space="preserve">
          <source>The set of destination bands to be used, as an array of &lt;code&gt;int&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 의 배열로 사용할 대상 밴드 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="7bdff17e6129a79d93316f1c821db4d8f82ede91" translate="yes" xml:space="preserve">
          <source>The set of destination bands to be used, as an array of &lt;code&gt;int&lt;/code&gt;s. By default, the value is &lt;code&gt;null&lt;/code&gt;, indicating all destination bands should be written in order.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 배열로서 사용되는 목적지 밴드 세트입니다 . 기본적으로 값은 &lt;code&gt;null&lt;/code&gt; 이며 모든 대상 밴드를 순서대로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b084606f5dbb7234dbaaff078b54b1db5148b15" translate="yes" xml:space="preserve">
          <source>The set of elements that can occur inside the element</source>
          <target state="translated">요소 내부에서 발생할 수있는 요소 집합</target>
        </trans-unit>
        <trans-unit id="b6dca056975449aabae25e6f632010d1fc2e0826" translate="yes" xml:space="preserve">
          <source>The set of elements that must not occur inside the element</source>
          <target state="translated">요소 내부에 있으면 안되는 요소 집합</target>
        </trans-unit>
        <trans-unit id="729a1180bc7c2901cd889e8f040bc5045cacfb92" translate="yes" xml:space="preserve">
          <source>The set of events may include additional implementation specific event that are not defined by the enum &lt;a href=&quot;standardwatcheventkinds&quot;&gt;&lt;code&gt;StandardWatchEventKinds&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이벤트 세트에는 열거 형 &lt;a href=&quot;standardwatcheventkinds&quot;&gt; &lt;code&gt;StandardWatchEventKinds&lt;/code&gt; 에&lt;/a&gt; 의해 정의되지 않은 추가 구현 특정 이벤트가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c728dd3ce97aa1a197697a57af717e73be26f0b" translate="yes" xml:space="preserve">
          <source>The set of extension keys, or the empty set if this locale has no extensions.</source>
          <target state="translated">확장 키 세트 또는이 로케일에 확장이없는 경우 비어있는 세트.</target>
        </trans-unit>
        <trans-unit id="1ca105b2eec11893f8655aa15ad8f33d78fa091c" translate="yes" xml:space="preserve">
          <source>The set of formats may differ according to the particular images being read or written; this method should indicate all the additional formats supported by the plug-in under any circumstances.</source>
          <target state="translated">형식 세트는 읽거나 쓰는 특정 이미지에 따라 다를 수 있습니다. 이 방법은 어떤 상황에서도 플러그인이 지원하는 모든 추가 형식을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6298735c68384e5ce50faeb99e64508afa7e2cb" translate="yes" xml:space="preserve">
          <source>The set of icons and colors used by &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; can be configured using the various setter methods. The value for each property is initialized from the defaults table. When the look and feel changes (&lt;code&gt;updateUI&lt;/code&gt; is invoked), any properties that have a value of type &lt;code&gt;UIResource&lt;/code&gt; are refreshed from the defaults table. The following table lists the mapping between &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; property and defaults table key:</source>
          <target state="translated">&lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; 에서 사용하는 아이콘 및 색상 세트 는 다양한 setter 메소드를 사용하여 구성 할 수 있습니다. 각 속성의 값은 기본값 테이블에서 초기화됩니다. 룩앤필이 변경되면 ( &lt;code&gt;updateUI&lt;/code&gt; 가 호출 됨) &lt;code&gt;UIResource&lt;/code&gt; 유형의 값을 가진 모든 특성이 기본값 테이블에서 새로 고쳐집니다. 다음 표에는 &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; 속성과 기본값 테이블 키 간의 매핑이 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3d89520f73d19bfe68e399e47cbe902639a37fe" translate="yes" xml:space="preserve">
          <source>The set of observable modules at both compile-time and run-time is determined by searching several different paths, and also by searching the compiled modules built in to the environment. The search order is as follows:</source>
          <target state="translated">컴파일 타임과 런타임 모두에서 관찰 가능한 모듈 세트는 여러 다른 경로를 검색하고 환경에 내장 된 컴파일 된 모듈을 검색하여 결정됩니다. 검색 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d0d29b95d763e2af0d05f2e532dc0d00a275aa0" translate="yes" xml:space="preserve">
          <source>The set of packages in the module are accumulated by the &lt;code&gt;
 Builder&lt;/code&gt; as the &lt;a href=&quot;#exports(java.lang.String)&quot;&gt;&lt;code&gt;exports&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#opens(java.lang.String)&quot;&gt;&lt;code&gt;opens&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#packages(java.util.Set)&quot;&gt;&lt;code&gt;packages&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#provides(java.lang.String,java.util.List)&quot;&gt;&lt;code&gt;provides&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#mainClass(java.lang.String)&quot;&gt;&lt;code&gt;mainClass&lt;/code&gt;&lt;/a&gt; methods are invoked.</source>
          <target state="translated">모듈의 패키지 세트가 축적된다 &lt;code&gt; Builder&lt;/code&gt; 는 AS &lt;a href=&quot;#exports(java.lang.String)&quot;&gt; &lt;code&gt;exports&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#opens(java.lang.String)&quot;&gt; &lt;code&gt;opens&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#packages(java.util.Set)&quot;&gt; &lt;code&gt;packages&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#provides(java.lang.String,java.util.List)&quot;&gt; &lt;code&gt;provides&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mainClass(java.lang.String)&quot;&gt; &lt;code&gt;mainClass&lt;/code&gt; 의&lt;/a&gt; 방법은 호출된다.</target>
        </trans-unit>
        <trans-unit id="af1c485e3af079d0e0b924f990daf5f80d7e2329" translate="yes" xml:space="preserve">
          <source>The set of packages in the module is derived from the non-directory entries in the JAR file that have names ending in &quot;&lt;code&gt;.class&lt;/code&gt;&quot;. A candidate package name is derived from the name using the characters up to, but not including, the last forward slash. All remaining forward slashes are replaced with dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;). If the resulting string is a legal package name then it is assumed to be a package name. For example, if the JAR file contains the entry &quot;&lt;code&gt;p/q/Foo.class&lt;/code&gt;&quot; then the package name derived is &quot;&lt;code&gt;p.q&lt;/code&gt;&quot;.</source>
          <target state="translated">모듈의 패키지 세트는 이름이 &quot; &lt;code&gt;.class&lt;/code&gt; &quot;로 끝나는 JAR 파일의 비 디렉토리 항목에서 파생됩니다 . 후보 패키지 이름은 마지막 슬래시를 포함하지 않는 문자를 사용하여 이름에서 파생됩니다. 나머지 모든 슬래시는 점 ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; )으로 대체됩니다 . 결과 문자열이 올바른 패키지 이름이면 패키지 이름으로 간주됩니다. 예를 들어, JAR 파일에 &quot; &lt;code&gt;p/q/Foo.class&lt;/code&gt; &quot; 항목이 포함 된 경우 파생 된 패키지 이름은 &quot; &lt;code&gt;p.q&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="bb27f124976a9cb1da8caffebba927a6c5a0a2ee" translate="yes" xml:space="preserve">
          <source>The set of packages includes all exported and open packages, as well as the packages of any service providers, and the package for the main class.</source>
          <target state="translated">패키지 세트에는 모든 내 보낸 패키지와 열려있는 패키지는 물론 서비스 공급자의 패키지와 기본 클래스 용 패키지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="10d94f3aa7e712fbe40291f913b08a2062951f72" translate="yes" xml:space="preserve">
          <source>The set of parameters defined here may not include all aspects of reverberation as specified by some systems. For example, the Midi Manufacturer's Association (MMA) has an Interactive Audio Special Interest Group (IASIG), which has a 3-D Working Group that has defined a Level 2 Spec (I3DL2). I3DL2 supports filtering of reverberation and control of reverb density. These properties are not included in the JavaSound 1.0 definition of a reverb control. In such a case, the implementing system should either extend the defined reverb control to include additional parameters, or else interpret the system's additional capabilities in a way that fits the model described here.</source>
          <target state="translated">여기에 정의 된 파라미터 세트는 일부 시스템에 의해 지정된 잔향의 모든 측면을 포함하지 않을 수 있습니다. 예를 들어 MMA (Midi Manufacturer 's Association)에는 IASL2 (Interactive Audio Special Interest Group)가 있으며,이 그룹에는 I2DL2 (Level 2 Spec)를 정의한 3D 작업 그룹이 있습니다. I3DL2는 잔향 필터링 및 잔향 밀도 제어를 지원합니다. 이러한 속성은 리버브 컨트롤의 JavaSound 1.0 정의에 포함되어 있지 않습니다. 이 경우 구현 시스템은 정의 된 리버브 컨트롤을 확장하여 추가 파라미터를 포함 시키거나 여기에 설명 된 모델에 맞는 방식으로 시스템의 추가 기능을 해석해야합니다.</target>
        </trans-unit>
        <trans-unit id="68d403ff4ac7d3e26edbaf2a349d84bb408ad098" translate="yes" xml:space="preserve">
          <source>The set of permissions evaluated is a function of whether the ProtectionDomain was constructed with a static set of permissions or it was bound to a dynamically mapped set of permissions.</source>
          <target state="translated">평가 된 권한 집합은 ProtectionDomain이 정적 권한 집합으로 구성되었는지 또는 동적으로 매핑 된 권한 집합에 바인딩되었는지 여부의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="0b9b26c8c7dd24de7fa7e0a2e0ee1b1f709f4d4b" translate="yes" xml:space="preserve">
          <source>The set of permissions granted to the principal is then calculated using the simple rule that individual permissions always override the group permissions. That is, the principal's individual negative permission set (specific denial of permissions) overrides the group positive permission set, and the principal's individual positive permission set overrides the group negative permission set.</source>
          <target state="translated">그런 다음 보안 주체에게 부여 된 권한 집합은 개별 권한이 항상 그룹 권한보다 우선한다는 간단한 규칙을 사용하여 계산됩니다. 즉, 주체의 개별 부정적 권한 집합 (특정 권한 거부)이 그룹 긍정적 권한 집합을 재정의하고 주체의 개별 긍정적 인 권한 집합이 그룹 부정적 권한 집합을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="7c5293b4016e691dbff48573988eed608f1e59b6" translate="yes" xml:space="preserve">
          <source>The set of root modules at compile-time is usually the set of modules being compiled. At run-time, the set of root modules is usually the application module specified to the 'java' launcher. When compiling code in the unnamed module, or at run-time when the main application class is loaded from the class path, then the default set of root modules is implementation specific. In the JDK the default set of root modules contains every module that is observable on the upgrade module path or among the system modules, and that exports at least one package without qualification.</source>
          <target state="translated">컴파일 타임에 루트 모듈 세트는 일반적으로 컴파일되는 모듈 세트입니다. 런타임시 루트 모듈 세트는 일반적으로 'java'실행기에 지정된 애플리케이션 모듈입니다. 이름이 지정되지 않은 모듈에서 코드를 컴파일 할 때 또는 기본 애플리케이션 클래스가 클래스 경로에서로드되는 런타임에 루트 모듈의 기본 세트는 구현에 따라 다릅니다. JDK에서 기본 루트 모듈 세트에는 업그레이드 모듈 경로 또는 시스템 모듈 사이에서 관찰 할 수 있고 자격없이 하나 이상의 패키지를 내보내는 모든 모듈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c855c2b33fa2f72b9413d964ffae18f1b08660a6" translate="yes" xml:space="preserve">
          <source>The set of root modules, whose names are the initial input to this algorithm, is determined in an implementation specific manner. The set of root modules may include automatic modules.</source>
          <target state="translated">이름이이 알고리즘에 대한 초기 입력 인 루트 모듈 세트는 구현 특정 방식으로 결정됩니다. 루트 모듈 세트에는 자동 모듈이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5e4eed3c1a6ad50555dc5a120636aac05d2d14" translate="yes" xml:space="preserve">
          <source>The set of source bands to be read and destination bands to be written is determined by calling &lt;code&gt;getSourceBands&lt;/code&gt; and &lt;code&gt;getDestinationBands&lt;/code&gt; on the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;. If the lengths of the arrays returned by these methods differ, the set of source bands contains an index larger that the largest available source index, or the set of destination bands contains an index larger than the largest legal destination index, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">읽을 소스 밴드 세트와 기록 할 대상 밴드 는 제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에서 &lt;code&gt;getSourceBands&lt;/code&gt; 및 &lt;code&gt;getDestinationBands&lt;/code&gt; 를 호출하여 결정됩니다 . 이러한 메소드에 의해 리턴 된 배열의 길이가 다른 경우, 소스 밴드 세트에 사용 가능한 가장 큰 소스 인덱스보다 큰 인덱스가 포함되거나 목적지 밴드 세트가 가장 큰 유효한 대상 인덱스보다 큰 인덱스를 포함하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6c7711952ed69b023e8f9dad86209b75e9faa4e" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; date and time fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 및 시간 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="17f958194f63b45fb85cee1d1ff860e19a4ebff9" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; date fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 필드를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="7b87b275acd5b0bbff5b52b9d09fd971743dbb82" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 필드를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="0cd5b52cb97e9595d03bfd112aa6100ad3af1552" translate="yes" xml:space="preserve">
          <source>The set of supported units is defined by the chronology and normally includes all &lt;code&gt;ChronoUnit&lt;/code&gt; date units except &lt;code&gt;FOREVER&lt;/code&gt;.</source>
          <target state="translated">지원되는 단위 집합은 시간 순서대로 정의되며 일반적으로 &lt;code&gt;FOREVER&lt;/code&gt; 를 제외한 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 날짜 단위를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="cf91e64de9db3a085379dbaade3e6f6c15d84327" translate="yes" xml:space="preserve">
          <source>The set of supported units is defined by the chronology and normally includes all &lt;code&gt;ChronoUnit&lt;/code&gt; units except &lt;code&gt;FOREVER&lt;/code&gt;.</source>
          <target state="translated">지원되는 단위 집합은 시간 순서대로 정의되며 일반적으로 &lt;code&gt;FOREVER&lt;/code&gt; 를 제외한 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 단위를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="a8ac334c4e2b7db89d71bf277bf47b78996510f3" translate="yes" xml:space="preserve">
          <source>The set of target module names or for an unqualified export, an empty set</source>
          <target state="translated">대상 모듈 이름 세트 또는 규정되지 않은 내보내기의 경우 빈 세트</target>
        </trans-unit>
        <trans-unit id="6411c296dc3589a36374e8f730a51bc836538d36" translate="yes" xml:space="preserve">
          <source>The set of target module names or for an unqualified opens, an empty set</source>
          <target state="translated">대상 모듈 이름 세트 또는 규정되지 않은 열기의 경우 빈 세트</target>
        </trans-unit>
        <trans-unit id="5cec8d2be735850abe92747462139ac2c64dc724" translate="yes" xml:space="preserve">
          <source>The set of terminals supported by a TerminalFactory.</source>
          <target state="translated">TerminalFactory에서 지원하는 터미널 세트입니다.</target>
        </trans-unit>
        <trans-unit id="1eb0b192e307c8d6408074ffabaad779d8fef889" translate="yes" xml:space="preserve">
          <source>The set of terminals supported by a TerminalFactory. This class allows applications to enumerate the available CardTerminals, obtain a specific CardTerminal, or wait for the insertion or removal of cards.</source>
          <target state="translated">TerminalFactory에서 지원하는 터미널 세트입니다. 이 클래스를 사용하면 응용 프로그램이 사용 가능한 CardTerminals를 열거하거나 특정 CardTerminal을 얻거나 카드 삽입 또는 제거를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="921bf8ce163fe63c69e39a66bfba8aae02a1cc6f" translate="yes" xml:space="preserve">
          <source>The set of warnings that are to be suppressed by the compiler in the annotated element.</source>
          <target state="translated">어노테이션이있는 요소에서 컴파일러에 의해 억제 될 경고 세트입니다.</target>
        </trans-unit>
        <trans-unit id="fe5205d619c2546cedc0aae80e2949df5b42d127" translate="yes" xml:space="preserve">
          <source>The set of warnings that are to be suppressed by the compiler in the annotated element. Duplicate names are permitted. The second and successive occurrences of a name are ignored. The presence of unrecognized warning names is</source>
          <target state="translated">어노테이션이있는 요소에서 컴파일러가 억제 할 경고 세트입니다. 중복 된 이름이 허용됩니다. 두 번째로 그리고 연속적으로 나타나는 이름은 무시됩니다. 인식 할 수없는 경고 이름이 있습니다</target>
        </trans-unit>
        <trans-unit id="cf50745559139179ac02ea11a6006ec30ea95b4e" translate="yes" xml:space="preserve">
          <source>The set of zone IDs can increase over time, although in a typical application the set of IDs is fixed. Each call to this method is thread-safe.</source>
          <target state="translated">일반적인 응용 프로그램에서는 ID 집합이 고정되어 있지만 영역 ID 집합은 시간이 지남에 따라 증가 할 수 있습니다. 이 메소드에 대한 각 호출은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b28e0ecb07f1416bf310fc7c1fb31a72ea753196" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order.</source>
          <target state="translated">세트의 반복자는 오름차순 키 순서로 항목을 반환합니다. 세트의 스플리터는 또한 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를보고합니다.&lt;/a&gt; 키 순서를 오름차순으로 만나는 발생 순서와 함께 .</target>
        </trans-unit>
        <trans-unit id="f353985651bff15e75e3ef09bec38c15d74624a5" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order.</source>
          <target state="translated">The set's iterator returns the entries in ascending key order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; with an encounter order that is ascending key order.</target>
        </trans-unit>
        <trans-unit id="499442b22634bbf31c6cc45cc4b266d5e35f872c" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The sets's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order.</source>
          <target state="translated">세트의 반복자는 오름차순 키 순서로 항목을 반환합니다. 세트의 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 이며, 키 순서가 오름차순 인 발생 순서로 &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 를 추가로보고합니다 .</target>
        </trans-unit>
        <trans-unit id="57326adf471d0608ffe63f3c2ada3c27d35abf46" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order.</source>
          <target state="translated">The set's iterator returns the keys in ascending order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt;, with an encounter order that is ascending key order.</target>
        </trans-unit>
        <trans-unit id="4685b0d5732f702ab85c0ed76d92a22ff9945c14" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;../spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the map's comparator (see &lt;a href=&quot;concurrentskiplistmap#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the map's comparator.</source>
          <target state="translated">세트의 반복자는 키를 오름차순으로 반환합니다. 세트의 스플리터는 또한 키 순서를 오름차순으로 만나는 발생 순서와 함께 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를&lt;/a&gt; 보고합니다 . 맵의 비교기 ( &lt;a href=&quot;concurrentskiplistmap#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, 분할기의 비교기 ( &lt;a href=&quot;../spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기가 맵의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="2714c6b13a1764a93e6b5af72f255c2219e07aa4" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree map's comparator (see &lt;a href=&quot;sortedmap#comparator()&quot;&gt;&lt;code&gt;SortedMap.comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator.</source>
          <target state="translated">The set's iterator returns the keys in ascending order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree map's comparator (see &lt;a href=&quot;sortedmap#comparator()&quot;&gt; &lt;code&gt;SortedMap.comparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; . Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator.</target>
        </trans-unit>
        <trans-unit id="46790b7f24e0bc5b45cc4e19d698ecf9c001e4f2" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree map's comparator (see &lt;a href=&quot;treemap#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator.</source>
          <target state="translated">세트의 반복자는 키를 오름차순으로 반환합니다. 세트의 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 이며, 키 순서가 오름차순 인 발생 순서로 &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 를 추가로보고합니다 . 트리 맵의 비교 자 ( &lt;a href=&quot;treemap#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기는 트리 맵의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="a4aff37df53c764fa75784f9af7cc154baaca8cd" translate="yes" xml:space="preserve">
          <source>The setColorModel method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setColorModel method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="669f9b373a4883c6affe2d61f4ab478337d861f6" translate="yes" xml:space="preserve">
          <source>The setDimensions method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setDimensions method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="c2516eb73a401a0d51802b1215cb53ea3fcb29df" translate="yes" xml:space="preserve">
          <source>The setHints method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setHints method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="0a7737011ca3b4f6d30e5001bcd5a5d682f03093" translate="yes" xml:space="preserve">
          <source>The setPixels method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setPixels method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="253bd9282184644a5e60303ce0fbf43d67f6a7dd" translate="yes" xml:space="preserve">
          <source>The setProperties method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</source>
          <target state="translated">The setProperties method is part of the ImageConsumer API which this class must implement to retrieve the pixels.</target>
        </trans-unit>
        <trans-unit id="780812be2038ec016303466bdffb453d52a56bf6" translate="yes" xml:space="preserve">
          <source>The sets of bindings and actions may be empty but must be non-&lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">The sets of bindings and actions may be empty but must be non- &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f060c2185618cf2a6c32ef4425c5bbd1f9463f3a" translate="yes" xml:space="preserve">
          <source>The setup parameters and general request properties are manipulated.</source>
          <target state="translated">설정 매개 변수 및 일반 요청 특성이 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="e45a6b9c2d290d870eaa0f880a9a918246e71542" translate="yes" xml:space="preserve">
          <source>The setup parameters are modified using the following methods:</source>
          <target state="translated">설정 매개 변수는 다음 방법을 사용하여 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd13c7488ba25ddcfcc26fab92f485990ee6b61" translate="yes" xml:space="preserve">
          <source>The seven one-argument public constructors provided by this class ensure that the assertion error returned by the invocation:</source>
          <target state="translated">이 클래스에서 제공하는 7 개의 1 인수 공용 생성자는 호출에서 반환 된 어설 션 오류를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c50586a794dd2d03708cb38eeaec0dfc03ceb15a" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error.</target>
        </trans-unit>
        <trans-unit id="cbfb5b21f94b1f39201ec64311f786525c788517" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error. A &lt;code&gt;SEVERITY_ERROR&lt;/code&gt; may not cause the processing to stop if the error can be recovered, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is error. A &lt;code&gt;SEVERITY_ERROR&lt;/code&gt; may not cause the processing to stop if the error can be recovered, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3090b59cda4a3cfaaada15e1b142bdc3aab39edc" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error.</target>
        </trans-unit>
        <trans-unit id="c3466b748260d572fcdcf4e5af7a15d80687e823" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error. A &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt; will cause the normal processing to stop. The return value of &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; is ignored unless the implementation chooses to continue, in which case the behavior becomes undefined.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is fatal error. A &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt; will cause the normal processing to stop. The return value of &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; is ignored unless the implementation chooses to continue, in which case the behavior becomes undefined.</target>
        </trans-unit>
        <trans-unit id="4dce1e66e356c13f39b0e1da4baf5b92e91bdf40" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning.</target>
        </trans-unit>
        <trans-unit id="faecc9cb5575ec0247ec8c48b1fbdcc24296de12" translate="yes" xml:space="preserve">
          <source>The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning. A &lt;code&gt;SEVERITY_WARNING&lt;/code&gt; will not cause the processing to stop, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">The severity of the error described by the &lt;code&gt;DOMError&lt;/code&gt; is warning. A &lt;code&gt;SEVERITY_WARNING&lt;/code&gt; will not cause the processing to stop, unless &lt;code&gt;DOMErrorHandler.handleError()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6683228de459fdaf28b8a641613d107e9fd7efe" translate="yes" xml:space="preserve">
          <source>The severity of the error, either &lt;code&gt;SEVERITY_WARNING&lt;/code&gt;, &lt;code&gt;SEVERITY_ERROR&lt;/code&gt;, or &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt;.</source>
          <target state="translated">The severity of the error, either &lt;code&gt;SEVERITY_WARNING&lt;/code&gt; , &lt;code&gt;SEVERITY_ERROR&lt;/code&gt; , or &lt;code&gt;SEVERITY_FATAL_ERROR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1d146216a151be9f0ea1c3654e3497f9a52dbb" translate="yes" xml:space="preserve">
          <source>The severity of this notification. It can be 0 to mean unknown severity or a value from 1 to 6 representing decreasing levels of severity. It can be represented as a decimal string or an &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">이 알림의 심각도 알 수없는 심각도를 나타내는 0 또는 심각도 감소 레벨을 나타내는 1-6의 값일 수 있습니다. 10 진수 문자열 또는 &lt;code&gt;Integer&lt;/code&gt; 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0eccb8cc0e921de7917ea0c1ada9687bb891455" translate="yes" xml:space="preserve">
          <source>The shaper assumes EUROPEAN as the starting context, that is, if EUROPEAN digits are encountered before any strong directional text in the string, the context is presumed to be EUROPEAN, and so the digits will not shape.</source>
          <target state="translated">The shaper assumes EUROPEAN as the starting context, that is, if EUROPEAN digits are encountered before any strong directional text in the string, the context is presumed to be EUROPEAN, and so the digits will not shape.</target>
        </trans-unit>
        <trans-unit id="7c0ee07626a06ec319c5fa6dda80e5cd02b895c5" translate="yes" xml:space="preserve">
          <source>The shift modifier.</source>
          <target state="translated">The shift modifier.</target>
        </trans-unit>
        <trans-unit id="71c1d09d15500daa94744a275e60c6c2939bb498" translate="yes" xml:space="preserve">
          <source>The shift modifier. An indicator that the shift key was held down during the event.</source>
          <target state="translated">The shift modifier. An indicator that the shift key was held down during the event.</target>
        </trans-unit>
        <trans-unit id="a66fafeb6fbab36159ed0d7cb6e57d97215745bd" translate="yes" xml:space="preserve">
          <source>The short at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 단락</target>
        </trans-unit>
        <trans-unit id="576f2f40fa40978110faae7dddc7b0f100fba9e6" translate="yes" xml:space="preserve">
          <source>The short at the given index</source>
          <target state="translated">주어진 색인에서 짧은</target>
        </trans-unit>
        <trans-unit id="66f18505d5b42c405be6d263a2a68a91ad1ba54c" translate="yes" xml:space="preserve">
          <source>The short value at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 짧은 값</target>
        </trans-unit>
        <trans-unit id="445cdd9d7081047dd595fe2a9c000aec02dddce0" translate="yes" xml:space="preserve">
          <source>The short value at the given index</source>
          <target state="translated">주어진 인덱스에서 짧은 값</target>
        </trans-unit>
        <trans-unit id="d44b2f7b9945d3e00f503b32d73edd3c18066dda" translate="yes" xml:space="preserve">
          <source>The shorts between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the short at index</source>
          <target state="translated">버퍼의 현재 위치와 한계 사이의 단락 (있는 경우)이 버퍼의 시작 부분에 복사됩니다. 즉, 지수 부족</target>
        </trans-unit>
        <trans-unit id="e6144db94e8f968200473ae365392fcfc5ce0cb6" translate="yes" xml:space="preserve">
          <source>The should be of the format 'BaseOfRange', such as 'MonthOfYear', unless the field has a range of &lt;code&gt;FOREVER&lt;/code&gt;, when only the base unit is mentioned, such as 'Year' or 'Era'.</source>
          <target state="translated">'Year'또는 'Era'와 같이 기본 단위 만 언급 된 경우 필드에 &lt;code&gt;FOREVER&lt;/code&gt; 범위가 없으면 'MonthOfYear'와 같은 'BaseOfRange'형식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3add085de9aaf5d9e08da4a23124aa74c77dac0e" translate="yes" xml:space="preserve">
          <source>The side input tray.</source>
          <target state="translated">측면 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="32380dd36b39ecdac95d6475271f9fd1eac8171d" translate="yes" xml:space="preserve">
          <source>The sign of the hours and minutes components must match. Thus, if the hours is negative, the minutes must be negative or zero. If the hours is zero, the minutes may be positive, negative or zero.</source>
          <target state="translated">시간 및 분 구성 요소의 부호가 일치해야합니다. 따라서 시간이 음수이면 분은 음수이거나 0이어야합니다. 시간이 0이면 분은 양수, 음수 또는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2a7170814ac7bf2d717ef435fa78b42211f6f7" translate="yes" xml:space="preserve">
          <source>The sign of the hours, minutes and seconds components must match. Thus, if the hours is negative, the minutes and seconds must be negative or zero.</source>
          <target state="translated">시간, 분 및 초 구성 요소의 부호가 일치해야합니다. 따라서 시간이 음수이면 분과 초는 음수 또는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee96bcfbe6567e84f1f76ed99e4ecc836a96fca7" translate="yes" xml:space="preserve">
          <source>The sign of the years and months units will be the same after normalization. For example, a period of &quot;1 year and -25 months&quot; will be normalized to &quot;-1 year and -1 month&quot;.</source>
          <target state="translated">연도 및 월 단위의 부호는 정규화 후에 동일합니다. 예를 들어 &quot;1 년 -25 개월&quot;기간은 &quot;-1 년 -1 개월&quot;로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="63a67b56142738f69b16820d1365a14f5a4ee3f6" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-1. The DSA algorithm using the SHA-1 message digest algorithm can be specified as &lt;code&gt;SHA1withDSA&lt;/code&gt;. In the case of RSA, there are multiple choices for the message digest algorithm, so the signing algorithm could be specified as, for example, &lt;code&gt;MD2withRSA&lt;/code&gt;, &lt;code&gt;MD5withRSA&lt;/code&gt;, or &lt;code&gt;SHA1withRSA&lt;/code&gt;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">서명 알고리즘은 특히 DSA 및 SHA-1을 사용하는 NIST 표준 DSA 일 수 있습니다. SHA-1 메시지 요약 알고리즘을 사용하는 DSA 알고리즘은 &lt;code&gt;SHA1withDSA&lt;/code&gt; 로 지정할 수 있습니다 . RSA의 경우 메시지 요약 알고리즘에 대해 여러 가지 선택이 있으므로 서명 알고리즘은 예를 들어 &lt;code&gt;MD2withRSA&lt;/code&gt; , &lt;code&gt;MD5withRSA&lt;/code&gt; 또는 &lt;code&gt;SHA1withRSA&lt;/code&gt; 로 지정할 수 있습니다 . 기본값이 없으므로 알고리즘 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a3f13d175903d19542fafe1776e926f2289f74d" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-1. The algorithm is specified using the same convention as that for signatures. The DSA algorithm using the SHA-1 message digest algorithm can be specified, for example, as &quot;SHA/DSA&quot; or &quot;SHA-1/DSA&quot; (they are equivalent). In the case of RSA, there are multiple choices for the message digest algorithm, so the signing algorithm could be specified as, for example, &quot;MD2/RSA&quot;, &quot;MD5/RSA&quot; or &quot;SHA-1/RSA&quot;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">서명 알고리즘은 특히 DSA 및 SHA-1을 사용하는 NIST 표준 DSA 일 수 있습니다. 알고리즘은 서명과 동일한 규칙을 사용하여 지정됩니다. SHA-1 메시지 요약 알고리즘을 사용하는 DSA 알고리즘은 예를 들어 &quot;SHA / DSA&quot;또는 &quot;SHA-1 / DSA&quot;로 지정할 수 있습니다 (동일 함). RSA의 경우 메시지 다이제스트 알고리즘에 대한 여러 선택이 있으므로 서명 알고리즘은 예를 들어 &quot;MD2 / RSA&quot;, &quot;MD5 / RSA&quot;또는 &quot;SHA-1 / RSA&quot;로 지정할 수 있습니다. 기본값이 없으므로 알고리즘 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4580befbe651a07f41f435d90006b6e04a4a69a" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The DSA algorithm using the SHA-256 message digest algorithm can be specified as &lt;code&gt;SHA256withDSA&lt;/code&gt;. In the case of RSA the signing algorithm could be specified as, for example, &lt;code&gt;SHA256withRSA&lt;/code&gt;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The DSA algorithm using the SHA-256 message digest algorithm can be specified as &lt;code&gt;SHA256withDSA&lt;/code&gt; . In the case of RSA the signing algorithm could be specified as, for example, &lt;code&gt;SHA256withRSA&lt;/code&gt; . The algorithm name must be specified, as there is no default.</target>
        </trans-unit>
        <trans-unit id="b6ff0462ece74d8c29d34b7ea3288f3bf76eb9da" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The algorithm is specified using the same convention as that for signatures. The DSA algorithm using the SHA-256 message digest algorithm can be specified, for example, as &quot;SHA256withDSA&quot;. In the case of RSA the signing algorithm could be specified as, for example, &quot;SHA256withRSA&quot;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-256. The algorithm is specified using the same convention as that for signatures. The DSA algorithm using the SHA-256 message digest algorithm can be specified, for example, as &quot;SHA256withDSA&quot;. In the case of RSA the signing algorithm could be specified as, for example, &quot;SHA256withRSA&quot;. The algorithm name must be specified, as there is no default.</target>
        </trans-unit>
        <trans-unit id="ff39bceb78bb23fcbbe70e1f5873034144eb781f" translate="yes" xml:space="preserve">
          <source>The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See Appendix A in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt; Java Cryptography Architecture API Specification &amp;amp; Reference &lt;/a&gt; for information about standard algorithm names.</source>
          <target state="translated">서명 알고리즘 이름은 표준 Java 보안 이름 (예 : &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;등)이어야합니다. 표준 알고리즘 이름에 대한 정보 는 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt;Java Cryptography Architecture API 스펙 및 참조 서&lt;/a&gt; 의 부록 A를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54dcf510ed19a2b7f8be77cd8487aba2b8f5418c" translate="yes" xml:space="preserve">
          <source>The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for information about standard algorithm names.</source>
          <target state="translated">The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for information about standard algorithm names.</target>
        </trans-unit>
        <trans-unit id="abb3f7329a67b3d4fbdda3d73c3b635eb5d93e29" translate="yes" xml:space="preserve">
          <source>The signature implementation is reset to its initial state (the state it was in after a call to one of the &lt;code&gt;engineInitSign&lt;/code&gt; methods) and can be reused to generate further signatures with the same private key. This method should be abstract, but we leave it concrete for binary compatibility. Knowledgeable providers should override this method.</source>
          <target state="translated">서명 구현은 초기 상태 ( &lt;code&gt;engineInitSign&lt;/code&gt; 메소드 중 하나를 호출 한 후의 상태)로 재설정되며 동일한 개인 키로 추가 서명을 생성하기 위해 재사용 할 수 있습니다. 이 방법은 추상적이어야하지만 바이너리 호환성을 위해 구체적으로 남겨둔다. 지식이 풍부한 공급자는이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="045f0d9e22ad722e6aac3627bd8e3b08a1c1d73b" translate="yes" xml:space="preserve">
          <source>The signature is invalid.</source>
          <target state="translated">서명이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ded27c36fe5ab7411d3e61933f2340152846415" translate="yes" xml:space="preserve">
          <source>The signed object is a &quot;deep copy&quot; (in serialized form) of an original object. Once the copy is made, further manipulation of the original object has no side effect on the copy.</source>
          <target state="translated">서명 된 객체는 원본 객체의 &quot;딥 카피&quot;(직렬화 된 형태)입니다. 복사가 완료되면 원본 개체를 추가로 조작해도 복사본에 부작용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0a59c44048f0e255610b14982004df77ebcfed2" translate="yes" xml:space="preserve">
          <source>The simple name of an array is the simple name of the component type with &quot;[]&quot; appended. In particular the simple name of an array whose component type is anonymous is &quot;[]&quot;.</source>
          <target state="translated">배열의 단순 이름은 &quot;[]&quot;가 추가 된 구성 요소 유형의 단순 이름입니다. 특히 구성 요소 유형이 익명 인 배열의 단순 이름은 &quot;[]&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4856758e2bc679598150b5beb9072d5658f18a73" translate="yes" xml:space="preserve">
          <source>The simplest implementation of this interface is just:</source>
          <target state="translated">이 인터페이스의 가장 간단한 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2790b740b20a089db3044ca3bea2a585feabf923" translate="yes" xml:space="preserve">
          <source>The simplest method is XYZ scaling. In this method each device XYZ value is converted to a PCS XYZ value by multiplying it by the ratio of the PCS white point (D50) to the device white point.</source>
          <target state="translated">The simplest method is XYZ scaling. In this method each device XYZ value is converted to a PCS XYZ value by multiplying it by the ratio of the PCS white point (D50) to the device white point.</target>
        </trans-unit>
        <trans-unit id="7601d63e6d779f847c6607714e8ec53d040dbbd9" translate="yes" xml:space="preserve">
          <source>The simplest type of ID is that from &lt;code&gt;ZoneOffset&lt;/code&gt;. This consists of 'Z' and IDs starting with '+' or '-'.</source>
          <target state="translated">가장 간단한 유형의 ID는 &lt;code&gt;ZoneOffset&lt;/code&gt; 의 ID입니다 . 'Z'와 '+'또는 '-'로 시작하는 ID로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4705f5b2ef8f72b3f9ee11b55f079122ada80e7" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is to install a listener that calls a method on the target object with no arguments. In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that invokes the &lt;code&gt;toFront&lt;/code&gt; method on an instance of &lt;code&gt;javax.swing.JFrame&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 의 가장 간단한 사용은 인수없이 대상 오브젝트에서 메소드를 호출하는 리스너를 설치하는 것입니다. 다음 예제에서는 &lt;code&gt;javax.swing.JFrame&lt;/code&gt; 인스턴스 에서 &lt;code&gt;toFront&lt;/code&gt; 메소드 를 호출 하는 &lt;code&gt;ActionListener&lt;/code&gt; 를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ddd983cd346b58b2aaf0f326494e8259d55fa6b4" translate="yes" xml:space="preserve">
          <source>The simulated full-screen mode places and resizes the window to the maximum possible visible area of the screen. However, the native windowing system may modify the requested geometry-related data, so that the &lt;code&gt;Window&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</source>
          <target state="translated">The simulated full-screen mode places and resizes the window to the maximum possible visible area of the screen. However, the native windowing system may modify the requested geometry-related data, so that the &lt;code&gt;Window&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</target>
        </trans-unit>
        <trans-unit id="72ac5c657bc308d65c18c1fea6c9f1bba77d6a25" translate="yes" xml:space="preserve">
          <source>The single instance of &lt;code&gt;EmptySelectionModel&lt;/code&gt;.</source>
          <target state="translated">The single instance of &lt;code&gt;EmptySelectionModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37fb3690360544e839a41fbd8b8e5c5a45340b29" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Heisei' era (1989-01-08 - 2019-04-30) which has the value 2.</source>
          <target state="translated">The singleton instance for the 'Heisei' era (1989-01-08 - 2019-04-30) which has the value 2.</target>
        </trans-unit>
        <trans-unit id="e33d8bb98b0a97976f391846111c47207f038c46" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Heisei' era (1989-01-08 - current) which has the value 2.</source>
          <target state="translated">값이 2 인 'Heisei'시대 (1989-01-08-현재)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="2ad53a43c41fc711e9fc765c7a76f4717f283334" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Meiji' era (1868-01-01 - 1912-07-29) which has the value -1.</source>
          <target state="translated">값이 -1 인 'Meiji'시대 (1868-01-01-1912-07-29)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d90af347fd6251915ffab61ea28205da8ea6f749" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Showa' era (1926-12-25 - 1989-01-07) which has the value 1.</source>
          <target state="translated">값이 1 인 'Showa'시대 (1926-12-25-1989-01-07)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="374b989066c6a8b313cd532f43d4978a478afb4f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Taisho' era (1912-07-30 - 1926-12-24) which has the value 0.</source>
          <target state="translated">값이 0 인 'Taisho'시대 (1912-07-30-1926-12-24)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d1b649d3aca82f1b585114b89db8e7c3dce97afa" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Anno Hegirae', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 단일 인스턴스 인 'Anno Hegirae'는 숫자 값 1을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="33553f68eda534c6d7ec7b5b2097412f8aa169ef" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Buddhist Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 '불교 시대 (Buddhist Era)'에 대한 싱글 톤 인스턴스. 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="18e0a9282dc09dc3f8d780bd88319f70049b3bc8" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Current Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 싱글 톤 인스턴스 인 'Current Era'. 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="a9078c5f2b2fb0c83101cd2aab438d63e4d37967" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Republic of China Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 '중화 민국 시대'의 단일 인스턴스이며 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="37056cb4b1f3c2ee07efbc354ac2f5400ad2df63" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Friday.</source>
          <target state="translated">The singleton instance for the day-of-week of Friday.</target>
        </trans-unit>
        <trans-unit id="831fb5e46d4c1ddc036d82d37411d75aecf60668" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Friday. This has the numeric value of &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">금요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ec9586cccb6a778352e7a8dd8a12d2579e4859d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Monday.</source>
          <target state="translated">The singleton instance for the day-of-week of Monday.</target>
        </trans-unit>
        <trans-unit id="854466f9d7677acbef6b426929908eeaea0c0ac9" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Monday. This has the numeric value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">월요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95b6e13ea6c89b236812e595ea75de12418330ff" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Saturday.</source>
          <target state="translated">The singleton instance for the day-of-week of Saturday.</target>
        </trans-unit>
        <trans-unit id="6eec5084ed707e201918c7bb81e4ef4045f48ec1" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Saturday. This has the numeric value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">토요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="78d35379c7acd7ced1ce07f8a02d53fa46868e5c" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Sunday.</source>
          <target state="translated">The singleton instance for the day-of-week of Sunday.</target>
        </trans-unit>
        <trans-unit id="ec410919ffc74e6ed0841570a165d1ab4f8518b3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Sunday. This has the numeric value of &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">일요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;7&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44f30fc5690e19a76a107f962afc755c430f1fa8" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Thursday.</source>
          <target state="translated">The singleton instance for the day-of-week of Thursday.</target>
        </trans-unit>
        <trans-unit id="1b47f4c269ae66d8d89624e16dab12fae314b4ae" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Thursday. This has the numeric value of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">목요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9f862e8dc4406d39bdc49daea39643bfd67e82cc" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Tuesday.</source>
          <target state="translated">The singleton instance for the day-of-week of Tuesday.</target>
        </trans-unit>
        <trans-unit id="8710ed5941f516f24bb8dc09854d8cbc78a468d6" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Tuesday. This has the numeric value of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">화요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4203c1fdd0478946eb06f1dc84aca7d5d14b634f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Wednesday.</source>
          <target state="translated">The singleton instance for the day-of-week of Wednesday.</target>
        </trans-unit>
        <trans-unit id="74f5d636b9653c07ec4dfb5343c1209f6f45dee7" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Wednesday. This has the numeric value of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">수요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7713ef876ec0d0ff70d52271f9980dec01c333d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Buddhist Era', which has the numeric value 0.</source>
          <target state="translated">숫자 값이 0 인 현재 '불교 전 시대'이전 시대의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b7f42f3144aa34fcb5eacd6614462e8933d9e7c5" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Current Era', which has the numeric value 0.</source>
          <target state="translated">현재 값 이전의 'Before Current Era'이전의 싱글 톤 인스턴스이며 숫자 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4b5ed684b1759647e9750f9a4982ba3a88602d2a" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Republic of China Era', which has the numeric value 0.</source>
          <target state="translated">숫자 값이 0 인 현재 '중국 이전 시대'이전 시대의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="41eacb4f52ecff4535c6e0cd6e7596d3c29916cb" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of April with 30 days.</source>
          <target state="translated">The singleton instance for the month of April with 30 days.</target>
        </trans-unit>
        <trans-unit id="3498e33856b3bc1fa91dfe207455e4d516871a4f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of April with 30 days. This has the numeric value of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 4 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="70bb761c71fbabd2f2c266b82d999a1f7068ff4d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of August with 31 days.</source>
          <target state="translated">The singleton instance for the month of August with 31 days.</target>
        </trans-unit>
        <trans-unit id="a0dc754b17787f96f2b3260ec04194b05222744d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of August with 31 days. This has the numeric value of &lt;code&gt;8&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 8 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d30a73566a6e9dbf9efa2a653e803caa4ad5d73d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of December with 31 days.</source>
          <target state="translated">The singleton instance for the month of December with 31 days.</target>
        </trans-unit>
        <trans-unit id="afeded1a61c1256c947b92fd91be8f38f688ade2" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of December with 31 days. This has the numeric value of &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 12 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;12&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="806b6cb116e04b29f83c29dc9e3bdcb40a592e14" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of February with 28 days, or 29 in a leap year.</source>
          <target state="translated">The singleton instance for the month of February with 28 days, or 29 in a leap year.</target>
        </trans-unit>
        <trans-unit id="58ce16c9d66eb0950d2e8d8a844af1f67a40ea2b" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of February with 28 days, or 29 in a leap year. This has the numeric value of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">28 일 또는 윤년 29 일의 2 월 달의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74e203bb14a07d04b6220cd4725722658def7d5a" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of January with 31 days.</source>
          <target state="translated">The singleton instance for the month of January with 31 days.</target>
        </trans-unit>
        <trans-unit id="dbbaed2d99f6b4a91bd5a263c15920ce26db8422" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of January with 31 days. This has the numeric value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 1 월 달의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84a201e965918b73f6f0a51fb95d40167274284d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of July with 31 days.</source>
          <target state="translated">The singleton instance for the month of July with 31 days.</target>
        </trans-unit>
        <trans-unit id="dbf8150d5e374559752b5a4144a24f8a49cc43d5" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of July with 31 days. This has the numeric value of &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 7 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;7&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d2ece5339a8942535bba2423c8f2d06bdcec0c3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of June with 30 days.</source>
          <target state="translated">The singleton instance for the month of June with 30 days.</target>
        </trans-unit>
        <trans-unit id="171ab07a731170963fee5c54879a243aba461820" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of June with 30 days. This has the numeric value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 6 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b1f2132810b846baf93a7cbba2b98223085cec9" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of March with 31 days.</source>
          <target state="translated">The singleton instance for the month of March with 31 days.</target>
        </trans-unit>
        <trans-unit id="c44b47253f5146f50a56c9c4736034ad855145f6" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of March with 31 days. This has the numeric value of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 3 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e931f22dda40194f4e445071e6bc03593a7d73b9" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of May with 31 days.</source>
          <target state="translated">The singleton instance for the month of May with 31 days.</target>
        </trans-unit>
        <trans-unit id="695b98cf8bd88f36fe7a8d59e7b014104eb39c42" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of May with 31 days. This has the numeric value of &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 5 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="573cb230de428c272b4736649c6a3825e16254bc" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of November with 30 days.</source>
          <target state="translated">The singleton instance for the month of November with 30 days.</target>
        </trans-unit>
        <trans-unit id="5e6f9285c59d2cfa11644efd29aaef36209c76e3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of November with 30 days. This has the numeric value of &lt;code&gt;11&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 11 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;11&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5882f0e70b11a8c3279fc0103861f8c7c5df376" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of October with 31 days.</source>
          <target state="translated">The singleton instance for the month of October with 31 days.</target>
        </trans-unit>
        <trans-unit id="77d17e30353cc1d8703e4ac383dfbcf24f64b2d7" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of October with 31 days. This has the numeric value of &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 10 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="680e4d7736cb5471597da49f9edf29e6acb2f15a" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of September with 30 days.</source>
          <target state="translated">The singleton instance for the month of September with 30 days.</target>
        </trans-unit>
        <trans-unit id="cd70f2cccb7c35228c39eb4016b4bd39aab9ea64" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of September with 30 days. This has the numeric value of &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 9 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;9&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a73fac7de9937b7c2c258ee59ea1bff17d0831e6" translate="yes" xml:space="preserve">
          <source>The size button text property.</source>
          <target state="translated">The size button text property.</target>
        </trans-unit>
        <trans-unit id="2d53c63b615a428bc85b992b7c04eed456185922" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">The size of &lt;code&gt;JOptionPane&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af1f4f7f642c922c1567312119a5e4ad52a0724a" translate="yes" xml:space="preserve">
          <source>The size of a doc is computed based on the print data representation class as specified by the doc's &lt;a href=&quot;../../docflavor&quot;&gt;&lt;code&gt;DocFlavor&lt;/code&gt;&lt;/a&gt;, as shown in the table below.</source>
          <target state="translated">문서의 크기는 아래 표에 표시된 것처럼 문서의 &lt;a href=&quot;../../docflavor&quot;&gt; &lt;code&gt;DocFlavor&lt;/code&gt; 에&lt;/a&gt; 지정된 인쇄 데이터 표현 클래스를 기반으로 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="23d732c5b294224e6c7bc0db0723f73dec9504a9" translate="yes" xml:space="preserve">
          <source>The size of components.</source>
          <target state="translated">The size of components.</target>
        </trans-unit>
        <trans-unit id="2b33100b39966e88e8e151f1b8c55dcbceae0f08" translate="yes" xml:space="preserve">
          <source>The size of each frame, in bytes.</source>
          <target state="translated">각 프레임의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="8f9034f1b6e8e551c9315d1f020fa1ede6c673ba" translate="yes" xml:space="preserve">
          <source>The size of each segment is estimated by counting the size of each input file to be transmitted in the segment, along with the size of its name and other transmitted properties.</source>
          <target state="translated">각 세그먼트의 크기는 이름 및 기타 전송 된 속성의 크기와 함께 세그먼트에서 전송 될 각 입력 파일의 크기를 계산하여 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="6945db6b9aaec59e9a237996f6de7fd4d6e01473" translate="yes" xml:space="preserve">
          <source>The size of the attribute value, in bytes.</source>
          <target state="translated">속성 값의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="d377fbc634cb1fcaa6d6aeebdf8a7126697e9a7f" translate="yes" xml:space="preserve">
          <source>The size of the divider while the dragging session is valid.</source>
          <target state="translated">The size of the divider while the dragging session is valid.</target>
        </trans-unit>
        <trans-unit id="2babd81935a68bc574cf140a8ed25e62a8a4ddfe" translate="yes" xml:space="preserve">
          <source>The size of the frame includes any area designated for the border. The dimensions of the border area may be obtained using the &lt;code&gt;getInsets&lt;/code&gt; method, however, since these dimensions are platform-dependent, a valid insets value cannot be obtained until the frame is made displayable by either calling &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;show&lt;/code&gt;. Since the border area is included in the overall size of the frame, the border effectively obscures a portion of the frame, constraining the area available for rendering and/or displaying subcomponents to the rectangle which has an upper-left corner location of &lt;code&gt;(insets.left, insets.top)&lt;/code&gt;, and has a size of &lt;code&gt;width - (insets.left + insets.right)&lt;/code&gt; by &lt;code&gt;height - (insets.top + insets.bottom)&lt;/code&gt;.</source>
          <target state="translated">The size of the frame includes any area designated for the border. The dimensions of the border area may be obtained using the &lt;code&gt;getInsets&lt;/code&gt; method, however, since these dimensions are platform-dependent, a valid insets value cannot be obtained until the frame is made displayable by either calling &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;show&lt;/code&gt; . Since the border area is included in the overall size of the frame, the border effectively obscures a portion of the frame, constraining the area available for rendering and/or displaying subcomponents to the rectangle which has an upper-left corner location of &lt;code&gt;(insets.left, insets.top)&lt;/code&gt; , and has a size of &lt;code&gt;width - (insets.left + insets.right)&lt;/code&gt; by &lt;code&gt;height - (insets.top + insets.bottom)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aef354301526547b65cbdbff808019ed00981550" translate="yes" xml:space="preserve">
          <source>The size of the locked region</source>
          <target state="translated">잠긴 영역의 크기</target>
        </trans-unit>
        <trans-unit id="ffd49f5a54a05c0e211000f48c06808a4e45ab2a" translate="yes" xml:space="preserve">
          <source>The size of the socket receive buffer</source>
          <target state="translated">소켓 수신 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="b93eb1ff5703dad725f268be21bfebee369e1241" translate="yes" xml:space="preserve">
          <source>The size of the socket receive buffer.</source>
          <target state="translated">소켓 수신 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="ac94f9348a7ec8ca8eb5a0577c7a3672cb67beac" translate="yes" xml:space="preserve">
          <source>The size of the socket send buffer</source>
          <target state="translated">소켓 송신 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="afb9a30fb21697b87a94f349ade50c4c64721e5a" translate="yes" xml:space="preserve">
          <source>The size of the socket send buffer.</source>
          <target state="translated">소켓 송신 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f546bdf38de152c096164ced3cb3faeef1188d54" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the partition or &lt;code&gt;0L&lt;/code&gt; if this abstract pathname does not name a partition</source>
          <target state="translated">파티션의 크기 (바이트) 또는 이 추상 경로명이 파티션 이름을 지정하지 않는 경우 &lt;code&gt;0L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77e7580d4eabd26a16573da1f1e6884d637aaaa9" translate="yes" xml:space="preserve">
          <source>The slider can show both major tick marks, and minor tick marks between the major ones. The number of values between the tick marks is controlled with &lt;code&gt;setMajorTickSpacing&lt;/code&gt; and &lt;code&gt;setMinorTickSpacing&lt;/code&gt;. Painting of tick marks is controlled by &lt;code&gt;setPaintTicks&lt;/code&gt;.</source>
          <target state="translated">The slider can show both major tick marks, and minor tick marks between the major ones. The number of values between the tick marks is controlled with &lt;code&gt;setMajorTickSpacing&lt;/code&gt; and &lt;code&gt;setMinorTickSpacing&lt;/code&gt; . Painting of tick marks is controlled by &lt;code&gt;setPaintTicks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6ffd0649eec316588f1e098e996254023ca6c5" translate="yes" xml:space="preserve">
          <source>The smallest acceptable size for the thumb.</source>
          <target state="translated">The smallest acceptable size for the thumb.</target>
        </trans-unit>
        <trans-unit id="608588a6ce7faa309c72f3d591de7b6a527d1475" translate="yes" xml:space="preserve">
          <source>The smallest grid that can be laid out by the grid bag layout.</source>
          <target state="translated">The smallest grid that can be laid out by the grid bag layout.</target>
        </trans-unit>
        <trans-unit id="eccc9011507e2f8d69cd68d30db124741a00ce17" translate="yes" xml:space="preserve">
          <source>The smallest integer in this set-of-integer attribute that is greater than &lt;code&gt;x&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; if no integer in this set-of-integer attribute is greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">보다 큰 정수형 세트의 특성에 작은 정수 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; 정수형 세트의 속성에는 정수를 초과하지 않는 경우 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9839a314b20b78f9253b406fd33020bc5eeae4df" translate="yes" xml:space="preserve">
          <source>The smallest reasonable width/height of the component or component group, in pixels.</source>
          <target state="translated">The smallest reasonable width/height of the component or component group, in pixels.</target>
        </trans-unit>
        <trans-unit id="d29505ba6327a428e6ada6e998db00c29198a04c" translate="yes" xml:space="preserve">
          <source>The smallest valid index for reading, initially 0.</source>
          <target state="translated">The smallest valid index for reading, initially 0.</target>
        </trans-unit>
        <trans-unit id="cc3e306f7c43f12a0cd31a1e11f56ee1c06bddfe" translate="yes" xml:space="preserve">
          <source>The smallest valid index for reading, initially 0. When &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, various methods may throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; on an attempt to access data associate with an image having a lower index.</source>
          <target state="translated">판독 할 때의 최소 유효 인덱스는 초기에 0 &lt;code&gt;seekForwardOnly&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; , 다양한 방법은 던질 수 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 화상 낮은 인덱스를 갖는 데이터 액세스 연관시킬 시도.</target>
        </trans-unit>
        <trans-unit id="d34a10ed96641b907e1eb213e81431652411700a" translate="yes" xml:space="preserve">
          <source>The socket address that the socket is bound to, or &lt;code&gt;null&lt;/code&gt; if the channel's socket is not bound</source>
          <target state="translated">소켓이 바인드 된 소켓 주소 또는 채널의 소켓이 바인드되지 않은 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004c4bf3ac859ce08e79a8b3e914c8cf5426cb22" translate="yes" xml:space="preserve">
          <source>The socket channel for the new connection, or &lt;code&gt;null&lt;/code&gt; if this channel is in non-blocking mode and no connection is available to be accepted</source>
          <target state="translated">새로운 접속의 소켓 채널. 이 채널이 비 블로킹 모드에있어 접속 가능한 접속이없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72330096ca60d13bfb3300d243f2b2b77e32b537" translate="yes" xml:space="preserve">
          <source>The socket channel returned by this method, if any, will be in blocking mode regardless of the blocking mode of this channel.</source>
          <target state="translated">이 메소드에 의해 돌려 주어진 소켓 채널은,이 채널의 블록킹 모드에 관계없이 차단 모드에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="0916495727f93025eff6a66cbf7b722521e11aa1" translate="yes" xml:space="preserve">
          <source>The socket factories are used when creating sockets for secure https URL connections.</source>
          <target state="translated">소켓 팩토리는 안전한 https URL 연결을위한 소켓을 만들 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9b1dacea19873875bd394d1604a0e5a5d30890d" translate="yes" xml:space="preserve">
          <source>The sockets returned to the application can be subclasses of java.net.Socket, so that they can directly expose new APIs for features such as compression, security, record marking, statistics collection, or firewall tunneling.</source>
          <target state="translated">애플리케이션에 리턴 된 소켓은 java.net.Socket의 서브 클래스 일 수 있으므로 압축, 보안, 레코드 표시, 통계 콜렉션 또는 방화벽 터널링과 같은 기능에 대한 새 API를 직접 노출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e877bbc8bfc38843765b0308b8332044317fbf2a" translate="yes" xml:space="preserve">
          <source>The sole constructor.</source>
          <target state="translated">유일한 생성자.</target>
        </trans-unit>
        <trans-unit id="d5d133be61491e0ac1417ab0eba748b3aa345615" translate="yes" xml:space="preserve">
          <source>The sole purpose of these additions is to allow the specification of tables for use in decoding abbreviated streams. The built-in JPEG reader will also accept an ordinary &lt;code&gt;ImageReadParam&lt;/code&gt;, which is sufficient for decoding non-abbreviated streams.</source>
          <target state="translated">이러한 추가의 유일한 목적은 축약 된 스트림을 디코딩하는 데 사용하기위한 테이블 지정을 허용하는 것입니다. 내장 JPEG 리더는 일반 &lt;code&gt;ImageReadParam&lt;/code&gt; 을 수용하므로 단축되지 않은 스트림을 디코딩하는 데 충분합니다.</target>
        </trans-unit>
        <trans-unit id="89b93c3df541630653c18e1886ceb597afae62a2" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="784cdcae362dc5581521030a458ea9926ba3223b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="7ff5d937d432a11ea2a201ecc58034dd5441a852" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="2e5b7af711e48ed5dc89614218be16edbd43e49c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="2fddd1310d77bbe7f9dfe3d3aa01ae962a906b1b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="02eeb024eac83701cb3dab1984790a4264154db6" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="4f90425a9cfcd671163aa3ba4f42ed3b9d2bc3a4" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="275540cfb6a8e26c5b313f0e391cacb2ad9d0076" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="94b575be4e8e24c03f457815c4ac16e5b75c882e" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="6ee0d5b8c7e0d8151809c5f26bb13f06d5c6f2a1" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="5e68b55659f65572149d90497e01649faf00e021" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="be292033b578af0efd8258008b00c522a942cd0c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="4939742092d60ecdc9f5ff5d5d17f5c9210da4ff" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="311db9e136afe682fa40514c417dc4d15f8e69c5" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="1fde7bfb5ab47c4ddc5c959bc79b4e7eb9f4030c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="c9a68b6c5882885166c6b5b6d4f8f9f68a7f939b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="38844e94f41cc1969fb62e4894696634a14fe20b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="75b2a84749a330a1c0b895e2bdf2312622f71cb8" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="20a31ccdaba6cb746cb91c886a84a8c2d7c538b7" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="48b9a8628a4883f257650b1adf775491c8f08839" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="d3cac5983cf37dcfe292291f746e0459fd7e8669" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="08eda0222f2f9308c70c208bbdafe98a9e736807" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="1b5efb4aa3ea50144cc0394f060b745aadbd838e" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="b9ac2ce61dcea76b147223bff87472496593df2a" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 하위 배열은 적절한&lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="ff09cbb5362e1360ac15f00a55f46a71d4e41ca1" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 서브 어레이 길이가 최소 입도에 도달하면, 서브 어레이를 사용하여 적절한 정렬 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="edc68fa2b5db74746879cf023d506ffd46c30425" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 서브 어레이 길이가 최소 입도에 도달하면, 서브 어레이를 사용하여 적절한 정렬 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="839592e0ded3d9de75771fbf4886b637ea10acea" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="614e7b8df8741ffaa018e919714cf7473694c642" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="648b93b50bbd09b1605688594b8660ecbbb90d1b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="0247ed33cde4f71d592e6d7daa37c7760b936d47" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 작은 최소 단위보다 긴 경우, 그것은 적절한하여 정렬 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="777d40468912737a83340f22bc67c6f77af71aaf" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="e41f68150d548775a312ef7c6bad1b753c9c647c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. 그만큼&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="b4ca5b611518435cd08b1d3ce800c9c8f468a67f" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;DocumentView&lt;/code&gt; of which this is an &lt;code&gt;AbstractView&lt;/code&gt;.</source>
          <target state="translated">The source &lt;code&gt;DocumentView&lt;/code&gt; of which this is an &lt;code&gt;AbstractView&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55944b789daff6ef5841d9434f11985f49ff23c4" translate="yes" xml:space="preserve">
          <source>The source actions represent the set of actions supported by the source of this transfer, and are represented as some bitwise-OR combination of &lt;code&gt;COPY&lt;/code&gt;, &lt;code&gt;MOVE&lt;/code&gt; and &lt;code&gt;LINK&lt;/code&gt;. You may wish to query this in &lt;code&gt;TransferHandler&lt;/code&gt;'s &lt;code&gt;canImport&lt;/code&gt; method when determining the suitability of a drop or when deciding on a drop action to explicitly choose. To determine if a particular action is supported by the source, bitwise-AND the action with the source drop actions, and then compare the result against the original action. For example:</source>
          <target state="translated">The source actions represent the set of actions supported by the source of this transfer, and are represented as some bitwise-OR combination of &lt;code&gt;COPY&lt;/code&gt; , &lt;code&gt;MOVE&lt;/code&gt; and &lt;code&gt;LINK&lt;/code&gt; . You may wish to query this in &lt;code&gt;TransferHandler&lt;/code&gt; 's &lt;code&gt;canImport&lt;/code&gt; method when determining the suitability of a drop or when deciding on a drop action to explicitly choose. To determine if a particular action is supported by the source, bitwise-AND the action with the source drop actions, and then compare the result against the original action. For example:</target>
        </trans-unit>
        <trans-unit id="368f0e5364e526b1a62ff1d9e84b032a4799d112" translate="yes" xml:space="preserve">
          <source>The source address if this membership key is source-specific, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">이 멤버쉽 키가 소스 별 인 경우 소스 주소 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ef1bc740369619f8b5584da49f9c3ff9ac10f5" translate="yes" xml:space="preserve">
          <source>The source and destination must be different.</source>
          <target state="translated">The source and destination must be different.</target>
        </trans-unit>
        <trans-unit id="1c54b79003a5eb4cba89a06459605f65bd7f13fd" translate="yes" xml:space="preserve">
          <source>The source bean is used as the source of events for the property changes. This source should be used for information purposes only and should not be modified by the PropertyEditor.</source>
          <target state="translated">소스 Bean은 특성 변경에 대한 이벤트 소스로 사용됩니다. 이 소스는 정보 용으로 만 사용해야하며 PropertyEditor에서 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d614f9d4f31f56431b30829db0ada88a1526496a" translate="yes" xml:space="preserve">
          <source>The source cannot be structurally interfered with.</source>
          <target state="translated">소스는 구조적으로 방해 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61689ca13fa0754b0dac1fef1851f1593b2946cb" translate="yes" xml:space="preserve">
          <source>The source format represents the format of the incoming audio data, which will be converted.</source>
          <target state="translated">소스 형식은 들어오는 오디오 데이터의 형식을 나타내며 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="46df136cd9cc4668c308b326cb05d7ed6808c192" translate="yes" xml:space="preserve">
          <source>The source increases the likelihood of throwing &lt;code&gt;ConcurrentModificationException&lt;/code&gt; since the window of potential interference is larger.</source>
          <target state="translated">잠재적 인 간섭의 창이 더 크기 때문에 소스는 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 던질 가능성을 높입니다 .</target>
        </trans-unit>
        <trans-unit id="c1f61cf74a08642c4ff7ee4b8bc3cda7829bff8b" translate="yes" xml:space="preserve">
          <source>The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction.</source>
          <target state="translated">소스는 구성 후에 감지되지 않은 간섭이 발생할 수 있으므로 임의의 비 결정적 동작의 위험을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="03d33500fcd4a667ea73efed98252841199edc27" translate="yes" xml:space="preserve">
          <source>The source is composited over the destination (Porter-Duff Source Over Destination rule).</source>
          <target state="translated">The source is composited over the destination (Porter-Duff Source Over Destination rule).</target>
        </trans-unit>
        <trans-unit id="dfdd906a9cfc82513a491834d2af899dcb03b222" translate="yes" xml:space="preserve">
          <source>The source is copied to the destination (Porter-Duff Source rule).</source>
          <target state="translated">The source is copied to the destination (Porter-Duff Source rule).</target>
        </trans-unit>
        <trans-unit id="29c343852025e2139effd2803766c6065e489fe6" translate="yes" xml:space="preserve">
          <source>The source is copied to the destination (Porter-Duff Source rule). The destination is not used as input.</source>
          <target state="translated">The source is copied to the destination (Porter-Duff Source rule). The destination is not used as input.</target>
        </trans-unit>
        <trans-unit id="7f5e35322fb74527344b994cfeb8d4a21c655439" translate="yes" xml:space="preserve">
          <source>The source manages concurrent modifications.</source>
          <target state="translated">소스는 동시 수정을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="8a5d1008eaa1af299fb1410c7693c63aa92311bc" translate="yes" xml:space="preserve">
          <source>The source object is the Relation Service itself.</source>
          <target state="translated">소스 오브젝트는 관계 서비스 자체입니다.</target>
        </trans-unit>
        <trans-unit id="aa58c7b11a77f180bde4263ee0c9af48ad826837" translate="yes" xml:space="preserve">
          <source>The source of the event can be retrieved with the method &lt;code&gt;event.getSource&lt;/code&gt;.</source>
          <target state="translated">The source of the event can be retrieved with the method &lt;code&gt;event.getSource&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b758d7983ddc60e8668a83198491ca7fd663319" translate="yes" xml:space="preserve">
          <source>The source of the event can be retrieved with the method event.getSource.</source>
          <target state="translated">The source of the event can be retrieved with the method event.getSource.</target>
        </trans-unit>
        <trans-unit id="ba472d8058ce42e7759745b4cd537b6da4c0628f" translate="yes" xml:space="preserve">
          <source>The source of this event is the SSLSocket on which handshaking just completed.</source>
          <target state="translated">이 이벤트의 소스는 핸드 쉐이킹이 완료된 SSLSocket입니다.</target>
        </trans-unit>
        <trans-unit id="34b28226ae9b0c9b05be3b2b72d0f78f8a72db57" translate="yes" xml:space="preserve">
          <source>The source of this pattern</source>
          <target state="translated">이 패턴의 근원</target>
        </trans-unit>
        <trans-unit id="9d040b79148889dda3be3cace827402195b26754" translate="yes" xml:space="preserve">
          <source>The source region of interest specified by this method will be clipped as needed to fit within the source bounds, as well as the destination offsets, width, and height at the time of actual I/O.</source>
          <target state="translated">이 방법으로 지정된 소스 관심 영역은 실제 I / O시 대상 오프셋, 너비 및 높이뿐만 아니라 소스 경계 내에 맞추기 위해 필요에 따라 잘립니다.</target>
        </trans-unit>
        <trans-unit id="6c425edd2b72c5bd49ce0000e1e9c0d010d1b680" translate="yes" xml:space="preserve">
          <source>The source region, on &lt;code&gt;null&lt;/code&gt; if none is set.</source>
          <target state="translated">소스 영역 . 설정되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79992770a23d8083e338e39d04240948297bfa86" translate="yes" xml:space="preserve">
          <source>The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected.</source>
          <target state="translated">간섭이 감지되지 않기 때문에 통과가 시작된 후 소스는 임의의 비 결정적 동작의 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d10c68f89f90c7178d019f1f4c1c12f009d6876" translate="yes" xml:space="preserve">
          <source>The south layout constraint (bottom of container).</source>
          <target state="translated">The south layout constraint (bottom of container).</target>
        </trans-unit>
        <trans-unit id="e68ddcb7c0e62435f6fe1696214e8145cd3b4f3c" translate="yes" xml:space="preserve">
          <source>The south-east-resize cursor type.</source>
          <target state="translated">The south-east-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="73fec64518a4d7b3dec25260b8298e0b9bed5f17" translate="yes" xml:space="preserve">
          <source>The south-resize cursor type.</source>
          <target state="translated">The south-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="3b088fa20b66361bda186416ad335eb99b17d70b" translate="yes" xml:space="preserve">
          <source>The south-west-resize cursor type.</source>
          <target state="translated">The south-west-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="b1f69a5894aacc09dd4212a4b7863d5992a5dd30" translate="yes" xml:space="preserve">
          <source>The space between strings.</source>
          <target state="translated">The space between strings.</target>
        </trans-unit>
        <trans-unit id="7900bed2b0d5a0428294adba3589eaef49b81ef4" translate="yes" xml:space="preserve">
          <source>The space character &quot; &quot; is converted into a plus sign &quot;&lt;code&gt;+&lt;/code&gt;&quot;.</source>
          <target state="translated">공백 문자 &quot;&quot;는 더하기 부호 &quot; &lt;code&gt;+&lt;/code&gt; &quot; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="507149f00d63c959176bee1f4d30e062fc83fdd7" translate="yes" xml:space="preserve">
          <source>The special characters &quot;&lt;code&gt;.&lt;/code&gt;&quot;, &quot;&lt;code&gt;-&lt;/code&gt;&quot;, &quot;&lt;code&gt;*&lt;/code&gt;&quot;, and &quot;&lt;code&gt;_&lt;/code&gt;&quot; remain the same.</source>
          <target state="translated">특수 문자 &quot; &lt;code&gt;.&lt;/code&gt; &quot;, &quot; &lt;code&gt;-&lt;/code&gt; &quot;, &quot; &lt;code&gt;*&lt;/code&gt; &quot;및 &quot; &lt;code&gt;_&lt;/code&gt; &quot;는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="554ae3414c670a7436c25a4064ec6ae6a231747b" translate="yes" xml:space="preserve">
          <source>The special method &lt;a href=&quot;#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt;&lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</source>
          <target state="translated">The special method &lt;a href=&quot;#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt; &lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</target>
        </trans-unit>
        <trans-unit id="a9d1df01fb5b8d33027995ef22465c9c621f1abe" translate="yes" xml:space="preserve">
          <source>The special method &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt;&lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</source>
          <target state="translated">특수 메소드 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt; &lt;/a&gt; 은 지정된 권한으로 표시된 액세스 요청을 승인할지 거부 할지를 결정합니다. 기본 구현 호출</target>
        </trans-unit>
        <trans-unit id="0f63e638f0c9b18504ea41e24439a23387628a9a" translate="yes" xml:space="preserve">
          <source>The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;#UNKNOWN_ATTRIBUTE&quot;&gt;&lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</source>
          <target state="translated">The special strings &lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;#UNKNOWN_ATTRIBUTE&quot;&gt; &lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt; &lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</target>
        </trans-unit>
        <trans-unit id="32010eba7b4259d4453391d1922bfa0e43808b88" translate="yes" xml:space="preserve">
          <source>The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt;&lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</source>
          <target state="translated">&lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt; &lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt; &lt;/a&gt; 와 같은 의미로 특수 문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다 . 이를 통해 사용자는 클래스 압축없이 특정 속성을 거부, 제거 또는 비트 단위로 전달하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a13bd69809d0a0a05735ac36655ba584ce36412" translate="yes" xml:space="preserve">
          <source>The special value 0 instructs the packer to copy through the original JAR file directly, with no compression. The JSR 200 standard requires any unpacker to understand this special case as a pass-through of the entire archive.</source>
          <target state="translated">특수 값 0은 압축하지 않고 패커가 원본 JAR 파일을 직접 복사하도록 지시합니다. JSR 200 표준은 압축 풀기 사용자가이 특수 사례를 전체 아카이브의 통과로 이해하도록 요구합니다.</target>
        </trans-unit>
        <trans-unit id="d43aa293b92f885948dfdec9b93e9f6263ba164c" translate="yes" xml:space="preserve">
          <source>The specialized subtype default implementations of &lt;a href=&quot;iterator#next()&quot;&gt;&lt;code&gt;Iterator.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining(java.util.function.Consumer)&quot;&gt;&lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt()&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next()&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.Consumer)&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The specialized subtype default implementations of &lt;a href=&quot;iterator#next()&quot;&gt; &lt;code&gt;Iterator.next()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining(java.util.function.Consumer)&quot;&gt; &lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt()&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next()&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.Consumer)&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bb3de17aa29974030176e4818ff90fa588d4cccd" translate="yes" xml:space="preserve">
          <source>The specialized subtype default implementations of &lt;a href=&quot;iterator#next--&quot;&gt;&lt;code&gt;Iterator.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator#next--&quot;&gt; &lt;code&gt;Iterator.next()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt; 상자 기본 값 의 특수 하위 유형 기본 구현은 해당 랩퍼 클래스의 인스턴스에 적용됩니다. 이러한 복싱은 원시 전문화를 사용할 때 얻는 모든 이점을 상쇄 할 수 있습니다. 복싱을 피하려면 해당하는 기본 기반 방법을 사용해야합니다. 예를 들어 &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;) 보다 우선적으로 사용해야합니다. 소비자) .</target>
        </trans-unit>
        <trans-unit id="50f407aa7fac51cbfd7197c06936b8340a15f9e5" translate="yes" xml:space="preserve">
          <source>The specification and implementation titles, versions, and vendors are unspecified.</source>
          <target state="translated">The specification and implementation titles, versions, and vendors are unspecified.</target>
        </trans-unit>
        <trans-unit id="d6f9034bc2b0e9e47c35477b9b0c1050884a6e58" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#floatDWidth&quot;&gt;width&lt;/a&gt; and &lt;a href=&quot;#floatDPrec&quot;&gt;precision&lt;/a&gt; is the same as defined for Float and Double.</source>
          <target state="translated">&lt;a href=&quot;#floatDWidth&quot;&gt;너비&lt;/a&gt; 와 &lt;a href=&quot;#floatDPrec&quot;&gt;정밀도&lt;/a&gt; 의 지정은 Float 및 Double에 정의 된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fa9ee937f65b438b3e28d90ed076c5fb130b0ebe" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#intWidth&quot;&gt;width&lt;/a&gt; is the same as defined for Byte, Short, Integer, and Long.</source>
          <target state="translated">의 사양 &lt;a href=&quot;#intWidth&quot;&gt;폭은&lt;/a&gt; Byte, Short, Integer, 및 Long로 정의 된 사양과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a10ca3cba79e422f1740bb3e0934c522a4f1925b" translate="yes" xml:space="preserve">
          <source>The specification of the &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;java.nio.charset.Charset&lt;/code&gt;&lt;/a&gt; class describes the naming conventions for character encodings as well as the set of standard encodings that must be supported by every implementation of the Java platform.</source>
          <target state="translated">&lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;java.nio.charset.Charset&lt;/code&gt; &lt;/a&gt; 클래스 의 스펙은 문자 인코딩의 이름 지정 규칙과 Java 플랫폼의 모든 구현에서 지원해야하는 표준 인코딩 세트를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5bc479f4b94e6ed3adb52c78855a8eaf971be4f5" translate="yes" xml:space="preserve">
          <source>The specifications of these methods enable implementations to employ efficient machine-level atomic instructions that are available on contemporary processors. However on some platforms, support may entail some form of internal locking. Thus the methods are not strictly guaranteed to be non-blocking -- a thread may block transiently before performing the operation.</source>
          <target state="translated">이러한 방법의 사양을 통해 구현시 최신 프로세서에서 사용할 수있는 효율적인 기계 수준의 원자 명령어를 사용할 수 있습니다. 그러나 일부 플랫폼에서는 일부 형태의 내부 잠금이 지원 될 수 있습니다. 따라서이 방법은 비 차단임을 반드시 보장하지는 않습니다. 작업을 수행하기 전에 스레드가 일시적으로 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">지정된</target>
        </trans-unit>
        <trans-unit id="62478b55800b13e9edc844048f06d81a5395c823" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;SecretKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;SecretKeyEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce6192f33f7b86e9ead09fddf2eb53ecad7d96e2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="d471977883e3ea29098c508c72fa94025049aa80" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; are cloned before they are stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;chain&lt;/code&gt; 과 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 개체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="feecfb1f75d3f2369d375a91acbc68cab6f7dc08" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;chain&lt;/code&gt; 은 새로운 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="91787ab6a545bac8438e8b3009f062a3b8a33372" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;name&lt;/code&gt; cannot begin with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, since all classes in the &quot;&lt;code&gt;java.*&lt;/code&gt; packages can only be defined by the bootstrap class loader. If &lt;code&gt;name&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be equal to the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class specified by the byte array &quot;&lt;code&gt;b&lt;/code&gt;&quot;, otherwise a &lt;a href=&quot;noclassdeffounderror&quot;&gt;&lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">&quot; &lt;code&gt;java.*&lt;/code&gt; 패키지 의 모든 클래스 는 부트 스트랩 클래스 로더로만 정의 할 수 있으므로 지정된 &lt;code&gt;name&lt;/code&gt; 은&quot; &lt;code&gt;java.&lt;/code&gt; &quot;로 시작할 수 없습니다 . &lt;code&gt;name&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 , 지정된 클래스 의 &lt;a href=&quot;#name&quot;&gt;이진 이름&lt;/a&gt; 과 같아야합니다. 바이트 배열 &quot; &lt;code&gt;b&lt;/code&gt; &quot;, 그렇지 않으면 &lt;a href=&quot;noclassdeffounderror&quot;&gt; &lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eaef74f38f0fefbf6b797c4d769b36b62a96e610" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;password&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PasswordProtection&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;password&lt;/code&gt; 는 새 &lt;code&gt;PasswordProtection&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="c18dc4bf1e553fd51a6ef779b53c94ede909086a" translate="yes" xml:space="preserve">
          <source>The specified MBean does not exist in the repository.</source>
          <target state="translated">지정된 MBean이 저장소에 없습니다.</target>
        </trans-unit>
        <trans-unit id="1da5f575f6552b129ebced03a3fcca62b2e49042" translate="yes" xml:space="preserve">
          <source>The specified MBean listener does not exist in the repository.</source>
          <target state="translated">지정된 MBean 리스너가 저장소에 없습니다.</target>
        </trans-unit>
        <trans-unit id="af5fc804aa4841cb6f3309cca620e06c665f28ff" translate="yes" xml:space="preserve">
          <source>The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt;. Other types are interpreted using &lt;a href=&quot;#from(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;from(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt; . Other types are interpreted using &lt;a href=&quot;#from(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;from(TemporalAmount)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="190c4561e923b6d02247206d09c8f34b9f935a7d" translate="yes" xml:space="preserve">
          <source>The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt;. Other types are interpreted using &lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;from(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 금액은 일반적으로 &lt;code&gt;Period&lt;/code&gt; 인스턴스입니다 . 다른 유형은 &lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;from(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f3bf406b8fb479bb6ba897f4dfcf1ddc3eae351" translate="yes" xml:space="preserve">
          <source>The specified amount of real time has elapsed, more or less. If &lt;code&gt;timeout&lt;/code&gt; is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</source>
          <target state="translated">지정된 실시간 시간이 다소 경과했습니다. 그러나 &lt;code&gt;timeout&lt;/code&gt; 가 0이면 실시간이 고려되지 않고 스레드가 통지 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="00452a58dccb117675d49a429b178f798add4786" translate="yes" xml:space="preserve">
          <source>The specified amount of real time has elapsed, more or less. The amount of real time, in nanoseconds, is given by the expression &lt;code&gt;1000000 * timeoutMillis + nanos&lt;/code&gt;. If &lt;code&gt;timeoutMillis&lt;/code&gt; and &lt;code&gt;nanos&lt;/code&gt; are both zero, then real time is not taken into consideration and the thread waits until awakened by one of the other causes.</source>
          <target state="translated">The specified amount of real time has elapsed, more or less. The amount of real time, in nanoseconds, is given by the expression &lt;code&gt;1000000 * timeoutMillis + nanos&lt;/code&gt; . If &lt;code&gt;timeoutMillis&lt;/code&gt; and &lt;code&gt;nanos&lt;/code&gt; are both zero, then real time is not taken into consideration and the thread waits until awakened by one of the other causes.</target>
        </trans-unit>
        <trans-unit id="2fb0d14ec3b91bd96d9fc6ab5161cd7aea17ba63" translate="yes" xml:space="preserve">
          <source>The specified attribute does not exist or cannot be retrieved.</source>
          <target state="translated">지정된 속성이 존재하지 않거나 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c4052d464c8f6871afa7336bc62a9e77ae7434b" translate="yes" xml:space="preserve">
          <source>The specified comparator is used to determine if two array elements from the each array are not equal.</source>
          <target state="translated">The specified comparator is used to determine if two array elements from the each array are not equal.</target>
        </trans-unit>
        <trans-unit id="7b8d3e0653b6d1561f69a4fc51247490be2c9fff" translate="yes" xml:space="preserve">
          <source>The specified deadline elapses; or</source>
          <target state="translated">지정된 마감 시간이 경과합니다. 또는</target>
        </trans-unit>
        <trans-unit id="dfc1facec1624a9e49107544937a16179ab58cc9" translate="yes" xml:space="preserve">
          <source>The specified deadline passes; or</source>
          <target state="translated">지정된 마감일이 지났습니다. 또는</target>
        </trans-unit>
        <trans-unit id="5247131e5691f2b17d264ef1c3dfc670058c9a69" translate="yes" xml:space="preserve">
          <source>The specified default value.</source>
          <target state="translated">지정된 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5b4866a14164fbbb9168f172b4e6e8d7dc395270" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances.</source>
          <target state="translated">The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances.</target>
        </trans-unit>
        <trans-unit id="f68d5b41f2fafda46b89738c8f86f8e066852d0c" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances. If there is no exact match, the closest match is used.</source>
          <target state="translated">The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances. If there is no exact match, the closest match is used.</target>
        </trans-unit>
        <trans-unit id="310ae4a82260e2743fd9957091b33702914d499e" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching MediaSize instance from amongst all the standard MediaSize instances. If there is no exact match, the closest match is used.</source>
          <target state="translated">지정된 차원은 모든 표준 MediaSize 인스턴스에서 일치하는 MediaSize 인스턴스를 찾는 데 사용됩니다. 정확히 일치하는 것이 없으면 가장 가까운 일치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="104dce0f8cf047aa941594c95f88524f18e28ce2" translate="yes" xml:space="preserve">
          <source>The specified list must be modifiable, but need not be resizable.</source>
          <target state="translated">지정된 목록은 수정 가능해야하지만 크기를 조정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f09ffd7e81a93fd6948e5a765fff32edb59db61" translate="yes" xml:space="preserve">
          <source>The specified map contains the current state of the parse. The map is mutable and must be mutated to resolve the field and any related fields. This method will only be invoked during parsing if the map contains this field, and implementations should therefore assume this field is present.</source>
          <target state="translated">지정된 맵에는 구문 분석의 현재 상태가 포함됩니다. 맵은 변경 가능하며 필드 및 관련 필드를 해결하려면 변경해야합니다. 이 메소드는 맵에이 필드가 포함 된 경우 구문 분석 중에 만 호출되므로 구현시이 필드가 있다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="493032b220120145406a2c95c31eb22182fdc14e" translate="yes" xml:space="preserve">
          <source>The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:</source>
          <target state="translated">지정된 맵은이 메소드가 호출 될 때 비어 있어야하며이 메소드가 리턴 된 후 직접 액세스해서는 안됩니다. 다음 코드 조각에 표시된대로 맵이 비어 있고이 메소드에 직접 전달되고 맵에 대한 참조가 유지되지 않으면 이러한 조건이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="e8d2949ab1852b4adf83258648df2f3d3aea9bdc" translate="yes" xml:space="preserve">
          <source>The specified number of bytes have been read,</source>
          <target state="translated">지정된 바이트 수를 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="04268be0844ec6f86b3371c45be5d6b167be71f6" translate="yes" xml:space="preserve">
          <source>The specified number of characters have been read,</source>
          <target state="translated">지정된 수의 문자를 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="8b6cc3dc228a55bbb5be0ad0c4aa456b38c93c73" translate="yes" xml:space="preserve">
          <source>The specified stream is closed after this method returns.</source>
          <target state="translated">이 메소드가 반환 된 후 지정된 스트림이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="51786fb87bcf180e4b0079696fd451f32baf2367" translate="yes" xml:space="preserve">
          <source>The specified stream remains open after this method returns.</source>
          <target state="translated">지정된 스트림은이 메서드가 반환 된 후에도 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="7526737a0fdb5c1ec28cb0f7e645a738da9f21ee" translate="yes" xml:space="preserve">
          <source>The specified string</source>
          <target state="translated">지정된 문자열</target>
        </trans-unit>
        <trans-unit id="020eb4b0a71ae7c3e458a5afa3348d57de83d3bc" translate="yes" xml:space="preserve">
          <source>The specified substring. If the sum of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; exceeds the &lt;code&gt;length&lt;/code&gt;, then all 16-bit units to the end of the data are returned.</source>
          <target state="translated">The specified substring. If the sum of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; exceeds the &lt;code&gt;length&lt;/code&gt; , then all 16-bit units to the end of the data are returned.</target>
        </trans-unit>
        <trans-unit id="2615e62cfbfda5abfd51b12dbda35048bb40079b" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units added.</source>
          <target state="translated">지정된 시간은이 기간과 동일한 연대기를 가져야합니다. 0이 아닌 지원 단위가 추가 된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="157250d9b4b02aeb6925cbf93c8ae0c1bd6e00ac" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units subtracted.</source>
          <target state="translated">지정된 시간은이 기간과 동일한 연대기를 가져야합니다. 0이 아닌 지원 단위를 뺀 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc9a505a8f5c31216ff0ecff5662a313bc10a9ec" translate="yes" xml:space="preserve">
          <source>The specified temporal objects must support the &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt; unit. For full accuracy, either the &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt; unit or the &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; field should be supported.</source>
          <target state="translated">지정된 임시 오브젝트는 &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt; 단위를 지원해야합니다 . 정확성을 &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt; 려면 NANOS 장치 또는 &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 필드가 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9126ea58e2571bc036db8beb3f6e7cb81714d752" translate="yes" xml:space="preserve">
          <source>The specified timeout elapses; or</source>
          <target state="translated">지정된 시간이 초과되었습니다. 또는</target>
        </trans-unit>
        <trans-unit id="77816529a97b17e719694d443a16cc6eb0b2358f" translate="yes" xml:space="preserve">
          <source>The specified value is used for components that do not have an explicit visibility specified.</source>
          <target state="translated">The specified value is used for components that do not have an explicit visibility specified.</target>
        </trans-unit>
        <trans-unit id="b837498e4f5bfb7ecf362b5a40901bb42bb72876" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses</source>
          <target state="translated">지정된 대기 시간이 경과합니다</target>
        </trans-unit>
        <trans-unit id="2e16f4e41d2bec157ff32585a40c8df18c39455f" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses.</source>
          <target state="translated">지정된 대기 시간이 경과합니다.</target>
        </trans-unit>
        <trans-unit id="f6172c989e04cb91e71e97089eeadbcfd41054bf" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses; or</source>
          <target state="translated">지정된 대기 시간이 경과합니다. 또는</target>
        </trans-unit>
        <trans-unit id="bcb09cd9d5c1d9cff3d8db3594d6e42aab3b0b8d" translate="yes" xml:space="preserve">
          <source>The spinner that we're a UI delegate for.</source>
          <target state="translated">The spinner that we're a UI delegate for.</target>
        </trans-unit>
        <trans-unit id="97f64657e5f059399930d54a08e9b83baa27ae28" translate="yes" xml:space="preserve">
          <source>The spinner that we're a UI delegate for. Initialized by the &lt;code&gt;installUI&lt;/code&gt; method, and reset to null by &lt;code&gt;uninstallUI&lt;/code&gt;.</source>
          <target state="translated">The spinner that we're a UI delegate for. Initialized by the &lt;code&gt;installUI&lt;/code&gt; method, and reset to null by &lt;code&gt;uninstallUI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d585405edcff8efbfeceb28b75b5f670d57bbe62" translate="yes" xml:space="preserve">
          <source>The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts.</source>
          <target state="translated">The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts.</target>
        </trans-unit>
        <trans-unit id="799c8129c9adc3cde63003661b566735c720a9dc" translate="yes" xml:space="preserve">
          <source>The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts. The splash screen is displayed as an undecorated window containing an image. You can use GIF, JPEG, or PNG files for the image. Animation is supported for the GIF format, while transparency is supported both for GIF and PNG. The window is positioned at the center of the screen. The position on multi-monitor systems is not specified. It is platform and implementation dependent. The splash screen window is closed automatically as soon as the first window is displayed by Swing/AWT (may be also closed manually using the Java API, see below).</source>
          <target state="translated">The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts. The splash screen is displayed as an undecorated window containing an image. You can use GIF, JPEG, or PNG files for the image. Animation is supported for the GIF format, while transparency is supported both for GIF and PNG. The window is positioned at the center of the screen. The position on multi-monitor systems is not specified. It is platform and implementation dependent. The splash screen window is closed automatically as soon as the first window is displayed by Swing/AWT (may be also closed manually using the Java API, see below).</target>
        </trans-unit>
        <trans-unit id="b1c8f20ff40da3f5e74a84ba6b16f559f12b32df" translate="yes" xml:space="preserve">
          <source>The splash screen will be displayed as faithfully as possible to present the whole splash screen image given the limitations of the target platform and display.</source>
          <target state="translated">The splash screen will be displayed as faithfully as possible to present the whole splash screen image given the limitations of the target platform and display.</target>
        </trans-unit>
        <trans-unit id="358fe8f4c03c65db9f92645925be98830ef03da4" translate="yes" xml:space="preserve">
          <source>The spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the collection's iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">spliterator는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;늦게 바인딩&lt;/a&gt;&lt;/em&gt; 되고 컬렉션 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 속성을 상속하며 제한된 병렬 처리를 허용하도록 &lt;code&gt;trySplit&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="5c3d939c98fbccf6b0709b1993b6b3ad3fbfd412" translate="yes" xml:space="preserve">
          <source>The spliterator is not &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">spliterator는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;늦게 바인딩&lt;/a&gt;&lt;/em&gt; 되지 않고 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 속성을 상속하며 제한된 병렬 처리를 허용하기 위해 &lt;code&gt;trySplit&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="c89136b191a7ef1fb716259822efc70d2b8982ba" translate="yes" xml:space="preserve">
          <source>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences.</source>
          <target state="translated">스플리터는 스트림 파이프 라인의 터미널 작업이 시작된 후 예상 크기에 대해서만 순회, 스플릿 또는 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="2e796cc75190234b6abcae4603bbe835004bc5ff" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the list when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">스플리터는 스플리터가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 스플리터에서 작동하는 동안 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb6fc47357accd5ef236f3f5c242ba1b0d8c1cb4" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the set when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">스플리터는 스플리터가 구성 될 때 세트 상태의 스냅 샷을 제공합니다. 스플리터에서 작동하는 동안 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c63ef1d32be1189c32d967974dfe2fc9a2f274a" translate="yes" xml:space="preserve">
          <source>The spliterator reports &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt;&lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스플리터는 &lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt; &lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt; 을보고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c0e1fd6ad7e570320cb5c4dec58534b0c8203896" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;../spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the set's comparator (see &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the set's comparator.</source>
          <target state="translated">세트의 비교 자 ( &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;../spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면, 스플리터의 비교기는 세트의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="fe057f9948defb315751a3ca1f88f4994c9e14dd" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;sortedset#comparator()&quot;&gt;&lt;code&gt;SortedSet.comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</source>
          <target state="translated">The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;sortedset#comparator()&quot;&gt; &lt;code&gt;SortedSet.comparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; . Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</target>
        </trans-unit>
        <trans-unit id="f6b692dffef505c29f727633715bcaa25d9f58af" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) must be &lt;code&gt;null&lt;/code&gt; if the sorted set's comparator (see &lt;a href=&quot;#comparator()&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.</source>
          <target state="translated">정렬 된 세트의 비교기 ( &lt;a href=&quot;#comparator()&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우 분할기의 비교기 ( &lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 이어야합니다 . 그렇지 않으면 분할기의 비교기는 정렬 된 세트의 비교기와 동일하거나 동일한 총 순서를 부과해야합니다.</target>
        </trans-unit>
        <trans-unit id="48dde829f5e209bbf80a37d8886c87c609c3d85b" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;treeset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</source>
          <target state="translated">트리 세트의 비교 자 ( &lt;a href=&quot;treeset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기는 트리 세트의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="5d0a078e5e6eab06b16fc00059f9764476f503fd" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) must be &lt;code&gt;null&lt;/code&gt; if the sorted set's comparator (see &lt;a href=&quot;sortedset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.</source>
          <target state="translated">정렬 된 세트의 비교기 ( &lt;a href=&quot;sortedset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, 분할기의 비교기 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 이어야합니다 . 그렇지 않으면 스플리터의 비교기가 정렬 된 세트의 비교기와 동일하거나 동일한 총 순서를 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="81c6f54339613405ef47fa4cf7fd2cfc6963fe4e" translate="yes" xml:space="preserve">
          <source>The spliterators for &lt;code&gt;Collection&lt;/code&gt; classes in the JDK that implement &lt;a href=&quot;navigableset&quot;&gt;&lt;code&gt;NavigableSet&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sortedset&quot;&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; report &lt;code&gt;SORTED&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;navigableset&quot;&gt; &lt;code&gt;NavigableSet&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sortedset&quot;&gt; &lt;code&gt;SortedSet&lt;/code&gt; &lt;/a&gt; 보고서 를 구현하는 JDK의 &lt;code&gt;Collection&lt;/code&gt; 클래스에 대한 스플리터는 &lt;code&gt;SORTED&lt;/code&gt; 를 보고 합니다 .</target>
        </trans-unit>
        <trans-unit id="cd697bf3371b30cc43133d20204f9b133ffb8c0e" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally report &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스의 모든 콜렉션 뷰 메소드에 의해 리턴 된 콜렉션의 spliterator 메소드에 의해 리턴 된 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 및 추가로 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를&lt;/a&gt; 보고 합니다 .</target>
        </trans-unit>
        <trans-unit id="3f5421d4c1a6fd2ddf5564c1dd18506c0df41358" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are created from the iterators of the corresponding collections.</source>
          <target state="translated">이 클래스의 모든 콜렉션 뷰 메소드에 의해 리턴 된 콜렉션의 spliterator 메소드에 의해 리턴 된 스플리터는 대응하는 콜렉션의 반복자로부터 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9f0eea49dd34a9dc6611340a54bee1813909e27a" translate="yes" xml:space="preserve">
          <source>The square root of a number numerically equal to &lt;code&gt;
 ZERO&lt;/code&gt; is numerically equal to &lt;code&gt;ZERO&lt;/code&gt; with a preferred scale according to the general rule above. In particular, for &lt;code&gt;ZERO&lt;/code&gt;, &lt;code&gt;ZERO.sqrt(mc).equals(ZERO)&lt;/code&gt; is true with any &lt;code&gt;MathContext&lt;/code&gt; as an argument.</source>
          <target state="translated">숫자와 동일한 숫자의 제곱근 &lt;code&gt; ZERO&lt;/code&gt; 는 같은 수치 &lt;code&gt;ZERO&lt;/code&gt; 위의 일반 규칙에 따라 바람직한 스케일. 특히 &lt;code&gt;ZERO&lt;/code&gt; 의 경우 &lt;code&gt;ZERO.sqrt(mc).equals(ZERO)&lt;/code&gt; 는 &lt;code&gt;MathContext&lt;/code&gt; 를 인수로 사용하여 true입니다 .</target>
        </trans-unit>
        <trans-unit id="97a32597a130645adffb584e7165020d15f080bc" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; values are:</source>
          <target state="translated">표준 &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec658a969bcb92aa1baad080b6a1974cf0ea66e2" translate="yes" xml:space="preserve">
          <source>The standard AC chrominance Huffman table.</source>
          <target state="translated">표준 AC 색차 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="de7f2a4797f9371ba730de4782f10f7289878bf4" translate="yes" xml:space="preserve">
          <source>The standard AC luminance Huffman table.</source>
          <target state="translated">표준 AC 휘도 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="c018ce1af2d766ca3e1a4abc0ceaf42164f207ce" translate="yes" xml:space="preserve">
          <source>The standard DC chrominance Huffman table.</source>
          <target state="translated">표준 DC 색차 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="a329f8b4144b879c7b6f5ae550949bccdbf73f49" translate="yes" xml:space="preserve">
          <source>The standard DC luminance Huffman table.</source>
          <target state="translated">표준 DC 휘도 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="db8c6341d94f5edfcecbdce8b46d6840a2f9998a" translate="yes" xml:space="preserve">
          <source>The standard MultipleDocumentHandling values are:</source>
          <target state="translated">표준 MultipleDocumentHandling 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cea92758ea1f357e469fa3131a98d496ed04fb3d" translate="yes" xml:space="preserve">
          <source>The standard WebRowSet XML Schema definition is available at the following URI:</source>
          <target state="translated">표준 WebRowSet XML 스키마 정의는 다음 URI에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92cab317859f368c1aae7d7671cb740196644a9d" translate="yes" xml:space="preserve">
          <source>The standard astronomical definition uses a fraction to indicate the time-of-day, thus 3.25 would represent the time 18:00, since days start at midday. This implementation uses an integer and days starting at midnight. The integer value for the Julian Day Number is the astronomical Julian Day value at midday of the date in question. This amounts to the astronomical Julian Day, rounded to an integer &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt;.</source>
          <target state="translated">표준 천문학적 정의는 분수를 사용하여 하루 중 시간을 나타내므로 하루가 정오에 시작하므로 3.25는 18:00 시간을 나타냅니다. 이 구현은 자정에 시작하는 정수와 요일을 사용합니다. Julian Day Number의 정수 값은 해당 날짜의 정오에 천문학적 Julian Day 값입니다. 이것은 천문학적 줄리안 데이에 해당하며 정수 &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt; 반올림됩니다 .</target>
        </trans-unit>
        <trans-unit id="880ecebc89a3bd9ce7264ab7dfc0e29562f0f35f" translate="yes" xml:space="preserve">
          <source>The standard astronomical definition uses a fraction to indicate the time-of-day, where each day is counted from midday to midday. For example, a fraction of 0 represents midday, a fraction of 0.25 represents 18:00, a fraction of 0.5 represents midnight and a fraction of 0.75 represents 06:00.</source>
          <target state="translated">표준 천문학적 정의는 분수를 사용하여 하루 중 시간을 나타내며 매일 정오부터 정오까지 계산됩니다. 예를 들어, 분수 0은 정오를 나타내고 0.25는 18:00를, 0.5는 자정을, 0.75는 06:00을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13ecff8dc7f4fb8e1c0a2ecc7b63b91ab8bf3498" translate="yes" xml:space="preserve">
          <source>The standard bold weight.</source>
          <target state="translated">표준 굵은 무게.</target>
        </trans-unit>
        <trans-unit id="87015164736bf1cd9c8bbb4ea24b900496c33f69" translate="yes" xml:space="preserve">
          <source>The standard class for rendering (displaying) individual cells in a &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; 에서 개별 셀을 렌더링 (표시)하기위한 표준 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="42ca28b6f9992a10a95b6a95ebf901f9b15239be" translate="yes" xml:space="preserve">
          <source>The standard classes and interfaces that a third party vendor has to use in its implementation of a synchronization provider.</source>
          <target state="translated">타사 공급 업체가 동기화 공급자 구현에 사용해야하는 표준 클래스 및 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f20e3d89b127e95d58c2061d7d4c9dd74ba0ee75" translate="yes" xml:space="preserve">
          <source>The standard classes and interfaces that a third party vendor has to use in its implementation of a synchronization provider. These classes and interfaces are referred to as the Service Provider Interface (SPI). To make it possible for a &lt;code&gt;RowSet&lt;/code&gt; object to use an implementation, the vendor must register it with the &lt;code&gt;SyncFactory&lt;/code&gt; singleton. (See the class comment for &lt;code&gt;SyncProvider&lt;/code&gt; for a full explanation of the registration process and the naming convention to be used.)</source>
          <target state="translated">타사 공급 업체가 동기화 공급자 구현에 사용해야하는 표준 클래스 및 인터페이스입니다. 이러한 클래스와 인터페이스를 SPI (서비스 공급자 인터페이스)라고합니다. &lt;code&gt;RowSet&lt;/code&gt; 객체가 구현을 사용할 수 있도록하려면 공급 업체가이를 &lt;code&gt;SyncFactory&lt;/code&gt; 싱글 톤에 등록해야합니다 . ( 등록 프로세스 및 사용할 명명 규칙에 대한 전체 설명은 &lt;code&gt;SyncProvider&lt;/code&gt; 에 대한 클래스 주석을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b131b8a4797ef2827907440045a418e64b3fbf06" translate="yes" xml:space="preserve">
          <source>The standard column-handler for a &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; 의 표준 열 처리기입니다 .</target>
        </trans-unit>
        <trans-unit id="ebd97f6234307a116f96853fd3903e56b9d40331" translate="yes" xml:space="preserve">
          <source>The standard default domain name is &lt;code&gt;DefaultDomain&lt;/code&gt;.</source>
          <target state="translated">표준 기본 도메인 이름은 &lt;code&gt;DefaultDomain&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef55295fde5154a258f26679975fa232098fcdbf" translate="yes" xml:space="preserve">
          <source>The standard file manager serves two purposes:</source>
          <target state="translated">표준 파일 관리자는 두 가지 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7ea3f0338f77cf538431691011f031baff3b34" translate="yes" xml:space="preserve">
          <source>The standard file manager will be automatically reopened if it is accessed after calls to &lt;code&gt;flush&lt;/code&gt; or &lt;code&gt;close&lt;/code&gt;. The standard file manager must be usable with other tools.</source>
          <target state="translated">표준 파일 관리자는 &lt;code&gt;flush&lt;/code&gt; 또는 &lt;code&gt;close&lt;/code&gt; 호출 후 액세스되면 자동으로 다시 열립니다 . 표준 파일 관리자는 다른 도구와 함께 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d899fd7b1f2ffca29d5ec4be5ab688999a5e0e42" translate="yes" xml:space="preserve">
          <source>The standard interface that all implementations of a &lt;code&gt;WebRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;WebRowSet&lt;/code&gt; 의 모든 구현이 구현해야하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="68aac4cc5c3cf5132e5aff63b1695213f60c720d" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;FilteredRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;FilteredRowSet&lt;/code&gt; 의 모든 표준 구현이 구현해야하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="247ee5b52f4343f5290a6af4a99cb5a09ea9f68c" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;FilteredRowSet&lt;/code&gt; must implement. The &lt;code&gt;FilteredRowSetImpl&lt;/code&gt; class provides the reference implementation which may be extended if required. Alternatively, a vendor is free to implement its own version by implementing this interface.</source>
          <target state="translated">&lt;code&gt;FilteredRowSet&lt;/code&gt; 의 모든 표준 구현이 구현해야하는 표준 인터페이스입니다 . &lt;code&gt;FilteredRowSetImpl&lt;/code&gt; 의 클래스는 필요하다면 연장 될 수도 참조 구현을 제공한다. 또는 공급 업체는이 인터페이스를 구현하여 자체 버전을 자유롭게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4179729038e158c2938276999d2a0f8a9a828d40" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;JdbcRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;JdbcRowSet&lt;/code&gt; 의 모든 표준 구현이 구현해야하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="bbf8d9d8dbd72ecf1f4215ba8e97cd7badb383b6" translate="yes" xml:space="preserve">
          <source>The standard interface that provides the framework for all &lt;code&gt;FilteredRowSet&lt;/code&gt; objects to describe their filters.</source>
          <target state="translated">필터를 설명하는 모든 &lt;code&gt;FilteredRowSet&lt;/code&gt; 개체에 대한 프레임 워크를 제공하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="f8f169d2bb832c35eba59bc410c0b85f0003b6f8" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key.</source>
          <target state="translated">DSA 개인 키에 대한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="be4242d6a22a82129b32c761e9b997ab8bdb7b76" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key. DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186.</source>
          <target state="translated">DSA 개인 키에 대한 표준 인터페이스입니다. DSA (Digital Signature Algorithm)는 NIST의 FIPS-186에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aee232c28f9de3b58df1a19a8e2a72c95efd9f7" translate="yes" xml:space="preserve">
          <source>The standard italic posture.</source>
          <target state="translated">표준 이탤릭체 자세.</target>
        </trans-unit>
        <trans-unit id="265e9fc158c49896c41933585c842cef5b8e987f" translate="yes" xml:space="preserve">
          <source>The standard layer, where most components go. This the bottommost layer.</source>
          <target state="translated">대부분의 구성 요소가 들어가는 표준 레이어입니다. 이것은 맨 아래 레이어입니다.</target>
        </trans-unit>
        <trans-unit id="7b2b71d5aa7e1b0b260acaadc43d3221dce05731" translate="yes" xml:space="preserve">
          <source>The standard light weight.</source>
          <target state="translated">표준 경량입니다.</target>
        </trans-unit>
        <trans-unit id="a8d8726b4a5a07328b176cca7d74f5e2a761a964" translate="yes" xml:space="preserve">
          <source>The standard mapping in the Java programming language for an SQL structured type.</source>
          <target state="translated">SQL 구조화 유형에 대한 Java 프로그래밍 언어의 표준 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="c2eeb32dafb015f6f93305e7066122591f181fc8" translate="yes" xml:space="preserve">
          <source>The standard mapping in the Java programming language for an SQL structured type. A &lt;code&gt;Struct&lt;/code&gt; object contains a value for each attribute of the SQL structured type that it represents. By default, an instance of&lt;code&gt;Struct&lt;/code&gt; is valid as long as the application has a reference to it.</source>
          <target state="translated">SQL 구조화 유형에 대한 Java 프로그래밍 언어의 표준 매핑입니다. &lt;code&gt;Struct&lt;/code&gt; 객체가 나타내는 SQL 구조형의 각 속성에 대한 값을 포함한다. 기본적으로 &lt;code&gt;Struct&lt;/code&gt; 의 인스턴스 는 응용 프로그램에 참조가있는 한 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c927c0ada9cba1ad53c2c1bf1aa34f20c5ec2c56" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">날짜의 표준 정신 모델은 세 가지 개념-년, 월 및 일을 기반으로합니다. 이들은 &lt;code&gt;YEAR&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 시대에 대한 언급은 없습니다. 날짜의 전체 모델에는 시대, 연도, 월, 일의 네 가지 개념이 필요합니다. 이들은 &lt;code&gt;ERA&lt;/code&gt; , &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 이 필드 또는 &lt;code&gt;YEAR&lt;/code&gt; 사용 여부는 사용중인 정신 모델에 따라 다릅니다. 이 주제에 대한 자세한 내용은 &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="552969cac10043f5eb1e8db38405b389d7505393" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">날짜의 표준 정신 모델은 세 가지 개념-년, 월 및 일을 기반으로합니다. 이지도는 &lt;code&gt;YEAR&lt;/code&gt; 에 &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 됩니다. 시대에 대한 언급은 없습니다. 날짜의 전체 모델에는 시대, 연도, 월, 일의 네 가지 개념이 필요합니다. 이들은 &lt;code&gt;ERA&lt;/code&gt; , &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 이 필드 또는 &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; 사용 여부는 사용중인 정신 모델에 따라 다릅니다. 이 주제에 대한 자세한 내용은 &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3661c18690ae34088219c95d1f642f9094ca6650" translate="yes" xml:space="preserve">
          <source>The standard posture, upright.</source>
          <target state="translated">표준 자세, 똑바로.</target>
        </trans-unit>
        <trans-unit id="bcac68430abf1f9b59c3fc0c0ced10c89898d656" translate="yes" xml:space="preserve">
          <source>The standard posture, upright. This is the default value for &lt;code&gt;POSTURE&lt;/code&gt;.</source>
          <target state="translated">표준 자세, 똑바로. 이것은 &lt;code&gt;POSTURE&lt;/code&gt; 의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="4204acbf3d5f3f85ee9f30f3059d6be897c6a196" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation name.</source>
          <target state="translated">동기화 공급자 구현 이름에 대한 표준 속성 ID입니다.</target>
        </trans-unit>
        <trans-unit id="80bb8e7243eb06e9dd0a04e994954134803a7ab1" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation vendor name.</source>
          <target state="translated">동기화 공급자 구현 공급 업체 이름의 표준 속성 ID입니다.</target>
        </trans-unit>
        <trans-unit id="f3300fc7bb9dd6b49894aeba609ac649a7e0edb1" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation version tag.</source>
          <target state="translated">동기화 공급자 구현 버전 태그의 표준 속성 ID입니다.</target>
        </trans-unit>
        <trans-unit id="f924447dc30c0a207a7a8dd003998719d641a65d" translate="yes" xml:space="preserve">
          <source>The standard reference implementation for the &lt;code&gt;CachedRowSet&lt;/code&gt; interface uses a &lt;code&gt;TreeMap&lt;/code&gt; object for the rowset, with the values in each row being contained in &lt;code&gt;Vector&lt;/code&gt; objects. It is expected that most implementations will do the same.</source>
          <target state="translated">&lt;code&gt;CachedRowSet&lt;/code&gt; 인터페이스에 대한 표준 참조 구현 은 행 집합에 대해 &lt;code&gt;TreeMap&lt;/code&gt; 개체를 사용하며 각 행의 값은 &lt;code&gt;Vector&lt;/code&gt; 개체 에 포함 됩니다. 대부분의 구현에서 동일한 작업을 수행 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="44003f488ebc1e70329a9b7e5361903f72e0de08" translate="yes" xml:space="preserve">
          <source>The standard reference implementation uses a &lt;code&gt;Vector&lt;/code&gt; object to contain the column values, and it is expected that most implementations will do the same. If a &lt;code&gt;Vector&lt;/code&gt; object is used, it size must be exactly equal to the number of rows in this &lt;code&gt;CachedRowSet&lt;/code&gt; object.</source>
          <target state="translated">표준 참조 구현은 &lt;code&gt;Vector&lt;/code&gt; 객체를 사용 하여 열 값을 포함하며 대부분의 구현에서 동일한 작업을 수행 할 것으로 예상됩니다. 경우 &lt;code&gt;Vector&lt;/code&gt; 객체가 사용되며, 그 크기는이 행의 수와 정확히 일치해야합니다 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5a269f562c7ddcb5223b4c729ca3aacff15045f7" translate="yes" xml:space="preserve">
          <source>The standard set of non-localized decimal style symbols.</source>
          <target state="translated">현지화되지 않은 10 진수 스타일 기호의 표준 세트입니다.</target>
        </trans-unit>
        <trans-unit id="2aa618fb16592d9504ead37dd1498e07dc1eb2fd" translate="yes" xml:space="preserve">
          <source>The standard target names for an Authentication Permission are:</source>
          <target state="translated">인증 권한의 표준 대상 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="085376bdd00c3589b2477d9a9b7e25e5aa764bdf" translate="yes" xml:space="preserve">
          <source>The standard text outputting methods use the localized text in the JDK. This method allows that text to be specified directly. The supplied map is not validated by the builder to ensure that formatting or parsing is possible, thus an invalid map may throw an error during later use.</source>
          <target state="translated">표준 텍스트 출력 방법은 JDK에서 지역화 된 텍스트를 사용합니다. 이 방법을 사용하면 해당 텍스트를 직접 지정할 수 있습니다. 제공된 맵은 형식화 또는 구문 분석이 가능한지 확인하기 위해 빌더에 의해 유효성 검증되지 않으므로 유효하지 않은 맵은 나중에 사용하는 동안 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace8ff3c243593fda8f90cc8a3f288d71a11483d" translate="yes" xml:space="preserve">
          <source>The standard value of the propertyName as fired from a BeanContext or other source of PropertyChangeEvents.</source>
          <target state="translated">BeanContext 또는 다른 PropertyChangeEvents 소스로부터 시작된 propertyName의 표준치입니다.</target>
        </trans-unit>
        <trans-unit id="49ec7e4579c545f03b2dbae2595c4136e74f5f2a" translate="yes" xml:space="preserve">
          <source>The standard weight.</source>
          <target state="translated">표준 무게입니다.</target>
        </trans-unit>
        <trans-unit id="062b0e97b7470f28f4677451830d828c09857342" translate="yes" xml:space="preserve">
          <source>The standard weight. This is the default value for &lt;code&gt;WEIGHT&lt;/code&gt;.</source>
          <target state="translated">표준 무게입니다. &lt;code&gt;WEIGHT&lt;/code&gt; 의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="5fa2e7b7afa217d5160022594a1240084ec90835" translate="yes" xml:space="preserve">
          <source>The standard width.</source>
          <target state="translated">표준 너비입니다.</target>
        </trans-unit>
        <trans-unit id="1ec1dd1d6de288f3d7a0a8ac09f8cd6fa6f29d04" translate="yes" xml:space="preserve">
          <source>The standard width. This is the default value for &lt;code&gt;WIDTH&lt;/code&gt;.</source>
          <target state="translated">표준 너비입니다. 이것은 &lt;code&gt;WIDTH&lt;/code&gt; 의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="f3bed9164e92a7973b9cbcd9ad79594c005f0947" translate="yes" xml:space="preserve">
          <source>The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date. The result will be negative if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 날짜이며 지정된 날짜입니다. 끝이 시작하기 전에 결과는 음수입니다. 음수 부호는 매년, 월, 일마다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3c2d246e90e00803aeb29283b1b8bc16d249d5bc" translate="yes" xml:space="preserve">
          <source>The start argument must be nonnegative, and not greater than &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">start 인수는 음이 아니어야하고 &lt;code&gt;end&lt;/code&gt; 보다 크지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="a4ddf7bb81f0c34d9260c89803dda3e7e413e128" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then normalized into years and months based on a 12 month year. A month is considered to be complete if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is &quot;1 year, 2 months and 3 days&quot;.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 완전한 월을 제거한 다음 남은 일 수를 계산하여 둘 다 동일한 부호를 갖도록 조정하여 계산됩니다. 그런 다음 월 수는 12 개월 연도를 기준으로 연도 및 월로 정규화됩니다. 월말이 시작일보다 크거나 같으면 한 달이 완료된 것으로 간주됩니다. 예를 들어 &lt;code&gt;2010-01-15&lt;/code&gt; 에서 &lt;code&gt;2011-03-18&lt;/code&gt; 은 &quot;1 년, 2 개월 및 3 일&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6620cb9be5fc56436fc3a7c1b18ff6874dd29e0c" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then split into years and months based on a 12 month year. A month is considered if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is one year, two months and three days.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 전체 월을 제거한 다음 남은 일 수를 계산하여 둘 다 동일한 부호를 갖도록 조정하여 계산됩니다. 그런 다음 월 수는 12 개월 연도를 기준으로 년과 월로 분할됩니다. 월말이 시작일보다 크거나 같은 경우 한 달로 간주됩니다. 예를 들어 &lt;code&gt;2010-01-15&lt;/code&gt; 에서 &lt;code&gt;2011-03-18&lt;/code&gt; 은 1 년, 2 개월 3 일입니다.</target>
        </trans-unit>
        <trans-unit id="7220f597737d970989890a2427aecffcbf28c9bf" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated using &lt;a href=&quot;chronolocaldate#until(java.time.chrono.ChronoLocalDate)&quot;&gt;&lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;. As such, the calculation is chronology specific.</source>
          <target state="translated">시작일은 포함되지만 종료일은 포함되지 않습니다. 기간은 &lt;a href=&quot;chronolocaldate#until(java.time.chrono.ChronoLocalDate)&quot;&gt; &lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 사용하여 계산됩니다 . 따라서 계산은 연대기별로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9238c2af9e0839f3491092fc2fe2b2c12cadecf1" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated using &lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;. As such, the calculation is chronology specific.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 &lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 사용하여 계산됩니다 . 따라서 계산은 시간순으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="4616505c5d1d5433c8afbd259a8f16eac5343c68" translate="yes" xml:space="preserve">
          <source>The start index of the text sequence.</source>
          <target state="translated">텍스트 시퀀스의 시작 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6becf8d53264f434379756115b0b786e11e4f8c2" translate="yes" xml:space="preserve">
          <source>The startDrag() method invokes the createDragSourceContext() method to instantiate an appropriate &lt;code&gt;DragSourceContext&lt;/code&gt; and associate the &lt;code&gt;DragSourceContextPeer&lt;/code&gt; with that.</source>
          <target state="translated">startDrag () 메소드는 적절한 인스턴스로 createDragSourceContext () 메소드 호출 &lt;code&gt;DragSourceContext&lt;/code&gt; 상기 연결 &lt;code&gt;DragSourceContextPeer&lt;/code&gt; 를을 그와 함께한다.</target>
        </trans-unit>
        <trans-unit id="82e2ccda6d83bc11eba880fd5d75e0aa357c29cd" translate="yes" xml:space="preserve">
          <source>The starting angle of the arc in degrees.</source>
          <target state="translated">호의 시작 각도 (도)입니다.</target>
        </trans-unit>
        <trans-unit id="2264eaa8f12a8a3d18c204a6414263d50eec329f" translate="yes" xml:space="preserve">
          <source>The starting point of this matcher's region</source>
          <target state="translated">이 매처 지역의 시작점</target>
        </trans-unit>
        <trans-unit id="711145c27ccf3166aa36ebb810ced05b44da407a" translate="yes" xml:space="preserve">
          <source>The state factories tried must each implement either &lt;code&gt;StateFactory&lt;/code&gt; or &lt;code&gt;DirStateFactory&lt;/code&gt;. If it implements &lt;code&gt;DirStateFactory&lt;/code&gt;, then &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; is called; otherwise, &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; is called.</source>
          <target state="translated">시도한 상태 팩토리는 각각 &lt;code&gt;StateFactory&lt;/code&gt; 또는 &lt;code&gt;DirStateFactory&lt;/code&gt; 를 구현해야합니다 . 그것을 구현하는 경우 &lt;code&gt;DirStateFactory&lt;/code&gt; 다음을, &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; 라고합니다; 그렇지 않으면 &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="069364d5e2bc01251c39eefbdac8ec561989f08f" translate="yes" xml:space="preserve">
          <source>The state information after the edit</source>
          <target state="translated">편집 후 상태 정보</target>
        </trans-unit>
        <trans-unit id="78b85e5c07d69b00d4a00829691f1844f46ca899" translate="yes" xml:space="preserve">
          <source>The state information prior to the edit</source>
          <target state="translated">편집 전 상태 정보</target>
        </trans-unit>
        <trans-unit id="b4b4593a62342b2b46d5d7ee91609ae7dd334526" translate="yes" xml:space="preserve">
          <source>The state maintained by an instance of &lt;code&gt;ImageReadParam&lt;/code&gt; is independent of any particular image being decoded. When actual decoding takes place, the values set in the read param are combined with the actual properties of the image being decoded from the stream and the destination &lt;code&gt;BufferedImage&lt;/code&gt; that will receive the decoded pixel data. For example, the source region set using &lt;code&gt;setSourceRegion&lt;/code&gt; will first be intersected with the actual valid source area. The result will be translated by the value returned by &lt;code&gt;getDestinationOffset&lt;/code&gt;, and the resulting rectangle intersected with the actual valid destination area to yield the destination area that will be written.</source>
          <target state="translated">&lt;code&gt;ImageReadParam&lt;/code&gt; 의 인스턴스에 의해 유지되는 상태 는 디코딩되는 특정 이미지와 무관합니다. 실제 디코딩이 수행 될 때, 판독 파라미터에 설정된 값은 스트림으로부터 디코딩되는 이미지의 실제 속성 및 디코딩 된 픽셀 데이터를 수신 할 목적지 &lt;code&gt;BufferedImage&lt;/code&gt; 와 결합된다 . 예를 들어, &lt;code&gt;setSourceRegion&lt;/code&gt; 을 사용하여 설정된 소스 영역 을 은 먼저 실제 유효한 소스 영역과 교차합니다. 결과는 &lt;code&gt;getDestinationOffset&lt;/code&gt; 에서 반환 한 값으로 변환되고 결과 사각형은 실제 유효한 대상 영역과 교차하여 작성 될 대상 영역을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3a932e6e75d4e4ee973a0e76a7f43125497f0c01" translate="yes" xml:space="preserve">
          <source>The state moves from readable to not readable once free() or any of the reading APIs are called: getBinaryStream(), getCharacterStream(), getSource(), and getString(). Implementations may also change the state to not writable when this occurs.</source>
          <target state="translated">free () 또는 읽기 API (getBinaryStream (), getCharacterStream (), getSource () 및 getString ())가 호출되면 상태가 읽기에서 읽을 수 없음으로 이동합니다. 구현시 이러한 상황이 발생하면 상태를 쓰기 불가능으로 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6f7bffc98d1e8352d937b1d9d3e6a929292204" translate="yes" xml:space="preserve">
          <source>The state moves from writable to not writable once free() or any of the writing APIs are called: setBinaryStream(), setCharacterStream(), setResult(), and setString(). Implementations may also change the state to not readable when this occurs.</source>
          <target state="translated">free () 또는 쓰기 API (setBinaryStream (), setCharacterStream (), setResult () 및 setString ())가 호출되면 상태가 쓰기 가능에서 쓰기 불가능으로 이동합니다. 구현시 상태를 읽을 수 없음으로 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f123d14f73abf8b927161bc953361f29bebc2d2" translate="yes" xml:space="preserve">
          <source>The state of each match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher's state.</source>
          <target state="translated">replacer 함수에 전달 된 각 일치 결과의 상태는 replacer 함수 호출 기간 동안과 replacer 함수가이 일치 자의 상태를 수정하지 않는 경우에만 일정하게 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="67f87189b7cffe5c4bdbf9a74576a5752597c030" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream &lt;a href=&quot;../../io/closeable#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결됩니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메서드에서 &lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. 파일 속성보기가 작성 될 때 파일이 존재하지 않아도되지만 파일 속성을 읽거나 업데이트하는 메소드가 호출 될 때 실패하고 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31371db7bcedb5e6ef0fa2a822080261021c1cbf" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결되어 있습니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메소드가 발생합니다.&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; . 파일 속성보기가 작성 될 때 파일이 존재하지 않아도되지만 호출 될 때 파일의 속성을 읽거나 업데이트하는 메소드가 실패하고 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5387502d22d451f2fcf83887e20653a2840e5163" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is &lt;a href=&quot;../../io/closeable#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결됩니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메서드에서 &lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6e75ea05d69038d832d8131b3848e4927b08478a" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결되어 있습니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메소드가 발생합니다.&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cfab20243a8ae6cc96b634df30cc6e006330263" translate="yes" xml:space="preserve">
          <source>The state of the horizontal and vertical scrollbars is represented by two &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; objects (one for each dimension) which implement the &lt;code&gt;Adjustable&lt;/code&gt; interface. The API provides methods to access those objects such that the attributes on the Adjustable object (such as unitIncrement, value, etc.) can be manipulated.</source>
          <target state="translated">가로 및 세로 스크롤 막대의 상태 는 &lt;code&gt;Adjustable&lt;/code&gt; 인터페이스 를 구현하는 두 개의 &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; 개체 (각 차원에 대해 하나씩)로 표시 됩니다. API는 해당 개체에 액세스하는 메서드를 제공하여 조정 가능한 개체의 속성 (예 : unitIncrement, 값 등)을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996e9184ffea209eb07129d46d0cbe21a541d384" translate="yes" xml:space="preserve">
          <source>The state of the match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher's state.</source>
          <target state="translated">replacer 함수에 전달 된 일치 결과의 상태는 replacer 함수 호출 기간 동안과 replacer 함수가이 일치 자의 상태를 수정하지 않는 경우에만 일정하게 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5df4fed0eb737b7e2f38a8fe3aee9d1a9f382989" translate="yes" xml:space="preserve">
          <source>The state of the modifier keys.</source>
          <target state="translated">수정 자 키의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="98da643dc29593f616d4b328dffe394f8b15ab99" translate="yes" xml:space="preserve">
          <source>The state of the modifier keys. This is replaced with InputEvent.getModifiers() In java 1.1 MouseEvent and KeyEvent are subclasses of InputEvent.</source>
          <target state="translated">수정 자 키의 상태입니다. 이것은 InputEvent.getModifiers ()로 대체되었습니다. java 1.1에서 MouseEvent와 KeyEvent는 InputEvent의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e2b4f9494871b832aa6cdc89d8afd5085d887c4d" translate="yes" xml:space="preserve">
          <source>The state of the tree selection is characterized by a set of TreePaths, and optionally a set of integers. The mapping from TreePath to integer is done by way of an instance of RowMapper. It is not necessary for a TreeSelectionModel to have a RowMapper to correctly operate, but without a RowMapper &lt;code&gt;getSelectionRows&lt;/code&gt; will return null.</source>
          <target state="translated">트리 선택의 상태는 TreePath 세트와 선택적으로 정수 세트로 특성화됩니다. TreePath에서 정수로의 매핑은 RowMapper의 인스턴스를 통해 수행됩니다. TreeSelectionModel이 올바르게 작동하기 위해 RowMapper를 가질 필요는 없지만 RowMapper가 없으면 &lt;code&gt;getSelectionRows&lt;/code&gt; 는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1dd113847fce5d615aef061976b5b5490ed246b1" translate="yes" xml:space="preserve">
          <source>The static methods of this class are also guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">이 클래스의 정적 메소드는 스레드로부터 안전합니다. 여러 스레드가 동시에이 클래스에 정의 된 정적 메서드를 아무런 영향없이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd0f94f9998daea410fa7e45671e8cee561746d9" translate="yes" xml:space="preserve">
          <source>The static methods of this class are guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">이 클래스의 정적 메소드는 스레드로부터 안전합니다. 여러 스레드가 동시에이 클래스에 정의 된 정적 메서드를 아무런 영향없이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="453f0a5aaaeaa1b3ec705217a056ecbeb4f2af9e" translate="yes" xml:space="preserve">
          <source>The status is allowed.</source>
          <target state="translated">상태가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b19b7fa28bfd0ac50416748ffc0c43c6c19d76ee" translate="yes" xml:space="preserve">
          <source>The status is rejected.</source>
          <target state="translated">상태가 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="43acb129e0f044bbc46043461b48630e54dab85d" translate="yes" xml:space="preserve">
          <source>The status is undecided, not allowed and not rejected.</source>
          <target state="translated">상태는 미결정, 허용되지 않음 및 거부되지 않음입니다.</target>
        </trans-unit>
        <trans-unit id="c8c42310ccefa275fea074e407b370d922b16a8c" translate="yes" xml:space="preserve">
          <source>The status of a check on the class, array length, number of references, depth, and stream size.</source>
          <target state="translated">클래스, 배열 길이, 참조 수, 깊이 및 스트림 크기에 대한 검사 상태입니다.</target>
        </trans-unit>
        <trans-unit id="0914f7bca27a68099a07b4e6076d13b547cbe3fd" translate="yes" xml:space="preserve">
          <source>The stax.properties file is read only once by the implementation and its values are then cached for future use. If the file does not exist when the first attempt is made to read from it, no further attempts are made to check for its existence. It is not possible to change the value of any property in stax.properties after it has been read for the first time.</source>
          <target state="translated">stax.properties 파일은 구현에 의해 한 번만 읽히고 그 값은 나중에 사용하기 위해 캐시됩니다. 파일을 처음 읽으려고 할 때 파일이 존재하지 않으면 그 존재를 확인하기 위해 더 이상 시도하지 않습니다. stax.properties의 속성 값을 처음 읽은 후에는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b80b91b73f97f322ab33c92b0bd0b2d998475afe" translate="yes" xml:space="preserve">
          <source>The step and pred functions are then executed, in clause order (step before pred), until a pred function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">그런 다음 pred 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때까지 step 및 pred 함수가 절 순서 (pred 전 단계)에 따라 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="894a59007f0696d713a79c9ba3e2b5d5cb14c470" translate="yes" xml:space="preserve">
          <source>The steps in the rendering process are:</source>
          <target state="translated">렌더링 프로세스의 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c14f9f8f60727625d22b3850782fe64ea87452ab" translate="yes" xml:space="preserve">
          <source>The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including &lt;code&gt;null&lt;/code&gt;, and throw an exception, as described in the specification for &lt;a href=&quot;collection#add(E)&quot;&gt;&lt;code&gt;Collection.add&lt;/code&gt;&lt;/a&gt;. Individual set implementations should clearly document any restrictions on the elements that they may contain.</source>
          <target state="translated">위의 규정은 집합이 모든 요소를 ​​수용해야 함을 의미하지 않습니다. 집합은 &lt;a href=&quot;collection#add(E)&quot;&gt; &lt;code&gt;Collection.add&lt;/code&gt; &lt;/a&gt; 사양에 설명 된대로 &lt;code&gt;null&lt;/code&gt; 을 포함한 특정 요소 추가를 거부 하고 예외를 throw 할 수 있습니다. 개별 집합 구현은 포함 할 수있는 요소에 대한 제한 사항을 명확하게 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="8af2436810c570bd5737c0e2bb02a5d795441443" translate="yes" xml:space="preserve">
          <source>The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including &lt;code&gt;null&lt;/code&gt;, and throw an exception, as described in the specification for &lt;a href=&quot;collection#add-E-&quot;&gt;&lt;code&gt;Collection.add&lt;/code&gt;&lt;/a&gt;. Individual set implementations should clearly document any restrictions on the elements that they may contain.</source>
          <target state="translated">위의 규정은 세트가 모든 요소를 ​​수용해야 함을 의미하지는 않습니다. set은 &lt;a href=&quot;collection#add-E-&quot;&gt; &lt;code&gt;Collection.add&lt;/code&gt; &lt;/a&gt; 사양에 설명 된대로 &lt;code&gt;null&lt;/code&gt; 을 포함한 특정 요소 추가를 거부 하고 예외를 throw 할 수 있습니다. 개별 집합 구현에는 포함될 수있는 요소에 대한 제한 사항이 명확하게 문서화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="18eb68b1ed315d63fa4df9e04e256a50303f9665" translate="yes" xml:space="preserve">
          <source>The stored chain is cloned before being returned.</source>
          <target state="translated">저장된 체인은 반환되기 전에 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="34211847f3a2164208058d0523645bdef1169daa" translate="yes" xml:space="preserve">
          <source>The stored derived color</source>
          <target state="translated">저장된 파생 색상</target>
        </trans-unit>
        <trans-unit id="59fa77a75631a5fd04013364bcf5c35eed6bf5bc" translate="yes" xml:space="preserve">
          <source>The strategy used to shut down the application, if Sudden Termination is not enabled.</source>
          <target state="translated">갑자기 종료가 활성화되지 않은 경우 응용 프로그램을 종료하는 데 사용되는 전략입니다.</target>
        </trans-unit>
        <trans-unit id="6a20537f8d5d92c9cff89f8fb6c2858031b1dd68" translate="yes" xml:space="preserve">
          <source>The stream binds to this bit set when the terminal stream operation commences (specifically, the spliterator for the stream is &lt;a href=&quot;spliterator#binding&quot;&gt;&lt;em&gt;late-binding&lt;/em&gt;&lt;/a&gt;). If the bit set is modified during that operation then the result is undefined.</source>
          <target state="translated">스트림은 터미널 스트림 작업이 시작될 때이 비트 세트에 바인딩됩니다 (특히 스트림의 분할자는 &lt;a href=&quot;spliterator#binding&quot;&gt;&lt;em&gt;후기 바인딩&lt;/em&gt;&lt;/a&gt; 임). 해당 작업 중에 비트 세트가 수정되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b503c50c6ec2a853d246bef99b17e237b1f62fe3" translate="yes" xml:space="preserve">
          <source>The stream binds to this sequence when the terminal stream operation commences (specifically, for mutable sequences the spliterator for the stream is &lt;a href=&quot;../util/spliterator#binding&quot;&gt;&lt;em&gt;late-binding&lt;/em&gt;&lt;/a&gt;). If the sequence is modified during that operation then the result is undefined.</source>
          <target state="translated">스트림은 터미널 스트림 작업이 시작될 때이 시퀀스에 바인딩됩니다 (특히, 변경 가능한 시퀀스의 경우 스트림에 대한 분할자는 &lt;a href=&quot;../util/spliterator#binding&quot;&gt;&lt;em&gt;후기 바인딩&lt;/em&gt;&lt;/a&gt; ). 해당 작업 중에 시퀀스가 ​​수정되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="284a200aa5c754806caf07fbf13e99a88b0c7015" translate="yes" xml:space="preserve">
          <source>The stream is</source>
          <target state="translated">스트림은</target>
        </trans-unit>
        <trans-unit id="0f4127d1899727942c90922302e4fcbdc49bed7d" translate="yes" xml:space="preserve">
          <source>The stream is parallel;</source>
          <target state="translated">스트림은 평행하다.</target>
        </trans-unit>
        <trans-unit id="18c2dad420890c0c93e56bc71847c1ffc91d517a" translate="yes" xml:space="preserve">
          <source>The stream is written using the ISO 8859-1 character encoding.</source>
          <target state="translated">스트림은 ISO 8859-1 문자 인코딩을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="40953f480e1f2608bd2829d4c5ca6a88b49f29cb" translate="yes" xml:space="preserve">
          <source>The stream of strings computed by splitting the input around matches of this pattern</source>
          <target state="translated">이 패턴의 일치 항목 주위에 입력을 분할하여 계산 된 문자열 스트림</target>
        </trans-unit>
        <trans-unit id="0278f0c3b2832857f3b5d471e56fa1f750974135" translate="yes" xml:space="preserve">
          <source>The stream position is left at its prior position upon exit from this method.</source>
          <target state="translated">이 방법에서 나갈 때 스트림 위치는 이전 위치에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c88da049e966b7fa1b0336d227d0469c10d044c" translate="yes" xml:space="preserve">
          <source>The stream returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the stream are in the order in which they occur in the input. Trailing empty strings will be discarded and not encountered in the stream.</source>
          <target state="translated">이 메소드에 의해 리턴 된 스트림은이 패턴과 일치하는 다른 서브 시퀀스에 의해 종료되거나 입력 시퀀스의 끝에 의해 종료되는 입력 시퀀스의 각 서브 스트링을 포함합니다. 스트림의 하위 문자열은 입력에서 발생하는 순서입니다. 후행 빈 문자열은 버리고 스트림에서 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f6114953487ace92dd1c168418f7e9f095d3d0" translate="yes" xml:space="preserve">
          <source>The stream returned by this method contains the lines from this string in the order in which they occur.</source>
          <target state="translated">이 메서드가 반환하는 스트림에는이 문자열의 행이 발생하는 순서대로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cc5a36b07837d8684881fc09793cf7774af9e41a" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를 지원하지 않습니다 . 스트림은 여러 동시 스레드에 의한 액세스에 안전합니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="8035d3c148eb320bea2a1229c6025747c0adc1f8" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 지원하지 않습니다 . 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="bc7063010775a8a4dfbf6ea7c3f4fd8168851da4" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않습니다. 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="635eea582878c3cee66666dcef47dae09ac40dc8" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e0b7738c3889e14f5b400112462983b88473f42" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;acceptSecContext(byte[], int, int)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;acceptSecContext(byte[], int, int)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fdd1e4fc8cc236e807967eab1defe58a2d7fb81c" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="75a1f54ce108d9e7d4e20f8e2e55c349191efa71" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;initSecContext(byte[], int, int)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;initSecContext(byte[], int, int)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="837beaf6b0fd108bd6761b7a930f749f93c98a2f" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20e163f975ddc90067dad425a1a8436ac6312c00" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(byte[], int, int, byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다. 대신 &lt;a href=&quot;#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(byte[], int, int, byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3311a132a16f8c1f01912c04e4d437b623872dab" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6e7c1e2a83cde4b74baace6a01266e9922cbc527" translate="yes" xml:space="preserve">
          <source>The stream-based methods of &lt;code&gt;GSSContext&lt;/code&gt; have been deprecated in Java SE 11. These methods have also been removed from &lt;a href=&quot;http://tools.ietf.org/html/rfc8353&quot;&gt; RFC 8353: Generic Security Service API Version 2: Java Bindings Update&lt;/a&gt; for the following reasons (see section 11): &quot;The overloaded methods of GSSContext that use input and output streams as the means to convey authentication and per-message GSS-API tokens as described in Section 5.15 of RFC 5653 are removed in this update as the wire protocol should be defined by an application and not a library. It's also impossible to implement these methods correctly when the token has no self-framing (where the end cannot be determined), or the library has no knowledge of the token format (for example, as a bridge talking to another GSS library)&quot;. These methods include &lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GSSContext&lt;/code&gt; 의 스트림 기반 메소드는 Java SE 11에서 더 이상 사용되지 않습니다. 이러한 메소드는 다음과 같은 이유로 &lt;a href=&quot;http://tools.ietf.org/html/rfc8353&quot;&gt;RFC 8353&lt;/a&gt; 에서 제거되었습니다 . 일반 보안 서비스 API 버전 2 : Java 바인딩 업데이트 (11 절 참조) : &quot; RFC 5653의 섹션 5.15에 설명 된대로 인증 및 메시지 당 GSS-API 토큰을 전달하는 수단으로 입력 및 출력 스트림을 사용하는 GSSContext는 유선 프로토콜이 라이브러리가 아닌 응용 프로그램에 의해 정의되어야하므로 이번 업데이트에서 제거되었습니다. 또한 토큰에 자체 프레이밍이 없거나 (끝을 확인할 수없는 경우) 라이브러리가 토큰 형식을 알지 못하는 경우 (예 : 다른 GSS 라이브러리와 통신하는 브리지) 이러한 메서드를 올바르게 구현할 수 없습니다. &quot; 이러한 방법에는 다음이 포함됩니다.&lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3196486e12ee1ceae179dd2a0073d0d87998aba" translate="yes" xml:space="preserve">
          <source>The strict sequential order of invocations from &lt;code&gt;WebSocket&lt;/code&gt; to &lt;code&gt;Listener&lt;/code&gt; means, in particular, that the &lt;code&gt;Listener&lt;/code&gt;'s methods are treated as non-reentrant. This means that &lt;code&gt;Listener&lt;/code&gt; implementations do not need to be concerned with possible recursion or the order in which they invoke &lt;code&gt;WebSocket.request&lt;/code&gt; in relation to their processing logic.</source>
          <target state="translated">&lt;code&gt;WebSocket&lt;/code&gt; 에서 &lt;code&gt;Listener&lt;/code&gt; 로의 엄격한 순차적 호출 순서는 특히 &lt;code&gt;Listener&lt;/code&gt; 의 메서드가 재진입이 아닌 것으로 처리 된다는 것을 의미 합니다. 이는 &lt;code&gt;Listener&lt;/code&gt; 구현이 가능한 재귀 또는 처리 로직과 관련하여 &lt;code&gt;WebSocket.request&lt;/code&gt; 를 호출하는 순서에 관심을 가질 필요가 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="677e924344268647b9f4c33bebdbd774bffeedb1" translate="yes" xml:space="preserve">
          <source>The strikethrough affects both the visual bounds and the outline of the text.</source>
          <target state="translated">취소 선은 텍스트의 시각적 경계와 윤곽 모두에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="08ace5725b5a326d5041f65d175699034a1c1db6" translate="yes" xml:space="preserve">
          <source>The string &quot;error&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;error&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="bfc3fe82f3ff5835f163f82fa9c6c4dba766b9ab" translate="yes" xml:space="preserve">
          <source>The string &quot;false&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;false&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="e30c0643390c5dc7ebd25358b9755769e7551051" translate="yes" xml:space="preserve">
          <source>The string &quot;keep&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;keep&quot;은 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="1f0cf467ff107c2e23c66f6d76abd1c756e88c98" translate="yes" xml:space="preserve">
          <source>The string &quot;latest&quot;, a possible value for certain properties.</source>
          <target state="translated">특정 속성에 가능한 값인 &quot;latest&quot;문자열</target>
        </trans-unit>
        <trans-unit id="108f1155e473064ee5869a10046f49c5f28678dc" translate="yes" xml:space="preserve">
          <source>The string &quot;pass&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;pass&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="558ef0c8eaf4af89eed40f1773ec89e05db3ff2d" translate="yes" xml:space="preserve">
          <source>The string &quot;strip&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;strip&quot;, 특정 속성에 가능한 값.</target>
        </trans-unit>
        <trans-unit id="465f99ea7628c0edb2cf953567db0aafbc5f0067" translate="yes" xml:space="preserve">
          <source>The string &quot;true&quot;, a possible value for certain properties.</source>
          <target state="translated">특정 속성에 가능한 값인 &quot;true&quot;문자열</target>
        </trans-unit>
        <trans-unit id="22c0cd468531813dfe7dcaa04b8b2d76bff20d6f" translate="yes" xml:space="preserve">
          <source>The string &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt; means that the pack operation as a whole will fail, with an exception of type &lt;code&gt;IOException&lt;/code&gt;. The string &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt; means that the attribute will be dropped. The string &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; means that the whole class-file will be passed through (as if it were a resource file) without compression, with a suitable warning. This is the default value for this property.</source>
          <target state="translated">&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; 문자열 은 &lt;code&gt;IOException&lt;/code&gt; 유형의 예외를 제외하고 전체적으로 압축 작업이 실패 함을 의미합니다 . &lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 문자열 은 속성이 삭제됨을 의미합니다. &lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 문자열 은 전체 클래스 파일이 압축없이 (리소스 파일 인 것처럼) 적절한 경고와 함께 전달됨을 의미합니다. 이 속성의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b7d2fbb70acb3059d5c5bbd79c4294963cdbf352" translate="yes" xml:space="preserve">
          <source>The string &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt; means that the pack operation as a whole will fail, with an exception of type &lt;code&gt;IOException&lt;/code&gt;. The string &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt; means that the attribute will be dropped. The string &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; means that the whole class-file will be passed through (as if it were a resource file) without compression, with a suitable warning. This is the default value for this property.</source>
          <target state="translated">문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;IOException&lt;/code&gt; 유형을 제외하고 전체 팩 조작이 실패 함을 의미합니다 . 문자열 &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 는 속성이 삭제됨을 의미합니다. 문자열 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 는 적절한 경고와 함께 전체 클래스 파일이 압축없이 (리소스 파일 인 것처럼) 전달됨을 의미합니다. 이것이이 속성의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ad02c3d243be4e9c61737e03ba9c0bf8b38dbb60" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these expressions:</source>
          <target state="translated">예를 들어, 문자열 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 표현식으로 다음 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0a75a6f894f0ae1c44cee0d9fcd6514b9f78e1dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these parameters:</source>
          <target state="translated">예를 들어, 문자열 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 매개 변수를 사용하여 다음 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1565ac3867c9c20773f4cb4feb587c3d597a0245" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;precision=&quot;&lt;/code&gt;, immediately followed by the value of the precision setting as a numeric string as if generated by the &lt;a href=&quot;../lang/integer#toString(int)&quot;&gt;&lt;code&gt;Integer.toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;precision=&quot;&lt;/code&gt; . &lt;a href=&quot;../lang/integer#toString(int)&quot;&gt; &lt;code&gt;Integer.toString&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성 된 것처럼 숫자 문자열로 정밀도 설정 값이 바로 뒤에옵니다 .</target>
        </trans-unit>
        <trans-unit id="6550e9f9888c201023a4fc7c4d06f985451147bf" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;precision=&quot;&lt;/code&gt;, immediately followed by the value of the precision setting as a numeric string as if generated by the &lt;a href=&quot;../lang/integer#toString-int-&quot;&gt;&lt;code&gt;Integer.toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;precision=&quot;&lt;/code&gt; , 바로 뒤에 &lt;a href=&quot;../lang/integer#toString-int-&quot;&gt; &lt;code&gt;Integer.toString&lt;/code&gt; &lt;/a&gt; 메서드에서 생성 된 것처럼 정밀도 설정 값이 숫자 문자열로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="62905723a8ac431fa9dccaf628bb9c07af02e5dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt;, immediately followed by the value of the &lt;code&gt;roundingMode&lt;/code&gt; setting as a word. This word will be the same as the name of the corresponding public constant in the &lt;a href=&quot;roundingmode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt; , 바로 뒤에 &lt;code&gt;roundingMode&lt;/code&gt; 설정 값이 단어로 표시됩니다. 이 단어는 &lt;a href=&quot;roundingmode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt; 열거 형 의 해당 공용 상수 이름과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a056f3c02b144a1272485d342c4c2a38f8a60c41" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean is an &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly with the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">이 MBean에 따른 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 는 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 입니다. MBean Server에 직접 등록되거나 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 작성된 표준 MBean 또는 MXBean 은이 필드를 MBeanInfo 디스크립터에 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fa3bdb340e93ffe54892a6e3894a1d8cb94a703a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean's MBeanInfo is &lt;em&gt;immutable&lt;/em&gt;. When this field is true, the MBeanInfo for the given MBean is guaranteed not to change over the lifetime of the MBean. Hence, a client can read it once and cache the read value. When this field is false or absent, there is no such guarantee, although that does not mean that the MBeanInfo will necessarily change. See also the &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; notification.</source>
          <target state="translated">이 MBean MBeanInfo로서의 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 캐릭터 라인 은 &lt;em&gt;불변&lt;/em&gt; 입니다. 이 필드가 true 인 경우, 지정된 MBean의 MBeanInfo는 MBean의 수명 동안 변경되지 않도록 보장됩니다. 따라서 클라이언트는 한 번 읽고 읽은 값을 캐시 할 수 있습니다. 이 필드가 false 또는없는 경우, MBeanInfo가 반드시 변경되는 것은 아닙니다만, 그러한 보증은 없습니다. &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt; 알림 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58cf603470519c5b5e195c25d45c63e85fd34cc0" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this item is enabled. When an attribute or operation is not enabled, it exists but cannot currently be accessed. A user interface might present it as a greyed-out item. For example, an attribute might only be meaningful after the &lt;code&gt;start()&lt;/code&gt; method of an MBean has been called, and is otherwise disabled. Likewise, a notification might be disabled if it cannot currently be emitted but could be in other circumstances.</source>
          <target state="translated">이 항목에 따라 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 가 활성화됩니다. 속성 또는 조작이 사용 가능하지 않으면 존재하지만 현재 액세스 할 수 없습니다. 사용자 인터페이스는이를 회색으로 표시 할 수 있습니다. 예를 들어, 속성은 MBean 의 &lt;code&gt;start()&lt;/code&gt; 메소드가 호출 된 후에 만 의미 가 있으며, 그렇지 않으면 비활성화됩니다. 마찬가지로 현재 알림을 생성 할 수 없지만 다른 상황에있을 수있는 경우 알림이 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="631ed054c3067658cc3a118e7936d64f51bfad09" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; is used to suppress unchecked warnings. Compiler vendors should document the additional warning names they support in conjunction with this annotation type. They are encouraged to cooperate to ensure that the same names work across multiple compilers.</source>
          <target state="translated">&lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; 문자열 은 확인되지 않은 경고를 억제하는 데 사용됩니다. 컴파일러 공급 업체는이 주석 유형과 함께 지원하는 추가 경고 이름을 문서화해야합니다. 동일한 이름이 여러 컴파일러에서 작동하도록 협력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69491b7b47334ee084c1c31f631a979ba7599e82" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s&lt;/code&gt; is processed from left to right, looking for data of interest. Any material in &lt;code&gt;s&lt;/code&gt; that is within the ASCII parenthesis characters &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; is ignored. Parentheses may be nested. Otherwise, the only characters permitted within &lt;code&gt;s&lt;/code&gt; are these ASCII characters:</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 는 왼쪽에서 오른쪽으로 처리되어 관심있는 데이터를 찾습니다. ASCII 괄호 문자 &lt;code&gt;(&lt;/code&gt; 및 &lt;code&gt;)&lt;/code&gt; 내에있는 &lt;code&gt;s&lt;/code&gt; 의 모든 자료 는 무시됩니다. 괄호는 중첩 될 수 있습니다. 그렇지 않으면 &lt;code&gt;s&lt;/code&gt; 내에 허용되는 유일한 문자 는 다음 ASCII 문자입니다.</target>
        </trans-unit>
        <trans-unit id="fa07a44e85f7b0960fe0afe9cd1bc3596bb25ceb" translate="yes" xml:space="preserve">
          <source>The string NULL (not enclosed in quotes) - if NULL was specified as the default value</source>
          <target state="translated">문자열 NULL (따옴표로 묶지 않음)-NULL이 기본값으로 지정된 경우</target>
        </trans-unit>
        <trans-unit id="919c5615e88a8576efe725aa5581160688478bfe" translate="yes" xml:space="preserve">
          <source>The string attribute values are not interpreted as &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; formatted RDN strings. That is, the values are used literally (not parsed) and assumed to be unescaped.</source>
          <target state="translated">문자열 속성 값은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; 형식의 RDN 문자열 로 해석되지 않습니다 . 즉, 값은 문자 그대로 (구문 분석되지 않음) 사용되며 이스케이프 처리되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fad0ec093c3f0998c8bdd918a0718e5eab967d10" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing each matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">일치하는 각 서브 시퀀스를 교체 스트링으로 교체하고 필요에 따라 캡처 된 서브 시퀀스를 대체하여 구성된 스트링</target>
        </trans-unit>
        <trans-unit id="afda6d3703500c7f92e7b1f7f59b56df33958ed8" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing each matching subsequence with the result of applying the replacer function to that matched subsequence, substituting captured subsequences as needed.</source>
          <target state="translated">각 일치하는 하위 시퀀스를 일치하는 하위 시퀀스에 대체 함수를 적용한 결과로 대체하여 생성 된 문자열입니다. 필요에 따라 캡처 된 하위 시퀀스를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c64ffe780cf31db4996cccb5e0b7a94f8f71ac12" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing the first matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">첫 번째로 일치하는 하위 시퀀스를 대체 문자열로 바꾸고 캡처 된 하위 시퀀스를 필요에 따라 대체하여 구성된 문자열</target>
        </trans-unit>
        <trans-unit id="e0bec6f730c0449ee38f585e3dde0d82f697b3cb" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing the first matching subsequence with the result of applying the replacer function to the matched subsequence, substituting captured subsequences as needed.</source>
          <target state="translated">첫 번째 일치하는 하위 시퀀스를 일치 된 하위 시퀀스에 대체 함수를 적용한 결과로 바꾸고 필요에 따라 캡처 된 하위 시퀀스를 대체하여 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="57510220bfaf470419bb00af78884a6462f36070" translate="yes" xml:space="preserve">
          <source>The string containing the version of the module if recorded at compile-time, or an empty &lt;code&gt;Optional&lt;/code&gt; if no version was recorded</source>
          <target state="translated">컴파일 타임에 기록 된 경우 모듈의 버전을 포함하는 문자열 또는 기록 된 버전이 없으면 빈 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a584ad3952c728ec28d3c26b8f0d57ad4cd86d7a" translate="yes" xml:space="preserve">
          <source>The string containing the version of the module or an empty &lt;code&gt;Optional&lt;/code&gt; if the module does not have a version</source>
          <target state="translated">모듈의 버전을 포함하는 문자열 또는 모듈에 버전이없는 경우 빈 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c31beff83674da5e332dc00712cbbbdd5562206f" translate="yes" xml:space="preserve">
          <source>The string form of the compound name follows the syntax described above. When the components of the compound name are turned into their string representation, the reserved syntax rules described above are applied (e.g. embedded separators are escaped or quoted) so that when the same string is parsed, it will yield the same components of the original compound name.</source>
          <target state="translated">복합 이름의 문자열 형식은 위에서 설명한 구문을 따릅니다. 복합 이름의 구성 요소가 문자열 표시로 바뀌면, 위에서 설명한 예약 구문 규칙이 적용되어 (예 : 내장 분리자가 이스케이프 또는 인용) 동일한 문자열이 구문 분석 될 때 원래 복합의 동일한 구성 요소가 생성됩니다 이름.</target>
        </trans-unit>
        <trans-unit id="f10938b9c9c0c8797b9503b58353064a7df27786" translate="yes" xml:space="preserve">
          <source>The string form of this URI</source>
          <target state="translated">이 URI의 문자열 형식</target>
        </trans-unit>
        <trans-unit id="2fdc4bee66cbffe9f8926f8d8bb6b3ff409dbcc9" translate="yes" xml:space="preserve">
          <source>The string form of this URI, encoded as needed so that it only contains characters in the US-ASCII charset</source>
          <target state="translated">이 URI의 문자열 형식으로 US-ASCII 문자 집합의 문자 만 포함하도록 필요에 따라 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="04761903fd7cc565bcc1b3b493f9a4d9ad183aaa" translate="yes" xml:space="preserve">
          <source>The string form of this abstract pathname</source>
          <target state="translated">이 추상 경로명의 문자열 형식</target>
        </trans-unit>
        <trans-unit id="a6a48b95d9bb03c06186693a1e56c1d93fae2d7c" translate="yes" xml:space="preserve">
          <source>The string from which bytes are read.</source>
          <target state="translated">바이트를 읽는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="63b46307980099765e658cf440f0d03747b95b05" translate="yes" xml:space="preserve">
          <source>The string from which this version was parsed.</source>
          <target state="translated">이 버전이 구문 분석 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b6724bb79c3c33d31e86e0f46c7de30b21951061" translate="yes" xml:space="preserve">
          <source>The string is between 1 and 128 characters in length inclusive</source>
          <target state="translated">문자열의 길이는 1 ~ 128 자입니다.</target>
        </trans-unit>
        <trans-unit id="15fa0640f7a89ad0499dc7372318874d0f8a6949" translate="yes" xml:space="preserve">
          <source>The string is not enclosed in double quotes</source>
          <target state="translated">문자열은 큰 따옴표로 묶여 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2361fc0fcc98f34cf7707bd58c3a48311a40b445" translate="yes" xml:space="preserve">
          <source>The string must match exactly the name of the era. (Extraneous whitespace characters are not permitted.)</source>
          <target state="translated">문자열은 시대의 이름과 정확히 일치해야합니다. (공백 공백 문자는 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="528b474b80585c5bde4792fd2aaffc2f3fc1d745" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜를 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt; 를&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a92bea7fe20a26d29fc02f1b18cfeb4a64f2befc" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9546955f3024f065c5daeea861e41048af02e3a1" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea655be45604489e8a988f1f62775445f297e35d" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="b639943db6958d9063503c47072cf422d9417cda" translate="yes" xml:space="preserve">
          <source>The string must represent a valid instant in UTC and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 인스턴트를 UTC로 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt; 를&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d2f552261c78dde5773d5eb748ea70d7ae99393" translate="yes" xml:space="preserve">
          <source>The string must represent a valid month-day. The format is &lt;code&gt;--MM-dd&lt;/code&gt;.</source>
          <target state="translated">문자열은 유효한 월일을 나타내야합니다. 형식은 &lt;code&gt;--MM-dd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f5fc471abeddd2fc10059070b03a26ea0e4f0e6" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="4834d95eb10fdeb7855ef1f3b7f1815cd5f315de" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="522d37a5cb0dea2932c0223382f776eae3acb124" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year-month. The format must be &lt;code&gt;uuuu-MM&lt;/code&gt;. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">문자열은 유효한 연도를 나타내야합니다. 형식은 &lt;code&gt;uuuu-MM&lt;/code&gt; 이어야합니다 . 0000-9999 범위를 벗어난 연도에는 더하기 또는 빼기 기호가 앞에 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="68fe36aa287218182684aa7a85b5b9b1977bc3ca" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">문자열은 유효한 연도를 나타내야합니다. 0000-9999 범위를 벗어난 연도에는 더하기 또는 빼기 기호가 앞에 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="137a5254a87fa6e0ce4c1568f6ddf435ae99c22b" translate="yes" xml:space="preserve">
          <source>The string only contains alphanumeric characters or the character &quot;_&quot;</source>
          <target state="translated">문자열에는 영숫자 또는 문자 &quot;_&quot;만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="abbf179f85853b351778a26629eb5657fc8e8fab" translate="yes" xml:space="preserve">
          <source>The string produced for a given number is always the same; it is not affected by locale. This means that it can be used as a canonical string representation for exchanging decimal data, or as a key for a Hashtable, etc. Locale-sensitive number formatting and parsing is handled by the &lt;a href=&quot;../text/numberformat&quot;&gt;&lt;code&gt;NumberFormat&lt;/code&gt;&lt;/a&gt; class and its subclasses.</source>
          <target state="translated">주어진 숫자에 대해 생성 된 문자열은 항상 같습니다. 로케일의 영향을받지 않습니다. 이는 10 진수 데이터 교환을위한 표준 문자열 표현 또는 해시 테이블 등의 키로 사용될 수 있음을 의미합니다. 로케일 구분 숫자 형식화 및 구문 분석은 &lt;a href=&quot;../text/numberformat&quot;&gt; &lt;code&gt;NumberFormat&lt;/code&gt; &lt;/a&gt; 클래스 및 해당 서브 클래스에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fe8bf77d08eee400f8eacfe6cb5d936ae0a4f48" translate="yes" xml:space="preserve">
          <source>The string representation consists of a list of the array's elements, enclosed in square brackets (&lt;code&gt;&quot;[]&quot;&lt;/code&gt;). Adjacent elements are separated by the characters &lt;code&gt;&quot;, &quot;&lt;/code&gt; (a comma followed by a space). Elements are converted to strings as by &lt;code&gt;String.valueOf(Object)&lt;/code&gt;, unless they are themselves arrays.</source>
          <target state="translated">문자열 표현은 배열의 요소 목록으로 구성되며 대괄호 ( &lt;code&gt;&quot;[]&quot;&lt;/code&gt; )로 묶습니다 . 인접한 요소는 문자 &lt;code&gt;&quot;, &quot;&lt;/code&gt; (쉼표 뒤에 공백)로 구분됩니다. 요소 자체가 배열이 아닌 경우 요소는 &lt;code&gt;String.valueOf(Object)&lt;/code&gt; 의해 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b44741f71d142966f86ccc32acede59a84d445d" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, and the tabular type of this instance.</source>
          <target state="translated">문자열 표현은 구현 클래스의 이름과이 인스턴스의 테이블 형식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="53d83a239c2a7be1cb8fe5f1423384d5522b995b" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">문자열 표현은 구현 클래스의 이름,이 인스턴스의 복합 유형의 문자열 표현 및 컨텐츠의 문자열 표현 (즉, itemName = itemValue 맵핑 나열)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce6c605327807271ff809bf8c3e33f72c8d71fb" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt;), the type name, the dimension, the elements' open type and the primitive array flag defined for this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt; ), 유형 이름, 차원, 요소의 열린 유형 및이 인스턴스에 대해 정의 된 기본 배열 플래그로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2883eec75a628ef99c332dc7e2aaea10651f3902" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 올바른 값의 문자열 표현 및 기술자의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="8a2464b0766b9e81e51253aa84918715aa0cd068" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 올바른 값의 문자열 표현 및 기술자의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="4d29a8e6e5f83180a9a2655eeeb086d4d8e9f13e" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;
 javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt;), the name and signature of the described constructor and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (즉, &lt;code&gt; javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt; ), 설명 된 생성자의 이름과 서명, 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ac01ca9000354d194b07d70a4e1b8028f60f9f3e" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;
 javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt;), and the name, signature, return open type and impact of the described operation and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (즉, &lt;code&gt; javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt; )과 이름, 서명, 반환 개방 유형 및 설명 된 작업의 영향과 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6002a9339d22eed93f555f1481a07a002e5091" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt;), the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt; ),이 인스턴스의 복합 유형의 문자열 표현 및 컨텐츠의 문자열 표현 (즉, itemName = itemValue 맵핑 나열)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="789eed41269dc56a9082ac2a97089c1d128afaf4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt;), the type name for this instance, and the list of the items names and types string representation of this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt; ),이 인스턴스의 유형 이름 및이 인스턴스의 항목 이름 및 유형 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a4e6ec5ac6aa3e0627edbc16f7c6430eb6a8d1d8" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt;), the string representation of the name and open type of the described attribute, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt; ), 설명 된 속성의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 유효한 값의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b716744f9ffc637689b371f05e304eff7af2a9" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt;), and the name and signature of the described constructor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt; )과 설명 된 생성자의 이름 및 서명으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ad27ad5ebd129c3ea4d4956977533104d272e95" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt;), the name and signature of the described constructor and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt; ), 설명 된 생성자의 이름 및 서명, 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="56f0f9a9629656eb5921de1b1b2280b717218bf7" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt;), the MBean class name, and the string representation of infos on attributes, constructors, operations and notifications of the described MBean.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt; ), MBean 클래스 이름 및 설명 된 MBean의 속성, 생성자, 조작 및 알림에 대한 정보의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d79b194f6330817e69226b3c9fd464f3f27be2" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt;), the MBean class name, the string representation of infos on attributes, constructors, operations and notifications of the described MBean and the string representation of the descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt; ), MBean 클래스 이름, 설명 된 MBean의 속성, 생성자, 조작 및 알림에 대한 정보의 문자열 표현 및 설명 자의 문자열 표현으로 구성됩니다. .</target>
        </trans-unit>
        <trans-unit id="4ab6a7c24f824a223fbd8a3831c0c3e6970b8c12" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt;), and the name, signature, return open type and impact of the described operation.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt; )과 이름, 서명, 리턴 열기 유형 및 설명 된 조작의 영향으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="640c583f5e5f932dc18d233947e5f9f45c18d88c" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt;), and the name, signature, return open type and impact of the described operation and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt; )과 설명 된 조작의 이름, 서명, 리턴 열기 유형 및 영향 및 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="56372f3341ed9c622ba1dff09dfa80ed9847d82f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt;), the string representation of the name and open type of the described parameter, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현 및 기본값, 최소, 최대 및 올바른 값의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e847596a7e03c71180c8216bb4f964ac80c8ce4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt;) and the type name for this instance (which is the java class name of the values this &lt;code&gt;SimpleType&lt;/code&gt; instance represents).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt; )과이 인스턴스의 유형 이름 (이 &lt;code&gt;SimpleType&lt;/code&gt; 인스턴스가 나타내는 값의 Java 클래스 이름 )으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="cdd41d530879d983b77fc6d88438a6e273a7cdec" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;), the string representation of the tabular type of this instance, and the string representation of the contents (ie list the key=value mappings as returned by a call to &lt;code&gt;dataMap.&lt;/code&gt;&lt;a href=&quot;../../../../java.base/java/util/abstractmap#toString()&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt; ),이 인스턴스의 표 형식의 문자열 표현, 콘텐츠의 문자열 표현 (예 : &lt;code&gt;dataMap.&lt;/code&gt; 대한 호출 &lt;a href=&quot;../../../../java.base/java/util/abstractmap#toString()&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="574dc6c379e8e51bf167c7fea2d4d1304ca21c2f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;), the string representation of the tabular type of this instance, and the string representation of the contents (ie list the key=value mappings as returned by a call to &lt;code&gt;dataMap.&lt;/code&gt;&lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt; ),이 인스턴스의 표 형식 유형의 문자열 표현 및 내용의 문자열 표현으로 구성됩니다 (즉, 키 = 값 매핑을 반환) 를 호출 &lt;code&gt;dataMap.&lt;/code&gt; &lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="807fbdd5da5244bfb18ce040224682952e87d826" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt;), the type name for this instance, the row type string representation of this instance, and the index names of this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt; ),이 인스턴스의 유형 이름,이 인스턴스의 행 유형 문자열 표현 및이 인스턴스의 색인 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc5fe65d5ab420dbf5b6b9fae291dad1f8925ed" translate="yes" xml:space="preserve">
          <source>The string representation for this &lt;code&gt;X500Principal&lt;/code&gt; can be obtained by calling the &lt;code&gt;getName&lt;/code&gt; methods.</source>
          <target state="translated">이 &lt;code&gt;X500Principal&lt;/code&gt; 의 캐릭터 라인 표현 은 &lt;code&gt;getName&lt;/code&gt; 메소드 를 호출하는 것으로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfa9c547b94d4a8505b4496d10852764a147d91f" translate="yes" xml:space="preserve">
          <source>The string representation may not have any leading and trailing whitespaces.</source>
          <target state="translated">문자열 표현에는 선행 및 후행 공백이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b612d9c02babd7e1408d7e8d784cf99d9d55260" translate="yes" xml:space="preserve">
          <source>The string representation of the LdapName.</source>
          <target state="translated">LdapName의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="a420c385cddda341e69db0764ebb091c11a4a7be" translate="yes" xml:space="preserve">
          <source>The string representation of the Rdn.</source>
          <target state="translated">Rdn의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="06141090c2bbeee203d15ec52d1050014ee8d75b" translate="yes" xml:space="preserve">
          <source>The string representation of the attribute.</source>
          <target state="translated">속성의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="acdd753dd59a9a0afe3c3ebf5bba1d1c8f5326bd" translate="yes" xml:space="preserve">
          <source>The string representation of the attribute. This should exactly match the string specified in the CSS specification.</source>
          <target state="translated">속성의 문자열 표현입니다. 이것은 CSS 사양에 지정된 문자열과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6de482475e09c2eeff30bcc77f9f20ef06b16b86" translate="yes" xml:space="preserve">
          <source>The string representation of this SearchResult. Cannot be null.</source>
          <target state="translated">이 SearchResult의 캐릭터 라인 표현 null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9095c816b4ff2b939ed38e5ec4c8dd104708dcc0" translate="yes" xml:space="preserve">
          <source>The string representation of this Service URL.</source>
          <target state="translated">이 서비스 URL의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="19b1dc6e3c56c1f7d2c94a2810b048ff86117b35" translate="yes" xml:space="preserve">
          <source>The string representation of this Service URL. If the value returned by this method is supplied to the &lt;code&gt;JMXServiceURL&lt;/code&gt; constructor, the resultant object is equal to this one.</source>
          <target state="translated">이 서비스 URL의 캐릭터 라인 표현 이 메소드에 의해 리턴 된 값이 &lt;code&gt;JMXServiceURL&lt;/code&gt; 생성자에 제공되면 결과 오브젝트는이 오브젝트와 같습니다.</target>
        </trans-unit>
        <trans-unit id="06f159652db61335f5666a5cf825b7a69627ed8c" translate="yes" xml:space="preserve">
          <source>The string representation of this exception consists of information about where the error occurred, and the first unexecuted modification.</source>
          <target state="translated">이 예외의 문자열 표현은 오류가 발생한 위치 및 실행되지 않은 첫 번째 수정 사항에 대한 정보로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="16f1d37b61e149769d5bb45d2d6b123bd696fbda" translate="yes" xml:space="preserve">
          <source>The string representation of this exception consists of information about where the error occurred, and the first unexecuted modification. This string is meant for debugging and not mean to be interpreted programmatically.</source>
          <target state="translated">이 예외의 문자열 표현은 오류가 발생한 위치 및 실행되지 않은 첫 번째 수정에 대한 정보로 구성됩니다. 이 문자열은 디버깅을위한 것이며 프로그래밍 방식으로 해석되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c7de16e9df6affa420db9ce81302405c1dfefd55" translate="yes" xml:space="preserve">
          <source>The string representation of this matcher</source>
          <target state="translated">이 정규 표현 엔진의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="bb74ce786b3d545de3a84f33214617b02d5c2940" translate="yes" xml:space="preserve">
          <source>The string representation of this module</source>
          <target state="translated">이 모듈의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="09eba65afc610d538d65c263d07c4a3212fcfe45" translate="yes" xml:space="preserve">
          <source>The string representation of this name/class pair.</source>
          <target state="translated">이 이름 / 클래스 쌍의 문자열 표현.</target>
        </trans-unit>
        <trans-unit id="053f914091e9887aaa58bf39744d8861af29fc0d" translate="yes" xml:space="preserve">
          <source>The string representation of this pattern</source>
          <target state="translated">이 패턴의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c2acdbf9130b5c1f31215890014846c808d3f0b0" translate="yes" xml:space="preserve">
          <source>The string representation of this scanner</source>
          <target state="translated">이 스캐너의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="f450b24ffb7d9483210505aa1ae5491f8f1973d0" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawAuthority()&quot;&gt;&lt;code&gt;getRawAuthority&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawAuthority()&quot;&gt; &lt;code&gt;getRawAuthority&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="17b139befffb2c60f26b6e3ef4ef71139b888633" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawFragment()&quot;&gt;&lt;code&gt;getRawFragment&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawFragment()&quot;&gt; &lt;code&gt;getRawFragment&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d13f16b94787c0c530d775e02f176898aa8709aa" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawPath()&quot;&gt;&lt;code&gt;getRawPath&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawPath()&quot;&gt; &lt;code&gt;getRawPath&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="49ceecc3a0a7b0c628428ecb824a9a4733fe10bc" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawQuery()&quot;&gt;&lt;code&gt;getRawQuery&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawQuery()&quot;&gt; &lt;code&gt;getRawQuery&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="950adaee23e256f95ac7d75c80da01a153533597" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawSchemeSpecificPart()&quot;&gt;&lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawSchemeSpecificPart()&quot;&gt; &lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="da24186777164723ddd293bab7dd828e99e48a24" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawUserInfo()&quot;&gt;&lt;code&gt;getRawUserInfo&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawUserInfo()&quot;&gt; &lt;code&gt;getRawUserInfo&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0428783f6a2a4ed333a95d1448a2bc32086c9f46" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawAuthority--&quot;&gt;&lt;code&gt;getRawAuthority&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 문자열에 의해 리턴 된 것과 동일하다 &lt;a href=&quot;uri#getRawAuthority--&quot;&gt; &lt;code&gt;getRawAuthority&lt;/code&gt; 의&lt;/a&gt; 탈출 옥텟의 모든 서열이된다는 점을 제외하고 방법 &lt;a href=&quot;#decode&quot;&gt;복호&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99f4ef96c814a7c3937663953ec5ac06f173ebb2" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawFragment--&quot;&gt;&lt;code&gt;getRawFragment&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawFragment--&quot;&gt; &lt;code&gt;getRawFragment&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a732cb50bbec78c973952b48ad9babe398c8380c" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawPath--&quot;&gt;&lt;code&gt;getRawPath&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawPath--&quot;&gt; &lt;code&gt;getRawPath&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ddd6a70f437a36a8a334d3aa1a18560bd5c5720e" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawQuery--&quot;&gt;&lt;code&gt;getRawQuery&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawQuery--&quot;&gt; &lt;code&gt;getRawQuery&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1a87d2cf19c437c64a305afdb85f728af90351" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt;&lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 &lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt; &lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4374f3d0ad6e121222206c9e637bf592e8f4f3" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawUserInfo--&quot;&gt;&lt;code&gt;getRawUserInfo&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawUserInfo--&quot;&gt; &lt;code&gt;getRawUserInfo&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="15003a859c5ec3a6cdfdb74230384f43324ebc22" translate="yes" xml:space="preserve">
          <source>The string returned by this method is not a JNDI composite name and should not be passed directly to context methods.</source>
          <target state="translated">이 메소드가 리턴 한 문자열은 JNDI 컴포지트 이름이 아니므로 컨텍스트 메소드에 직접 전달해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="720d46b0678e4b58ffd12635e35e8f669c782484" translate="yes" xml:space="preserve">
          <source>The string returned by this method may differ from the string returned by the &lt;a href=&quot;../../lang/object#toString()&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메서드에서 반환 된 문자열은 &lt;a href=&quot;../../lang/object#toString()&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 문자열과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d86e2c12a8b526574d8ed3d4f0ad084aa1496f" translate="yes" xml:space="preserve">
          <source>The string returned by this method may differ from the string returned by the &lt;a href=&quot;../../lang/object#toString--&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드가 리턴 한 문자열은 &lt;a href=&quot;../../lang/object#toString--&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 문자열과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edba6dbdeab519bfb2488ac8fa5d24d1d5096a05" translate="yes" xml:space="preserve">
          <source>The string returned is made of the text content of this node depending on its type, as defined below:</source>
          <target state="translated">반환 된 문자열은 아래 정의 된대로 유형에 따라이 노드의 텍스트 콘텐츠로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a98b16691a6548a5f40d785a69cfe7819a08aa9f" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. At least one of the four sections must be present. The sections have suffixes in ASCII of &quot;Y&quot;, &quot;M&quot;, &quot;W&quot; and &quot;D&quot; for years, months, weeks and days, accepted in upper or lower case. The suffixes must occur in order. The number part of each section must consist of ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number must parse to an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 무시됩니다. ASCII 문자 &quot;P&quot;는 다음에 대문자 또는 소문자입니다. 그런 다음 네 개의 섹션이 있으며 각 섹션에는 숫자와 접미사가 있습니다. 네 섹션 중 하나 이상이 있어야합니다. 이 섹션에는 ASCII의 &quot;Y&quot;, &quot;M&quot;, &quot;W&quot;및 &quot;D&quot;접미사가 있습니다. 대문자, 소문자로 허용됩니다. 접미사는 순서대로 발생해야합니다. 각 섹션의 숫자 부분은 ASCII 숫자로 구성되어야합니다. 숫자 앞에 ASCII 음수 또는 양수 기호를 붙일 수 있습니다. 숫자는 &lt;code&gt;int&lt;/code&gt; 로 구문 분석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d0a3cf68706224b4e1564938792fbbb36cb2a5f2" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if &quot;T&quot; is present there must be at least one section after the &quot;T&quot;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to a &lt;code&gt;long&lt;/code&gt;. The number of seconds must parse to a &lt;code&gt;long&lt;/code&gt; with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 부정됩니다. ASCII 문자 &quot;P&quot;는 다음 대문자 또는 소문자입니다. 그런 다음 각각 숫자와 접미사로 구성된 네 개의 섹션이 있습니다. 섹션에는 &quot;D&quot;, &quot;H&quot;, &quot;M&quot;및 &quot;S&quot;라는 ASCII 접미사가 있으며 대문자 또는 소문자로 허용됩니다. 접미사는 순서대로 표시되어야합니다. ASCII 문자 &quot;T&quot;는 시간, 분 또는 두 번째 섹션의 첫 번째 발생 (있는 경우) 앞에 와야합니다. 4 개 섹션 중 하나 이상이 있어야하며 &quot;T&quot;가있는 경우 &quot;T&quot;뒤에 하나 이상의 섹션이 있어야합니다. 각 섹션의 숫자 부분은 하나 이상의 ASCII 숫자로 구성되어야합니다.숫자 앞에는 ASCII 음수 또는 양수 기호가 붙을 수 있습니다. 일, 시간 및 분 수는 &lt;code&gt;long&lt;/code&gt; . 초 수는 선택적 분수 를 사용하여 &lt;code&gt;long&lt;/code&gt; 으로 구문 분석해야합니다 . 소수점은 점 또는 쉼표 일 수 있습니다. 소수 부분은 0에서 9 자리까지 가능합니다.</target>
        </trans-unit>
        <trans-unit id="89a747d82990c6aea3987f68f6f2f3b3b15c1eff" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if &quot;T&quot; is present there must be at least one section after the &quot;T&quot;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to an &lt;code&gt;long&lt;/code&gt;. The number of seconds must parse to an &lt;code&gt;long&lt;/code&gt; with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 무시됩니다. ASCII 문자 &quot;P&quot;는 다음에 대문자 또는 소문자입니다. 그런 다음 네 개의 섹션이 있으며 각 섹션에는 숫자와 접미사가 있습니다. 이 섹션에는 ASCII로 &quot;D&quot;, &quot;H&quot;, &quot;M&quot;및 &quot;S&quot;의 접미사가 있으며 소문자, 대문자, 소문자로 허용됩니다. 접미사는 순서대로 발생해야합니다. ASCII 문자 &quot;T&quot;는 첫 번째 항목 (있는 경우), 1 분, 2 분 또는 2 초 전에 발생해야합니다. 네 개의 섹션 중 하나 이상이 있어야하며 &quot;T&quot;가 있으면 &quot;T&quot;뒤에 하나 이상의 섹션이 있어야합니다. 각 섹션의 숫자 부분은 하나 이상의 ASCII 숫자로 구성되어야합니다.숫자 앞에 ASCII 음수 또는 양수 기호를 붙일 수 있습니다. 일, 시간 및 분의 수는 &lt;code&gt;long&lt;/code&gt; . 초는 선택적 분수 를 사용하여 &lt;code&gt;long&lt;/code&gt; 으로 구문 분석해야합니다 . 소수점은 점 또는 쉼표 일 수 있습니다. 소수 부분은 0-9 자리입니다.</target>
        </trans-unit>
        <trans-unit id="4685a9bbdb9380ea8c94c58ff588b3c8fbe09edf" translate="yes" xml:space="preserve">
          <source>The string that appears after a negative number (may be empty),</source>
          <target state="translated">음수 뒤에 나오는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="121fd276daa28030f6a820cb1573874d3a75d6c9" translate="yes" xml:space="preserve">
          <source>The string that appears after a positive number (may be empty),</source>
          <target state="translated">양수 뒤에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="5bdb1009de16112ed78878cf54efa430f792f9b9" translate="yes" xml:space="preserve">
          <source>The string that appears before a negative number (may be empty),</source>
          <target state="translated">음수 앞에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="ca10167dd9b711a6fe69878b203a07e7493844d5" translate="yes" xml:space="preserve">
          <source>The string that appears before a positive number (may be empty),</source>
          <target state="translated">양수 앞에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="1230518d13d5910243029a9e67f1cba26841e687" translate="yes" xml:space="preserve">
          <source>The string that represents infinity for floating-point values,</source>
          <target state="translated">부동 소수점 값의 무한대를 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="0ef60f4fe5623badec9511506d8c3e9aab99fce8" translate="yes" xml:space="preserve">
          <source>The string that represents not-a-number for floating-point values,</source>
          <target state="translated">부동 소수점 값의 숫자가 아님을 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="a78a098297ed979ec8fd87a13cc391ae93c8972a" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens.</source>
          <target state="translated">문자열 토크 나이저 클래스는 애플리케이션이 문자열을 토큰으로 나눌 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="04fb2cffb71f257048052d20b8fe56a4f66e790f" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens. The tokenization method is much simpler than the one used by the &lt;code&gt;StreamTokenizer&lt;/code&gt; class. The &lt;code&gt;StringTokenizer&lt;/code&gt; methods do not distinguish among identifiers, numbers, and quoted strings, nor do they recognize and skip comments.</source>
          <target state="translated">문자열 토크 나이저 클래스를 사용하면 응용 프로그램에서 문자열을 토큰으로 나눌 수 있습니다. 토큰 화 방법은 &lt;code&gt;StreamTokenizer&lt;/code&gt; 클래스에서 사용하는 방법보다 훨씬 간단합니다 . &lt;code&gt;StringTokenizer&lt;/code&gt; 방법은 식별자, 숫자, 인용 된 문자열을 구분 없으며 인식하고 설명을 생략하지 않는다.</target>
        </trans-unit>
        <trans-unit id="53fa55c105fb0b4c765bc0d34087bf552da7b9c4" translate="yes" xml:space="preserve">
          <source>The string used to display the String in the syntax of the scripting language.</source>
          <target state="translated">스크립트 언어의 구문으로 문자열을 표시하는 데 사용되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c78459f86d1f255e120d7d995d1329b245c41ee8" translate="yes" xml:space="preserve">
          <source>The string value of the output property, or null if no property was found.</source>
          <target state="translated">출력 속성의 문자열 값 또는 속성이 없으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="6b860b97ae2648994958ff5f145b7575c2d21991" translate="yes" xml:space="preserve">
          <source>The string value.</source>
          <target state="translated">문자열 값</target>
        </trans-unit>
        <trans-unit id="f11c947d653626328bad48f1c4cdf9159acc0a3b" translate="yes" xml:space="preserve">
          <source>The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).</source>
          <target state="translated">이 클래스의 인스턴스에서 숫자로 구문 분석 할 수있는 문자열은 다음 정규식 문법으로 지정됩니다. 여기서 Rmax는 사용되는 기수에서 가장 높은 자릿수입니다 (예 : 밑 10의 경우 Rmax는 9).</target>
        </trans-unit>
        <trans-unit id="192956733edd06bdd0c654a6ba995e1bcee04c0f" translate="yes" xml:space="preserve">
          <source>The structure and contents of the &quot;native&quot; metadata format are defined by the plug-in that created this &lt;code&gt;IIOMetadata&lt;/code&gt; object. Plug-ins for simple formats will usually create a dummy node for the root, and then a series of child nodes representing individual tags, chunks, or keyword/value pairs. A plug-in may choose whether or not to document its native format.</source>
          <target state="translated">&quot;네이티브&quot;메타 데이터 형식의 구조와 내용은이 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체 를 생성 한 플러그인에 의해 정의됩니다 . 간단한 형식의 플러그인은 일반적으로 루트에 대한 더미 노드를 만든 다음 개별 태그, 청크 또는 키워드 / 값 쌍을 나타내는 일련의 자식 노드를 만듭니다. 플러그인은 고유 형식을 문서화할지 여부를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d00af5b5c0dfb3866ccfa55c912f873c782dbff" translate="yes" xml:space="preserve">
          <source>The structure and encoding of Oids is defined in ISOIEC-8824 and ISOIEC-8825. For example the Oid representation of Kerberos V5 mechanism is &quot;1.2.840.113554.1.2.2&quot;</source>
          <target state="translated">Oid의 구조와 인코딩은 ISOIEC-8824 및 ISOIEC-8825에 정의되어 있습니다. 예를 들어 Kerberos V5 메커니즘의 Oid 표현은 &quot;1.2.840.113554.1.2.2&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="cb2c5dc909eef768d7f9cd7e34bb554bcaaaebaa" translate="yes" xml:space="preserve">
          <source>The structure is a return type accompanied by any number of parameter types. The types (primitive, &lt;code&gt;void&lt;/code&gt;, and reference) are represented by &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; objects. (For ease of exposition, we treat &lt;code&gt;void&lt;/code&gt; as if it were a type. In fact, it denotes the absence of a return type.)</source>
          <target state="translated">구조는 여러 매개 변수 유형과 함께 리턴 유형입니다. 유형 (primitive, &lt;code&gt;void&lt;/code&gt; 및 reference)은 &lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 객체 로 표시됩니다 . (노출을 쉽게하기 위해 &lt;code&gt;void&lt;/code&gt; 를 타입처럼 취급 합니다. 실제로는 리턴 타입이 없음을 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="fdfbb9e2e84d666d2a855ee7c1631508d148c17f" translate="yes" xml:space="preserve">
          <source>The structures that may be described by this class are a subset of those expressible using XML document type definitions (DTDs), with the addition of some basic information on the datatypes of attributes and the ability to store an &lt;code&gt;Object&lt;/code&gt; reference within a node. In the future, XML Schemas could be used to represent these structures, and many others.</source>
          <target state="translated">이 클래스에서 설명 할 수있는 구조는 속성의 데이터 유형에 대한 몇 가지 기본 정보와 노드 내에 &lt;code&gt;Object&lt;/code&gt; 참조 를 저장하는 기능과 함께 XML 문서 유형 정의 (DTD)를 사용하여 표현할 수있는 구조의 서브 세트입니다 . 미래에는 XML 스키마를 사용하여 이러한 구조 및 기타 여러 구조를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1300b7e4fbbe647c420f08d4ea464e607a0b93" translate="yes" xml:space="preserve">
          <source>The stub class is loaded by name using the class loader of the root class. The stub class must be public, it must extend &lt;a href=&quot;remotestub&quot;&gt;&lt;code&gt;RemoteStub&lt;/code&gt;&lt;/a&gt;, it must reside in a package that is exported to at least the &lt;code&gt;java.rmi&lt;/code&gt; module, and it must have a public constructor that has one parameter of type &lt;a href=&quot;remoteref&quot;&gt;&lt;code&gt;RemoteRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스텁 클래스는 루트 클래스의 클래스 로더를 사용하여 이름별로로드됩니다. 스텁 클래스는 공용 이어야하고 &lt;a href=&quot;remotestub&quot;&gt; &lt;code&gt;RemoteStub&lt;/code&gt; 을&lt;/a&gt; 확장 해야하며 최소한 &lt;code&gt;java.rmi&lt;/code&gt; 모듈로 내 보내진 패키지에 있어야하며 &lt;a href=&quot;remoteref&quot;&gt; &lt;code&gt;RemoteRef&lt;/code&gt; &lt;/a&gt; 유형의 매개 변수가 하나있는 공용 생성자를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="a232a3677fbba52c761d261392a47c4a403e95f0" translate="yes" xml:space="preserve">
          <source>The stub might not yet be connected to the ORB. The stub will be serializable only if it is connected to the ORB.</source>
          <target state="translated">스텁이 아직 ORB에 연결되지 않았을 수 있습니다. 스텁은 ORB에 연결된 경우에만 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7ed2b6144ace5c60a1401e5428a1fc3686ffe408" translate="yes" xml:space="preserve">
          <source>The style of this &lt;code&gt;Font&lt;/code&gt;, as passed to the constructor.</source>
          <target state="translated">생성자에 전달 된 이 &lt;code&gt;Font&lt;/code&gt; 스타일입니다 .</target>
        </trans-unit>
        <trans-unit id="498a3c78ad0c0604083f3769f1ef9e8b0c526e13" translate="yes" xml:space="preserve">
          <source>The style of this &lt;code&gt;Font&lt;/code&gt;, as passed to the constructor. This style can be PLAIN, BOLD, ITALIC, or BOLD+ITALIC.</source>
          <target state="translated">생성자에 전달 된 이 &lt;code&gt;Font&lt;/code&gt; 스타일입니다 . 이 스타일은 PLAIN, BOLD, ITALIC 또는 BOLD + ITALIC 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff2ab664c61a826342f48467d919591b7be5528" translate="yes" xml:space="preserve">
          <source>The sub-range is defined to be out of bounds if any of the following inequalities is true:</source>
          <target state="translated">다음 부등식 중 하나라도 참인 경우 하위 범위는 범위를 벗어난 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e5c879c6bdae17e077ece202d05c591a659999bb" translate="yes" xml:space="preserve">
          <source>The subclass may supply a different base name for the resource bundles using the &lt;code&gt;setResourceBaseName&lt;/code&gt; method.</source>
          <target state="translated">서브 클래스는 &lt;code&gt;setResourceBaseName&lt;/code&gt; 메소드를 사용하여 자원 번들에 다른 기본 이름을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="527c0a0960cc0fe34b4ce860e5a1c2222c46e968" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; for the SQLState class value '</source>
          <target state="translated">SQLState 클래스 값 '에 대한 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="7713c2f78de0d5ff78645f34f1aa9c89839a8b5a" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown in situations where a previously failed operation might be able to succeed when the operation is retried without any intervention by application-level functionality.</source>
          <target state="translated">&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 서브 클래스는 이전에 실패한 조작이 애플리케이션 레벨 기능의 개입없이 조작이 재 시도 될 때 성공할 수있는 상황에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80f483f7072263836c5107593eb17db254d36bf4" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown when one or more client info properties could not be set on a &lt;code&gt;Connection&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스는 하나 이상의 클라이언트 정보 속성을 &lt;code&gt;Connection&lt;/code&gt; 에서 설정할 수 없을 때 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="7b3fc8fd4fb26a88d9f95ef4851700e0411e08a2" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown when one or more client info properties could not be set on a &lt;code&gt;Connection&lt;/code&gt;. In addition to the information provided by &lt;code&gt;SQLException&lt;/code&gt;, a &lt;code&gt;SQLClientInfoException&lt;/code&gt; provides a list of client info properties that were not set. Some databases do not allow multiple client info properties to be set atomically. For those databases, it is possible that some of the client info properties had been set even though the &lt;code&gt;Connection.setClientInfo&lt;/code&gt; method threw an exception. An application can use the &lt;code&gt;getFailedProperties &lt;/code&gt; method to retrieve a list of client info properties that were not set. The properties are identified by passing a &lt;code&gt;Map&amp;lt;String,ClientInfoStatus&amp;gt;&lt;/code&gt; to the appropriate &lt;code&gt;SQLClientInfoException&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스는 하나 이상의 클라이언트 정보 속성을 &lt;code&gt;Connection&lt;/code&gt; 에서 설정할 수 없을 때 발생 합니다 . &lt;code&gt;SQLException&lt;/code&gt; 에서 제공하는 정보 외에도 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 은 설정되지 않은 클라이언트 정보 속성 목록을 제공합니다. 일부 데이터베이스에서는 여러 클라이언트 정보 속성을 원자 적으로 설정할 수 없습니다. 이러한 데이터베이스의 경우 &lt;code&gt;Connection.setClientInfo&lt;/code&gt; 메서드에서 예외가 발생 했음에도 불구하고 클라이언트 정보 속성 중 일부가 설정되었을 수 있습니다. 애플리케이션은 &lt;code&gt;getFailedProperties &lt;/code&gt; 메소드를 사용하여 설정되지 않은 클라이언트 정보 특성 목록을 검색 할 수 있습니다 . 속성은 &lt;code&gt;Map&amp;lt;String,ClientInfoStatus&amp;gt;&lt;/code&gt; 를 적절한 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 생성자에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="6717effbf2eae66083ee44deed5d8b60c5c6fe2d" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown for the SQLState class value '</source>
          <target state="translated">SQLState 클래스 값 '에 대해 throw 된 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스</target>
        </trans-unit>
        <trans-unit id="8607beac95f1d4cb0f607da7d63685d6dfbf8d4c" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch.</source>
          <target state="translated">애플리케이션이 일부 복구 단계를 수행하고 전체 트랜잭션을 재 시도하는 경우 이전에 실패한 작업이 성공할 수있는 상황에서 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 또는 분산 트랜잭션의 경우 트랜잭션 분기입니다.</target>
        </trans-unit>
        <trans-unit id="bbb8274ee2db6a0201b391b30cdfd8adbecfb841" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch. At a minimum, the recovery operation must include closing the current connection and getting a new connection.</source>
          <target state="translated">애플리케이션이 일부 복구 단계를 수행하고 전체 트랜잭션을 재 시도하는 경우 이전에 실패한 작업이 성공할 수있는 상황에서 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 또는 분산 트랜잭션의 경우 트랜잭션 분기입니다. 최소한 복구 작업에는 현재 연결 닫기 및 새 연결 가져 오기가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a54587a45ff8b2645e125fd0b8ffb8307a8ef66b" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an error occurs during a batch update operation.</source>
          <target state="translated">일괄 업데이트 작업 중에 오류가 발생할 때 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="803499fb5061ae4d61cec028a03de443ffd7786f" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an error occurs during a batch update operation. In addition to the information provided by &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;BatchUpdateException&lt;/code&gt; provides the update counts for all commands that were executed successfully during the batch update, that is, all commands that were executed before the error occurred. The order of elements in an array of update counts corresponds to the order in which commands were added to the batch.</source>
          <target state="translated">일괄 업데이트 작업 중에 오류가 발생할 때 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 에서 제공하는 정보 외에도 &lt;code&gt;BatchUpdateException&lt;/code&gt; 은 일괄 업데이트 중에 성공적으로 실행 된 모든 명령, 즉 오류가 발생하기 전에 실행 된 모든 명령에 대한 업데이트 횟수를 제공합니다. 업데이트 수 배열의 요소 순서는 명령이 배치에 추가 된 순서에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="72d539ca6fdd4b7c88bd110f4dcd389de1ff790c" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an instance where a retry of the same operation would fail unless the cause of the &lt;code&gt;SQLException&lt;/code&gt; is corrected.</source>
          <target state="translated">의 서브 클래스 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 원인 않는 한, 같은 조작을 재 시행해도 인스턴스가 실패 할 경우에 throw &lt;code&gt;SQLException&lt;/code&gt; 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="040505f7787304a32e3c75ae93a27084235243c1" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when the SQLState class value is '</source>
          <target state="translated">SQLState 클래스 값이 '인 경우 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스</target>
        </trans-unit>
        <trans-unit id="ccf2e655300c92dbbb85b4f642a0803f74b73233" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when the timeout specified by &lt;code&gt;Statement.setQueryTimeout&lt;/code&gt;, &lt;code&gt;DriverManager.setLoginTimeout&lt;/code&gt;, &lt;code&gt;DataSource.setLoginTimeout&lt;/code&gt;,&lt;code&gt;XADataSource.setLoginTimeout&lt;/code&gt; has expired.</source>
          <target state="translated">&lt;code&gt;Statement.setQueryTimeout&lt;/code&gt; , &lt;code&gt;DriverManager.setLoginTimeout&lt;/code&gt; , &lt;code&gt;DataSource.setLoginTimeout&lt;/code&gt; , &lt;code&gt;XADataSource.setLoginTimeout&lt;/code&gt; 에 의해 지정된 제한 시간 이 만료 되었을 때 발생 하는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="62072bc327b8cecfe4f10440c7fba64d72ceae2d" translate="yes" xml:space="preserve">
          <source>The subclass returned depends on the value of &lt;a href=&quot;#isParseBigDecimal()&quot;&gt;&lt;code&gt;isParseBigDecimal()&lt;/code&gt;&lt;/a&gt; as well as on the string being parsed.</source>
          <target state="translated">반환되는 하위 클래스는 &lt;a href=&quot;#isParseBigDecimal()&quot;&gt; &lt;code&gt;isParseBigDecimal()&lt;/code&gt; &lt;/a&gt; 의 값과 구문 분석되는 문자열에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="bac1d40c541f2bc78282b5fcf04be8326df2e993" translate="yes" xml:space="preserve">
          <source>The subclass returned depends on the value of &lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt;&lt;code&gt;isParseBigDecimal()&lt;/code&gt;&lt;/a&gt; as well as on the string being parsed.</source>
          <target state="translated">리턴되는 서브 클래스는 &lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt; &lt;code&gt;isParseBigDecimal()&lt;/code&gt; &lt;/a&gt; 의 값과 구문 분석되는 문자열에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b79749f58cf1bfcecb1d563bcce417c79a3f48ee" translate="yes" xml:space="preserve">
          <source>The subclass's &lt;code&gt;set(int, E)&lt;/code&gt;, &lt;code&gt;get(int)&lt;/code&gt;, &lt;code&gt;add(int, E)&lt;/code&gt;, &lt;code&gt;remove(int)&lt;/code&gt;, &lt;code&gt;addAll(int,
 Collection)&lt;/code&gt; and &lt;code&gt;removeRange(int, int)&lt;/code&gt; methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The &lt;code&gt;addAll(Collection c)&lt;/code&gt; method merely returns &lt;code&gt;addAll(size,
 c)&lt;/code&gt;.</source>
          <target state="translated">서브 클래스의 &lt;code&gt;set(int, E)&lt;/code&gt; , &lt;code&gt;get(int)&lt;/code&gt; , &lt;code&gt;add(int, E)&lt;/code&gt; , &lt;code&gt;remove(int)&lt;/code&gt; , &lt;code&gt;addAll(int, Collection)&lt;/code&gt; 및 &lt;code&gt;removeRange(int, int)&lt;/code&gt; 메소드는 모두 기본 초록의 해당 메소드에 위임됩니다. 인덱스의 경계를 확인하고 오프셋을 조정 한 후 목록. &lt;code&gt;addAll(Collection c)&lt;/code&gt; 방법은 단순히 반환 &lt;code&gt;addAll(size, c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729c3d64219547cb810998bd0f169dacbb67b1a4" translate="yes" xml:space="preserve">
          <source>The subclasses of &lt;code&gt;LayerUI&lt;/code&gt; can either be stateless and shareable by multiple &lt;code&gt;JLayer&lt;/code&gt;s or not shareable.</source>
          <target state="translated">&lt;code&gt;LayerUI&lt;/code&gt; 의 하위 클래스는 상태 비 저장이고 여러 &lt;code&gt;JLayer&lt;/code&gt; 에서 공유 할 수 있거나 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="41754262853cd8dda8e7145fb4fe6436a4d4ac99" translate="yes" xml:space="preserve">
          <source>The subprocess is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the subprocess continues executing asynchronously.</source>
          <target state="translated">&lt;code&gt;Process&lt;/code&gt; 오브젝트에 대한 참조가 더 이상 없을 때 서브 프로세스가 종료되지 않고 서브 프로세스가 비동기 적으로 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7df4f8cdb60df8a1704c9b01b240279889a753" translate="yes" xml:space="preserve">
          <source>The subscriber returned by this handler is not flow controlled. Therefore, the supplied consumer must be able to process whatever amount of data is delivered in a timely fashion.</source>
          <target state="translated">이 처리기에 의해 반환 된 구독자는 흐름이 제어되지 않습니다. 따라서 공급 된 소비자는 제공되는 데이터 양에 관계없이 적시에 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="24df0de55c6e5cbab8a446a4d7da62cab861430c" translate="yes" xml:space="preserve">
          <source>The subsequence of the argument &lt;code&gt;s&lt;/code&gt; specified by &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are inserted, in order, into this sequence at the specified destination offset, moving up any characters originally above that position. The length of this sequence is increased by &lt;code&gt;end - start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 로 지정된 인수 &lt;code&gt;s&lt;/code&gt; 하위 시퀀스는 지정된 대상 오프셋에서이 시퀀스에 순서대로 삽입되어 원래 해당 위치 위에있는 문자를 위로 이동합니다. 이 시퀀스의 길이는 &lt;code&gt;end - start&lt;/code&gt; 증가 합니다 .</target>
        </trans-unit>
        <trans-unit id="98347390f1f0edc351744b3bec1803d66b95c900" translate="yes" xml:space="preserve">
          <source>The subtract filter operation.</source>
          <target state="translated">빼기 필터 연산입니다.</target>
        </trans-unit>
        <trans-unit id="9bb649597713d07a6a3f68ef4b622114bd9bb42f" translate="yes" xml:space="preserve">
          <source>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a &lt;code&gt;NaN&lt;/code&gt; or the sum is at any point a &lt;code&gt;NaN&lt;/code&gt; then the sum will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">반환되는 합계는 크기가 다른 값의 누적 반올림 오차로 인해 값이 기록되는 순서에 따라 달라질 수 있습니다. 절대 크기를 늘리면 정렬 된 값이 더 정확한 결과를 얻는 경향이 있습니다. 기록 된 값이 &lt;code&gt;NaN&lt;/code&gt; 이거나 합계가 &lt;code&gt;NaN&lt;/code&gt; 이면 합계는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5b109e54c81cacf004fb931535e7f7c5e9a6ad4" translate="yes" xml:space="preserve">
          <source>The super class of all menu related containers.</source>
          <target state="translated">모든 메뉴 관련 컨테이너의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2edd5140cff4220974aa4530adeee309c448831e" translate="yes" xml:space="preserve">
          <source>The superclass behavior will try to update the child views which is not desired in this case, since the children are zones and not directly effected by the changes to the associated element.</source>
          <target state="translated">수퍼 클래스 비헤이비어는이 경우에는 원하지 않는 자식 뷰를 업데이트하려고 할 것입니다. 자식은 영역이고 관련 요소의 변경에 의해 직접 영향을받지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="223c3b7c239c5d80bf9c6472a205737e2c00d21b" translate="yes" xml:space="preserve">
          <source>The superclass behavior will try to update the child views which is not desired in this case, since the children are zones and not directly effected by the changes to the associated element. This is reimplemented to do nothing and return false.</source>
          <target state="translated">수퍼 클래스 비헤이비어는이 경우에는 원하지 않는 자식 뷰를 업데이트하려고 할 것입니다. 자식은 영역이고 관련 요소의 변경에 의해 직접 영향을받지 않기 때문입니다. 아무것도하지 않고 false를 반환하도록 다시 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="602000e37c0a2e549407c0c276a26b61377db86f" translate="yes" xml:space="preserve">
          <source>The supertypes (both class and interface types) of a declared type may be found using the &lt;a href=&quot;../util/types#directSupertypes(javax.lang.model.type.TypeMirror)&quot;&gt;&lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt;&lt;/a&gt; method. This returns the supertypes with any type arguments substituted in.</source>
          <target state="translated">선언 된 유형의 상위 유형 (클래스 및 인터페이스 유형 모두)은 &lt;a href=&quot;../util/types#directSupertypes(javax.lang.model.type.TypeMirror)&quot;&gt; &lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 찾을 수 있습니다 . 이는 모든 유형 인수가 대체 된 상위 유형을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8b4fd272478c2bf5755a6c3fbfac56931cb9665d" translate="yes" xml:space="preserve">
          <source>The supertypes (both class and interface types) of a declared type may be found using the &lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt;&lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt;&lt;/a&gt; method. This returns the supertypes with any type arguments substituted in.</source>
          <target state="translated">선언 된 유형의 수퍼 타입 ​​(클래스 및 인터페이스 유형 모두)은 &lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt; &lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 찾을 수 있습니다 . 타입 인수가 치환 된 슈퍼 타입을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="14dfb8fa2619f0e88128d788e30861e3728092dc" translate="yes" xml:space="preserve">
          <source>The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. For predictable results, the accumulator function should be commutative and associative within the floating point tolerance required in usage contexts. The function is applied with an existing value (or identity) as one argument, and a given update as the other argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Double::max&lt;/code&gt; along with &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.</source>
          <target state="translated">제공된 누산기 함수는 스레드 간의 경합으로 인해 업데이트 시도가 실패 할 때 다시 적용될 수 있으므로 부작용이 없어야합니다. 예측 가능한 결과를 위해 누산기 함수는 사용 컨텍스트에 필요한 부동 소수점 허용 범위 내에서 교환 및 연관이어야합니다. 함수는 기존 값 (또는 ID)을 하나의 인수로 적용하고 주어진 업데이트를 다른 인수로 적용합니다. 예를 들어 실행중인 최대 값을 유지하려면 &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; 와 함께 &lt;code&gt;Double::max&lt;/code&gt; 를 ID로 제공 할 수 있습니다. 스레드 내부 또는 스레드 간의 누적 순서는 보장되지 않습니다. 따라서이 등급은 수치 안정성이 필요한 경우 적용되지 않을 수 있습니다. 특히 크기가 상당히 다른 값을 결합 할 때 더욱 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="6acd237472bddb6f88b28a9f2fd993ab87094ddb" translate="yes" xml:space="preserve">
          <source>The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Double::max&lt;/code&gt; along with &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.</source>
          <target state="translated">제공된 어큐뮬레이터 기능은 부작용이 없어야합니다. 스레드 간의 경합으로 인해 업데이트 시도가 실패하면 다시 적용될 수 있습니다. 이 함수는 현재 값을 첫 번째 인수로, 지정된 업데이트를 두 번째 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하기 위해 &lt;code&gt;Double::max&lt;/code&gt; 를 &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; 와 함께 ID로 제공 할 수 있습니다. 스레드 내에서 또는 스레드 간 누적 순서는 보장되지 않습니다. 따라서 수치 안정성이 필요한 경우, 특히 실질적으로 다른 차수의 값을 결합 할 때이 등급을 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6025b666165a1f5fda89da5a8e8ee1de31444459" translate="yes" xml:space="preserve">
          <source>The supplied array holding three internalized strings representing the Namespace URI (or empty string), the local name, and the XML qualified name; or null if there is an undeclared prefix.</source>
          <target state="translated">네임 스페이스 URI (또는 빈 문자열), 로컬 이름 및 XML 규정 이름을 나타내는 세 개의 내부화 된 문자열을 보유하는 제공된 배열. 선언되지 않은 접두사가있는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="7ad24e24ba3ab22cd4ef21994274386c9cd69325" translate="yes" xml:space="preserve">
          <source>The supplied object parameter acts as an optional configuration argument. For example, it could be of type &lt;code&gt;Component&lt;/code&gt;. A &lt;code&gt;Painter&lt;/code&gt; that expected it could then read state from that &lt;code&gt;Component&lt;/code&gt; and use the state for painting. For example, an implementation may read the backgroundColor and use that.</source>
          <target state="translated">제공된 개체 매개 변수는 선택적 구성 인수 역할을합니다. 예를 들어 &lt;code&gt;Component&lt;/code&gt; 유형일 수 있습니다 . 그런 다음 해당 &lt;code&gt;Component&lt;/code&gt; 에서 상태를 읽고 페인팅에 상태를 사용할 수 있다고 예상 한 &lt;code&gt;Painter&lt;/code&gt; 입니다 . 예를 들어 구현은 backgroundColor를 읽고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84e7dcea201cffacdcbf9be7a2353ff95d845a5" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer should generate them internally.</source>
          <target state="translated">제공된 축소판 그림은 필요한 경우 크기가 조정되며 지원되는 수를 초과하는 축소판 그림은 무시됩니다. 형식에 제공되지 않은 추가 축소판 그림이 필요한 경우 작성자는 내부에서 축소판 그림을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="753904bcbd3964af858d18cda3d913205d84b5e6" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer will generate them internally.</source>
          <target state="translated">제공된 축소판 그림은 필요한 경우 크기가 조정되며 지원되는 수를 초과하는 축소판 그림은 무시됩니다. 형식에 제공되지 않은 추가 축소판 그림이 필요한 경우 기록기는 내부에서 축소판 그림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bce2b22d14479cd69e56124d69d47db8b57076ba" translate="yes" xml:space="preserve">
          <source>The support for this is provided by the &lt;code&gt;StyleSheet&lt;/code&gt; class. The presentation of the HTML can be heavily influenced by the setting of the StyleSheet property on the EditorKit.</source>
          <target state="translated">이에 대한 지원은 &lt;code&gt;StyleSheet&lt;/code&gt; 클래스에서 제공합니다 . HTML의 표현은 EditorKit의 StyleSheet 속성 설정에 의해 크게 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc15d8eee723cd7e4ccfbd5a0f0bd59ce88d1002" translate="yes" xml:space="preserve">
          <source>The supported &lt;code&gt;ChronoField&lt;/code&gt; instances are:</source>
          <target state="translated">지원되는 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b2cd39555d2c728a665b32d4100c19f45b92402" translate="yes" xml:space="preserve">
          <source>The supported calendar systems includes:</source>
          <target state="translated">지원되는 캘린더 시스템에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="83bd48a0eac4e9b358a53d73d8f0c393f28dcfbc" translate="yes" xml:space="preserve">
          <source>The supported categories are those of &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt; &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the &lt;a href=&quot;../../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; class. The category names are those defined in the Standard, both normative and informative.</source>
          <target state="translated">지원되는 범주는 &lt;a href=&quot;../../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; 클래스에서 지정한 버전 의 &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; 범주 입니다. 범주 이름은 규범 및 유익한 표준에서 정의 된 이름입니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="27c2737ecb716851489499e7d8287bbcd13402f5" translate="yes" xml:space="preserve">
          <source>The supported component types (variables types) are &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">지원되는 구성 요소 유형 (변수 유형)은 &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f2e9acf0920ea9550ff69da281e2ea26f2481f3" translate="yes" xml:space="preserve">
          <source>The supported syntax is:</source>
          <target state="translated">지원되는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d6a5bc82895e1be1c598d816a928419e077fb62" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt;. They are returned in the order seconds, nanos.</source>
          <target state="translated">지원되는 단위는 &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt; 입니다. 그들은 몇 초, 나노 단위로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50995038a878ce286701de766382bef69778b604" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in the order years, months, days.</source>
          <target state="translated">지원되는 단위는 &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 입니다. 그들은 년, 월, 일 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7618ee46d4016ebcae2e5cbf1a065473c760968b" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Requesting an unsupported unit will throw an exception.</source>
          <target state="translated">지원되는 단위는 연대순입니다. 그들은 일반적으로 될 것 &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; . 지원되지 않는 유닛을 요청하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b30d06d3ef729bd157ab81214e7e89bcf4f23fd7" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in order from largest to smallest.</source>
          <target state="translated">지원되는 단위는 연대순입니다. 그들은 일반적으로 될 것 &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; . 가장 큰 것부터 가장 작은 것까지 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="612ea5ebf89d96a0eba935a9ea4b0154afc481ad" translate="yes" xml:space="preserve">
          <source>The supported units of a period are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. All three fields are always present, but may be set to zero.</source>
          <target state="translated">지원되는 기간의 단위는 &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 입니다. 세 필드는 모두 항상 존재하지만 0으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba6f6bccc56ef3d310dd0f60418a50729535d8d9" translate="yes" xml:space="preserve">
          <source>The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;via a constructor&lt;/a&gt;. When suppression is disabled, this method does nothing other than to validate its argument.</source>
          <target state="translated">&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;생성자를 통해&lt;/a&gt; 비활성화 &lt;em&gt;하지 않는 한&lt;/em&gt; 억제 동작이 활성화 &lt;em&gt;됩니다&lt;/em&gt; . 억제가 비활성화 된 경우이 메서드는 인수의 유효성을 검사하는 것 외에 다른 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5be801d8d7c141429eb2a06d10b0aef903302c4" translate="yes" xml:space="preserve">
          <source>The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;via a constructor&lt;/a&gt;. When suppression is disabled, this method does nothing other than to validate its argument.</source>
          <target state="translated">&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;생성자를 통해&lt;/a&gt; 비활성화 &lt;em&gt;하지 않으면&lt;/em&gt; 억제 동작이 활성화 &lt;em&gt;됩니다&lt;/em&gt; . 억제를 무효로하면 (자),이 메소드는 인수를 검증하는 것 외에는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d792cc659c3710e68412ad26001e0365e4fe31b" translate="yes" xml:space="preserve">
          <source>The swing text components provide some support of thread safe operations. Because of the high level of configurability of the text components, it is possible to circumvent the protection provided. The protection primarily comes from the model, so the documentation of &lt;code&gt;AbstractDocument&lt;/code&gt; describes the assumptions of the protection provided. The methods that are safe to call asynchronously are marked with comments.</source>
          <target state="translated">스윙 텍스트 구성 요소는 스레드 안전 작업을 일부 지원합니다. 텍스트 구성 요소의 높은 수준의 구성 가능성으로 인해 제공된 보호 기능을 우회 할 수 있습니다. 보호는 주로 모델에서 제공되므로 &lt;code&gt;AbstractDocument&lt;/code&gt; 의 문서는 제공된 보호의 가정을 설명합니다. 비동기 적으로 호출해도 안전한 메서드는 주석으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="841ed2261b840ee034e2fc667a839f1eea97e56b" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchange&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchange&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_EXCHANGE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="80c4a3b73d48513a6615b83f39f27edf617e75d0" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchangeAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchangeAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6fd514eb09ba3f8f2597220841a1a986e13cd4bc" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchangeRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchangeRelease&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8383b8927a886acbd2d87b4f789aa3cd1800f65" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndSet&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fc1fe303a671f659dfcb75ed69ad915a0b9cf34" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSet&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2d6fc33cce92819cac6f3c0aae23a1e0f658baf" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetAcquire&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c238fc4ba306a85bf1a7b6a1059990d27fd23416" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetPlain&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetPlain&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN) 을 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3caa02cdc85af699be3da720087d3b254a1e0d14" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetRelease&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d92d0c26fd0ceacd6a22912f8e08a2af1144ac03" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;get&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="785e11e22d0e4f59f3c358dd707d0c8bb9c45c5d" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_ACQUIRE) 호출 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3909d7fd71a3ce0d45b42b91b83a4cb3a38cc4c7" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAdd&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAdd&lt;/code&gt; 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_ADD) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b8c1e07e45f3df0e3f4c7960f4689cc7ff853fb5" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAddAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAddAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_ADD_ACQUIRE) 호출 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb3556eafa083c922f5ddc536ef70abc23d8064c" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAddRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAddRelease&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_ADD_RELEASE) 호출 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aab207cd06c5ec5d7499697ca6ba7769359b6579" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAnd&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAnd&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_AND) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="836795e8bc56b921c84886828b4ff0823073d2b0" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAndAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAndAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE) 호출 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78cc40ca583a385f170594f785f938d9b667b6eb" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAndRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAndRelease&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="845f2ed88bc26c3452225eb1d4ee813e31903cab" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOr&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOr&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_OR) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ddd9f837d79fd41f1a93fe6a1f1e69fb4737c0f" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOrAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOrAcquire&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b92e606932a5540d338db4148a4c5b8e213940b9" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOrRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOrRelease&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="248d840d1056e103e71ed4367a20a6f5c5c6b14b" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXor&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXor&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_XOR) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6603458f74711c546450ff99c0fa6a4f391bc1ad" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXorAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXorAcquire&lt;/code&gt; 의 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="582cd1e29d747ef96d86945b9cc3596d644def63" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXorRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXorRelease&lt;/code&gt; 의 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b49e84c3b73b7c67f75202b8dcf68959c3b67df" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSet&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="726283d34708064e448798ed7558fd26056194bc" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSetAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSetAcquire&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_SET_ACQUIRE) 호출 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d72b516be7afed65c7b9b32c7e234a778cc590e8" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSetRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSetRelease&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_SET_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4a3f7c47047a21314dc4bcc3cfef336f2dea3704" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getOpaque&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_OPAQUE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getOpaque&lt;/code&gt; 의 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_OPAQUE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_OPAQUE) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="80d17bb7d7e04c4f675b8b6a6964580c44801bf2" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getVolatile&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_VOLATILE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getVolatile&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_VOLATILE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_VOLATILE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="94be2d0c54621beaec5e232a04f1856df457acaf" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;set&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="158dfc3921c96e11341de806f439c35a94497773" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setOpaque&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_OPAQUE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setOpaque&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_OPAQUE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET_OPAQUE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="342170d52a224940f39c38e69957aa300beeb148" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setRelease&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="68ed9d8b4bcd184b8baaaf811374d5c92f6c83db" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setVolatile&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_VOLATILE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setVolatile&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_VOLATILE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET_VOLATILE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52423f32e1b10ddbf83308406995a99e390cdeaf" translate="yes" xml:space="preserve">
          <source>The synchronization mechanism that provides reader/writer capabilities for disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체에 대한 읽기 / 쓰기 기능을 제공하는 동기화 메커니즘입니다 .</target>
        </trans-unit>
        <trans-unit id="711ab65736cb44038b84d447045e9ee485fba83d" translate="yes" xml:space="preserve">
          <source>The synchronization mechanism that provides reader/writer capabilities for disconnected &lt;code&gt;RowSet&lt;/code&gt; objects. A &lt;code&gt;SyncProvider&lt;/code&gt; implementation is a class that extends the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체에 대한 읽기 / 쓰기 기능을 제공하는 동기화 메커니즘입니다 . &lt;code&gt;SyncProvider&lt;/code&gt; 구현은 확장하는 클래스 &lt;code&gt;SyncProvider&lt;/code&gt; 추상 클래스를.</target>
        </trans-unit>
        <trans-unit id="4e55e499a6fc5c1dbd4e8b7511cc0424a80a9f71" translate="yes" xml:space="preserve">
          <source>The syntactic locations where annotations may appear are split into &lt;em&gt;declaration contexts&lt;/em&gt; , where annotations apply to declarations, and &lt;em&gt;type contexts&lt;/em&gt; , where annotations apply to types used in declarations and expressions.</source>
          <target state="translated">주석이 나타날 수있는 구문 적 위치는 &lt;em&gt;선언 컨텍스트 (&lt;/em&gt; 주석이 선언에 적용되는 경우)와 &lt;em&gt;유형 컨텍스트 (&lt;/em&gt; 주석이 선언 및 표현식에 사용 된 형식에 적용되는) 로 분할됩니다 .</target>
        </trans-unit>
        <trans-unit id="00a77c038c4619155739ddefe087cb77c766d025" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;URL&lt;/code&gt; is defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described &lt;a href=&quot;inet6address#scoped&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">의 구문 &lt;code&gt;URL&lt;/code&gt; 은 에 의해 정의되는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;범용 리소스 식별자 (URI) : 일반 구문 RFC 2396&lt;/i&gt;&lt;/a&gt; 에 의해 개정 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732 : URL에 리터럴 IPv6 주소 형식&lt;/i&gt;&lt;/a&gt; . 리터럴 IPv6 주소 형식은 scope_id도 지원합니다. scope_ids의 구문과 사용법은 &lt;a href=&quot;inet6address#scoped&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="449145cc99d61f1de8faac0f36747e42eeda60f0" translate="yes" xml:space="preserve">
          <source>The syntax of a JAR URL is:</source>
          <target state="translated">JAR URL의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08fb1f0d6774918d6dc928c999a8c810bc3e1cf4" translate="yes" xml:space="preserve">
          <source>The syntax of a compound name is specified using a set of properties:</source>
          <target state="translated">복합 이름의 구문은 일련의 속성을 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb2ecb6c058b701542fac5ca88a96aa5fb606b8" translate="yes" xml:space="preserve">
          <source>The system &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">시스템 &lt;code&gt;ClassLoader&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74f5647e4732b56055ffb73b5ef679c9f6b0e018" translate="yes" xml:space="preserve">
          <source>The system &lt;code&gt;ClassLoader&lt;/code&gt; for delegation, or &lt;code&gt;null&lt;/code&gt; if none</source>
          <target state="translated">위 임용 시스템 &lt;code&gt;ClassLoader&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; 경우는 null</target>
        </trans-unit>
        <trans-unit id="09bd470fb008a04d052a9d37972d68c9fb1da6a5" translate="yes" xml:space="preserve">
          <source>The system can interpolate the provided value.</source>
          <target state="translated">시스템은 제공된 값을 보간 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53b892170425a40e4822de5a8c352ee0cdcdd75" translate="yes" xml:space="preserve">
          <source>The system class loader supports adding a JAR file to be searched if it implements a method named &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; which takes a single parameter of type &lt;code&gt;java.lang.String&lt;/code&gt;. The method is not required to have &lt;code&gt;public&lt;/code&gt; access. The name of the JAR file is obtained by invoking the &lt;a href=&quot;../../../../java.base/java/util/zip/zipfile#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;jarfile&lt;/code&gt; and this is provided as the parameter to the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method.</source>
          <target state="translated">시스템 클래스 로더는 &lt;code&gt;java.lang.String&lt;/code&gt; 유형의 단일 매개 변수를 취하는 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드를 구현하는 경우 검색 할 JAR 파일 추가를 지원합니다 . 이 메서드는 &lt;code&gt;public&lt;/code&gt; 액세스 권한 이 필요하지 않습니다 . JAR 파일의 이름은 호출함으로써 얻어지는 &lt;a href=&quot;../../../../java.base/java/util/zip/zipfile#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 상의 메소드 &lt;code&gt;jarfile&lt;/code&gt; 가를 이는 본의 파라미터로서 제공된다 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="74a5a2feb3472fb9649c9e133c6a12917cacd2aa" translate="yes" xml:space="preserve">
          <source>The system class loader supports adding a JAR file to be searched if it implements a method named &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; which takes a single parameter of type &lt;code&gt;java.lang.String&lt;/code&gt;. The method is not required to have &lt;code&gt;public&lt;/code&gt; access. The name of the JAR file is obtained by invoking the &lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;jarfile&lt;/code&gt; and this is provided as the parameter to the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method.</source>
          <target state="translated">시스템 클래스 로더는 &lt;code&gt;java.lang.String&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드를 구현하는 경우 검색 할 JAR 파일 추가를 지원합니다 . 이 방법은 &lt;code&gt;public&lt;/code&gt; 액세스 권한 이 필요하지 않습니다 . JAR 파일의 이름은 &lt;code&gt;jarfile&lt;/code&gt; 에서 &lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 얻을 수 있으며 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드에 매개 변수로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7007628b7373da2f3acc46dea4b6fc181e177f3" translate="yes" xml:space="preserve">
          <source>The system console, if any, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 시스템 콘솔, 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990083cbffe223d7dee670ed0f3eec843ed8520d" translate="yes" xml:space="preserve">
          <source>The system default &lt;code&gt;LoggerFinder&lt;/code&gt; implementation uses &lt;code&gt;java.util.logging&lt;/code&gt; as the backend framework when the &lt;code&gt;java.logging&lt;/code&gt; module is present. It returns a &lt;a href=&quot;system.logger&quot;&gt;logger&lt;/a&gt; instance that will route log messages to a &lt;a href=&quot;../../../java.logging/java/util/logging/logger&quot;&gt;&lt;code&gt;java.util.logging.Logger&lt;/code&gt;&lt;/a&gt;. Otherwise, if &lt;code&gt;java.logging&lt;/code&gt; is not present, the default implementation will return a simple logger instance that will route log messages of &lt;code&gt;INFO&lt;/code&gt; level and above to the console (&lt;code&gt;System.err&lt;/code&gt;).</source>
          <target state="translated">시스템 기본 &lt;code&gt;LoggerFinder&lt;/code&gt; 구현은 &lt;code&gt;java.logging&lt;/code&gt; 모듈이 있을 때 &lt;code&gt;java.util.logging&lt;/code&gt; 을 백엔드 프레임 워크로 사용합니다 . 로그 메시지를 &lt;a href=&quot;../../../java.logging/java/util/logging/logger&quot;&gt; &lt;code&gt;java.util.logging.Logger&lt;/code&gt; 로&lt;/a&gt; 라우팅 하는 &lt;a href=&quot;system.logger&quot;&gt;로거&lt;/a&gt; 인스턴스를 반환 합니다 . 그렇지 않으면 &lt;code&gt;java.logging&lt;/code&gt; 이없는 경우 기본 구현은 &lt;code&gt;INFO&lt;/code&gt; 수준 이상의 로그 메시지를 콘솔 ( &lt;code&gt;System.err&lt;/code&gt; )로 라우팅하는 간단한 로거 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3cf101b78cd06413158b1ec4f8db88795dfdf0e0" translate="yes" xml:space="preserve">
          <source>The system does not provide a reason for a session change.</source>
          <target state="translated">시스템은 세션 변경 이유를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d37ff3b03f83b416aeccd9836d23dd0072998488" translate="yes" xml:space="preserve">
          <source>The system identifier as a string, or null if none is available.</source>
          <target state="translated">시스템 식별자 (문자열) 또는 사용할 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="c9d316b1fe86ec8261312bc65a64ba6fd6ecd9f6" translate="yes" xml:space="preserve">
          <source>The system identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">엔티티와 연관된 시스템 식별자 (지정된 경우), 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df19c9feca0d6dc04cc43c03e2d1251edf9e4510" translate="yes" xml:space="preserve">
          <source>The system identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise. This may be an absolute URI or not.</source>
          <target state="translated">엔티티와 연관된 시스템 식별자 (지정된 경우), 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 입니다. 절대 URI 일 수도 있고 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32fa52354502a426e561283736887788b3252db" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if the source does not get its data from a URL, but it may still be useful to provide one. The application can use a system identifier, for example, to resolve relative URIs and to include in error messages and warnings.</source>
          <target state="translated">소스가 URL에서 데이터를 가져 오지 않는 경우 시스템 식별자는 선택 사항이지만 여전히 제공하는 것이 유용 할 수 있습니다. 예를 들어 응용 프로그램은 시스템 식별자를 사용하여 상대 URI를 확인하고 오류 메시지 및 경고에 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2364c05ce4f7479bebd35fee2edf0a7d214455de" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if there is a byte stream or a character stream, but it is still useful to provide one, since the application can use it to resolve relative URIs and can include it in error messages and warnings (the parser will attempt to open a connection to the URI only if no byte stream or character stream is specified).</source>
          <target state="translated">시스템 식별자는 바이트 스트림이나 문자 스트림이있는 경우 선택 사항이지만 응용 프로그램에서이를 사용하여 상대 URI를 확인하고 오류 메시지 및 경고에 포함 할 수 있기 때문에 (파서가 바이트 스트림이나 문자 스트림이 지정되지 않은 경우에만 URI에 대한 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="c83b9a58a230a52e3ca07250c92629dfdd6df1bf" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if there is a byte stream or a character stream, but it is still useful to provide one, since the application can use it to resolve relative URIs and can include it in error messages and warnings (the parser will attempt to open a connection to the URI only if there is no byte stream or character stream specified).</source>
          <target state="translated">시스템 식별자는 바이트 스트림이나 문자 스트림이있는 경우 선택 사항이지만 응용 프로그램에서이를 사용하여 상대 URI를 확인하고 오류 메시지 및 경고에 포함 할 수 있기 때문에 (파서가 지정된 바이트 스트림 또는 문자 스트림이없는 경우에만 URI에 대한 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="3cef073d95130421d24f48582c3ee6a831095599" translate="yes" xml:space="preserve">
          <source>The system identifier may be &lt;code&gt;null&lt;/code&gt; or an empty &lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">시스템 식별자는 &lt;code&gt;null&lt;/code&gt; 이거나 빈 &lt;code&gt;&quot;&quot;&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff7e558528664a0592a67c50fde5c5a005f60b33" translate="yes" xml:space="preserve">
          <source>The system identifier of the external subset.</source>
          <target state="translated">외부 하위 집합의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="5b27a3eb89c729d7e642ff92ff95e3dac820f59c" translate="yes" xml:space="preserve">
          <source>The system identifier of the external subset. This may be an absolute URI or not.</source>
          <target state="translated">외부 서브 세트의 시스템 식별자. 절대 URI 일 수도 있고 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff0c997f101dd04693253ebc52fe8874df3b5062" translate="yes" xml:space="preserve">
          <source>The system identifier of this notation.</source>
          <target state="translated">이 표기법의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="54b96c3bc9ebc5adfe89119951cb415cb6d98e20" translate="yes" xml:space="preserve">
          <source>The system identifier of this notation. If the system identifier was not specified, this is &lt;code&gt;null&lt;/code&gt;. This may be an absolute URI or not.</source>
          <target state="translated">이 표기법의 시스템 식별자입니다. 시스템 식별자가 지정되지 않은 경우 이것은 &lt;code&gt;null&lt;/code&gt; 입니다. 절대 URI 일 수도 있고 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0dc421d48b89f1f1bd983b514fa401be307f95f" translate="yes" xml:space="preserve">
          <source>The system identifier that was set with setSystemId, or null if setSystemId was not called.</source>
          <target state="translated">setSystemId로 설정된 시스템 식별자 또는 setSystemId가 호출되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="a1ce02ce7ff2b78b9dae3fc1cf570c0f7333877f" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source.</source>
          <target state="translated">이 입력 소스에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="257e29fd1c5d73c7e7ae227aff860a12a6b60071" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source. The system identifier is optional if there is a byte stream, a character stream, or string data. It is still useful to provide one, since the application will use it to resolve any relative URIs and can include it in error messages and warnings. (The LSParser will only attempt to fetch the resource identified by the URI reference if there is no other input available in the input source.)</source>
          <target state="translated">이 입력 소스에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]. 바이트 스트림, 문자 스트림 또는 문자열 데이터가있는 경우 시스템 식별자는 선택 사항입니다. 응용 프로그램에서 상대 URI를 확인하는 데 사용하고 오류 메시지 및 경고에 포함 할 수 있으므로이를 제공하는 것이 여전히 유용합니다. (LSParser는 입력 소스에 사용할 수있는 다른 입력이없는 경우에만 URI 참조로 식별되는 리소스를 가져 오려고 시도합니다.)</target>
        </trans-unit>
        <trans-unit id="9aecaed599272a3cd0476ff61a2a3b31138ead77" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this output destination.</source>
          <target state="translated">이 출력 대상에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="9ac19f96242350b7673acfdd7d4b02b017a83550" translate="yes" xml:space="preserve">
          <source>The system identifier, or null if none was supplied.</source>
          <target state="translated">시스템 식별자 또는 제공되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="9432be2aa85292b809c263d55400ca2c13bb187f" translate="yes" xml:space="preserve">
          <source>The system identifier.</source>
          <target state="translated">시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="33154309f44b1f3e4b9b63aa2db5ffb66d8d5f1d" translate="yes" xml:space="preserve">
          <source>The system modules, which are the compiled definitions built in to the environment.</source>
          <target state="translated">환경에 내장 된 컴파일 된 정의 인 시스템 모듈.</target>
        </trans-unit>
        <trans-unit id="84fb25c617804e775187a1ef35381adde7a462d2" translate="yes" xml:space="preserve">
          <source>The system property that controls which Factory implementation to create is named &lt;code&gt;&quot;javax.xml.parsers.SAXParserFactory&quot;&lt;/code&gt;. This property names a class that is a concrete subclass of this abstract class. If no property is defined, a platform default will be used.</source>
          <target state="translated">생성 할 Factory 구현을 제어하는 ​​시스템 속성의 이름은 &lt;code&gt;&quot;javax.xml.parsers.SAXParserFactory&quot;&lt;/code&gt; 입니다. 이 속성은이 추상 클래스의 구체적인 하위 클래스 인 클래스의 이름을 지정합니다. 속성이 정의되지 않은 경우 플랫폼 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d513879bd2964703d8728b1b4c20e907f2382f9" translate="yes" xml:space="preserve">
          <source>The system property that determines which Factory implementation to create is named &lt;code&gt;&quot;javax.xml.transform.TransformerFactory&quot;&lt;/code&gt;. This property names a concrete subclass of the &lt;code&gt;TransformerFactory&lt;/code&gt; abstract class. If the property is not defined, a platform default is be used.</source>
          <target state="translated">작성할 팩토리 구현을 판별하는 시스템 특성은 &lt;code&gt;&quot;javax.xml.transform.TransformerFactory&quot;&lt;/code&gt; 로 명명 됩니다. 이 속성은 &lt;code&gt;TransformerFactory&lt;/code&gt; 추상 클래스 의 구체적인 하위 클래스 이름을 지정합니다 . 속성이 정의되지 않은 경우 플랫폼 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="305047c960aad4ed37ebc14427e984473ca4e5f9" translate="yes" xml:space="preserve">
          <source>The system property to override the system class loader is not examined until the VM is almost fully initialized. Code that executes this method during startup should take care not to cache the return value until the system is fully initialized.</source>
          <target state="translated">시스템 클래스 로더를 재정의하는 시스템 속성은 VM이 거의 완전히 초기화 될 때까지 검사되지 않습니다. 시작 중에이 메서드를 실행하는 코드는 시스템이 완전히 초기화 될 때까지 반환 값을 캐시하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f722c038ba46377c26c7b3d111ee938421ee539" translate="yes" xml:space="preserve">
          <source>The system property to specify the DOMImplementationSource class names.</source>
          <target state="translated">DOMImplementationSource 클래스 이름을 지정하는 시스템 속성입니다.</target>
        </trans-unit>
        <trans-unit id="78a2fb8c1adaa830a99ae7c2ad610a98649d150e" translate="yes" xml:space="preserve">
          <source>The system will probe the specified file to determine its keystore type and return a keystore implementation with its entries already loaded. When this approach is used there is no need to call the keystore's &lt;a href=&quot;#load(java.io.InputStream,char%5B%5D)&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">시스템은 지정된 파일을 조사하여 해당 키 저장소 유형을 결정하고 항목이 이미로드 된 키 저장소 구현을 반환합니다. 이 접근 방식을 사용하면 키 저장소의 &lt;a href=&quot;#load(java.io.InputStream,char%5B%5D)&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 메서드 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7923449f8c0c0791eb5aa081bc5a65fcb2555819" translate="yes" xml:space="preserve">
          <source>The system will return a keystore implementation for the default type.</source>
          <target state="translated">시스템은 기본 유형에 대한 키 저장소 구현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="00bc1824cf3bd5ca4947f7d237f20eddafbb842c" translate="yes" xml:space="preserve">
          <source>The system will return the most preferred implementation of the specified keystore type available in the environment.</source>
          <target state="translated">시스템은 환경에서 사용 가능한 지정된 키 저장소 유형의 가장 선호되는 구현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bf575b9617841369bd0654ef25dcbd4387d7d8b2" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 기본 이름 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="a94fecc52deafc39728c10e86b4031f2cc84b1c9" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience. This string contains a single character, namely &lt;a href=&quot;#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 기본 이름 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;a href=&quot;#separatorChar&quot;&gt; &lt;code&gt;separatorChar&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="db9af4ad444ca84eeeac9fb19764f73c768a1db0" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 기본 이름 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="23edeff72c72b6eac94037a43840bbb8e7b551b6" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character.</source>
          <target state="translated">시스템 종속 기본 이름 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="06c823441fa92d743c30c7c0a19a1d4b758a3865" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;file.separator&lt;/code&gt;. On UNIX systems the value of this field is &lt;code&gt;'/'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;'\\'&lt;/code&gt;.</source>
          <target state="translated">시스템에 따른 기본 이름 구분 문자입니다. 이 필드는 시스템 특성 &lt;code&gt;file.separator&lt;/code&gt; 값의 첫 문자를 포함하도록 초기화됩니다 . UNIX 시스템에서이 필드의 값은 &lt;code&gt;'/'&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 &lt;code&gt;'\\'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8793c76c9da5710b62dc7c9e42c8f2cdc86a36b3" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 경로 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="1f14bf8cb7ba1cb6fe8976b4d14659286d00de2c" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience. This string contains a single character, namely &lt;a href=&quot;#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 경로 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;a href=&quot;#pathSeparatorChar&quot;&gt; &lt;code&gt;pathSeparatorChar&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a67c3801f69a10a5f6ee1400db51f1a4d991731c" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 경로 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="56704d0b0a7bdab899863fa1d0c2f23658372f6a" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character.</source>
          <target state="translated">시스템 종속 경로 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="79dc28fe296e6f9a3e10386e77dffcce367aaf90" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;path.separator&lt;/code&gt;. This character is used to separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;. On UNIX systems, this character is &lt;code&gt;':'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;';'&lt;/code&gt;.</source>
          <target state="translated">시스템 종속 경로 구분 문자 이 필드는 시스템 특성 &lt;code&gt;path.separator&lt;/code&gt; 값의 첫 문자를 포함하도록 초기화됩니다 . 이 문자는 &lt;em&gt;경로 목록으로&lt;/em&gt; 지정된 파일 시퀀스에서 파일 이름을 구분하는 데 사용됩니다 . UNIX 시스템에서이 문자는 &lt;code&gt;':'&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 &lt;code&gt;';'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="518a2fc9a68e3f3d5382e5d1a00ce498fcc2e594" translate="yes" xml:space="preserve">
          <source>The system-wide default AsynchronousChannel provider</source>
          <target state="translated">시스템 전체의 기본 AsynchronousChannel 제공자</target>
        </trans-unit>
        <trans-unit id="0f461893764b32c9834282b1f614f9186ccf0cf0" translate="yes" xml:space="preserve">
          <source>The system-wide default provider is used by the static &lt;code&gt;open&lt;/code&gt; methods of the &lt;a href=&quot;../datagramchannel#open()&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../pipe#open()&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../selector#open()&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../serversocketchannel#open()&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../socketchannel#open()&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; classes. It is also used by the &lt;a href=&quot;../../../lang/system#inheritedChannel()&quot;&gt;&lt;code&gt;System.inheritedChannel()&lt;/code&gt;&lt;/a&gt; method. A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the &lt;code&gt;open&lt;/code&gt; methods defined in this class.</source>
          <target state="translated">시스템 전체의 기본 공급자는 &lt;a href=&quot;../datagramchannel#open()&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../pipe#open()&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../selector#open()&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../serversocketchannel#open()&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../socketchannel#open()&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 클래스 의 정적 &lt;code&gt;open&lt;/code&gt; 메서드에서 사용됩니다 . &lt;a href=&quot;../../../lang/system#inheritedChannel()&quot;&gt; &lt;code&gt;System.inheritedChannel()&lt;/code&gt; &lt;/a&gt; 메서드 에서도 사용됩니다 . 프로그램은 해당 공급자를 인스턴스화 한 다음 이 클래스에 정의 된 &lt;code&gt;open&lt;/code&gt; 메서드 를 직접 호출하여 기본 공급자가 아닌 다른 공급자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e7874d4b84773bdddf3caf1a22fc6b1ddcdb68c" translate="yes" xml:space="preserve">
          <source>The system-wide default provider is used by the static &lt;code&gt;open&lt;/code&gt; methods of the &lt;a href=&quot;../datagramchannel#open--&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../pipe#open--&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../selector#open--&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../serversocketchannel#open--&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../socketchannel#open--&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; classes. It is also used by the &lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt;&lt;code&gt;System.inheritedChannel()&lt;/code&gt;&lt;/a&gt; method. A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the &lt;code&gt;open&lt;/code&gt; methods defined in this class.</source>
          <target state="translated">시스템 전체의 기본 제공자는 &lt;a href=&quot;../datagramchannel#open--&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../pipe#open--&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../selector#open--&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../serversocketchannel#open--&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../socketchannel#open--&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 클래스 의 정적 &lt;code&gt;open&lt;/code&gt; 메소드에서 사용됩니다 . &lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt; &lt;code&gt;System.inheritedChannel()&lt;/code&gt; &lt;/a&gt; 메서드 에서도 사용됩니다 . 프로그램은 해당 제공자를 인스턴스화 한 다음 이 클래스에 정의 된 &lt;code&gt;open&lt;/code&gt; 메소드 를 직접 호출하여 기본 제공자 이외의 제공자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1854b090241392edcc60935113761df6965da7c2" translate="yes" xml:space="preserve">
          <source>The system-wide default selector provider</source>
          <target state="translated">시스템 전체 기본 선택기 공급자</target>
        </trans-unit>
        <trans-unit id="95bf3ad30c8dc77c99ea4e641b49758e0b289c1f" translate="yes" xml:space="preserve">
          <source>The system-wide default values are retrieved at the time the &lt;code&gt;HttpClient&lt;/code&gt; instance is constructed. Changing the system-wide values after an &lt;code&gt;HttpClient&lt;/code&gt; instance has been built, for instance, by calling &lt;a href=&quot;../../../../java.base/java/net/proxyselector#setDefault(java.net.ProxySelector)&quot;&gt;&lt;code&gt;ProxySelector.setDefault(ProxySelector)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#setDefault(javax.net.ssl.SSLContext)&quot;&gt;&lt;code&gt;SSLContext.setDefault(SSLContext)&lt;/code&gt;&lt;/a&gt;, has no effect on already built instances.</source>
          <target state="translated">시스템 전체 기본값은 &lt;code&gt;HttpClient&lt;/code&gt; 인스턴스가 생성 될 때 검색됩니다 . 예를 들어 &lt;a href=&quot;../../../../java.base/java/net/proxyselector#setDefault(java.net.ProxySelector)&quot;&gt; &lt;code&gt;ProxySelector.setDefault(ProxySelector)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#setDefault(javax.net.ssl.SSLContext)&quot;&gt; &lt;code&gt;SSLContext.setDefault(SSLContext)&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;code&gt;HttpClient&lt;/code&gt; 인스턴스가 빌드 된 후 시스템 전체 값을 변경하는 것은 이미 빌드 된 인스턴스에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b245a40ab8beba1018593de4068b70324a8a9b7f" translate="yes" xml:space="preserve">
          <source>The systemID of the Result is implementation dependent.</source>
          <target state="translated">결과의 systemID는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="03cfd5043423fd52868491470982807b0134453d" translate="yes" xml:space="preserve">
          <source>The systemID that was set with &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt;&lt;code&gt;setSystemId(java.lang.String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt; &lt;code&gt;setSystemId(java.lang.String)&lt;/code&gt; &lt;/a&gt; 로 설정된 시스템 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="a1045e7af40ef3b112d277437311ac29c399a948" translate="yes" xml:space="preserve">
          <source>The tab character (&lt;code&gt;'\u0009'&lt;/code&gt;)</source>
          <target state="translated">탭 문자 ( &lt;code&gt;'\u0009'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="724f41c531f5aa59b222eabf7abf5a6c43d9e2c4" translate="yes" xml:space="preserve">
          <source>The tab layout policy for wrapping tabs in multiple runs when all tabs will not fit within a single run.</source>
          <target state="translated">모든 탭이 단일 실행에 맞지 않을 때 여러 실행에서 탭을 래핑하는 탭 레이아웃 정책입니다.</target>
        </trans-unit>
        <trans-unit id="199233d8422b6532357239677c0d77118df3b357" translate="yes" xml:space="preserve">
          <source>The tab pane</source>
          <target state="translated">탭 창</target>
        </trans-unit>
        <trans-unit id="50f511f50ec79dac8854d97e6e1fc6b46ec9821b" translate="yes" xml:space="preserve">
          <source>The tab title can be rendered by a &lt;code&gt;Component&lt;/code&gt;. For example, the following produce similar results:</source>
          <target state="translated">탭 제목은 &lt;code&gt;Component&lt;/code&gt; 에서 렌더링 할 수 있습니다 . 예를 들어 다음은 유사한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="70b6d74a75747576812470d4e1829a1958e25ff9" translate="yes" xml:space="preserve">
          <source>The table below defines the mapping between XML Schema 1.0 date/time datatype fields and this class' fields. It also summarizes the value constraints for the date and time fields defined in &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">아래 표는 XML Schema 1.0 날짜 / 시간 데이터 유형 필드와이 클래스의 필드 간의 매핑을 정의합니다. 또한 &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats에&lt;/i&gt;&lt;/a&gt; 정의 된 날짜 및 시간 필드에 대한 값 제약 조건을 요약합니다 .</target>
        </trans-unit>
        <trans-unit id="956c09a6d0ea87af6414b81e63f37ed614bbe89f" translate="yes" xml:space="preserve">
          <source>The table below lists all the printing attributes. The table shows the tagging interfaces each attribute class implements in addition to interface &lt;a href=&quot;../attribute&quot;&gt; Attribute&lt;/a&gt;, thus indicating how each attribute is used in the API. For each doc attribute and print request attribute, the column marked &quot;SupportedValuesAttribute&quot; lists the supported-values attribute class, if any, with which a print service indicates the supported values for that attribute category.</source>
          <target state="translated">아래 표에는 모든 인쇄 속성이 나열되어 있습니다. 이 테이블은 &lt;a href=&quot;../attribute&quot;&gt;Attribute 속성&lt;/a&gt; 외에도 각 속성 클래스가 구현하는 태깅 인터페이스를 보여줍니다. 따라서 각 속성이 API에서 사용되는 방식을 나타냅니다. 각 doc 속성 및 인쇄 요청 속성에 대해 &quot;SupportedValuesAttribute&quot;로 표시된 열은 지원되는 값 속성 클래스를 나열합니다 (있는 경우). 인쇄 서비스가 해당 속성 범주에 대해 지원되는 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="287f71a5c4a7b8e7e0742c0ff2ef999a33855d9e" translate="yes" xml:space="preserve">
          <source>The table below lists possible effective values if a certain capability is requested, i.e.</source>
          <target state="translated">아래 표에는 특정 기능이 요청 된 경우 가능한 유효 값이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf06ceead298594cb308f75d4760c64b1d7032fe" translate="yes" xml:space="preserve">
          <source>The table below shows the effects of specifying a Chromaticity attribute of &lt;a href=&quot;#MONOCHROME&quot;&gt;&lt;code&gt;MONOCHROME&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#COLOR&quot;&gt;&lt;code&gt;COLOR&lt;/code&gt;&lt;/a&gt; for a monochrome or color document.</source>
          <target state="translated">아래 표 는 단색 또는 컬러 문서에 대해 &lt;a href=&quot;#MONOCHROME&quot;&gt; &lt;code&gt;MONOCHROME&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#COLOR&quot;&gt; &lt;code&gt;COLOR&lt;/code&gt; &lt;/a&gt; 의 색도 속성을 지정했을 때의 효과를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="93b17809af88bed6b165bc41c7cce6b651c3dd33" translate="yes" xml:space="preserve">
          <source>The table below shows the effects of specifying a Chromaticity attribute of &lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt;&lt;code&gt;MONOCHROME&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;chromaticity#COLOR&quot;&gt;&lt;code&gt;COLOR&lt;/code&gt;&lt;/a&gt; for a monochrome or color document.</source>
          <target state="translated">아래 표 는 단색 또는 컬러 문서에 대해 &lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt; &lt;code&gt;MONOCHROME&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;chromaticity#COLOR&quot;&gt; &lt;code&gt;COLOR&lt;/code&gt; &lt;/a&gt; 의 색도 속성을 지정하는 효과를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6550573ca0506c03709606c1bdd17da7666522cf" translate="yes" xml:space="preserve">
          <source>The table below summarizes which kind of annotation presence different methods in this interface examine.</source>
          <target state="translated">아래 표는이 인터페이스에서 어떤 종류의 주석이 다른 방법으로 검사되는지 요약합니다.</target>
        </trans-unit>
        <trans-unit id="0785827f1aca709e13a4cfacab1b11dec6fe1d51" translate="yes" xml:space="preserve">
          <source>The table draws horizontal lines between cells if &lt;code&gt;showHorizontalLines&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;showHorizontalLines&lt;/code&gt; 가 true 인 경우 테이블 은 셀 사이에 수평선을 그립니다 .</target>
        </trans-unit>
        <trans-unit id="cc764edbccef2f5a651977b7ffdec182e128fba7" translate="yes" xml:space="preserve">
          <source>The table draws vertical lines between cells if &lt;code&gt;showVerticalLines&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;showVerticalLines&lt;/code&gt; 가 true 인 경우 테이블은 셀 사이에 수직선을 그립니다 .</target>
        </trans-unit>
        <trans-unit id="d46376b57361e34cc862402a3ff75bfa5957b99c" translate="yes" xml:space="preserve">
          <source>The table for which this object is the header; the default is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 개체가 헤더 인 테이블입니다. 기본값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="affe517f34332866171ca57d9e9e5b23870e7f83" translate="yes" xml:space="preserve">
          <source>The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional &lt;code&gt;
 initialCapacity&lt;/code&gt; constructor argument. An additional optional &lt;code&gt;loadFactor&lt;/code&gt; constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected &lt;code&gt;concurrencyLevel&lt;/code&gt; as an additional hint for internal sizing. Note that using many keys with exactly the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">충돌이 너무 많으면 (즉, 고유 한 해시 코드가 있지만 테이블 크기의 모듈로 동일한 슬롯에 속하는 키) 테이블은 동적으로 확장되며 매핑 당 대략 2 개의 빈을 유지하는 예상 평균 효과 (0.75로드에 해당) 크기 조정을위한 요소 임계 값). 매핑이 추가 및 제거됨에 따라이 평균 주변에 많은 차이가있을 수 있지만 전반적으로 해시 테이블에 대해 일반적으로 허용되는 시간 / 공간 균형을 유지합니다. 그러나이 테이블이나 다른 종류의 해시 테이블 크기를 조정하는 작업은 비교적 느릴 수 있습니다. 가능하면 선택적인 &lt;code&gt; initialCapacity&lt;/code&gt; 생성자 인수 로 크기 추정치를 제공하는 것이 좋습니다 . 추가 옵션 인 &lt;code&gt;loadFactor&lt;/code&gt; constructor 인수는 주어진 요소 수에 할당 할 공간의 양을 계산하는 데 사용할 테이블 밀도를 지정하여 초기 테이블 용량을 사용자 정의하는 추가 수단을 제공합니다. 또한이 클래스의 이전 버전과의 호환성을 위해 생성자는 내부 크기 조정을위한 추가 힌트로 예상되는 &lt;code&gt;concurrencyLevel&lt;/code&gt; 을 선택적으로 지정할 수 있습니다 . 정확히 동일한 &lt;code&gt;hashCode()&lt;/code&gt; 가진 많은 키를 사용 하는 것은 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 영향을 개선하기 위해 키가 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때이 클래스는 키 간의 비교 순서를 사용하여 관계를 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abdfbcd8569ed822dbb9b0566e80bdcdfb0ce663" translate="yes" xml:space="preserve">
          <source>The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional &lt;code&gt;initialCapacity&lt;/code&gt; constructor argument. An additional optional &lt;code&gt;loadFactor&lt;/code&gt; constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected &lt;code&gt;concurrencyLevel&lt;/code&gt; as an additional hint for internal sizing. Note that using many keys with exactly the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">충돌이 너무 많으면 (예 : 별개의 해시 코드가 있지만 테이블 크기가 같은 슬롯에 해당하는 키) 테이블이 동적으로 확장됩니다 (매핑 당 약 2 개의 빈을 유지하는 예상 평균 효과 (0.75로드에 해당) 크기 조정을위한 요인 임계 값). 매핑이 추가 및 제거 될 때이 평균 주위에 많은 차이가있을 수 있지만 전반적으로 해시 테이블에 대해 일반적으로 허용되는 시간 / 공간 균형을 유지합니다. 그러나이 또는 다른 종류의 해시 테이블 크기를 조정하면 작업 속도가 느려질 수 있습니다. 가능한 경우 크기 추정값을 선택적 &lt;code&gt;initialCapacity&lt;/code&gt; 생성자 인수 로 제공하는 것이 좋습니다 . 추가 옵션 인 &lt;code&gt;loadFactor&lt;/code&gt; 생성자 인수는 주어진 요소 수에 할당 할 공간의 양을 계산하는 데 사용할 테이블 밀도를 지정하여 초기 테이블 용량을 사용자 정의하는 추가 수단을 제공합니다. 또한이 클래스의 이전 버전과의 호환성을 위해 생성자는 내부 크기 조정에 대한 추가 힌트로 예상되는 &lt;code&gt;concurrencyLevel&lt;/code&gt; 수준을 선택적으로 지정할 수 있습니다 . 정확히 같은 &lt;code&gt;hashCode()&lt;/code&gt; 가진 많은 키를 사용 하는 것은 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 키가 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때 영향을 개선하기 위해이 클래스는 키 간 비교 순서를 사용하여 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="807c7f2278f08fd9a560612599a053ac4a77aa0b" translate="yes" xml:space="preserve">
          <source>The table of key properties.</source>
          <target state="translated">주요 속성 테이블.</target>
        </trans-unit>
        <trans-unit id="29c2e665a3b18a1ce29ba700eb12bfe8ef2d57b7" translate="yes" xml:space="preserve">
          <source>The table type is:</source>
          <target state="translated">테이블 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e72d6ec95379480e6ddcff8a30f3ae018d25f5a5" translate="yes" xml:space="preserve">
          <source>The table will query the &lt;code&gt;TableModel&lt;/code&gt; to build the default set of columns if this is true.</source>
          <target state="translated">이것이 참인 경우 테이블은 &lt;code&gt;TableModel&lt;/code&gt; 을 쿼리하여 기본 열 집합을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="4b683043db5214bb3bb29c225b881df7d62a7411" translate="yes" xml:space="preserve">
          <source>The tag number.</source>
          <target state="translated">태그 번호.</target>
        </trans-unit>
        <trans-unit id="e3034177648d7a592ed4b995252076ff2a379e97" translate="yes" xml:space="preserve">
          <source>The tag values for this property. May be null if this property cannot be represented as a tagged value.</source>
          <target state="translated">이 프로퍼티의 태그 치입니다. 이 속성을 태그 값으로 나타낼 수없는 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b446899d309ae9229be1541a42b9d0cf00a0ac6b" translate="yes" xml:space="preserve">
          <source>The target and cleanup must return the same type, even if the cleanup always throws. To create such a throwing cleanup, compose the cleanup logic with &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">대상 및 정리는 정리가 항상 발생하더라도 동일한 유형을 반환해야합니다. 이러한 던지는 정리 를 생성하려면 올바른 반환 유형의 메서드 핸들을 생성하기 위해 &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; 으로&lt;/a&gt; 정리 논리를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="02cefdef6f6fd1cf2781c5dd156f06c3b67ffe8b" translate="yes" xml:space="preserve">
          <source>The target and fallback must be of exactly the same method type, and the resulting combined method handle will also be of this type.</source>
          <target state="translated">대상과 폴백은 정확히 동일한 메소드 유형이어야하며 결과 결합 된 메소드 핸들도이 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="f42cc55413084526e1a3b93e74bf70c3317cb6fa" translate="yes" xml:space="preserve">
          <source>The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in &lt;a href=&quot;#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)&quot;&gt;&lt;code&gt;guardWithTest&lt;/code&gt;&lt;/a&gt;). Also, the handler must have an extra leading parameter of &lt;code&gt;exType&lt;/code&gt; or a supertype.</source>
          <target state="translated">대상 및 핸들러는 핸들러가 후행 인수를 생략 할 수 있다는 점을 제외하고 동일한 대응 인수 및 리턴 유형을 &lt;a href=&quot;#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)&quot;&gt; &lt;code&gt;guardWithTest&lt;/code&gt; &lt;/a&gt; 의 술어와 유사 함 ). 또한 핸들러에는 &lt;code&gt;exType&lt;/code&gt; 또는 상위 유형 의 추가 선행 매개 변수가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cfe18dce3e23910cc798ebbf8a13a2dd958ea48f" translate="yes" xml:space="preserve">
          <source>The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in &lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt;&lt;code&gt;guardWithTest&lt;/code&gt;&lt;/a&gt;). Also, the handler must have an extra leading parameter of &lt;code&gt;exType&lt;/code&gt; or a supertype.</source>
          <target state="translated">핸들러가 후행 인수를 생략 할 수 있다는 점을 제외하고 대상 및 핸들러는 동일한 해당 인수 및 리턴 유형을 &lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt; &lt;code&gt;guardWithTest&lt;/code&gt; &lt;/a&gt; 의 술어와 유사 ). 또한 핸들러에는 &lt;code&gt;exType&lt;/code&gt; 또는 supertype 의 추가 선행 매개 변수가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e01418ac4cb37a5ae8fb9a819eaaca5266eb99c3" translate="yes" xml:space="preserve">
          <source>The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a &lt;code&gt;finally&lt;/code&gt; clause). To create such a throwing handler, compose the handler creation logic with &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">대상과 핸들러는 핸들러가 항상 throw하더라도 동일한 유형을 반환해야합니다. (예를 들어 핸들러가 &lt;code&gt;finally&lt;/code&gt; 절을 시뮬레이션하고 있기 때문에 이런 일이 발생할 수 있습니다 .) 이러한 throwing 핸들러 를 생성하려면 올바른 반환 유형의 메서드 핸들을 생성하기 위해 &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; 으로&lt;/a&gt; 핸들러 생성 로직을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="44e11701adb06063c652521aa85aae71912799bf" translate="yes" xml:space="preserve">
          <source>The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a &lt;code&gt;finally&lt;/code&gt; clause). To create such a throwing handler, compose the handler creation logic with &lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">핸들러가 항상 발생하더라도 대상과 핸들러는 동일한 유형을 리턴해야합니다. (예를 들어, 핸들러가 &lt;code&gt;finally&lt;/code&gt; 절을 시뮬레이션하기 때문에 이런 일이 발생할 수 있습니다 ). 이러한 처리 핸들러를 작성 하려면 올바른 리턴 유형의 메소드 핸들을 작성하기 위해 처리기 작성 로직을 &lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; &lt;/a&gt; 으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6331eb65cfaeb17d610de47a1492d63404554822" translate="yes" xml:space="preserve">
          <source>The target component.</source>
          <target state="translated">대상 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a48909c6d391288fca7020961e9c52b23bc4c69d" translate="yes" xml:space="preserve">
          <source>The target component. This indicates the component over which the event occurred or with which the event is associated. This object has been replaced by AWTEvent.getSource()</source>
          <target state="translated">대상 구성 요소입니다. 이벤트가 발생한 구성 요소 또는 이벤트와 관련된 구성 요소를 나타냅니다. 이 객체는 AWTEvent.getSource ()로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="41cfd1c3c3da57cda5880021b389e8ff6e52178e" translate="yes" xml:space="preserve">
          <source>The target data line can be obtained from a mixer by invoking the &lt;a href=&quot;mixer#getLine(javax.sound.sampled.Line.Info)&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Mixer&lt;/code&gt; with an appropriate &lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">적절한 &lt;a href=&quot;dataline.info&quot;&gt; &lt;code&gt;DataLine.Info&lt;/code&gt; &lt;/a&gt; 개체를 사용하여 &lt;code&gt;Mixer&lt;/code&gt; 의 &lt;a href=&quot;mixer#getLine(javax.sound.sampled.Line.Info)&quot;&gt; &lt;code&gt;getLine&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 믹서에서 대상 데이터 라인을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="294becfa926713ae4f4611aad1c89088d4f17efe" translate="yes" xml:space="preserve">
          <source>The target data line can be obtained from a mixer by invoking the &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of &lt;code&gt;Mixer&lt;/code&gt; with an appropriate &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">목표 데이터 라인은 호출하여 믹서로부터 얻어 질 수 &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 방법 &lt;code&gt;Mixer&lt;/code&gt; 적절한으로 &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 의 개체.</target>
        </trans-unit>
        <trans-unit id="2e92be738dd320065c504e7c597383304da41f9b" translate="yes" xml:space="preserve">
          <source>The target format represents the format of the processed, converted audio data. This is the format of the data that can be read from the stream returned by one of the &lt;code&gt;getAudioInputStream&lt;/code&gt; methods.</source>
          <target state="translated">대상 형식은 처리 된 변환 된 오디오 데이터의 형식을 나타냅니다. &lt;code&gt;getAudioInputStream&lt;/code&gt; 메소드 중 하나가 리턴 한 스트림에서 읽을 수있는 데이터 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="e7de801befb3afea6c0cedebce5ac02cc3cf8db7" translate="yes" xml:space="preserve">
          <source>The target handle has the parameter type list &lt;code&gt;S..., M...&lt;/code&gt;, with as many types in &lt;code&gt;S&lt;/code&gt; as indicated by &lt;code&gt;skip&lt;/code&gt;. The &lt;code&gt;M&lt;/code&gt; types are those that are supposed to match part of the given type list, &lt;code&gt;newTypes&lt;/code&gt;.</source>
          <target state="translated">대상 핸들에는 매개 변수 유형 목록 &lt;code&gt;S..., M...&lt;/code&gt; 있으며 &lt;code&gt;S&lt;/code&gt; 에는 &lt;code&gt;skip&lt;/code&gt; 으로 표시된 만큼 많은 유형이 있습니다 . &lt;code&gt;M&lt;/code&gt; 의 유형은 주어진 유형 목록의 일부와 일치 해야하는 것들이다 &lt;code&gt;newTypes&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="03b0fb3903bf8315a0952c04b4865416cb3c9b29" translate="yes" xml:space="preserve">
          <source>The target height to scale the image.</source>
          <target state="translated">이미지 크기를 조정할 대상 높이입니다.</target>
        </trans-unit>
        <trans-unit id="61ee1882c6fbd7985ddaac74fcc91b429f418e8c" translate="yes" xml:space="preserve">
          <source>The target name is of the form &quot;&lt;code&gt;className#member[objectName]&lt;/code&gt;&quot; where each part is optional. It must not be empty or null.</source>
          <target state="translated">대상 이름은 &quot; &lt;code&gt;className#member[objectName]&lt;/code&gt; &quot;형식이며 각 부분은 선택 사항입니다. 비어 있거나 null이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="ce62a8e103e81312eae100e20ed400ca3da9c713" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the &lt;code&gt;AuthPermission&lt;/code&gt; object is used to guard access to the &lt;a href=&quot;subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;login/logincontext&quot;&gt;&lt;code&gt;LoginContext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;login/configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 &lt;code&gt;AuthPermission&lt;/code&gt; 객체는 &lt;a href=&quot;subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;login/logincontext&quot;&gt; &lt;code&gt;LoginContext&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;login/configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 객체에 대한 액세스를 보호하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c855fc5f9080ecc03acfbcb7e0983b870dcc2a70" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the &lt;code&gt;SecurityPermission&lt;/code&gt; object is used to guard access to the &lt;a href=&quot;accesscontrolcontext&quot;&gt;&lt;code&gt;AccessControlContext&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;provider&quot;&gt;&lt;code&gt;Provider&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;security&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;signer&quot;&gt;&lt;code&gt;Signer&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;identity&quot;&gt;&lt;code&gt;Identity&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 &lt;code&gt;SecurityPermission&lt;/code&gt; 객체는 &lt;a href=&quot;accesscontrolcontext&quot;&gt; &lt;code&gt;AccessControlContext&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;provider&quot;&gt; &lt;code&gt;Provider&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;security&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;signer&quot;&gt; &lt;code&gt;Signer&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;identity&quot;&gt; &lt;code&gt;Identity&lt;/code&gt; &lt;/a&gt; 객체에 대한 액세스를 보호하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7928d48cbde0bd5806a16e749b843ab056e2bff2" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the AuthPermission object is used to guard access to the Policy, Subject, LoginContext, and Configuration objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 AuthPermission 오브젝트는 Policy, Subject, LoginContext 및 Configuration 오브젝트에 대한 액세스를 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2890f709a91749b2fe10e52fd580bddb149e0444" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the SecurityPermission object is used to guard access to the Policy, Security, Provider, Signer, and Identity objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 SecurityPermission 오브젝트는 Policy, Security, Provider, Signer 및 Identity 오브젝트에 대한 액세스를 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17f38fb0c6986e5e7a83073a2ad1774730542b07" translate="yes" xml:space="preserve">
          <source>The target name is the name of the AWT permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk could be used to represent all AWT permissions.</source>
          <target state="translated">대상 이름은 AWT 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 모든 AWT 권한을 나타내는 데 별표를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e139ec2f3c65e0160a69e0966a9e12f3721fc07" translate="yes" xml:space="preserve">
          <source>The target name is the name of the Serializable permission (see below).</source>
          <target state="translated">대상 이름은 Serializable 권한의 이름입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="1d4510b6174912a740c895643371245def2a4d9e" translate="yes" xml:space="preserve">
          <source>The target name is the name of the audio permission (see the table below). The names follow the hierarchical property-naming convention. Also, an asterisk can be used to represent all the audio permissions.</source>
          <target state="translated">대상 이름은 오디오 권한의 이름입니다 (아래 표 참조). 이름은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표를 사용하여 모든 오디오 권한을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8645249d279e7c3cf29a83a9b3bb1e507d282b4" translate="yes" xml:space="preserve">
          <source>The target name is the name of the authorization principal classname followed by a period and the authorization principal name, that is &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">대상 이름은 권한 부여 주체 클래스 이름의 이름 뒤에 마침표와 권한 부여 주체 이름 ( &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1de21a429ece939c67b7e50829885099ad2d45eb" translate="yes" xml:space="preserve">
          <source>The target name is the name of the network permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;foo.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*foo&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">대상 이름은 네트워크 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어 &quot;foo. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* foo&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35aa664b77bc8ac5af633fd3abfe001e77f837cd" translate="yes" xml:space="preserve">
          <source>The target name is the name of the runtime permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;loadLibrary.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*loadLibrary&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">대상 이름은 런타임 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어 &quot;loadLibrary. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* loadLibrary&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d958abd00740d8b81aa7e7e8a7237d717e401b13" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a Credential class name, and a Set of Principals. The only valid value for this Permission's actions is, &quot;read&quot;. The target name must abide by the following syntax:</source>
          <target state="translated">이 &lt;code&gt;Permission&lt;/code&gt; 의 대상 이름은 자격 증명 클래스 이름과 프린시 펄 세트를 지정합니다. 이 권한 작업에 유효한 값은 &quot;읽기&quot;뿐입니다. 대상 이름은 다음 구문을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="91a399d1980f8a6ccc96217289bf0be48ee37eb6" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a pair of kerberos service principals. The first is the subordinate service principal being entrusted to use the TGT. The second service principal designates the target service the subordinate service principal is to interact with on behalf of the initiating KerberosPrincipal. This latter service principal is specified to restrict the use of a proxiable ticket.</source>
          <target state="translated">이 &lt;code&gt;Permission&lt;/code&gt; 의 대상 이름은 한 쌍의 Kerberos 서비스 주체를 지정합니다. 첫 번째는 TGT를 사용하도록 위임 된 하위 서비스 주체입니다. 두 번째 서비스 주체는 하위 서비스 주체가 시작 KerberosPrincipal을 대신하여 상호 작용할 대상 서비스를 지정합니다. 후자의 서비스 주체는 프록시 가능한 티켓의 사용을 제한하도록 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a69bc10fa3486dc0c871c21c9260fdc72fa60465" translate="yes" xml:space="preserve">
          <source>The target of the symbolic link</source>
          <target state="translated">심볼릭 링크의 대상</target>
        </trans-unit>
        <trans-unit id="2c722da0815ce9e96b3f893e4617b9ba63277f4a" translate="yes" xml:space="preserve">
          <source>The target of this processing instruction.</source>
          <target state="translated">이 처리 명령의 대상입니다.</target>
        </trans-unit>
        <trans-unit id="161ea52ef7deec6ab2b397da40779879d17b9eba" translate="yes" xml:space="preserve">
          <source>The target of this processing instruction. XML defines this as being the first token following the markup that begins the processing instruction.</source>
          <target state="translated">이 처리 명령의 대상입니다. XML은이를 처리 명령을 시작하는 마크 업 다음의 첫 번째 토큰으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0fba2a96aca3512f3b2fa2ec8c997febf4ea99a4" translate="yes" xml:space="preserve">
          <source>The target property may also be &quot;qualified&quot; with an arbitrary number of property prefixs delimited with the &quot;.&quot; character. For example, the following action listener:</source>
          <target state="translated">대상 속성은 &quot;.&quot;로 구분 된 임의의 수의 속성 접두사를 사용하여 &quot;자격을 갖춘&quot;것일 수도 있습니다. 캐릭터. 예를 들어, 다음 조치 리스너 :</target>
        </trans-unit>
        <trans-unit id="1d3891a04d782b20001436f81be88566164c49f9" translate="yes" xml:space="preserve">
          <source>The target screen mentioned below is a screen to which the window should be placed after the setLocationRelativeTo method is called.</source>
          <target state="translated">아래에 언급 된 대상 화면은 setLocationRelativeTo 메소드가 호출 된 후 윈도우가 배치되어야하는 화면입니다.</target>
        </trans-unit>
        <trans-unit id="c97110c6e47104527f8b4580cb3b4fa2f5426ed0" translate="yes" xml:space="preserve">
          <source>The target section of the processing instruction</source>
          <target state="translated">처리 명령의 대상 섹션</target>
        </trans-unit>
        <trans-unit id="8a356eae8e68f37248d1a45a231f374ef9c3a79c" translate="yes" xml:space="preserve">
          <source>The target string buffer</source>
          <target state="translated">대상 문자열 버퍼</target>
        </trans-unit>
        <trans-unit id="ce314a2a38875a9da27cad30daa60b7f939567ca" translate="yes" xml:space="preserve">
          <source>The target string builder</source>
          <target state="translated">대상 문자열 작성기</target>
        </trans-unit>
        <trans-unit id="90b7bab6e96d93a1672aed421456af62833a888b" translate="yes" xml:space="preserve">
          <source>The target width to scale the image.</source>
          <target state="translated">이미지 크기를 조정할 대상 너비입니다.</target>
        </trans-unit>
        <trans-unit id="0a63b487811a4aecdd285055ad083a6242c879eb" translate="yes" xml:space="preserve">
          <source>The task is &lt;a href=&quot;future#cancel(boolean)&quot;&gt;explicitly cancelled&lt;/a&gt; via the returned future.</source>
          <target state="translated">반환 된 미래를 통해 작업이 &lt;a href=&quot;future#cancel(boolean)&quot;&gt;명시 적으로 취소&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ac13bf867264e56e3d64038eb74fe1bea028918f" translate="yes" xml:space="preserve">
          <source>The tc &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= tc &amp;lt;=
 255&lt;/code&gt; or an IllegalArgumentException will be thrown.</source>
          <target state="translated">tc &lt;b&gt;는 &lt;/b&gt; &lt;code&gt;0 &amp;lt;= tc &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="351d171d0044484a95b6580add4a8d56a0b09177" translate="yes" xml:space="preserve">
          <source>The tempo-based timing type, for which the resolution is expressed in pulses (ticks) per quarter note.</source>
          <target state="translated">해상도가 1/4 음당 펄스 (틱)로 표시되는 템포 기반 타이밍 유형입니다.</target>
        </trans-unit>
        <trans-unit id="92a16bca2794be2e4d981e961e77157c978a16e0" translate="yes" xml:space="preserve">
          <source>The term &quot;blit&quot; is the pronounced version of the PDP-10 BLT (BLock Transfer) instruction, which copied a block of bits. (In case you were curious.)</source>
          <target state="translated">&quot;blit&quot;이라는 용어는 비트 블록을 복사 한 PDP-10 BLT (BLock Transfer) 명령의 발음 버전입니다. (호기심이 많을 경우)</target>
        </trans-unit>
        <trans-unit id="f2ec5ccb70e544f59fa930934598819b7960048f" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;directly present&lt;/em&gt;, &lt;em&gt;indirectly present&lt;/em&gt;, &lt;em&gt;present&lt;/em&gt;, and &lt;em&gt;associated&lt;/em&gt; are used throughout this interface to describe precisely which annotations are returned by methods:</source>
          <target state="translated">용어 &lt;em&gt;직접 본&lt;/em&gt; , &lt;em&gt;간접적으로 본&lt;/em&gt; , &lt;em&gt;본&lt;/em&gt; 과 &lt;em&gt;연관된은&lt;/em&gt; 정확하게 주석 방법에 의해 반환되는 기술이 인터페이스에 걸쳐 사용된다 :</target>
        </trans-unit>
        <trans-unit id="7bc919453997f5f639ef67c31f748841da8f874b" translate="yes" xml:space="preserve">
          <source>The text attributes.</source>
          <target state="translated">텍스트 속성.</target>
        </trans-unit>
        <trans-unit id="5e5bbe231cb2211cfe2a7c06f4bc2ee771bc88c2" translate="yes" xml:space="preserve">
          <source>The text boundary returned from the above methods, first or last text boundary.</source>
          <target state="translated">위 방법에서 반환 된 텍스트 경계, 첫 번째 또는 마지막 텍스트 경계.</target>
        </trans-unit>
        <trans-unit id="8858d11b87b0f0a3e19ee86a888321a1258f017b" translate="yes" xml:space="preserve">
          <source>The text components have a model-view split. A text component pulls together the objects used to represent the model, view, and controller. The text document model may be shared by other views which act as observers of the model (e.g. a document may be shared by multiple components).</source>
          <target state="translated">텍스트 구성 요소에는 모델보기 분할이 있습니다. 텍스트 구성 요소는 모델,보기 및 컨트롤러를 나타내는 데 사용되는 개체를 함께 가져옵니다. 텍스트 문서 모델은 모델의 관찰자 역할을하는 다른 뷰에 의해 공유 될 수 있습니다 (예 : 문서가 여러 구성 요소에 의해 공유 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="9f88b97ebbe499c00fc788624ded865b62c2d07e" translate="yes" xml:space="preserve">
          <source>The text components support flexible and internationalized text input, using keymaps and the input method framework, while maintaining compatibility with the AWT listener model.</source>
          <target state="translated">텍스트 구성 요소는 AWT 리스너 모델과의 호환성을 유지하면서 키맵 및 입력 방법 프레임 워크를 사용하여 유연하고 국제화 된 텍스트 입력을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bb4bc96683614ed09586bda7da975dbd546cc010" translate="yes" xml:space="preserve">
          <source>The text cursor type.</source>
          <target state="translated">텍스트 커서 유형입니다.</target>
        </trans-unit>
        <trans-unit id="792c37abc4943eebd3bef907dbd09262f47b21d8" translate="yes" xml:space="preserve">
          <source>The text editing component also has to provide an input method event listener.</source>
          <target state="translated">텍스트 편집 구성 요소는 입력 메서드 이벤트 리스너도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="68f58f74d3780f9460b9207f3ef04661f0ea9185" translate="yes" xml:space="preserve">
          <source>The text editing component also has to provide an instance of InputMethodRequests.</source>
          <target state="translated">텍스트 편집 구성 요소는 InputMethodRequests의 인스턴스도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="abe46b84ee53a236c2700231fa5bd7581d2fd49f" translate="yes" xml:space="preserve">
          <source>The text included with the input method event consists of two parts: committed text and composed text. Either part may be empty. The two parts together replace any uncommitted composed text sent in previous events, or the currently selected committed text. Committed text should be integrated into the text component's persistent data, it will not be sent again. Composed text may be sent repeatedly, with changes to reflect the user's editing operations. Committed text always precedes composed text.</source>
          <target state="translated">입력 방법 이벤트에 포함 된 텍스트는 커밋 된 텍스트와 작성된 텍스트의 두 부분으로 구성됩니다. 두 부분 모두 비어있을 수 있습니다. 두 부분은 함께 이전 이벤트에서 전송 된 커밋되지 않은 작성된 텍스트 또는 현재 선택된 커밋 된 텍스트를 대체합니다. 커밋 된 텍스트는 텍스트 구성 요소의 영구 데이터에 통합되어야하며 다시 전송되지 않습니다. 작성된 텍스트는 사용자의 편집 작업을 반영하도록 변경하여 반복적으로 보낼 수 있습니다. 커밋 된 텍스트는 항상 작성된 텍스트보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1899b3e37537fc1d6b9f560d72d02ead7717a9d2" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date-time.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 날짜-시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="119fbb383bccf4eac0375adfb016d1b3f8304e40" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date.</source>
          <target state="translated">포맷터를 사용하여 텍스트를 구문 분석하고 날짜를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc611f16d1b6999b1ff7fa074c651bc88768faa1" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a month-day.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 한 달 동안 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2408a1b2fa16fded0ccd21134505f7a2dfa87a20" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a time.</source>
          <target state="translated">포맷터를 사용하여 텍스트를 구문 분석하여 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8aa28741c1cf5a7ab0d06ececd2ac50c4950d93d" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year-month.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 1 년을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1700b19da145b2d61543e5a3e6060e9ee5311e75" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 1 년을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="714efd5fdbdc7a0051ac3528e30febfdfcc4d3b6" translate="yes" xml:space="preserve">
          <source>The text of the field will be output during a format. The value must be within the valid range of the field. If the value cannot be obtained then an exception will be thrown. If the field has no textual representation, then the numeric value will be used.</source>
          <target state="translated">필드의 텍스트는 포맷 중에 출력됩니다. 값은 필드의 유효한 범위 내에 있어야합니다. 값을 얻을 수 없으면 예외가 발생합니다. 필드에 텍스트 표현이 없으면 숫자 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="994a75acb429e80d94201f4b7fd1307dd3c02908" translate="yes" xml:space="preserve">
          <source>The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is the same that would be returned by</source>
          <target state="translated">반환 된 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 의 텍스트 는 다음과 같이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8d32f65f9358481d68c26733468e9f5827be3bb9" translate="yes" xml:space="preserve">
          <source>The text range that the attribute is applied to is critical to the semantics of the range. That means, the attribute cannot be applied to subranges of the text range that it applies to, and, if two adjacent text ranges have the same value for this attribute, the attribute still cannot be applied to the combined range as a whole with this value.</source>
          <target state="translated">속성이 적용되는 텍스트 범위는 해당 범위의 의미에 중요합니다. 즉, 속성을 적용 할 텍스트 범위의 하위 범위에 속성을 적용 할 수 없으며, 인접한 두 텍스트 범위에이 속성 값이 동일한 경우이 값을 사용하여 속성을 결합 된 범위에 계속 적용 할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="7c3f83472e562d9215e150160baafa85452b5724" translate="yes" xml:space="preserve">
          <source>The text representation of each constant UnicodeBlock identifier. For example, this method will return the &lt;a href=&quot;#BASIC_LATIN&quot;&gt;&lt;code&gt;BASIC_LATIN&lt;/code&gt;&lt;/a&gt; block if provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and hyphens in the canonical name with underscores.</source>
          <target state="translated">각 상수 UnicodeBlock 식별자의 텍스트 표현입니다. 예를 들어,이 메서드는 &quot;BASIC_LATIN&quot;이름과 함께 제공된 경우 &lt;a href=&quot;#BASIC_LATIN&quot;&gt; &lt;code&gt;BASIC_LATIN&lt;/code&gt; &lt;/a&gt; 블록 을 반환합니다 . 이 양식은 표준 이름의 모든 공백과 하이픈을 밑줄로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1b53d1b9f2d6a1ffec39094319a28b6fff2de1b3" translate="yes" xml:space="preserve">
          <source>The text representation of each constant UnicodeBlock identifier. For example, this method will return the &lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt;&lt;code&gt;BASIC_LATIN&lt;/code&gt;&lt;/a&gt; block if provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and hyphens in the canonical name with underscores.</source>
          <target state="translated">각 상수 UnicodeBlock 식별자의 텍스트 표현입니다. 예를 들어,이 메소드는 &quot;BASIC_LATIN&quot;이름이 제공된 경우 &lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt; &lt;code&gt;BASIC_LATIN&lt;/code&gt; &lt;/a&gt; 블록 을 리턴합니다 . 이 형식은 표준 이름의 모든 공백과 하이픈을 밑줄로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="77b9d7619830528efce6f7817705037fc5acc9d6" translate="yes" xml:space="preserve">
          <source>The text substituted for the individual format elements is derived from the current subformat of the format element and the &lt;code&gt;arguments&lt;/code&gt; element at the format element's argument index as indicated by the first matching line of the following table. An argument is</source>
          <target state="translated">개별 형식 요소로 대체 ​​된 텍스트는 형식 요소의 현재 하위 형식과 다음 표의 첫 번째 일치 행으로 표시되는 형식 요소의 인수 색인에 있는 &lt;code&gt;arguments&lt;/code&gt; 요소에서 파생됩니다 . 논쟁은</target>
        </trans-unit>
        <trans-unit id="9207fb7b3a8409b78131b80ed0af5df70aca6d6f" translate="yes" xml:space="preserve">
          <source>The text will be parsed from the specified start &lt;code&gt;ParsePosition&lt;/code&gt;. The entire length of the text does not have to be parsed, the &lt;code&gt;ParsePosition&lt;/code&gt; will be updated with the index at the end of parsing.</source>
          <target state="translated">지정된 시작 &lt;code&gt;ParsePosition&lt;/code&gt; 에서 텍스트가 구문 분석됩니다 . 텍스트의 전체 길이를 구문 분석 할 필요는 없습니다 . 구문 분석 종료시 &lt;code&gt;ParsePosition&lt;/code&gt; 이 색인으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ef359eb63a3e4e2e83b93c0386e4232cb9ad999c" translate="yes" xml:space="preserve">
          <source>The text.</source>
          <target state="translated">텍스트</target>
        </trans-unit>
        <trans-unit id="1448b4199b12055b6e038925f7a2322eace6c39d" translate="yes" xml:space="preserve">
          <source>The textual representation of IPv6 addresses as described above can be extended to specify IPv6 scoped addresses. This extension to the basic addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].</source>
          <target state="translated">위에서 설명한 IPv6 주소의 텍스트 표현을 확장하여 IPv6 범위 주소를 지정할 수 있습니다. 기본 주소 지정 아키텍처에 대한이 확장은 [draft-ietf-ipngwg-scoping-arch-04.txt]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="619857d696535395d9a9e6e85c75cbda308cd69b" translate="yes" xml:space="preserve">
          <source>The textual representation of an IP address is address family specific.</source>
          <target state="translated">IP 주소의 텍스트 표현은 주소 패밀리에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a243b35a93201c218afa01a0732e236f52dc54db" translate="yes" xml:space="preserve">
          <source>The third rule means for example that if the attribute &lt;code&gt;HeapMemoryUsage&lt;/code&gt; is a &lt;code&gt;MemoryUsage&lt;/code&gt;, monitoring &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; will obtain the observed value by calling &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt;.</source>
          <target state="translated">세 번째 규칙은 예를 들어 &lt;code&gt;HeapMemoryUsage&lt;/code&gt; 속성 이 &lt;code&gt;MemoryUsage&lt;/code&gt; 인 경우 &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; 를 모니터링 하면 &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt; 를 호출하여 관찰 된 값을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="1524da4ee526fb66e2dfa2fc314cd6b0009b09e7" translate="yes" xml:space="preserve">
          <source>The third statement above returns a &lt;code&gt;SecureRandom&lt;/code&gt; object of the specific algorithm supporting the specific instantiate parameters. The implementation's effective instantiated parameters must match this minimum request but is not necessarily the same. For example, even if the request does not require a certain feature, the actual instantiation can provide the feature. An implementation may lazily instantiate a &lt;code&gt;SecureRandom&lt;/code&gt; until it's actually used, but the effective instantiate parameters must be determined right after it's created and &lt;a href=&quot;#getParameters()&quot;&gt;&lt;code&gt;getParameters()&lt;/code&gt;&lt;/a&gt; should always return the same result unchanged.</source>
          <target state="translated">위의 세 번째 문 은 특정 인스턴스화 매개 변수를 지원하는 특정 알고리즘 의 &lt;code&gt;SecureRandom&lt;/code&gt; 개체를 반환합니다 . 구현의 효과적인 인스턴스화 매개 변수는이 최소 요청과 일치해야하지만 반드시 동일하지는 않습니다. 예를 들어 요청에 특정 기능이 필요하지 않더라도 실제 인스턴스화가 해당 기능을 제공 할 수 있습니다. 구현은 실제로 사용될 때까지 &lt;code&gt;SecureRandom&lt;/code&gt; 을 느리게 인스턴스화 할 수 있지만 효과적인 인스턴스화 매개 변수는 생성 된 직후 결정되어야하며 &lt;a href=&quot;#getParameters()&quot;&gt; &lt;code&gt;getParameters()&lt;/code&gt; &lt;/a&gt; 는 항상 동일한 결과를 변경하지 않고 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd8c7b9c1c14ab7ee8912062724df6f9139f499d" translate="yes" xml:space="preserve">
          <source>The third type of ID are region-based IDs. A region-based ID must be of two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'. Region-based IDs are defined by configuration, see &lt;a href=&quot;zone/zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt;. The configuration focuses on providing the lookup from the ID to the underlying &lt;code&gt;ZoneRules&lt;/code&gt;.</source>
          <target state="translated">세 번째 유형의 ID는 지역 기반 ID입니다. 지역 기반 ID는 2 자 이상이어야하며 'UTC', 'GMT', 'UT' '+'또는 '-'로 시작하지 않아야합니다. 지역 기반 ID는 구성에 따라 정의됩니다 ( &lt;a href=&quot;zone/zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; &lt;/a&gt; 참조) . 구성은 ID에서 기본 &lt;code&gt;ZoneRules&lt;/code&gt; 로 조회를 제공하는 데 중점을 둡니다 .</target>
        </trans-unit>
        <trans-unit id="7b2d5ce3a5a55711a2ea3b6fec5e3843d8b5a85a" translate="yes" xml:space="preserve">
          <source>The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this object and re-enabled for thread scheduling. It competes in the usual manner with other threads for the right to synchronize on the object; once it has regained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the &lt;code&gt;wait&lt;/code&gt; method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the invocation of the &lt;code&gt;wait&lt;/code&gt; method. Thus, on return from the &lt;code&gt;wait&lt;/code&gt; method, the synchronization state of the object and of thread &lt;code&gt;T&lt;/code&gt; is exactly as it was when the &lt;code&gt;wait&lt;/code&gt; method was invoked.</source>
          <target state="translated">그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 는이 개체에 대한 대기 세트에서 제거되고 스레드 예약을 위해 다시 활성화됩니다. 개체에서 동기화 할 수있는 권한을 얻기 위해 일반적인 방식으로 다른 스레드와 경쟁합니다. 개체에 대한 제어권을 다시 확보하면 개체에 대한 모든 동기화 클레임이 상태 유지, 즉 &lt;code&gt;wait&lt;/code&gt; 메서드가 호출 된 시점의 상황으로 복원 됩니다. 그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 는 &lt;code&gt;wait&lt;/code&gt; 메서드 호출에서 반환됩니다 . 따라서 &lt;code&gt;wait&lt;/code&gt; 메소드 에서 리턴 할 때 객체와 스레드 &lt;code&gt;T&lt;/code&gt; 의 동기화 상태 는 &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 되었을 때와 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="798fb3ab3b700a8b0974f49f646feb0adf6c0b98" translate="yes" xml:space="preserve">
          <source>The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the &lt;code&gt;wait&lt;/code&gt; method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the invocation of the &lt;code&gt;wait&lt;/code&gt; method. Thus, on return from the &lt;code&gt;wait&lt;/code&gt; method, the synchronization state of the object and of thread &lt;code&gt;T&lt;/code&gt; is exactly as it was when the &lt;code&gt;wait&lt;/code&gt; method was invoked.</source>
          <target state="translated">그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 가이 오브젝트의 대기 세트에서 제거되고 스레드 스케줄링을 위해 다시 사용 가능합니다. 그런 다음 일반적인 방식으로 다른 스레드와 경쟁하여 개체에서 동기화 할 수 있습니다. 일단 객체의 제어권을 얻은 후에는 객체에 대한 모든 동기화 클레임이 현재 상태 즉, &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 된 시점의 상황으로 복원 됩니다. 그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 는 &lt;code&gt;wait&lt;/code&gt; 메소드 호출에서 리턴합니다 . 따라서 &lt;code&gt;wait&lt;/code&gt; 메소드 에서 리턴 될 때 오브젝트와 스레드 &lt;code&gt;T&lt;/code&gt; 의 동기화 상태 는 &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 되었을 때와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3886d03f704e9f4661772e22e536d051a2540f61" translate="yes" xml:space="preserve">
          <source>The thread ID property will be initialized with a unique ID for the current thread.</source>
          <target state="translated">스레드 ID 속성은 현재 스레드의 고유 ID로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="3224cdeecc04e300e6f6eb5dd7b0f464a0f08ee9" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#BLOCKED&quot;&gt;&lt;code&gt;BLOCKED&lt;/code&gt;&lt;/a&gt; state waiting to enter the &lt;code&gt;synchronized&lt;/code&gt; statement or method.</source>
          <target state="translated">스레드가 &lt;code&gt;synchronized&lt;/code&gt; 명령문 또는 메소드 를 입력하기 위해 대기중인 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#BLOCKED&quot;&gt; &lt;code&gt;BLOCKED&lt;/code&gt; &lt;/a&gt; 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="f6a7e6fbe217b20213591b29b1d875c85171794a" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../../../java.base/java/lang/object#wait()&quot;&gt;&lt;code&gt;Object.wait&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드가 &lt;a href=&quot;../../../../java.base/java/lang/object#wait()&quot;&gt; &lt;code&gt;Object.wait&lt;/code&gt; &lt;/a&gt; 메서드 호출로 인해 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태에 있습니다.</target>
        </trans-unit>
        <trans-unit id="87a5145ea7018df714b4f0182c383913942e6f12" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#park(java.lang.Object)&quot;&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;&lt;/a&gt; method. The synchronization object is the object returned from &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#getBlocker(java.lang.Thread)&quot;&gt;&lt;code&gt;LockSupport.getBlocker&lt;/code&gt;&lt;/a&gt; method. Typically it is an &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt; or a &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#park(java.lang.Object)&quot;&gt; &lt;code&gt;LockSupport.park&lt;/code&gt; &lt;/a&gt; 메서드 호출로 인해 스레드가 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태에 있습니다. 동기화 개체는 &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#getBlocker(java.lang.Thread)&quot;&gt; &lt;code&gt;LockSupport.getBlocker&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 개체입니다 . 일반적으로 &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;소유 할 수있는 동기화 장치&lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b9cc25b45a652d2428c1ca7ad40c7f0ae634fb0" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#BLOCKED&quot;&gt;&lt;code&gt;BLOCKED&lt;/code&gt;&lt;/a&gt; state waiting to enter the &lt;code&gt;synchronized&lt;/code&gt; statement or method.</source>
          <target state="translated">스레드가 &lt;a href=&quot;../thread.state#BLOCKED&quot;&gt; &lt;code&gt;BLOCKED&lt;/code&gt; &lt;/a&gt; 상태에 있으며 &lt;code&gt;synchronized&lt;/code&gt; 명령문 또는 메소드 를 입력하려고 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="77e59a24e2fff88b3f72bac70df76f307ccbec5b" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;&lt;/a&gt; method. The synchronization object is the object returned from &lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;LockSupport.getBlocker&lt;/code&gt;&lt;/a&gt; method. Typically it is an &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt; or a &lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt; &lt;code&gt;LockSupport.park&lt;/code&gt; &lt;/a&gt; 메소드 호출로 인해 스레드가 &lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태 입니다. 동기화 오브젝트는 &lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;LockSupport.getBlocker&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 오브젝트입니다 . 일반적으로 &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;소유 가능한 동기화 기&lt;/a&gt; 또는 &lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7b971951034e25a9cbf8c4a7520b71c76ce7c9c" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../object#wait-long-&quot;&gt;&lt;code&gt;Object.wait&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드는 &lt;a href=&quot;../object#wait-long-&quot;&gt; &lt;code&gt;Object.wait&lt;/code&gt; &lt;/a&gt; 메소드 호출로 인해 &lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="1cae8d80c59d4da83095fa5ad01a12ad0e9b0377" translate="yes" xml:space="preserve">
          <source>The thread represented by this thread is forced to stop whatever it is doing abnormally and to throw a newly created &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.</source>
          <target state="translated">이 스레드로 표시되는 스레드는 비정상적으로 수행중인 작업을 중지하고 새로 작성된 &lt;code&gt;ThreadDeath&lt;/code&gt; 오브젝트를 예외로 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0b3e60ed90635a926c08dd344792b7dde7c9298f" translate="yes" xml:space="preserve">
          <source>The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</source>
          <target state="translated">그런 다음 스레드는 모니터 소유권을 다시 얻을 수있을 때까지 기다렸다가 실행을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="25b717a3fa1cf9d27360f778068bc0905b1e3681" translate="yes" xml:space="preserve">
          <source>The threads may be executing while this method is called. The stack trace of each thread only represents a snapshot and each stack trace may be obtained at different time. A zero-length array will be returned in the map value if the virtual machine has no stack trace information about a thread.</source>
          <target state="translated">이 메소드가 호출되는 동안 스레드가 실행 중일 수 있습니다. 각 스레드의 스택 추적은 스냅 샷 만 나타내며 각 스택 추적은 다른 시간에 얻을 수 있습니다. 가상 머신에 스레드에 대한 스택 추적 정보가없는 경우 길이가 0 인 배열이 맵 값으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e3ff0b6b3a8faf4f1e95b0c706e80d227c4311" translate="yes" xml:space="preserve">
          <source>The three aspects of &lt;code&gt;collect&lt;/code&gt; -- supplier, accumulator, and combiner -- are tightly coupled. We can use the abstraction of a &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; to capture all three aspects. The above example for collecting strings into a &lt;code&gt;List&lt;/code&gt; can be rewritten using a standard &lt;code&gt;Collector&lt;/code&gt; as:</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; , 공급기, 축 압기 및 결합기 의 세 가지 측면 은 밀접하게 연결되어 있습니다. &lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt; 의 추상화를 사용하여 세 가지 측면을 모두 캡처 할 수 있습니다 . 문자열을 &lt;code&gt;List&lt;/code&gt; 로 수집하는 위의 예제는 다음과 같이 표준 &lt;code&gt;Collector&lt;/code&gt; 를 사용하여 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac4e5d34586392cc6376d13f3ac41b119993fff0" translate="yes" xml:space="preserve">
          <source>The three forms of &lt;code&gt;park&lt;/code&gt; each also support a &lt;code&gt;blocker&lt;/code&gt; object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method &lt;a href=&quot;#getBlocker(java.lang.Thread)&quot;&gt;&lt;code&gt;getBlocker(Thread)&lt;/code&gt;&lt;/a&gt;.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a &lt;code&gt;blocker&lt;/code&gt; within a lock implementation is &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">세 가지 형태의 &lt;code&gt;park&lt;/code&gt; 각각 &lt;code&gt;blocker&lt;/code&gt; 개체 매개 변수를 지원합니다 . 이 개체는 스레드가 차단 된 동안 기록되어 스레드가 차단 된 이유를 식별 할 수있는 모니터링 및 진단 도구를 허용합니다. (이러한 도구는 &lt;a href=&quot;#getBlocker(java.lang.Thread)&quot;&gt; &lt;code&gt;getBlocker(Thread)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 차단기에 액세스 할 수 있습니다 .)이 매개 변수가없는 원래 양식 대신 이러한 양식을 사용하는 것이 좋습니다. 잠금 구현 내에서 &lt;code&gt;blocker&lt;/code&gt; 로 제공하는 일반적인 인수 는 &lt;code&gt;this&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ccdf2eb66d2e71f34a919a596f65bb338f795c35" translate="yes" xml:space="preserve">
          <source>The three forms of &lt;code&gt;park&lt;/code&gt; each also support a &lt;code&gt;blocker&lt;/code&gt; object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method &lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;getBlocker(Thread)&lt;/code&gt;&lt;/a&gt;.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a &lt;code&gt;blocker&lt;/code&gt; within a lock implementation is &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">3 가지 형태의 &lt;code&gt;park&lt;/code&gt; 각각 &lt;code&gt;blocker&lt;/code&gt; 객체 매개 변수를 지원합니다 . 이 오브젝트는 스레드가 차단되는 동안 기록되어 모니터링 및 진단 도구가 스레드가 차단 된 이유를 식별 할 수 있습니다. (이러한 도구는 &lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;getBlocker(Thread)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 블로커에 액세스 할 수 있습니다 .)이 매개 변수가없는 원래 양식 대신 이러한 양식을 사용하는 것이 좋습니다. 잠금 구현 내에서 &lt;code&gt;blocker&lt;/code&gt; 로 제공하는 일반적인 인수 는 &lt;code&gt;this&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df00dd95000e60bd282d65d477e94c0a82461152" translate="yes" xml:space="preserve">
          <source>The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms.</source>
          <target state="translated">대기 중, 중단 불가능 및 시간 지정의 세 가지 조건 대기 조건은 일부 플랫폼에서의 구현 용이성과 성능 특성이 다를 수 있습니다. 특히, 이러한 기능을 제공하고 주문 보장과 같은 특정 의미를 유지하는 것이 어려울 수 있습니다. 또한 스레드의 실제 서스펜션을 방해하는 기능이 모든 플랫폼에서 항상 구현 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db29ad82518a2ee6d7ddfaf1a9c7b34c8ecf4057" translate="yes" xml:space="preserve">
          <source>The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt; acquisition of a lock may not be available in a given &lt;code&gt;Lock&lt;/code&gt; class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.</source>
          <target state="translated">3 가지 형태의 잠금 획득 (인터럽터 블, 인터럽터 블 및 타임 드)은 성능 특성, 순서 보증 또는 기타 구현 품질이 다를 수 있습니다. 또한, 잠금 의 &lt;em&gt;진행중인&lt;/em&gt; 획득 을 방해하는 기능 은 주어진 &lt;code&gt;Lock&lt;/code&gt; 에서 사용 가능하지 않을 수 있습니다수업. 결과적으로, 구현은 세 가지 형태의 잠금 획득 모두에 대해 정확히 동일한 보장 또는 의미를 정의 할 필요가 없으며, 진행중인 잠금 획득의 중단을 지원할 필요도 없다. 각 잠금 방법이 제공하는 의미 및 보증을 명확하게 문서화하려면 구현이 필요합니다. 또한 잠금 획득 중단이 지원되는 정도까지이 인터페이스에 정의 된 중단 시맨틱을 준수해야합니다. 이는 완전히 또는 메소드 입력에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb65090e22ab8912d71a3b4c421185f9239fb8c9" translate="yes" xml:space="preserve">
          <source>The three types of rendering operations, along with details of each of their particular rendering processes are:</source>
          <target state="translated">세 가지 유형의 렌더링 작업과 각 특정 렌더링 프로세스의 세부 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1243cf17aa93cee91f50c4b5f0c4dfc5e1efee1" translate="yes" xml:space="preserve">
          <source>The three values for decomposition mode are:</source>
          <target state="translated">분해 모드의 세 가지 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eca35f7b2afddf8594835c4c8f46728d1529fce5" translate="yes" xml:space="preserve">
          <source>The three-argument form is a generalization of the two-argument form, incorporating a mapping step into the accumulation step. We could re-cast the simple sum-of-weights example using the more general form as follows:</source>
          <target state="translated">3 인수 형식은 매핑 단계를 누적 단계에 통합 한 2 인수 형식의 일반화입니다. 다음과 같이보다 일반적인 형식을 사용하여 간단한 가중치 합계 예제를 다시 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e826b013ebf5d13455251fda42b4b52a0a40d6" translate="yes" xml:space="preserve">
          <source>The threshold high or threshold low are not of the same type as the gauge (gauge monitors).</source>
          <target state="translated">임계 값 상한 또는 임계 값 하한은 게이지 (게이지 모니터)와 동일한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="618cf78884b8f69aa1ff4f548c236bef8d448a10" translate="yes" xml:space="preserve">
          <source>The threshold or the offset or the modulus are not of the same type as the counter (counter monitors).</source>
          <target state="translated">임계 값 또는 오프셋 또는 계수는 카운터 (카운터 모니터)와 동일한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b761c49c0df6550fd9288c6d950a41463038892" translate="yes" xml:space="preserve">
          <source>The threshold value for the specified MBean if this MBean is in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">이 MBean가 관찰 된 MBean 세트에있는 경우, 지정된 MBean의 임계 값 . 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4abbaad922146601ba46b4fe49f8e578a3e9883a" translate="yes" xml:space="preserve">
          <source>The threshold value of the specified object.</source>
          <target state="translated">지정된 객체의 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="93ccc78354f36ab6014746446d9124e4c9a55c8e" translate="yes" xml:space="preserve">
          <source>The threshold value.</source>
          <target state="translated">임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="c8421d23d14f7481a0d1af497cd30f15efc9c681" translate="yes" xml:space="preserve">
          <source>The tick duration must be positive. If it has a part smaller than a whole millisecond, then the whole duration must divide into one second without leaving a remainder. All normal tick durations will match these criteria, including any multiple of hours, minutes, seconds and milliseconds, and sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.</source>
          <target state="translated">틱 기간은 양수 여야합니다. 전체 밀리 초보다 작은 부분이 있으면 나머지 시간을 남기지 않고 전체 지속 시간을 1 초로 나누어야합니다. 모든 일반 틱 기간은 시간, 분, 초 및 밀리 초의 배수 및 20ns, 250,000ns 및 500,000ns와 같은 합리적인 나노초 기간을 포함하여 이러한 기준과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3d7a7f884123f38061b4f01b40f6fca44848eb92" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cf65733067f037d5f7c0913c18befc5a4452eae3" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown.</source>
          <target state="translated">시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 결과 &lt;code&gt;OffsetDateTime&lt;/code&gt; 이 유효하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c06ad7fab5af0cf4e31869a72aaa8c0967814aa" translate="yes" xml:space="preserve">
          <source>The time does not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">시간은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4106b4f9e69339c1872abca12ca2da7faed9666a" translate="yes" xml:space="preserve">
          <source>The time in milli-seconds that the MBeanInfo can reasonably be expected to be unchanged. The value can be a &lt;code&gt;Long&lt;/code&gt; or a decimal string. This provides a hint from a DynamicMBean or any MBean that does not define &lt;code&gt;immutableInfo&lt;/code&gt; as &lt;code&gt;true&lt;/code&gt; that the MBeanInfo is not likely to change within this period and therefore can be cached. When this field is missing or has the value zero, it is not recommended to cache the MBeanInfo unless it has the &lt;code&gt;immutableInfo&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; or it has &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; in its &lt;a href=&quot;mbeannotificationinfo&quot;&gt;&lt;code&gt;MBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; array.</source>
          <target state="translated">MBeanInfo가 합리적으로 변경 될 것으로 예상되는 시간 (밀리 초)입니다. 값은 &lt;code&gt;Long&lt;/code&gt; 또는 10 진수 문자열 일 수 있습니다 . 이는 MBeanInfo가이 기간 내에 변경되지 않아 캐시 될 수 있다는 &lt;code&gt;true&lt;/code&gt; &lt;code&gt;immutableInfo&lt;/code&gt; 를 true 로 정의하지 않은 DynamicMBean 또는 MBean의 힌트를 제공합니다 . 이 필드가 없거나 값이 0 인 경우, &lt;code&gt;immutableInfo&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있거나 &lt;a href=&quot;mbeannotificationinfo&quot;&gt; &lt;code&gt;MBeanNotificationInfo&lt;/code&gt; &lt;/a&gt; 배열 에 &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 MBeanInfo를 캐시하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="acbf0fbbf2519547cc43bc06b63a9e4515272ec9" translate="yes" xml:space="preserve">
          <source>The time is converted into an instant using the time definition.</source>
          <target state="translated">시간은 시간 정의를 사용하여 순간으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5996955378dd36992f5dee7922b6ee64c4396fe3" translate="yes" xml:space="preserve">
          <source>The time limit of these SearchControls in milliseconds.</source>
          <target state="translated">이러한 SearchControl의 시간 제한 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="526444c169e427c129c525d4df96c1420c7a51f7" translate="yes" xml:space="preserve">
          <source>The time of midnight at the start of the day, '00:00'.</source>
          <target state="translated">시작 시간의 자정 시간, '00 : 00 '.</target>
        </trans-unit>
        <trans-unit id="8f833517ae6c82bdf28f4d07f70897fd379d4f67" translate="yes" xml:space="preserve">
          <source>The time of noon in the middle of the day, '12:00'.</source>
          <target state="translated">정오의 시간, '12 : 00 '.</target>
        </trans-unit>
        <trans-unit id="64a643ca048518ba71b10504256b6f2db499384f" translate="yes" xml:space="preserve">
          <source>The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of &lt;em&gt;mode&lt;/em&gt;s to specify the time: &lt;a href=&quot;#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STANDARD_TIME&quot;&gt;&lt;code&gt;STANDARD_TIME&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#UTC_TIME&quot;&gt;&lt;code&gt;UTC_TIME&lt;/code&gt;&lt;/a&gt;. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the &lt;a href=&quot;#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt; mode. In this case, the wall clock time for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.</source>
          <target state="translated">일광 절약 시간이 시작되거나 끝나는 시간은 하루 중 밀리 초 값으로 지정됩니다. 시간을 지정하는 &lt;em&gt;모드&lt;/em&gt; 에는 &lt;a href=&quot;#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#STANDARD_TIME&quot;&gt; &lt;code&gt;STANDARD_TIME&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#UTC_TIME&quot;&gt; &lt;code&gt;UTC_TIME&lt;/code&gt; &lt;/a&gt; 세 종류가 &lt;em&gt;있습니다&lt;/em&gt; . 예를 들어 일광 절약 시간이 벽시계 시간으로 오전 2시에 종료되는 경우 &lt;a href=&quot;#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; 모드 에서 7200000 밀리 초로 지정할 수 있습니다 . 이 경우 &lt;em&gt;종료 규칙의&lt;/em&gt; 벽시계 시간 은 일광 시간과 동일한 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8f963cde5781a47df760ad32650d381c8f0dbe75" translate="yes" xml:space="preserve">
          <source>The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of &lt;em&gt;mode&lt;/em&gt;s to specify the time: &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt;&lt;code&gt;STANDARD_TIME&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt;&lt;code&gt;UTC_TIME&lt;/code&gt;&lt;/a&gt;. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt; mode. In this case, the wall clock time for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.</source>
          <target state="translated">일광 절약 시간 제가 시작되거나 끝나는 시간은 하루 내의 밀리 초 값으로 지정됩니다. 시간을 지정하는 세 가지 종류의 &lt;em&gt;모드&lt;/em&gt; 가 있습니다 : &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt; &lt;code&gt;STANDARD_TIME&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt; &lt;code&gt;UTC_TIME&lt;/code&gt; &lt;/a&gt; . 예를 들어, 일광 절약 시간이 벽시계 시간으로 오전 2시에 종료되면 &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; 모드 에서 7200000 밀리 초로 지정할 수 있습니다 . 이 경우 &lt;em&gt;종료 규칙의&lt;/em&gt; 벽시계 시간 은 일광 절약 시간과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3f682fddb863e7c5b381d42cd6be2e0499225644" translate="yes" xml:space="preserve">
          <source>The time stamp.</source>
          <target state="translated">타임 스탬프.</target>
        </trans-unit>
        <trans-unit id="3cb58d5d8003015620c159da03ce3e4d5619a359" translate="yes" xml:space="preserve">
          <source>The time stamp. Replaced by InputEvent.getWhen().</source>
          <target state="translated">타임 스탬프. InputEvent.getWhen ()으로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="422a6a0727efc668eadfab588f39e7901af76990" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for disabling the expiration control for loaded resource bundle instances in the cache.</source>
          <target state="translated">캐시에로드 된 자원 번들 인스턴스에 대한 만료 제어를 사용하지 않도록 설정하기위한 지속 시간 상수</target>
        </trans-unit>
        <trans-unit id="c09406968aca987adec6afd3d870562c13c5226c" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for not caching loaded resource bundle instances.</source>
          <target state="translated">로드 된 자원 번들 인스턴스를 캐싱하지 않는 지속 시간 상수.</target>
        </trans-unit>
        <trans-unit id="2948afa6c507e96db7157cef9cbb050870dbd00b" translate="yes" xml:space="preserve">
          <source>The time-zone offset for UTC, with an ID of 'Z'.</source>
          <target state="translated">ID가 'Z'인 UTC의 시간대 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="1dfd324cfb41000f9d3aba1f9dad090939b1b93f" translate="yes" xml:space="preserve">
          <source>The timeout period, specified by &lt;code&gt;timeout&lt;/code&gt; milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds arguments, has elapsed.</source>
          <target state="translated">시간 &lt;code&gt;timeout&lt;/code&gt; 밀리 초와 &lt;code&gt;nanos&lt;/code&gt; 나노초 인수로 지정된 시간 초과 기간 이 경과했습니다.</target>
        </trans-unit>
        <trans-unit id="e87dd73958b4c331aa3b482b31ba9b3bb70f0291" translate="yes" xml:space="preserve">
          <source>The timeout value, in milliseconds, indicates the maximum amount of time the try should take. If the operation times out before getting an answer, the host is deemed unreachable. A negative value will result in an IllegalArgumentException being thrown.</source>
          <target state="translated">시간 초과 값 (밀리 초)은 시도에 걸리는 최대 시간을 나타냅니다. 응답을 받기 전에 작업 시간이 초과되면 호스트에 연결할 수없는 것으로 간주됩니다. 값이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a3c7016b356d85ab2005993ec546da2021f5da3" translate="yes" xml:space="preserve">
          <source>The timer notification detailed message or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 상세 메세지. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 맵되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="e45c48a5b2ba20c62b4614e6273292d7390eb1e1" translate="yes" xml:space="preserve">
          <source>The timer notification type or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 형. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 매핑되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="23967f54cac8eb8b003d2fc196f922e43be03fd3" translate="yes" xml:space="preserve">
          <source>The timer notification user data object or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 사용자 데이터 객체. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 매핑되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="d238facacd1f3d07587721542ed70d70cb4c4775" translate="yes" xml:space="preserve">
          <source>The timer notification will be handled once at the specified date.</source>
          <target state="translated">타이머 알림은 지정된 날짜에 한 번 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="414f37292531292150b0ccb1cad0625336e616e7" translate="yes" xml:space="preserve">
          <source>The timer notification will repeat continuously using the timer period using a</source>
          <target state="translated">타이머 알림은 a를 사용하여 타이머 기간을 사용하여 계속 반복됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
