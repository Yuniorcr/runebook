<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="4763a9ecd486025e4d2f3721af996066ac33a40e" translate="yes" xml:space="preserve">
          <source>Identifies the attributes that are unsupported for a print request in the context of a particular DocFlavor. This method is useful for validating a potential print job and identifying the specific attributes which cannot be supported. It is important to supply only a supported DocFlavor or an IllegalArgumentException will be thrown. If the return value from this method is null, all attributes are supported.</source>
          <target state="translated">특정 DocFlavor의 컨텍스트에서 인쇄 요청에 지원되지 않는 속성을 식별합니다. 이 방법은 잠재적 인 인쇄 작업의 유효성을 검사하고 지원할 수없는 특정 속성을 식별하는 데 유용합니다. 지원되는 DocFlavor 만 제공하는 것이 중요합니다. 그렇지 않으면 IllegalArgumentException이 발생합니다. 이 메소드의 리턴 값이 널이면 모든 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e29f496c3f456820ee10c81956796ec487e44240" translate="yes" xml:space="preserve">
          <source>Identifies the column of the cell being edited.</source>
          <target state="translated">Identifies the column of the cell being edited.</target>
        </trans-unit>
        <trans-unit id="703c3afbde758e774437bc323b1693360cdd4baa" translate="yes" xml:space="preserve">
          <source>Identifies the deletion of rows and/or columns.</source>
          <target state="translated">Identifies the deletion of rows and/or columns.</target>
        </trans-unit>
        <trans-unit id="60c1e07980f5b52bc5c14a70128194ef7e7dfe73" translate="yes" xml:space="preserve">
          <source>Identifies the focus change event as temporary or permanent.</source>
          <target state="translated">Identifies the focus change event as temporary or permanent.</target>
        </trans-unit>
        <trans-unit id="2135de32921487f93b0f024f77cef6796558ef06" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;ARRAY&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;ARRAY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8cc5f6a758c760582e2fdedfc5273ae9a232b3f" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;BIGINT&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;BIGINT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="614c7b06b077206da60786b2df54b5feaadfbc10" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;BINARY&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;BINARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a42917ae9e487899b4ce01dc77bc6d81d4f40cf" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;BIT&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;BIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa503f381bf148559d93656d7c20bf2086c66326" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;BLOB&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;BLOB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c3844d028f3c49b58e76352bd44ce17851c42bf" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;BOOLEAN&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;BOOLEAN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="909d4f82a0aa011074d75f3d5920742c8948332a" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;CHAR&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;CHAR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f94f2d3db1e10a5d0da3f2bd144e22c66125c3" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;CLOB&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;CLOB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c15b77bde6f51aa541790a5c4130207d0fb11b3" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;DATALINK&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;DATALINK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eceba3d91171b8a1eca59d4d33a9b2f7b0ce24f5" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;DATE&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;DATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74fb7b20ddcaf5e9685fcf86b140f3190f51e345" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;DECIMAL&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;DECIMAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="688c544b63e8873879dd2a2ef366f61c0e7546aa" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;DISTINCT&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;DISTINCT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccea0d6e0f9e2d1798f3a419588c6dbecc4cc031" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;DOUBLE&lt;/code&gt;.</source>
          <target state="translated">Identifies the generic SQL type &lt;code&gt;DOUBLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb54ca4d563f04c7ee7070e4b3395006e3e4084" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;FLOAT&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;FLOAT&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="112d7d8b208a46016abcd4cf9a05a0e0c449a3cc" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;INTEGER&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="72b2c7c1d580a52ef8b189e7f6e5878d294baae4" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;LONGNVARCHAR&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;LONGNVARCHAR&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="27fef305fe3e21a19856194cc365168bc4be4443" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;LONGVARBINARY&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;LONGVARBINARY&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="0b8d6474e6986e84ec72f03d25cbbc2ae7ea156d" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;LONGVARCHAR&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;LONGVARCHAR&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="09e14cc09b2b8c819de78e99f2d1a9aecdf78fe9" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;NCHAR&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;NCHAR&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="1740cd8b83b39847276c4e3c69bd4cf9532bd47a" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;NCLOB&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;NCLOB&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="caf59a1e3d20876f7f01079945e21163f41c17d4" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;NUMERIC&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;NUMERIC&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="8156948aa7428d60e81aa317561caeed6e0a2fe5" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;NVARCHAR&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;NVARCHAR&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="644c208d0f728cefb9962647b49440a9c797b09a" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;REAL&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="82536ef282ecd1282580fe12142330f04432e04c" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;REF&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;REF&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="72a5e67d539cadc8d1c93fe3f769a6e8a6509689" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;REF_CURSOR&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;REF_CURSOR&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="6fb53f3fa45032b92d2b78916761486e60886165" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;SMALLINT&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;SMALLINT&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="dc8aca5ea937fcc007281e4fd111a5f93667ceea" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;SQLXML&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;SQLXML&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="f62701dd7d4c5d444777c4419d6dcb9a129553ef" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;STRUCT&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;STRUCT&lt;/code&gt; 를 식별 합니다 .</target>
        </trans-unit>
        <trans-unit id="c782b926a2a3e80b6574788fc3946edb70e49997" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;TIME&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;TIME&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="a22f0c9396551e5cfc27a65e5ecb0149e108e2a8" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;TIMESTAMP&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;TIMESTAMP&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="b54a9a09860af92b250373d4616d2daa293edc00" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;TIMESTAMP_WITH_TIMEZONE&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;TIMESTAMP_WITH_TIMEZONE&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="d1b919932729232f0663eb4272e21d52a8008234" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;TIME_WITH_TIMEZONE&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;TIME_WITH_TIMEZONE&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="3beb0c5c7419e8ebb83fe992ff37747a6e3a1e2c" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;TINYINT&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;TINYINT&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="effa86850e3c4d5a634962a15ab894536b0b8692" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;VARBINARY&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;VARBINARY&lt;/code&gt; 를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="d260147031f016ef0678c4ff5972d537e30c4c97" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL type &lt;code&gt;VARCHAR&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 유형 &lt;code&gt;VARCHAR&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="f581f7153d160e3dd6da2963700f65ccbd982afa" translate="yes" xml:space="preserve">
          <source>Identifies the generic SQL value &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">일반 SQL 값 &lt;code&gt;NULL&lt;/code&gt; 을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="7e05f5026bfc91b63859bb6497f2a24278a06724" translate="yes" xml:space="preserve">
          <source>Identifies the group the button belongs to -- needed for radio buttons, which are mutually exclusive within their group.</source>
          <target state="translated">버튼이 속한 그룹을 식별합니다. 그룹 내에서 상호 배타적 인 라디오 버튼에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a1242edea0194d8e8f5f67b017524279f59655a9" translate="yes" xml:space="preserve">
          <source>Identifies the header row.</source>
          <target state="translated">헤더 행을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="186a84b67d52316836f8eddb5e60f642b669307c" translate="yes" xml:space="preserve">
          <source>Identifies the horizontal scroll bar policy property.</source>
          <target state="translated">가로 스크롤 막대 정책 속성을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="eedb4d879e4c72f2d8457d04bd9bc34ed419d1a4" translate="yes" xml:space="preserve">
          <source>Identifies the insertion of new rows and/or columns.</source>
          <target state="translated">새 행 및 / 또는 열의 삽입을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f708858734adaf51cedcf1e16105cfc107683560" translate="yes" xml:space="preserve">
          <source>Identifies the leading edge of text for use with left-to-right and right-to-left languages.</source>
          <target state="translated">왼쪽에서 오른쪽 및 오른쪽에서 왼쪽 언어에 사용할 텍스트의 앞쪽 가장자리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="2b0aef1d3dfa0827241b03a41f99044cb99a3077" translate="yes" xml:space="preserve">
          <source>Identifies the leading edge of text for use with left-to-right and right-to-left languages. Used by buttons and labels.</source>
          <target state="translated">왼쪽에서 오른쪽 및 오른쪽에서 왼쪽 언어에 사용할 텍스트의 앞쪽 가장자리를 식별합니다. 버튼과 라벨에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc4b2f6f17ab1fdb531640104ff880af9601d688" translate="yes" xml:space="preserve">
          <source>Identifies the lower leading edge corner of the viewport.</source>
          <target state="translated">뷰포트의 아래쪽 앞 가장자리 모서리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="06825cdfea7f5d81247a155442185743278b6713" translate="yes" xml:space="preserve">
          <source>Identifies the lower leading edge corner of the viewport. The leading edge is determined relative to the Scroll Pane's ComponentOrientation property.</source>
          <target state="translated">뷰포트의 아래쪽 앞 가장자리 모서리를 식별합니다. 앞 가장자리는 Scroll Pane의 ComponentOrientation 속성을 기준으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c29b75411447e432ab405c31450e665b10d10799" translate="yes" xml:space="preserve">
          <source>Identifies the lower left corner of the viewport.</source>
          <target state="translated">뷰포트의 왼쪽 아래 구석을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="1617f8235eb03ce14dd8e145a9d0409bb6e1914d" translate="yes" xml:space="preserve">
          <source>Identifies the lower right corner of the viewport.</source>
          <target state="translated">뷰포트의 오른쪽 아래 구석을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="528576255bd5f81db22e8bb75c000110aef63cd8" translate="yes" xml:space="preserve">
          <source>Identifies the lower trailing edge corner of the viewport.</source>
          <target state="translated">뷰포트의 하단 후행 가장자리 모서리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="6592332ea48942987ad6bf34ba275450d4fd167a" translate="yes" xml:space="preserve">
          <source>Identifies the lower trailing edge corner of the viewport. The trailing edge is determined relative to the Scroll Pane's ComponentOrientation property.</source>
          <target state="translated">뷰포트의 하단 후행 가장자리 모서리를 식별합니다. 후행 가장자리는 Scroll Pane의 ComponentOrientation 속성을 기준으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="08db4777ff8b849d78b546a081b9ae45cccedf2a" translate="yes" xml:space="preserve">
          <source>Identifies the menu item as &quot;armed&quot;.</source>
          <target state="translated">메뉴 항목을 &quot;armed&quot;로 식별합니다.</target>
        </trans-unit>
        <trans-unit id="7f4b1c10c90ab16860e12d755929969a4f86d552" translate="yes" xml:space="preserve">
          <source>Identifies the menu item as &quot;armed&quot;. If the mouse button is released while it is over this item, the menu's action event will fire. If the mouse button is released elsewhere, the event will not fire and the menu item will be disarmed.</source>
          <target state="translated">메뉴 항목을 &quot;armed&quot;로 식별합니다. 이 항목 위에있는 동안 마우스 버튼을 놓으면 메뉴의 작업 이벤트가 발생합니다. 다른 곳에서 마우스 버튼을 놓으면 이벤트가 발생하지 않고 메뉴 항목이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6a082ce45475078db682c126ddf051485f0cdd" translate="yes" xml:space="preserve">
          <source>Identifies the next direction in a sequence.</source>
          <target state="translated">시퀀스에서 다음 방향을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="3213345d95a22bb64185a62fa1ca36fc5e73505d" translate="yes" xml:space="preserve">
          <source>Identifies the previous direction in a sequence.</source>
          <target state="translated">시퀀스에서 이전 방향을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="6e925a017ab7df03e05e4c08209846a13bf25256" translate="yes" xml:space="preserve">
          <source>Identifies the removal of one or more contiguous items from the list</source>
          <target state="translated">목록에서 하나 이상의 연속 항목 제거를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="04dd86e28a61d27421ccc3bb4e6dfecac6133340" translate="yes" xml:space="preserve">
          <source>Identifies the removal of rows or columns.</source>
          <target state="translated">행 또는 열 제거를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="0aebcc8eabde7a219eceaced07db5eeaa6625314" translate="yes" xml:space="preserve">
          <source>Identifies the row of the cell being edited.</source>
          <target state="translated">편집중인 셀의 행을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="279969b040e0c1c9de8cd0eeddd40bfcccacd407" translate="yes" xml:space="preserve">
          <source>Identifies the set of all public members of a class or interface, including inherited members.</source>
          <target state="translated">상속 된 멤버를 포함하여 클래스 또는 인터페이스의 모든 공개 멤버 세트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="760869607fcf6b2f8f6104babf8f7e5d60ecfcbb" translate="yes" xml:space="preserve">
          <source>Identifies the set of declared members of a class or interface.</source>
          <target state="translated">클래스 또는 인터페이스의 선언 된 멤버 집합을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="eb1a3984b1e7f278088af0cc739d40b0ccf92587" translate="yes" xml:space="preserve">
          <source>Identifies the set of declared members of a class or interface. Inherited members are not included.</source>
          <target state="translated">클래스 또는 인터페이스의 선언 된 멤버 집합을 식별합니다. 상속 된 멤버는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6b7392b078e780645e3998074814d989ba71cc6" translate="yes" xml:space="preserve">
          <source>Identifies the trailing edge of text for use with left-to-right and right-to-left languages.</source>
          <target state="translated">왼쪽에서 오른쪽 및 오른쪽에서 왼쪽 언어에 사용할 텍스트의 후행 가장자리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="a43f8ee08fb02ad60ae0fcf89a95877b09e585eb" translate="yes" xml:space="preserve">
          <source>Identifies the trailing edge of text for use with left-to-right and right-to-left languages. Used by buttons and labels.</source>
          <target state="translated">왼쪽에서 오른쪽 및 오른쪽에서 왼쪽 언어에 사용할 텍스트의 후행 가장자리를 식별합니다. 버튼과 라벨에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99f5db1162e314406e4e5dfa507d7827eab15b60" translate="yes" xml:space="preserve">
          <source>Identifies the upper leading edge corner of the viewport.</source>
          <target state="translated">뷰포트의 위쪽 가장자리 모서리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="1e4875e073b3cfa210e69893ca375f6684af6b57" translate="yes" xml:space="preserve">
          <source>Identifies the upper leading edge corner of the viewport. The leading edge is determined relative to the Scroll Pane's ComponentOrientation property.</source>
          <target state="translated">뷰포트의 위쪽 가장자리 모서리를 식별합니다. 앞 가장자리는 Scroll Pane의 ComponentOrientation 속성을 기준으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="20331849bc92a3e903286540eb493261e7c238a9" translate="yes" xml:space="preserve">
          <source>Identifies the upper left corner of the viewport.</source>
          <target state="translated">뷰포트의 왼쪽 위 모서리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="3dd5baaf77bf4f7f82382c1e1051c0e6d1d80908" translate="yes" xml:space="preserve">
          <source>Identifies the upper right corner of the viewport.</source>
          <target state="translated">뷰포트의 오른쪽 상단 모서리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="d9eb36eeb5f69c2faa753bd9d38c0c80e1786d96" translate="yes" xml:space="preserve">
          <source>Identifies the upper trailing edge corner of the viewport.</source>
          <target state="translated">뷰포트의 상단 후행 가장자리 모서리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="9423e84cedf47a58cb807d571058f645143870f3" translate="yes" xml:space="preserve">
          <source>Identifies the upper trailing edge corner of the viewport. The trailing edge is determined relative to the Scroll Pane's ComponentOrientation property.</source>
          <target state="translated">뷰포트의 상단 후행 가장자리 모서리를 식별합니다. 후행 가장자리는 Scroll Pane의 ComponentOrientation 속성을 기준으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f87a5ec7091c6befaf9698907e1ad1f8aa533772" translate="yes" xml:space="preserve">
          <source>Identifies the vertical scroll bar policy property.</source>
          <target state="translated">세로 스크롤 막대 정책 속성을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="87e72ffc3c95b082611843e363f6ac1d46e5c975" translate="yes" xml:space="preserve">
          <source>Identifies user's directory change.</source>
          <target state="translated">사용자의 디렉토리 변경을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="9d6c252095e6713c748c32f9a51e124772a6a357" translate="yes" xml:space="preserve">
          <source>Identifies whether a the AcceptAllFileFilter is used or not.</source>
          <target state="translated">AcceptAllFileFilter가 사용되는지 여부를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c13130ff97a80aba150517b02c5248084a11ac61" translate="yes" xml:space="preserve">
          <source>Identify a font resource of type TRUETYPE.</source>
          <target state="translated">TRUETYPE 유형의 글꼴 자원을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="47760858b09034612c5a65d1b2c3d77bb11e13c5" translate="yes" xml:space="preserve">
          <source>Identify a font resource of type TRUETYPE. Used to specify a TrueType font resource to the &lt;a href=&quot;#createFont(int,java.io.InputStream)&quot;&gt;&lt;code&gt;createFont(int, java.io.InputStream)&lt;/code&gt;&lt;/a&gt; method. The TrueType format was extended to become the OpenType format, which adds support for fonts with Postscript outlines, this tag therefore references these fonts, as well as those with TrueType outlines.</source>
          <target state="translated">TRUETYPE 유형의 글꼴 자원을 식별하십시오. &lt;a href=&quot;#createFont(int,java.io.InputStream)&quot;&gt; &lt;code&gt;createFont(int, java.io.InputStream)&lt;/code&gt; &lt;/a&gt; 메서드에 TrueType 글꼴 리소스를 지정하는 데 사용됩니다 . TrueType 형식은 OpenType 형식으로 확장되어 포스트 스크립트 윤곽선이있는 글꼴에 대한 지원을 추가하므로이 태그는 이러한 글꼴과 TrueType 윤곽선이있는 글꼴을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="30dc4b68edd86300505c95516c62c6e55b0ac0bb" translate="yes" xml:space="preserve">
          <source>Identify a font resource of type TYPE1.</source>
          <target state="translated">TYPE1 유형의 글꼴 자원을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="359d0209cd6f71dfe19c6cb928b19ede972b383b" translate="yes" xml:space="preserve">
          <source>Identify a font resource of type TYPE1. Used to specify a Type1 font resource to the &lt;a href=&quot;#createFont(int,java.io.InputStream)&quot;&gt;&lt;code&gt;createFont(int, java.io.InputStream)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">TYPE1 유형의 글꼴 자원을 식별하십시오. &lt;a href=&quot;#createFont(int,java.io.InputStream)&quot;&gt; &lt;code&gt;createFont(int, java.io.InputStream)&lt;/code&gt; &lt;/a&gt; 메서드에 Type1 글꼴 리소스를 지정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="42c248d3ebfc85ce8bc00d5f353dcd70d64d391c" translate="yes" xml:space="preserve">
          <source>Identities</source>
          <target state="translated">Identities</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="0b0f6a0f64fcafde121508c78eb880d25fff6b54" translate="yes" xml:space="preserve">
          <source>Identity.addCertificate()</source>
          <target state="translated">Identity.addCertificate()</target>
        </trans-unit>
        <trans-unit id="6ea74d1f4045f821b7d0a6d3696620b259fe3497" translate="yes" xml:space="preserve">
          <source>Identity.certificates()</source>
          <target state="translated">Identity.certificates()</target>
        </trans-unit>
        <trans-unit id="c1c3655062b87f1051e4fd09134b18e000061de8" translate="yes" xml:space="preserve">
          <source>Identity.equals()</source>
          <target state="translated">Identity.equals()</target>
        </trans-unit>
        <trans-unit id="faaa351d28829d41d6d30ee90b779a82067052df" translate="yes" xml:space="preserve">
          <source>Identity.getInfo()</source>
          <target state="translated">Identity.getInfo()</target>
        </trans-unit>
        <trans-unit id="a1ba07b3e796d24cb197db9683a305403dca8b24" translate="yes" xml:space="preserve">
          <source>Identity.getName()</source>
          <target state="translated">Identity.getName()</target>
        </trans-unit>
        <trans-unit id="7e06df9d60785c32f9fa9cc12af8f3ce5a0bd36b" translate="yes" xml:space="preserve">
          <source>Identity.getPublicKey()</source>
          <target state="translated">Identity.getPublicKey()</target>
        </trans-unit>
        <trans-unit id="4e3247620e189bd06c4d7d85b8b7a7b3b65edb55" translate="yes" xml:space="preserve">
          <source>Identity.getScope()</source>
          <target state="translated">Identity.getScope()</target>
        </trans-unit>
        <trans-unit id="f6a65fdfc6cfd35d24ccf4396b97e6a57a8b4fe3" translate="yes" xml:space="preserve">
          <source>Identity.hashCode()</source>
          <target state="translated">Identity.hashCode()</target>
        </trans-unit>
        <trans-unit id="31e52c542b2d1364e6c70c9ea2c14d7637efaf28" translate="yes" xml:space="preserve">
          <source>Identity.identityEquals()</source>
          <target state="translated">Identity.identityEquals()</target>
        </trans-unit>
        <trans-unit id="478e7e6a28e330c5310ec2387e8dc67901a7a20c" translate="yes" xml:space="preserve">
          <source>Identity.removeCertificate()</source>
          <target state="translated">Identity.removeCertificate()</target>
        </trans-unit>
        <trans-unit id="4dbdb0d9b5aa198b95bae16d550e5f55b741e668" translate="yes" xml:space="preserve">
          <source>Identity.setInfo()</source>
          <target state="translated">Identity.setInfo()</target>
        </trans-unit>
        <trans-unit id="a16316fad14e99082cd014e6bc3e0ce96639b6bb" translate="yes" xml:space="preserve">
          <source>Identity.setPublicKey()</source>
          <target state="translated">Identity.setPublicKey()</target>
        </trans-unit>
        <trans-unit id="4adaf7d86aa6deaf8025145032c0eba7214267fb" translate="yes" xml:space="preserve">
          <source>Identity.toString()</source>
          <target state="translated">Identity.toString()</target>
        </trans-unit>
        <trans-unit id="055806d9b9778fca80748c4d613ac38948290c00" translate="yes" xml:space="preserve">
          <source>IdentityHashMap</source>
          <target state="translated">IdentityHashMap</target>
        </trans-unit>
        <trans-unit id="713f8c19951c04a5daa1152aa553d7ed32d77d3e" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.clear()</source>
          <target state="translated">IdentityHashMap.clear()</target>
        </trans-unit>
        <trans-unit id="8c070c7c5f42951c49a393954f80385512f9b1e0" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.clone()</source>
          <target state="translated">IdentityHashMap.clone()</target>
        </trans-unit>
        <trans-unit id="96a90590285faa127d72287a45aa55c1e0bc46b3" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.containsKey()</source>
          <target state="translated">IdentityHashMap.containsKey()</target>
        </trans-unit>
        <trans-unit id="733f4ef120f1306bd77fdde589a5d752a4836e00" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.containsValue()</source>
          <target state="translated">IdentityHashMap.containsValue()</target>
        </trans-unit>
        <trans-unit id="c0f330d6932dfba39e84e1584955a4db00ede64c" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.entrySet()</source>
          <target state="translated">IdentityHashMap.entrySet()</target>
        </trans-unit>
        <trans-unit id="6be07b11d503f4af9b5d58ca5b4253be49c7f84e" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.equals()</source>
          <target state="translated">IdentityHashMap.equals()</target>
        </trans-unit>
        <trans-unit id="dae3e2eb70e68c919c0c287c3311e7ccf4c80fed" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.forEach()</source>
          <target state="translated">IdentityHashMap.forEach()</target>
        </trans-unit>
        <trans-unit id="79afac5401c0b0f66bd83b885c5d59e9a3e50a66" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.get()</source>
          <target state="translated">IdentityHashMap.get()</target>
        </trans-unit>
        <trans-unit id="87765b1fdf557f96a1a85007be7576a9f8d4bfa5" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.hashCode()</source>
          <target state="translated">IdentityHashMap.hashCode()</target>
        </trans-unit>
        <trans-unit id="1544072f40ea89d35e6d678e43d3ad3ba40011d3" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.isEmpty()</source>
          <target state="translated">IdentityHashMap.isEmpty()</target>
        </trans-unit>
        <trans-unit id="225b132ff9e5dbc36da9d9d1926cf0048a66b0cd" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.keySet()</source>
          <target state="translated">IdentityHashMap.keySet()</target>
        </trans-unit>
        <trans-unit id="8882eaedfea32a0e13d39c1cc7901474888b9db5" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.put()</source>
          <target state="translated">IdentityHashMap.put()</target>
        </trans-unit>
        <trans-unit id="2e9ed9e2deb69dbb764267b673db74f0077c0c38" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.putAll()</source>
          <target state="translated">IdentityHashMap.putAll()</target>
        </trans-unit>
        <trans-unit id="1ca65aebcd62c9e93f3f356bd43885b60b4b67b3" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.remove()</source>
          <target state="translated">IdentityHashMap.remove()</target>
        </trans-unit>
        <trans-unit id="c3ff19bc854690a18b003e767eba4733c132c871" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.replaceAll()</source>
          <target state="translated">IdentityHashMap.replaceAll()</target>
        </trans-unit>
        <trans-unit id="67441c4570c0198d17c64036002c48723ff1db9a" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.size()</source>
          <target state="translated">IdentityHashMap.size()</target>
        </trans-unit>
        <trans-unit id="f4161f937b9486a8f03e53d96ccbb8e942d78a08" translate="yes" xml:space="preserve">
          <source>IdentityHashMap.values()</source>
          <target state="translated">IdentityHashMap.values()</target>
        </trans-unit>
        <trans-unit id="1e7d4329d8f3f5782817488e54fad55d6ce49ca5" translate="yes" xml:space="preserve">
          <source>IdentityScope</source>
          <target state="translated">IdentityScope</target>
        </trans-unit>
        <trans-unit id="363c8b6dfb6af4e6c2ee54050ae0902a9324c54a" translate="yes" xml:space="preserve">
          <source>IdentityScope.addIdentity()</source>
          <target state="translated">IdentityScope.addIdentity()</target>
        </trans-unit>
        <trans-unit id="33bf28e5acb84614d4449a14c1834ce39a2e8a93" translate="yes" xml:space="preserve">
          <source>IdentityScope.getIdentity()</source>
          <target state="translated">IdentityScope.getIdentity()</target>
        </trans-unit>
        <trans-unit id="eecb98656d916b14d38fe225678b23e99a605a00" translate="yes" xml:space="preserve">
          <source>IdentityScope.getSystemScope()</source>
          <target state="translated">IdentityScope.getSystemScope()</target>
        </trans-unit>
        <trans-unit id="baa5e518befa18000269294ed54f7568738f8112" translate="yes" xml:space="preserve">
          <source>IdentityScope.identities()</source>
          <target state="translated">IdentityScope.identities()</target>
        </trans-unit>
        <trans-unit id="95712e173fbfc4f03c5431e974418ea774b27bdc" translate="yes" xml:space="preserve">
          <source>IdentityScope.removeIdentity()</source>
          <target state="translated">IdentityScope.removeIdentity()</target>
        </trans-unit>
        <trans-unit id="c40ec0d7574e40d356fa3dea6401d406743778ba" translate="yes" xml:space="preserve">
          <source>IdentityScope.setSystemScope()</source>
          <target state="translated">IdentityScope.setSystemScope()</target>
        </trans-unit>
        <trans-unit id="ab6e25a8a5e10b3f2f0298156519cb83b53c7374" translate="yes" xml:space="preserve">
          <source>IdentityScope.size()</source>
          <target state="translated">IdentityScope.size()</target>
        </trans-unit>
        <trans-unit id="9df777ebf16a06cabf53313d962e4eedb98ce4f0" translate="yes" xml:space="preserve">
          <source>IdentityScope.toString()</source>
          <target state="translated">IdentityScope.toString()</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="4dae338ae2b9fef6bd50143f5aeea08c3a588a3e" translate="yes" xml:space="preserve">
          <source>If &quot;CANONICAL&quot; is specified as the format, this method returns an RFC 2253 conformant string representation with the following additional canonicalizations:</source>
          <target state="translated">&quot;CANONICAL&quot;이 형식으로 지정된 경우이 메소드는 다음과 같은 추가 표준화를 사용하여 RFC 2253 준수 문자열 표현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="633424989c4e096f35ed3b0fc7d931c788bac3f8" translate="yes" xml:space="preserve">
          <source>If &quot;RFC1779&quot; is specified as the format, this method emits the attribute type keywords defined in RFC 1779 (CN, L, ST, O, OU, C, STREET). Any other attribute type is emitted as an OID.</source>
          <target state="translated">&quot;RFC1779&quot;가 형식으로 지정된 경우이 메소드는 RFC 1779에 정의 된 속성 유형 키워드 (CN, L, ST, O, OU, C, STREET)를 생성합니다. 다른 속성 유형은 OID로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3ca45018ebba62fdeb3e3b4a1c50c1cc9ffa64a6" translate="yes" xml:space="preserve">
          <source>If &quot;RFC2253&quot; is specified as the format, this method emits the attribute type keywords defined in RFC 2253 (CN, L, ST, O, OU, C, STREET, DC, UID). Any other attribute type is emitted as an OID. Under a strict reading, RFC 2253 only specifies a UTF-8 string representation. The String returned by this method is the Unicode string achieved by decoding this UTF-8 representation.</source>
          <target state="translated">&quot;RFC2253&quot;이 형식으로 지정된 경우이 메소드는 RFC 2253에 정의 된 속성 유형 키워드 (CN, L, ST, O, OU, C, STREET, DC, UID)를 생성합니다. 다른 속성 유형은 OID로 생성됩니다. 엄격한 판독에서 RFC 2253은 UTF-8 문자열 표현 만 지정합니다. 이 메소드에 의해 돌려 주어지는 캐릭터 라인은,이 UTF-8 표현을 디코드함으로써 얻어진 Unicode 캐릭터 라인입니다.</target>
        </trans-unit>
        <trans-unit id="abd2df33fc4ef6bb998cd541a6fa509101894ef5" translate="yes" xml:space="preserve">
          <source>If &quot;java.util.logging.config.class&quot; property is &lt;b&gt;not&lt;/b&gt; set, then the &quot;java.util.logging.config.file&quot; system property can be used to specify a properties file (in java.util.Properties format). The initial logging configuration will be read from this file.</source>
          <target state="translated">&quot;java.util.logging.config.class&quot;특성이 설정 &lt;b&gt;되지 않은&lt;/b&gt; 경우 &quot;java.util.logging.config.file&quot;시스템 특성을 사용하여 특성 파일 (java.util.Properties 형식)을 지정할 수 있습니다. 이 파일에서 초기 로깅 구성을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c4b5bd56bcf23a13a227d6c6904fe4ae0ffaac5f" translate="yes" xml:space="preserve">
          <source>If &quot;java.util.logging.config.class&quot; system property is &lt;b&gt;not&lt;/b&gt; set, then this method will read the initial configuration from a properties file and calls the &lt;a href=&quot;#readConfiguration(java.io.InputStream)&quot;&gt;&lt;code&gt;readConfiguration(InputStream)&lt;/code&gt;&lt;/a&gt; method to initialize the configuration. The &quot;java.util.logging.config.file&quot; system property can be used to specify the properties file that will be read as the initial configuration; if not set, then the LogManager default configuration is used. The default configuration is typically loaded from the properties file &quot;&lt;code&gt;conf/logging.properties&lt;/code&gt;&quot; in the Java installation directory.</source>
          <target state="translated">&quot;java.util.logging.config.class&quot;시스템 속성이 설정 &lt;b&gt;되지 않은&lt;/b&gt; 경우이 메서드는 속성 파일에서 초기 구성을 읽고 &lt;a href=&quot;#readConfiguration(java.io.InputStream)&quot;&gt; &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하여 구성을 초기화합니다. &quot;java.util.logging.config.file&quot;시스템 속성을 사용하여 초기 구성으로 읽을 속성 파일을 지정할 수 있습니다. 설정되지 않은 경우 LogManager 기본 구성이 사용됩니다. 기본 구성은 일반적으로 Java 설치 디렉토리 의 속성 파일 &quot; &lt;code&gt;conf/logging.properties&lt;/code&gt; &quot;에서 로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="be290b8703d48cd7f67a8837cbf1bc5b0b1384ae" translate="yes" xml:space="preserve">
          <source>If (DELTA &amp;gt; 0) we are in expand mode where:</source>
          <target state="translated">(DELTA&amp;gt; 0)이면 확장 모드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1170a9c44bbd28d95723bc52e3c9c0a7d15ba5f" translate="yes" xml:space="preserve">
          <source>If (DELTA &amp;lt; 0) we are in shrink mode where:</source>
          <target state="translated">(DELTA &amp;lt;0)이면 축소 모드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a83d0c326b1b263ede1d6ce2acf5f57596274848" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#UNIX_LINES&quot;&gt;&lt;code&gt;UNIX_LINES&lt;/code&gt;&lt;/a&gt; mode is activated, then the only line terminators recognized are newline characters.</source>
          <target state="translated">만약 &lt;a href=&quot;#UNIX_LINES&quot;&gt; &lt;code&gt;UNIX_LINES&lt;/code&gt; &lt;/a&gt; 모드가 활성화 된인식되는 유일한 줄 종결자는 개행 문자입니다.</target>
        </trans-unit>
        <trans-unit id="e78f618fb982895e323f2a8270ab887366b80a4a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#canReadRaster()&quot;&gt;&lt;code&gt;canReadRaster()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, this method throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#canReadRaster()&quot;&gt; &lt;code&gt;canReadRaster()&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;false&lt;/code&gt; ,이 방법은 발생 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71efcc82ef190899651d4c3646efb25fa325c808" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#closeServer()&quot;&gt;&lt;code&gt;closeServer()&lt;/code&gt;&lt;/a&gt; returns normally but one or more of the individual connections throws an &lt;code&gt;IOException&lt;/code&gt;, then, after closing all the connections, one of those &lt;code&gt;IOException&lt;/code&gt;s is thrown from this method. If more than one connection throws an &lt;code&gt;IOException&lt;/code&gt;, it is unspecified which one is thrown from this method.</source>
          <target state="translated">경우 &lt;a href=&quot;#closeServer()&quot;&gt; &lt;code&gt;closeServer()&lt;/code&gt; &lt;/a&gt; 일반적으로하지만, 하나 이상의 개별 연결을 돌려줍니다 &lt;code&gt;IOException&lt;/code&gt; 이는 , 다음, 모든 연결, 그 중 하나 닫은 후 &lt;code&gt;IOException&lt;/code&gt; 이 들이 방법에서 발생합니다. 둘 이상의 연결에서 &lt;code&gt;IOException&lt;/code&gt; 이 발생 하는 경우 throw하면이 메서드에서 어느 연결이 throw되는지 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="772326f336356f582b8722bde9c43c8722381694" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#closeServer()&quot;&gt;&lt;code&gt;closeServer()&lt;/code&gt;&lt;/a&gt; throws an &lt;code&gt;IOException&lt;/code&gt;, the individual connections are nevertheless closed, and then the &lt;code&gt;IOException&lt;/code&gt; is thrown from this method.</source>
          <target state="translated">경우 &lt;a href=&quot;#closeServer()&quot;&gt; &lt;code&gt;closeServer()&lt;/code&gt; &lt;/a&gt; 발생 &lt;code&gt;IOException&lt;/code&gt; 가 개별 연결 역시 후 폐쇄되고 &lt;code&gt;IOException&lt;/code&gt; 이 이 방법에서 발생한다.</target>
        </trans-unit>
        <trans-unit id="65e7781f5b0657fa71179d9775bc9b7c45120cf9" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#command()&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#arguments()&quot;&gt;&lt;code&gt;arguments()&lt;/code&gt;&lt;/a&gt; return non-empty optionals, this is simply a convenience method which concatenates the values of the two functions separated by spaces. Otherwise it will return a best-effort, platform dependent representation of the command line.</source>
          <target state="translated">if &lt;a href=&quot;#command()&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#arguments()&quot;&gt; &lt;code&gt;arguments()&lt;/code&gt; &lt;/a&gt; 리턴 비어 선택적 항목이 단순히 두 함수의 값이 공백으로 구분 연접하는 편리한 방법이다. 그렇지 않으면 명령 줄의 최선형, 플랫폼 의존적 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ece37854884a00d52ed756d15b60bb9c060c3350" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#hasDynamicLocaleList()&quot;&gt;&lt;code&gt;hasDynamicLocaleList()&lt;/code&gt;&lt;/a&gt; returns true, this method is called each time the information is needed. This gives input methods that depend on network resources the chance to add or remove locales as resources become available or unavailable.</source>
          <target state="translated">&lt;a href=&quot;#hasDynamicLocaleList()&quot;&gt; &lt;code&gt;hasDynamicLocaleList()&lt;/code&gt; &lt;/a&gt; 경우 true를 돌려,이 메소드는 정보가 필요할 때마다 호출됩니다. 이를 통해 네트워크 리소스에 의존하는 입력 방법은 리소스를 사용할 수 있거나 사용할 수 없게 될 때 로케일을 추가하거나 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9290b661461033ed1bc13cb69107504da4f2c89b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#isNotifyOnEDT()&quot;&gt;&lt;code&gt;isNotifyOnEDT()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and called off the</source>
          <target state="translated">경우 &lt;a href=&quot;#isNotifyOnEDT()&quot;&gt; &lt;code&gt;isNotifyOnEDT()&lt;/code&gt; &lt;/a&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 과 중지가</target>
        </trans-unit>
        <trans-unit id="bb7e3afa0c9cff769e2ef4fba8fcdd5c43648f7d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#isSupplementaryCodePoint(int)&quot;&gt;&lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;a href=&quot;#isHighSurrogate(char)&quot;&gt;&lt;code&gt;isHighSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(highSurrogate(x))&lt;/code&gt; and &lt;a href=&quot;#toCodePoint(char,char)&quot;&gt;&lt;code&gt;toCodePoint&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(highSurrogate(x), &lt;/code&gt;&lt;a href=&quot;#lowSurrogate(int)&quot;&gt;&lt;code&gt;lowSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(x)) == x&lt;/code&gt; are also always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#isSupplementaryCodePoint(int)&quot;&gt; &lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;true&lt;/code&gt; , 다음 &lt;a href=&quot;#isHighSurrogate(char)&quot;&gt; &lt;code&gt;isHighSurrogate&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(highSurrogate(x))&lt;/code&gt; 과 &lt;a href=&quot;#toCodePoint(char,char)&quot;&gt; &lt;code&gt;toCodePoint&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(highSurrogate(x), &lt;/code&gt; &lt;a href=&quot;#lowSurrogate(int)&quot;&gt; &lt;code&gt;lowSurrogate&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(x)) == x&lt;/code&gt; 항상 또한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53364ddeaf870e898228ca4dece118f3648e3c77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#isSupplementaryCodePoint(int)&quot;&gt;&lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;a href=&quot;#isLowSurrogate(char)&quot;&gt;&lt;code&gt;isLowSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(lowSurrogate(x))&lt;/code&gt; and &lt;a href=&quot;#toCodePoint(char,char)&quot;&gt;&lt;code&gt;toCodePoint&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;#highSurrogate(int)&quot;&gt;&lt;code&gt;highSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(x), lowSurrogate(x)) == x&lt;/code&gt; are also always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#isSupplementaryCodePoint(int)&quot;&gt; &lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;true&lt;/code&gt; , 다음 &lt;a href=&quot;#isLowSurrogate(char)&quot;&gt; &lt;code&gt;isLowSurrogate&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(lowSurrogate(x))&lt;/code&gt; 과 &lt;a href=&quot;#toCodePoint(char,char)&quot;&gt; &lt;code&gt;toCodePoint&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;#highSurrogate(int)&quot;&gt; &lt;code&gt;highSurrogate&lt;/code&gt; 를&lt;/a&gt; &lt;code&gt;(x), lowSurrogate(x)) == x&lt;/code&gt; 항상 또한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb928076f9e85da10265f97d47af6c1f858474ba" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#setZoneStrings(java.lang.String%5B%5D%5B%5D)&quot;&gt;&lt;code&gt;setZoneStrings&lt;/code&gt;&lt;/a&gt; has been called on this &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance, then the strings provided by that call are returned. Otherwise, the returned array contains names provided by the Java runtime and by installed &lt;a href=&quot;../util/spi/timezonenameprovider&quot;&gt;&lt;code&gt;TimeZoneNameProvider&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">이 &lt;code&gt;DateFormatSymbols&lt;/code&gt; 인스턴스 에서 &lt;a href=&quot;#setZoneStrings(java.lang.String%5B%5D%5B%5D)&quot;&gt; &lt;code&gt;setZoneStrings&lt;/code&gt; &lt;/a&gt; 가 호출 된 경우 해당 호출에서 제공된 문자열이 반환됩니다. 그렇지 않으면 반환 된 배열에는 Java 런타임 및 설치된 &lt;a href=&quot;../util/spi/timezonenameprovider&quot;&gt; &lt;code&gt;TimeZoneNameProvider&lt;/code&gt; &lt;/a&gt; 구현에서 제공 한 이름이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2fb0326651e821be2f35a54b23e7fb99de23aa49" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt;&lt;code&gt;TransformerFactory.getFeature(String name)&lt;/code&gt;&lt;/a&gt; returns true when passed this value as an argument, the Transformer supports Result output of this type.</source>
          <target state="translated">경우 &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt; &lt;code&gt;TransformerFactory.getFeature(String name)&lt;/code&gt; &lt;/a&gt; 이 값을 인수로서 건네 주었을 때에 true를 돌려, Transformer는이 형태의 Result 출력을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c7454b6fcdeaecd8bf32f437095fa39a351ab8b2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt;&lt;code&gt;TransformerFactory.getFeature(String name)&lt;/code&gt;&lt;/a&gt; returns true when passed this value as an argument, the Transformer supports Source input of this type.</source>
          <target state="translated">경우 &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt; &lt;code&gt;TransformerFactory.getFeature(String name)&lt;/code&gt; &lt;/a&gt; 이 값을 인수로서 건네 주었을 때에 true를 돌려, Transformer는이 형태의 Source 입력을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="45a303d890c16446e3f417305a332de9cb02377a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt;&lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt; when passed this value as an argument, the &lt;code&gt;Transformer&lt;/code&gt; supports &lt;code&gt;Result&lt;/code&gt; output of this type.</source>
          <target state="translated">경우 &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt; &lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; 이 값을 인수로서 건네 때 &lt;code&gt;Transformer&lt;/code&gt; 지원 &lt;code&gt;Result&lt;/code&gt; 이러한 유형의 출력을.</target>
        </trans-unit>
        <trans-unit id="8d46649a9c61c5839460d234d1d6732c409a2d26" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt;&lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt;&lt;/a&gt; returns true when passed this value as an argument, the &lt;a href=&quot;#newXMLFilter(javax.xml.transform.Source)&quot;&gt;&lt;code&gt;newXMLFilter(Source src)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#newXMLFilter(javax.xml.transform.Templates)&quot;&gt;&lt;code&gt;newXMLFilter(Templates templates)&lt;/code&gt;&lt;/a&gt; methods are supported.</source>
          <target state="translated">경우 &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt; &lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt; &lt;/a&gt; 이 값을 인수로서 건네 주었을 때에 true를 돌려의 &lt;a href=&quot;#newXMLFilter(javax.xml.transform.Source)&quot;&gt; &lt;code&gt;newXMLFilter(Source src)&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#newXMLFilter(javax.xml.transform.Templates)&quot;&gt; &lt;code&gt;newXMLFilter(Templates templates)&lt;/code&gt; &lt;/a&gt; 방법이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6eed928fc11fb8cba11ac356c2dcff1804896bc5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt;&lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt;&lt;/a&gt; returns true when passed this value as an argument, the Transformer supports Result output of this type.</source>
          <target state="translated">경우 &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt; &lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt; &lt;/a&gt; 이 값을 인수로서 건네 주었을 때에 true를 반환 변압기 지원이 유형의 출력 결과.</target>
        </trans-unit>
        <trans-unit id="31e60d4a882306cd78ca4a7492ef33ba5f716cf7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt;&lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt;&lt;/a&gt; returns true when passed this value as an argument, the Transformer supports Source input of this type.</source>
          <target state="translated">만약 &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt; &lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt; &lt;/a&gt; 이 값을 인수로서 건네 주었을 때에 true를 돌려, Transformer는이 형태의 Source 입력을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="00f3c1a33a8d63656bc37124d61e96005150561a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt;&lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt;&lt;/a&gt; returns true when passed this value as an argument, the TransformerFactory returned from &lt;a href=&quot;../transformerfactory#newInstance()&quot;&gt;&lt;code&gt;TransformerFactory.newInstance()&lt;/code&gt;&lt;/a&gt; may be safely cast to a SAXTransformerFactory.</source>
          <target state="translated">경우 &lt;a href=&quot;../transformerfactory#getFeature(java.lang.String)&quot;&gt; &lt;code&gt;TransformerFactory.getFeature(java.lang.String)&lt;/code&gt; &lt;/a&gt; 인수에서 반환 된 TransformerFactory이 값 전달 된 경우 true를 반환 &lt;a href=&quot;../transformerfactory#newInstance()&quot;&gt; &lt;code&gt;TransformerFactory.newInstance()&lt;/code&gt; &lt;/a&gt; SAXTransformerFactory에 안전하게 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65270733fdd62aa43250eea89ef5a685be9b5185" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;character#isSupplementaryCodePoint-int-&quot;&gt;&lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;a href=&quot;character#isHighSurrogate-char-&quot;&gt;&lt;code&gt;isHighSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(highSurrogate(x))&lt;/code&gt; and &lt;a href=&quot;character#toCodePoint-char-char-&quot;&gt;&lt;code&gt;toCodePoint&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(highSurrogate(x), &lt;/code&gt;&lt;a href=&quot;character#lowSurrogate-int-&quot;&gt;&lt;code&gt;lowSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(x)) == x&lt;/code&gt; are also always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;character#isSupplementaryCodePoint-int-&quot;&gt; &lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;true&lt;/code&gt; , 다음 &lt;a href=&quot;character#isHighSurrogate-char-&quot;&gt; &lt;code&gt;isHighSurrogate&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(highSurrogate(x))&lt;/code&gt; 과 &lt;a href=&quot;character#toCodePoint-char-char-&quot;&gt; &lt;code&gt;toCodePoint&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(highSurrogate(x), &lt;/code&gt; &lt;a href=&quot;character#lowSurrogate-int-&quot;&gt; &lt;code&gt;lowSurrogate&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(x)) == x&lt;/code&gt; 항상 또한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8545235843cd5b34079506fb27dd2164c836bfd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;character#isSupplementaryCodePoint-int-&quot;&gt;&lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;a href=&quot;character#isLowSurrogate-char-&quot;&gt;&lt;code&gt;isLowSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(lowSurrogate(x))&lt;/code&gt; and &lt;a href=&quot;character#toCodePoint-char-char-&quot;&gt;&lt;code&gt;toCodePoint&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;character#highSurrogate-int-&quot;&gt;&lt;code&gt;highSurrogate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(x), lowSurrogate(x)) == x&lt;/code&gt; are also always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;character#isSupplementaryCodePoint-int-&quot;&gt; &lt;code&gt;isSupplementaryCodePoint(x)&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;true&lt;/code&gt; , 다음 &lt;a href=&quot;character#isLowSurrogate-char-&quot;&gt; &lt;code&gt;isLowSurrogate&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(lowSurrogate(x))&lt;/code&gt; 과 &lt;a href=&quot;character#toCodePoint-char-char-&quot;&gt; &lt;code&gt;toCodePoint&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;character#highSurrogate-int-&quot;&gt; &lt;code&gt;highSurrogate&lt;/code&gt; 를&lt;/a&gt; &lt;code&gt;(x), lowSurrogate(x)) == x&lt;/code&gt; 항상 또한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3620e251aca3edeca3496fe35264c59f5537d6f9" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;dateformatsymbols#setZoneStrings-java.lang.String:A:A-&quot;&gt;&lt;code&gt;setZoneStrings&lt;/code&gt;&lt;/a&gt; has been called on this &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance, then the strings provided by that call are returned. Otherwise, the returned array contains names provided by the Java runtime and by installed &lt;a href=&quot;../util/spi/timezonenameprovider&quot;&gt;&lt;code&gt;TimeZoneNameProvider&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">이 &lt;code&gt;DateFormatSymbols&lt;/code&gt; 인스턴스 에서 &lt;a href=&quot;dateformatsymbols#setZoneStrings-java.lang.String:A:A-&quot;&gt; &lt;code&gt;setZoneStrings&lt;/code&gt; &lt;/a&gt; 가 호출 된 경우 해당 호출에서 제공 한 문자열이 리턴됩니다. 그렇지 않으면 반환 된 배열에는 Java 런타임 및 설치된 &lt;a href=&quot;../util/spi/timezonenameprovider&quot;&gt; &lt;code&gt;TimeZoneNameProvider&lt;/code&gt; &lt;/a&gt; 구현에서 제공 한 이름이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="012a4a34353b239237400f96d0b85f099eb12eb9" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;imagereader#canReadRaster--&quot;&gt;&lt;code&gt;canReadRaster()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, this method throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;imagereader#canReadRaster--&quot;&gt; &lt;code&gt;canReadRaster()&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;false&lt;/code&gt; ,이 방법은 발생 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8720024e850dd5509a41495f4288ed56ad7b9bf5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pattern#UNIX_LINES&quot;&gt;&lt;code&gt;UNIX_LINES&lt;/code&gt;&lt;/a&gt; mode is activated, then the only line terminators recognized are newline characters.</source>
          <target state="translated">&lt;a href=&quot;pattern#UNIX_LINES&quot;&gt; &lt;code&gt;UNIX_LINES&lt;/code&gt; &lt;/a&gt; 모드가 활성화 된 경우 인식되는 유일한 줄 종결자는 줄 바꿈 문자입니다.</target>
        </trans-unit>
        <trans-unit id="6ce13f116c496bcb9e3ba0e3dfe9d128f47cc99f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;rmiserverimpl#closeServer--&quot;&gt;&lt;code&gt;closeServer()&lt;/code&gt;&lt;/a&gt; returns normally but one or more of the individual connections throws an &lt;code&gt;IOException&lt;/code&gt;, then, after closing all the connections, one of those &lt;code&gt;IOException&lt;/code&gt;s is thrown from this method. If more than one connection throws an &lt;code&gt;IOException&lt;/code&gt;, it is unspecified which one is thrown from this method.</source>
          <target state="translated">경우 &lt;a href=&quot;rmiserverimpl#closeServer--&quot;&gt; &lt;code&gt;closeServer()&lt;/code&gt; &lt;/a&gt; 일반적으로하지만, 하나 이상의 개별 연결을 돌려줍니다 &lt;code&gt;IOException&lt;/code&gt; 이는 , 다음, 모든 연결, 그 중 하나 닫은 후 &lt;code&gt;IOException&lt;/code&gt; 이 들이 방법에서 발생합니다. 둘 이상의 연결에서 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면이 메소드에서 어떤 연결이 throw 되는지 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b978ee312f37db78ada9f7138437d69f3b7381a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;rmiserverimpl#closeServer--&quot;&gt;&lt;code&gt;closeServer()&lt;/code&gt;&lt;/a&gt; throws an &lt;code&gt;IOException&lt;/code&gt;, the individual connections are nevertheless closed, and then the &lt;code&gt;IOException&lt;/code&gt; is thrown from this method.</source>
          <target state="translated">경우 &lt;a href=&quot;rmiserverimpl#closeServer--&quot;&gt; &lt;code&gt;closeServer()&lt;/code&gt; &lt;/a&gt; 발생 &lt;code&gt;IOException&lt;/code&gt; 가 개별 연결 그럼에도 폐쇄하고 &lt;code&gt;IOException&lt;/code&gt; 이는 이 방법에서 발생한다.</target>
        </trans-unit>
        <trans-unit id="3abf10012265dcdcfca3e662bc4a4be5033c55ff" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;[member type definition]&lt;/b&gt; exists:</source>
          <target state="translated">만약 &lt;b&gt;[부재 타입 정의]&lt;/b&gt; 존재 :</target>
        </trans-unit>
        <trans-unit id="a8d4cdfe7c119d32b6dcb6d3394722e8eb16ea7e" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;button 2&lt;/b&gt; is released first, the &lt;code&gt;MOUSE_RELEASED&lt;/code&gt;/&lt;code&gt;MOUSE_CLICKED&lt;/code&gt; pair for &lt;code&gt;BUTTON2_MASK&lt;/code&gt; arrives first, followed by the pair for &lt;code&gt;BUTTON1_MASK&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;b&gt;버튼 (2)이&lt;/b&gt; 먼저 해제되어 상기 &lt;code&gt;MOUSE_RELEASED&lt;/code&gt; / &lt;code&gt;MOUSE_CLICKED&lt;/code&gt; 에 대한 쌍 &lt;code&gt;BUTTON2_MASK&lt;/code&gt; 을 위한 한 쌍의 이어 제 도착 &lt;code&gt;BUTTON1_MASK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea42aa471fba70c8c5b879eed0b11a81d33d9730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'('&lt;/code&gt;, &lt;code&gt;' '&lt;/code&gt;, &lt;code&gt;'+'&lt;/code&gt;, or &lt;code&gt;','&lt;/code&gt; flags are given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'('&lt;/code&gt; , &lt;code&gt;' '&lt;/code&gt; , &lt;code&gt;'+'&lt;/code&gt; , 또는 &lt;code&gt;','&lt;/code&gt; 플래그는 다음 주어진 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="72cf99edd0149e99bab38b3d6d6fbd948dc81740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'('&lt;/code&gt;, &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt;, &lt;code&gt;'+'&lt;/code&gt;, or &lt;code&gt;','&lt;/code&gt; flags are given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">만약 &lt;code&gt;'('&lt;/code&gt; , &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; , &lt;code&gt;'+'&lt;/code&gt; , 또는 &lt;code&gt;','&lt;/code&gt; 플래그는 다음 주어진 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="7eeb89ae73822389cade1b0807bea11839e3a1ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'('&lt;/code&gt;, &lt;code&gt;'+'&lt;/code&gt;, ' ', or &lt;code&gt;','&lt;/code&gt; flags are given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'('&lt;/code&gt; , &lt;code&gt;'+'&lt;/code&gt; , '', 또는 &lt;code&gt;','&lt;/code&gt; 플래그는 다음 부여되는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="9a750ec5d14dc374b103aa1249376aa5622bf85d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is not symbolically accessible from the lookup class's loader, the lookup can still succeed, even when there is no equivalent Java expression or bytecoded constant.</source>
          <target state="translated">경우 &lt;code&gt;C&lt;/code&gt; 가 조회 클래스의 로더에서 상징적으로 액세스 할 수 없습니다, 조회는 여전히 해당하는 Java 표현식 또는 bytecoded 일정이 경우에도 성공할 수 없다.</target>
        </trans-unit>
        <trans-unit id="c22cabf75bf63e32ee6f7bf21ab4e81e3f070b6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Connection.getTypeMap&lt;/code&gt; does not throw a &lt;code&gt;SQLFeatureNotSupportedException&lt;/code&gt;, then when a column contains a structured or distinct value, the behavior of this method is as if it were a call to: &lt;code&gt;getObject(columnIndex,
 this.getStatement().getConnection().getTypeMap())&lt;/code&gt;. If &lt;code&gt;Connection.getTypeMap&lt;/code&gt; does throw a &lt;code&gt;SQLFeatureNotSupportedException&lt;/code&gt;, then structured values are not supported, and distinct values are mapped to the default Java class as determined by the underlying SQL type of the DISTINCT type.</source>
          <target state="translated">경우 &lt;code&gt;Connection.getTypeMap&lt;/code&gt; 가 던져 않는 &lt;code&gt;SQLFeatureNotSupportedException&lt;/code&gt; , 열이 구성 또는 고유 값을 포함하는 다음 때,이 방식의 문제는 호출 것처럼이다 &lt;code&gt;getObject(columnIndex, this.getStatement().getConnection().getTypeMap())&lt;/code&gt; . 경우 &lt;code&gt;Connection.getTypeMap&lt;/code&gt; 가 던져 않는 &lt;code&gt;SQLFeatureNotSupportedException&lt;/code&gt; , 다음 구성 값은 지원되지 않으며, 구별 유형의 기본 SQL 유형에 의해 결정되는 고유 값은 기본 Java 클래스에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="3c21bf137499e0118aff96e76a6afb91441eb454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Cursor&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; no exception is thrown and the default drag cursor behavior is activated for this drag operation.</source>
          <target state="translated">경우 &lt;code&gt;Cursor&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 예외가 발생되지 않고 디폴트의 드래그 커서의 동작이 드래그 조작을 위해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e669d963990128b93e38d67205209583419f0b76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DragGestureEvent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;DragGestureEvent&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="2cc16da218aeec80b9faf3af3f5a2ccbfcd47a24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DragSourceContextPeer&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;DragSourceContextPeer&lt;/code&gt; 를가 이다 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="342d9167035ad1f34d894ef2cf294f94594d6f3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DragSourceListener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; no exception is thrown.</source>
          <target state="translated">경우 &lt;code&gt;DragSourceListener&lt;/code&gt; 를이 인 &lt;code&gt;null&lt;/code&gt; 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad564b0bb08d01c04970b6289af857200ce5d3cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Image&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; no exception is thrown.</source>
          <target state="translated">경우 &lt;code&gt;Image&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07b1dec93404026e340cb746fe1d54f79e42ea62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Image&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; and the offset is &lt;code&gt;null NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;Image&lt;/code&gt; 아닌 &lt;code&gt;null&lt;/code&gt; 오프셋입니다 &lt;code&gt;null NullPointerException&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="404a461e2c575d8e7a6469633b8caf8b2dcca973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InternationalFormatter&lt;/code&gt; is configured to only allow valid values (&lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;), every valid edit will result in the text of the &lt;code&gt;JFormattedTextField&lt;/code&gt; being completely reset from the &lt;code&gt;Format&lt;/code&gt;. The cursor position will also be adjusted as literal characters are added/removed from the resulting String.</source>
          <target state="translated">&lt;code&gt;InternationalFormatter&lt;/code&gt; 가 유효한 값 ( &lt;code&gt;setAllowsInvalid(false)&lt;/code&gt; ) 만 허용하도록 구성된 경우 모든 유효한 편집은 &lt;code&gt;JFormattedTextField&lt;/code&gt; 의 텍스트가 &lt;code&gt;Format&lt;/code&gt; 에서 완전히 재설정됩니다 . 결과 문자열에서 리터럴 문자가 추가 / 제거 될 때 커서 위치도 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="98dd4adde63200410c7fe1c5e173af2007b8e15c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the password parameter will also be &lt;code&gt;null&lt;/code&gt;. Otherwise the &lt;code&gt;KeyStore.ProtectionParameter&lt;/code&gt; of &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt; must be either a &lt;code&gt;KeyStore.PasswordProtection&lt;/code&gt; or a &lt;code&gt;KeyStore.CallbackHandlerProtection&lt;/code&gt; that supports &lt;code&gt;PasswordCallback&lt;/code&gt; so that the password parameter can be extracted. If the &lt;code&gt;KeyStore.ProtectionParameter&lt;/code&gt; is neither of those classes then a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; is thrown.</source>
          <target state="translated">만약 &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt; 이 있다 &lt;code&gt;null&lt;/code&gt; 다음 암호 매개 변수는있을 것 &lt;code&gt;null&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;KeyStore.ProtectionParameter&lt;/code&gt; 의 &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt; 는 이어야합니다 &lt;code&gt;KeyStore.PasswordProtection&lt;/code&gt; 또는 &lt;code&gt;KeyStore.CallbackHandlerProtection&lt;/code&gt; 지원하는 것을 &lt;code&gt;PasswordCallback&lt;/code&gt; 의 암호 매개 변수를 추출 할 수 있도록. 경우 &lt;code&gt;KeyStore.ProtectionParameter&lt;/code&gt; 이 있다 이러한 클래스의도는 다음 &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d2cc398b4306bef500f8237a19b749b6bcbc8d23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListResourceBundle&lt;/code&gt; or &lt;code&gt;PropertyResourceBundle&lt;/code&gt; do not suit your needs, you can write your own &lt;code&gt;ResourceBundle&lt;/code&gt; subclass. Your subclasses must override two methods: &lt;code&gt;handleGetObject&lt;/code&gt; and &lt;code&gt;getKeys()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ListResourceBundle&lt;/code&gt; 또는 &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 는이 사용자의 요구에 적합하지 않은, 당신은 당신의 자신 쓸 수 &lt;code&gt;ResourceBundle&lt;/code&gt; 서브 클래스를. 서브 클래스는 &lt;code&gt;handleGetObject&lt;/code&gt; 및 &lt;code&gt;getKeys()&lt;/code&gt; 두 메소드를 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="19986d39095a906f212f7d5b0880993833e0d2d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than &lt;code&gt;M&lt;/code&gt;, perform the following checks and actions to shorten the logical argument list:</source>
          <target state="translated">경우 &lt;code&gt;N&lt;/code&gt; 은 보다 큰 &lt;code&gt;M&lt;/code&gt; 은 다음 수표 작업 논리 인수 목록을 단축 수행</target>
        </trans-unit>
        <trans-unit id="935835d2737aeb04ed15a1c0f755b84619f5b469" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Statement.executeLargeBatch&lt;/code&gt; method is invoked it is recommended that &lt;code&gt;getLargeUpdateCounts&lt;/code&gt; be called instead of &lt;code&gt;getUpdateCounts&lt;/code&gt; in order to avoid a possible overflow of the integer update count.</source>
          <target state="translated">경우 &lt;code&gt;Statement.executeLargeBatch&lt;/code&gt; 의 방법은 호출이하는 것이 좋습니다 &lt;code&gt;getLargeUpdateCounts&lt;/code&gt; 가 대신 호출 할 &lt;code&gt;getUpdateCounts&lt;/code&gt; 정수 갱신 카운트의 가능한 오버 플로우를 방지하기 위해.</target>
        </trans-unit>
        <trans-unit id="ae944b060ac36332df795905a98cd54ca172deed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Transferable&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;Transferable&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0e9c0a6d7916cd7df894cc4e4ebfb70e6dafa12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;aComponent&lt;/code&gt; is a &lt;code&gt;JComponent&lt;/code&gt; with a &lt;code&gt;JComponent.WHEN_FOCUSED&lt;/code&gt;&lt;code&gt;InputMap&lt;/code&gt; that is neither &lt;code&gt;null&lt;/code&gt; nor empty, returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;aComponent&lt;/code&gt; 의이 A는 &lt;code&gt;JComponent&lt;/code&gt; 의 A를 &lt;code&gt;JComponent.WHEN_FOCUSED&lt;/code&gt; &lt;code&gt;InputMap&lt;/code&gt; 도 아닌 &lt;code&gt;null&lt;/code&gt; 나 비어, 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a4dbd2384da6b5613acd40d7abd9de5eb93c363" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;aComponent&lt;/code&gt; is an instance of &lt;code&gt;JComboBox&lt;/code&gt;, then returns the value of &lt;code&gt;aComponent.getUI().isFocusTraversable(aComponent)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;aComponent&lt;/code&gt; 의 인스턴스 &lt;code&gt;JComboBox&lt;/code&gt; 에 , 다음의 값 반환 &lt;code&gt;aComponent.getUI().isFocusTraversable(aComponent)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae4cc07da39e229fe02aafbd9bcda878e1f082aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;aComponent&lt;/code&gt; is an instance of &lt;code&gt;JTable&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;aComponent&lt;/code&gt; 의 인스턴스 &lt;code&gt;JTable&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f39db4019e1b54a9fab13c1a8a821a89eba4afd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addEdit&lt;/code&gt; returns false &lt;code&gt;replaceEdit&lt;/code&gt; is called on the new edit with the current edit passed in as the argument. This is the inverse of &lt;code&gt;addEdit&lt;/code&gt; &amp;mdash; if the new edit returns true from &lt;code&gt;replaceEdit&lt;/code&gt;, the new edit replaces the current edit.</source>
          <target state="translated">경우 &lt;code&gt;addEdit&lt;/code&gt; 의 false를 반환 &lt;code&gt;replaceEdit&lt;/code&gt; 는 인수로 전달 된 현재 편집과 새로운 편집 호출됩니다. 이것은 &lt;code&gt;addEdit&lt;/code&gt; 의 반대입니다 . 새 편집이 &lt;code&gt;replaceEdit&lt;/code&gt; 에서 true를 반환 하면 새 편집이 현재 편집을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0c0884131e4907911693caac0e27601b51588c81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;anObject&lt;/code&gt; is</source>
          <target state="translated">경우 &lt;code&gt;anObject&lt;/code&gt; 를가 있다</target>
        </trans-unit>
        <trans-unit id="5ffca39545d24e1d7920cc8116cb0da5e9c4e9ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;attributes&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new &lt;code&gt;Font&lt;/code&gt; is initialized with default values.</source>
          <target state="translated">경우 &lt;code&gt;attributes&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 새로운 &lt;code&gt;Font&lt;/code&gt; 기본값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="a0434246c444d50c0f52a07a8946c3257869e693" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;authorityKeyID&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded value corresponding to the contents of the extension value (not including the object identifier, criticality setting, and encapsulating OCTET STRING) for an AuthorityKeyIdentifier extension. The ASN.1 notation for this structure follows.</source>
          <target state="translated">&lt;code&gt;authorityKeyID&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 AuthorityKeyIdentifier 확장에 대한 확장 값의 내용 (개체 식별자, 중요도 설정 및 OCTET STRING 캡슐화 제외)에 해당하는 단일 DER 인코딩 값이 포함되어야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ae4986c4460a5ebb1bbee1c90a680c389e1bb9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 는 이다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="21e86457236cd9a3d8817e8cd34e957152d8c15b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;b.length&lt;/code&gt; is zero, then no bytes are read. Otherwise, the first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. If an exception is thrown from this method, then it may be that some but not all bytes of &lt;code&gt;b&lt;/code&gt; have been updated with data from the input stream.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 는 이다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다. 경우 &lt;code&gt;b.length&lt;/code&gt; 를가 제로, 다음 바이트를 읽을하지 않습니다. 그렇지 않으면, 첫번째 바이트의 판독 소자에 저장된 &lt;code&gt;b[0]&lt;/code&gt; , 다음으로 하나 &lt;code&gt;b[1]&lt;/code&gt; 그래서, 및. 이 메소드에서 예외가 발생하면, &lt;code&gt;b&lt;/code&gt; 의 일부 바이트가 아닌 일부 가 입력 스트림의 데이터로 갱신 된 것일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82242ce2dcd2406c65038894f40a74a74e10c4fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;off&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off+len&lt;/code&gt; is greater than the length of the array &lt;code&gt;b&lt;/code&gt;, then an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown. If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read. Otherwise, the first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read is, at most, equal to &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 는 이다 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다. 경우 &lt;code&gt;off&lt;/code&gt; 음수 또는 &lt;code&gt;len&lt;/code&gt; 음수 또는 &lt;code&gt;off+len&lt;/code&gt; 어레이의 길이보다 큰 경우 &lt;code&gt;b&lt;/code&gt; , 다음 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 발생된다. 경우 &lt;code&gt;len&lt;/code&gt; 제로, 다음 바이트를 읽을하지 않습니다. 그렇지 않으면, 첫번째 바이트의 판독 소자에 저장된다 &lt;code&gt;b[off]&lt;/code&gt; 에, 다음 중 하나를 &lt;code&gt;b[off+1]&lt;/code&gt; , 등. 읽은 바이트 수는 최대 &lt;code&gt;len&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ab0ddd3d3685dccd379b30ef43efacf18a61b24e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, sets palette icons.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 는 것입니다 &lt;code&gt;true&lt;/code&gt; , 세트 아이콘 팔레트.</target>
        </trans-unit>
        <trans-unit id="b074080c1d245e1b6646c58148e3f07e7034e1a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is null, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 는 null 인하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다. &lt;code&gt;b&lt;/code&gt; 의 길이 가 0이면 바이트를 읽지 않고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 적어도 1 바이트를 읽으려고 시도합니다. 스트림이 파일의 끝에 있기 때문에 사용 가능한 바이트가 없으면 값 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 적어도 하나의 바이트를 읽고 &lt;code&gt;b&lt;/code&gt; 에 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="aa3df66e6030f152b16b8b265b1c6de9bd0b49be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bounds&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, accept bounds supplied by the system. If non-&lt;code&gt;null&lt;/code&gt; you can override some of the system supplied values while accepting others by setting those fields you want to accept from system to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;bounds&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 시스템에 의해 공급 범위에 동의합니다. &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 시스템에서 허용하려는 필드를 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 로 설정하여 시스템 제공 값 중 일부를 무시하고 다른 값을 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c263dd49a555ae8cc4e42c809ded8d859be194a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is the &lt;code&gt;JOptionPane&lt;/code&gt; the receiver is contained in, the preferred size that is returned is the maximum of the preferred size of the &lt;code&gt;LayoutManager&lt;/code&gt; for the &lt;code&gt;JOptionPane&lt;/code&gt;, and &lt;code&gt;getMinimumOptionPaneSize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 수신자가 포함 된 &lt;code&gt;JOptionPane&lt;/code&gt; 인 경우 리턴되는 선호 크기 는 &lt;code&gt;JOptionPane&lt;/code&gt; 및 &lt;code&gt;getMinimumOptionPaneSize&lt;/code&gt; 에 대한 &lt;code&gt;LayoutManager&lt;/code&gt; 의 선호 크기의 최대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6238ba66fb71e08c402b5cfcf99a20d3798ba64b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt;'s parent is not a &lt;code&gt;CellRendererPane&lt;/code&gt;, a new &lt;code&gt;CellRendererPane&lt;/code&gt; is created, &lt;code&gt;c&lt;/code&gt; is added to it, and the &lt;code&gt;CellRendererPane&lt;/code&gt; is added to &lt;code&gt;p&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt;'s parent is a &lt;code&gt;CellRendererPane&lt;/code&gt; and the &lt;code&gt;CellRendererPane&lt;/code&gt;s parent is not &lt;code&gt;p&lt;/code&gt;, it is added to &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 의 부모가 아닌 &lt;code&gt;CellRendererPane&lt;/code&gt; 의 새로운 &lt;code&gt;CellRendererPane&lt;/code&gt; 의가 생성되고, &lt;code&gt;c&lt;/code&gt; 여기에 추가되고 &lt;code&gt;CellRendererPane&lt;/code&gt; 의이 추가됩니다 &lt;code&gt;p&lt;/code&gt; . 경우 &lt;code&gt;c&lt;/code&gt; 의 부모가있다 &lt;code&gt;CellRendererPane&lt;/code&gt; 의은 과 &lt;code&gt;CellRendererPane&lt;/code&gt; 의 부모가 아닌 &lt;code&gt;p&lt;/code&gt; , 그것은 추가됩니다 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2675390c8288f1c4183082124ca397aad9ad3c27" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canInsertEmpty(imageIndex)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canInsertEmpty(imageIndex)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="7151989edd5727743e92fe06833dc2c71dbf1c43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canInsertImage(imageIndex)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canInsertImage(imageIndex)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="8cf48012372f187bb754c28dc9c707889224506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canOffsetTiles&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then the &lt;code&gt;tileGridXOffset&lt;/code&gt; and &lt;code&gt;tileGridYOffset&lt;/code&gt; parameters must be zero.</source>
          <target state="translated">경우 &lt;code&gt;canOffsetTiles&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; , 다음 &lt;code&gt;tileGridXOffset&lt;/code&gt; 와 &lt;code&gt;tileGridYOffset&lt;/code&gt; 매개 변수가 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6ef90a3f0620689c0190d90d57383f7c72fa3f81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canRemoveImage(imageIndex)&lt;/code&gt; returns false, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canRemoveImage(imageIndex)&lt;/code&gt; false를 반환 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="131c53ffd8cea0e4696d724ad0d0b0d332584bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canRemoveImage(imageIndex)&lt;/code&gt; returns false, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canRemoveImage(imageIndex)&lt;/code&gt; false를 반환 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="02a850ece86159de397bc5c898179b444eb7af75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canReplaceImageMetadata(imageIndex)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canReplaceImageMetadata(imageIndex)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="d25817283a6baae65b3ec58084670fa5869de866" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canReplacePixels&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canReplacePixels&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; , 그리고 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="a3238e19962e0a1997d962077704181eb94f1170" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canReplaceStreamMetadata&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canReplaceStreamMetadata&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="dc5e822bd2cf172adb0973609c29e090ffc04190" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canWriteEmpty()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canWriteEmpty()&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="6521717d79941f992534e2eb4c5b1a5d830f9bf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canWriteEmpty&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;canWriteEmpty&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="3d959168f33e335af899036fd5788e3aa5701067" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canWriteRasters&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOImage&lt;/code&gt; may contain a &lt;code&gt;Raster&lt;/code&gt; source. Otherwise, it must contain a &lt;code&gt;RenderedImage&lt;/code&gt; source.</source>
          <target state="translated">경우 &lt;code&gt;canWriteRasters&lt;/code&gt; 의 반환 &lt;code&gt;true&lt;/code&gt; 의 &lt;code&gt;IIOImage&lt;/code&gt; 를이 포함 할 수 &lt;code&gt;Raster&lt;/code&gt; 소스를. 그렇지 않으면 &lt;code&gt;RenderedImage&lt;/code&gt; 소스를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2289fa9b502b199c4fcc80b75fb2215fa5267c24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canWriteSequence&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;writeToSequence&lt;/code&gt; and &lt;code&gt;endWriteSequence&lt;/code&gt; will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;canWriteSequence&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;writeToSequence&lt;/code&gt; 및 &lt;code&gt;endWriteSequence&lt;/code&gt; 는 발생합니다 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가를 .</target>
        </trans-unit>
        <trans-unit id="b447acaf9f7c8dcdc76e9db3f30272946e988621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;canWriteSequence&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, this method will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;canWriteSequence&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 돌려주는 경우 ,이 메소드는 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="2a9184b5c2aa2da13bb7f1d1ed8e7e6060888116" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cause&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;cause&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="8ada8ee35a7cd5bc5cd75a312b4c8e9972dc43c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cd&lt;/code&gt; does not contain this attribute, the &lt;code&gt;LockInfo&lt;/code&gt; object will be constructed from the value of the &lt;code&gt;lockName&lt;/code&gt; attribute.</source>
          <target state="translated">경우 &lt;code&gt;cd&lt;/code&gt; 이 속성을 포함하지 않는의 &lt;code&gt;LockInfo&lt;/code&gt; 의 객체의 값으로 구성됩니다 &lt;code&gt;lockName&lt;/code&gt; 의 속성.</target>
        </trans-unit>
        <trans-unit id="bf887bb96afb0aa59ad2aae60bab1721c5d207f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cd&lt;/code&gt; does not contain this attribute, this attribute will be set to an empty array.</source>
          <target state="translated">경우 &lt;code&gt;cd&lt;/code&gt; 이 속성을 포함하지 않는,이 속성은 빈 배열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="812ad9de22a73d6ca9f245c43ac636f16a671009" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;close&lt;/code&gt; has already been called successfully on this object, calling it again has no effect. If &lt;code&gt;close&lt;/code&gt; has never been called, or if it was called but produced an exception, an attempt will be made to close the connection. This attempt can succeed, in which case &lt;code&gt;close&lt;/code&gt; will return normally, or it can generate an exception.</source>
          <target state="translated">경우 &lt;code&gt;close&lt;/code&gt; 이미이 객체에 성공적으로 호출 된, 다시 호출하면 아무 효과가 없습니다. 경우 &lt;code&gt;close&lt;/code&gt; 불려 가지 않은 그 호출에 대해서 예외가 생성되었을 경우, 또는 시도가 연결을 종료하게됩니다. 이 시도는 성공할 수 있으며,이 경우 &lt;code&gt;close&lt;/code&gt; 는 정상적으로 리턴되거나 예외를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a1147b5d21ae2e7ca580654a0c59d07ed3bbd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;com.example.impl.StandardCodecs&lt;/code&gt; is an implementation of the &lt;code&gt;CodecSet&lt;/code&gt; service then its jar file also contains a file named</source>
          <target state="translated">경우 &lt;code&gt;com.example.impl.StandardCodecs&lt;/code&gt; 이 의 구현입니다 &lt;code&gt;CodecSet&lt;/code&gt; 의 서비스는 다음의 jar 파일도라는 이름의 파일이 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8b84890e8f8a46b3708d293c656fc550b2c37ad1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; is not in the &lt;code&gt;GridBagLayout&lt;/code&gt;, a set of default &lt;code&gt;GridBagConstraints&lt;/code&gt; are returned. A &lt;code&gt;comp&lt;/code&gt; value of &lt;code&gt;null&lt;/code&gt; is invalid and returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;comp&lt;/code&gt; 에없는 &lt;code&gt;GridBagLayout&lt;/code&gt; 에 기본 세트 &lt;code&gt;GridBagConstraints&lt;/code&gt; 반환됩니다. &lt;code&gt;comp&lt;/code&gt; 의 값이 &lt;code&gt;null&lt;/code&gt; 무효이며, 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd7ff993d2281047c4a2ada3938e892ca27ff483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;component&lt;/code&gt; is not a child of the &lt;code&gt;Container&lt;/code&gt; this &lt;code&gt;GroupLayout&lt;/code&gt; is managing, it will be added to the &lt;code&gt;Container&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;component&lt;/code&gt; 의 아이가 아닌 &lt;code&gt;Container&lt;/code&gt; 이 &lt;code&gt;GroupLayout&lt;/code&gt; 가 관리하고, 그것은 추가됩니다 &lt;code&gt;Container&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64ca2ca06cfca94fd9c82cd4417d0dcb8fcf16c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; is not a &lt;code&gt;ComponentInputMap&lt;/code&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Similarly, if &lt;code&gt;condition&lt;/code&gt; is not one of the values listed, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;condition&lt;/code&gt; 입니다 &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; 및 &lt;code&gt;map&lt;/code&gt; 하지 않은 것입니다 &lt;code&gt;ComponentInputMap&lt;/code&gt; 는 , &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다. 마찬가지로 &lt;code&gt;condition&lt;/code&gt; 이 나열된 값 중 하나가 아닌 경우 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92a777126fff87fc6575840ceb6f43f1af8bf701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;connect&lt;/code&gt; has already been called successfully on this object, calling it again has no effect. If, however, &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; was called after &lt;code&gt;connect&lt;/code&gt;, the new &lt;code&gt;connect&lt;/code&gt; will throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;connect&lt;/code&gt; 이미 다시 호출하면 아무런 효과가 없습니다,이 객체에 성공적으로 불려왔다. 그러나 &lt;code&gt;connect&lt;/code&gt; 후에 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 가 호출 되면 새 &lt;code&gt;connect&lt;/code&gt; 은 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ee84e6720c3161c6d7cb8dc3ad7c925084b52e84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;connect&lt;/code&gt; has already been called successfully on this object, calling it again has no effect. If, however, &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnector#close()&quot;&gt;&lt;code&gt;JMXConnector.close()&lt;/code&gt;&lt;/a&gt; was called after &lt;code&gt;connect&lt;/code&gt;, the new &lt;code&gt;connect&lt;/code&gt; will throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;connect&lt;/code&gt; 이미 다시 호출하면 아무런 효과가 없습니다,이 객체에 성공적으로 불려왔다. 그러나, 경우 &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnector#close()&quot;&gt; &lt;code&gt;JMXConnector.close()&lt;/code&gt; &lt;/a&gt; 이후에 호출 된 &lt;code&gt;connect&lt;/code&gt; , 새로운 &lt;code&gt;connect&lt;/code&gt; 발생합니다 &lt;code&gt;IOException&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="f4f3e05fefcfe0a00e4807cbf6116adda73d0128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;connect&lt;/code&gt; has already been called successfully on this object, calling it again has no effect. If, however, &lt;a href=&quot;../jmxconnector#close--&quot;&gt;&lt;code&gt;JMXConnector.close()&lt;/code&gt;&lt;/a&gt; was called after &lt;code&gt;connect&lt;/code&gt;, the new &lt;code&gt;connect&lt;/code&gt; will throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;connect&lt;/code&gt; 이미 다시 호출하면 아무런 효과가 없습니다,이 객체에 성공적으로 불려왔다. 그러나, 경우 &lt;a href=&quot;../jmxconnector#close--&quot;&gt; &lt;code&gt;JMXConnector.close()&lt;/code&gt; &lt;/a&gt; 이후에 호출 된 &lt;code&gt;connect&lt;/code&gt; , 새로운 &lt;code&gt;connect&lt;/code&gt; 발생합니다 &lt;code&gt;IOException&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="224e6e3c9c9ab5ea85db23541af55fdf9a95fbf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;connect&lt;/code&gt; has already been called successfully on this object, calling it again has no effect. If, however, &lt;a href=&quot;jmxconnector#close--&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; was called after &lt;code&gt;connect&lt;/code&gt;, the new &lt;code&gt;connect&lt;/code&gt; will throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;connect&lt;/code&gt; 이미 다시 호출하면 아무런 효과가 없습니다,이 객체에 성공적으로 불려왔다. 그러나 &lt;code&gt;connect&lt;/code&gt; 후에 &lt;a href=&quot;jmxconnector#close--&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 가 호출 되면 새 &lt;code&gt;connect&lt;/code&gt; 에서 &lt;code&gt;IOException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bf6be8a4a637ba85e059625467587617880d83be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;connected&lt;/code&gt; is false, the returned &lt;code&gt;Sequencer&lt;/code&gt; instance is not connected, it has no open &lt;code&gt;Transmitters&lt;/code&gt;. In order to play the sequencer on a MIDI device, or a &lt;code&gt;Synthesizer&lt;/code&gt;, it is necessary to get a &lt;code&gt;Transmitter&lt;/code&gt; and set its &lt;code&gt;Receiver&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;connected&lt;/code&gt; 거짓, 반환 된 &lt;code&gt;Sequencer&lt;/code&gt; 인스턴스가 열린이 없습니다, 연결되어 있지 &lt;code&gt;Transmitters&lt;/code&gt; . MIDI 장치 또는 &lt;code&gt;Synthesizer&lt;/code&gt; 에서 시퀀서를 재생하려면 &lt;code&gt;Transmitter&lt;/code&gt; 를 가져와 &lt;code&gt;Receiver&lt;/code&gt; 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6124e6c6d2d58106429f5f0d3d792a46b8aa09f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;connected&lt;/code&gt; is true, the returned &lt;code&gt;Sequencer&lt;/code&gt; instance is connected to the default &lt;code&gt;Synthesizer&lt;/code&gt;, as returned by &lt;a href=&quot;#getSynthesizer()&quot;&gt;&lt;code&gt;getSynthesizer()&lt;/code&gt;&lt;/a&gt;. If there is no &lt;code&gt;Synthesizer&lt;/code&gt; available, or the default &lt;code&gt;Synthesizer&lt;/code&gt; cannot be opened, the &lt;code&gt;sequencer&lt;/code&gt; is connected to the default &lt;code&gt;Receiver&lt;/code&gt;, as returned by &lt;a href=&quot;#getReceiver()&quot;&gt;&lt;code&gt;getReceiver()&lt;/code&gt;&lt;/a&gt;. The connection is made by retrieving a &lt;code&gt;Transmitter&lt;/code&gt; instance from the &lt;code&gt;Sequencer&lt;/code&gt; and setting its &lt;code&gt;Receiver&lt;/code&gt;. Closing and re-opening the sequencer will restore the connection to the default device.</source>
          <target state="translated">경우 &lt;code&gt;connected&lt;/code&gt; 사실이다, 반환 &lt;code&gt;Sequencer&lt;/code&gt; 인스턴스가 기본에 연결되어 &lt;code&gt;Synthesizer&lt;/code&gt; 에 의해 반환, &lt;a href=&quot;#getSynthesizer()&quot;&gt; &lt;code&gt;getSynthesizer()&lt;/code&gt; &lt;/a&gt; . 사용 가능한 &lt;code&gt;Synthesizer&lt;/code&gt; 가 없거나 기본 &lt;code&gt;Synthesizer&lt;/code&gt; 를 열 수없는 경우 &lt;code&gt;sequencer&lt;/code&gt; 는 &lt;a href=&quot;#getReceiver()&quot;&gt; &lt;code&gt;getReceiver()&lt;/code&gt; &lt;/a&gt; 반환 한대로 기본 &lt;code&gt;Receiver&lt;/code&gt; 에 연결됩니다 . 연결은 &lt;code&gt;Sequencer&lt;/code&gt; 에서 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스를 검색 하고 &lt;code&gt;Receiver&lt;/code&gt; 를 설정하여 이루어 집니다. 시퀀서를 닫았다가 다시 열면 기본 장치에 대한 연결이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="6a400989fbeb9d471598798fd6fec1b4c9e019b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;connected&lt;/code&gt; is true, the returned &lt;code&gt;Sequencer&lt;/code&gt; instance is connected to the default &lt;code&gt;Synthesizer&lt;/code&gt;, as returned by &lt;a href=&quot;midisystem#getSynthesizer--&quot;&gt;&lt;code&gt;getSynthesizer()&lt;/code&gt;&lt;/a&gt;. If there is no &lt;code&gt;Synthesizer&lt;/code&gt; available, or the default &lt;code&gt;Synthesizer&lt;/code&gt; cannot be opened, the &lt;code&gt;sequencer&lt;/code&gt; is connected to the default &lt;code&gt;Receiver&lt;/code&gt;, as returned by &lt;a href=&quot;midisystem#getReceiver--&quot;&gt;&lt;code&gt;getReceiver()&lt;/code&gt;&lt;/a&gt;. The connection is made by retrieving a &lt;code&gt;Transmitter&lt;/code&gt; instance from the &lt;code&gt;Sequencer&lt;/code&gt; and setting its &lt;code&gt;Receiver&lt;/code&gt;. Closing and re-opening the sequencer will restore the connection to the default device.</source>
          <target state="translated">경우 &lt;code&gt;connected&lt;/code&gt; 사실이다, 반환 &lt;code&gt;Sequencer&lt;/code&gt; 인스턴스가 기본에 연결되어 &lt;code&gt;Synthesizer&lt;/code&gt; 에 의해 반환, &lt;a href=&quot;midisystem#getSynthesizer--&quot;&gt; &lt;code&gt;getSynthesizer()&lt;/code&gt; &lt;/a&gt; . 사용 가능한 &lt;code&gt;Synthesizer&lt;/code&gt; 가 없거나 기본 &lt;code&gt;Synthesizer&lt;/code&gt; 를 열 수없는 경우 &lt;code&gt;sequencer&lt;/code&gt; 는 &lt;a href=&quot;midisystem#getReceiver--&quot;&gt; &lt;code&gt;getReceiver()&lt;/code&gt; &lt;/a&gt; 리턴 한대로 기본 &lt;code&gt;Receiver&lt;/code&gt; 에 연결됩니다 . &lt;code&gt;Sequencer&lt;/code&gt; 에서 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스를 검색 하고 &lt;code&gt;Receiver&lt;/code&gt; 설정하여 연결 합니다. 시퀀서를 닫았다가 다시 열면 기본 장치에 대한 연결이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="71d325005d1bc9bba30654c9f87b669bc09dd8f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;constraints&lt;/code&gt; is an instance of &lt;code&gt;SpringLayout.Constraints&lt;/code&gt;, associates the constraints with the specified component.</source>
          <target state="translated">&lt;code&gt;constraints&lt;/code&gt; 이 &lt;code&gt;SpringLayout.Constraints&lt;/code&gt; 인스턴스 인 경우 제약 조건을 지정된 구성 요소와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="97f5e07abbf189549bdbc5ad08d04eb152337829" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;context&lt;/code&gt; is an instance of &lt;code&gt;AccessControlContext&lt;/code&gt; then the &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; method is invoked with the specified permission.</source>
          <target state="translated">경우 &lt;code&gt;context&lt;/code&gt; 의 인스턴스 &lt;code&gt;AccessControlContext&lt;/code&gt; 다음 &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; 방법은 지정된 권한 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b20325f6c4303d0c066b9de050d67cec56121bd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;context&lt;/code&gt; is an instance of &lt;code&gt;AccessControlContext&lt;/code&gt; then the &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; method will be invoked with the &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">경우 &lt;code&gt;context&lt;/code&gt; 의 인스턴스 &lt;code&gt;AccessControlContext&lt;/code&gt; 다음 &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; 메소드가 호출됩니다 &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; 권한을.</target>
        </trans-unit>
        <trans-unit id="31ddafe0a0829efbbb709dbf3255ad93832991d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;context&lt;/code&gt; is not an instance of &lt;code&gt;AccessControlContext&lt;/code&gt; then a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;context&lt;/code&gt; 의 인스턴스가 아닌 &lt;code&gt;AccessControlContext&lt;/code&gt; 에 다음 &lt;code&gt;SecurityException&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc38633af183f173deffa3cab8c939a608e1eb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero then the remaining arguments are ignored and an empty instance is constructed.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 다음 제로입니다 나머지 인수는 무시되고 빈 인스턴스가 구성된다.</target>
        </trans-unit>
        <trans-unit id="6852ce4878997a6df2ef650e9b72a8f4bdbefa27" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d1&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt; both represent &lt;code&gt;Double.NaN&lt;/code&gt;, then the &lt;code&gt;equals&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, even though &lt;code&gt;Double.NaN==Double.NaN&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;d1&lt;/code&gt; 과 &lt;code&gt;d2&lt;/code&gt; 두 대표 &lt;code&gt;Double.NaN&lt;/code&gt; , 다음은 &lt;code&gt;equals&lt;/code&gt; 방법 반환 &lt;code&gt;true&lt;/code&gt; 에도 불구하고, &lt;code&gt;Double.NaN==Double.NaN&lt;/code&gt; 값이 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44bc5bc3fcb0b8a2244ead4272ba0f93aea4bb22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d1&lt;/code&gt; represents &lt;code&gt;+0.0&lt;/code&gt; while &lt;code&gt;d2&lt;/code&gt; represents &lt;code&gt;-0.0&lt;/code&gt;, or vice versa, the &lt;code&gt;equal&lt;/code&gt; test has the value &lt;code&gt;false&lt;/code&gt;, even though &lt;code&gt;+0.0==-0.0&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;d1&lt;/code&gt; 나타내는 &lt;code&gt;+0.0&lt;/code&gt; 을 하는 동안 &lt;code&gt;d2&lt;/code&gt; 나타내는 &lt;code&gt;-0.0&lt;/code&gt; 마찬가지 또는 그을 상기 &lt;code&gt;equal&lt;/code&gt; 시험 값 갖는 &lt;code&gt;false&lt;/code&gt; 있더라도, &lt;code&gt;+0.0==-0.0&lt;/code&gt; 값 갖는 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ba4e970f24dc7ce81bab831a86712d0ca61a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is a malformed UTF-16 sequence, the operation will fail with &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 조작 UTF-16 시퀀스이며, 동작은 실패한다 &lt;code&gt;IOException&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="0bd004ac511dc7f0af51bcd3f300b32e91cfba19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;daylight&lt;/code&gt; is true, the method should return a name appropriate for daylight saving time even if the specified time zone has not observed daylight saving time in the past.</source>
          <target state="translated">경우 &lt;code&gt;daylight&lt;/code&gt; 사실, 방법은 지정된 시간대가 과거에 일광 절약 시간을 준수하지 않을 경우에도 일광 절약 시간의 이름에 적절한를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="19ba50e0e0c3a073c02888c3b83f64e9b0e40d9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="4270f1f433b498dcded315305fe45a8471416ec6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destCM&lt;/code&gt; is null, an appropriate &lt;code&gt;ColorModel&lt;/code&gt; is used; this &lt;code&gt;ColorModel&lt;/code&gt; may have an alpha channel even if the source &lt;code&gt;ColorModel&lt;/code&gt; is opaque.</source>
          <target state="translated">경우 &lt;code&gt;destCM&lt;/code&gt; 가 null의 경우, 적절한 &lt;code&gt;ColorModel&lt;/code&gt; 의가 사용된다 이 &lt;code&gt;ColorModel&lt;/code&gt; 은 소스 &lt;code&gt;ColorModel&lt;/code&gt; 이 불투명 하더라도 알파 채널을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a42022849e46c90a898cbd2c51734fedee5cea9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a newly-created &lt;code&gt;BufferedImage&lt;/code&gt; will be returned by those methods.</source>
          <target state="translated">경우 &lt;code&gt;destination&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 새로 생성 &lt;code&gt;BufferedImage&lt;/code&gt; 그 방법으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="86c59a9151e7d15445b65e3a9dd4496ec4d2015f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dragImage&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no image is used to represent the drag over feedback for this drag operation, but &lt;code&gt;NullPointerException&lt;/code&gt; is not thrown.</source>
          <target state="translated">경우 &lt;code&gt;dragImage&lt;/code&gt; 가 있다 &lt;code&gt;null&lt;/code&gt; , 이미지가이 드래그 조작의 피드백을 통해 드래그를 나타내는 데 사용됩니다,하지만 &lt;code&gt;NullPointerException&lt;/code&gt; 발생되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07a758ae6b20af2b136010d8da073e17d7100045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dsl&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no drag source listener is registered with the created &lt;code&gt;DragSourceContext&lt;/code&gt;, but &lt;code&gt;NullPointerException&lt;/code&gt; is not thrown.</source>
          <target state="translated">경우 &lt;code&gt;dsl&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 더 드래그 소스 리스너 생성에 등록되지 &lt;code&gt;DragSourceContext&lt;/code&gt; 에 있지만, &lt;code&gt;NullPointerException&lt;/code&gt; 발생되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="671e32152696994997f192189c484af652fa86e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elem&lt;/code&gt;'s children are leaves, and the character at a &lt;code&gt;elem.getEndOffset() - 1&lt;/code&gt; is a newline, this will insert before the newline so that there isn't text after the newline.</source>
          <target state="translated">경우 &lt;code&gt;elem&lt;/code&gt; 의 아이들이 잎과 문자가에있다 &lt;code&gt;elem.getEndOffset() - 1&lt;/code&gt; 개행이며,이 개행 후에 텍스트가 없게하기 위해서 개행 전에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0e833bca2753aebf4a94a4ac1b2271036c873d56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;emitter&lt;/code&gt; is an instance of &lt;code&gt;
 NotificationBroadcasterSupport&lt;/code&gt; then the MBean's &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;emitter&lt;/code&gt; 의 인스턴스 &lt;code&gt; NotificationBroadcasterSupport&lt;/code&gt; 는 다음의 MBean의 &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 에의&lt;/a&gt; 방법은 호출 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="acf80930c16745703588fc8e28d2d3df55d01d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;emitter&lt;/code&gt; is an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then the MBean's &lt;a href=&quot;standardemittermbean#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;emitter&lt;/code&gt; 의 인스턴스 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 는 다음의 MBean의 &lt;a href=&quot;standardemittermbean#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 에의&lt;/a&gt; 방법은 호출 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8324b3ddb33d3e4e604a3283dc65c4b7e2c1714" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to ensure it's ok to enable the stream to do replacement of objects in the stream.</source>
          <target state="translated">경우 &lt;code&gt;enable&lt;/code&gt; 사실, 설치 보안 매니저가 존재하는,이 메소드는 최초로 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 과 방법을 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; 는 스트림의 객체를 스트림을 치환 할 수 있도록 할 수있는 것을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="e97c9dab350a635e1bd626e9e0c916b1c358faad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;envp&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the subprocess inherits the environment settings of the current process.</source>
          <target state="translated">경우 &lt;code&gt;envp&lt;/code&gt; 는가 이다 &lt;code&gt;null&lt;/code&gt; , 서브 프로세스는 현재의 프로세스의 환경 설정을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="8c047902addb64f0147944efb0c8e559fa07ca7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;expression&lt;/code&gt; contains any &lt;a href=&quot;xpathfunction&quot;&gt;&lt;code&gt;XPathFunction&lt;/code&gt;&lt;/a&gt;s, they must be available via the &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; will be thrown if the &lt;code&gt;XPathFunction&lt;/code&gt; cannot be resovled with the &lt;code&gt;XPathFunctionResolver&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;expression&lt;/code&gt; 어떤 포함 &lt;a href=&quot;xpathfunction&quot;&gt; &lt;code&gt;XPathFunction&lt;/code&gt; &lt;/a&gt; 들, 그들은을 통해 사용할 수 있어야합니다 &lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; 는&lt;/a&gt; 경우 발생합니다 &lt;code&gt;XPathFunction&lt;/code&gt; 가 와 resovled 수 없습니다 &lt;code&gt;XPathFunctionResolver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9da61e21551ded09c572b8458799b783326a7876" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;expression&lt;/code&gt; contains any variables, the &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt; in effect &lt;strong&gt;at compile time&lt;/strong&gt; will be used to resolve them.</source>
          <target state="translated">경우 &lt;code&gt;expression&lt;/code&gt; 어떤 변수가 포함의 &lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; 에&lt;/a&gt; 효과 &lt;strong&gt;컴파일시는&lt;/strong&gt; 이를 해결하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d365ce5462b9cce5c4cc76e80ec9bcaf6dc2827e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; both represent &lt;code&gt;Float.NaN&lt;/code&gt;, then the &lt;code&gt;equals&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, even though &lt;code&gt;Float.NaN==Float.NaN&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f1&lt;/code&gt; 및 &lt;code&gt;f2&lt;/code&gt; 모두 대표 &lt;code&gt;Float.NaN&lt;/code&gt; 다음은 &lt;code&gt;equals&lt;/code&gt; 방법 반환 &lt;code&gt;true&lt;/code&gt; 에도 &lt;code&gt;Float.NaN==Float.NaN&lt;/code&gt; 값 갖는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02f2e27c390e74634fe1d9d347fb6aedb7e004fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f1&lt;/code&gt; represents &lt;code&gt;+0.0f&lt;/code&gt; while &lt;code&gt;f2&lt;/code&gt; represents &lt;code&gt;-0.0f&lt;/code&gt;, or vice versa, the &lt;code&gt;equal&lt;/code&gt; test has the value &lt;code&gt;false&lt;/code&gt;, even though &lt;code&gt;0.0f==-0.0f&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f1&lt;/code&gt; 나타낸다 &lt;code&gt;+0.0f&lt;/code&gt; 를가 하면서 &lt;code&gt;f2&lt;/code&gt; 나타내는 &lt;code&gt;-0.0f&lt;/code&gt; 또는 그 역으로는 상기 &lt;code&gt;equal&lt;/code&gt; 시험 값 갖는 &lt;code&gt;false&lt;/code&gt; 있더라도 &lt;code&gt;0.0f==-0.0f&lt;/code&gt; 값을 갖는 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a4e8f71e325659bc4df66fba601fd08fe6cbbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factoryId&lt;/code&gt; is &quot;javax.xml.stream.XMLEventFactory&quot;, use the service-provider loading facility, defined by the &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; class, to attempt to &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class,java.lang.ClassLoader)&quot;&gt;locate and load&lt;/a&gt; an implementation of the service using the specified &lt;code&gt;ClassLoader&lt;/code&gt;. If &lt;code&gt;classLoader&lt;/code&gt; is null, the &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class)&quot;&gt;default loading mechanism&lt;/a&gt; will apply: That is, the service-provider loading facility will use the &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;current thread's context class loader&lt;/a&gt; to attempt to load the service. If the context class loader is null, the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;system class loader&lt;/a&gt; will be used.</source>
          <target state="translated">경우 &lt;code&gt;factoryId&lt;/code&gt; 는 &quot;javax.xml.stream.XMLEventFactory&quot;입니다,에 의해 정의 된 서비스 프로 바이더로드기구 사용 &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; 를&lt;/a&gt; 시도하는, 클래스를 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class,java.lang.ClassLoader)&quot;&gt;찾아로드&lt;/a&gt; 지정된 사용하여 서비스의 구현 &lt;code&gt;ClassLoader&lt;/code&gt; . 경우 &lt;code&gt;classLoader&lt;/code&gt; NULL 인의 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class)&quot;&gt;기본 로딩 메커니즘이&lt;/a&gt; 적용됩니다 : 즉, 서비스 프로 바이더로드기구가 사용하는 &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;현재의 thread의 문맥 클래스 로더를&lt;/a&gt; 서비스를로드하려고 할 수 있습니다. 컨텍스트 클래스 로더가 널이면 &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;시스템 클래스 로더&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b52f1fd05c564079d1ef7372e4d9641e12a536" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factoryId&lt;/code&gt; is &quot;javax.xml.stream.XMLInputFactory&quot;, use the service-provider loading facility, defined by the &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; class, to attempt to &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class,java.lang.ClassLoader)&quot;&gt;locate and load&lt;/a&gt; an implementation of the service using the specified &lt;code&gt;ClassLoader&lt;/code&gt;. If &lt;code&gt;classLoader&lt;/code&gt; is null, the &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class)&quot;&gt;default loading mechanism&lt;/a&gt; will apply: That is, the service-provider loading facility will use the &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;current thread's context class loader&lt;/a&gt; to attempt to load the service. If the context class loader is null, the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;system class loader&lt;/a&gt; will be used.</source>
          <target state="translated">경우 &lt;code&gt;factoryId&lt;/code&gt; 는 &quot;javax.xml.stream.XMLInputFactory&quot;입니다,에 의해 정의 된 서비스 프로 바이더로드기구 사용 &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; 를&lt;/a&gt; 시도하는, 클래스를 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class,java.lang.ClassLoader)&quot;&gt;찾아로드&lt;/a&gt; 지정된 사용하여 서비스의 구현 &lt;code&gt;ClassLoader&lt;/code&gt; . 경우 &lt;code&gt;classLoader&lt;/code&gt; NULL 인의 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class)&quot;&gt;기본 로딩 메커니즘이&lt;/a&gt; 적용됩니다 : 즉, 서비스 프로 바이더로드기구가 사용하는 &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;현재의 thread의 문맥 클래스 로더를&lt;/a&gt; 서비스를로드하려고 할 수 있습니다. 컨텍스트 클래스 로더가 널이면 &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;시스템 클래스 로더&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f7e5734521ac85dd8febe80b1d9322d97653dec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factoryId&lt;/code&gt; is &quot;javax.xml.stream.XMLOutputFactory&quot;, use the service-provider loading facility, defined by the &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; class, to attempt to &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class,java.lang.ClassLoader)&quot;&gt;locate and load&lt;/a&gt; an implementation of the service using the specified &lt;code&gt;ClassLoader&lt;/code&gt;. If &lt;code&gt;classLoader&lt;/code&gt; is null, the &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class)&quot;&gt;default loading mechanism&lt;/a&gt; will apply: That is, the service-provider loading facility will use the &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;current thread's context class loader&lt;/a&gt; to attempt to load the service. If the context class loader is null, the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;system class loader&lt;/a&gt; will be used.</source>
          <target state="translated">경우 &lt;code&gt;factoryId&lt;/code&gt; 는 &quot;javax.xml.stream.XMLOutputFactory&quot;입니다,에 의해 정의 된 서비스 프로 바이더로드기구 사용 &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; 를&lt;/a&gt; 시도하는, 클래스를 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class,java.lang.ClassLoader)&quot;&gt;찾아로드&lt;/a&gt; 지정된 사용하여 서비스의 구현 &lt;code&gt;ClassLoader&lt;/code&gt; . 경우 &lt;code&gt;classLoader&lt;/code&gt; NULL 인의 &lt;a href=&quot;../../../../java.base/java/util/serviceloader#load(java.lang.Class)&quot;&gt;기본 로딩 메커니즘이&lt;/a&gt; 적용됩니다 : 즉, 서비스 프로 바이더로드기구가 사용하는 &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;현재의 thread의 문맥 클래스 로더를&lt;/a&gt; 서비스를로드하려고 할 수 있습니다. 컨텍스트 클래스 로더가 널이면 &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;시스템 클래스 로더&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a17fe183773e714b799598ab729f9897cba3dda0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; is specified for this parameter, no dialog will be displayed and printing will begin immediately on the event-dispatch thread. This blocks any other events, including repaints, from being processed until printing is complete. Although this effectively prevents the table from being changed, it doesn't provide a good user experience. For this reason, specifying &lt;code&gt;false&lt;/code&gt; is only recommended when printing from an application with no visible GUI.</source>
          <target state="translated">이 매개 변수에 대해 &lt;code&gt;false&lt;/code&gt; 를 지정 하면 대화 상자가 표시되지 않고 이벤트 디스패치 스레드에서 즉시 인쇄가 시작됩니다. 이렇게하면 인쇄가 완료 될 때까지 다시 그리기를 비롯한 다른 이벤트가 처리되지 않습니다. 이렇게하면 테이블이 변경되는 것을 효과적으로 방지 할 수 있지만 좋은 사용자 경험을 제공하지는 않습니다. 따라서 GUI가 표시되지 않는 응용 프로그램에서 인쇄 할 때만 &lt;code&gt;false&lt;/code&gt; 를 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1eb496259f00592aff5b9be8d63e8acf543432df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, hides this &lt;code&gt;Window&lt;/code&gt;, its subcomponents, and all of its owned children. The &lt;code&gt;Window&lt;/code&gt; and its subcomponents can be made visible again with a call to &lt;code&gt;#setVisible(true)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; 이 숨어 &lt;code&gt;Window&lt;/code&gt; , 그 서브 컴퍼넌트, 그 소유 된 모든 아이를. &lt;code&gt;Window&lt;/code&gt; 와 그 하위 구성 요소에 대한 호출을 통해 다시 볼을 만들 수 있습니다 &lt;code&gt;#setVisible(true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf347bae0413ed579fe931fe93b7cc8014deb8b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, then don't track the viewport's height. This allows vertical scrolling if the &lt;code&gt;JViewport&lt;/code&gt; is itself embedded in a &lt;code&gt;JScrollPane&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; , 뷰포트의 높이를 추적하지 않습니다. 이것은 &lt;code&gt;JViewport&lt;/code&gt; 자체가 &lt;code&gt;JScrollPane&lt;/code&gt; 에 내장 된 경우 수직 스크롤을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="30afcaa6953a6452eb8a238dc84f098a4f12526a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, then don't track the viewport's width. This allows horizontal scrolling if the &lt;code&gt;JViewport&lt;/code&gt; is itself embedded in a &lt;code&gt;JScrollPane&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; , 뷰포트의 폭을 추적하지 않습니다. 이것은 &lt;code&gt;JViewport&lt;/code&gt; 자체가 &lt;code&gt;JScrollPane&lt;/code&gt; 에 내장 된 경우 수평 스크롤을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="66a8be1fdc88dd83d0d09b1f4ba920fc5ee7189f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, this connection object has not created a communications link to the specified URL.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; 이 연결 오브젝트가 작성되지 않은 통신은 지정된 URL로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="630fae85e6e75f8a21f5f5d31a0400d282d6a9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, this connection object has not created a communications link to the specified URL. If &lt;code&gt;true&lt;/code&gt;, the communications link has been established.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 인 경우 ,이 연결 오브젝트는 지정된 URL에 대한 통신 링크를 작성하지 않았습니다. 경우 &lt;code&gt;true&lt;/code&gt; , 통신 링크가 확립되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9702dde3d9a0118b7dd2912b75454177c523a37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fdObj&lt;/code&gt; is null then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;fdObj&lt;/code&gt; 가 null의 다음 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8fe7727e267fc41983357258d9e1b31e029f61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, instructs the &lt;code&gt;Timer&lt;/code&gt; to send only one action event to its listeners.</source>
          <target state="translated">경우 &lt;code&gt;flag&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; 의 지시 &lt;code&gt;Timer&lt;/code&gt; 의 액션 이벤트를 1 개만 청취자에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3395a8472778d028cdc391d0c4cd441420219c03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flavor&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or is an empty set, this method returns all the printing attribute values this Print Service supports for any possible job. If &lt;code&gt;flavor&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;attributes&lt;/code&gt; is not an empty set, this method returns just the printing attribute values that are compatible with the given doc flavor and/or set of attributes. That is, a &lt;code&gt;null&lt;/code&gt; return value may indicate that specifying this attribute is incompatible with the specified DocFlavor. Also if &lt;code&gt;DocFlavor&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; it must be a flavor supported by this &lt;code&gt;PrintService&lt;/code&gt;, else &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;flavor&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 와 &lt;code&gt;attributes&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 또는 빈 집합입니다,이 메소드가 리턴는 모든 인쇄 속성은 가능한 모든 작업이 인쇄에게 서비스가 지원하는 값. 경우 &lt;code&gt;flavor&lt;/code&gt; 없는 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;attributes&lt;/code&gt; 빈 설정되지 않은,이 메서드가 반환하는 속성의 지정된 문서의 맛 및 / 또는 세트와 호환 바로 인쇄 속성 값. 즉, &lt;code&gt;null&lt;/code&gt; 반환 값은이 속성을 지정하는 것이 지정된 DocFlavor와 호환되지 않음을 나타낼 수 있습니다. 또한 &lt;code&gt;DocFlavor&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 아니면 이 &lt;code&gt;PrintService&lt;/code&gt; 에서 지원하는 플레이버 여야합니다. &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fc4a3d8e19e95f7c5560897f5b0527a32150fd2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flavor&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or is an empty set, this method tells whether this Print Service supports the given printing attribute value for some possible combination of doc flavor and set of attributes. If &lt;code&gt;flavor&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;attributes&lt;/code&gt; is not an empty set, this method tells whether this Print Service supports the given printing attribute value in combination with the given doc flavor and/or set of attributes.</source>
          <target state="translated">경우 &lt;code&gt;flavor&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 와 &lt;code&gt;attributes&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 이 인쇄 서비스는 문서의 맛과 속성 집합의 몇 가지 가능한 조합에 대해 지정된 인쇄 속성 값을 지원하는지 여부를이 방법을 알려줍니다, 또는 빈 세트입니다. 경우 &lt;code&gt;flavor&lt;/code&gt; 없는 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;attributes&lt;/code&gt; 빈 설정되지 않은,이 방법이 인쇄 서비스 속성의 지정된 문서의 맛 및 / 또는 세트와 함께 제공된 인쇄 속성 값을 지원하는지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="be23bf2f29c50a82b21120383b7ebe578f180829" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flavor&lt;/code&gt; is null and &lt;code&gt;attributes&lt;/code&gt; is null or is an empty set, this method returns all the printing attribute values this Print Service supports for any possible job. If &lt;code&gt;flavor&lt;/code&gt; is not null or &lt;code&gt;attributes&lt;/code&gt; is not an empty set, this method returns just the printing attribute values that are compatible with the given doc flavor and/or set of attributes. That is, a null return value may indicate that specifying this attribute is incompatible with the specified DocFlavor. Also if DocFlavor is not null it must be a flavor supported by this PrintService, else IllegalArgumentException will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;flavor&lt;/code&gt; null로, &lt;code&gt;attributes&lt;/code&gt; null의 경우, 또는 공집합이 메소드가 리턴는 모든 인쇄 속성은 가능한 모든 작업이 인쇄에게 서비스가 지원하는 값. 경우 &lt;code&gt;flavor&lt;/code&gt; 널 (null)이 아니거나 &lt;code&gt;attributes&lt;/code&gt; 빈 설정되지 않은,이 메서드가 반환하는 속성의 지정된 문서의 맛 및 / 또는 세트와 호환 바로 인쇄 속성 값. 즉, null 반환 값은이 속성을 지정하는 것이 지정된 DocFlavor와 호환되지 않음을 나타낼 수 있습니다. 또한 DocFlavor가 null이 아닌 경우,이 PrintService가 지원하는 플레이버가 아니면 안됩니다. 그렇지 않으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d49f1a825da9124482947de19b8854b16f9cfcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flavor&lt;/code&gt; is null and &lt;code&gt;attributes&lt;/code&gt; is null or is an empty set, this method tells whether this Print Service supports the given printing attribute value for some possible combination of doc flavor and set of attributes. If &lt;code&gt;flavor&lt;/code&gt; is not null or &lt;code&gt;attributes&lt;/code&gt; is not an empty set, this method tells whether this Print Service supports the given printing attribute value in combination with the given doc flavor and/or set of attributes.</source>
          <target state="translated">경우 &lt;code&gt;flavor&lt;/code&gt; null로, &lt;code&gt;attributes&lt;/code&gt; 이 인쇄 서비스는 문서의 맛과 속성 집합의 몇 가지 가능한 조합에 대해 지정된 인쇄 속성 값을 지원하는지 여부를이 방법을 알려줍니다 널 또는 빈 세트입니다. 경우 &lt;code&gt;flavor&lt;/code&gt; 널 (null)이 아니거나 &lt;code&gt;attributes&lt;/code&gt; 빈 설정되지 않은,이 방법이 인쇄 서비스 속성의 지정된 문서의 맛 및 / 또는 세트와 함께 제공된 인쇄 속성 값을 지원하는지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="728f88aebecd0c6c9117a6392cef0bb533b3cbde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;, the &lt;a href=&quot;../lang/class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; specified by the bundle name is loaded by calling &lt;a href=&quot;../lang/classloader#loadClass-java.lang.String-&quot;&gt;&lt;code&gt;ClassLoader.loadClass(String)&lt;/code&gt;&lt;/a&gt;. Then, a &lt;code&gt;ResourceBundle&lt;/code&gt; is instantiated by calling &lt;a href=&quot;../lang/class#newInstance--&quot;&gt;&lt;code&gt;Class.newInstance()&lt;/code&gt;&lt;/a&gt;. Note that the &lt;code&gt;reload&lt;/code&gt; flag is ignored for loading class-based resource bundles in this default implementation.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 입니다 &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; 의 &lt;a href=&quot;../lang/class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 를 호출하여로드 번들 이름으로 지정 &lt;a href=&quot;../lang/classloader#loadClass-java.lang.String-&quot;&gt; &lt;code&gt;ClassLoader.loadClass(String)&lt;/code&gt; &lt;/a&gt; . 그런 다음 &lt;a href=&quot;../lang/class#newInstance--&quot;&gt; &lt;code&gt;Class.newInstance()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;code&gt;ResourceBundle&lt;/code&gt; 을 인스턴스화합니다 . 이 기본 구현에서 클래스 기반 자원 번들을로드 할 때는 &lt;code&gt;reload&lt;/code&gt; 플래그가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6039368456cf5fbee27aa04ee3108fdc83e13de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;, the &lt;a href=&quot;../lang/class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; specified by the bundle name is loaded with the given class loader. If the &lt;code&gt;Class&lt;/code&gt; is found and accessible then the &lt;code&gt;ResourceBundle&lt;/code&gt; is instantiated. The resource bundle is accessible if the package of the bundle class file is open unconditionally; otherwise, &lt;code&gt;IllegalAccessException&lt;/code&gt; will be thrown. Note that the &lt;code&gt;reload&lt;/code&gt; flag is ignored for loading class-based resource bundles in this default implementation.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 입니다 &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; 의 &lt;a href=&quot;../lang/class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 번들 이름으로 지정이 지정된 클래스 로더로로드됩니다. 경우 &lt;code&gt;Class&lt;/code&gt; 다음을 발견하고 접근 할 수있는 &lt;code&gt;ResourceBundle&lt;/code&gt; 인스턴스화됩니다. 번들 클래스 파일의 패키지가 무조건 열린 경우 자원 번들에 액세스 할 수 있습니다. 그렇지 않으면 &lt;code&gt;IllegalAccessException&lt;/code&gt; 이 발생합니다. 이 기본 구현에서 클래스 기반 리소스 번들을로드 하는 경우 &lt;code&gt;reload&lt;/code&gt; 플래그가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ee8c7630c25cce52a31a7ddf6438af84a04bab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, &lt;a href=&quot;#toResourceName(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;toResourceName(bundlename,
 &quot;properties&quot;)&lt;/code&gt;&lt;/a&gt; is called to get the resource name. If &lt;code&gt;reload&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;../lang/classloader#getResource(java.lang.String)&quot;&gt;&lt;code&gt;load.getResource&lt;/code&gt;&lt;/a&gt; is called to get a &lt;a href=&quot;../net/url&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; for creating a &lt;a href=&quot;../net/urlconnection&quot;&gt;&lt;code&gt;URLConnection&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;URLConnection&lt;/code&gt; is used to &lt;a href=&quot;../net/urlconnection#setUseCaches(boolean)&quot;&gt;disable the caches&lt;/a&gt; of the underlying resource loading layers, and to &lt;a href=&quot;../net/urlconnection#getInputStream()&quot;&gt;get an &lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;. Otherwise, &lt;a href=&quot;../lang/classloader#getResourceAsStream(java.lang.String)&quot;&gt;&lt;code&gt;loader.getResourceAsStream&lt;/code&gt;&lt;/a&gt; is called to get an &lt;a href=&quot;../io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;. Then, a &lt;a href=&quot;propertyresourcebundle&quot;&gt;&lt;code&gt;PropertyResourceBundle&lt;/code&gt;&lt;/a&gt; is constructed with the &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 입니다 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; , &lt;a href=&quot;#toResourceName(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;toResourceName(bundlename, &quot;properties&quot;)&lt;/code&gt; &lt;/a&gt; 자원 이름을 얻기 위해 호출된다. 경우 &lt;code&gt;reload&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , &lt;a href=&quot;../lang/classloader#getResource(java.lang.String)&quot;&gt; &lt;code&gt;load.getResource&lt;/code&gt; 를이&lt;/a&gt; 얻기 위해 호출되는 &lt;a href=&quot;../net/url&quot;&gt; &lt;code&gt;URL&lt;/code&gt; 을&lt;/a&gt; 만드는 &lt;a href=&quot;../net/urlconnection&quot;&gt; &lt;code&gt;URLConnection&lt;/code&gt; 의를&lt;/a&gt; . 이 &lt;code&gt;URLConnection&lt;/code&gt; 은 기본 리소스 로딩 레이어 &lt;a href=&quot;../net/urlconnection#setUseCaches(boolean)&quot;&gt;의 캐시&lt;/a&gt; 를 비활성화하고 &lt;a href=&quot;../net/urlconnection#getInputStream()&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 을 가져 오는 데 사용 됩니다. 그렇지 않으면 &lt;a href=&quot;../lang/classloader#getResourceAsStream(java.lang.String)&quot;&gt; &lt;code&gt;loader.getResourceAsStream&lt;/code&gt; &lt;/a&gt; 이 호출되어 &lt;a href=&quot;../io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 을 가져옵니다 . 그런 다음 &lt;code&gt;InputStream&lt;/code&gt; 으로 &lt;a href=&quot;propertyresourcebundle&quot;&gt; &lt;code&gt;PropertyResourceBundle&lt;/code&gt; &lt;/a&gt; 이 생성됩니다..</target>
        </trans-unit>
        <trans-unit id="4b8ff2ae3c3edfe6e55d36fcd777f2a4b551bda0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, &lt;a href=&quot;resourcebundle.control#toResourceName-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;toResourceName(bundlename,
 &quot;properties&quot;)&lt;/code&gt;&lt;/a&gt; is called to get the resource name. If &lt;code&gt;reload&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;load.getResource&lt;/code&gt;&lt;/a&gt; is called to get a &lt;a href=&quot;../net/url&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; for creating a &lt;a href=&quot;../net/urlconnection&quot;&gt;&lt;code&gt;URLConnection&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;URLConnection&lt;/code&gt; is used to &lt;a href=&quot;../net/urlconnection#setUseCaches-boolean-&quot;&gt;disable the caches&lt;/a&gt; of the underlying resource loading layers, and to &lt;a href=&quot;../net/urlconnection#getInputStream--&quot;&gt;get an &lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;. Otherwise, &lt;a href=&quot;../lang/classloader#getResourceAsStream-java.lang.String-&quot;&gt;&lt;code&gt;loader.getResourceAsStream&lt;/code&gt;&lt;/a&gt; is called to get an &lt;a href=&quot;../io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;. Then, a &lt;a href=&quot;propertyresourcebundle&quot;&gt;&lt;code&gt;PropertyResourceBundle&lt;/code&gt;&lt;/a&gt; is constructed with the &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 입니다 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; , &lt;a href=&quot;resourcebundle.control#toResourceName-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;toResourceName(bundlename, &quot;properties&quot;)&lt;/code&gt; &lt;/a&gt; 자원 이름을 얻기 위해 호출된다. 경우 &lt;code&gt;reload&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;load.getResource&lt;/code&gt; 를이&lt;/a&gt; 얻기 위해 호출되는 &lt;a href=&quot;../net/url&quot;&gt; &lt;code&gt;URL&lt;/code&gt; 을&lt;/a&gt; 만드는 &lt;a href=&quot;../net/urlconnection&quot;&gt; &lt;code&gt;URLConnection&lt;/code&gt; 의를&lt;/a&gt; . 이 &lt;code&gt;URLConnection&lt;/code&gt; 은 기본 리소스 로딩 레이어 &lt;a href=&quot;../net/urlconnection#setUseCaches-boolean-&quot;&gt;의 캐시&lt;/a&gt; 를 비활성화하고 &lt;a href=&quot;../net/urlconnection#getInputStream--&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 을 얻는 데 사용 됩니다. 그렇지 않으면, &lt;a href=&quot;../lang/classloader#getResourceAsStream-java.lang.String-&quot;&gt; &lt;code&gt;loader.getResourceAsStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 을 얻기 위해 호출됩니다 . 그런 다음 &lt;a href=&quot;propertyresourcebundle&quot;&gt; &lt;code&gt;PropertyResourceBundle&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;InputStream&lt;/code&gt; 으로 구성됩니다..</target>
        </trans-unit>
        <trans-unit id="f42cfefdfecf42455430978075c24a908e609d41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is neither &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; nor &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 도 아니다 &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; 이나 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; , &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc7cb12e560b7ce1ea4006578a8c4be2c3028af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;formatName&lt;/code&gt; is not the name of a supported metadata format, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;formatName&lt;/code&gt; 이 지원되는 메타 데이터 형식의 이름이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c2beafb307d147c084fdb79b125de967839d099f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;formatName&lt;/code&gt; is not the name of a supported metadata format, &lt;code&gt;null&lt;/code&gt; may be returned.</source>
          <target state="translated">&lt;code&gt;formatName&lt;/code&gt; 이 지원되는 메타 데이터 형식의 이름이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4999a54931bc187d155c5a8b3698a6b48785bb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;free&lt;/code&gt; is called multiple times, the subsequent calls to &lt;code&gt;free&lt;/code&gt; are treated as a no-op.</source>
          <target state="translated">경우 &lt;code&gt;free&lt;/code&gt; 여러 번 호출에 후속 호출 &lt;code&gt;free&lt;/code&gt; 무 조작으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4f5c627c071a3f95cd6975b3038e253343f70ee2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;functionName&lt;/code&gt; or &lt;code&gt;arity&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;functionName&lt;/code&gt; 또는 &lt;code&gt;arity&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="b2bca824599e9b044b10a21f505308df9e325ad3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;genParams&lt;/code&gt; is true, this method generates new p, q and g parameters. If it is false, the method uses precomputed parameters for the modulus length requested. If there are no precomputed parameters for that modulus length, an exception will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;genParams&lt;/code&gt; 는 사실,이 방법은 새로운 P, Q 및 g 파라미터를 생성한다. false이면 요청 된 모듈러스 길이에 대해 미리 계산 된 매개 변수를 사용합니다. 해당 모듈러스 길이에 대해 미리 계산 된 매개 변수가 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d738c59b5a30411d7967aa3404684da21b829b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;genParams&lt;/code&gt; is true, this method generates new p, q and g parameters. If it is false, the method uses precomputed parameters for the modulus length requested. If there are no precomputed parameters for that modulus length, an exception will be thrown. It is guaranteed that there will always be default parameters for modulus lengths of 512 and 1024 bits.</source>
          <target state="translated">경우 &lt;code&gt;genParams&lt;/code&gt; 는 사실,이 방법은 새로운 P, Q 및 g 파라미터를 생성한다. false 인 경우, 메소드는 요청 된 계수 길이에 대해 사전 계산 된 매개 변수를 사용합니다. 해당 계수 길이에 대해 사전 계산 된 매개 변수가 없으면 예외가 발생합니다. 512와 1024 비트의 모듈러스 길이에 대한 기본 매개 변수가 항상 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="b63b16077e4b88eda3ca54b2339f4fa714c5920f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;getAllowsInvalid()&lt;/code&gt; is false, this will ask the &lt;code&gt;Format&lt;/code&gt; to format the current text on every edit.</source>
          <target state="translated">경우 &lt;code&gt;getAllowsInvalid()&lt;/code&gt; 거짓이는 물을 것이다 &lt;code&gt;Format&lt;/code&gt; 각 편집의 현행 텍스트에 서식을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="974da0d9b27cacc783e6a3eeaa75fb9cb956c4a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;getLocalizedMessage&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, then just the class name is returned.</source>
          <target state="translated">경우 &lt;code&gt;getLocalizedMessage&lt;/code&gt; 반환 &lt;code&gt;null&lt;/code&gt; , 그럼 그냥 클래스 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="907b2824eea31c80cbd26162e8a3337f722ad7b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;getSourceNumProgressivePasses&lt;/code&gt; is equal to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, returns &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;getSourceNumProgressivePasses&lt;/code&gt; 에가 동일 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 를 반환 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e1894481f6c66504adea99b2ac962cbd98ec2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;getSourceNumProgressivePasses&lt;/code&gt; is equal to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, returns &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;. Otherwise, returns &lt;code&gt;getSourceMinProgressivePass() +
 getSourceNumProgressivePasses() - 1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;getSourceNumProgressivePasses&lt;/code&gt; 에가 동일 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 를 반환 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;getSourceMinProgressivePass() + getSourceNumProgressivePasses() - 1&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d26c245764deb5e5a49c02d6fb3e134690c580e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;getSupportsIncrement&lt;/code&gt; returns true, this returns two Actions suitable for incrementing/decrementing the value.</source>
          <target state="translated">경우 &lt;code&gt;getSupportsIncrement&lt;/code&gt; 가 true를 반환 증가에 대한 두 가지 작업에 적합한이 반환 / 값을 감소시키는.</target>
        </trans-unit>
        <trans-unit id="0b83bf6cf2191fd0ca1ce76107162612831c8212" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;getUI()&lt;/code&gt; fails for any reason, it calls this method before returning &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;getUI()&lt;/code&gt; 어떤 이유로 실패, 그것은 반환하기 전에이 메소드를 호출 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb8d881a6862460eb3f3e1ff18bdc2cc39110927" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;getUI()&lt;/code&gt; fails for any reason, it calls this method before returning &lt;code&gt;null&lt;/code&gt;. Subclasses may choose to do more or less here.</source>
          <target state="translated">경우 &lt;code&gt;getUI()&lt;/code&gt; 어떤 이유로 실패, 그것은 반환하기 전에이 메소드를 호출 &lt;code&gt;null&lt;/code&gt; . 서브 클래스는 여기서 더 많거나 적은 것을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b1a74b2ecbae4b36efdb3fffb81c50933310a1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;identifier&lt;/code&gt; is not a simple SQL identifier, &lt;code&gt;identifier&lt;/code&gt; will be enclosed in double quotes if not already present. If the datasource does not support double quotes for delimited identifiers, the identifier should be enclosed by the string returned from &lt;a href=&quot;databasemetadata#getIdentifierQuoteString()&quot;&gt;&lt;code&gt;DatabaseMetaData.getIdentifierQuoteString()&lt;/code&gt;&lt;/a&gt;. If the datasource does not support delimited identifiers, a &lt;code&gt;SQLFeatureNotSupportedException&lt;/code&gt; should be thrown.</source>
          <target state="translated">경우 &lt;code&gt;identifier&lt;/code&gt; 간단한의 SQL 식별자 아니라, &lt;code&gt;identifier&lt;/code&gt; 아니지만 이미 큰 따옴표로 묶어야합니다. 데이터 소스가 구분 식별자에 큰 따옴표를 지원하지 않는 경우 식별자는 &lt;a href=&quot;databasemetadata#getIdentifierQuoteString()&quot;&gt; &lt;code&gt;DatabaseMetaData.getIdentifierQuoteString()&lt;/code&gt; &lt;/a&gt; 에서 반환 된 문자열로 묶어야합니다 . 데이터 소스가 구분 된 식별자를 지원하지 않는 &lt;code&gt;SQLFeatureNotSupportedException&lt;/code&gt; 이 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa36ccf5c744f0752d847fd1a68c0f81f1adea54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the loop variable will be initialized to its &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;init&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 루프 변수는 초기화됩니다 &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;기본값&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66c8f48850938200dd0dd54407e6a4723e8d13f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it must have return type &lt;code&gt;V&lt;/code&gt;. Its parameter list (of some &lt;a href=&quot;methodhandles#astar&quot;&gt;form &lt;code&gt;(A*)&lt;/code&gt;&lt;/a&gt;) must be &lt;a href=&quot;methodhandles#effid&quot;&gt;effectively identical&lt;/a&gt; to the external parameter list &lt;code&gt;(A...)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;init&lt;/code&gt; 비입니다 &lt;code&gt;null&lt;/code&gt; , 그것은 반환 형식이 있어야 &lt;code&gt;V&lt;/code&gt; 를 . &lt;a href=&quot;methodhandles#astar&quot;&gt; &lt;code&gt;(A*)&lt;/code&gt; &lt;/a&gt; 형식 의 매개 변수 목록 은 외부 매개 변수 목록 &lt;code&gt;(A...)&lt;/code&gt; &lt;a href=&quot;methodhandles#effid&quot;&gt;과 사실상 동일&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9263d80c7e6d313c1f67a86574a2a10853f3cd4f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; has a length of zero, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;input&lt;/code&gt; 0의 길이가,이 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8350717158b00042f3abe9d471b9cbca7a0340d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputLen&lt;/code&gt; is zero, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;inputLen&lt;/code&gt; 제로,이 메소드는 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9261b779ae1d6f321ad2f0afc91c251c41e791" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputLen&lt;/code&gt; is zero, this method returns a length of zero.</source>
          <target state="translated">경우 &lt;code&gt;inputLen&lt;/code&gt; 제로,이 메소드는 0의 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b360875f169639471eb29957edb6d34c0bd1677" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isIconOnly&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then only icon is painted.</source>
          <target state="translated">경우 &lt;code&gt;isIconOnly&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; 만 아이콘이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="6205d082ac75d25ba929a2bf10aabc50076ee5cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isPalette&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, sets palette border and title</source>
          <target state="translated">경우 &lt;code&gt;isPalette&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 팔레트 테두리와 제목을 설정합니다</target>
        </trans-unit>
        <trans-unit id="1bd0823852f4205f4524ddce229347454ba40a49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false (the default), most integer values are returned as &lt;code&gt;Long&lt;/code&gt; objects, no matter how they are written: &lt;code&gt;&quot;17&quot;&lt;/code&gt; and &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; both parse to &lt;code&gt;Long(17)&lt;/code&gt;. Values that cannot fit into a &lt;code&gt;Long&lt;/code&gt; are returned as &lt;code&gt;Double&lt;/code&gt;s. This includes values with a fractional part, infinite values, &lt;code&gt;NaN&lt;/code&gt;, and the value -0.0. &lt;code&gt;DecimalFormat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; decide whether to return a &lt;code&gt;Double&lt;/code&gt; or a &lt;code&gt;Long&lt;/code&gt; based on the presence of a decimal separator in the source string. Doing so would prevent integers that overflow the mantissa of a double, such as &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt;, from being parsed accurately.</source>
          <target state="translated">경우 &lt;code&gt;isParseBigDecimal()&lt;/code&gt; false (기본값)와 같이, 대부분의 정수 값을 반환 &lt;code&gt;Long&lt;/code&gt; : 오브젝트은 작성하는 방법에 상관없이 &lt;code&gt;&quot;17&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; 에 모두 구문 분석 &lt;code&gt;Long(17)&lt;/code&gt; . &lt;code&gt;Long&lt;/code&gt; 에 맞지 않는 값은 &lt;code&gt;Double&lt;/code&gt; 으로 반환됩니다 . 여기에는 소수 부분, 무한 값, &lt;code&gt;NaN&lt;/code&gt; 및 -0.0 값이 포함 된 값이 포함됩니다 . &lt;code&gt;DecimalFormat&lt;/code&gt; 은 소스 문자열에 소수 구분 기호가 있는지 여부에 따라 &lt;code&gt;Double&lt;/code&gt; 또는 &lt;code&gt;Long&lt;/code&gt; 을 반환할지 여부를 결정 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그렇게하면 다음과 같이 double의 가수에 오버플로되는 정수가 방지됩니다. &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt; 을 정확하게 분석하지 못했습니다 .</target>
        </trans-unit>
        <trans-unit id="900faee5ccc6c44b5dd8cbc004ad0b37fa6413ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones constructed by &lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; for corresponding strings in locale-independent format. The special cases negative and positive infinity and NaN are returned as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the corresponding &lt;code&gt;Double&lt;/code&gt; constants.</source>
          <target state="translated">경우 &lt;code&gt;isParseBigDecimal()&lt;/code&gt; true 인, 값으로 반환됩니다 &lt;code&gt;BigDecimal&lt;/code&gt; 객체. 값은 로케일 독립 형식의 해당 문자열에 대해 &lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 값 입니다. 특수한 경우 음수 및 양수 무한대 및 NaN은 해당 &lt;code&gt;Double&lt;/code&gt; 상수 의 값을 보유하는 &lt;code&gt;Double&lt;/code&gt; 인스턴스 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3991537febb7c383b2b1e9676a6139c310d5f3bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones constructed by &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal.BigDecimal(String)&lt;/code&gt;&lt;/a&gt; for corresponding strings in locale-independent format. The special cases negative and positive infinity and NaN are returned as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the corresponding &lt;code&gt;Double&lt;/code&gt; constants.</source>
          <target state="translated">경우 &lt;code&gt;isParseBigDecimal()&lt;/code&gt; true 인, 값으로 반환됩니다 &lt;code&gt;BigDecimal&lt;/code&gt; 객체. 값은 로케일 독립적 형식의 해당 문자열에 대해 &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal.BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 값 입니다. 특수한 경우 음과 양의 무한대와 NaN은 해당 &lt;code&gt;Double&lt;/code&gt; 상수 의 값을 보유하는 &lt;code&gt;Double&lt;/code&gt; 인스턴스 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad7955d8b155abbd159e8530f81bd04621448d7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;issuerDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a distinguished name, in RFC 2253 format.</source>
          <target state="translated">&lt;code&gt;issuerDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 는 RFC 2253 형식의 식별 명을 포함 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fade5d7398b0a36fb97c29bda07ffec0ca96c5ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;issuerDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">&lt;code&gt;issuerDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 고유 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf8daeb7b51eb9c17c6b351281641b26236105bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;iterator&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; it defaults to a method handle which behaves like &lt;a href=&quot;../iterable#iterator()&quot;&gt;&lt;code&gt;Iterable.iterator()&lt;/code&gt;&lt;/a&gt;. In that case, the internal parameter list &lt;code&gt;(V T A...)&lt;/code&gt; must have at least one &lt;code&gt;A&lt;/code&gt; type, and the default iterator handle parameter is adjusted to accept the leading &lt;code&gt;A&lt;/code&gt; type, as if by the &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; conversion method. The leading &lt;code&gt;A&lt;/code&gt; type must be &lt;code&gt;Iterable&lt;/code&gt; or a subtype thereof. This conversion step, done at loop construction time, must not throw a &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;iterator&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 좋아하는 동작합니다 방법 핸들이 기본적으로 &lt;a href=&quot;../iterable#iterator()&quot;&gt; &lt;code&gt;Iterable.iterator()&lt;/code&gt; &lt;/a&gt; . 이 경우 내부 매개 변수 목록 &lt;code&gt;(V T A...)&lt;/code&gt; 에는 하나 이상의 &lt;code&gt;A&lt;/code&gt; 유형 이 있어야 하며 기본 반복기 핸들 매개 변수는 마치 &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 변환 메소드 에서처럼 선행 &lt;code&gt;A&lt;/code&gt; 유형 을 허용하도록 조정됩니다 . 선행 &lt;code&gt;A&lt;/code&gt; 유형은 &lt;code&gt;Iterable&lt;/code&gt; 또는 그 하위 유형이어야합니다 . 루프 생성 시간에 수행되는이 변환 단계는 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; 을 발생시키지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="bef1d3d13a9d6651764b8de67667b94279a7b1f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a simple &lt;code&gt;npath&lt;/code&gt; is inside a wildcard &lt;code&gt;npath&lt;/code&gt; if and only if &lt;code&gt; simple_npath.relativize(wildcard_npath)&lt;/code&gt; is exactly &quot;..&quot;, a simple &lt;code&gt;npath&lt;/code&gt; is recursively inside a wildcard &lt;code&gt;npath&lt;/code&gt; if and only if &lt;code&gt;simple_npath.relativize(wildcard_npath)&lt;/code&gt; is a series of one or more &quot;..&quot;. This means &quot;/-&quot; implies &quot;/foo&quot; but not &quot;foo&quot;.</source>
          <target state="translated">경우 &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; 가 있다 &lt;code&gt;false&lt;/code&gt; 간단한 &lt;code&gt;npath&lt;/code&gt; 는 와일드 내부 &lt;code&gt;npath&lt;/code&gt; 경우에만, &lt;code&gt; simple_npath.relativize(wildcard_npath)&lt;/code&gt; 정확히 &quot;..&quot;단순 &lt;code&gt;npath&lt;/code&gt; 는 와일드 카드 내부에 반복적 인 &lt;code&gt;npath&lt;/code&gt; 경우에만, &lt;code&gt;simple_npath.relativize(wildcard_npath)&lt;/code&gt; 는 하나 이상의 &quot;..&quot;시리즈입니다. 이것은 &quot;/-&quot;는 &quot;/ foo&quot;를 의미하지만 &quot;foo&quot;는 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa0b8f2907bf5b6de34e006f7a244b928659a30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a simple &lt;code&gt;cpath&lt;/code&gt; is inside a wildcard &lt;code&gt;cpath&lt;/code&gt; if and only if after removing the base name (the last name in the pathname's name sequence) from the former the remaining part equals to the latter, a simple &lt;code&gt;cpath&lt;/code&gt; is recursively inside a wildcard &lt;code&gt;cpath&lt;/code&gt; if and only if the former starts with the latter.</source>
          <target state="translated">경우 &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 간단한 &lt;code&gt;cpath&lt;/code&gt; 와일드 카드 안에 &lt;code&gt;cpath&lt;/code&gt; 경우에만 전자에서 기본 이름 (경로 이름의 이름 순서의 마지막 이름)을 제거한 후 나머지 부분은 후자에 동일한 경우, 간단한 &lt;code&gt;cpath&lt;/code&gt; 전자가 후자로 시작하는 경우에만 와일드 카드 &lt;code&gt;cpath&lt;/code&gt; 내부에 재귀 적으로 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3806db4319c80c008ed8ec50076576313291db5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt;, an &lt;code&gt;Action&lt;/code&gt; is created using the value from the defaults with key &lt;code&gt;key&lt;/code&gt;. The value identifies the sound resource to load when &lt;code&gt;actionPerformed&lt;/code&gt; is invoked on the &lt;code&gt;Action&lt;/code&gt;. The sound resource is loaded into a &lt;code&gt;byte[]&lt;/code&gt; by way of &lt;code&gt;getClass().getResourceAsStream()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 인 &lt;code&gt;non-null&lt;/code&gt; , &lt;code&gt;Action&lt;/code&gt; 키의 디폴트 값을 사용하여 생성되는 &lt;code&gt;key&lt;/code&gt; . 이 값 은 &lt;code&gt;Action&lt;/code&gt; 에서 &lt;code&gt;actionPerformed&lt;/code&gt; 가 호출 될 때로드 할 사운드 리소스를 식별합니다 . 사운드 리소스는 &lt;code&gt;getClass().getResourceAsStream()&lt;/code&gt; 을 통해 &lt;code&gt;byte[]&lt;/code&gt; 에 로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="e51ae0dac7e8d263aae86348d05a6f149420f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded SubjectPublicKeyInfo structure, as defined in X.509. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 , X.509에 정의 된 DER로 encode 된 SubjectPublicKeyInfo 구조체를 포함 할 필요가 있습니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="712b765888f31bac4d2a38f3d4f75895e152c895" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keyBindingList's&lt;/code&gt; length is odd, the last element is ignored.</source>
          <target state="translated">경우 &lt;code&gt;keyBindingList's&lt;/code&gt; 길이가 홀수, 마지막 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="32625fd006abff028ed31d4e842cc2324285bb3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 제로, 다음 바이트를 읽을되지 않고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다; 그렇지 않으면 적어도 1 바이트를 읽으려고 시도합니다. 스트림이 파일의 끝에 있기 때문에 사용 가능한 바이트가 없으면 값 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 적어도 하나의 바이트를 읽고 &lt;code&gt;b&lt;/code&gt; 에 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="8e5aa1bc7a742384a935498942c42e5e07740bdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read up to &lt;code&gt;len&lt;/code&gt; bytes.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 제로, 다음 바이트를 읽을되지 않고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다; 그렇지 않으면 최대 &lt;code&gt;len&lt;/code&gt; 바이트 를 읽으려는 시도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5438d4f7b68e1d94da5051ffd2373361f8220bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is performed.</source>
          <target state="translated">경우 &lt;code&gt;listener&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 예외는 슬로우되지 않고, 처리도 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14cef07d064064c29c7a5fe965b5831e7bd96e0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;locale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the current default &lt;code&gt;Locale&lt;/code&gt; returned by &lt;code&gt;Locale.getLocale&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;locale&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;Locale.getLocale&lt;/code&gt; 에서 반환 한 현재 기본 &lt;code&gt;Locale&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d066008eefc78e3a51bd16c0caf8b74c778d465" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mapper&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;(k) -&amp;gt; ((o, n) -&amp;gt; n)&lt;/code&gt; is assumed.</source>
          <target state="translated">경우 &lt;code&gt;mapper&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt;(k) -&amp;gt; ((o, n) -&amp;gt; n)&lt;/code&gt; 가정한다.</target>
        </trans-unit>
        <trans-unit id="237bb0004c48dd310c68797e03807fbf69feb843" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mapper&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then</source>
          <target state="translated">경우 &lt;code&gt;mapper&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 후,</target>
        </trans-unit>
        <trans-unit id="407e3ad33f33ee6203d55e51347b6733cfed4536" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;markpos&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; (no mark has been set or the mark has been invalidated), an &lt;code&gt;IOException&lt;/code&gt; is thrown. Otherwise, &lt;code&gt;pos&lt;/code&gt; is set equal to &lt;code&gt;markpos&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;markpos&lt;/code&gt; 가 있다 &lt;code&gt;-1&lt;/code&gt; (더 마크가 설정되어 있지 않은 또는 표시가 무효화되었습니다), &lt;code&gt;IOException&lt;/code&gt; 이가 발생합니다. 그렇지 않으면 &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;markpos&lt;/code&gt; 와 동일하게 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad329c08ba7e98db38c9c94383d0c1a4b4e1d823" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mechanism&lt;/code&gt; is listed in the &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; security property, it will be ignored and this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;mechanism&lt;/code&gt; 에 나열되어 &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; 의 보안 속성 무시하고이 방법 반환됩니다 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb5428935fd216a01577def3121a1bf636692f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;message&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;message&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f2493ae9d005a4929a69f19605e63b6eba077d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;method&lt;/code&gt; is one of the following methods, it is processed as described below:</source>
          <target state="translated">경우 &lt;code&gt;method&lt;/code&gt; 다음 방법 중 하나 후술하는 바와 같이, 이것은 처리 :</target>
        </trans-unit>
        <trans-unit id="80272f80ea0d9272e8e3872b8249981af2f99944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;method&lt;/code&gt; overrides &lt;a href=&quot;../../../../java.base/java/lang/object#finalize()&quot;&gt;&lt;code&gt;Object.finalize&lt;/code&gt;&lt;/a&gt;, it is ignored.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; 가 &lt;a href=&quot;../../../../java.base/java/lang/object#finalize()&quot;&gt; &lt;code&gt;Object.finalize&lt;/code&gt; 를&lt;/a&gt; 재정의 하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e54e6c513d26ba9e689c9210d9c6fc20b9490552" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method clears the current &lt;code&gt;ColorModel&lt;/code&gt; of this &lt;code&gt;BufferedImageFilter&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 방법은 현재 클리어 &lt;code&gt;ColorModel&lt;/code&gt; 이의 &lt;code&gt;BufferedImageFilter&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0c2e23895c3bfb12eba7ee751967501b320f0652" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;moduleAndPkg&lt;/code&gt; contains a &quot;&lt;code&gt;/&lt;/code&gt;&quot; character, the prefix before the &quot;&lt;code&gt;/&lt;/code&gt;&quot; character is the module name and the suffix after the &quot;&lt;code&gt;/&lt;/code&gt;&quot; character is the package name. The package suffix may be empty; however, if a module name is present, it must be nonempty. If &lt;code&gt;moduleAndPkg&lt;/code&gt; does not contain a &quot;&lt;code&gt;/&lt;/code&gt;&quot; character, the entire argument is interpreted as a package name.</source>
          <target state="translated">경우 &lt;code&gt;moduleAndPkg&lt;/code&gt; 이 에 &quot;포함 &lt;code&gt;/&lt;/code&gt; &quot;문자는 &quot;앞에 접두사 &lt;code&gt;/&lt;/code&gt; &quot;문자는 모듈 이름이며, &quot;뒤에 접미사 &lt;code&gt;/&lt;/code&gt; &quot;문자는 패키지 이름입니다. 패키지 접미사는 비어있을 수 있습니다. 그러나 모듈 이름이있는 경우 비어 있지 않아야합니다. 경우 &lt;code&gt;moduleAndPkg&lt;/code&gt; 이 는 &quot;이 포함되어 있지 않습니다 &lt;code&gt;/&lt;/code&gt; &quot;문자를 전체 인수는 패키지 이름으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="264bd5ff686dc149927060f95422b38db18ee5ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ms &amp;gt; 0&lt;/code&gt;, waits until all pixels are delivered as timeout expires.</source>
          <target state="translated">경우 &lt;code&gt;ms &amp;gt; 0&lt;/code&gt; , 모든 픽셀까지 대기가 전달되는 시간 제한이 만료한다.</target>
        </trans-unit>
        <trans-unit id="b27bb44e815edaa410b82b8a519582447426eeeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ms &amp;lt; 0&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt; if all pixels are grabbed, &lt;code&gt;false&lt;/code&gt; otherwise and does not wait.</source>
          <target state="translated">경우 &lt;code&gt;ms &amp;lt; 0&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; 모든 픽셀 잡고하는 경우, &lt;code&gt;false&lt;/code&gt; , 그렇지 및 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="037e3456b138d91962ada484f36e147f33a6541b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ms == 0&lt;/code&gt;, waits until all pixels are delivered</source>
          <target state="translated">경우 &lt;code&gt;ms == 0&lt;/code&gt; , 모든 픽셀 때까지 기다립니다 전달</target>
        </trans-unit>
        <trans-unit id="14625748855476ca64ac0e0ad4823a75fd7ff91e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is &lt;code&gt;name&lt;/code&gt;. Therefore, this method cannot be used to obtain any of the &lt;code&gt;Class&lt;/code&gt; objects representing primitive types or void.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이 프리미티브 유형을 나타내거나 void 인 경우 이름 이없는 패키지에서 name이 &lt;code&gt;name&lt;/code&gt; 인 사용자 정의 클래스를 찾으려고 시도 합니다. 따라서이 메소드를 사용하여 기본 유형 또는 void를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체 를 얻을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="426264473ef88575d36cf8a0d5508390a0fa058c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; denotes an array class, the component type of the array class is loaded but not initialized.</source>
          <target state="translated">경우 &lt;code&gt;name&lt;/code&gt; 배열 클래스를 나타내며, 어레이 클래스의 컴포넌트 유형은로드되었지만 초기화되지 않는다.</target>
        </trans-unit>
        <trans-unit id="33ac51e088b5d11aa55931b104e2ffe194b82871" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; does not name an MBean, this method throws &lt;a href=&quot;instancenotfoundexception&quot;&gt;&lt;code&gt;InstanceNotFoundException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">name이 MBean의 이름을 &lt;code&gt;name&lt;/code&gt; 하지 않는 경우 ,이 메소드는 &lt;a href=&quot;instancenotfoundexception&quot;&gt; &lt;code&gt;InstanceNotFoundException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="31a1346ae62f4c960e5aaf99e30947fb827be94b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is empty, returns a new instance of this context (which represents the same naming context as this context, but its environment may be modified independently and it may be accessed concurrently).</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이 비어 있으면 이 컨텍스트의 새 인스턴스를 리턴합니다 (이 컨텍스트와 동일한 이름 지정 컨텍스트를 나타내지 만 환경은 독립적으로 수정 될 수 있으며 동시에 액세스 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="a4300c4d88a600996e56c3b7c63fa1bc6c68c8b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;newChild&lt;/code&gt; is a &lt;code&gt;DocumentFragment&lt;/code&gt; object, &lt;code&gt;oldChild&lt;/code&gt; is replaced by all of the &lt;code&gt;DocumentFragment&lt;/code&gt; children, which are inserted in the same order. If the &lt;code&gt;newChild&lt;/code&gt; is already in the tree, it is first removed.</source>
          <target state="translated">경우 &lt;code&gt;newChild&lt;/code&gt; A는 &lt;code&gt;DocumentFragment&lt;/code&gt; 가의 객체, &lt;code&gt;oldChild&lt;/code&gt; 를는 의 모든으로 대체됩니다 &lt;code&gt;DocumentFragment&lt;/code&gt; 가에 같은 순서로 삽입 아이들. 는 IF &lt;code&gt;newChild&lt;/code&gt; 트리에 이미이를 먼저 제거된다.</target>
        </trans-unit>
        <trans-unit id="8fda31fb895f12fd65525af110d36c4f0062c17e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;newChild&lt;/code&gt; is a &lt;code&gt;DocumentFragment&lt;/code&gt; object, all of its children are inserted, in the same order, before &lt;code&gt;refChild&lt;/code&gt;. If the &lt;code&gt;newChild&lt;/code&gt; is already in the tree, it is first removed.</source>
          <target state="translated">경우 &lt;code&gt;newChild&lt;/code&gt; A는 &lt;code&gt;DocumentFragment&lt;/code&gt; 가의 목적은, 모든 자식 전에, 같은 순서로, 삽입 &lt;code&gt;refChild&lt;/code&gt; 의 . 는 IF &lt;code&gt;newChild&lt;/code&gt; 트리에 이미이를 먼저 제거된다.</target>
        </trans-unit>
        <trans-unit id="b9a6fbecabc4d75c8cb3a22604105c27e3ceaf7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; also implements &lt;a href=&quot;../descriptorread&quot;&gt;&lt;code&gt;DescriptorRead&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;../descriptorread#getDescriptor()&quot;&gt;&lt;code&gt;getDescriptor()&lt;/code&gt;&lt;/a&gt; method must also return the same value as for this object.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 또한 구현 &lt;a href=&quot;../descriptorread&quot;&gt; &lt;code&gt;DescriptorRead&lt;/code&gt; 를&lt;/a&gt; 다음의 &lt;a href=&quot;../descriptorread#getDescriptor()&quot;&gt; &lt;code&gt;getDescriptor()&lt;/code&gt; &lt;/a&gt; 메소드는이 오브젝트와 동일한 값을 반환한다.</target>
        </trans-unit>
        <trans-unit id="9da71f6612d3d5ce3b22299926128ecddac8e404" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; also implements &lt;a href=&quot;../descriptorread&quot;&gt;&lt;code&gt;DescriptorRead&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;../descriptorread#getDescriptor--&quot;&gt;&lt;code&gt;getDescriptor()&lt;/code&gt;&lt;/a&gt; method must also return the same value as for this object.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 또한 구현 &lt;a href=&quot;../descriptorread&quot;&gt; &lt;code&gt;DescriptorRead&lt;/code&gt; 를&lt;/a&gt; 다음의 &lt;a href=&quot;../descriptorread#getDescriptor--&quot;&gt; &lt;code&gt;getDescriptor()&lt;/code&gt; &lt;/a&gt; 메소드는이 오브젝트와 동일한 값을 반환한다.</target>
        </trans-unit>
        <trans-unit id="e91688719b84d5b134a62a7edfd802aae113078d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is a URL string, create an object (typically a context) identified by the URL. For example, suppose this is an LDAP URL context factory. If &lt;code&gt;obj&lt;/code&gt; is &quot;ldap://ldap.wiz.com/o=wiz,c=us&quot;, getObjectInstance() would return the context named by the distinguished name &quot;o=wiz, c=us&quot; at the LDAP server ldap.wiz.com. This context can then be used to resolve LDAP names (such as &quot;cn=George&quot;) relative to that context.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 URL 캐릭터 라인의 URL에 의해 식별되는 객체 (일반적으로 컨텍스트)를 생성합니다. 예를 들어, 이것이 LDAP URL 컨텍스트 팩토리라고 가정하십시오. 경우 &lt;code&gt;obj&lt;/code&gt; 가 있다 &quot;LDAP : //ldap.wiz.com/o=wiz,c=us&quot;로 getObjectInstance () &quot;우리 = 대단한, C = O&quot;LDAP 서버에서 LDAP 고유 이름에 의해 명명 된 컨텍스트를 반환합니다. wiz.com. 그런 다음이 컨텍스트를 사용하여 해당 컨텍스트와 관련된 LDAP 이름 (예 : &quot;cn = George&quot;)을 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32945fa108fdfdcbdbc1bca10a08bd1d1b6d1907" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is an array of URL strings, the assumption is that the URLs are equivalent in terms of the context to which they refer. Verification of whether the URLs are, or need to be, equivalent is up to the context factory. The order of the URLs in the array is not significant. The object returned by getObjectInstance() is like that of the single URL case. It is the object named by the URLs.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 URL 문자열의 배열입니다, 가정은 URL이가 참조되는 맥락의 측면에서 동일 점이다. URL이 동등한 지 또는 필요한지를 검증하는 것은 컨텍스트 팩토리에 달려 있습니다. 배열에서 URL의 순서는 중요하지 않습니다. getObjectInstance ()에 의해 리턴 된 오브젝트는 단일 URL 케이스의 오브젝트와 유사합니다. URL로 명명 된 개체입니다.</target>
        </trans-unit>
        <trans-unit id="a6602e383de5967e74ad68c0b9673a5a019fb76c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should be a primitive array of type &lt;code&gt;TransferType&lt;/code&gt;. Otherwise, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown. An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if the coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; and is not large enough to hold the pixel data.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 &lt;code&gt;TransferType&lt;/code&gt; 유형의 기본 배열이어야합니다 . 그렇지 않으면 &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다. &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 가 좌표가 경계 내에없는 경우에 슬로우, 또는 될 수있는 경우 &lt;code&gt;obj&lt;/code&gt; 가 아닌 &lt;code&gt;null&lt;/code&gt; 및 픽셀 데이터를 보유 할 충분한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b15b227abfe354ba6f8da5faaa4e98ce43464a60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should be a primitive array of type TransferType. Otherwise, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown. An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; and is not large enough to hold the pixel data.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 아닌 &lt;code&gt;null&lt;/code&gt; , transferType 형태의 원시적 배열한다. 그렇지 않으면 &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다. &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 가 좌표가 경계 내에없는 경우에 슬로우 경우 또는 &lt;code&gt;obj&lt;/code&gt; 가 아닌 &lt;code&gt;null&lt;/code&gt; 및 픽셀 데이터를 보유 할 충분한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1aa9408c35607b4446b25efa8c3b62e3cb06a3e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is null, create a context for resolving URLs of the scheme associated with this factory. The resulting context is not tied to a specific URL: it is able to handle arbitrary URLs with this factory's scheme id. For example, invoking &lt;code&gt;getObjectInstance()&lt;/code&gt; with &lt;code&gt;obj&lt;/code&gt; set to null on an LDAP URL context factory would return a context that can resolve LDAP URLs such as &quot;ldap://ldap.wiz.com/o=wiz,c=us&quot; and &quot;ldap://ldap.umich.edu/o=umich,c=us&quot;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 null 인 경우 ,이 팩토리에 관련된 체계의 URL을 해결하기위한 컨텍스트를 작성하십시오. 결과 컨텍스트는 특정 URL에 연결되지 않습니다.이 팩토리의 스키마 ID를 사용하여 임의의 URL을 처리 할 수 ​​있습니다. 예를 들어 LDAP URL 컨텍스트 팩토리에서 &lt;code&gt;obj&lt;/code&gt; 가 null로 설정된 &lt;code&gt;getObjectInstance()&lt;/code&gt; 를 호출 하면 &quot;ldap : //ldap.wiz.com/o=wiz,c=us&quot;및 &quot;LDAP&quot;와 같은 LDAP URL을 해석 할 수있는 컨텍스트가 리턴됩니다. ldap : //ldap.umich.edu/o=umich,c=us &quot;.</target>
        </trans-unit>
        <trans-unit id="ec1a4fe48f2a096cb276495abb05e869b10eb3e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is of any other type, the behavior of &lt;code&gt;getObjectInstance()&lt;/code&gt; is determined by the context factory implementation.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 다른 유형 인의 행위 &lt;code&gt;getObjectInstance()&lt;/code&gt; 컨텍스트 팩토리 구현에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f8bc9645ac7697c4ff55e25f0175b71947d108" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; is a &lt;a href=&quot;../../../java/lang/class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; that implements &lt;code&gt;interfaceName&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt; is returned downcast to type &lt;a href=&quot;../../../java/lang/class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;; otherwise an exception is thrown.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 가 &lt;code&gt;interfaceName&lt;/code&gt; 를 구현 하는 &lt;a href=&quot;../../../java/lang/class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; 의&lt;/a&gt; 경우 , &lt;code&gt;object&lt;/code&gt; 는 &lt;a href=&quot;../../../java/lang/class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 형에 다운 캐스트됩니다 . 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9eb2deae4cbfdfe775a6fd21ec7ae0a0f4b83da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; is an instance of &lt;code&gt;interfaceName&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt; is returned downcast to type &lt;a href=&quot;attribute&quot;&gt;&lt;code&gt;Attribute&lt;/code&gt;&lt;/a&gt;; otherwise an exception is thrown.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 가 &lt;code&gt;interfaceName&lt;/code&gt; 의 인스턴스 인 경우 , &lt;code&gt;object&lt;/code&gt; 는 &lt;a href=&quot;attribute&quot;&gt; &lt;code&gt;Attribute&lt;/code&gt; &lt;/a&gt; 형으로 다운 캐스트됩니다 . 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1c8f73d41108e88b12d37509a1209cf7ee237a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;off&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off+len&lt;/code&gt; is greater than the length of the array &lt;code&gt;b&lt;/code&gt;, then an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;off&lt;/code&gt; 음수 또는 &lt;code&gt;len&lt;/code&gt; 음수 또는 &lt;code&gt;off+len&lt;/code&gt; 어레이의 길이보다 큰 경우 &lt;code&gt;b&lt;/code&gt; , 다음 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="6f916136c09ba20fe608884bc6b34b5a0a8ea28c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optionType&lt;/code&gt; is &lt;code&gt;YES_NO_OPTION&lt;/code&gt;, or &lt;code&gt;YES_NO_CANCEL_OPTION&lt;/code&gt; and the &lt;code&gt;options&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, then the options are supplied by the Look and Feel.</source>
          <target state="translated">경우 &lt;code&gt;optionType&lt;/code&gt; 있다 &lt;code&gt;YES_NO_OPTION&lt;/code&gt; 또는 &lt;code&gt;YES_NO_CANCEL_OPTION&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 인 매개 변수 &lt;code&gt;null&lt;/code&gt; , 다음 옵션은 모양과 느낌에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="700e8398ef8d2ca991374c2cd5c61cb5ec47b634" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optionType&lt;/code&gt; is &lt;code&gt;YES_NO_OPTION&lt;/code&gt;, or &lt;code&gt;YES_NO_CANCEL_OPTION&lt;/code&gt; and the &lt;code&gt;options&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, then the options are supplied by the look and feel.</source>
          <target state="translated">경우 &lt;code&gt;optionType&lt;/code&gt; 있다 &lt;code&gt;YES_NO_OPTION&lt;/code&gt; 또는 &lt;code&gt;YES_NO_CANCEL_OPTION&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 인 매개 변수 &lt;code&gt;null&lt;/code&gt; , 다음 옵션은 모양과 느낌에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4fdd88cb8f430b71b6c946c7cb4a475103672c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;orders&lt;/code&gt; is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a stream containing all the line items in all the orders:</source>
          <target state="translated">경우 &lt;code&gt;orders&lt;/code&gt; 구매 주문의 흐름이며, 각 구매 주문 라인 항목의 컬렉션을 포함, 그 다음은 모든 주문의 모든 광고 항목이 포함 된 스트림을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="dc1e542a49fcca8372c3f1e72acb2239503c5a25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;output.remaining()&lt;/code&gt; 바이트가 결과를 보관 유지하는데 불충분하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b021403fe5efad5b861bd19c30c59be586bb654" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#getOutputSize(int)&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">&lt;code&gt;output.remaining()&lt;/code&gt; 바이트가 결과를 보유하기에 충분하지 않으면 &lt;code&gt;ShortBufferException&lt;/code&gt; 이 발생합니다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;#getOutputSize(int)&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼의 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="84d8cee5c4a220d78576a202ebce821b35cedb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">경우 &lt;code&gt;output.remaining()&lt;/code&gt; 바이트가 결과를 보관 유지하는데 불충분하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생합니다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f043acbc87ab351734e5aed1db463393096cbfa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; is an &lt;code&gt;ImageOutputStream&lt;/code&gt;, calls to the &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeToSequence&lt;/code&gt;, and &lt;code&gt;prepareWriteEmpty&lt;/code&gt;/&lt;code&gt;endWriteEmpty&lt;/code&gt; methods will preserve the existing contents of the stream. Other write methods, such as &lt;code&gt;writeInsert&lt;/code&gt;, &lt;code&gt;replaceStreamMetadata&lt;/code&gt;, &lt;code&gt;replaceImageMetadata&lt;/code&gt;, &lt;code&gt;replacePixels&lt;/code&gt;, &lt;code&gt;prepareInsertEmpty&lt;/code&gt;/&lt;code&gt;endInsertEmpty&lt;/code&gt;, and &lt;code&gt;endWriteSequence&lt;/code&gt;, require the full contents of the stream to be readable and writable, and may alter any portion of the stream.</source>
          <target state="translated">&lt;code&gt;output&lt;/code&gt; 이 &lt;code&gt;ImageOutputStream&lt;/code&gt; 인 경우 , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeToSequence&lt;/code&gt; 및 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; / &lt;code&gt;endWriteEmpty&lt;/code&gt; 메소드 에 대한 호출 은 스트림의 기존 컨텐츠를 보존합니다. 같은 다른 기록 방법 &lt;code&gt;writeInsert&lt;/code&gt; , &lt;code&gt;replaceStreamMetadata&lt;/code&gt; , &lt;code&gt;replaceImageMetadata&lt;/code&gt; , &lt;code&gt;replacePixels&lt;/code&gt; , &lt;code&gt;prepareInsertEmpty&lt;/code&gt; / &lt;code&gt;endInsertEmpty&lt;/code&gt; 및 &lt;code&gt;endWriteSequence&lt;/code&gt; 는 , 스트림의 전체 내용을 읽고 쓰기 가능하고, 스트림의 임의의 부분을 변경할 필요있다.</target>
        </trans-unit>
        <trans-unit id="e8efb2d341a19b3a0630891bb7481cba8f49a495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;param&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or the above steps have not yielded an image or an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;, the first value obtained from the &lt;code&gt;imageTypes&lt;/code&gt; parameter is used. Typically, the caller will set &lt;code&gt;imageTypes&lt;/code&gt; to the value of &lt;code&gt;getImageTypes(imageIndex)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;param&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 또는 상기 단계는 이미지 또는 산출하지 &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; 가 상기에서 얻어진 첫 번째 값 &lt;code&gt;imageTypes&lt;/code&gt; 사용되는 파라미터. 일반적으로 호출자는 &lt;code&gt;imageTypes&lt;/code&gt; 를 &lt;code&gt;getImageTypes(imageIndex)&lt;/code&gt; 값으로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="12c0e44f695a02a0e0c1cf51002f7968c10d35bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params.getCipherSuites()&lt;/code&gt; is non-null, &lt;code&gt;setEnabledCipherSuites()&lt;/code&gt; is called with that value.</source>
          <target state="translated">경우 &lt;code&gt;params.getCipherSuites()&lt;/code&gt; null 이외이다 &lt;code&gt;setEnabledCipherSuites()&lt;/code&gt; 그 값으로 호출된다.</target>
        </trans-unit>
        <trans-unit id="4301233809b8c6e0214fe220a512fcb9eb677755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params.getNeedClientAuth()&lt;/code&gt; or &lt;code&gt;params.getWantClientAuth()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;setNeedClientAuth(true)&lt;/code&gt; and &lt;code&gt;setWantClientAuth(true)&lt;/code&gt; are called, respectively; otherwise &lt;code&gt;setWantClientAuth(false)&lt;/code&gt; is called.</source>
          <target state="translated">경우 &lt;code&gt;params.getNeedClientAuth()&lt;/code&gt; 또는 &lt;code&gt;params.getWantClientAuth()&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;setNeedClientAuth(true)&lt;/code&gt; 와 &lt;code&gt;setWantClientAuth(true)&lt;/code&gt; 각각라고; 그렇지 않으면 &lt;code&gt;setWantClientAuth(false)&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5dc9bed100bed19e8adfc8e9302ad1262864c82f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params.getProtocols()&lt;/code&gt; is non-null, &lt;code&gt;setEnabledProtocols()&lt;/code&gt; is called with that value.</source>
          <target state="translated">&lt;code&gt;params.getProtocols()&lt;/code&gt; 가 널이 아닌 경우 해당 값으로 &lt;code&gt;setEnabledProtocols()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="477f25588563362cacb627b17133335ce391a72c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params.getSNIMatchers()&lt;/code&gt; is non-null, the engine will configure its SNI matchers with that value.</source>
          <target state="translated">경우 &lt;code&gt;params.getSNIMatchers()&lt;/code&gt; null이 아닌, 엔진은 그 값과의 SNI 매처 (matcher)를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="799d996f3532ac2b9dac7ce11be2fa83700e6665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params.getSNIMatchers()&lt;/code&gt; is non-null, the socket will configure its SNI matchers with that value.</source>
          <target state="translated">경우 &lt;code&gt;params.getSNIMatchers()&lt;/code&gt; null 이외의 소켓은 그 값과의 SNI 매처 (matcher)를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d68acdf564188e7ceaa402d78c141e40ba803119" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params.getServerNames()&lt;/code&gt; is non-null, the engine will configure its server names with that value.</source>
          <target state="translated">경우 &lt;code&gt;params.getServerNames()&lt;/code&gt; null 이외는, 엔진은 그 값의 서버 이름을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f3b5eca36dcc4e54ec46277b9ac0712351942ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params.getServerNames()&lt;/code&gt; is non-null, the socket will configure its server names with that value.</source>
          <target state="translated">경우 &lt;code&gt;params.getServerNames()&lt;/code&gt; null 이외는, 소켓은 그 값의 서버 이름을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="5d3cebc72399735c7028c3947622a912c96f3867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a default read param will be used for all images.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 모든 이미지에 기본 읽기 매개 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="164da61ede6423d7452b5925f00510b40a4ff9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the new &lt;code&gt;File&lt;/code&gt; instance is created as if by invoking the single-argument &lt;code&gt;File&lt;/code&gt; constructor on the given &lt;code&gt;child&lt;/code&gt; pathname string.</source>
          <target state="translated">경우 &lt;code&gt;parent&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; 다음 새 &lt;code&gt;File&lt;/code&gt; 인스턴스는 하나의 인수를 호출하는 것처럼 만든 &lt;code&gt;File&lt;/code&gt; 주어진에 생성자를 &lt;code&gt;child&lt;/code&gt; 패스 명 문자열.</target>
        </trans-unit>
        <trans-unit id="dc8d5e6586d766794fde25c90e2efcfa3efd1a6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is the path to a file, then the following produces a stream of the &lt;code&gt;words&lt;/code&gt; contained in that file:</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 파일의 경로 인 경우 다음은 해당 파일에 포함 된 &lt;code&gt;words&lt;/code&gt; 의 스트림을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="a03ee7e8529525f1d22d51655d541d0ee465a7a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;popup&lt;/code&gt; is null, and &lt;code&gt;getInheritsPopupMenu&lt;/code&gt; returns true, then &lt;code&gt;getComponentPopupMenu&lt;/code&gt; will be delegated to the parent. This provides for a way to make all child components inherit the popupmenu of the parent.</source>
          <target state="translated">경우 &lt;code&gt;popup&lt;/code&gt; 널 (null)이며, &lt;code&gt;getInheritsPopupMenu&lt;/code&gt; 가 true를 반환하고, 다음 &lt;code&gt;getComponentPopupMenu&lt;/code&gt; 가 부모에게 위임됩니다. 이것은 모든 자식 구성 요소가 부모의 팝업 메뉴를 상속하도록하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bc7971a45b4c8a0415fc982c79c19ec96e7fd238" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted string will be returned.</source>
          <target state="translated">경우 &lt;code&gt;pos&lt;/code&gt; 가 null가 아닌,을 의미하고 &lt;code&gt;Field.ARGUMENT&lt;/code&gt; , 최초의 포맷 된 문자열의 위치가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a60a9d806b7d757c47a033e228e73c85243699ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or invalid, no exception is thrown and no action is taken.</source>
          <target state="translated">경우 &lt;code&gt;propertyName&lt;/code&gt; 형식 또는 &lt;code&gt;listener&lt;/code&gt; 있습니다 &lt;code&gt;null&lt;/code&gt; 또는 무효, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da632f0b344946ea9b5f1aa47e37fb7b4a7642b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is taken.</source>
          <target state="translated">경우 &lt;code&gt;propertyName&lt;/code&gt; 형식 또는 &lt;code&gt;listener&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99c505c662d5ba404c469fac648652d0acd78c4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;provider&lt;/code&gt; implements the &lt;code&gt;RegisterableService&lt;/code&gt; interface, its &lt;code&gt;onDeregistration&lt;/code&gt; method will be called.</source>
          <target state="translated">경우 &lt;code&gt;provider&lt;/code&gt; 구현하는 &lt;code&gt;RegisterableService&lt;/code&gt; 의 인터페이스, 그 &lt;code&gt;onDeregistration&lt;/code&gt; 의 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cdaa1756b63c97e31b5453fc52eecff803807ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;provider&lt;/code&gt; implements the &lt;code&gt;RegisterableService&lt;/code&gt; interface, its &lt;code&gt;onRegistration&lt;/code&gt; method will be called once for each category it is registered under. Its &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time it is deregistered from a category or when the registry is finalized.</source>
          <target state="translated">경우 &lt;code&gt;provider&lt;/code&gt; 구현 &lt;code&gt;RegisterableService&lt;/code&gt; 의 인터페이스, 그 &lt;code&gt;onRegistration&lt;/code&gt; 의 메소드가 등록되는 각 카테고리 한번 호출된다. 그 &lt;code&gt;onDeregistration&lt;/code&gt; 의 방법은이 범주하거나 레지스트리가 완료됩니다로부터 등록 해제 될 때마다 불려갑니다.</target>
        </trans-unit>
        <trans-unit id="0784a0a7bf824430bc838bc404fb08f17c2bb553" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;provider&lt;/code&gt; implements the &lt;code&gt;RegisterableService&lt;/code&gt; interface, its &lt;code&gt;onRegistration&lt;/code&gt; method will be called. Its &lt;code&gt;onDeregistration&lt;/code&gt; method will be called each time it is deregistered from a category, for example if a category is removed or the registry is garbage collected.</source>
          <target state="translated">경우 &lt;code&gt;provider&lt;/code&gt; 구현하는 &lt;code&gt;RegisterableService&lt;/code&gt; 의 인터페이스, 그 &lt;code&gt;onRegistration&lt;/code&gt; 의 메소드가 호출됩니다. 그 &lt;code&gt;onDeregistration&lt;/code&gt; 의 범주가 제거되면 방법은 예를 들어,이 범주에서 등록 해제 될 때마다 호출됩니다 또는 레지스트리 쓰레기 수집입니다.</target>
        </trans-unit>
        <trans-unit id="f06c2b9a81bf2e8537aa79d7c76106a244c8674c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;proxy&lt;/code&gt; is not an instance of the interface &lt;a href=&quot;../remote&quot;&gt;&lt;code&gt;Remote&lt;/code&gt;&lt;/a&gt;, then an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;proxy&lt;/code&gt; 인터페이스의 인스턴스가 아닌 &lt;a href=&quot;../remote&quot;&gt; &lt;code&gt;Remote&lt;/code&gt; &lt;/a&gt; , 다음 &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="30a704bc2a41ccd6a295a4a304ab52480277f796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new &lt;code&gt;Point2D&lt;/code&gt; object is allocated and then the result of the transform is stored in this object. In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the transformed point, is returned for convenience. If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same object, the input point is correctly overwritten with the transformed point.</source>
          <target state="translated">경우 &lt;code&gt;ptDst&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 새 &lt;code&gt;Point2D&lt;/code&gt; 객체 할당하고 변환의 결과는,이 오브젝트에 저장된다. 두 경우 모두 편의를 위해 변환 된 점을 포함하는 &lt;code&gt;ptDst&lt;/code&gt; 가 반환됩니다. 경우 &lt;code&gt;ptSrc&lt;/code&gt; 를 하고 &lt;code&gt;ptDst&lt;/code&gt; 동일한 목적이며, 입력 점은 변화 점으로 겹쳐있다.</target>
        </trans-unit>
        <trans-unit id="6b70be6c1d4b8c38fadd2d92229b8b5af1f296d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;refInfo&lt;/code&gt; is a &lt;code&gt;Reference&lt;/code&gt; or &lt;code&gt;Referenceable&lt;/code&gt; containing a factory class name, use the named factory to create the object. Return &lt;code&gt;refInfo&lt;/code&gt; if the factory cannot be created. Under JDK 1.1, if the factory class must be loaded from a location specified in the reference, a &lt;code&gt;SecurityManager&lt;/code&gt; must have been installed or the factory creation will fail. If an exception is encountered while creating the factory, it is passed up to the caller.</source>
          <target state="translated">경우 &lt;code&gt;refInfo&lt;/code&gt; A는 &lt;code&gt;Reference&lt;/code&gt; 또는 &lt;code&gt;Referenceable&lt;/code&gt; 공장 클래스 이름을 포함하는 객체를 생성하기 위해 명명 된 공장을 사용합니다. 팩토리를 작성할 수없는 경우 &lt;code&gt;refInfo&lt;/code&gt; 를 리턴 하십시오 . JDK 1.1에서 팩토리 클래스를 참조에 지정된 위치에서로드 해야하는 경우 &lt;code&gt;SecurityManager&lt;/code&gt; 가 설치되어 있거나 팩토리 작성에 실패합니다. 팩토리를 생성하는 동안 예외가 발생하면 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="46e2f36cf5a69a7659eccf53bd7e3c068ad15127" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;refInfo&lt;/code&gt; is a &lt;code&gt;Reference&lt;/code&gt; or &lt;code&gt;Referenceable&lt;/code&gt; with no factory class name, and the address or addresses are &lt;code&gt;StringRefAddr&lt;/code&gt;s with address type &quot;URL&quot;, try the URL context factory corresponding to each URL's scheme id to create the object (see &lt;code&gt;getURLContext()&lt;/code&gt;). If that fails, continue to the next step.</source>
          <target state="translated">경우 &lt;code&gt;refInfo&lt;/code&gt; A는 &lt;code&gt;Reference&lt;/code&gt; 또는 &lt;code&gt;Referenceable&lt;/code&gt; 어떤 팩토리 클래스의 이름 및 주소 또는 주소가 &lt;code&gt;StringRefAddr&lt;/code&gt; 주소 유형 &quot;URL&quot;로들, 객체를 생성하는 각 URL의 schema ID에 대응하는 URL 문맥 팩토리를 시도합니다 ( &lt;code&gt;getURLContext()&lt;/code&gt; ). 실패하면 다음 단계를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="1c155ad46a4245a542e0a856a2e04822b42fb9f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;returnType&lt;/code&gt; is not one of the types defined in &lt;a href=&quot;xpathconstants&quot;&gt;&lt;code&gt;XPathConstants&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;returnType&lt;/code&gt; 이가 에 정의 된 유형 중 하나가 아닌 &lt;a href=&quot;xpathconstants&quot;&gt; &lt;code&gt;XPathConstants&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="d860614074042f19bdf291701426974c3c57e4a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;row&lt;/code&gt; is &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt; this will have no effect.</source>
          <target state="translated">경우 &lt;code&gt;row&lt;/code&gt; 의 &amp;lt;0&amp;gt; = &lt;code&gt;getRowCount&lt;/code&gt; 이 효과가 없을 것이다.</target>
        </trans-unit>
        <trans-unit id="876d8a672b3c54e715d8e73f684241ce161aa28e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s.length&lt;/code&gt; 가 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 문자 &lt;code&gt;s[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;s[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 문자는 &lt;code&gt;s[s.length-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9e4b1baa5111d66d53cd12fc271e18655498ac09" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, one byte is written, the low-order byte, in exactly the manner of the &lt;code&gt;writeByte&lt;/code&gt; method . The high-order eight bits of each character in the string are ignored.</source>
          <target state="translated">경우 &lt;code&gt;s.length&lt;/code&gt; 가 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 문자 &lt;code&gt;s[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;s[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 문자는 &lt;code&gt;s[s.length-1]&lt;/code&gt; 입니다. 각 문자에 대해 &lt;code&gt;writeByte&lt;/code&gt; 메소드 와 정확히 같은 방식으로 하위 바이트 인 1 바이트가 기록 됩니다. 문자열에서 각 문자의 상위 8 비트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="edcdda7ec2d8edbea83d4e8f71c2458f937626bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, one byte is written, the low-order byte, in exactly the manner of the &lt;code&gt;writeByte&lt;/code&gt; method. The high-order eight bits of each character in the string are ignored.</source>
          <target state="translated">경우 &lt;code&gt;s.length&lt;/code&gt; 가 제로, 다음, 바이트가 기록되지 않습니다. 그렇지 않으면 문자 &lt;code&gt;s[0]&lt;/code&gt; 이 먼저 기록 된 다음 &lt;code&gt;s[1]&lt;/code&gt; 등 이 기록 됩니다. 마지막으로 쓴 문자는 &lt;code&gt;s[s.length-1]&lt;/code&gt; 입니다. 각 문자에 대해 정확히 &lt;code&gt;writeByte&lt;/code&gt; 메서드 와 같은 방식으로 하위 바이트 인 1 바이트가 기록 됩니다. 문자열에서 각 문자의 상위 8 비트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e875e2a67d01ff828275b31d43c1fbd127c980d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="44817af6998c4077db388be5b4a7890f5a06339e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are appended.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; , 4 개 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="990d1368ff7f5774e8459cd4e9be500eb83cc4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are inserted into this sequence.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 , 이 순서에 4 개의 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="b05ca4901f2ddfb6f0df8f458f94e1208be8876d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method appends characters as if the s parameter was a sequence containing the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 ,이 메소드는 s 파라미터가 4 개의 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 를 포함한 순서 인 것처럼 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f17a7925b555b07f1177d7e0b04970042d705c0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method inserts characters as if the s parameter was a sequence containing the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 ,이 메소드는 s 파라미터가 4 개의 문자 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 을 포함한 순서 인 것처럼 문자를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="9aac27d78dce887df2392eaea3ecd3f3fa4c1f8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setDestinationOffsets&lt;/code&gt; has not been called, a &lt;code&gt;Point&lt;/code&gt; with zero X and Y values is returned (which is the correct value).</source>
          <target state="translated">경우 &lt;code&gt;setDestinationOffsets&lt;/code&gt; 가 호출되지하는 &lt;code&gt;Point&lt;/code&gt; 제로의 X 및 Y 값은 (올바른 값이다)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="f3a9e603b0a4b8521e4750e1c066ac967b23512c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 0 is returned (which is the correct value).</source>
          <target state="translated">&lt;code&gt;setSourceSubsampling&lt;/code&gt; 이 호출되지 않은 경우 0이 리턴됩니다 (올바른 값).</target>
        </trans-unit>
        <trans-unit id="79ac09906fe716bce01c69681d75a4bf9a9cb03d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 1 is returned (which is the correct value).</source>
          <target state="translated">&lt;code&gt;setSourceSubsampling&lt;/code&gt; 이 호출되지 않은 경우 1이 리턴됩니다 (올바른 값).</target>
        </trans-unit>
        <trans-unit id="aa1ac4e940630f846fd22734fc11fce22cf0121f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setToolTipText&lt;/code&gt; has been invoked with a non-&lt;code&gt;null&lt;/code&gt; value, it will be returned, otherwise</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 &lt;code&gt;setToolTipText&lt;/code&gt; 가 호출 된 경우 반환됩니다. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="61566ceca2a0f3c6f13616e2fc6f7a73b100c4e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sites&lt;/code&gt; contains a null element, a &lt;code&gt;NullPointerException&lt;/code&gt; will be raised. In this case, some non-null elements in the array may be processed before the method returns abnormally. Which elements these are (if any) is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;sites&lt;/code&gt; 에 null 요소가 포함되어 있으면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다. 이 경우 배열에서 null이 아닌 일부 요소는 메서드가 비정상적으로 반환되기 전에 처리 될 수 있습니다. 어떤 요소가 존재하는지는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cee89be3aeb95368cd40a9cab8c4abdc56959164" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream and &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;snk&lt;/code&gt; 연결되지 않은 파이프 입력 스트림이고 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 출력 스트림, 그들은 호출 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="690341647fe6d76e88ef315850f5a25397916209" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader and &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;snk&lt;/code&gt; 미 접속의 파이프 리더이고 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 작가, 그들은 호출 중 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="f9c5366be534f93ab5f5deefe308b27ed6664cd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="3f3a2230d84b641f83bf303d40e79f1f03207242" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is not an instance of one of the classes returned by &lt;code&gt;getInputTypes&lt;/code&gt;, the method should simply return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 가 &lt;code&gt;getInputTypes&lt;/code&gt; 에 의해 리턴 된 클래스 중 하나의 인스턴스가 아닌 경우 , 메소드는 단순히 &lt;code&gt;false&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="637f0a7792b7cb0bc9a73c24b4e0f9994163e5c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;returnType&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 또는 &lt;code&gt;returnType&lt;/code&gt; 이가 있다 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="219f0aba2e1ad229cd0601cb06d21c32b8f7d289" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown and the destination array is not modified.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 , &lt;code&gt;NullPointerException&lt;/code&gt; 가 Throw되어 목적지 배열은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d71167d52ef22cb2f16571454a6827b101e0c9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream and &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 출력 스트림이고 &lt;code&gt;snk&lt;/code&gt; 연결되지 않은 파이프 입력 스트림, 그들은 호출 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="760f4c540dae14e4e4ea567bb935f8fcce39cb15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer and &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader, they may be connected by either the call:</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 연결되지 않은 파이프 작가이며, &lt;code&gt;snk&lt;/code&gt; 연결되지 않은 파이프 리더, 그들은 호출 중 하나에 의해 접속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="c619334825864b10343e14e3a5fa2edbf88f1438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is &amp;plusmn;&lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, then a zero with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn;이다 &lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; 가&lt;/a&gt; 와 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기, 같은 기호 다음 제로해야한다는 등의 값이 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fae5b0093d13f14219d9322f18e9441f961ca477" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is &amp;plusmn;&lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, then a zero with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn;이다 &lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; 가&lt;/a&gt; 와 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기, 같은 기호 다음 제로해야한다는 등의 값이 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f66998e543c1a12b2ca918a211e06eae5f94b1c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is equal to &amp;plusmn; &lt;a href=&quot;double#MAX_VALUE&quot;&gt;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a larger magnitude, an infinity with same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn; 같다 &lt;a href=&quot;double#MAX_VALUE&quot;&gt; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;direction&lt;/code&gt; 결과는 더 큰 크기로 동일한 부호를 갖는 무한대가되어야되도록 값 가지고 &lt;code&gt;start&lt;/code&gt; 리턴된다.</target>
        </trans-unit>
        <trans-unit id="a161a170f19a8906de8c9a6cfd3d5e37f8f5ff13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is equal to &amp;plusmn; &lt;a href=&quot;float#MAX_VALUE&quot;&gt;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a larger magnitude, an infinity with same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; &amp;plusmn; 같다 &lt;a href=&quot;float#MAX_VALUE&quot;&gt; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;direction&lt;/code&gt; 결과는 더 큰 크기로 동일한 부호를 갖는 무한대가되어야되도록 값 가지고 &lt;code&gt;start&lt;/code&gt; 리턴된다.</target>
        </trans-unit>
        <trans-unit id="a58cc90d3a573be11a8ea4b0883f3c2086b63b6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is infinite and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, &lt;a href=&quot;double#MAX_VALUE&quot;&gt;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;&lt;/a&gt; with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 무한과 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기, 있어야한다고 같은 값이 &lt;a href=&quot;double#MAX_VALUE&quot;&gt; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 같은 기호로 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae7182c34098ff9d6f56022f88e1e7fdd3a318a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is infinite and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, &lt;a href=&quot;float#MAX_VALUE&quot;&gt;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;&lt;/a&gt; with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 무한과 &lt;code&gt;direction&lt;/code&gt; 결과가 더 작은 크기,해야한다는 등의 값이 &lt;a href=&quot;float#MAX_VALUE&quot;&gt; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; 을&lt;/a&gt; 같은 기호로 &lt;code&gt;start&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6cd80221ac94b2f2e71b197d42d75c47e15af2c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;strict&lt;/code&gt; is false, when a tag that breaks flow, (&lt;code&gt;TagElement.breaksFlows&lt;/code&gt;) or trailing whitespace is encountered, all whitespace will be ignored until a non whitespace character is encountered. This appears to give behavior closer to the popular browsers.</source>
          <target state="translated">경우 &lt;code&gt;strict&lt;/code&gt; 거짓하는 휴식 시간이 흐를 것을 태그 (시 &lt;code&gt;TagElement.breaksFlows&lt;/code&gt; 공백 이외의 문자가 발견 될 때까지) 나 말미에 공백이 발견, 공백은 모두 무시됩니다. 이것은 인기있는 브라우저에 더 가까운 동작을 제공하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="dd9e9926b4084569dcc965ce6b61db0e47d85ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a distinguished name, in RFC 2253 format.</source>
          <target state="translated">&lt;code&gt;subjectDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 는 RFC 2253 형식의 식별 명을 포함 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8333161ec6b6561928b6f53c8cfefeeee4ccdf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded distinguished name, as defined in X.501. For the ASN.1 notation for this structure, see &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;subjectDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ea050f10d06248bcf9421ca5fbce2a0e9eb8454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded distinguished name, as defined in X.501. For the ASN.1 notation for this structure, see &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;subjectDN&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2013740722fd95a1604400c614bd63582e466a8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectKeyID&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded value corresponding to the contents of the extension value (not including the object identifier, criticality setting, and encapsulating OCTET STRING) for a SubjectKeyIdentifier extension. The ASN.1 notation for this structure follows.</source>
          <target state="translated">&lt;code&gt;subjectKeyID&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 SubjectKeyIdentifier 확장에 대한 확장 값의 내용 (개체 식별자, 중요도 설정 및 OCTET STRING 캡슐화 제외)에 해당하는 단일 DER 인코딩 값을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8a2d56ad412e7e8bed4d2deae78a648b54d9910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;switchPoints&lt;/code&gt; contains a null element, a &lt;code&gt;NullPointerException&lt;/code&gt; will be raised. In this case, some non-null elements in the array may be processed before the method returns abnormally. Which elements these are (if any) is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;switchPoints&lt;/code&gt; 에 null 요소가 포함되어 있으면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다. 이 경우 배열에서 null이 아닌 일부 요소는 메서드가 비정상적으로 반환되기 전에 처리 될 수 있습니다. 어떤 요소가 존재하는지는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="73066e095387b022012986549b34f1448bd7aa6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout&lt;/code&gt; is greater than 0, the method returns after &lt;code&gt;timeout&lt;/code&gt; milliseconds even if there is no change in state. In that case, this method returns &lt;code&gt;false&lt;/code&gt;; otherwise it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;timeout&lt;/code&gt; 0보다 큰 경우, 이후의 메소드가 리턴 &lt;code&gt;timeout&lt;/code&gt; 상태에 변화가 밀리가없는 경우에도. 이 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9110736d0ba8beddd891578c4cd267d3ed2df9b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trayIcon&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or was not added to the system tray, no exception is thrown and no action is performed.</source>
          <target state="translated">경우 &lt;code&gt;trayIcon&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 또는 시스템 트레이에 첨가되지 않은, 예외가 발생되지 않고, 처리는 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="1dc73700c68c63f248dae219cde824ef4b8f9196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; is returned, the JDBC driver must support the returning of auto-generated keys for at least SQL INSERT statements</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 반환되면, JDBC 드라이버의 자동 생성 키의 반환을 지원해야합니다 적어도 SQL INSERT 문에서</target>
        </trans-unit>
        <trans-unit id="06115dacf5b34fb8d3c0d2c47a4c8739954912e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the auto-scrolling is enabled.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 자동 스크롤을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a6d295804593883ad2ce93da589746015b3c79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching whenever it can.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 가능한 때에 캐쉬 (cache)를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="9165b89186b82d1302645d783c2a0c1050d0333c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching whenever it can. If &lt;code&gt;false&lt;/code&gt;, the protocol must always try to get a fresh copy of the object.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 가능한 때에 캐쉬 (cache)를 사용할 수있다. 경우 &lt;code&gt;false&lt;/code&gt; , 프로토콜은 항상 객체의 새로운 카피를 취득 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28bab1545813399b6959c7a48698b477c2089f22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol will automatically follow redirects.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 자동적으로 리다이렉트 (redirect)에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e68e3758b38fae66da1ed8095766c26a46ef65a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol will automatically follow redirects. If &lt;code&gt;false&lt;/code&gt;, the protocol will not automatically follow redirects.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 프로토콜은 자동적으로 리다이렉트 (redirect)에 따릅니다. 경우 &lt;code&gt;false&lt;/code&gt; , 프로토콜은 자동으로 리디렉션을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c2bff42d38b3e74f0a77d30306aa66a141445c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;URL&lt;/code&gt; is being examined in a context in which it makes sense to allow user interactions such as popping up an authentication dialog.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 &lt;code&gt;URL&lt;/code&gt; 은 이 인증 대화 상자를 팝업으로 사용자 상호 작용은 허용하는 의미가있는 맥락에서 검토되고있다.</target>
        </trans-unit>
        <trans-unit id="1347facf72554ede8e0ebdf4e21d8496b6b672a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;URL&lt;/code&gt; is being examined in a context in which it makes sense to allow user interactions such as popping up an authentication dialog. If &lt;code&gt;false&lt;/code&gt;, then no user interaction is allowed.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 인증 대화 상자 팝업과 같은 사용자 상호 작용을 허용하는 컨텍스트 에서이 &lt;code&gt;URL&lt;/code&gt; 을 검사합니다. &lt;code&gt;false&lt;/code&gt; 인 경우 사용자 상호 작용이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c993a9c8cd84f954007dac990e0fc740f486086" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this glyph absorbs all extra space at this and lower priority levels when it grows.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 그래프는 여분의 영역을 모두 흡수하고 성장하면 우선 순위 레벨을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="976048025c34666d0a2f1d2690ac8cc5cc20d7e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;,this glyph absorbs all remaining shrinkage at this and lower priority levels as it shrinks.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 그래프는이 축분을 모두 흡수하고 축소로 우선 순위 레벨을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="d0224176165c2117154a3a0f83358aa57f06cb34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uris&lt;/code&gt; is empty, system property &lt;code&gt;javax.xml.catalog.files&lt;/code&gt;, as defined in &lt;a href=&quot;catalogfeatures&quot;&gt;&lt;code&gt;CatalogFeatures&lt;/code&gt;&lt;/a&gt;, will be read to locate the initial list of catalog files.</source>
          <target state="translated">&lt;code&gt;uris&lt;/code&gt; 가 비어 있으면 &lt;a href=&quot;catalogfeatures&quot;&gt; &lt;code&gt;CatalogFeatures&lt;/code&gt; 에&lt;/a&gt; 정의 된 시스템 속성 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 를 읽어 카탈로그 파일의 초기 목록을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="adee4dfa9a0b08ac726e589fa9dfc1c09a04aa62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useNative&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;color&lt;/code&gt; is created by using &lt;code&gt;Color.decode&lt;/code&gt; to convert the &lt;code&gt;
 String&lt;/code&gt; into a &lt;code&gt;Color&lt;/code&gt;. If &lt;code&gt;decode&lt;/code&gt; can not convert the &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Color&lt;/code&gt; (&lt;code&gt;
 NumberFormatException&lt;/code&gt; is thrown) then a &lt;code&gt;
 ColorUIResource&lt;/code&gt; of black is used.</source>
          <target state="translated">경우 &lt;code&gt;useNative&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;color&lt;/code&gt; 사용하여 만든 &lt;code&gt;Color.decode&lt;/code&gt; 을 변환 할 &lt;code&gt; String&lt;/code&gt; 에 &lt;code&gt;Color&lt;/code&gt; . &lt;code&gt;decode&lt;/code&gt; 가 &lt;code&gt;String&lt;/code&gt; 을 &lt;code&gt;Color&lt;/code&gt; 으로 변환 할 수없는 경우 ( &lt;code&gt; NumberFormatException&lt;/code&gt; 이 발생 함) 검은 색 의 &lt;code&gt; ColorUIResource&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e12a5a71cacdb7a4b0cc546bbaf64c5c1947c59f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useNative&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;color&lt;/code&gt; is the value of the field in &lt;code&gt;SystemColor&lt;/code&gt; with the same name as the &lt;code&gt;name&lt;/code&gt; of the &lt;code&gt;name-color&lt;/code&gt; pair. If the field is not valid, a &lt;code&gt;ColorUIResource&lt;/code&gt; of black is used.</source>
          <target state="translated">경우 &lt;code&gt;useNative&lt;/code&gt; 가 인 &lt;code&gt;true&lt;/code&gt; 은 &lt;code&gt;color&lt;/code&gt; 의 필드 값 &lt;code&gt;SystemColor&lt;/code&gt; 는 AS 동일한 이름 &lt;code&gt;name&lt;/code&gt; 의 &lt;code&gt;name-color&lt;/code&gt; 쌍. 필드가 유효하지 않으면 검은 색 의 &lt;code&gt;ColorUIResource&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42c68be27b55a7fc86e8255ec96cc9fc619eff9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a primitive array then &lt;code&gt;h&lt;/code&gt; is computed using the appropriate overloading of &lt;code&gt;java.util.Arrays.hashCode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 가 프리미티브 배열 인 경우 , &lt;code&gt;java.util.Arrays.hashCode&lt;/code&gt; 의 적절한 오버로드를 사용하여 &lt;code&gt;h&lt;/code&gt; 가 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d6ba7534f9cf9c2b36675a6962310dd6297fdb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepHashCode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 한 후 &lt;code&gt;h&lt;/code&gt; 사용하여 계산된다 &lt;a href=&quot;../../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepHashCode&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="697fc3a2ae17f1968e68001fdcb19fb233006602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 후 &lt;code&gt;h&lt;/code&gt; 로 하여 계산된다 &lt;a href=&quot;../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7c2ed9b1d962075a2a4a29e826a8f5a3166754e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepHashCode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 한 후 &lt;code&gt;h&lt;/code&gt; 사용하여 계산된다 &lt;a href=&quot;../../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepHashCode&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b9f393b2dc17964bf329368f78f1fec6ffbcc1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 객체 배열 후 &lt;code&gt;h&lt;/code&gt; 로 하여 계산된다 &lt;a href=&quot;../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f9ca186e13d8a0b2f51cb3a886210bea7f10ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is null then &lt;code&gt;h&lt;/code&gt; is 0.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 널 (null)이 다음 &lt;code&gt;h&lt;/code&gt; 0입니다.</target>
        </trans-unit>
        <trans-unit id="6af7ae4e213065c80428b397aa23f3ea124048d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; this method will remove the property.</source>
          <target state="translated">If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; this method will remove the property.</target>
        </trans-unit>
        <trans-unit id="cdf69f59b52da316eefe1f6713b87184e68ea952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;variableName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">If &lt;code&gt;variableName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; , then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="de58d32d92fa75ad61a38656206078ffc1357769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt;, the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt;
 weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt;
 IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</source>
          <target state="translated">If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt; , the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt; weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt; IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</target>
        </trans-unit>
        <trans-unit id="cf22cf86c23376b8eca15d02a9bb39702899c3a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt;, the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt;weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</source>
          <target state="translated">경우 &lt;code&gt;weekOfYear&lt;/code&gt; 이 있는 유효한 일주일의 년 범위를 벗어 &lt;code&gt;weekYear&lt;/code&gt; 의 &lt;code&gt;weekYear&lt;/code&gt; 및 &lt;code&gt;weekOfYear&lt;/code&gt; 값은 관대 모드에서 조정하거나, &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 엄밀 모드에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e04829a460140c9fa38864c5d9d7777958bc689" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;J&lt;/em&gt; has a method</source>
          <target state="translated">&lt;em&gt;J&lt;/em&gt; 에 메소드가있는 경우</target>
        </trans-unit>
        <trans-unit id="780f93481eae7dbaf2119163257a12d0c3bdf665" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean, then a Java casting conversion (JLS 5.5) is applied. (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by widening and/or narrowing.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 와 &lt;em&gt;T1은&lt;/em&gt; 부울 이외의 기본 요소는 다음 자바 캐스팅 변환 (JLS 5.5) 적용됩니다. 구체적으로, &lt;em&gt;T0&lt;/em&gt; 은 확장 및 / 또는 축소 하여 &lt;em&gt;T1&lt;/em&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dac40b6866039e1587ae30b3906847041aa9167" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, &lt;em&gt;T0&lt;/em&gt; must convert to &lt;em&gt;T1&lt;/em&gt; by a widening primitive conversion.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 및 &lt;em&gt;T1은&lt;/em&gt; 원시적 존재하는 경우, 다음 자바 메소드 호출 변환 (JLS 5.3)에 적용된다. 특히, &lt;em&gt;T0&lt;/em&gt; 은 확장 기본 변환 으로 &lt;em&gt;T1&lt;/em&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ab9ec122966f4e63c48e8d018d94714edba20c1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type, then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast. (This treatment of interfaces follows the usage of the bytecode verifier.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 및 &lt;em&gt;T1을&lt;/em&gt; 참조하고, &lt;em&gt;T1은&lt;/em&gt; 인터페이스 유형, 유형 다음 값 &lt;em&gt;T0는&lt;/em&gt; A와 전달 &lt;em&gt;T1&lt;/em&gt; 캐스팅없이. (이 인터페이스 처리는 바이트 코드 검증기의 사용을 따릅니다.)</target>
        </trans-unit>
        <trans-unit id="79aeb4d5dd8cb350db9c0c092dba6e42f02a5549" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, then a cast to &lt;em&gt;T1&lt;/em&gt; is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.)</source>
          <target state="translated">경우 &lt;em&gt;T0&lt;/em&gt; 와 &lt;em&gt;T1이&lt;/em&gt; 참조하고, 그 다음에 캐스트 &lt;em&gt;T1이&lt;/em&gt; 적용됩니다. 유형이 특정 방식으로 관련 될 필요는 없습니다. 이는 동적 값 널 (null)이 모든 참조 유형으로 변환 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4afc8d053d3eb053b07d58aea74885c54772acb0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a primitive and &lt;em&gt;T1&lt;/em&gt; a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from &lt;em&gt;T0&lt;/em&gt; to its wrapper class, which is then widened as needed to &lt;em&gt;T1&lt;/em&gt;.)</source>
          <target state="translated">경우 &lt;em&gt;T0은&lt;/em&gt; 원시적이며 &lt;em&gt;T1&lt;/em&gt; 참조가 존재하는 경우, 자바 주조 변환 (JLS 5.5)에 적용된다. (특히, 값은 &lt;em&gt;T0&lt;/em&gt; 에서 래퍼 클래스 까지 상자로 &lt;em&gt;묶고&lt;/em&gt; 필요에 따라 &lt;em&gt;T1&lt;/em&gt; 까지 확장됩니다 .)</target>
        </trans-unit>
        <trans-unit id="f9f655a906d4defe08e1ec4ccc11021ab6bc8df7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java casting conversion (JLS 5.5) on the primitive value, possibly followed by a conversion from byte to boolean by testing the low-order bit.</source>
          <target state="translated">경우 &lt;em&gt;T0는&lt;/em&gt; 기준이고 &lt;em&gt;T1&lt;/em&gt; 원시, 개봉기 변환 프리미티브 값에 자바 주조 변환 (JLS 5.5)에 의해 가능 런타임에 적용 하였다 될 가능성 저차 테스트하여 부울하는 바이트에서 전환 하였다 비트.</target>
        </trans-unit>
        <trans-unit id="db644feaac62822a15a472df6abb94d10f3b2937" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</source>
          <target state="translated">If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="5e7880911e2e6fcd9ad74806ba0070443b27d0e7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T0는&lt;/em&gt; 기준이고 &lt;em&gt;T1&lt;/em&gt; 원시, 개봉기 변환 가능한 프리미티브 값에 자바 메소드 호출 변환 (JLS 5.3) 한 후, 실행시에 적용된다. (이것은 원시 확장 변환입니다.) &lt;em&gt;T0&lt;/em&gt; 은 랩퍼 클래스이거나 1의 수퍼 타입이어야합니다. ( &lt;em&gt;T0&lt;/em&gt; 이 Object 인 경우 &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; 에서&lt;/a&gt; 허용하는 변환 입니다.) unboxing 변환에 성공할 가능성이 있어야합니다. 즉, &lt;em&gt;T0&lt;/em&gt; 자체가 랩퍼 클래스가 아닌 경우 에는 &lt;em&gt;T0&lt;/em&gt; 의 하위 유형이며 상자에없는 기본 값을 &lt;em&gt;T1&lt;/em&gt; 로 확장 할 수있는 하나 이상의 랩퍼 클래스 &lt;em&gt;TW&lt;/em&gt; 가 존재합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="8960999c2c149641fb63da1b8b2e73d16c83837a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, and if the reference is null at runtime, a zero value is introduced.</source>
          <target state="translated">경우 &lt;em&gt;T0는&lt;/em&gt; 기준이고, &lt;em&gt;T1&lt;/em&gt; 프리미티브, 참조가 null 런타임시이면 0의 값이 도입된다.</target>
        </trans-unit>
        <trans-unit id="c411b97d9273d8806592b1669554d07cf4ebec56" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive, the boolean is converted to a byte value, 1 for true, 0 for false. (This treatment follows the usage of the bytecode verifier.)</source>
          <target state="translated">경우 &lt;em&gt;T0은&lt;/em&gt; 부울이며 &lt;em&gt;T1은&lt;/em&gt; 다른 프리미티브이며, 부울 거짓 0 참하는 바이트 값 1로 변환된다. (이 처리는 바이트 코드 검증기의 사용법을 따릅니다.)</target>
        </trans-unit>
        <trans-unit id="11dcb0b6d39107c41f9d02034203e755a22bc31f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive, &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5), and the low order bit of the result is tested, as if by &lt;code&gt;(x &amp;amp; 1) != 0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T1은&lt;/em&gt; 부울이고 &lt;em&gt;T0는&lt;/em&gt; 다른 프리미티브이고, &lt;em&gt;T0는&lt;/em&gt; 변환 (JLS 5.5) 주조 자바를 통해 바이트로 변환하고, 결과의 하위 비트는 마치하여 시험한다 &lt;code&gt;(x &amp;amp; 1) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e03b8b722d047ebd8ff3f27197eddd18529d96a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt;
      &quot;java.lang.String&quot;&lt;/code&gt;.</source>
          <target state="translated">If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt; &quot;java.lang.String&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fd2145f2a73182fb43d09ea345dee1a6c4c8988" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt;&quot;java.lang.String&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T가&lt;/em&gt; 아닌 일반 비 어레이 형이다 &lt;em&gt;genericstring (T)에&lt;/em&gt; 의해 반환 된 값 &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt; , 예를 들면 &lt;code&gt;&quot;int&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;java.lang.String&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="860ba81ee558617e504db9f36e3c29f31a880b19" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt;. For example, &lt;em&gt;genericstring(&lt;code&gt;int[]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt;, and &lt;em&gt;genericstring(&lt;code&gt;
      List&amp;lt;String&amp;gt;[][]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;
      &quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt;.</source>
          <target state="translated">If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt; . For example, &lt;em&gt;genericstring( &lt;code&gt;int[]&lt;/code&gt; )&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt; , and &lt;em&gt;genericstring( &lt;code&gt; List&amp;lt;String&amp;gt;[][]&lt;/code&gt; )&lt;/em&gt; is &lt;code&gt; &quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fc604f0af1a190516ca2a3a164921e85df65901" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt;. For example, &lt;em&gt;genericstring(&lt;code&gt;int[]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt;, and &lt;em&gt;genericstring(&lt;code&gt;List&amp;lt;String&amp;gt;[][]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;T는&lt;/em&gt; 어레이 인 &lt;em&gt;E []를&lt;/em&gt; , &lt;em&gt;genericstring (T)가&lt;/em&gt; 된다 &lt;em&gt;(E) genericstring&lt;/em&gt; 뒤에 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; . 예를 들어, &lt;em&gt;genericstring ( &lt;code&gt;int[]&lt;/code&gt; )&lt;/em&gt; 은 &lt;code&gt;&quot;int[]&quot;&lt;/code&gt; 이고 &lt;em&gt;genericstring ( &lt;code&gt;List&amp;lt;String&amp;gt;[][]&lt;/code&gt; )&lt;/em&gt; 은 &lt;code&gt;&quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a5ada396ebd42f6281b2f214e6a5eb260e1d65b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;opendata(J)&lt;/em&gt; is &lt;code&gt;CompositeData&lt;/code&gt; for a Java type &lt;em&gt;J&lt;/em&gt;, then either an instance of &lt;em&gt;J&lt;/em&gt; can be reconstructed from a &lt;code&gt;CompositeData&lt;/code&gt;, or &lt;em&gt;J&lt;/em&gt; is not reconstructible. If any item in the &lt;code&gt;CompositeData&lt;/code&gt; is not reconstructible, then &lt;em&gt;J&lt;/em&gt; is not reconstructible either.</source>
          <target state="translated">경우 &lt;em&gt;opendata (J)이&lt;/em&gt; 있다 &lt;code&gt;CompositeData&lt;/code&gt; 자바 타입 &lt;em&gt;J&lt;/em&gt; 후 하나의 인스턴스 &lt;em&gt;J는&lt;/em&gt; (A)로부터 재구성 될 수 &lt;code&gt;CompositeData&lt;/code&gt; 또는 &lt;em&gt;J는&lt;/em&gt; reconstructible 아니다. &lt;code&gt;CompositeData&lt;/code&gt; 의 항목을 재구성 할 수없는 경우 &lt;em&gt;J&lt;/em&gt; 도 재구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8262855ebc180b3d6778bf226e7f53f50f72af47" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType()&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType()&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; . This means that:</target>
        </trans-unit>
        <trans-unit id="55e80b82ba0e613e2bb9e96436b7f7884b762e6f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 의 인스턴스 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , 다음하자 &lt;code&gt;ct&lt;/code&gt; 그 수 &lt;code&gt;CompositeType&lt;/code&gt; 에 의해 반환 &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt; . 경우, 결과는 사실 &lt;code&gt;this&lt;/code&gt; 이다 &lt;em&gt;에서 할당 &lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; . 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e4299f574b0825744c73fc58489cb793e0aeb31f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;
 td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType()&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue(java.lang.Object)&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; , say &lt;code&gt; td&lt;/code&gt; , the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType()&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue(java.lang.Object)&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c5b21be35113bc2c3c5695016e41e7a8961aa607" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 의 인스턴스 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 말 &lt;code&gt;td&lt;/code&gt; 이되면 그 결과는 true입니다 &lt;code&gt;TabularType&lt;/code&gt; 의가 있습니다 &lt;em&gt;에서 할당 &lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt; 에 정의 된대로, &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bc555f2367ab62f427bf89fb970ff34e2a7eac" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 널 (null)이거나의 인스턴스가 아닌 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , &lt;code&gt;isValue&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fca7400d753ab2ac94fb4572ae69584ddad617" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 널 (null)이거나의 인스턴스가 아닌 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; , &lt;code&gt;isValue&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee964581c68796c9de47e0f9fcc18bb6c0cdfe3" translate="yes" xml:space="preserve">
          <source>If B 'requires transitive' C, then A &quot;reads&quot; C as well as B. This augmentation is recursive: since A &quot;reads&quot; C, if C 'requires transitive' D, then A &quot;reads&quot; D as well as C and B.</source>
          <target state="translated">If B 'requires transitive' C, then A &quot;reads&quot; C as well as B. This augmentation is recursive: since A &quot;reads&quot; C, if C 'requires transitive' D, then A &quot;reads&quot; D as well as C and B.</target>
        </trans-unit>
        <trans-unit id="217ddf9447b9b7371675e7e32d2dda97e83ca937" translate="yes" xml:space="preserve">
          <source>If B is an automatic module, then A &quot;reads&quot; every other enumerated automatic module. (It is &quot;as if&quot; an automatic module has 'requires transitive' directives for every other enumerated automatic module).</source>
          <target state="translated">If B is an automatic module, then A &quot;reads&quot; every other enumerated automatic module. (It is &quot;as if&quot; an automatic module has 'requires transitive' directives for every other enumerated automatic module).</target>
        </trans-unit>
        <trans-unit id="f6eb29fd93b0c765afc3bd3b512f90a195dcbb2f" translate="yes" xml:space="preserve">
          <source>If BeanContext parameter is null, then it shall associate the Applet with its appropriate Container by adding that Applet to its Container via an invocation of add(). If the BeanContext parameter is non-null, then it is the responsibility of the BeanContext to associate the Applet with its Container during the subsequent invocation of its addChildren() method.</source>
          <target state="translated">BeanContext 파라미터가 null의 경우, add ()의 호출을 사용해 그 애플릿을 컨테이너에 추가하는 것으로 애플릿을 적절한 컨테이너에 관련 짓습니다. BeanContext 매개 변수가 널이 아닌 경우, 이후 addChildren () 메소드 호출 중에 애플릿을 컨테이너와 연관시키는 것은 BeanContext의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b3801f11fd37bcce7f8fba639fe8d4ee887aad7e" translate="yes" xml:space="preserve">
          <source>If C declares a public field with the name specified, that is the field to be reflected.</source>
          <target state="translated">C가 지정된 이름으로 공개 필드를 선언하면 해당 필드가 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="e74b12226ef970b004e90369d97d9ef001f09d83" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then include the result of invoking this algorithm recursively on the superclass of C.</source>
          <target state="translated">If C is a class other than &lt;code&gt;Object&lt;/code&gt; , then include the result of invoking this algorithm recursively on the superclass of C.</target>
        </trans-unit>
        <trans-unit id="ca26ee5702ced758c636159001396b48df22d8a6" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then this algorithm is invoked recursively on the superclass of C.</source>
          <target state="translated">C가 &lt;code&gt;Object&lt;/code&gt; 이외의 클래스 인 경우이 알고리즘은 C의 수퍼 클래스에서 재귀 적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9b9649ab976d62198d1ec3dfed66527d11d467" translate="yes" xml:space="preserve">
          <source>If C is the class &lt;code&gt;Object&lt;/code&gt;, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected.</source>
          <target state="translated">C가 &lt;code&gt;Object&lt;/code&gt; 클래스 이거나 C가 인터페이스 인 경우 C (있는 경우)의 수퍼 인터페이스에서 일치하는 메소드를 검색합니다. 그러한 방법이 발견되면 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="2d85abeeeb1aa21f2267ac0f2f921e008ecb6b5d" translate="yes" xml:space="preserve">
          <source>If CPU time measurement is enabled after the thread has started, the Java virtual machine implementation may choose any time up to and including the time that the capability is enabled as the point where CPU time measurement starts.</source>
          <target state="translated">스레드가 시작된 후 CPU 시간 측정이 사용 가능한 경우, JVM (Java Virtual Machine) 구현은 기능이 사용 가능한 시간을 포함하여 CPU 시간 측정이 시작되는 시점을 포함하여 언제든지 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b2e184e73a9f507b63cab71f6b6a0fc51255aa" translate="yes" xml:space="preserve">
          <source>If CredentialClass is &quot;*&quot;, then access is granted to all private Credentials belonging to the specified &lt;code&gt;Subject&lt;/code&gt;. If &quot;PrincipalName&quot; is &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has the specified &lt;code&gt;Principal&lt;/code&gt; (the actual PrincipalName doesn't matter). For example, the following grants access to the a.b.Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has an a.b.Principal.</source>
          <target state="translated">CredentialClass가 &quot;*&quot;이면 지정된 &lt;code&gt;Subject&lt;/code&gt; 에 속하는 모든 개인 자격 증명에 액세스 권한이 부여됩니다 . &quot;PrincipalName&quot;이 &quot;*&quot;이면 지정된 &lt;code&gt;Principal&lt;/code&gt; 이있는 모든 &lt;code&gt;Subject&lt;/code&gt; 가 소유 한 지정된 자격 증명에 대한 액세스 권한이 부여됩니다 (실제 PrincipalName은 중요하지 않음). 예를 들어, 다음 은 abPrincipal이있는 모든 &lt;code&gt;Subject&lt;/code&gt; 소유 한 abCredential에 대한 액세스 권한을 부여합니다 .</target>
        </trans-unit>
        <trans-unit id="6a39eb1a01812d32c33a1ca34fe7c0a3f9fe824c" translate="yes" xml:space="preserve">
          <source>If January 1st is Friday then week 1 starts on January 4th</source>
          <target state="translated">1 월 1 일이 금요일이면 1 주차는 1 월 4 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="8212bef3cde7fd918667a428a4beb2926b2aaf30" translate="yes" xml:space="preserve">
          <source>If January 1st is Monday then week 1 starts on January 1st</source>
          <target state="translated">1 월 1 일이 월요일이면 1 월 1 일에 1 주차가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1d8c7e06d2ed477961cc6b9bf02767f72d2e8e" translate="yes" xml:space="preserve">
          <source>If January 1st is Saturday then week 1 starts on January 3rd</source>
          <target state="translated">1 월 1 일이 토요일이면 1 주차는 1 월 3 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="93384845075a732cc09f28c1fdb3a1493434370f" translate="yes" xml:space="preserve">
          <source>If January 1st is Sunday then week 1 starts on January 2nd</source>
          <target state="translated">1 월 1 일이 일요일이면 1 주차는 1 월 2 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d773a45b8b76332ac1c9cf30d6d26cbed25b1ef6" translate="yes" xml:space="preserve">
          <source>If January 1st is Thursday then week 1 starts on December 29th of the previous standard year</source>
          <target state="translated">1 월 1 일이 목요일이면 1 주차는 이전 표준 연도의 12 월 29 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="dff679f893694acfcb5844ad440b7fd91f379885" translate="yes" xml:space="preserve">
          <source>If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year</source>
          <target state="translated">1 월 1 일이 화요일이면 1 주차는 이전 표준 연도의 12 월 31 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4487b7e39c0d7129e69d67e0df2749862989ef" translate="yes" xml:space="preserve">
          <source>If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year</source>
          <target state="translated">1 월 1 일이 수요일이면 1 주차는 전년도의 12 월 30 일에 시작됩니다</target>
        </trans-unit>
        <trans-unit id="f38e0c7c32dd408bc04c87c04c2100fa3feb4c90" translate="yes" xml:space="preserve">
          <source>If N equals &lt;code&gt;className&lt;/code&gt;, the result is true.</source>
          <target state="translated">N이 &lt;code&gt;className&lt;/code&gt; 인 경우 결과는 true입니다.</target>
        </trans-unit>
        <trans-unit id="0ba990b0a52d90609129011e460cfce22958559a" translate="yes" xml:space="preserve">
          <source>If Q is not a primitive wrapper, cast Q to the base Wrapper(S); for example Number for numeric types</source>
          <target state="translated">Q가 기본 랩퍼가 아닌 경우 Q를 기본 랩퍼로 캐스트하십시오. 예를 들어 숫자 유형의 경우 Number</target>
        </trans-unit>
        <trans-unit id="703cac5535402dfbacd6e10480e5c86732963b2a" translate="yes" xml:space="preserve">
          <source>If SQL distinct or structured types are supported, then information on the individual types may be obtained from the getUDTs() method.</source>
          <target state="translated">If SQL distinct or structured types are supported, then information on the individual types may be obtained from the getUDTs() method.</target>
        </trans-unit>
        <trans-unit id="b161924f4e548ad87c34d6fc35e9d529b38669ec" translate="yes" xml:space="preserve">
          <source>If TMFAIL is specified, the portion of work has failed. The resource manager may mark the transaction as rollback-only</source>
          <target state="translated">If TMFAIL is specified, the portion of work has failed. The resource manager may mark the transaction as rollback-only</target>
        </trans-unit>
        <trans-unit id="34e620dd9f663543c0cd6de489c85fce57f1d753" translate="yes" xml:space="preserve">
          <source>If TMSUCCESS is specified, the portion of work has completed successfully.</source>
          <target state="translated">If TMSUCCESS is specified, the portion of work has completed successfully.</target>
        </trans-unit>
        <trans-unit id="666f46da82bcae259e1d59dba9446d046eb56729" translate="yes" xml:space="preserve">
          <source>If TMSUSPEND is specified in the flags, the transaction branch is temporarily suspended in an incomplete state. The transaction context is in a suspended state and must be resumed via the &lt;code&gt;start&lt;/code&gt; method with TMRESUME specified.</source>
          <target state="translated">If TMSUSPEND is specified in the flags, the transaction branch is temporarily suspended in an incomplete state. The transaction context is in a suspended state and must be resumed via the &lt;code&gt;start&lt;/code&gt; method with TMRESUME specified.</target>
        </trans-unit>
        <trans-unit id="d4e43d0787d6a1f0ea103acb6274a424055f2393" translate="yes" xml:space="preserve">
          <source>If UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">UDP 소켓을 사용하는 경우 TCP / IP 관련 소켓 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d35b5e2d84fd7cadfe9d220ae2dd518e06e9f2d7" translate="yes" xml:space="preserve">
          <source>If XInclude markup is found in the document instance, should it be processed as specified in &lt;a href=&quot;http://www.w3.org/TR/xinclude/&quot;&gt; XML Inclusions (XInclude) Version 1.0&lt;/a&gt;.</source>
          <target state="translated">If XInclude markup is found in the document instance, should it be processed as specified in &lt;a href=&quot;http://www.w3.org/TR/xinclude/&quot;&gt; XML Inclusions (XInclude) Version 1.0&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cf93dc358d8e904b576e25277f8f25bb773404f0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d758c373d5c33100c18bb64f511e7cfa9ca774b0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7ff99926f4a6706109dc64ddd976098f7dbb7eca" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0e9892804baed9af42e82a13b8ef76149b94c399" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present and no factory is specified, then the default pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. The system class loader is used to load these classes. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">경우 &lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; 존재하고 어떤 공장이 지정되지 않은, 디폴트 풀은 더 한 스레드 공급하는 공장 사용 &lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt; 활성화되지합니다. 시스템 클래스 로더는 이러한 클래스를로드하는 데 사용됩니다. 이러한 설정을 설정하는 중 오류가 발생하면 기본 매개 변수가 사용됩니다. parallelism 속성을 0으로 설정하거나 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수있는 팩토리를 사용하여 공통 풀에서 스레드 사용을 비활성화하거나 제한 할 수 있습니다 . 그러나 이렇게하면 결합되지 않은 작업이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56cfbf9c11a3bf93497432039e845c2caa01626" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&quot;..&quot;&lt;/code&gt; segment is preceded by a non-&lt;code&gt;&quot;..&quot;&lt;/code&gt; segment then both of these segments are removed. This step is repeated until it is no longer applicable.</source>
          <target state="translated">경우 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 세그먼트가 비 앞에는 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 다음 부분이 세그먼트는 모두 제거된다. 이 단계는 더 이상 적용되지 않을 때까지 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a595fa88f9f83de3f8fcc49ca39b0b97a48f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CONCURRENT&lt;/code&gt; collector is not also &lt;code&gt;UNORDERED&lt;/code&gt;, then it should only be evaluated concurrently if applied to an unordered data source.</source>
          <target state="translated">경우 &lt;code&gt;CONCURRENT&lt;/code&gt; 콜렉터도되지 &lt;code&gt;UNORDERED&lt;/code&gt; 정렬되지 않은 데이터 소스에인가하는 경우, 그것은 동시에 만 평가되어야한다.</target>
        </trans-unit>
        <trans-unit id="889b6a11619fbd0768ef25d463af6d6d1eb26b68" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CachedRowSet&lt;/code&gt; object becomes part of a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the keys defined by this method and the resulting constraints are maintained if the columns designated as key columns also become match columns.</source>
          <target state="translated">If a &lt;code&gt;CachedRowSet&lt;/code&gt; object becomes part of a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the keys defined by this method and the resulting constraints are maintained if the columns designated as key columns also become match columns.</target>
        </trans-unit>
        <trans-unit id="023e1ebdfb712240675bc329abb0aeba8c03fd80" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Comparator&lt;/code&gt; has been specified for the column by the &lt;code&gt;setComparator&lt;/code&gt; method, use it.</source>
          <target state="translated">If a &lt;code&gt;Comparator&lt;/code&gt; has been specified for the column by the &lt;code&gt;setComparator&lt;/code&gt; method, use it.</target>
        </trans-unit>
        <trans-unit id="87a0262c290ea66e1e4a3ee02285d9a618034184" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataLine&lt;/code&gt; is requested, and &lt;code&gt;info&lt;/code&gt; is an instance of &lt;code&gt;DataLine.Info&lt;/code&gt; specifying at least one fully qualified audio format, the last one will be used as the default format of the returned &lt;code&gt;DataLine&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;DataLine&lt;/code&gt; 요구되며, &lt;code&gt;info&lt;/code&gt; 의 인스턴스 &lt;code&gt;DataLine.Info&lt;/code&gt; 적어도 하나의 완전한 오디오 형식을 지정, 마지막은 반환의 기본 형식으로 사용됩니다 &lt;code&gt;DataLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="822fd67bb76ff6305db4ff466cd709d70f4144a8" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DriverAction&lt;/code&gt; instance was specified when the JDBC driver was registered, its deregister method will be called prior to the driver being removed from the list of registered drivers.</source>
          <target state="translated">If a &lt;code&gt;DriverAction&lt;/code&gt; instance was specified when the JDBC driver was registered, its deregister method will be called prior to the driver being removed from the list of registered drivers.</target>
        </trans-unit>
        <trans-unit id="0307105d00c9e2e53f227a7583fda0f66d0bdfee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;FilteredRowSet&lt;/code&gt; implementation is shared using the inherited &lt;code&gt;createShared&lt;/code&gt; method in parent interfaces, the &lt;code&gt;Predicate&lt;/code&gt; should be shared without modification by all &lt;code&gt;FilteredRowSet&lt;/code&gt; instance clones.</source>
          <target state="translated">If a &lt;code&gt;FilteredRowSet&lt;/code&gt; implementation is shared using the inherited &lt;code&gt;createShared&lt;/code&gt; method in parent interfaces, the &lt;code&gt;Predicate&lt;/code&gt; should be shared without modification by all &lt;code&gt;FilteredRowSet&lt;/code&gt; instance clones.</target>
        </trans-unit>
        <trans-unit id="738e1b86e8d51219176a3aef7355506e4b762fc6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JButton&lt;/code&gt; is being added, it is initially set to be disabled.</source>
          <target state="translated">If a &lt;code&gt;JButton&lt;/code&gt; is being added, it is initially set to be disabled.</target>
        </trans-unit>
        <trans-unit id="baa9e0dcc52392fc3cfab576edd859e0065fab5d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt;, it is positioned along the upper edge of the frame. The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to fill the remaining area. (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the &lt;code&gt;layeredPane&lt;/code&gt; component at the &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)</source>
          <target state="translated">If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt; , it is positioned along the upper edge of the frame. The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to fill the remaining area. (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the &lt;code&gt;layeredPane&lt;/code&gt; component at the &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)</target>
        </trans-unit>
        <trans-unit id="1d76683d65c14154863276b53c328991a5b273fb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JOptionPane&lt;/code&gt; has configured to all input &lt;code&gt;setWantsInput&lt;/code&gt; the bound property &lt;code&gt;JOptionPane.INPUT_VALUE_PROPERTY&lt;/code&gt; can also be listened to, to determine when the user has input or selected a value.</source>
          <target state="translated">If a &lt;code&gt;JOptionPane&lt;/code&gt; has configured to all input &lt;code&gt;setWantsInput&lt;/code&gt; the bound property &lt;code&gt;JOptionPane.INPUT_VALUE_PROPERTY&lt;/code&gt; can also be listened to, to determine when the user has input or selected a value.</target>
        </trans-unit>
        <trans-unit id="88dd2d3eceec11295d7042c434141f4e15854a11" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JobPriority&lt;/code&gt; attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">If a &lt;code&gt;JobPriority&lt;/code&gt; attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</target>
        </trans-unit>
        <trans-unit id="789dd14e5349e6a03d7591e97c806c5a4a9cec5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;#getUnboundInstance()&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#getUnboundInstance(java.io.File)&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal)&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal,java.io.File)&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;#getUnboundInstance()&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#getUnboundInstance(java.io.File)&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal)&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal,java.io.File)&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</target>
        </trans-unit>
        <trans-unit id="96e5812f9668e1871b3f46e04c3c43773aa3cf41" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">하면 &lt;code&gt;KeyTab&lt;/code&gt; 개체로부터 얻어진다 &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt; , 그 바인딩 해제하고 따라서 모든 서비스 주체에 의해 사용될 수있다. 그렇지 않은 경우, &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt; 에서 확보 한 경우 특정 서비스 프린시 펄에 바인드되어 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169583703e821554fd005ef25ad00c1501c82436" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;MarshalException&lt;/code&gt; occurs during a remote method call, the call may or may not have reached the server. If the call did reach the server, parameters may have been deserialized. A call may not be retransmitted after a &lt;code&gt;MarshalException&lt;/code&gt; and reliably preserve &quot;at most once&quot; call semantics.</source>
          <target state="translated">If a &lt;code&gt;MarshalException&lt;/code&gt; occurs during a remote method call, the call may or may not have reached the server. If the call did reach the server, parameters may have been deserialized. A call may not be retransmitted after a &lt;code&gt;MarshalException&lt;/code&gt; and reliably preserve &quot;at most once&quot; call semantics.</target>
        </trans-unit>
        <trans-unit id="7341cf2f876d3c7a46c61b0becb56d0668f2a5a7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;MaskFormatter&lt;/code&gt; is configured to only allow valid characters (&lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;) literal characters will be skipped as necessary when editing. Consider a &lt;code&gt;MaskFormatter&lt;/code&gt; with the mask &quot;###-####&quot; and current value &quot;555-1212&quot;. Using the right arrow key to navigate through the field will result in (| indicates the position of the caret):</source>
          <target state="translated">If a &lt;code&gt;MaskFormatter&lt;/code&gt; is configured to only allow valid characters ( &lt;code&gt;setAllowsInvalid(false)&lt;/code&gt; ) literal characters will be skipped as necessary when editing. Consider a &lt;code&gt;MaskFormatter&lt;/code&gt; with the mask &quot;###-####&quot; and current value &quot;555-1212&quot;. Using the right arrow key to navigate through the field will result in (| indicates the position of the caret):</target>
        </trans-unit>
        <trans-unit id="ead077860ccdc5ff506c0098c7c9fa85462cc96f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;ModuleDescriptor&lt;/code&gt; cannot be created (by means of the &lt;a href=&quot;moduledescriptor.builder&quot;&gt;&lt;code&gt;ModuleDescriptor.Builder&lt;/code&gt;&lt;/a&gt; API) for an automatic module then &lt;code&gt;FindException&lt;/code&gt; is thrown. This can arise when the value of the &quot;&lt;code&gt;Automatic-Module-Name&lt;/code&gt;&quot; attribute is not a legal module name, a legal module name cannot be derived from the file name of the JAR file, where the JAR file contains a &lt;code&gt;.class&lt;/code&gt; in the top-level directory of the JAR file, where an entry in a service configuration file is not a legal class name or its package name is not in the set of packages derived for the module.</source>
          <target state="translated">If a &lt;code&gt;ModuleDescriptor&lt;/code&gt; cannot be created (by means of the &lt;a href=&quot;moduledescriptor.builder&quot;&gt; &lt;code&gt;ModuleDescriptor.Builder&lt;/code&gt; &lt;/a&gt; API) for an automatic module then &lt;code&gt;FindException&lt;/code&gt; is thrown. This can arise when the value of the &quot; &lt;code&gt;Automatic-Module-Name&lt;/code&gt; &quot; attribute is not a legal module name, a legal module name cannot be derived from the file name of the JAR file, where the JAR file contains a &lt;code&gt;.class&lt;/code&gt; in the top-level directory of the JAR file, where an entry in a service configuration file is not a legal class name or its package name is not in the set of packages derived for the module.</target>
        </trans-unit>
        <trans-unit id="441cc4fd494fbe5b1ad39c7fa559b1582982d101" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Node&lt;/code&gt; is used in a different document than the one that created it (that doesn't support it).</source>
          <target state="translated">If a &lt;code&gt;Node&lt;/code&gt; is used in a different document than the one that created it (that doesn't support it).</target>
        </trans-unit>
        <trans-unit id="4644effb4a6d5ba07fcf8513d9d0cd6f314112a7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PageRanges&lt;/code&gt; attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the &lt;code&gt;PageRanges&lt;/code&gt; attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">If a &lt;code&gt;PageRanges&lt;/code&gt; attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the &lt;code&gt;PageRanges&lt;/code&gt; attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3283302ea3f0883d87077d68bd9cbb226e3ffd4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;ParseException&lt;/code&gt; has not been thrown, and the value is outside the min/max a &lt;code&gt;ParseException&lt;/code&gt; is thrown.</source>
          <target state="translated">If a &lt;code&gt;ParseException&lt;/code&gt; has not been thrown, and the value is outside the min/max a &lt;code&gt;ParseException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="6ea4836a2a47cbda56eec3b84a8b5aa80316b7db" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt; , then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</target>
        </trans-unit>
        <trans-unit id="d851531cc7c0ba18b4dbffa855d090b319da4df2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">경우 &lt;code&gt;PreferencesFactory&lt;/code&gt; 구현 클래스 파일이에 볼 수있는 jar 파일에 설치되어있는 &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt; , 그 jar 파일이 이름의 프로 바이더 구성 파일이 포함되어 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 그러한 jar 파일이 두 개 이상 제공되면 처음 발견 된 jar 파일이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="622c2551e9494318dc465bf15dd37446b19792a2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RenderingHints&lt;/code&gt; object is specified in the constructor, the interpolation hint and the rendering quality hint are used to set the interpolation type for this operation. The color rendering hint and the dithering hint can be used when color conversion is required.</source>
          <target state="translated">If a &lt;code&gt;RenderingHints&lt;/code&gt; object is specified in the constructor, the interpolation hint and the rendering quality hint are used to set the interpolation type for this operation. The color rendering hint and the dithering hint can be used when color conversion is required.</target>
        </trans-unit>
        <trans-unit id="ef39b802886ff9b6ff97af1ea901d5330b3307e6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; implementation is instantiated with a specified provider and the specified provider has been properly registered, the requested provider is supplied. Otherwise a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown.</source>
          <target state="translated">If a &lt;code&gt;RowSet&lt;/code&gt; implementation is instantiated with a specified provider and the specified provider has been properly registered, the requested provider is supplied. Otherwise a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="da1a08658f1dbe589bccb3ea8d557b60263f9878" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; object attempts to obtain a &lt;code&gt;MyProvider&lt;/code&gt; object, the &lt;code&gt;SyncFactory&lt;/code&gt; will try to locate it. First it searches for it in the system properties, then it looks in the resource files, and finally it checks the JNDI context that has been set. The &lt;code&gt;SyncFactory&lt;/code&gt; instance verifies that the requested provider is a valid extension of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class and then gives it to the &lt;code&gt;RowSet&lt;/code&gt; object. In the following code fragment, a new &lt;code&gt;CachedRowSet&lt;/code&gt; object is created and initialized with</source>
          <target state="translated">If a &lt;code&gt;RowSet&lt;/code&gt; object attempts to obtain a &lt;code&gt;MyProvider&lt;/code&gt; object, the &lt;code&gt;SyncFactory&lt;/code&gt; will try to locate it. First it searches for it in the system properties, then it looks in the resource files, and finally it checks the JNDI context that has been set. The &lt;code&gt;SyncFactory&lt;/code&gt; instance verifies that the requested provider is a valid extension of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class and then gives it to the &lt;code&gt;RowSet&lt;/code&gt; object. In the following code fragment, a new &lt;code&gt;CachedRowSet&lt;/code&gt; object is created and initialized with</target>
        </trans-unit>
        <trans-unit id="85924d6f4f84b3110f734f518f0de7bf01d0e847" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; object does not specify a &lt;code&gt;SyncProvider&lt;/code&gt; implementation and no additional &lt;code&gt;SyncProvider&lt;/code&gt; implementations are available, the reference implementation providers are supplied.</source>
          <target state="translated">If a &lt;code&gt;RowSet&lt;/code&gt; object does not specify a &lt;code&gt;SyncProvider&lt;/code&gt; implementation and no additional &lt;code&gt;SyncProvider&lt;/code&gt; implementations are available, the reference implementation providers are supplied.</target>
        </trans-unit>
        <trans-unit id="005a68567a9c263db1c792152177b5d5b3c37e24" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the calling thread must be granted the &lt;code&gt;AWTPermission&lt;/code&gt; &quot;replaceKeyboardFocusManager&quot; in order to replace the the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If this permission is not granted, this method will throw a &lt;code&gt;SecurityException&lt;/code&gt;, and the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will be unchanged.</source>
          <target state="translated">If a &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the calling thread must be granted the &lt;code&gt;AWTPermission&lt;/code&gt; &quot;replaceKeyboardFocusManager&quot; in order to replace the the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; . If this permission is not granted, this method will throw a &lt;code&gt;SecurityException&lt;/code&gt; , and the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will be unchanged.</target>
        </trans-unit>
        <trans-unit id="bf0127e04708633ff438380e9063019f694d008f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains</source>
          <target state="translated">If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains</target>
        </trans-unit>
        <trans-unit id="4f2c61caf99510b2cab1bf9c38fbc6348259df28" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains a reference to the provider, the requested provider is supplied.</source>
          <target state="translated">If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains a reference to the provider, the requested provider is supplied.</target>
        </trans-unit>
        <trans-unit id="6536cee7d50ac1adadff34bddda00e1d72420e1a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProviderException&lt;/code&gt; object is thrown, an application may use this method to generate a &lt;code&gt;SyncResolver&lt;/code&gt; object with which to resolve the conflict or conflicts that caused the exception to be thrown.</source>
          <target state="translated">If a &lt;code&gt;SyncProviderException&lt;/code&gt; object is thrown, an application may use this method to generate a &lt;code&gt;SyncResolver&lt;/code&gt; object with which to resolve the conflict or conflicts that caused the exception to be thrown.</target>
        </trans-unit>
        <trans-unit id="a2c0481cf37e4b6df1c957fb1176bf4576ce6d06" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;TableStringConverter&lt;/code&gt; has been specified, use it to convert the values to &lt;code&gt;String&lt;/code&gt;s and then use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt;.</source>
          <target state="translated">If a &lt;code&gt;TableStringConverter&lt;/code&gt; has been specified, use it to convert the values to &lt;code&gt;String&lt;/code&gt; s and then use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88f021219bb5adbaaf305230bab58b361bbbf62e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;WebRowSet&lt;/code&gt; object does not specify a provider in its constructor, the &lt;code&gt;SyncFactory&lt;/code&gt; will give it an instance of &lt;code&gt;RIOptimisticProvider&lt;/code&gt;. However, the constructor for &lt;code&gt;WebRowSet&lt;/code&gt; is implemented to set the provider to the &lt;code&gt;RIXMLProvider&lt;/code&gt;, which reads and writes a &lt;code&gt;RowSet&lt;/code&gt; object in XML format.</source>
          <target state="translated">If a &lt;code&gt;WebRowSet&lt;/code&gt; object does not specify a provider in its constructor, the &lt;code&gt;SyncFactory&lt;/code&gt; will give it an instance of &lt;code&gt;RIOptimisticProvider&lt;/code&gt; . However, the constructor for &lt;code&gt;WebRowSet&lt;/code&gt; is implemented to set the provider to the &lt;code&gt;RIXMLProvider&lt;/code&gt; , which reads and writes a &lt;code&gt;RowSet&lt;/code&gt; object in XML format.</target>
        </trans-unit>
        <trans-unit id="c6d143f1c9666cc7913e46a053fe559e1a96fe26" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null Cursor&lt;/code&gt; is specified no exception will be thrown and default drag cursors will be used instead.</source>
          <target state="translated">If a &lt;code&gt;null Cursor&lt;/code&gt; is specified no exception will be thrown and default drag cursors will be used instead.</target>
        </trans-unit>
        <trans-unit id="8f4b45cbcd2002bbfaa5e00b1ed409af80135472" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null Transferable&lt;/code&gt; is specified &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If a &lt;code&gt;null Transferable&lt;/code&gt; is specified &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="4e14b0a6b6bb76cc2c0b6e35711b0ecf985814b3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null&lt;/code&gt; value is specified for the driver to be removed, then no action is taken.</source>
          <target state="translated">If a &lt;code&gt;null&lt;/code&gt; value is specified for the driver to be removed, then no action is taken.</target>
        </trans-unit>
        <trans-unit id="e52e706791f96fcec7c06d42e023ea2edd9c9435" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="fee0a461ccedb0cec1c346f64b81ad734d6b4474" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="1ca6fa88cbddfe8774a575dd729aff8c4c1ff45e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="439453cd55d4370948e1a390997169512de7d762" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="c287b4bb12cc003fe3dff0af6571caedd594b2e6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt; . Specifically:</target>
        </trans-unit>
        <trans-unit id="23ec38983597030f5c01de386bdcfad6f3c016aa" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is not inside the &lt;code&gt;shape&lt;/code&gt;, then it might still be contained in the &lt;code&gt;bounds&lt;/code&gt; object:</source>
          <target state="translated">If a &lt;code&gt;point&lt;/code&gt; is not inside the &lt;code&gt;shape&lt;/code&gt; , then it might still be contained in the &lt;code&gt;bounds&lt;/code&gt; object:</target>
        </trans-unit>
        <trans-unit id="cb3f45e83272884b8fce5d6e7cf093613a1f0235" translate="yes" xml:space="preserve">
          <source>If a Class has been set for the values (&lt;code&gt;setValueClass&lt;/code&gt;), supers implementation is invoked to convert the value returned from &lt;code&gt;parseObject&lt;/code&gt; to the appropriate class.</source>
          <target state="translated">If a Class has been set for the values ( &lt;code&gt;setValueClass&lt;/code&gt; ), supers implementation is invoked to convert the value returned from &lt;code&gt;parseObject&lt;/code&gt; to the appropriate class.</target>
        </trans-unit>
        <trans-unit id="c22024a55d98f2d5bfb4a62cbb3885fd92657704" translate="yes" xml:space="preserve">
          <source>If a DRBG is not instantiated with a &lt;a href=&quot;drbgparameters.instantiation&quot;&gt;&lt;code&gt;DrbgParameters.Instantiation&lt;/code&gt;&lt;/a&gt; object explicitly, this implementation instantiates it with a default requested strength of 128 bits, no prediction resistance request, and no personalization string. These default instantiation parameters can also be customized with the &lt;code&gt;securerandom.drbg.config&lt;/code&gt; security property.</source>
          <target state="translated">If a DRBG is not instantiated with a &lt;a href=&quot;drbgparameters.instantiation&quot;&gt; &lt;code&gt;DrbgParameters.Instantiation&lt;/code&gt; &lt;/a&gt; object explicitly, this implementation instantiates it with a default requested strength of 128 bits, no prediction resistance request, and no personalization string. These default instantiation parameters can also be customized with the &lt;code&gt;securerandom.drbg.config&lt;/code&gt; security property.</target>
        </trans-unit>
        <trans-unit id="95e527be19ab2827e077013513499ad6b9cbcff0" translate="yes" xml:space="preserve">
          <source>If a GUI control is both an active &lt;code&gt;DropTarget&lt;/code&gt; and is also scrollable, it can receive notifications of autoscrolling gestures by the user from the DnD system by implementing this interface.</source>
          <target state="translated">If a GUI control is both an active &lt;code&gt;DropTarget&lt;/code&gt; and is also scrollable, it can receive notifications of autoscrolling gestures by the user from the DnD system by implementing this interface.</target>
        </trans-unit>
        <trans-unit id="99e2b5ed00fcac649fe3f3623264074d666a2942" translate="yes" xml:space="preserve">
          <source>If a JobPriority attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">인쇄 작업에 JobPriority 속성이 지정된 경우 작업 예약 우선 순위를 지정합니다. 값이 클수록 우선 순위가 높습니다. 값 1은 가능한 최저 우선 순위를 나타냅니다. 값 100은 가능한 가장 높은 우선 순위를 나타냅니다. 인쇄 준비가 된 작업 중에서 프린터는 우선 순위 값이 모든 작업을 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="efa62e398135fa151e6296eb9565e2ee0a846e6d" translate="yes" xml:space="preserve">
          <source>If a PageRanges attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the PageRanges attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">인쇄 작업에 PageRanges 속성을 지정하지 않으면 문서의 모든 페이지가 인쇄됩니다. 즉, PageRanges 속성의 기본값은 항상 &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56fcf828deb12fa7c8d023153792b45f6be1b50b" translate="yes" xml:space="preserve">
          <source>If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used to control color conversion.</source>
          <target state="translated">If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used to control color conversion.</target>
        </trans-unit>
        <trans-unit id="4df78250cfd2d96c297fc417911e5b1721cfe666" translate="yes" xml:space="preserve">
          <source>If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.</source>
          <target state="translated">If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.</target>
        </trans-unit>
        <trans-unit id="68b1d4751c3a4fe9ee24ce1abe018576aed949a4" translate="yes" xml:space="preserve">
          <source>If a SAX application needs information about notations and unparsed entities, then the application implements this interface and registers an instance with the SAX parser using the parser's setDTDHandler method. The parser uses the instance to report notation and unparsed entity declarations to the application.</source>
          <target state="translated">If a SAX application needs information about notations and unparsed entities, then the application implements this interface and registers an instance with the SAX parser using the parser's setDTDHandler method. The parser uses the instance to report notation and unparsed entity declarations to the application.</target>
        </trans-unit>
        <trans-unit id="3ba5b890d7e1cdc89fd5a6bca00ab40e11acebb0" translate="yes" xml:space="preserve">
          <source>If a SAX application needs to implement customized error handling, it must implement this interface and then register an instance with the XML reader using the &lt;a href=&quot;xmlreader#setErrorHandler(org.xml.sax.ErrorHandler)&quot;&gt;&lt;code&gt;setErrorHandler&lt;/code&gt;&lt;/a&gt; method. The parser will then report all errors and warnings through this interface.</source>
          <target state="translated">If a SAX application needs to implement customized error handling, it must implement this interface and then register an instance with the XML reader using the &lt;a href=&quot;xmlreader#setErrorHandler(org.xml.sax.ErrorHandler)&quot;&gt; &lt;code&gt;setErrorHandler&lt;/code&gt; &lt;/a&gt; method. The parser will then report all errors and warnings through this interface.</target>
        </trans-unit>
        <trans-unit id="699d691146da85f7d6329e02b5ea8958eea65fcb" translate="yes" xml:space="preserve">
          <source>If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the &lt;a href=&quot;xmlreader#setEntityResolver(org.xml.sax.EntityResolver)&quot;&gt;&lt;code&gt;setEntityResolver&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the &lt;a href=&quot;xmlreader#setEntityResolver(org.xml.sax.EntityResolver)&quot;&gt; &lt;code&gt;setEntityResolver&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="0cc9dd15259390fb3e7ac0a12e455bdc750c4cf5" translate="yes" xml:space="preserve">
          <source>If a SAX application requires the customized handling which this interface defines for external entities, it must ensure that it uses an XMLReader with the &lt;em&gt;http://xml.org/sax/features/use-entity-resolver2&lt;/em&gt; feature flag set to &lt;em&gt;true&lt;/em&gt; (which is its default value when the feature is recognized). If that flag is unrecognized, or its value is false, or the resolver does not implement this interface, then only the &lt;a href=&quot;../entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt; method will be used.</source>
          <target state="translated">If a SAX application requires the customized handling which this interface defines for external entities, it must ensure that it uses an XMLReader with the &lt;em&gt;http://xml.org/sax/features/use-entity-resolver2&lt;/em&gt; feature flag set to &lt;em&gt;true&lt;/em&gt; (which is its default value when the feature is recognized). If that flag is unrecognized, or its value is false, or the resolver does not implement this interface, then only the &lt;a href=&quot;../entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt; method will be used.</target>
        </trans-unit>
        <trans-unit id="36e370cda70c2e439141820154cd61632fd96375" translate="yes" xml:space="preserve">
          <source>If a SAX parser provides location information to the SAX application, it does so by implementing this interface and then passing an instance to the application using the content handler's &lt;a href=&quot;contenthandler#setDocumentLocator(org.xml.sax.Locator)&quot;&gt;&lt;code&gt;setDocumentLocator&lt;/code&gt;&lt;/a&gt; method. The application can use the object to obtain the location of any other SAX event in the XML source document.</source>
          <target state="translated">If a SAX parser provides location information to the SAX application, it does so by implementing this interface and then passing an instance to the application using the content handler's &lt;a href=&quot;contenthandler#setDocumentLocator(org.xml.sax.Locator)&quot;&gt; &lt;code&gt;setDocumentLocator&lt;/code&gt; &lt;/a&gt; method. The application can use the object to obtain the location of any other SAX event in the XML source document.</target>
        </trans-unit>
        <trans-unit id="33790afd26c1ed1a1a9f56f095ee280b02987ed3" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to create a &lt;code&gt;TrayIcon&lt;/code&gt;. Otherwise the constructor will throw a SecurityException.</source>
          <target state="translated">If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to create a &lt;code&gt;TrayIcon&lt;/code&gt; . Otherwise the constructor will throw a SecurityException.</target>
        </trans-unit>
        <trans-unit id="23738716044ec44efb04a5c326db73bc15c62530" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to get the &lt;code&gt;SystemTray&lt;/code&gt; instance. Otherwise this method will throw a SecurityException.</source>
          <target state="translated">If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to get the &lt;code&gt;SystemTray&lt;/code&gt; instance. Otherwise this method will throw a SecurityException.</target>
        </trans-unit>
        <trans-unit id="d6dfd5ce3a3f3a54e3b033911ffb2f2c1d054b1a" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus cycle root will not be changed.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus cycle root will not be changed.</target>
        </trans-unit>
        <trans-unit id="12612b7cb4320c32adc61321ec0710dfbe600dab" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus owner will not be cleared.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus owner will not be cleared.</target>
        </trans-unit>
        <trans-unit id="1b4ef801a419d4c91c8ce0f0fe4a7ae44b83b337" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;replaceKeyboardFocusManager&quot; in order to replace the the current KeyboardFocusManager. If this permission is not granted, this method will throw a SecurityException, and the current KeyboardFocusManager will be unchanged.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;replaceKeyboardFocusManager&quot; in order to replace the the current KeyboardFocusManager. If this permission is not granted, this method will throw a SecurityException, and the current KeyboardFocusManager will be unchanged.</target>
        </trans-unit>
        <trans-unit id="3c085f80770d9292364ba49610a3d688b254c596" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in order to set the value of this property. If this permission is not granted, this method will throw a SecurityException, and the current value of the property will be left unchanged.</source>
          <target state="translated">If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in order to set the value of this property. If this permission is not granted, this method will throw a SecurityException, and the current value of the property will be left unchanged.</target>
        </trans-unit>
        <trans-unit id="419f51299062e187ed812366bb64fa93ee056e2e" translate="yes" xml:space="preserve">
          <source>If a Set of traversal keys has not been explicitly defined for this Component, then this Component's parent's Set is returned. If no Set has been explicitly defined for any of this Component's ancestors, then the current KeyboardFocusManager's default Set is returned.</source>
          <target state="translated">If a Set of traversal keys has not been explicitly defined for this Component, then this Component's parent's Set is returned. If no Set has been explicitly defined for any of this Component's ancestors, then the current KeyboardFocusManager's default Set is returned.</target>
        </trans-unit>
        <trans-unit id="877904e5a9d9ff637ebc73df19af808b92b14754" translate="yes" xml:space="preserve">
          <source>If a Set of traversal keys has not been explicitly defined for this Container, then this Container's parent's Set is returned. If no Set has been explicitly defined for any of this Container's ancestors, then the current KeyboardFocusManager's default Set is returned.</source>
          <target state="translated">If a Set of traversal keys has not been explicitly defined for this Container, then this Container's parent's Set is returned. If no Set has been explicitly defined for any of this Container's ancestors, then the current KeyboardFocusManager's default Set is returned.</target>
        </trans-unit>
        <trans-unit id="54875f0ae002ae009f6261e6ee89713bac0fc513" translate="yes" xml:space="preserve">
          <source>If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</source>
          <target state="translated">Spliterator가 일관되지 않은 특성 세트 (단일 호출에서 또는 여러 호출에서 리턴 된 특성)를보고하면이 Spliterator를 사용한 계산에 대해 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a91c9f9234bda5620ef4d3e6ac923de910e62499" translate="yes" xml:space="preserve">
          <source>If a UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">UDP 소켓을 사용하는 경우 TCP / IP 관련 소켓 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22b4fec2b9413e137341f86ae67c8350043b7d53" translate="yes" xml:space="preserve">
          <source>If a UDT does not have a direct super type, it is not listed here. A row of the &lt;code&gt;ResultSet&lt;/code&gt; object returned by this method describes the designated UDT and a direct supertype. A row has the following columns:</source>
          <target state="translated">If a UDT does not have a direct super type, it is not listed here. A row of the &lt;code&gt;ResultSet&lt;/code&gt; object returned by this method describes the designated UDT and a direct supertype. A row has the following columns:</target>
        </trans-unit>
        <trans-unit id="27875d35d17c64c41e9933d166925700a1b171f4" translate="yes" xml:space="preserve">
          <source>If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.</source>
          <target state="translated">바인딩이이 컨텍스트에 추가되거나이 컨텍스트에서 제거되면 이전에 리턴 된 열거에 대한 영향은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d7601c05999ae661b9aa6d9768d23b6fac1b78b" translate="yes" xml:space="preserve">
          <source>If a border has been set on this component, returns the border's insets, else calls super.getInsets.</source>
          <target state="translated">If a border has been set on this component, returns the border's insets, else calls super.getInsets.</target>
        </trans-unit>
        <trans-unit id="60267cd6f737fd6024fc6b14a87a199eac11a918" translate="yes" xml:space="preserve">
          <source>If a border has been set on this component, returns the border's insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt;.</source>
          <target state="translated">If a border has been set on this component, returns the border's insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4d13fb061d48c8e4e28fb887ecf8598eb732db" translate="yes" xml:space="preserve">
          <source>If a borrow occurs in the days field (in other words, if the computation needs to borrow 1 or -1 month to compensate days), then the computation fails by throwing an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a borrow occurs in the days field (in other words, if the computation needs to borrow 1 or -1 month to compensate days), then the computation fails by throwing an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2b8644225e60775049f73144977a4d20b30637be" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;engineSetSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom implementation to seed itself. This self-seeding will not occur if &lt;code&gt;engineSetSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">&lt;code&gt;engineSetSeed&lt;/code&gt; 에 대한 호출 이 이전에 발생하지 않은 경우, 이 메소드에 대한 첫 번째 호출은이 SecureRandom 구현을 강제로 시드합니다. &lt;code&gt;engineSetSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자동 시딩이 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="911ec002bf686d39657f3069553cf1c3b5b5def4" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;setSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">&lt;code&gt;setSeed&lt;/code&gt; 에 대한 호출 이 이전에 발생하지 않은 경우, 이 메소드에 대한 첫 번째 호출은이 SecureRandom 오브젝트를 강제로 시드합니다. &lt;code&gt;setSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자체 시드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="17ddc7ad6d330841c65c3723b7bd2743059a6602" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done.</source>
          <target state="translated">If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done.</target>
        </trans-unit>
        <trans-unit id="334736f49b8d7e0587d8194db7199baa9d06b47d" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done. This code is used in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt;] . Refer to this specification for further information.</source>
          <target state="translated">If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done. This code is used in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt;] . Refer to this specification for further information.</target>
        </trans-unit>
        <trans-unit id="12d3ca455a566616659c43d38fa4c19d72a68ea1" translate="yes" xml:space="preserve">
          <source>If a card is present in this terminal when this method is called, it returns immediately.</source>
          <target state="translated">If a card is present in this terminal when this method is called, it returns immediately.</target>
        </trans-unit>
        <trans-unit id="05d89b94bbc85cf7d77886e27828d6c62151d272" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;\u0000&lt;/code&gt; or is in the range &lt;code&gt;\u0080&lt;/code&gt; through &lt;code&gt;\u07ff&lt;/code&gt;, then it is represented by two bytes, to be written in the order shown:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0000&lt;/code&gt; 이거나 &lt;code&gt;\u0080&lt;/code&gt; ~ &lt;code&gt;\u07ff&lt;/code&gt; 범위에있는 경우 , 표시된 순서대로 기록되도록 2 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cced7ce9329a5beb13d9d0de6d94d760dcc0c4e8" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0001&lt;/code&gt; through &lt;code&gt;\u007f&lt;/code&gt;, it is represented by one byte:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0001&lt;/code&gt; ~ &lt;code&gt;\u007f&lt;/code&gt; 범위에 있으면 1 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="07952f6eaca135b300da4ff28ea9b192ef542fea" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0800&lt;/code&gt; through &lt;code&gt;uffff&lt;/code&gt;, then it is represented by three bytes, to be written in the order shown:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0800&lt;/code&gt; 에서 &lt;code&gt;uffff&lt;/code&gt; 까지 의 범위에있는 경우, 표시된 순서대로 3 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0d5494a676f207ae321fc2c494aa6a96120e143c" translate="yes" xml:space="preserve">
          <source>If a character with value &lt;code&gt;ch&lt;/code&gt; occurs in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object at an index no smaller than &lt;code&gt;fromIndex&lt;/code&gt;, then the index of the first such occurrence is returned. For values of &lt;code&gt;ch&lt;/code&gt; in the range from 0 to 0xFFFF (inclusive), this is the smallest value</source>
          <target state="translated">값이 &lt;code&gt;ch&lt;/code&gt; 인 문자 가 &lt;code&gt;fromIndex&lt;/code&gt; 보다 작은 인덱스 에서이 &lt;code&gt;String&lt;/code&gt; 객체가 나타내는 문자 시퀀스에서 발생하는 경우 , 그러한 첫 번째 발생의 인덱스가 리턴됩니다. 0에서 0xFFFF (포함) 범위 의 &lt;code&gt;ch&lt;/code&gt; 값의 경우 가장 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="88d64da6fa30bc481b1c1898ad57b4a92324448a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA&lt;/i&gt;&lt;/a&gt; 문자 세트 &lt;i&gt;레지스트리에&lt;/i&gt; 나열된 문자 세트 가 Java 플랫폼의 구현에서 지원되는 경우 표준 이름은 레지스트리에 나열된 이름이어야합니다. 많은 문자 집합에 레지스트리에 둘 이상의 이름이 지정됩니다.이 경우 레지스트리는 이름 중 하나를</target>
        </trans-unit>
        <trans-unit id="835ccd3a2f50b48c8dbdc664f50805c5e332968a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</target>
        </trans-unit>
        <trans-unit id="7a4670c109b4e15f0dcd8e95409c55e92f7d1ad1" translate="yes" xml:space="preserve">
          <source>If a class is defined in an &lt;em&gt;unnamed module&lt;/em&gt; then the second element is omitted as shown in &quot;&lt;code&gt;com.foo.loader//com.foo.bar.App.run(App.java:12)&lt;/code&gt;&quot;.</source>
          <target state="translated">If a class is defined in an &lt;em&gt;unnamed module&lt;/em&gt; then the second element is omitted as shown in &quot; &lt;code&gt;com.foo.loader//com.foo.bar.App.run(App.java:12)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="6fc4948186617f7bd346a9a17fd3789662107304" translate="yes" xml:space="preserve">
          <source>If a class loader wishes to define a package with specific properties, such as version information, then the class loader should call this &lt;code&gt;definePackage&lt;/code&gt; method before calling &lt;code&gt;defineClass&lt;/code&gt;. Otherwise, the &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; method will define a package in this class loader corresponding to the package of the newly defined class; the properties of this defined package are specified by &lt;a href=&quot;package&quot;&gt;&lt;code&gt;Package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If a class loader wishes to define a package with specific properties, such as version information, then the class loader should call this &lt;code&gt;definePackage&lt;/code&gt; method before calling &lt;code&gt;defineClass&lt;/code&gt; . Otherwise, the &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; &lt;/a&gt; method will define a package in this class loader corresponding to the package of the newly defined class; the properties of this defined package are specified by &lt;a href=&quot;package&quot;&gt; &lt;code&gt;Package&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2e1f6c2a012c9ee1480d2aea7e18a07e1c842c87" translate="yes" xml:space="preserve">
          <source>If a class provides explicit BeanInfo about itself then we add that to the BeanInfo information we obtained from analyzing any derived classes, but we regard the explicit information as being definitive for the current class and its base classes, and do not proceed any further up the superclass chain.</source>
          <target state="translated">클래스가 자신에 대한 명시 적 BeanInfo를 제공하는 경우 파생 클래스를 분석하여 얻은 BeanInfo 정보에 해당 정보를 추가하지만 명시 적 정보는 현재 클래스 및 기본 클래스에 대해 결정적인 것으로 간주하고 더 이상 진행하지 않습니다. 슈퍼 클래스 체인.</target>
        </trans-unit>
        <trans-unit id="2cd6058bf392d70f519fdd4e9472bf934b1511bc" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a &lt;code&gt;PrintQuality&lt;/code&gt; attribute which often controls resolution.</source>
          <target state="translated">If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a &lt;code&gt;PrintQuality&lt;/code&gt; attribute which often controls resolution.</target>
        </trans-unit>
        <trans-unit id="acece6c1313b9c506151182d4c10bc5adcf63087" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a PrintQuality attribute which often controls resolution.</source>
          <target state="translated">클라이언트가 필요한 최소값보다 큰 해상도를 지원하는 프린터를 찾으려면이 속성을 조회 요청에서 제외하고 지원되는 해상도를 직접 쿼리하고 클라이언트의 요구 사항에 가장 적합한 프린터를 지정해야합니다. 요구 사항. 경우에 따라 종종 해상도를 제어하는 ​​PrintQuality 속성을 지정하여보다 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ce72ead2f2b5aae2c69c76ea112e52bebf52e8" translate="yes" xml:space="preserve">
          <source>If a collection refuses to add a particular element for any reason other than that it already contains the element, it</source>
          <target state="translated">컬렉션이 이미 요소를 포함하고있는 것 이외의 다른 이유로 특정 요소 추가를 거부하면 컬렉션</target>
        </trans-unit>
        <trans-unit id="41ab0ee2bc38c356fcd8956baea5b131f76b3cf6" translate="yes" xml:space="preserve">
          <source>If a component hierarchy contains validate roots and the new optimized &lt;code&gt;invalidate()&lt;/code&gt; behavior is enabled, the &lt;code&gt;validate()&lt;/code&gt; method must be invoked on the validate root of a previously invalidated component to restore the validity of the hierarchy later. Otherwise, calling the &lt;code&gt;validate()&lt;/code&gt; method on the top-level container (such as a &lt;code&gt;Frame&lt;/code&gt; object) should be used to restore the validity of the component hierarchy.</source>
          <target state="translated">If a component hierarchy contains validate roots and the new optimized &lt;code&gt;invalidate()&lt;/code&gt; behavior is enabled, the &lt;code&gt;validate()&lt;/code&gt; method must be invoked on the validate root of a previously invalidated component to restore the validity of the hierarchy later. Otherwise, calling the &lt;code&gt;validate()&lt;/code&gt; method on the top-level container (such as a &lt;code&gt;Frame&lt;/code&gt; object) should be used to restore the validity of the component hierarchy.</target>
        </trans-unit>
        <trans-unit id="0d2698c7a918c9b4b3b198d13142ac40d60315ae" translate="yes" xml:space="preserve">
          <source>If a component spans rows it is aligned either to the baseline of the start row (if the baseline-resize behavior is &lt;code&gt;
 CONSTANT_ASCENT&lt;/code&gt;) or the end row (if the baseline-resize behavior is &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt;). The row that the component is aligned to is called the &lt;em&gt;prevailing row&lt;/em&gt;.</source>
          <target state="translated">If a component spans rows it is aligned either to the baseline of the start row (if the baseline-resize behavior is &lt;code&gt; CONSTANT_ASCENT&lt;/code&gt; ) or the end row (if the baseline-resize behavior is &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt; ). The row that the component is aligned to is called the &lt;em&gt;prevailing row&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="6d2eb7a73c51f56dc6865791e43b959fff2b8eaf" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;#connectFailed(java.net.URI,java.net.SocketAddress,java.io.IOException)&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;#connectFailed(java.net.URI,java.net.SocketAddress,java.io.IOException)&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</target>
        </trans-unit>
        <trans-unit id="c4776000b1707ea1d8288ccc9e65458bb1c58a2d" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">프록시 (PROXY 또는 SOCKS) 서버에 연결할 수없는 경우 호출자는 프록시 선택기 에게 프록시 서버를 사용할 수 없음을 알리기 위해 프록시 선택기 의 &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4eae2f1f9567895366b2134e4a320c3d0b03090" translate="yes" xml:space="preserve">
          <source>If a constructor is annotated by the both &lt;code&gt;@java.beans.ConstructorProperties&lt;/code&gt; and &lt;code&gt;@javax.management.ConstructorParameters&lt;/code&gt; annotations the JMX introspection will give an absolute precedence to the latter one.</source>
          <target state="translated">If a constructor is annotated by the both &lt;code&gt;@java.beans.ConstructorProperties&lt;/code&gt; and &lt;code&gt;@javax.management.ConstructorParameters&lt;/code&gt; annotations the JMX introspection will give an absolute precedence to the latter one.</target>
        </trans-unit>
        <trans-unit id="66d389f1702f33b50016c87da612c3454fb27ac7" translate="yes" xml:space="preserve">
          <source>If a cookie corresponding to the given URI already exists, then it is replaced with the new one.</source>
          <target state="translated">주어진 URI에 해당하는 쿠키가 이미 존재하면 새로운 쿠키로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="a0e617630717a0b35f702c38de0ff62f4e555322" translate="yes" xml:space="preserve">
          <source>If a custom system class loader is configured (by means of the system property &lt;code&gt;java.system.class.loader&lt;/code&gt; as specified in the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;getSystemClassLoader&lt;/code&gt;&lt;/a&gt; method) then it must define the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method as specified in &lt;a href=&quot;instrumentation#appendToSystemClassLoaderSearch(java.util.jar.JarFile)&quot;&gt;&lt;code&gt;appendToSystemClassLoaderSearch&lt;/code&gt;&lt;/a&gt;. In other words, a custom system class loader must support the mechanism to add an agent JAR file to the system class loader search.</source>
          <target state="translated">If a custom system class loader is configured (by means of the system property &lt;code&gt;java.system.class.loader&lt;/code&gt; as specified in the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;getSystemClassLoader&lt;/code&gt; &lt;/a&gt; method) then it must define the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method as specified in &lt;a href=&quot;instrumentation#appendToSystemClassLoaderSearch(java.util.jar.JarFile)&quot;&gt; &lt;code&gt;appendToSystemClassLoaderSearch&lt;/code&gt; &lt;/a&gt;. In other words, a custom system class loader must support the mechanism to add an agent JAR file to the system class loader search.</target>
        </trans-unit>
        <trans-unit id="df8f1040f8046d584674ec649bf9175bb489aff9" translate="yes" xml:space="preserve">
          <source>If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">데이터 그램을 즉시 사용할 수 있거나이 채널이 블로킹 모드에 있고 결국 하나를 사용할 수있게되면 데이터 그램이 지정된 바이트 버퍼에 복사되고 소스 주소가 반환됩니다. 이 채널이 비 블로킹 모드에 있고 데이터 그램을 즉시 사용할 수없는 경우이 메서드는 즉시 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0818faad6aab3d19f4e535d7f7f60ce1951d12ec" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator()&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator()&quot;&gt;decimal separator&lt;/a&gt; is substituted.</target>
        </trans-unit>
        <trans-unit id="1a7a080897c03d2a2dec7ade95e887516b9ac13d" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">소수 구분 기호가 있으면 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;소수 구분 기호&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c1f9b7f79d8ec91fb01ae3268899c778ab68a65" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;#setDefault(javax.net.ssl.SSLContext)&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">If a default context was set using the &lt;a href=&quot;#setDefault(javax.net.ssl.SSLContext)&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; . If successful, that object is made the default SSL context and returned.</target>
        </trans-unit>
        <trans-unit id="ef151b03b8bdfd0c5b1285060dc05b180bd41b5a" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">&lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 기본 컨텍스트를 설정 한 경우 리턴됩니다. 그렇지 않은 경우,이 메소드의 첫 번째 호출은 &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; 호출을 트리거합니다 . 성공하면 해당 오브젝트가 기본 SSL 컨텍스트가되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="51c46ada07dadd84ce5e7fda86de6679eac1d1c4" translate="yes" xml:space="preserve">
          <source>If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls &lt;code&gt;revalidate&lt;/code&gt;, validate from here on down.</source>
          <target state="translated">If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls &lt;code&gt;revalidate&lt;/code&gt; , validate from here on down.</target>
        </trans-unit>
        <trans-unit id="6749109880140700857e250f0be8ceceea7ff072" translate="yes" xml:space="preserve">
          <source>If a destination &lt;code&gt;URI&lt;/code&gt; is specified in a PrintRequest and it is not accessible for output by the &lt;code&gt;PrintService&lt;/code&gt;, a &lt;code&gt;PrintException&lt;/code&gt; will be thrown. The &lt;code&gt;PrintException&lt;/code&gt; may implement &lt;code&gt;URIException&lt;/code&gt; to provide a more specific cause.</source>
          <target state="translated">If a destination &lt;code&gt;URI&lt;/code&gt; is specified in a PrintRequest and it is not accessible for output by the &lt;code&gt;PrintService&lt;/code&gt; , a &lt;code&gt;PrintException&lt;/code&gt; will be thrown. The &lt;code&gt;PrintException&lt;/code&gt; may implement &lt;code&gt;URIException&lt;/code&gt; to provide a more specific cause.</target>
        </trans-unit>
        <trans-unit id="14abd8b4a751858e76b43b1c734186c7f7ef97b3" translate="yes" xml:space="preserve">
          <source>If a destination URI is specified in a PrintRequest and it is not accessible for output by the PrintService, a PrintException will be thrown. The PrintException may implement URIException to provide a more specific cause.</source>
          <target state="translated">목적지 URI가 PrintRequest에 지정되고 PrintService에서 출력 할 수없는 경우 PrintException이 발생합니다. PrintException은보다 구체적인 원인을 제공하기 위해 URIException을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce1a2c4f98ff2d6af0860f8597c46c4d0b903836" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively.</source>
          <target state="translated">If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively.</target>
        </trans-unit>
        <trans-unit id="8bacc9e3344a41d79a4651f2c7e9da527b4943d5" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively. For example, the property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getReceiver&lt;/code&gt; is called: if the class &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; exists in the list of installed MIDI device providers, the first &lt;code&gt;Receiver&lt;/code&gt; device with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Receiver&lt;/code&gt; from that provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Receiver&lt;/code&gt; with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; in the list of all devices (as returned by &lt;code&gt;getMidiDeviceInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Receiver&lt;/code&gt; that can be found in the list of all devices is returned. If that fails, too, a &lt;code&gt;MidiUnavailableException&lt;/code&gt; is thrown.</source>
          <target state="translated">장치 이름을 지정하면 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체 의 결과 목록 이 검색됩니다. 이름이 일치하고 &lt;code&gt;MidiDevice&lt;/code&gt; 가 해당 인터페이스를 구현 하는 첫 번째 목록 이 반환됩니다. 일치하는 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체가 없거나 장치 이름을 지정하지 않으면 결과 목록에서 첫 번째로 적합한 장치가 반환됩니다. 시퀀서 및 신시사이저의 경우, 각 인터페이스를 구현하는 경우 장치가 적합합니다. 수신기와 송신기의 경우 장치는 시퀀서 나 신시사이저를 구현하지 않고 각각 하나 이상의 수신기 나 송신기를 제공하는 경우에 적합합니다. 예를 들어, 값이있는 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 특성 &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; 때 다음과 같은 결과를 초래할 &lt;code&gt;getReceiver&lt;/code&gt; 가 호출됩니다 클래스의 경우 &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; 가 설치된 MIDI 장치 공급자 목록에있는 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 장치를 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 이라는 이름 이 반환됩니다. 찾을 수 없으면 이름에 관계없이 해당 제공자 의 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 가 리턴됩니다. 없는 경우, 모든 장치 목록에서 이름이 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 인 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; ( &lt;code&gt;getMidiDeviceInfo&lt;/code&gt; 가 리턴 한 )가 리턴되거나 발견되지 않은 경우 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 가 리턴됩니다.모든 장치 목록에서 찾을 수 있습니다. 이것도 실패하면 &lt;code&gt;MidiUnavailableException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c348cf79394a1b079ec5b17aaca7e9df6caf0f51" translate="yes" xml:space="preserve">
          <source>If a disconnected &lt;code&gt;RowSet&lt;/code&gt; object modifies some of its data, and it has a writer associated with it, it may be implemented so that it calls on the writer's &lt;code&gt;writeData&lt;/code&gt; method internally to write the updates back to the data source. In order to do this, the writer must first establish a connection with the rowset's data source.</source>
          <target state="translated">If a disconnected &lt;code&gt;RowSet&lt;/code&gt; object modifies some of its data, and it has a writer associated with it, it may be implemented so that it calls on the writer's &lt;code&gt;writeData&lt;/code&gt; method internally to write the updates back to the data source. In order to do this, the writer must first establish a connection with the rowset's data source.</target>
        </trans-unit>
        <trans-unit id="96852e06c1dca016e17f4895cd5c8ddd5ec791ac" translate="yes" xml:space="preserve">
          <source>If a document is valid, or if a document contains some errors but none of them were fatal and the &lt;code&gt;ErrorHandler&lt;/code&gt; didn't throw any exception, then the method returns normally.</source>
          <target state="translated">If a document is valid, or if a document contains some errors but none of them were fatal and the &lt;code&gt;ErrorHandler&lt;/code&gt; didn't throw any exception, then the method returns normally.</target>
        </trans-unit>
        <trans-unit id="1dc1d0d7d632f8adb52a90a5d33de0f5ebfd86ab" translate="yes" xml:space="preserve">
          <source>If a factory is instantiated, it is invoked with the following parameters to produce the resulting context.</source>
          <target state="translated">팩토리가 인스턴스화되면 결과 매개 변수를 생성하기 위해 다음 매개 변수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="61b02e48c383e6261e3240e4271679924e0689b0" translate="yes" xml:space="preserve">
          <source>If a fieldValue is an object then the toString() method is called on it and its returned value is used as the value for the field enclosed in parenthesis.</source>
          <target state="translated">fieldValue가 객체이면 toString () 메서드가 호출되고 반환 된 값이 괄호로 묶인 필드의 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fbb5e24d20d361c0ea0a62c5f3f2f90aea684d9" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;documentationtool.location&quot;&gt;&lt;code&gt;DocumentationTool.Location&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt;&lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 관리자가 제공되면 &lt;a href=&quot;documentationtool.location&quot;&gt; &lt;code&gt;DocumentationTool.Location&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 위치 와 &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt; &lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt; &lt;/a&gt; 를 처리 할 수 ​​있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdbf6cb18404a64f45d2b8abf710d01eb9d7f2cb" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;standardlocation&quot;&gt;&lt;code&gt;StandardLocation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 관리자가 제공되면 &lt;a href=&quot;standardlocation&quot;&gt; &lt;code&gt;StandardLocation&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 위치를 처리 할 수 ​​있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e77610d088ca1d95b7392fcd2274aef9c2f8d21" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;F&lt;/code&gt; applies to the &lt;code&gt;N&lt;/code&gt;th argument of the target, then &lt;code&gt;F&lt;/code&gt; must be a method handle which takes exactly one argument. The type of &lt;code&gt;F&lt;/code&gt;'s sole argument replaces the corresponding argument type of the target in the resulting adapted method handle. The return type of &lt;code&gt;F&lt;/code&gt; must be identical to the corresponding parameter type of the target.</source>
          <target state="translated">필터하면 &lt;code&gt;F&lt;/code&gt; 가 받는 적용 &lt;code&gt;N&lt;/code&gt; 타겟의 번째 인수 후 &lt;code&gt;F&lt;/code&gt; 는 한 인자를 취하는 방법 핸들이어야한다. 의 타입 &lt;code&gt;F&lt;/code&gt; 의 유일한 인자 생성하도록 핸들 방법에서 대상의 대응하는 인수 유형을 대체한다. &lt;code&gt;F&lt;/code&gt; 의 리턴 유형은 대상의 해당 매개 변수 유형과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8312dbe0498425dc3e432f47a6cc52909ff0f4aa" translate="yes" xml:space="preserve">
          <source>If a fini function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the loop return type.</source>
          <target state="translated">If a fini function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the loop return type.</target>
        </trans-unit>
        <trans-unit id="0f0b37f0970ece4cf3ea7a2708e4bc36a7d62db5" translate="yes" xml:space="preserve">
          <source>If a font in this environment has multiple programmable variations, such as Multiple-Master fonts, only one instance of that font is returned in the &lt;code&gt;Font&lt;/code&gt; array. The other variations must be derived by the application.</source>
          <target state="translated">If a font in this environment has multiple programmable variations, such as Multiple-Master fonts, only one instance of that font is returned in the &lt;code&gt;Font&lt;/code&gt; array. The other variations must be derived by the application.</target>
        </trans-unit>
        <trans-unit id="77fff40663a1f21028623e35281e042a8419f5f8" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">형식 매개 변수 유형이 매개 변수화 된 유형 인 경우, 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="48218943f2a8994e2b422a9456a012477f87f4f0" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">형식 매개 변수 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa45ce5030fe67e696cd9c90f1c3d32a9e26312" translate="yes" xml:space="preserve">
          <source>If a format specifier contains a conversion character that is not applicable to the corresponding argument, then an &lt;a href=&quot;illegalformatconversionexception&quot;&gt;&lt;code&gt;IllegalFormatConversionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">형식 지정자에 해당 인수에 적용 할 수없는 변환 문자가 포함 된 경우 &lt;a href=&quot;illegalformatconversionexception&quot;&gt; &lt;code&gt;IllegalFormatConversionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47e2137fd18da09bdd7e054d7015bc33023b31e0" translate="yes" xml:space="preserve">
          <source>If a given &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies no static arguments, the instruction's bootstrap method will be invoked on three arguments, conveying the instruction's caller class, name, and method type. If the &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies one or more static arguments, those values will be passed as additional arguments to the method handle. (Note that because there is a limit of 255 arguments to any method, at most 251 extra arguments can be supplied, since the bootstrap method handle itself and its first three arguments must also be stacked.) The bootstrap method will be invoked as if by either &lt;code&gt;MethodHandle.invoke&lt;/code&gt; or &lt;code&gt;invokeWithArguments&lt;/code&gt;. (There is no way to tell the difference.)</source>
          <target state="translated">주어진 &lt;code&gt;invokedynamic&lt;/code&gt; 명령이 정적 인수를 지정하지 않으면 명령의 부트 스트랩 메소드는 명령의 호출자 클래스, 이름 및 메소드 유형을 전달하는 세 개의 인수에서 호출됩니다. 경우] &lt;code&gt;invokedynamic&lt;/code&gt; 명령이 하나 개 이상의 정적 인수 지정이 값은 방법 핸들 추가적인 인수로 전달한다. (모든 메소드에는 255 개의 인수가 제한되어 있기 때문에 부트 스트랩 메소드 자체를 처리하고 처음 세 개의 인수도 스택해야하므로 최대 251 개의 추가 인수를 제공 할 수 있습니다.) 부트 스트랩 메소드는 다음과 같이 호출됩니다. &lt;code&gt;MethodHandle.invoke&lt;/code&gt; 또는 &lt;code&gt;invokeWithArguments&lt;/code&gt; 중 하나 입니다. (차이를 알 수있는 방법이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="a80d4c3ad4e53040c1a39d7a7bdca9679c68c78f" translate="yes" xml:space="preserve">
          <source>If a horizontal scrollbar is needed, it is treated like the column header (see the paragraph above regarding the vertical scrollbar).</source>
          <target state="translated">If a horizontal scrollbar is needed, it is treated like the column header (see the paragraph above regarding the vertical scrollbar).</target>
        </trans-unit>
        <trans-unit id="1b302c4fa309e55608aa77d71aa898540e38e284" translate="yes" xml:space="preserve">
          <source>If a host is given then it is appended. If the host is a literal IPv6 address but is not enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;) then the square brackets are added.</source>
          <target state="translated">호스트가 제공되면 호스트가 추가됩니다. 호스트가 리터럴 IPv6 주소이지만 대괄호 ( &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; )로 묶이지 않은 경우 대괄호가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3c059615b57ed62378344964e37548f3b0e6335b" translate="yes" xml:space="preserve">
          <source>If a list of several images was specified as a Window's icon, this method will return the first item of the list.</source>
          <target state="translated">If a list of several images was specified as a Window's icon, this method will return the first item of the list.</target>
        </trans-unit>
        <trans-unit id="7a15cd0977f55c58d7c0850d3c01c8a63da1d40d" translate="yes" xml:space="preserve">
          <source>If a logical line is spread across several natural lines, the backslash escaping the line terminator sequence, the line terminator sequence, and any white space at the start of the following line have no affect on the key or element values. The remainder of the discussion of key and element parsing (when loading) will assume all the characters constituting the key and element appear on a single natural line after line continuation characters have been removed. Note that it is</source>
          <target state="translated">논리적 선이 여러 개의 자연 선으로 분산 된 경우 선 종결 자 시퀀스, 선 종결 자 시퀀스 및 다음 줄의 시작 부분의 공백을 이스케이프하는 백 슬래시는 키 또는 요소 값에 영향을 미치지 않습니다. 키 및 요소 구문 분석 (로드시)에 대한 나머지 설명에서는 키와 요소를 구성하는 모든 문자가 줄 연속 문자가 제거 된 후 하나의 자연 줄에 나타나는 것으로 가정합니다. 참고</target>
        </trans-unit>
        <trans-unit id="cd8e0bbcc783eadd4865fc925b200f06558d3ae6" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the component's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the component's &lt;code&gt;TransferHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6cc836fe190aff287b75e0daabe7ceb48e9d86e" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the list's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">이 속성을 무시하는 룩앤필이 사용 된 경우에도 목록의 &lt;code&gt;TransferHandler&lt;/code&gt; 에서 &lt;code&gt;exportAsDrag&lt;/code&gt; 를 호출하여 드래그 앤 드롭 작업을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfc09a82d3ef30f5685534ffe059fc2caa38aa88" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the table's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">이 속성을 무시하는 룩앤필이 사용 된 경우에도 테이블의 &lt;code&gt;TransferHandler&lt;/code&gt; 에서 &lt;code&gt;exportAsDrag&lt;/code&gt; 를 호출하여 끌어서 놓기 작업을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccd26ad32dd26739826327f4b3d5f7134a7882ee" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the tree's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">이 속성을 무시하는 룩앤필이 사용 된 경우에도 트리의 &lt;code&gt;TransferHandler&lt;/code&gt; 에서 &lt;code&gt;exportAsDrag&lt;/code&gt; 를 호출하여 끌어서 놓기 작업을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2255669d20b77ac21c330711ce13f6ea363e0b8f" translate="yes" xml:space="preserve">
          <source>If a mapping for &lt;code&gt;uiClassID&lt;/code&gt; exists or if the specified class can't be found, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uiClassID&lt;/code&gt; 에 대한 매핑 이 존재하거나 지정된 클래스를 찾을 수없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3a82003bc08000c8f46219ed82ab846fd6727cbe" translate="yes" xml:space="preserve">
          <source>If a match to the specified pattern is not found at the current position, then no input is skipped and a &lt;code&gt;NoSuchElementException&lt;/code&gt; is thrown.</source>
          <target state="translated">지정된 패턴과 일치하는 항목이 현재 위치에 없으면 입력을 건너 뛰지 않고 &lt;code&gt;NoSuchElementException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e40a20d79d378f273949a8affbffa48e1bdad009" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;public&lt;/code&gt; entry is found, it is returned immediately.</source>
          <target state="translated">일치하는 경우 &lt;code&gt;public&lt;/code&gt; 항목이 발견되면 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f69b5cff049ebc9630323ba63bb4d652364d38f2" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;system&lt;/code&gt; entry exists, it is returned immediately.</source>
          <target state="translated">매칭 &lt;code&gt;system&lt;/code&gt; 항목이 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="42a4c103812a63e5b048b88e9e4af583a5c904c6" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;uri&lt;/code&gt; entry is found, it is returned immediately.</source>
          <target state="translated">일치하는 &lt;code&gt;uri&lt;/code&gt; 항목이 발견되면 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="041906718779e0735497b8d8a4420c278fc6dbb9" translate="yes" xml:space="preserve">
          <source>If a mechanism is listed in the &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; security property, it will be ignored and won't be negotiated.</source>
          <target state="translated">메커니즘이 &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; 에 나열되는 경우 보안 속성에 있으면 무시되고 협상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03f7ab2c34aa311345e83cbc387505226e713e48" translate="yes" xml:space="preserve">
          <source>If a method handle for a caller-sensitive method is requested, the general rules for &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply, but they take account of the lookup class in a special way. The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class. (By contrast, the invoker of the method handle is disregarded.) Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles.</source>
          <target state="translated">호출자 구분 메소드에 대한 메소드 핸들이 요청되면 &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;바이트 코드 동작에&lt;/a&gt; 대한 일반 규칙이 적용되지만 특수한 방식으로 조회 클래스를 고려합니다. 결과 메소드 핸들은 조회 클래스에 포함 된 명령에서 호출 된 것처럼 작동하므로 호출자 감지 메소드는 조회 클래스를 감지합니다. 대조적으로, 메소드 핸들의 호출자는 무시됩니다. 따라서 호출자 감지 메소드의 경우, 다른 검색 클래스가 다르게 작동하는 메소드 핸들을 야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de9caf9128a5abc525b8ff949c024d6c3b7462b7" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned.</source>
          <target state="translated">믹서 이름이 지정되면 &lt;code&gt;Mixer.Info&lt;/code&gt; 개체 의 결과 목록 이 검색됩니다. 일치하는 이름을 가진 첫 번째 목록 과 해당 &lt;code&gt;Mixer&lt;/code&gt; 가 해당 라인 인터페이스를 제공 하는 믹서 가 반환됩니다. 일치하는 &lt;code&gt;Mixer.Info&lt;/code&gt; 가 없는 경우 개체가 없거나 믹서 이름이 지정되지 않은 경우 결과 목록에서 각 라인 인터페이스를 제공하는 첫 번째 믹서가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4e595c2df825132a51481c97b50495434dfe5e" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned. For example, the property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getLine&lt;/code&gt; is called requesting a &lt;code&gt;Clip&lt;/code&gt; instance: if the class &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; exists in the list of installed mixer providers, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer of the specified provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Clip&lt;/code&gt; from the first &lt;code&gt;Mixer&lt;/code&gt; with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; in the list of all mixers (as returned by &lt;code&gt;getMixerInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Clip&lt;/code&gt; of the first &lt;code&gt;Mixer&lt;/code&gt;that can be found in the list of all mixers is returned. If that fails, too, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">믹서 이름을 지정하면 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체 의 결과 목록 이 검색됩니다. 이름이 일치하고 &lt;code&gt;Mixer&lt;/code&gt; 가 해당 회선 인터페이스를 제공 하는 첫 번째 목록 이 반환됩니다. 일치하는 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체가 없거나 믹서 이름을 지정하지 않으면 결과 목록에서 각 라인 인터페이스를 제공하는 첫 번째 믹서가 반환됩니다. 예를 들어, 값이 &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; 인 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 등록 정보 는 &lt;code&gt;getLine&lt;/code&gt; 이 &lt;code&gt;Clip&lt;/code&gt; 인스턴스 요청 시 호출 될 때 다음과 같은 결과를 초래 합니다. 클래스 &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; 설치된 믹서 제공 업체 목록에 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 이라는 이름을 가진 첫 번째 믹서의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 반환됩니다. 찾을 수 없으면 지정된 공급자의 첫 번째 믹서의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 이름에 관계없이 반환됩니다. 없는 경우, 모든 믹서 목록에서 이름이 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 인 첫 번째 &lt;code&gt;Mixer&lt;/code&gt; 의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; ( &lt;code&gt;getMixerInfo&lt;/code&gt; 에서 반환 됨 )이 반환되거나 발견되지 않으면 첫 번째 &lt;code&gt;Mixer&lt;/code&gt; 의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 발견 될 수 있습니다 모든 믹서 목록에 반환됩니다. 이것도 실패하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57d4cb4422179df06d85df6edeaf036f2c77e296" translate="yes" xml:space="preserve">
          <source>If a module declares more than one provider then the providers are located in the order that its module descriptor &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;lists the providers&lt;/a&gt;. Providers added dynamically by instrumentation agents (see &lt;a href=&quot;../../../java.instrument/java/lang/instrument/instrumentation#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)&quot;&gt;&lt;code&gt;redefineModule&lt;/code&gt;&lt;/a&gt;) are always located after providers declared by the module.</source>
          <target state="translated">모듈이 둘 이상의 공급자를 선언하면 공급자는 해당 모듈 설명자가 &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;공급자를 나열하는&lt;/a&gt; 순서대로 배치됩니다 . 계측 에이전트에 의해 동적으로 추가 된 공급자 ( &lt;a href=&quot;../../../java.instrument/java/lang/instrument/instrumentation#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)&quot;&gt; &lt;code&gt;redefineModule&lt;/code&gt; &lt;/a&gt; 참조) )에 는 항상 모듈에서 선언 한 공급자 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="efaf60a7b1c87aa4ff2f97aa446a4442865cc86e" translate="yes" xml:space="preserve">
          <source>If a module declares more than one provider then the providers are located in the order that its module descriptor &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;lists the providers&lt;/a&gt;. Providers added dynamically by instrumentation agents are always located after providers declared by the module.</source>
          <target state="translated">모듈이 둘 이상의 공급자를 선언하면 공급자는 해당 모듈 설명자가 &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;공급자를 나열하는&lt;/a&gt; 순서대로 배치됩니다. . 계측 에이전트에 의해 동적으로 추가 된 공급자는 항상 모듈에서 선언 한 공급자 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2898de51e2cf727ad3969c2fe5a2e8ee04593e2d" translate="yes" xml:space="preserve">
          <source>If a mouse has more than three enabled buttons then more values are admissible (4, 5, etc.). There is no assigned constants for these extended buttons. The button masks for the extra buttons returned by this method have no assigned names like the first three button masks.</source>
          <target state="translated">마우스에 3 개 이상의 활성화 된 버튼이있는 경우 더 많은 값이 허용됩니다 (4, 5 등). 이러한 확장 버튼에는 지정된 상수가 없습니다. 이 메서드가 반환하는 추가 버튼의 버튼 마스크에는 처음 세 개의 버튼 마스크와 같이 할당 된 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8a0c1b372f5ed387a77d0a8139d565c090fb292" translate="yes" xml:space="preserve">
          <source>If a mutable target is not required, an &lt;code&gt;invokedynamic&lt;/code&gt; instruction may be permanently bound by means of a &lt;a href=&quot;constantcallsite&quot;&gt;constant call site&lt;/a&gt;.</source>
          <target state="translated">변경 가능한 대상이 필요하지 않은 경우 &lt;code&gt;invokedynamic&lt;/code&gt; 명령은 &lt;a href=&quot;constantcallsite&quot;&gt;상수 호출 사이트를&lt;/a&gt; 통해 영구적으로 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d153e3199dbf3a239e1e74edc668dcfac7b620a7" translate="yes" xml:space="preserve">
          <source>If a mutable target is required which has volatile variable semantics, because updates to the target must be immediately and reliably witnessed by other threads, a &lt;a href=&quot;volatilecallsite&quot;&gt;volatile call site&lt;/a&gt; may be used.</source>
          <target state="translated">휘발성 변수 의미가있는 가변 대상이 필요한 경우 다른 스레드가 대상에 대한 업데이트를 즉시 확실하게 감시해야하므로 &lt;a href=&quot;volatilecallsite&quot;&gt;휘발성 호출 사이트를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeca574c1ffd9cbc5b38291c6b65f0adb833dc01" translate="yes" xml:space="preserve">
          <source>If a name for the desired display language is not available, the method may fall back to some other language.</source>
          <target state="translated">원하는 표시 언어의 이름을 사용할 수없는 경우 메서드가 다른 언어로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="657a9f6756d750ee4adc0e4bbc100a654dce7128" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7be17e75afa7fb0ce61b9792a5c8387c175a86f7" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 고유 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="82b7eb3aeab5135e75a853270d3a38d65b14ccb2" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 문서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96afaaa19f7e5c5798f8d8403e551ecc219a3743" translate="yes" xml:space="preserve">
          <source>If a native receiver provided by the default device does not implement the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface. The corresponding &lt;code&gt;Receiver&lt;/code&gt; method calls will be forwarded to the native receiver.</source>
          <target state="translated">기본 장치에서 제공하는 기본 수신기가 구현하지 않는 경우 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 의 인터페이스를, 그것은 래퍼 클래스가 구현하는 것을 감싸됩니다 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 의 인터페이스를 제공합니다. 해당 &lt;code&gt;Receiver&lt;/code&gt; 메소드 호출은 기본 수신자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f15617aacf84e28d7719762bc77a6e2a240fb2d8" translate="yes" xml:space="preserve">
          <source>If a native transmitter provided by the default device does not implement the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface. The corresponding &lt;code&gt;Transmitter&lt;/code&gt; method calls will be forwarded to the native transmitter.</source>
          <target state="translated">기본 장치에서 제공하는 기본 송신기가 구현하지 않는 경우 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 의 인터페이스를, 그것은 래퍼 클래스가 구현하는 것을 감싸됩니다 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 의 인터페이스를 제공합니다. 해당 &lt;code&gt;Transmitter&lt;/code&gt; 메소드 호출은 기본 송신기로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5e81249a7f19b34aae5c963bc81798bff7133902" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will be configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 생성되면 로그 수준이 LogManager를 기반으로 구성되며 로깅 출력도 부모의 처리기로 보내도록 구성됩니다. LogManager 전역 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e885f68e1bc095b374d6b1ebbe1a47153753c95e" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 작성되면 로그 레벨은 LogManager를 기반으로 구성되며 로깅 출력을 상위 핸들러로 보내도록 구성됩니다. LogManager 글로벌 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="88b90c99db81cefd92b6c450a7c98a50da340a3f" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will be configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 생성되면 로그 수준이 LogManager 구성을 기반으로 구성되며 로깅 출력도 부모의 처리기로 보내도록 구성됩니다. LogManager 전역 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="5e945b5d1146ab0148461e7bb66b4cc1b6317073" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 작성되면 로그 레벨은 LogManager 구성을 기반으로 구성되며 로깅 출력을 상위 핸들러로 보내도록 구성됩니다. LogManager 글로벌 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a4f0b05b5c2d22a20b05a71a5d7c135620cfeb" translate="yes" xml:space="preserve">
          <source>If a non-null &lt;code&gt;AbstractFormatter&lt;/code&gt; has not been found, use the default formatter.</source>
          <target state="translated">널 이 아닌 &lt;code&gt;AbstractFormatter&lt;/code&gt; 를 찾지 못한 경우 기본 포맷터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e4374be394b79479c7e1fa5bcc1e8102ae6664e5" translate="yes" xml:space="preserve">
          <source>If a non-null CodeSource is supplied a ProtectionDomain is constructed and associated with the class being defined.</source>
          <target state="translated">널이 아닌 코드 소스가 제공되면 ProtectionDomain이 구성되고 정의중인 클래스와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="ed948d67e59d3b1ab1a6ab69b72cf90841f818b2" translate="yes" xml:space="preserve">
          <source>If a non-null value is returned, then the PropertyEditor should be prepared to parse that string back in setAsText().</source>
          <target state="translated">널이 아닌 값이 리턴되면 PropertyEditor는 해당 문자열을 다시 setAsText ()로 구문 분석 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="f75d62399906604e72f84182bca91703960c54bf" translate="yes" xml:space="preserve">
          <source>If a null dispatcher is specified, if the specified dispatcher is not in the dispatcher chain, or if this KeyboardFocusManager is specified without having been explicitly re-registered, no action is taken and no exception is thrown.</source>
          <target state="translated">널 디스패처가 지정된 경우, 지정된 디스패처가 디스패처 체인에 없거나 명시 적으로 다시 등록되지 않고이 KeyboardFocusManager가 지정된 경우에는 작업이 수행되지 않고 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f7c58a9060f8818a2c1c94eb51743d12a9a275a" translate="yes" xml:space="preserve">
          <source>If a null dispatcher is specified, no action is taken and no exception is thrown.</source>
          <target state="translated">널 디스패처가 지정되면 조치가 수행되지 않고 예외도 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9858a7d611d85aa9445822454181b23692a649db" translate="yes" xml:space="preserve">
          <source>If a null post-processor is specified, if the specified post-processor is not in the post-processor chain, or if this KeyboardFocusManager is specified without having been explicitly added, no action is taken and no exception is thrown.</source>
          <target state="translated">널 포스트 프로세서가 지정되거나 지정된 포스트 프로세서가 포스트 프로세서 체인에 없거나 명시 적으로 추가되지 않고이 KeyboardFocusManager가 지정된 경우에는 작업이 수행되지 않고 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80e5e24189da6aec4a702f1b11675b7d716e2c68" translate="yes" xml:space="preserve">
          <source>If a null post-processor is specified, no action is taken and no exception is thrown.</source>
          <target state="translated">널 포스트 프로세서가 지정되면 조치가 수행되지 않고 예외도 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9d7fb43a6f9ab347881ca798d47872764ac074f" translate="yes" xml:space="preserve">
          <source>If a number is preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and a year has already been recognized, then the number is a time-zone offset. If the number is less than 24, it is an offset measured in hours. Otherwise, it is regarded as an offset in minutes, expressed in 24-hour time format without punctuation. A preceding &lt;code&gt;-&lt;/code&gt; means a westward offset. Time zone offsets are always relative to UTC (Greenwich). Thus, for example, &lt;code&gt;-5&lt;/code&gt; occurring in the string would mean &quot;five hours west of Greenwich&quot; and &lt;code&gt;+0430&lt;/code&gt; would mean &quot;four hours and thirty minutes east of Greenwich.&quot; It is permitted for the string to specify &lt;code&gt;GMT&lt;/code&gt;, &lt;code&gt;UT&lt;/code&gt;, or &lt;code&gt;UTC&lt;/code&gt; redundantly-for example, &lt;code&gt;GMT-5&lt;/code&gt; or &lt;code&gt;utc+0430&lt;/code&gt;.</source>
          <target state="translated">숫자 앞에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 가 있고 연도가 이미 인식 된 경우 숫자는 시간대 오프셋입니다. 숫자가 24보다 작 으면 시간 단위로 측정 된 오프셋입니다. 그렇지 않으면 구두점없이 24 시간 형식으로 표현 된 분 단위 오프셋으로 간주됩니다. 앞에 &lt;code&gt;-&lt;/code&gt; 는 서쪽 방향 오프셋을 의미합니다. 시간대 오프셋은 항상 UTC (그리니치)를 기준으로합니다. 예를 들어, 문자열에서 &lt;code&gt;-5&lt;/code&gt; 가 발생하면 &quot;그리니치에서 서쪽으로 5 시간&quot; 을 의미 하고 &lt;code&gt;+0430&lt;/code&gt; 은 &quot;그리니치에서 동쪽으로 4 시간 30 분&quot;을 의미합니다. 문자열이 &lt;code&gt;GMT&lt;/code&gt; , &lt;code&gt;UT&lt;/code&gt; 또는 &lt;code&gt;UTC&lt;/code&gt; 를 중복 으로 지정할 수 있습니다 (예 : &lt;code&gt;GMT-5&lt;/code&gt; 또는 &lt;code&gt;utc+0430&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">기본 개체가 매개 변수 또는 작업을 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="81c0651f2b5e452650a2ea674b863476cc997e33" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;#getDeclaredType(javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeElement,javax.lang.model.type.TypeMirror...)&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수가있는 형식이 반환되는 경우 해당 형식 요소는 일반 외부 클래스에 포함되지 않아야합니다. 예를 들어 매개 변수화 된 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; 유형을 가져온 다음 &lt;a href=&quot;#getDeclaredType(javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeElement,javax.lang.model.type.TypeMirror...)&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 생성 할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="a7e7b1f4d4e8c47890d4e04c211a6340b6dc972a" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수화 된 유형이 리턴되는 경우 해당 유형 요소는 일반 외부 클래스 내에 포함되지 않아야합니다. 예를 들어, 매개 변수화 된 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; 메소드를 사용하여 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; 을 가져온 후 &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43ccbd75a69c5df862ae14549f2be12f58f6705e" translate="yes" xml:space="preserve">
          <source>If a parsing error occurs, the exception that is thrown will include information about the location of the error in the original XML document.</source>
          <target state="translated">구문 분석 오류가 발생하면 throw되는 예외에 원본 XML 문서의 오류 위치에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b860cee6c1daa1284a85c7a9b7c1c7d6c9380907" translate="yes" xml:space="preserve">
          <source>If a particular concrete charset provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">특정 콘크리트 문자 세트 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 반드시 파일을로드 한 클래스 로더는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fbd441057e8700833c9533c87ba431e637f763c4" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.</source>
          <target state="translated">특정 구체적 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 이것은 파일이 실제로로드 된 클래스 로더 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5da4bf007198af6025012fc0fecd914082583539" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">특정 구체적 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 반드시 파일을로드 한 클래스 로더는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="11cee8d3b1bf0c5f932f0904e55f7a8ab8555e41" translate="yes" xml:space="preserve">
          <source>If a particular provider is specified by a &lt;code&gt;RowSet&lt;/code&gt; object, and the &lt;code&gt;SyncFactory&lt;/code&gt; does not contain a reference to this provider, a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown stating that the synchronization provider could not be found.</source>
          <target state="translated">특정 공급자가 &lt;code&gt;RowSet&lt;/code&gt; 개체에 의해 지정되고 &lt;code&gt;SyncFactory&lt;/code&gt; 에이 공급자에 대한 참조가 포함되지 않은 경우 동기화 공급자를 찾을 수 없음을 나타내는 &lt;code&gt;SyncFactoryException&lt;/code&gt; 이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="29590084579273dadce0a572331ee22aa9d1bda8" translate="yes" xml:space="preserve">
          <source>If a partition has no elements, its value in the result Map will be an empty List.</source>
          <target state="translated">파티션에 요소가없는 경우 결과 맵의 해당 값은 빈 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="42129ba221a5197a6e8db6241f12cd2c90200f85" translate="yes" xml:space="preserve">
          <source>If a partition has no elements, its value in the result Map will be obtained by calling the downstream collector's supplier function and then applying the finisher function.</source>
          <target state="translated">파티션에 요소가없는 경우 결과 맵의 값은 다운 스트림 수집기의 공급 업체 함수를 호출 한 다음 마무리 기능을 적용하여 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d5668fe10c0723c5fca50dcc78c1b35e4b358bc9" translate="yes" xml:space="preserve">
          <source>If a path is given then it is appended. Any character not in the</source>
          <target state="translated">경로가 제공되면 추가됩니다. 에없는 모든 문자</target>
        </trans-unit>
        <trans-unit id="0e5a965d6474edf02c5830767daff8c0d82cf26d" translate="yes" xml:space="preserve">
          <source>If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.</source>
          <target state="translated">패턴을 여러 번 사용하는 경우 한 번 컴파일 한 후 재사용하면 매번이 메소드를 호출하는 것보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="89b4c008a45797eef3268e7fe508720bf307f893" translate="yes" xml:space="preserve">
          <source>If a permit is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">허가가 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="42b24fec51a71ad010963ae360a48a8c5d862862" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;#setPersistenceDelegate(java.lang.Class,java.beans.PersistenceDelegate)&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">지속성 위임이 &lt;a href=&quot;#setPersistenceDelegate(java.lang.Class,java.beans.PersistenceDelegate)&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 주어진 유형과 연관되면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="619e1dee8db482adbcc19510b522caad9b3dd86b" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">지속성 대리자가 &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 지정된 유형과 연관되어 있으면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="11d9ed1e56dc29ed992752f78c70910959ce2ab4" translate="yes" xml:space="preserve">
          <source>If a port number is given then a colon character (&lt;code&gt;':'&lt;/code&gt;) is appended, followed by the port number in decimal.</source>
          <target state="translated">포트 번호가 제공되면 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; )가 추가되고 그 뒤에 포트 번호가 10 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d701428b48ae7874b54baebebd1df48be574b193" translate="yes" xml:space="preserve">
          <source>If a pred function is omitted, use a constant &lt;code&gt;true&lt;/code&gt; function. (This will keep the loop going, as far as this clause is concerned. Note that in such cases the corresponding fini function is unreachable.)</source>
          <target state="translated">pred 함수가 생략 된 경우 상수 &lt;code&gt;true&lt;/code&gt; 함수를 사용하십시오. (이것은이 절에 관한 한 루프를 계속 진행할 것입니다. 이러한 경우 해당 fini 함수에 도달 할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="1e2d6f69246267134b84e23e4dd1a1f828cae635" translate="yes" xml:space="preserve">
          <source>If a pred function returns &lt;code&gt;false&lt;/code&gt;, the corresponding fini function is called, and the resulting value (of type &lt;code&gt;R&lt;/code&gt;) is returned from the loop as a whole.</source>
          <target state="translated">pred 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 해당 fini 함수가 호출되고 결과 값 ( &lt;code&gt;R&lt;/code&gt; 유형 )이 전체 루프에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caf5336d5c7e67a44f03340f4fbe7da00052aa6b" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel &lt;code&gt;Component&lt;/code&gt;. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the &lt;code&gt;AttributeSet&lt;/code&gt;. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">인쇄 서비스에서 공급 업체 확장을 제공하는 경우 공급 업체에서 제공하는 탭 패널 &lt;code&gt;Component&lt;/code&gt; 통해 사용자가 액세스 할 수 있습니다 . 이러한 공급 업체 확장은 Swing을 사용하는 것이 좋습니다! 접근성 API를 지원합니다. 공급 업체 확장은 &lt;code&gt;AttributeSet&lt;/code&gt; 의 일부로 설정을 반환해야합니다 . 사용자 설정을 보존하려는 응용 프로그램은 해당 설정을 사용하여 인쇄 작업을 지정해야합니다. 이 클래스는 Java Print Service의 다른 부분에서 참조되지 않으며 AWT 패키지의 존재 여부에 의존 할 수없는 프로파일에 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d056108653d02210141b2a751f0e69e31fb1fd" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel Component. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the AttributeSet. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">인쇄 서비스가 공급 업체 확장을 제공하는 경우 공급 업체 제공 탭 패널 구성 요소를 통해 사용자가 액세스 할 수 있습니다. 이러한 공급 업체 확장 프로그램은 Swing! 접근성 API를 지원합니다. 공급 업체 확장은 설정을 AttributeSet의 일부로 반환해야합니다. 사용자 설정을 유지하려는 응용 프로그램은 해당 설정을 사용하여 인쇄 작업을 지정해야합니다. 이 클래스는 Java 인쇄 서비스의 다른 부분에서 참조되지 않으며 AWT 패키지의 존재에 의존 할 수없는 프로파일에는 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59af891bcb7ad7848a092781a278ba855f208533" translate="yes" xml:space="preserve">
          <source>If a printer does not support the &lt;code&gt;SheetCollate&lt;/code&gt; attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though &lt;code&gt;SheetCollate&lt;/code&gt; were always set to &lt;code&gt;COLLATED&lt;/code&gt;.</source>
          <target state="translated">프린터가 &lt;code&gt;SheetCollate&lt;/code&gt; 속성을 지원하지 않는 경우 (클라이언트가 특정 시트 데이터 정렬을 지정할 수 없음) 프린터는 &lt;code&gt;SheetCollate&lt;/code&gt; 가 항상 &lt;code&gt;COLLATED&lt;/code&gt; 로 설정된 것처럼 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f29ea7b220242b9cb8462cb83e9acfd3082297b2" translate="yes" xml:space="preserve">
          <source>If a printer does not support the SheetCollate attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though SheetCollate were always set to COLLATED.</source>
          <target state="translated">프린터가 SheetCollate 특성을 지원하지 않으면 (클라이언트가 특정 시트 정렬을 지정할 수 없음을 의미) 프린터는 SheetCollate가 항상 COLLATED로 설정된 것처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="49665e43d0c605dc9888cfc626aa1ab47db7f814" translate="yes" xml:space="preserve">
          <source>If a processor object is created and used without the above protocol being followed, then the processor's behavior is not defined by this interface specification.</source>
          <target state="translated">위의 프로토콜을 따르지 않고 프로세서 객체를 만들어 사용하는 경우이 인터페이스 사양에 따라 프로세서의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81af254ec927065b733bde24b627fbd0490e34d9" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised()&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">프로세서에서 포착되지 않은 예외가 발생하면 도구가 다른 활성 주석 프로세서를 중지 할 수 있습니다. 프로세서에서 오류가 발생하면 현재 라운드가 완료 될 때까지 실행되고 후속 라운드에서 &lt;a href=&quot;roundenvironment#errorRaised()&quot;&gt;오류가 발생&lt;/a&gt; 했음을 나타냅니다 . 주석 프로세서는 협력 환경에서 실행되기 때문에 프로세서는 오류 복구 나보고가 불가능한 상황에서만 포착되지 않은 예외를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="ca6e8c92cea494ed3f4a024c3b0fdf6756539fd3" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">프로세서가 포착되지 않은 예외를 처리하면 도구가 다른 활성 주석 프로세서를 중지 할 수 있습니다. 프로세서에서 오류가 발생하면 현재 라운드가 완료되고 다음 라운드에서 &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;오류가 발생&lt;/a&gt; 했음을 나타냅니다 . 어노테이션 프로세서는 협업 환경에서 실행되므로 오류 복구 또는보고가 불가능한 상황에서만 프로세서가 포착되지 않은 예외를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb6c65b34b95b44418e49ca6b3559cef82f09432" translate="yes" xml:space="preserve">
          <source>If a property has been set using &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, that value will be returned. Otherwise, if a property is explicitly specified in the stylesheet, that value will be returned. If the value of the property has been defaulted, that is, if no value has been set explicitly either with &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt; or in the stylesheet, the result may vary depending on implementation and input stylesheet.</source>
          <target state="translated">&lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; 사용하여 속성을 설정 한 경우 해당 값이 반환됩니다. 그렇지 않고 속성이 스타일 시트에 명시 적으로 지정되면 해당 값이 반환됩니다. 속성 값이 기본값으로 설정된 경우, 즉 &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; 또는 스타일 시트에 명시 적으로 값이 설정되지 않은 경우 결과는 구현 및 입력에 따라 달라질 수 있습니다. 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="fe881171d1c239ccd44b6c4f0b3100103c51b330" translate="yes" xml:space="preserve">
          <source>If a property is indexed, then its entry in the result array belongs to the &lt;a href=&quot;indexedpropertydescriptor&quot;&gt;&lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;&lt;/a&gt; subclass of the &lt;a href=&quot;propertydescriptor&quot;&gt;&lt;code&gt;PropertyDescriptor&lt;/code&gt;&lt;/a&gt; class. A client of the &lt;code&gt;getPropertyDescriptors&lt;/code&gt; method can use the &lt;code&gt;instanceof&lt;/code&gt; operator to check whether a given &lt;code&gt;PropertyDescriptor&lt;/code&gt; is an &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;.</source>
          <target state="translated">특성이 색인화되는 경우 결과 배열의 해당 항목 은 &lt;a href=&quot;propertydescriptor&quot;&gt; &lt;code&gt;PropertyDescriptor&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;indexedpropertydescriptor&quot;&gt; &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; &lt;/a&gt; 서브 클래스에 속합니다 . &lt;code&gt;getPropertyDescriptors&lt;/code&gt; 메소드 의 클라이언트는 &lt;code&gt;instanceof&lt;/code&gt; 연산자를 사용하여 지정된 &lt;code&gt;PropertyDescriptor&lt;/code&gt; 가 &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; 인지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73b5d72f7f083f370b03d87e8286e01120577634" translate="yes" xml:space="preserve">
          <source>If a property value is a directory name, all files under that directory will be passed also.</source>
          <target state="translated">특성 값이 디렉토리 이름 인 경우 해당 디렉토리 아래의 모든 파일도 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b052521b488218cd7b9b35156c5fdb24478e5826" translate="yes" xml:space="preserve">
          <source>If a prototype display value is specified, the preferred size of the combo box is calculated by configuring the renderer with the prototype display value and obtaining its preferred size. Specifying the preferred display value is often useful when the combo box will be displaying large amounts of data. If no prototype display value has been specified, the renderer must be configured for each value from the model and its preferred size obtained, which can be relatively expensive.</source>
          <target state="translated">프로토 타입 디스플레이 값이 지정되면 콤보 상자의 선호 크기는 프로토 타입 디스플레이 값으로 렌더러를 구성하고 선호하는 크기를 가져 와서 계산됩니다. 선호하는 표시 값을 지정하면 콤보 상자에 많은 양의 데이터가 표시 될 때 유용합니다. 프로토 타입 표시 값이 지정되지 않은 경우 렌더러는 모델의 각 값에 대해 구성해야하며 선호하는 크기를 얻어야하므로 상대적으로 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c4d961909cb1d8509dc7e80ad518ce9be7c9742" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">제공자 클래스가 시스템 클래스 로더가 볼 수있는 jar 파일에 설치되었고 해당 jar 파일 에 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 라는 제공자 구성 파일이 포함 된 경우 , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fdfa29d9e3e5dd048f606f387c561e986beb3b1f" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">제공자 클래스가 시스템 클래스 로더가 볼 수있는 jar 파일에 설치되었고 해당 jar 파일 에 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 라는 제공자 구성 파일이 포함 된 경우 , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40aff6af09d58df40b7fd9256b872b6c75872438" translate="yes" xml:space="preserve">
          <source>If a proxy class implements a non-public interface, then it will be defined in the same package as that interface. Otherwise, the package of a proxy class is also unspecified. Note that package sealing will not prevent a proxy class from being successfully defined in a particular package at runtime, and neither will classes already defined by the same class loader and the same package with particular signers.</source>
          <target state="translated">프록시 클래스가 공용 인터페이스를 구현하지 않으면 해당 인터페이스와 동일한 패키지에 정의됩니다. 그렇지 않으면 프록시 클래스의 패키지도 지정되지 않습니다. 패키지 씰링은 프록시 클래스가 런타임에 특정 패키지에서 성공적으로 정의되는 것을 막지 않으며, 동일한 클래스 로더에 의해 이미 정의 된 클래스와 특정 서명자와 동일한 패키지가 이미 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="796aaf5cfdf7fbf122008c7936a12a38e2eb7d28" translate="yes" xml:space="preserve">
          <source>If a proxy interface contains a method with the same name and parameter signature as the &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt;, or &lt;code&gt;toString&lt;/code&gt; methods of &lt;code&gt;java.lang.Object&lt;/code&gt;, when such a method is invoked on a proxy instance, the &lt;code&gt;Method&lt;/code&gt; object passed to the invocation handler will have &lt;code&gt;java.lang.Object&lt;/code&gt; as its declaring class. In other words, the public, non-final methods of &lt;code&gt;java.lang.Object&lt;/code&gt; logically precede all of the proxy interfaces for the determination of which &lt;code&gt;Method&lt;/code&gt; object to pass to the invocation handler.</source>
          <target state="translated">프록시 인터페이스 에 &lt;code&gt;java.lang.Object&lt;/code&gt; 의 &lt;code&gt;hashCode&lt;/code&gt; , &lt;code&gt;equals&lt;/code&gt; 또는 &lt;code&gt;toString&lt;/code&gt; 메소드 와 이름 및 매개 변수 특성이 동일한 메소드가 포함 된 경우, 해당 &lt;code&gt;Method&lt;/code&gt; 가 프록시 인스턴스 에서 호출 될 때 호출 핸들러에 전달 된 Method 오브젝트는 선언 클래스로 &lt;code&gt;java.lang.Object&lt;/code&gt; 가 있습니다 . 다시 말해, &lt;code&gt;java.lang.Object&lt;/code&gt; 의 최종 비 최종 메소드 는 호출 핸들러에 전달할 &lt;code&gt;Method&lt;/code&gt; 오브젝트를 판별하기 위해 모든 프록시 인터페이스보다 논리적으로 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="1d6e567397cafeb01c674366adf43d058fe31b2c" translate="yes" xml:space="preserve">
          <source>If a pushed value is a primitive type, it may be converted to a reference by boxing conversion. If the bootstrap method is a variable arity method (its modifier bit &lt;code&gt;0x0080&lt;/code&gt; is set), then some or all of the arguments specified here may be collected into a trailing array parameter. (This is not a special rule, but rather a useful consequence of the interaction between &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constants, the modifier bit for variable arity methods, and the &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; transformation.)</source>
          <target state="translated">푸시 된 값이 기본 유형이면 복싱 변환을 통해 참조로 변환 될 수 있습니다. 부트 스트랩 메서드가 가변 arity 메서드 (수정 자 비트 &lt;code&gt;0x0080&lt;/code&gt; 이 설정 됨)이면 여기에 지정된 일부 또는 모든 인수가 후행 배열 매개 변수로 수집 될 수 있습니다. (이것은 특별한 규칙이 아니라 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수, 가변 arity 메서드에 대한 수정 자 비트 및 &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt; 변환 간의 상호 작용의 유용한 결과입니다 .)</target>
        </trans-unit>
        <trans-unit id="da20e235784a287eb944654e195ab8c9e647b20d" translate="yes" xml:space="preserve">
          <source>If a query is given then a question-mark character (&lt;code&gt;'?'&lt;/code&gt;) is appended, followed by the query. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.</source>
          <target state="translated">쿼리가 제공되면 물음표 문자 ( &lt;code&gt;'?'&lt;/code&gt; )가 추가되고 그 뒤에 쿼리가옵니다. &lt;a href=&quot;#legal-chars&quot;&gt;유효한 URI 문자&lt;/a&gt; 가 아닌 문자 는 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd66988b876e62bc3940fc9fa272fb4aa056a6e8" translate="yes" xml:space="preserve">
          <source>If a redefined method has active stack frames, those active frames continue to run the bytecodes of the original method. The redefined method will be used on new invokes.</source>
          <target state="translated">재정의 된 메소드에 활성 스택 프레임이있는 경우 해당 활성 프레임은 원래 메소드의 바이트 코드를 계속 실행합니다. 재정의 된 메소드는 새로운 호출에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a353f255cddb3e5f45349ee73fbfca26933c3382" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">남아있는 요소가 존재하는 경우 해당 요소에 대해 지정된 작업을 수행하고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c3cb610dc9a4ccd073a7cbb93e3b0cbe1831a23f" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">남아있는 요소가 존재하는 경우 해당 요소에 대해 지정된 작업을 수행하고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 Spliterator가 &lt;a href=&quot;#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에서 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="24ef3bceba0cb2aab5212a59ddb1c10b5a5728ca" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">나머지 요소가 존재하면 주어진 조치를 수행하여 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . else는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 스플리터가&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에 의해 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e159606ce958fbbed771df76f4f0eabd266798cd" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">나머지 요소가 존재하면 주어진 조치를 수행하여 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . else는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 스플리터가&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에 의해 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1839ce02fdf0a084101d2dedb7a7ec30b1eddf93" translate="yes" xml:space="preserve">
          <source>If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</source>
          <target state="translated">요청을 대기열에 넣을 수 없으면 maximumPoolSize를 초과하지 않는 한 새 스레드가 만들어지며이 경우 작업이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8dcd6f2eb2f000d41479fe75ebb34b375f18a3c4" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">요청 된 액세스가 허용되면 &lt;code&gt;checkPermission&lt;/code&gt; 이 자동으로 리턴됩니다. 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="887186d0f2e36f1ee7e723c9cc603e07ae277a39" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, an AccessControlException is thrown. AccessControlException can also be thrown if the requested permission is of an incorrect type or contains an invalid value. Such information is given whenever possible. Suppose the current thread traversed m callers, in the order of caller 1 to caller 2 to caller m. Then caller m invoked the &lt;code&gt;checkPermission&lt;/code&gt; method. The &lt;code&gt;checkPermission&lt;/code&gt; method determines whether access is granted or denied based on the following algorithm:</source>
          <target state="translated">요청 된 액세스가 허용되면 &lt;code&gt;checkPermission&lt;/code&gt; 이 자동으로 리턴됩니다. 거부되면 AccessControlException이 발생합니다. 요청 된 권한이 올바르지 않은 유형이거나 유효하지 않은 값을 포함하는 경우 AccessControlException이 발생할 수도 있습니다. 그러한 정보는 가능할 때마다 제공됩니다. 현재 스레드가 호출자 1-호출자 2-호출자 m의 순서로 m 호출자를 순회한다고 가정하십시오. 그런 다음 호출자 m은 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출했습니다 . &lt;code&gt;checkPermission&lt;/code&gt; 방법은 액세스가 부여되거나 다음과 같은 알고리즘을 기반으로 거부 여부를 결정합니다 :</target>
        </trans-unit>
        <trans-unit id="d5d7514de1aef2342f9130eb5c0a7ab75fbed7e9" translate="yes" xml:space="preserve">
          <source>If a resource named &lt;code&gt;META-INF/services/java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; is visible to the system class loader, then the contents of that resource are interpreted as a provider-configuration file, and the first class name specified in that file is used as the provider class name. If a class with that name can be loaded by the system class loader and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the resource is found but a provider cannot be instantiated as described, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">&lt;code&gt;META-INF/services/java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; 라는 리소스 가 시스템 클래스 로더에 표시되면 해당 리소스의 내용이 공급자 구성 파일로 해석되고 해당 파일에 지정된 첫 번째 클래스 이름은 다음과 같습니다. 공급자 클래스 이름으로 사용됩니다. 해당 이름의 클래스가 시스템 클래스 로더에 의해로드 될 수 있고 해당 클래스가 &lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; 에&lt;/a&gt; 할당 가능하고 인수가없는 공용 생성자가있는 경우 해당 생성자가 호출되어 공급자 인스턴스를 생성합니다. 리소스를 찾았지만 설명 된대로 공급자를 인스턴스화 할 수없는 경우 &lt;code&gt;RMIClassLoader&lt;/code&gt; 사용을 시도하는 코드에 지정되지 않은 &lt;code&gt;Error&lt;/code&gt; 가 발생 하여 공급자 인스턴스를 가져 오지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef31bdb236c1be020d8ae03fbd2d0a2a44475408" translate="yes" xml:space="preserve">
          <source>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</source>
          <target state="translated">결과가 컴 바이 너 또는 피니셔 함수로 전달되고 해당 함수에서 동일한 오브젝트가 리턴되지 않으면 다시 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f6485f2810241e1f59964a0306f13fb66de588c" translate="yes" xml:space="preserve">
          <source>If a retransformed method has active stack frames, those active frames continue to run the bytecodes of the original method. The retransformed method will be used on new invokes.</source>
          <target state="translated">재 변환 된 메소드에 활성 스택 프레임이있는 경우 해당 활성 프레임은 원래 메소드의 바이트 코드를 계속 실행합니다. 재 변환 된 메소드는 새로운 호출에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14bfd111544b6485485ff232a946c27189f15782" translate="yes" xml:space="preserve">
          <source>If a scheme is given then it is appended to the result, followed by a colon character (&lt;code&gt;':'&lt;/code&gt;).</source>
          <target state="translated">체계가 제공되면 결과에 추가되고 그 뒤에 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; )가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e5292412b3ee897a572e5c7195ad6e65ff3c8f5e" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter or, in the case of the &lt;code&gt;port&lt;/code&gt; parameter, by passing &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">구성표가 제공되면 경로도 지정되거나 비어 있거나 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작해야합니다 . 그렇지 않으면 새 URI의 구성 요소는 해당 매개 변수에 대해 &lt;code&gt;null&lt;/code&gt; 을 전달 하거나 &lt;code&gt;port&lt;/code&gt; 매개 변수 의 경우 &lt;code&gt;-1&lt;/code&gt; 을 전달 하여 정의되지 않은 채로 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7eb7b84865919239961f0fcc50c50d09850970cc" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter.</source>
          <target state="translated">구성표가 제공되면 경로도 지정되거나 비어 있거나 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작해야합니다 . 그렇지 않으면 새 URI의 구성 요소 는 해당 매개 변수에 대해 &lt;code&gt;null&lt;/code&gt; 을 전달하여 정의되지 않은 채로있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="952cc358b56318941d6e6ab799e6dc4bef4fa5ce" translate="yes" xml:space="preserve">
          <source>If a scheme-specific part is given then it is appended. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.</source>
          <target state="translated">구성표 별 부품이 제공되면 추가됩니다. &lt;a href=&quot;#legal-chars&quot;&gt;유효한 URI 문자&lt;/a&gt; 가 아닌 문자 는 &lt;a href=&quot;#quote&quot;&gt;인용&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="13bf2d89737ab4f9e4f3365daa8c4a8a75373b41" translate="yes" xml:space="preserve">
          <source>If a search filter with invalid variable substitutions is provided to this method, the result is undefined. When changes are made to this DirContext, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">유효하지 않은 변수 대체가있는 검색 필터가이 메소드에 제공되면 결과는 정의되지 않습니다. 이 DirContext가 변경되면,이 메소드에 대한 이전 호출에 의해 리턴 된 열거에 대한 영향은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21aa33f224ffda676da8658661118410003b3a1d" translate="yes" xml:space="preserve">
          <source>If a second-based field is present, but &lt;code&gt;LocalTime&lt;/code&gt; was not parsed, then the resolver ensures that milli, micro and nano second values are available to meet the contract of &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. These will be set to zero if missing.</source>
          <target state="translated">초 기반 필드가 있지만 &lt;code&gt;LocalTime&lt;/code&gt; 이 구문 분석되지 않은 경우 해석기는 밀리, 마이크로 및 나노초 값이 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; &lt;/a&gt; 의 계약을 충족하는 데 사용할 수 있는지 확인 합니다. 누락 된 경우 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e18b76d1fe5541051eb8484610c674d8c7326195" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 검사가 실패하면 메서드는 &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e97fd2ab90897223be3d44a61e5dac3ab116baef" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 검사에 실패하면, 메소드는 &lt;a href=&quot;../../java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="221b98a86674d566a65e15145ec84aa3ec7800d3" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드는 배열 &lt;code&gt;cmdarray&lt;/code&gt; 의 첫 번째 구성 요소를 인수로 사용하여 호출됩니다. 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9dea5876966fa5396ec8f16c92b8e2f701b1ace9" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재 하면 배열 &lt;code&gt;cmdarray&lt;/code&gt; 의 첫 번째 구성 요소를 인수로 사용하여 &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 이 발생 .</target>
        </trans-unit>
        <trans-unit id="f62df6f0d1a2b5825cab2050a4ec3aeebeb23980" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;getenv.&quot;+name)&lt;/code&gt;&lt;/a&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;getenv.&quot;+name)&lt;/code&gt; &lt;/a&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 . 예외가 발생하지 않으면 변수 &lt;code&gt;name&lt;/code&gt; 의 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f1619a19a25be011be70c741cc0c43a2226d965a" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;getenv.*&quot;)&lt;/code&gt;&lt;/a&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;getenv.*&quot;)&lt;/code&gt; &lt;/a&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e6026eb4f64490fabd44f7ccd2cafba99ebb3a0" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 있으면 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53168f421aa4d312fe84c343c76a94712c016bae" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2be9fb106610b30c8cb7f763862c74ced2b9d9be" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 . 예외가 발생하지 않으면 변수 &lt;code&gt;name&lt;/code&gt; 의 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="799c889390e9c989ec60d735a9738bf280d5b1a4" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2278e2e0ebd6f6139022aa0c469fba80c78c2df6" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;deregisterDriver&quot;)&lt;/code&gt; permission to check that the caller is allowed to deregister a JDBC Driver.</source>
          <target state="translated">보안 관리자가 존재하면 먼저 &lt;code&gt;SQLPermission(&quot;deregisterDriver&quot;)&lt;/code&gt; 권한 과 함께 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출 하여 호출자가 JDBC 드라이버를 등록 취소 할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="44b4a416183d3454eaa000dc618d86aeea1d6cfb" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; permission to check that the caller is allowed to call &lt;code&gt;setLogStream&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 존재하면 먼저 &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; 권한 과 함께 &lt;code&gt;checkPermission&lt;/code&gt; 메소드 를 호출하여 호출자가 &lt;code&gt;setLogStream&lt;/code&gt; 을 호출 할 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e94ff9d44d0443fcf36a01243a61054d009a97a3" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; permission to check that the caller is allowed to call &lt;code&gt;setLogWriter&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 존재하면 먼저 &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; 권한 과 함께 &lt;code&gt;checkPermission&lt;/code&gt; 메소드 를 호출하여 호출자가 &lt;code&gt;setLogWriter&lt;/code&gt; 를 호출 할 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2028007eeb90e55bc59c501b744cac8fe55582db" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress()&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast(java.net.InetAddress)&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">보안 관리자가 설치된 경우 원격 주소에 대한 액세스를 확인하기 위해 호출됩니다. 특히, 주어진 &lt;code&gt;address&lt;/code&gt; 가 &lt;a href=&quot;inetaddress#isMulticastAddress()&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt; 이면 보안 관리자의 &lt;a href=&quot;../lang/securitymanager#checkMulticast(java.net.InetAddress)&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt; 메소드가 주어진 &lt;code&gt;address&lt;/code&gt; 호출됩니다 . 그렇지 않으면 보안 관리자의 &lt;a href=&quot;../lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드가 주어진 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 와 함께 호출 되어 데이터 그램의 송수신이 각각 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a1659595caad59762dfff687e8404d52f631d93f" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">보안 관리자가 설치된 경우 원격 주소에 대한 액세스를 확인하기 위해 호출됩니다. 주어진 경우 특히, &lt;code&gt;address&lt;/code&gt; A는 &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt; , 보안 매니저의 &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt; 방법은 주어진를 호출 &lt;code&gt;address&lt;/code&gt; . 그렇지 않으면, 주어진 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 로 보안 관리자의 &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되어 데이터 그램이 각각 송수신 될 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5ec3f03393550037c5eee923c4fe6688b7340633" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가 설치된 경우 연결 원격 엔드 포인트의 주소 및 포트 번호가 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드에 의해 허용되는지 확인합니다 . 권한 검사는이 메서드의 호출 컨텍스트에 의해 제한되는 권한으로 수행됩니다. 권한 검사가 실패하면 연결이 닫히고 작업이 &lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 으로&lt;/a&gt; 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="e62ef67bcdaa9aa21e31d7d487c07bd914492ed8" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가 설치된 경우 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드 가 연결 원격 엔드 포인트의 주소 및 포트 번호를 허용하는지 확인합니다 . 권한 확인은이 메소드의 호출 컨텍스트에 의해 제한된 권한으로 수행됩니다. 권한 점검에 실패하면 연결이 닫히고 조작이 &lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 으로&lt;/a&gt; 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f4c4a17220ef5e90aea04a442f8bc074ebea3c6" translate="yes" xml:space="preserve">
          <source>If a security manager is already set in the group VM, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method. This could result in a &lt;code&gt;SecurityException&lt;/code&gt;. If your application needs to set a different security manager, you must ensure that the policy file specified by the group's &lt;code&gt;ActivationGroupDesc&lt;/code&gt; grants the group the necessary permissions to set a new security manager. (Note: This will be necessary if your group downloads and sets a security manager).</source>
          <target state="translated">보안 관리자가 이미 그룹 VM에 설정되어있는 경우이 메소드는 먼저 보안 관리자의 &lt;code&gt;checkSetFactory&lt;/code&gt; 메소드를 호출합니다 . 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 . 애플리케이션이 다른 보안 관리자를 설정해야하는 경우 그룹의 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 에 지정된 정책 파일이 그룹 에 새 보안 관리자를 설정하는 데 필요한 권한을 부여 하는지 확인해야합니다 . (참고 : 그룹이 보안 관리자를 다운로드하고 설정하는 경우 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="774bb30d85acccb9e7832ec0c0d531eef6b9e9b6" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (where &lt;code&gt;name&lt;/code&gt; is the provider name) to see if it's ok to clear this provider.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 임) 문자열로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출 되어이 제공자를 지울 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f35e03213aea8a9f7162a4e6061b476c733a84f5" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 문자열 ( 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 임 )로 호출 되어이 제공자의 특성 값을 설정해도 괜찮은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97b050d112e298b259d22c6b122aa0f103951b1a" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to remove this provider's properties.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; 문자열과 함께 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출됩니다 . 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 이며이 제공자의 특성을 제거 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ece65adbb64e89095abfe9c2349b473bbf31084f" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the strings &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; and &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values and remove this provider's properties.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, 문자열 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 및 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; 으로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출됩니다 . 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름입니다.이 제공자의 특성 값을 설정하고이를 제거해도 괜찮은지 확인하십시오. 공급자의 속성.</target>
        </trans-unit>
        <trans-unit id="cf20f936473755f39be868cd9845f771cb103a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed and the specified &lt;code&gt;AccessControlContext&lt;/code&gt; was not created by system code and the caller's &lt;code&gt;ProtectionDomain&lt;/code&gt; has not been granted the &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt;&lt;code&gt;SecurityPermission&lt;/code&gt;&lt;/a&gt;, then the action is performed with no permissions.</source>
          <target state="translated">보안 관리자가 설치되어 있고 지정된 &lt;code&gt;AccessControlContext&lt;/code&gt; 가 시스템 코드로 작성되지 않고 호출자의 &lt;code&gt;ProtectionDomain&lt;/code&gt; 에 &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt; &lt;code&gt;SecurityPermission&lt;/code&gt; &lt;/a&gt; 이 부여되지 않은 경우, 권한없이 조치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dd8d2c5d44a3aa942e5df643c8cc56f8591079d9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 공급자 구현은 기존 파일 시스템에 대한 참조를 반환하기 전에 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3b5b0dd2a87988fc996fb7a1ac5c2588c90d706" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 공급자 구현은 기존 파일 시스템에 대한 참조를 반환하기 전에 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;../filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71505a5d56a109fcf20595110953779d866b2e80" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 기존 파일 시스템에 대한 참조를 리턴하기 전에 권한을 점검해야합니다. &lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94817a0d003779bd7b3676c9e779ce36983364b9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 기존 파일 시스템에 대한 참조를 리턴하기 전에 권한을 점검해야합니다. &lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e04465cdbf974bbd5f8ba0a91561e8dc8debf9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 공급자 구현은 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;../filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d8b4d6a644688d37bf4f42e678ef49d5a579de5" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="143f1755f82fd54bafd1bbd2d643a9b8c831879a" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:</source>
          <target state="translated">보안 관리자가 설치되어 있고 연결을 시도하는 메서드가 호출되면 호출자는 다음 중 하나를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0d87efa51aa6969d6f0da372f01e957e877983c" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-</source>
          <target state="translated">보안 관리자가 설치되어 있고 연결을 시도하는 메소드가 호출 된 경우 호출자는 다음 중 하나를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d45c9e8f126e9404c3d2b7c327aa338dc699327" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, in order to create a &lt;code&gt;GSSName&lt;/code&gt; that contains a Kerberos name element without providing its realm, a &lt;a href=&quot;../../../javax/security/auth/kerberos/servicepermission&quot;&gt;&lt;code&gt;ServicePermission&lt;/code&gt;&lt;/a&gt; must be granted and the service principal of the permission must minimally be inside the Kerberos name element's realm. For example, if the result of &lt;a href=&quot;gssmanager#createName(java.lang.String,org.ietf.jgss.Oid)&quot;&gt;&lt;code&gt;createName(&quot;user&quot;, NT_USER_NAME)&lt;/code&gt;&lt;/a&gt; contains a Kerberos name element &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt;, then a &lt;code&gt;ServicePermission&lt;/code&gt; with service principal &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (and any action) must be granted. Otherwise, the creation will throw a &lt;a href=&quot;gssexception&quot;&gt;&lt;code&gt;GSSException&lt;/code&gt;&lt;/a&gt; containing the &lt;code&gt;GSSException.FAILURE&lt;/code&gt; error code.</source>
          <target state="translated">보안 관리자가 설치된 경우 영역을 제공하지 않고 Kerberos 이름 요소를 포함 하는 &lt;code&gt;GSSName&lt;/code&gt; 을 만들려면 &lt;a href=&quot;../../../javax/security/auth/kerberos/servicepermission&quot;&gt; &lt;code&gt;ServicePermission&lt;/code&gt; &lt;/a&gt; 을 부여해야하며 권한의 서비스 주체는 최소한 Kerberos 이름 요소의 영역 내에 있어야합니다. 예를 들어 &lt;a href=&quot;gssmanager#createName(java.lang.String,org.ietf.jgss.Oid)&quot;&gt; &lt;code&gt;createName(&quot;user&quot;, NT_USER_NAME)&lt;/code&gt; &lt;/a&gt; 의 결과에 Kerberos 이름 요소 &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt; 이 포함 된 경우 서비스 주체 &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (및 모든 작업)이 있는 &lt;code&gt;ServicePermission&lt;/code&gt; 은 부여. 그렇지 않으면, 창조가 발생합니다 &lt;a href=&quot;gssexception&quot;&gt; &lt;code&gt;GSSException&lt;/code&gt; 가&lt;/a&gt; 포함하는 &lt;code&gt;GSSException.FAILURE&lt;/code&gt; 의 오류 코드를.</target>
        </trans-unit>
        <trans-unit id="2cf065c4d0904a0cb44740e8e70a65fae00e790f" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPrincipals&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 반환 된 집합을 수정하기 위해 &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPrincipals&quot;)&lt;/code&gt; &lt;/a&gt; 권한이 있어야합니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d705115f8db059c39a12d168cf6ae0c2ae12a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPrivateCredentials&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 반환 된 집합을 수정하기 위해 &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPrivateCredentials&quot;)&lt;/code&gt; &lt;/a&gt; 권한이 있어야합니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="277c3aef4348bc841723740d60214a68d5615799" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPublicCredentials&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPublicCredentials&quot;)&lt;/code&gt; &lt;/a&gt;반환 된 집합을 수정하기 위해 AuthPermission ( &quot;modifyPublicCredentials&quot;) 권한이 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf6549af10b8e67c5c26a129534c96167f417bb6" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;privatecredentialpermission&quot;&gt;&lt;code&gt;PrivateCredentialPermission&lt;/code&gt;&lt;/a&gt; to access all of the requested Credentials, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 설치된 경우 호출자는 &lt;a href=&quot;privatecredentialpermission&quot;&gt; &lt;code&gt;PrivateCredentialPermission&lt;/code&gt; &lt;/a&gt;요청 된 모든 자격 증명에 액세스 할 PrivateCredentialPermission 이 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e951d48b2804e2b72e838d29cf84001eb9605eaa" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectInputStream.readFields or ObjectInputStream.readUnshared methods.</source>
          <target state="translated">보안 관리자가 설치된 경우이 생성자는 ObjectInputStream.readFields 또는 ObjectInputStream.readUnshared 메소드를 대체하는 서브 클래스의 생성자가 직접 또는 간접적으로 호출 할 때 &quot;enableSubclassImplementation&quot;SerializablePermission을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97bae6ffb96e1d4b174839ef22d4e1aad74be094" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared methods.</source>
          <target state="translated">보안 관리자가 설치된 경우이 생성자는 ObjectOutputStream.putFields 또는 ObjectOutputStream.writeUnshared 메소드를 대체하는 서브 클래스의 생성자가 직접 또는 간접적으로 호출 할 때 &quot;enableSubclassImplementation&quot;SerializablePermission을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d92bb3509ac791abbf0139a9c7f57cc935e83b78" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this method is caller sensitive. During any invocation of the target method handle via the returned wrapper, the original creator of the wrapper (the caller) will be visible to context checks requested by the security manager.</source>
          <target state="translated">보안 관리자가 설치된 경우이 방법은 호출자에 민감합니다. 리턴 된 랩퍼를 통해 대상 메소드 핸들을 호출하는 동안 랩퍼의 원래 작성자 (호출자)는 보안 관리자가 요청한 컨텍스트 확인에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="65b3db194eedd1b31a2888097e8d1e43da0bb0ea" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the given &lt;code&gt;option&lt;/code&gt; is &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt;&lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;, it calls its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method for &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 있고 주어진 &lt;code&gt;option&lt;/code&gt; 이 &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt; &lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt; &lt;/a&gt; 인 경우&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt; 에 대한 checkPermission 메서드를.</target>
        </trans-unit>
        <trans-unit id="1670cbe57d528fea2424601e7c9d68d106c819ac" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the given &lt;code&gt;options&lt;/code&gt; contains &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt;&lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;, it calls its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method for &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 있고 지정된 &lt;code&gt;options&lt;/code&gt; 에 &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt; &lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt; &lt;/a&gt; 가 포함 된 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt; 에 대한 checkPermission 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f235ec91b53b01416e59e95836269f2b24928eee" translate="yes" xml:space="preserve">
          <source>If a security manager is present then security checks are performed by the HTTP Client's sending methods. An appropriate &lt;a href=&quot;../../../../java.base/java/net/urlpermission&quot;&gt;&lt;code&gt;URLPermission&lt;/code&gt;&lt;/a&gt; is required to access the destination server, and proxy server if one has been configured. The form of the &lt;code&gt;URLPermission&lt;/code&gt; required to access a proxy has a &lt;code&gt;method&lt;/code&gt; parameter of &lt;code&gt;&quot;CONNECT&quot;&lt;/code&gt; (for all kinds of proxying) and a &lt;code&gt;URL&lt;/code&gt; string of the form &lt;code&gt;&quot;socket://host:port&quot;&lt;/code&gt; where host and port specify the proxy's address.</source>
          <target state="translated">보안 관리자가있는 경우 HTTP 클라이언트의 전송 방법에 의해 보안 검사가 수행됩니다. 대상 서버 및 프록시 서버 (구성된 경우)에 액세스하려면 적절한 &lt;a href=&quot;../../../../java.base/java/net/urlpermission&quot;&gt; &lt;code&gt;URLPermission&lt;/code&gt; &lt;/a&gt; 이 필요합니다. 프록시에 액세스하는 데 필요한 &lt;code&gt;URLPermission&lt;/code&gt; 의 형식에는 &lt;code&gt;&quot;CONNECT&quot;&lt;/code&gt; (모든 종류의 프록시 용) &lt;code&gt;method&lt;/code&gt; 매개 변수 와 &lt;code&gt;&quot;socket://host:port&quot;&lt;/code&gt; 형식 의 &lt;code&gt;URL&lt;/code&gt; 문자열이 있습니다. 여기서 host 및 port는 프록시 주소를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d8a665c3d954d0fc47740977c830812c0a85b298" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the class loader for the class.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 널 (null)이 아니고 호출자의 클래스 로더가 클래스 로더가 요청 된 클래스에 대한 클래스 로더의 조상과 같거나 같지 않은 경우,이 메소드는 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출합니다. 로모그래퍼 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 의 허가는 클래스의 클래스 로더에 액세스 할 수있는 것을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="fae23e2153f023848b4e6ff03b38daa20b992dd7" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not an ancestor of this class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the parent class loader is permitted. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고이 클래스 로더 의 조상이 아닌 경우이 메소드는 상위 클래스에 대한 액세스를 확인하기 위해 &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 권한으로 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. 로더가 허용됩니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d340f476b6c3ae11657fddd0392b049fcfa29b4e" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not the same as or an ancestor of the context class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; permission to verify that retrieval of the context class loader is permitted.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고 컨텍스트 클래스 로더의 조상과 같거나 같지 않은 경우이 메소드는 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. 컨텍스트 클래스 로더 검색이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7bab9ae3bc48ceb4d26ca9f16abf87e363a12c" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and the invoker's class loader is not the same as or an ancestor of the system class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the system class loader. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고 호출자의 클래스 로더가 시스템 클래스 로더와 동일하거나 상위 클래스가 아닌 경우,이 메소드는 &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 사용하여 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. ) 시스템 클래스 로더에 대한 액세스를 확인하는 권한 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c67e806fb2de6670301476b333eef74af4db7033" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;
 (&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 경우 컨텍스트 ClassLoader 설정이 허용되는지 확인하기 위해 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt; (&quot;setContextClassLoader&quot;)&lt;/code&gt; 권한으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="459bc04b32cd4cdbb41e230932994ba0a7971ad8" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">보안 관리자가 존재하면 해당 클래스의 컨텍스트 설정이 허용되는지 확인하기 위해 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; 권한으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="e624bb62f16bc940f5cf53be80f8d86fd6570fa0" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member and class lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. (If a class or other type is being accessed, the &lt;code&gt;refc&lt;/code&gt; and &lt;code&gt;defc&lt;/code&gt; values are the class itself.) The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">보안 관리자가있는 경우 구성원 및 클래스 조회는 추가 검사를받습니다. 보안 관리자에게 1 ~ 3 회의 호출이 이루어집니다. 이러한 호출은 &lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 액세스를 거부 할 수 있습니다 . 정의 &lt;code&gt;smgr&lt;/code&gt; 보안 관리자와 같은 &lt;code&gt;lookc&lt;/code&gt; 룩업 현재 룩업 객체의 클래스로서 &lt;code&gt;refc&lt;/code&gt; 부재가 모색되고있는 함유 클래스로하고 &lt;code&gt;defc&lt;/code&gt; 부재 실제로 정의 된 클래스로한다. (클래스 또는 다른 유형이 액세스되는 경우 &lt;code&gt;refc&lt;/code&gt; 및 &lt;code&gt;defc&lt;/code&gt; 값 클래스 자체이다.) 값 &lt;code&gt;lookc&lt;/code&gt; 는 로 정의&lt;em&gt; 없는&lt;/em&gt;현재 조회 개체에 이없는 경우&lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;개인 액세스&lt;/a&gt; . 호출은 다음 규칙에 따라 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="944477a6804441726a3b8f252f78eae83726e3a4" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">보안 관리자가있는 경우 멤버 조회에는 추가 검사가 적용됩니다. 1 ~ 3 번의 보안 관리자 호출 이러한 호출은 &lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 액세스를 거부 할 수 있습니다 . &lt;code&gt;smgr&lt;/code&gt; 을 보안 관리자로 정의 하고, &lt;code&gt;lookc&lt;/code&gt; 를 현재 조회 오브젝트의 검색 클래스로, &lt;code&gt;refc&lt;/code&gt; 를 멤버를 찾는 포함 클래스로, &lt;code&gt;defc&lt;/code&gt; 를 멤버를 실제로 정의한 클래스로 정의하십시오. 현재 조회 오브젝트에 &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;개인 액세스 권한&lt;/a&gt; 이없는 경우 &lt;code&gt;lookc&lt;/code&gt; 값 은 &lt;em&gt;존재하지 않는 것으로&lt;/em&gt; 정의됩니다 . 다음 규칙에 따라 전화를 겁니다.</target>
        </trans-unit>
        <trans-unit id="d370048efbe2c926a15f430ef8f627c5e5941de0" translate="yes" xml:space="preserve">
          <source>If a sequence of nodes is needed, the node contained in the &lt;code&gt;DOMStructure&lt;/code&gt; is the first node of the sequence and successive nodes can be accessed by invoking &lt;a href=&quot;../../../../../java.xml/org/w3c/dom/node#getNextSibling()&quot;&gt;&lt;code&gt;Node.getNextSibling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">노드 시퀀스가 ​​필요한 경우 &lt;code&gt;DOMStructure&lt;/code&gt; 에 포함 된 노드가 시퀀스의 첫 번째 노드이며 Node.getNextSibling &lt;a href=&quot;../../../../../java.xml/org/w3c/dom/node#getNextSibling()&quot;&gt; &lt;code&gt;Node.getNextSibling()&lt;/code&gt; &lt;/a&gt; 을 호출하여 연속 노드에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="401c7fd6161f35837fa11c7a250b7f821910874a" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</source>
          <target state="translated">직렬화 가능 클래스가 serialVersionUID를 명시 적으로 선언하지 않으면 직렬화 런타임은 Java (TM) 객체 직렬화 스펙에 설명 된대로 클래스의 다양한 측면을 기반으로 해당 클래스의 기본 serialVersionUID 값을 계산합니다. 그러나 기본 serialVersionUID 계산은 컴파일러 구현에 따라 달라질 수있는 클래스 세부 사항에 매우 민감하므로 예기치 않은 &lt;code&gt;InvalidClassException&lt;/code&gt; 이 발생할 수 있으므로 모든 serializable 클래스는 serialVersionUID 값을 명시 적으로 선언 &lt;em&gt;하는 것이 좋습니다.&lt;/em&gt;직렬화 해제 중입니다. 따라서 다른 Java 컴파일러 구현에서 일관된 serialVersionUID 값을 보장하려면 직렬화 가능 클래스가 명시 적 serialVersionUID 값을 선언해야합니다. 또한 명시 적 serialVersionUID 선언 은 가능한 경우 &lt;code&gt;private&lt;/code&gt; 수정자를 사용하는 것이 좋습니다. 이러한 선언은 즉시 선언하는 클래스에만 적용되므로 serialVersionUID 필드는 상속 된 멤버로 유용하지 않습니다. 배열 클래스는 명시적인 serialVersionUID를 선언 할 수 없으므로 항상 기본 계산 된 값을 갖지만 serialVersionUID 값과 일치하는 요구 사항은 배열 클래스에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8a284373bcb59e24e39e3dac459820aaa1124e2" translate="yes" xml:space="preserve">
          <source>If a service only supports registration for existing targets, an attempt to register for a nonexistent target results in a &lt;code&gt;NameNotFoundException&lt;/code&gt; being thrown as early as possible, preferably at the time &lt;code&gt;addNamingListener()&lt;/code&gt; is called, or if that is not possible, the listener will receive the exception through the &lt;code&gt;NamingExceptionEvent&lt;/code&gt;.</source>
          <target state="translated">서비스가 기존 대상에 대한 등록 만 지원하는 경우 존재하지 않는 대상에 대한 등록을 시도하면 바람직하게 &lt;code&gt;addNamingListener()&lt;/code&gt; 가 호출되거나 가능하지 않은 경우 리스너가 수신 할 때 &lt;code&gt;NameNotFoundException&lt;/code&gt; 이 가능한 빨리 발생 합니다 관통 예외 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="f0a93070904cd7e6062d269f73ed4cf640917a73" translate="yes" xml:space="preserve">
          <source>If a service supports this method it cannot be concluded that job cancellation will always succeed. A job may not be able to be cancelled once it has reached and passed some point in its processing. A successful cancellation means only that the entire job was not printed, some portion may already have printed when cancel returns.</source>
          <target state="translated">서비스가이 방법을 지원하면 작업 취소가 항상 성공할 것이라고 결론을 내릴 수 없습니다. 처리 중 어느 시점에 도달하여 작업을 통과 한 후에는 작업을 취소하지 못할 수 있습니다. 성공적으로 취소한다는 것은 전체 작업이 인쇄되지 않았 음을 의미하며, 취소가 반환되면 일부 부분이 이미 인쇄되었을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2255c8ae3c0e253b4d1c3edfe6c7951b6b7652" translate="yes" xml:space="preserve">
          <source>If a signer, or codesource is granted this permission, then it is considered a trusted source for MBeans. Only MBeans from trusted sources may be registered in the MBeanServer.</source>
          <target state="translated">서명자 또는 코드 소스에이 권한이 부여되면 MBean의 신뢰할 수있는 소스로 간주됩니다. 신뢰할 수있는 소스의 MBean 만 MBeanServer에 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03ecf67fc16b1bbea18316b3fee73e9a01230e4e" translate="yes" xml:space="preserve">
          <source>If a single argument is parsed more than once in the string, then the later parse wins.</source>
          <target state="translated">문자열에서 단일 인수가 두 번 이상 구문 분석되면 나중에 구문 분석이 승리합니다.</target>
        </trans-unit>
        <trans-unit id="f7c81fc364f1f00a7430bc8ff3d40572c48b36c2" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">&lt;code&gt;InetSocketAddress &lt;/code&gt; 가 나타내는 끝점에 바인딩 된 소켓 이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 이 메서드는 소켓이 닫힌 후에도 &lt;code&gt;InetSocketAddress&lt;/code&gt; 를 계속 반환합니다 . 이 경우 반환 된 &lt;code&gt;InetSocketAddress&lt;/code&gt; 의 주소는 &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt; 주소이고 해당 포트는 바인딩 된 로컬 포트입니다.</target>
        </trans-unit>
        <trans-unit id="31689da1ab6eb24083df20cceed8f165c2b092ae" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">&lt;code&gt;InetSocketAddress &lt;/code&gt; 로 표시되는 엔드 포인트에 바인드 된 소켓 이 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 이 메소드는 소켓이 닫힌 후에도 &lt;code&gt;InetSocketAddress&lt;/code&gt; 를 계속 리턴합니다 . 이 경우 반환 된 &lt;code&gt;InetSocketAddress&lt;/code&gt; 의 주소는 &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt; 주소이고 해당 포트는 바인딩 된 로컬 포트입니다.</target>
        </trans-unit>
        <trans-unit id="bb0809c0cf763cd6b646a20d3b4af68f3b750ce9" translate="yes" xml:space="preserve">
          <source>If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is specified it applies to the whole collator object.</source>
          <target state="translated">&amp;lt;modifier&amp;gt;에 의해 제어되는 특수 데이터 정렬 규칙이 지정된 경우 전체 데이터 정렬 기 개체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="427f94ff7874e329986bda9d7fe7b3d120876900" translate="yes" xml:space="preserve">
          <source>If a specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the data transfer subsystem, then invoking this method will establish a mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt; and an encoded version of its MIME type as its native.</source>
          <target state="translated">지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 가 가 이전에 데이터 전송 하위 시스템에 알려지지 않은 경우이 메서드를 호출하면 지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 와 해당 MIME 유형의 인코딩 된 버전 사이의 양방향 매핑 이 네이티브로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cdffd367cf1c3286a3204c998849759d715a852b" translate="yes" xml:space="preserve">
          <source>If a specified native is previously unknown to the data transfer subsystem, and that native has been properly encoded, then invoking this method will establish a mapping in both directions between the specified native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded version of the native.</source>
          <target state="translated">지정된 네이티브가 이전에 데이터 전송 하위 시스템에 알려지지 않았고 해당 네이티브가 올바르게 인코딩 된 경우이 메서드를 호출하면 지정된 네이티브와 서버 사이의 양방향 매핑이 설정됩니다. &lt;code&gt;DataFlavor&lt;/code&gt; MIME 유형이 네이티브의 디코딩 된 버전 인 DataFlavor .</target>
        </trans-unit>
        <trans-unit id="5dcefe732742542e44af9fa0d4a6e91c269fcc8e" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator()&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">spliterator는 그 이상 다음에 요소 추가 특성 값의보고를 포함하지 않는 경우 &lt;code&gt;SIZED&lt;/code&gt; 와 &lt;code&gt;SUBSIZED&lt;/code&gt; 을 제어 전문화 또는 단순화 계산에 클라이언트를 도움이되지 않습니다. 그러나 이렇게하면 변경 불가능하고 빈 분할기 인스턴스를 공유 할 수 있습니다 (&lt;a href=&quot;spliterators#emptySpliterator()&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt;빈 컬렉션 Spliterators.emptySpliterator ())를할 수 있으며 클라이언트가 이러한 분할기가 요소를 포함하지 않는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde854bb0f9389f51a8a547bcdbab6e693c555ad" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">spliterator는 그 이상 다음에 요소 추가 특성 값의보고를 포함하지 않는 경우 &lt;code&gt;SIZED&lt;/code&gt; 와 &lt;code&gt;SUBSIZED&lt;/code&gt; 을 제어 전문화 또는 단순화 계산에 클라이언트를 도움이되지 않습니다. 그러나 이렇게하면 빈 컬렉션 에 대해 불변의 빈 스플리터 인스턴스 ( &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt; 참조 )를 공유하여 사용할 수 있으며 클라이언트가 그러한 스플리터가 요소를 포함하지 않는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b9f294ae09940094318e9c13a1774353137fae2" translate="yes" xml:space="preserve">
          <source>If a step function is omitted, use an &lt;a href=&quot;#identity(java.lang.Class)&quot;&gt;identity function&lt;/a&gt; of the clause's iteration variable type; insert dropped argument parameters before the identity function parameter for the non-&lt;code&gt;void&lt;/code&gt; iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)</source>
          <target state="translated">단계 함수가 생략 된 경우 절의 반복 변수 유형의 &lt;a href=&quot;#identity(java.lang.Class)&quot;&gt;식별 함수&lt;/a&gt; 를 사용하십시오. 삭제 된 인수 매개 변수를 식별 기능 매개 변수 앞에 삽입하십시오. &lt;code&gt;void&lt;/code&gt; 이전 절의 무효 반복 변수에 . (이렇게하면 루프 변수가 로컬 루프 불변으로 바뀝니다.)</target>
        </trans-unit>
        <trans-unit id="377c4e71a3077730a1c7765115b7830cff588ee5" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput(java.lang.Object,boolean,boolean)&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">스트림에 테이블이 포함 된 경우 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 제공된 테이블 은 무시됩니다. 또한 스트림의 첫 번째 이미지에 테이블이 포함되어 있고 후속 이미지에는 포함되지 않은 경우 첫 번째 이미지에 제공된 테이블이 모든 축약 된 이미지에 사용됩니다. 스트림에서 테이블을 읽은 후에는 동일한 스트림에서 읽은 테이블에 의해서만 재정의 될 수 있습니다. 새 테이블을 지정하려면&lt;a href=&quot;../../imagereader#setInput(java.lang.Object,boolean,boolean)&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt;하려면 판독기 setInput 메서드를 호출하여 스트림을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="eceb3e8bdd7aa7928b72e084cf57d623f635838d" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">스트림에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 지정된 테이블 이 무시됩니다. 또한 스트림의 첫 번째 이미지에 테이블이 포함되고 후속 이미지에 테이블이 포함되지 않은 경우 첫 번째 이미지에 제공된 테이블이 모든 약어 이미지에 사용됩니다. 스트림에서 테이블을 읽은 후에는 동일한 스트림에서 읽은 테이블 만 재정의 할 수 있습니다. 새 테이블을 지정 하려면 스트림을 변경하기 위해 리더 의 &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2750feeb92c351bda0cd825237cf381d71b3604" translate="yes" xml:space="preserve">
          <source>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;[1, 2, 3]&lt;/code&gt;, then the result of executing &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; must be &lt;code&gt;[2, 4, 6]&lt;/code&gt;. However, if the source has no defined encounter order, then any permutation of the values &lt;code&gt;[2, 4, 6]&lt;/code&gt; would be a valid result.</source>
          <target state="translated">스트림이 정렬되면 대부분의 작업은 요소에 대해 발생 순서대로 작동하도록 제한됩니다. 스트림의 소스가 &lt;code&gt;List&lt;/code&gt; 인 경우 가 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 포함 경우 &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; 실행 결과는 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 이어야합니다 . 그러나 소스에 정의 된 조우 순서가 없으면 값 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 순열이 올바른 결과가됩니다.</target>
        </trans-unit>
        <trans-unit id="ec3da9f5ed3a50caf2ebc15ff55bbd7387d78001" translate="yes" xml:space="preserve">
          <source>If a string quote character is encountered, then a string is recognized, consisting of all characters after (but not including) the string quote character, up to (but not including) the next occurrence of that same string quote character, or a line terminator, or end of file. The usual escape sequences such as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and &lt;code&gt;&quot;\t&quot;&lt;/code&gt; are recognized and converted to single characters as the string is parsed.</source>
          <target state="translated">문자열 따옴표 문자가 발견되면 문자열 따옴표 문자 다음의 모든 문자 (포함되지는 않음), 같은 문자열 따옴표 문자의 다음 발생 (또는 포함하지 않음)까지의 문자열이 인식됩니다. 또는 파일 끝입니다. &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 와 같은 일반적인 이스케이프 시퀀스 는 문자열을 구문 분석 할 때 인식되어 단일 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9282cd8e98665287e6b1f89eff4485a0a4410646" translate="yes" xml:space="preserve">
          <source>If a style name field is not one of the valid style strings, it is interpreted as part of the font name, and the default style is used.</source>
          <target state="translated">스타일 이름 필드가 유효한 스타일 문자열 중 하나가 아닌 경우 글꼴 이름의 일부로 해석되고 기본 스타일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b339629857a7b6f3977e054ffb46a3342349d262" translate="yes" xml:space="preserve">
          <source>If a suitable MIDI port is not available, the Receiver is retrieved from an installed synthesizer.</source>
          <target state="translated">적합한 MIDI 포트를 사용할 수없는 경우 설치된 신디사이저에서 수신기를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="cee086fbf4e72f394e2cd369d7a1a31214c885ef" translate="yes" xml:space="preserve">
          <source>If a superinterface is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types.</source>
          <target state="translated">수퍼 인터페이스가 매개 변수화 된 유형 인 경우 &lt;code&gt;Type&lt;/code&gt; 리턴 Type 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다. 각 슈퍼 인터페이스를 나타내는 매개 변수화 된 유형은 이전에 작성되지 않은 경우 작성됩니다. 매개 변수화 된 유형에 대한 작성 프로세스의 시맨틱에 대해서는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 선언을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1534d214fc89bef5391048993cff1403fb779faa" translate="yes" xml:space="preserve">
          <source>If a supported attribute-value is specified in this attribute set, it will take precedence over the API settings for this print() operation only. The following behaviour is specified for PageFormat: If a client uses the Printable interface, then the &lt;code&gt;attributes&lt;/code&gt; parameter to this method is examined for attributes which specify media (by size), orientation, and imageable area, and those are used to construct a new PageFormat which is passed to the Printable object's print() method. See &lt;a href=&quot;printable&quot;&gt;&lt;code&gt;Printable&lt;/code&gt;&lt;/a&gt; for an explanation of the required behaviour of a Printable to ensure optimal printing via PrinterJob. For clients of the Pageable interface, the PageFormat will always be as supplied by that interface, on a per page basis.</source>
          <target state="translated">이 속성 세트에 지원되는 속성 값이 지정되면이 print () 작업에 대해서만 API 설정보다 우선합니다. PageFormat에 대해 다음 동작이 지정됩니다. 클라이언트가 Printable 인터페이스를 사용하는 경우이 메서드에 대한 &lt;code&gt;attributes&lt;/code&gt; 매개 변수는 미디어 (크기별), 방향 및 이미지 가능 영역을 지정하는 속성에 대해 검사되며 새 PageFormat을 구성하는 데 사용됩니다. Printable 객체의 print () 메서드에 전달됩니다. PrinterJob을 통해 최적의 인쇄를 보장하기 위해 Printable의 필수 동작에 대한 설명은 &lt;a href=&quot;printable&quot;&gt; &lt;code&gt;Printable&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 . Pageable 인터페이스의 클라이언트의 경우 PageFormat은 항상 페이지별로 해당 인터페이스에서 제공하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="155d85c2f3acb3ff96d47d191351e45387cd2b50" translate="yes" xml:space="preserve">
          <source>If a system property named &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then the headless implementation of &lt;code&gt;Toolkit&lt;/code&gt; is used, otherwise the default platform-specific implementation of &lt;code&gt;Toolkit&lt;/code&gt; is used.</source>
          <target state="translated">시스템 프로퍼티라는 이름의 경우 &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; 로 설정 &lt;code&gt;true&lt;/code&gt; 다음의 헤드리스 구현 &lt;code&gt;Toolkit&lt;/code&gt; , 사용의 다른 기본 플랫폼 별 구현 &lt;code&gt;Toolkit&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6f96de5e57069f6d14d17aca38943e0fdc8ff7" translate="yes" xml:space="preserve">
          <source>If a thread does not lock any object monitor or &lt;code&gt;lockedMonitors&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;MonitorInfo&lt;/code&gt; array. Similarly, if a thread does not lock any synchronizer or &lt;code&gt;lockedSynchronizers&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;LockInfo&lt;/code&gt; array.</source>
          <target state="translated">스레드가 객체 모니터를 잠그지 않거나 &lt;code&gt;lockedMonitors&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 반환 된 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체는 빈 &lt;code&gt;MonitorInfo&lt;/code&gt; 배열을 갖습니다 . 마찬가지로 스레드가 동기화 프로그램을 잠그지 않거나 &lt;code&gt;lockedSynchronizers&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 반환 된 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체에는 빈 &lt;code&gt;LockInfo&lt;/code&gt; 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="423d67d62c33ea4b987acaba9861af6927d6c017" translate="yes" xml:space="preserve">
          <source>If a thread initiates the loading of the installed file system providers and another thread invokes a method that also attempts to load the providers then the method will block until the loading completes.</source>
          <target state="translated">스레드가 설치된 파일 시스템 제공자의로드를 시작하고 다른 스레드가 제공자를로드하려고 시도하는 메소드를 호출하면로드가 완료 될 때까지 메소드가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c16eea84f6a093216a1f6035633219e642c6696f" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">대기 중 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 대기가 종료되고 &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt; 이 발생하며 스레드의 중단 상태가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="c7ba95dc1b6c41c9659ab72fa979fc5c3b29d122" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">기다리는 동안 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 대기가 종료됩니다.&lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt; 이 발생하며 스레드의 중단 상태가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="26eeddc8ed4e366f2633c02e1ace6b55601c08d7" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 차단 된 스레드의 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다 . 이로 인해 채널이 닫히고 차단 된 스레드가 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt; 을 수신하며 차단 된 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9af6babb2d89b7b1bcb5f61c939d4682bb0b8bf3" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 차단 된 스레드의 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 . 그러면 채널이 닫히고 차단 된 스레드가 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt; 을 수신 하고 차단 된 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b319d96f8fb779e6cf6dbc96644a4c37d14e3fed" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 채널의 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다 . 이로 인해 차단 된 스레드가 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 을 수신하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd99bc1eee5eed72f1e348ec811d11b7678f072e" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;interruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 채널의 &lt;a href=&quot;interruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 . 차단 된 스레드가 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 을 수신하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="741c512b0e9856c5e2dfc36c34abb9cce44c9e8d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;#wakeup()&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드가 현재이 선택기의 선택 방법 중 하나에서 차단 된 경우 선택기의 &lt;a href=&quot;#wakeup()&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 방법 을 호출하는 것처럼 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="da330aea3c98594d1083e77da98a318f71baeb0d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드가이 선택기의 선택 방법 중 하나에서 현재 차단 된 경우 선택기의 호출을 호출하는 것처럼 스레드가 중단됩니다. &lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="dd825fe40f49db3b150afa3490d105cbd6aabd48" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;#take()&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#poll(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid()&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스레드가 현재 &lt;a href=&quot;#take()&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 에서 차단 된 경우 또는 &lt;a href=&quot;#poll(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 메서드 키가 대기열에 추가되기를 기다리는 경우 즉시 &lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; 을&lt;/a&gt; 수신합니다 . 이 감시 서비스와 관련된 모든 유효한 키는 &lt;a href=&quot;watchkey#isValid()&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d5afbadf14eba91b88bef9af2e17ba1b04cf7b04" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;watchservice#take--&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid--&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스레드가 현재 키 대기를 기다리는 &lt;a href=&quot;watchservice#take--&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 경우 즉시 &lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; 을&lt;/a&gt; 수신합니다 . 이 시계 서비스와 관련된 모든 유효한 키는&lt;a href=&quot;watchkey#isValid--&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="79a80fec9ac0e51a906db8a969589f57b8d53771" translate="yes" xml:space="preserve">
          <source>If a thread of the given ID is not alive or does not exist, this method will return &lt;code&gt;null&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">주어진 ID의 스레드가 존재하지 않거나 존재하지 않으면이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c7367fdf45de9116c0531a4eb673c46e4df10f0d" translate="yes" xml:space="preserve">
          <source>If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;; its interrupt status will remain set.</source>
          <target state="translated">스레드의 인터럽트 상태가 이미 설정되어 있고 채널에서 차단 I / O 작업을 호출하면 채널이 닫히고 스레드는 즉시 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; 을&lt;/a&gt;. 인터럽트 상태는 설정된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f20c8ec4cbcd889326c0ec36148d75b1de4b78c0" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 예외와 함께 완료됩니다. &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;. 시간 초과가 발생하고 구현에서 바이트를 읽지 못했거나 채널에서 지정된 버퍼로 읽지 않는다고 보장 할 수없는 경우 채널에서 계속 읽으려고하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="085511ee4e6f8838601b8420555dabe5caf417db" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 예외와 함께 완료됩니다. &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;. 시간 초과가 발생하고 구현시 바이트가 기록되지 않았거나 지정된 버퍼에서 채널에 기록되지 않을 것을 보장 할 수없는 경우 채널에 쓰려고 시도하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1e6a9ea34cc15cb7dc234bc610d3da7fd2fd1d7" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt; 예외와 함께 완료됩니다. . 시간 초과가 발생하고 구현시 바이트가 기록되지 않았거나 지정된 버퍼에서 채널에 기록되지 않을 것을 보장 할 수없는 경우 채널에 쓰려고하면 추가로 런타임에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aeea9b2c990269d554f71236286a06879279f31" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">제한 시간이 지정되고 조작이 완료되기 전에 제한 시간이 경과하면 &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt; 예외로 조작이 완료됩니다 . 시간 초과가 발생하고 구현에서 바이트를 읽지 못했거나 채널에서 지정된 버퍼로 읽지 않을 것을 보장 할 수없는 경우 채널에서 계속 읽으려고하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b059429e7b4fbc4030cc099662067f32b6c7ab30" translate="yes" xml:space="preserve">
          <source>If a type is annotated with this annotation type, compilers are required to generate an error message unless:</source>
          <target state="translated">이 주석 유형으로 유형에 주석이 달린 경우 다음과 같은 경우를 제외하고 컴파일러는 오류 메시지를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="30a46db240d4202d821461d90b26ad19eebaf078" translate="yes" xml:space="preserve">
          <source>If a type map is explicitly supplied to a method that can perform custom mapping, that type map supersedes the connection's type map.</source>
          <target state="translated">사용자 지정 매핑을 수행 할 수있는 메서드에 형식 맵이 명시 적으로 제공되면 해당 형식 맵이 연결의 형식 맵을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="cec90847ba71497dbb8ac58a8a03e00d0d13737f" translate="yes" xml:space="preserve">
          <source>If a value attribute is not specified for a FORM input element of type &quot;reset&quot;, then this default string is used.</source>
          <target state="translated">&quot;reset&quot;유형의 FORM 입력 요소에 값 속성이 지정되지 않은 경우이 기본 문자열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0d011a6bf2d15325c296c503e117073be6dd16" translate="yes" xml:space="preserve">
          <source>If a value attribute is not specified for a FORM input element of type &quot;submit&quot;, then this default string is used.</source>
          <target state="translated">&quot;제출&quot;유형의 FORM 입력 요소에 값 속성이 지정되지 않은 경우이 기본 문자열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9870e38cea09b6406ac14017d5c924cd67267c1" translate="yes" xml:space="preserve">
          <source>If a value is not present, returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 없으면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="860fe4e2923a6695add73192da6784b1d700c654" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;Optional&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Optional&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="ac19fb5ed0433a6a84bbf9870c3d0508394c1ec9" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalDouble&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalDouble&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="77f8284a88fc486cd8c49e73e5157ec4382cced0" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalInt&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalInt&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="b442beaf0679fd03d92130f9d3a16dff8abc1a47" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalLong&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalLong&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="b332c643a29d3b80d91478304a9a05ebfa61d296" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;Optional&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 존재하는 &lt;code&gt;Optional&lt;/code&gt; 은 분명하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc6398511731b6bf47b59801abf764ae618774f0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalDouble&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 현재 &lt;code&gt;OptionalDouble&lt;/code&gt; 은 명확하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d13847496ad6374cf53cad3b090b540d8f97008c" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalInt&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 현재 &lt;code&gt;OptionalInt&lt;/code&gt; 는 분명하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="32534cbdba6aa1b3be53d4a1e4bd73d3c27b87e1" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalLong&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">값이있는 경우 결과는 결과에 해당 문자열 표현을 포함해야합니다. 비어 있고 현재 &lt;code&gt;OptionalLong&lt;/code&gt; 은 명확하게 구별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e270a2bbe380815af7730e0b32eed7b9b310b0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present Optionals must be unambiguously differentiable.</source>
          <target state="translated">값이 있으면 결과에 문자열 표현이 포함되어야합니다. 비어 있고 존재하는 옵션은 명확하게 구분할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="53843db157010fe9437f6ec6848ceaa2431d68a8" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present instances must be unambiguously differentiable.</source>
          <target state="translated">값이 있으면 결과에 문자열 표현이 포함되어야합니다. 비어있는 인스턴스와 현재 인스턴스는 명확하게 구분할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0706b2c7911a55318a829716b41ba2d3be31b10d" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, return an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하고 값이 주어진 술어와 일치 하면 값을 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 리턴하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f1f67ed14ddaf89a0a9fae6c94b2add61c02da04" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, returns an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하고 값이 주어진 술어와 일치하면 &lt;code&gt;Optional&lt;/code&gt; 리턴합니다. 하면 값을 설명 을 반환하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="891603f3a0de1e1f312f4666b625f9fb23d2e9c9" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to it, return that result, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;. This method is similar to &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt;&lt;code&gt;map(Function)&lt;/code&gt;&lt;/a&gt;, but the provided mapper is one whose result is already an &lt;code&gt;Optional&lt;/code&gt;, and if invoked, &lt;code&gt;flatMap&lt;/code&gt; does not wrap it with an additional &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하면 제공된 &lt;code&gt;Optional&lt;/code&gt; 베어링 맵핑 함수를 적용하고 결과를 리턴하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 리턴하십시오 . 이 메소드는 &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt; &lt;code&gt;map(Function)&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 제공된 매퍼는 결과가 이미 &lt;code&gt;Optional&lt;/code&gt; 인 결과이며 , 호출 된 경우 &lt;code&gt;flatMap&lt;/code&gt; 은 추가 &lt;code&gt;Optional&lt;/code&gt; 로 랩핑하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b5560d2bb98c2edc06f003311054df22294d95" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an &lt;code&gt;Optional&lt;/code&gt; describing the result. Otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 제공된 맵핑 함수를 적용하고 결과가 널이 아닌 경우 결과를 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 리턴 하십시오. 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fad40f63b1a2a9bdb013e89c0f84f329771e8703" translate="yes" xml:space="preserve">
          <source>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</source>
          <target state="translated">값이 존재하면 지정된 소비자를 값으로 호출하십시오. 그렇지 않으면 아무 것도 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5d567ac49757fc0782070c29f442b2ed3c10a3dd" translate="yes" xml:space="preserve">
          <source>If a value is present, performs the given action with the value, otherwise does nothing.</source>
          <target state="translated">값이 있으면 해당 값으로 지정된 작업을 수행하고 그렇지 않으면 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80f1d15f081a557c0c89dfe542e08e6466937a4a" translate="yes" xml:space="preserve">
          <source>If a value is present, performs the given action with the value, otherwise performs the given empty-based action.</source>
          <target state="translated">값이 있으면 해당 값으로 지정된 작업을 수행하고, 그렇지 않으면 지정된 빈 기반 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7c76eb4f4aed61ec0dcaef4e6193ded7df1448b7" translate="yes" xml:space="preserve">
          <source>If a value is present, returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . .</target>
        </trans-unit>
        <trans-unit id="990df4fbcc05f42f66d4bdbbd223d271fecafc58" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/doublestream&quot;&gt;&lt;code&gt;DoubleStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;DoubleStream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차 &lt;a href=&quot;stream/doublestream&quot;&gt; &lt;code&gt;DoubleStream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;DoubleStream&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="385631a2bb5e8e2699a3121cde109d9d5c428c7c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/intstream&quot;&gt;&lt;code&gt;IntStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;IntStream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차적 &lt;a href=&quot;stream/intstream&quot;&gt; &lt;code&gt;IntStream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;IntStream&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="866cb2164afa2f09d3d5f20e37c35481f6eb4412" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/longstream&quot;&gt;&lt;code&gt;LongStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;LongStream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차 &lt;a href=&quot;stream/longstream&quot;&gt; &lt;code&gt;LongStream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;LongStream&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5d3bb8d4c843a69020ffe62321e3f9054e0b137e" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;Stream&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 해당 값만 포함 하는 순차 &lt;a href=&quot;stream/stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 을 반환하고, 그렇지 않으면 빈 &lt;code&gt;Stream&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="80b22e4088b80520ac0af98bec76415b35276b8f" translate="yes" xml:space="preserve">
          <source>If a value is present, returns an &lt;code&gt;Optional&lt;/code&gt; describing (as if by &lt;a href=&quot;#ofNullable(T)&quot;&gt;&lt;code&gt;ofNullable(T)&lt;/code&gt;&lt;/a&gt;) the result of applying the given mapping function to the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 주어진 매핑 함수를 값에 적용한 결과를 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 반환하고 ( &lt;a href=&quot;#ofNullable(T)&quot;&gt; &lt;code&gt;ofNullable(T)&lt;/code&gt; &lt;/a&gt; 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="abd4d4cf8da044effb78b2adaaded70498203413" translate="yes" xml:space="preserve">
          <source>If a value is present, returns an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise returns an &lt;code&gt;Optional&lt;/code&gt; produced by the supplying function.</source>
          <target state="translated">값이 있으면 값을 설명하는 &lt;code&gt;Optional&lt;/code&gt; 을 반환하고 그렇지 않으면 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다. 제공하는 함수에 의해 생성 된 합니다.</target>
        </trans-unit>
        <trans-unit id="d4b5e82c51b8cf385fd5db9aef6045fbce1f3044" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the result of applying the given &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 주어진 &lt;code&gt;Optional&lt;/code&gt; -bearing 매핑 함수를 값 에 적용한 결과를 반환하고 , 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f14d878112134ffc9ff4d14f0e3174e5576c31bb" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise returns &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 값을 반환하고 그렇지 않으면 &lt;code&gt;other&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8c50641617ef0d200da8db393fec3586af58ae1c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise returns the result produced by the supplying function.</source>
          <target state="translated">값이 있으면 값을 반환하고, 그렇지 않으면 제공하는 함수에서 생성 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56c949f365a2890532569468d612418290144d9c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="ae9bed738425dfb5a5a5674c68f5303dddc05d71" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise throws an exception produced by the exception supplying function.</source>
          <target state="translated">값이 있으면 값을 반환하고, 그렇지 않으면 예외 제공 함수에서 생성 한 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="8eddee0588c954a17deb099f9dd61de2515231b4" translate="yes" xml:space="preserve">
          <source>If a value of null is specified for the Set, this Component inherits the Set from its parent. If all ancestors of this Component have null specified for the Set, then the current KeyboardFocusManager's default Set is used.</source>
          <target state="translated">Set에 null 값이 지정되면이 컴포넌트는 부모로부터 Set을 상속합니다. 이 컴포넌트의 모든 조상이 Set에 대해 null을 지정하면 현재 KeyboardFocusManager의 기본 Set이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f16c24760d5749166bc98a390f507c2d3216615" translate="yes" xml:space="preserve">
          <source>If a value of null is specified for the Set, this Container inherits the Set from its parent. If all ancestors of this Container have null specified for the Set, then the current KeyboardFocusManager's default Set is used.</source>
          <target state="translated">Set에 null 값이 지정되면이 컨테이너는 부모로부터 Set를 상속합니다. 이 컨테이너의 모든 조상이 Set에 대해 null을 지정하면 현재 KeyboardFocusManager의 기본 Set이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="387ee9cb7e9e0be3dd6915fcd912184178dc89a4" translate="yes" xml:space="preserve">
          <source>If a vertical scrollbar is needed, i.e. if the viewport's extent height is smaller than its view height or if the &lt;code&gt;displayPolicy&lt;/code&gt; is ALWAYS, it's treated like the row header with respect to its dimensions and is made visible.</source>
          <target state="translated">수직 스크롤바가 필요한 경우, 즉 뷰포트의 범위 높이가 뷰 높이보다 작거나 &lt;code&gt;displayPolicy&lt;/code&gt; 가 ALWAYS 인 경우, 치수와 관련하여 행 헤더처럼 처리되고 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc4cf82efa4121c970d3bd205365e50de294c4b" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;
 NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">방문자가의 결과를 돌려주는 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt; NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="92cb4d374f2fe9448ca335ac55aeaabe71a1f569" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">방문자가의 결과를 돌려주는 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="5e01b98873a0cadbbe64c47b2b726716a54e9964" translate="yes" xml:space="preserve">
          <source>If a watched file is not located on a local storage device then it is implementation specific if changes to the file can be detected. In particular, it is not required that changes to files carried out on remote systems be detected.</source>
          <target state="translated">감시 된 파일이 로컬 저장 장치에 없으면 파일 변경이 감지 될 수있는 경우 구현에 따라 다릅니다. 특히, 원격 시스템에서 수행 된 파일의 변경을 감지 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5650a3db9a7e2000acade2b25c2be5c4db496f6e" translate="yes" xml:space="preserve">
          <source>If a writer isRepairingNamespaces it will create a namespace declaration on the current StartElement for any attribute that does not currently have a namespace declaration in scope. If the StartElement has a uri but no prefix specified a prefix will be assigned, if the prefix has not been declared in a parent of the current StartElement it will be declared on the current StartElement. If the defaultNamespace is bound and in scope and the default namespace matches the URI of the attribute or StartElement QName no prefix will be assigned.</source>
          <target state="translated">작성자가 isRepairingNamespaces이면 현재 범위에 네임 스페이스 선언이없는 속성에 대해 현재 StartElement에 네임 스페이스 선언을 만듭니다. StartElement에 uri가 있지만 접두사가 지정되지 않은 경우 접두사가 할당되고 접두사가 현재 StartElement의 부모에서 선언되지 않은 경우 현재 StartElement에서 선언됩니다. defaultNamespace가 바인딩되고 범위 내에 있고 기본 네임 스페이스가 특성의 URI 또는 ​​StartElement QName과 일치하면 접두사가 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73a81112b02af25fafd5aeb53509af8b9467d422" translate="yes" xml:space="preserve">
          <source>If aContainer is &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;, the focus is always transferred down-cycle.</source>
          <target state="translated">aContainer가 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;포커스 순회 정책 공급자&lt;/a&gt; 인 경우 포커스는 항상 다운 사이클로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="bee200d444da7e51810a8f81ba5dffe16cc316fc" translate="yes" xml:space="preserve">
          <source>If addr specifies an IPv4 address an instance of Inet4Address will be returned; otherwise, an instance of Inet6Address will be returned.</source>
          <target state="translated">addr이 IPv4 주소를 지정하면 Inet4Address의 인스턴스가 리턴됩니다. 그렇지 않으면 Inet6Address의 인스턴스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="923186511eab92209b32f15d3fb01aaacb2e442c" translate="yes" xml:space="preserve">
          <source>If adjacent parsing is active, then parsing must match exactly the specified number of digits in both strict and lenient modes. In addition, no positive or negative sign is permitted.</source>
          <target state="translated">인접 구문 분석이 활성화 된 경우 구문 분석은 엄격 모드와 무성 모드에서 지정된 자릿수와 정확히 일치해야합니다. 또한 양수 또는 음수 부호는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="200dbc311565e1132ebe3228cefc3d9aab1c06b2" translate="yes" xml:space="preserve">
          <source>If adjacent runs of text with the same &lt;code&gt;InputMethodHighlight&lt;/code&gt; need to be rendered separately, the &lt;code&gt;InputMethodHighlights&lt;/code&gt; should be wrapped in &lt;code&gt;Annotation&lt;/code&gt; instances.</source>
          <target state="translated">동일한 &lt;code&gt;InputMethodHighlight&lt;/code&gt; 를 가진 인접 텍스트 실행을 별도로 렌더링해야하는 경우 &lt;code&gt;InputMethodHighlights&lt;/code&gt; 를 &lt;code&gt;Annotation&lt;/code&gt; 인스턴스 로 래핑해야 합니다.</target>
        </trans-unit>
        <trans-unit id="716099ad8a55cb2a7c2b3773b52c94f64ee203cb" translate="yes" xml:space="preserve">
          <source>If after the window location has been calculated, the upper, left, or right edge of the window is out of the screen, then the window is located in such a way that the upper, left, or right edge of the window coincides with the corresponding edge of the screen. If both left and right edges of the window are out of the screen, the window is placed at the left side of the screen. The similar placement will occur if both top and bottom edges are out of the screen. In that case, the window is placed at the top side of the screen.</source>
          <target state="translated">창 위치를 계산 한 후 창의 위쪽, 왼쪽 또는 오른쪽 가장자리가 화면 밖에 있으면 창의 위쪽, 왼쪽 또는 오른쪽 가장자리가 일치하는 방식으로 창이 배치됩니다. 화면의 해당 가장자리. 창의 왼쪽과 오른쪽 가장자리가 모두 화면 밖에있는 경우 창은 화면 왼쪽에 배치됩니다. 위쪽과 아래쪽 가장자리가 모두 화면을 벗어나면 유사한 배치가 발생합니다. 이 경우 창은 화면 상단에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="44d02905089e1694a5a3552ec8bae0d4cda874a1" translate="yes" xml:space="preserve">
          <source>If agent classes need to link to classes in platform (or other) modules that are not in the boot layer then the application may need to be started in a way that ensures that these modules are in the boot layer. In the JDK implementation for example, the &lt;code&gt;--add-modules&lt;/code&gt; command line option can be used to add modules to the set of root modules to resolve at startup.</source>
          <target state="translated">에이전트 클래스가 부트 계층에없는 플랫폼 (또는 기타) 모듈의 클래스에 링크해야하는 경우 이러한 모듈이 부트 계층에 있는지 확인하는 방식으로 애플리케이션을 시작해야 할 수 있습니다. 예를 들어 JDK 구현에서 &lt;code&gt;--add-modules&lt;/code&gt; 명령 줄 옵션을 사용하여 시작시 확인할 루트 모듈 집합에 모듈을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa34a3f881c3ffb5525522b340dad76550fa33e" translate="yes" xml:space="preserve">
          <source>If all inputs are null, the &lt;code&gt;LSParser&lt;/code&gt; will report a &lt;code&gt;DOMError&lt;/code&gt; with its &lt;code&gt;DOMError.type&lt;/code&gt; set to &lt;code&gt;&quot;no-input-specified&quot;&lt;/code&gt; and its &lt;code&gt;DOMError.severity&lt;/code&gt; set to &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt;.</source>
          <target state="translated">모든 입력이 null의 경우, &lt;code&gt;LSParser&lt;/code&gt; 에이 보고서 것 &lt;code&gt;DOMError&lt;/code&gt; 을 그와 함께 &lt;code&gt;DOMError.type&lt;/code&gt; 의 로 세트 &lt;code&gt;&quot;no-input-specified&quot;&lt;/code&gt; 과 &lt;code&gt;DOMError.severity&lt;/code&gt; 의 로 설정 &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8c6c1fd23bed92157c4876b59e8a94de5ba0fe9" translate="yes" xml:space="preserve">
          <source>If all of the keys in the key set at the start of this step have empty interest sets then neither the selected-key set nor any of the keys' ready-operation sets will be updated.</source>
          <target state="translated">이 단계를 시작할 때 키 세트의 모든 키에 비어있는 관심 세트가 있으면 선택한 키 세트와 키의 준비 작업 세트가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="785bd1a03946e5c11649c06831e14c3b158e51f0" translate="yes" xml:space="preserve">
          <source>If all samples of both source and destination Rasters are of integral type and less than or equal to 32 bits in size, then calling this method is equivalent to executing the following code for all &lt;code&gt;x,y&lt;/code&gt; addresses valid in both Rasters.</source>
          <target state="translated">소스 및 대상 Raster의 모든 샘플이 정수 유형이고 크기가 32 비트 이하인 경우이 메서드를 호출하는 것은 두 Raster에서 유효한 모든 &lt;code&gt;x,y&lt;/code&gt; 주소에 대해 다음 코드를 실행하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f4ad16a03d874b1099d86cc284527a5d0fd4f2c9" translate="yes" xml:space="preserve">
          <source>If all that is desired is the simple identity transformation of a source to a result, then &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; provides a &lt;a href=&quot;transformerfactory#newTransformer()&quot;&gt;&lt;code&gt;TransformerFactory.newTransformer()&lt;/code&gt;&lt;/a&gt; method with no arguments. This method creates a Transformer that effectively copies the source to the result. This method may be used to create a DOM from SAX events or to create an XML or HTML stream from a DOM or SAX events.</source>
          <target state="translated">원하는 것이 소스를 결과로 단순 ID 변환 하는 것 &lt;a href=&quot;transformerfactory#newTransformer()&quot;&gt; &lt;code&gt;TransformerFactory.newTransformer()&lt;/code&gt; &lt;/a&gt; 이라면 &lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt; 는 인수없이 TransformerFactory.newTransformer () 메서드를 제공합니다 . 이 메서드는 소스를 결과에 효과적으로 복사하는 Transformer를 만듭니다. 이 메서드는 SAX 이벤트에서 DOM을 생성하거나 DOM 또는 SAX 이벤트에서 XML 또는 HTML 스트림을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478f44b721763a191efa4a005ca8cf8c23dac1b2" translate="yes" xml:space="preserve">
          <source>If all the date objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date is used. To compare the dates of two &lt;code&gt;TemporalAccessor&lt;/code&gt; instances, including dates in two different chronologies, use &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as a comparator.</source>
          <target state="translated">비교되는 모든 날짜 개체가 동일한 연대기 인 경우 추가 연대기 단계가 필요하지 않으며 현지 날짜 만 사용됩니다. 두 개의 다른 연대기 날짜를 포함하여 두 &lt;code&gt;TemporalAccessor&lt;/code&gt; 인스턴스 의 날짜를 비교하려면 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 를 비교 자로 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="920032b96bedf78cb11745b4b01ea2b9da62f86c" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date-time is used.</source>
          <target state="translated">비교되는 모든 날짜-시간 객체가 동일한 연대기에있는 경우 추가 연대기 단계가 필요하지 않으며 로컬 날짜-시간 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91e24b45b1050248e3d9b0f32a1bfe41649a4f37" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required.</source>
          <target state="translated">비교되는 모든 날짜-시간 객체가 동일한 연대기이면 추가 연대기 단계가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eed6c18a7529e057741cc5ea4bc802b1033492a2" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo(java.time.chrono.ChronoLocalDateTime)&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교되는 모든 날짜-시간이 &lt;code&gt;LocalDateTime&lt;/code&gt; 의 인스턴스 인 경우 비교는 전적으로 날짜-시간을 기반으로합니다. 비교되는 일부 날짜가 다른 연대기에있는 경우 연대기도 고려됩니다. &lt;a href=&quot;chrono/chronolocaldatetime#compareTo(java.time.chrono.ChronoLocalDateTime)&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7af80a78ccebdf694054065e68649e1c92533dff" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교중인 모든 날짜-시간이 &lt;code&gt;LocalDateTime&lt;/code&gt; 의 인스턴스 인 경우 비교는 전적으로 날짜-시간을 기반으로합니다. 비교중인 일부 날짜가 다른 연대기 인 경우 연대기도 고려됩니다. &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8b68f4d96414def1c9a247a1feae8028274ccf8" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo(java.time.chrono.ChronoLocalDate)&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교되는 모든 날짜가 &lt;code&gt;LocalDate&lt;/code&gt; 의 인스턴스 인 경우 비교는 전적으로 날짜를 기반으로합니다. 비교되는 일부 날짜가 다른 연대기에있는 경우 연대기도 고려됩니다 . &lt;a href=&quot;chrono/chronolocaldate#compareTo(java.time.chrono.ChronoLocalDate)&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c70daeec02ec422b3471ddc6193b4b37b8cb8342" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교중인 모든 날짜가 &lt;code&gt;LocalDate&lt;/code&gt; 인스턴스 인 경우 비교는 전적으로 날짜를 기준으로합니다. 비교되는 일부 날짜가 다른 연대기 인 경우 연대기도 고려됩니다 . &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95938a0cd815321f6453791f7f4283d94220e212" translate="yes" xml:space="preserve">
          <source>If all the docs have the same binding specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">모든 문서에 지정된 바인딩이 동일 하면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의&lt;/a&gt; 값 이 의미가 있으며 프린터 처리는 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7869c5e4ed330a875f3cd70b80530f1cdf968256" translate="yes" xml:space="preserve">
          <source>If all the docs have the same number up value</source>
          <target state="translated">모든 문서의 번호가 같은 값을 갖는 경우</target>
        </trans-unit>
        <trans-unit id="323feabb33d09245620f68d33109a728cd260051" translate="yes" xml:space="preserve">
          <source>If all the docs have the same page ranges specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">모든 문서에 동일한 페이지 범위가 지정되어 있으면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 이 의미가 있으며 프린터 처리는 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7632f9c77b81ad5d1b5d6f09a7736f43de381a75" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of &lt;code&gt;SheetCollate&lt;/code&gt; and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">모든 문서에 동일한 시트 정렬이 지정된 경우 다음과 같은 &lt;code&gt;SheetCollate&lt;/code&gt; 및 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 조합 이 허용되며 다른 조합이 지정된 경우 작업이 제출 될 때 프린터가 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="43de23ce23841ef0c6a6fa16c30e0adac32dff5f" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of SheetCollate and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">모든 문서에 동일한 시트 데이터 정렬이 지정된 경우 다음 SheetCollate 및 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 조합 이 허용되며 다른 조합이 지정된 경우 작업이 제출 될 때 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="53f4aefa8b3b18b801db7105e517f135c3160808" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sides value</source>
          <target state="translated">모든 문서의 측면 값이 동일한 경우</target>
        </trans-unit>
        <trans-unit id="3b7bb19ce2d8fc8ee789c0716e2955f9d1adbc31" translate="yes" xml:space="preserve">
          <source>If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit except by throwing an exception.</source>
          <target state="translated">모든 pred 함수가 항상 true를 반환하면 fini 함수가 호출되지 않으며 루프는 예외를 throw하는 경우를 제외하고는 종료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5b294fc85ac6bc7caf05040784ae5fbc6fd93b1" translate="yes" xml:space="preserve">
          <source>If all the proxy interfaces are in &lt;em&gt;exported&lt;/em&gt; or &lt;em&gt;open&lt;/em&gt; packages:</source>
          <target state="translated">모든 프록시 인터페이스가 &lt;em&gt;내보내&lt;/em&gt; 거나 &lt;em&gt;열려있는&lt;/em&gt; 패키지에있는 경우 :</target>
        </trans-unit>
        <trans-unit id="13b164fb9c908e01dba066b8fc6c58bae1a8266f" translate="yes" xml:space="preserve">
          <source>If all the weights are zero, all the extra space appears between the grids of the cell and the left and right edges.</source>
          <target state="translated">모든 가중치가 0이면 셀의 그리드와 왼쪽 및 오른쪽 가장자리 사이에 모든 추가 공간이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="75e3f80e58848d10fc7b05443ed5b045728e7ed1" translate="yes" xml:space="preserve">
          <source>If all the weights are zero, all the extra space appears between the grids of the cell and the top and bottom edges.</source>
          <target state="translated">모든 가중치가 0이면 셀의 그리드와 위쪽 및 아래쪽 가장자리 사이에 모든 추가 공간이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="eb8a32bf1903f2512087dd34b708c9f237e4fae2" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#parsedExcessDays()&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">는 IF &lt;a href=&quot;#parsedExcessDays()&quot;&gt;일을 초과하는 수는&lt;/a&gt; 다음 구문 분석 그것은 날짜가 사용할 수있는 경우 날짜에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4098503fbcb241fe10627044b2064dc72f141550" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after returned from this method, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이는&lt;/a&gt; 이 메서드에서 반환 후 디렉토리에 액세스 할 때 발생합니다, 그것은는에 싸여 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 자리를 차지할 액세스의 원인이 된 방법에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="088dd2d19f784625275b483d3f0f4f2ddbb175e3" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after this method has returned, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이는&lt;/a&gt; 이 방법이 리턴 한 후 디렉토리에 액세스 할 때 발생합니다, 그것은는에 싸여 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 자리를 차지할 액세스의 원인이 된 방법에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="448273579cd0c1573f50adb27cc551f6240ac792" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">는 IF &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;일을 초과하는 수는&lt;/a&gt; 다음 구문 분석 그것은 날짜가 사용할 수있는 경우 날짜에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f440d6e16437287ae444b44920a0eee99c549130" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the underlying &lt;code&gt;BufferedReader&lt;/code&gt;, it is wrapped in an &lt;a href=&quot;uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the &lt;code&gt;Stream&lt;/code&gt; method that caused the read to take place. This method will return a Stream if invoked on a BufferedReader that is closed. Any operation on that stream that requires reading from the BufferedReader after it is closed, will cause an UncheckedIOException to be thrown.</source>
          <target state="translated">경우 &lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 가이&lt;/a&gt; 기본에 액세스 할 때 발생합니다 &lt;code&gt;BufferedReader&lt;/code&gt; 로를 , 그것은에 싸여 &lt;a href=&quot;uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 으로부터 발생합니다 &lt;code&gt;Stream&lt;/code&gt; 읽기가 발생하는 원인 방법. 이 메소드는 닫힌 BufferedReader에서 호출 된 경우 스트림을 리턴합니다. 해당 스트림에서 BufferedReader를 닫은 후 읽기가 필요한 작업을 수행하면 UncheckedIOException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="959df27348a054da287e538a4f7d1a74313d32f5" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is not present on an annotation type &lt;code&gt;T&lt;/code&gt; , then an annotation of type &lt;code&gt;T&lt;/code&gt; may be written as a modifier for any declaration except a type parameter declaration.</source>
          <target state="translated">는 IF &lt;code&gt;@Target&lt;/code&gt; 의 메타 주석이 주석 형에 존재하지 않는 &lt;code&gt;T&lt;/code&gt; 를 입력 한 다음의 주석 &lt;code&gt;T&lt;/code&gt; 는 타입 파라미터 선언 제외한 선언 개질제로서 기록 될 수있다.</target>
        </trans-unit>
        <trans-unit id="8371b963c2b6f04360837c6404d40bc176c92b9b" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is present, the compiler will enforce the usage restrictions indicated by &lt;code&gt;ElementType&lt;/code&gt; enum constants, in line with JLS 9.7.4.</source>
          <target state="translated">는 IF &lt;code&gt;@Target&lt;/code&gt; 의 메타 주석이 존재하는, 사용 제한을 적용합니다 컴파일러에 의해 표시 &lt;code&gt;ElementType&lt;/code&gt; 에의 JLS 9.7.4에 맞춰, 열거 상수.</target>
        </trans-unit>
        <trans-unit id="0c49dc23b8bd2062de89ca86518931b5b9024793" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; has not been explicitly set, one will be set based on the &lt;code&gt;Class&lt;/code&gt; of the value type after &lt;code&gt;setValue&lt;/code&gt; has been invoked (assuming value is non-null). For example, in the following code an appropriate &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; and &lt;code&gt;AbstractFormatter&lt;/code&gt; will be created to handle formatting of numbers:</source>
          <target state="translated">&lt;code&gt;AbstractFormatterFactory&lt;/code&gt; 가 명시 적으로 설정되지 않은 경우 &lt;code&gt;setValue&lt;/code&gt; 가 호출 된 후 값 유형 의 &lt;code&gt;Class&lt;/code&gt; 를 기반으로 하나가 설정 됩니다 (값이 널이 아닌 것으로 가정). 예를 들어, 다음 코드에서 적절한 &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; 및 &lt;code&gt;AbstractFormatter&lt;/code&gt; 는 숫자 형식을 처리하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2413517d9fd5745a82ae6ddf00cd7489151ba27f" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AffineTransform&lt;/code&gt; is passed to &lt;a href=&quot;#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)&quot;&gt;&lt;code&gt;drawImage(Image, AffineTransform, ImageObserver)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;AffineTransform&lt;/code&gt; is used to transform the bounding box from image space to user space. If no &lt;code&gt;AffineTransform&lt;/code&gt; is supplied, the bounding box is treated as if it is already in user space.</source>
          <target state="translated">는 IF &lt;code&gt;AffineTransform&lt;/code&gt; 전달됩니다 &lt;a href=&quot;#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)&quot;&gt; &lt;code&gt;drawImage(Image, AffineTransform, ImageObserver)&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;AffineTransform&lt;/code&gt; 이미지 공간으로부터 사용자 공간에 바운딩 박스를 변환하는 데 사용됩니다. &lt;code&gt;AffineTransform&lt;/code&gt; 이 제공 되지 않으면 경계 상자가 이미 사용자 공간에있는 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9496a4d3cf27eda519ac141e2a00e405156b6ffb" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the particular type of the input stream.</source>
          <target state="translated">는 IF &lt;code&gt;IOException&lt;/code&gt; 가이 발생되지 않고, 그 스트림은 입력 스트림의 특정 유형에 따라 고정 된 상태로 리셋되고 그것이 어떻게 만들어졌다. &lt;code&gt;read&lt;/code&gt; 메소드 의 후속 호출자에게 제공 될 바이트 는 입력 스트림의 특정 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8be497ebd5fad36819e8bdb92f6d004796dc73ce" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IndexColorModel&lt;/code&gt; object has a transparency value of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;, then the &lt;code&gt;hasAlpha&lt;/code&gt; and &lt;code&gt;getNumComponents&lt;/code&gt; methods (both inherited from &lt;code&gt;ColorModel&lt;/code&gt;) return false and 3, respectively. For any other transparency value, &lt;code&gt;hasAlpha&lt;/code&gt; returns true and &lt;code&gt;getNumComponents&lt;/code&gt; returns 4.</source>
          <target state="translated">는 IF &lt;code&gt;IndexColorModel&lt;/code&gt; 오브젝트의 투명도 값 갖는다 &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; 가를 다음 &lt;code&gt;hasAlpha&lt;/code&gt; 및 &lt;code&gt;getNumComponents&lt;/code&gt; 방법 (모두로부터 상속 &lt;code&gt;ColorModel&lt;/code&gt; 에 각각 복귀 거짓 및도 3). 다른 투명도 값의 경우 &lt;code&gt;hasAlpha&lt;/code&gt; 는 true를 반환하고 &lt;code&gt;getNumComponents&lt;/code&gt; 는 4를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6de50cf0b5b005c73f2b22f23092356cfbc265a6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; reference was previously allowed, the previous settings are overwritten.</source>
          <target state="translated">경우 &lt;code&gt;Object&lt;/code&gt; 참조가 이전에 허용 된 이전 설정을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ce889769df21717dff5602aeddeab9f3a68fa96a" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;RMIServerImpl&lt;/code&gt; was supplied to the constructor, it is used.</source>
          <target state="translated">&lt;code&gt;RMIServerImpl&lt;/code&gt; 이 생성자에 제공된 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c147456e60cfbfb343d2b171d44a03397a71498d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optionType&lt;/code&gt; was specified to this &lt;code&gt;ConfirmationCallback&lt;/code&gt;, this option may be specified as a &lt;code&gt;defaultOption&lt;/code&gt; or returned as the selected index.</source>
          <target state="translated">&lt;code&gt;optionType&lt;/code&gt; 이이 &lt;code&gt;ConfirmationCallback&lt;/code&gt; 에 지정된 경우 ,이 옵션은 &lt;code&gt;defaultOption&lt;/code&gt; 으로 지정 되거나 선택된 색인으로 리턴 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8447b90738960e5c08b7001e6598b18a44c5ae38" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal()&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">ACL 항목 에이 속성보기와 동일한 제공자와 연관되지 않은 &lt;a href=&quot;aclentry#principal()&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt; 이 포함 된 경우 &lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 추가 검증 (있는 경우)은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bddc19f4e2a7499584504adbd2e120339e8a9d2c" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal--&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">ACL 항목 에이 속성보기와 동일한 제공자와 연관되지 않은 &lt;a href=&quot;aclentry#principal--&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt; 이 포함 된 경우 &lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 추가 검증 (있는 경우)은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6e691cd0ee7a41eeed3186a97648a8370581048b" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered when accessing the directory then it causes the &lt;code&gt;Iterator&lt;/code&gt;'s &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; methods to throw &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; as the cause. As stated above, the &lt;code&gt;hasNext&lt;/code&gt; method is guaranteed to read-ahead by at least one element. This means that if &lt;code&gt;hasNext&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, and is followed by a call to the &lt;code&gt;next&lt;/code&gt; method, then it is guaranteed that the &lt;code&gt;next&lt;/code&gt; method will not fail with a &lt;code&gt;DirectoryIteratorException&lt;/code&gt;.</source>
          <target state="translated">디렉토리에 액세스 할 때 I / O 오류가 발생하면 &lt;code&gt;Iterator&lt;/code&gt; 의 &lt;code&gt;hasNext&lt;/code&gt; 또는 &lt;code&gt;next&lt;/code&gt; 메소드가 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 을 원인으로하여 &lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt; 을 발생시킵니다. 위에서 언급 한 바와 같이, &lt;code&gt;hasNext&lt;/code&gt; 방법은 적어도 하나의 요소에 의해 미리 읽히도록 보장된다. 즉, &lt;code&gt;hasNext&lt;/code&gt; 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 한 후 &lt;code&gt;next&lt;/code&gt; 메소드를 호출 하면 &lt;code&gt;next&lt;/code&gt; 메소드가 &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 과 함께 실패하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="feeedb640cf4499009e04bb26412c9322b88b5ad" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the file or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the output stream may be in an inconsistent state. It is strongly recommended that the output stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">파일에서 읽거나 출력 스트림에 쓰는 동안 I / O 오류가 발생하면 일부 바이트를 읽거나 쓴 후에 오류가 발생할 수 있습니다. 결과적으로 출력 스트림이 일치하지 않는 상태에있을 수 있습니다. I / O 오류가 발생하면 출력 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9c872125a1307797d25e4f9f64998713cf5ca5f3" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the file, then it may do so after the target file has been created and after some bytes have been read or written. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the input stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 읽거나 파일에 쓰는 동안 I / O 오류가 발생하면 대상 파일을 작성한 후 일부 바이트를 읽거나 쓴 후에 발생할 수 있습니다. 결과적으로, 입력 스트림은 스트림의 끝에 있지 않을 수 있으며 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 입력 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e4515b55c84516838e1780f2824973489fcfac02" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the input stream may not be at end of stream and one, or both, streams may be in an inconsistent state. It is strongly recommended that both streams be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 읽거나 출력 스트림에 쓰는 I / O 오류가 발생하면 일부 바이트를 읽거나 쓴 후에 오류가 발생할 수 있습니다. 결과적으로 입력 스트림은 스트림의 끝이 아닐 수 있으며 스트림 중 하나 또는 둘 모두가 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 두 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6575b29bb7b7702708e4556bb126e11740cace5" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream, then it may do so after some, but not all, bytes have been read. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 I / O 오류가 발생하면 일부 바이트를 읽은 후에 발생할 수 있습니다. 결과적으로 입력 스트림은 스트림의 끝에 있지 않을 수 있으며 일관성없는 상태에있을 수 있습니다. I / O 오류가 발생하면 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8650ce7705399aaaa8cc71478fcf996136dfacc1" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream, then it may do so after some, but not all, bytes of &lt;code&gt;b&lt;/code&gt; have been updated with data from the input stream. Consequently the input stream and &lt;code&gt;b&lt;/code&gt; may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 읽기 I / O 오류가 발생하면 전체가 아닌 일부 &lt;code&gt;b&lt;/code&gt; 바이트가 입력 스트림의 데이터로 업데이트 된 후에 발생할 수 있습니다 . 결과적으로 입력 스트림과 &lt;code&gt;b&lt;/code&gt; 는 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b10fec173abaf89ed742106df0192bdc5dd2cd41" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the reader or writing to the writer, then it may do so after some characters have been read or written. Consequently the reader may not be at end of the stream and one, or both, streams may be in an inconsistent state. It is strongly recommended that both streams be promptly closed if an I/O error occurs.</source>
          <target state="translated">판독기에서 읽거나 기록기에 쓰는 I / O 오류가 발생하면 일부 문자를 읽거나 쓴 후에 오류가 발생할 수 있습니다. 결과적으로 판독기는 스트림의 끝에 있지 않을 수 있으며 스트림 중 하나 또는 둘 모두가 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 두 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e0e0bbd8cf71d8f39745254a8443c1668c16acb" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context</source>
          <target state="translated">InitialContextFactoryBuilder가 설치되어 있으면 초기 컨텍스트를 만들기위한 팩토리를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="190c966c8992a3839001e7e1af1d2b89e9457c04" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context. Otherwise, the class specified in the &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; environment property is used. Note that an initial context factory (an object that implements the InitialContextFactory interface) must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">InitialContextFactoryBuilder가 설치된 경우 초기 컨텍스트를 작성하기위한 팩토리를 작성하는 데 사용됩니다. 그렇지 않으면 &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; 환경 특성에 가 사용됩니다. 초기 컨텍스트 팩토리 (InitialContextFactory 인터페이스를 구현하는 객체)는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="98657208ee304eaeabe25e126ff14f176c167883" translate="yes" xml:space="preserve">
          <source>If an MBean implements the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, then it is not added to the class loader repository. The class &lt;a href=&quot;privatemlet&quot;&gt;&lt;code&gt;PrivateMLet&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;code&gt;MLet&lt;/code&gt; that implements &lt;code&gt;PrivateClassLoader&lt;/code&gt;.</source>
          <target state="translated">MBean가 &lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 , 클래스 로더 저장소에 추가되지 않습니다. 클래스 &lt;a href=&quot;privatemlet&quot;&gt; &lt;code&gt;PrivateMLet&lt;/code&gt; 를는&lt;/a&gt; 의 서브 클래스 &lt;code&gt;MLet&lt;/code&gt; 를 그 구현의 &lt;code&gt;PrivateClassLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7dbdf0d0215e39ffb9e056dc435071a7e3d1afd" translate="yes" xml:space="preserve">
          <source>If an ObjectName is not a pattern, it must contain at least one key with its associated value.</source>
          <target state="translated">ObjectName이 패턴이 아닌 경우 연관된 값을 가진 하나 이상의 키를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="58773dafdf455bae89181c8eface9c51e941a81b" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=rmi_guide&quot;&gt;Java RMI Guide&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">RMI 커넥터 클라이언트 또는 서버가 자신이 모르는 클래스의 인스턴스를 피어로부터 수신하고 RMI 연결에 대해 동적 코드 다운로드가 활성화 된 경우 피어가 지정한 코드베이스에서 클래스를 다운로드 할 수 있습니다. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=rmi_guide&quot;&gt;Java RMI 가이드에서는 이에&lt;/a&gt; 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0bc3775989ff9a0fa2129381bf0e75ba0c93374" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. The article &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Dynamic code downloading using Java RMI&lt;/em&gt;&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">RMI 커넥터 클라이언트 또는 서버가 자신의 피어에서 알 수없는 클래스의 인스턴스를 수신하고 RMI 연결에 대해 동적 코드 다운로드가 활성화 된 경우 피어가 지정한 코드베이스에서 클래스를 다운로드 할 수 있습니다. &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Java RMI를 사용한 동적 코드 다운로드&lt;/em&gt;&lt;/a&gt; 기사&lt;em&gt;&lt;/em&gt; 에서이를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="08988225aef79e54029028850710dc91fcab9d17" translate="yes" xml:space="preserve">
          <source>If an action has already been registered for the receiving container, with the same charCode and the same modifiers, &lt;code&gt;anAction&lt;/code&gt; will replace the action.</source>
          <target state="translated">동일한 charCode 및 동일한 수정자를 사용하여 수신 컨테이너에 대한 조치가 이미 등록 된 경우 &lt;code&gt;anAction&lt;/code&gt; 이 조치를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ac4ee4e3be7f792562359278f4f57ab7faea7f57" translate="yes" xml:space="preserve">
          <source>If an alpha sample is present, it corresponds the last index.</source>
          <target state="translated">알파 샘플이있는 경우 마지막 인덱스에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9c4c5268bcffbf9c0c5b98ecb4ed28911043818e" translate="yes" xml:space="preserve">
          <source>If an annotation of type</source>
          <target state="translated">유형이 주석 인 경우</target>
        </trans-unit>
        <trans-unit id="9df83510632408ed0d5232c4209c863ed75fc2b2" translate="yes" xml:space="preserve">
          <source>If an annotation returned by a method in this interface contains (directly or indirectly) a &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;-valued member referring to a class that is not accessible in this VM, attempting to read the class by calling the relevant Class-returning method on the returned annotation will result in a &lt;a href=&quot;../typenotpresentexception&quot;&gt;&lt;code&gt;TypeNotPresentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스의 메소드에 의해 리턴 된 주석 이이 VM에서 액세스 할 수없는 클래스를 참조 하는 &lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 값 멤버를 (직접 또는 간접적으로) 포함하는 경우, 리턴 된 주석 에서 관련 클래스 리턴 메소드를 호출하여 클래스를 읽으려고합니다. &lt;a href=&quot;../typenotpresentexception&quot;&gt; &lt;code&gt;TypeNotPresentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0227ca62999d931b56d6f6658a6e345f41f26f21" translate="yes" xml:space="preserve">
          <source>If an annotation type</source>
          <target state="translated">주석 유형 인 경우</target>
        </trans-unit>
        <trans-unit id="ed99bca3e6f592b88e87557055d253e0c0b22f1a" translate="yes" xml:space="preserve">
          <source>If an application caches method handles for broad sharing, it should use &lt;code&gt;publicLookup()&lt;/code&gt; to create them. If there is a lookup of &lt;code&gt;Class.forName&lt;/code&gt;, it will fail, and the application must take appropriate action in that case. It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible.</source>
          <target state="translated">응용 프로그램이 광범위한 공유를 위해 메서드 핸들을 캐시하는 경우 &lt;code&gt;publicLookup()&lt;/code&gt; 을 사용하여 만들어야합니다. 조회가있는 경우 &lt;code&gt;Class.forName&lt;/code&gt; 실패하고 애플리케이션은 적절한 조치를 취해야합니다. 아마도 부트 스트랩 메서드를 호출하는 동안 나중에 조회하면 호출자의 특정 ID를 통합하여 메서드에 액세스 할 수있게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517b0d95c98c17f7230f34f43d8c177b399282df" translate="yes" xml:space="preserve">
          <source>If an application does &lt;em&gt;not&lt;/em&gt; register its own custom &lt;code&gt;ErrorListener&lt;/code&gt;, the default &lt;code&gt;ErrorListener&lt;/code&gt; is used which reports all warnings and errors to &lt;code&gt;System.err&lt;/code&gt; and does not throw any &lt;code&gt;Exception&lt;/code&gt;s. Applications are &lt;em&gt;strongly&lt;/em&gt; encouraged to register and use &lt;code&gt;ErrorListener&lt;/code&gt;s that insure proper behavior for warnings and errors.</source>
          <target state="translated">응용 프로그램이 자체 사용자 정의 &lt;code&gt;ErrorListener&lt;/code&gt; 를 등록 하지 &lt;em&gt;않으면&lt;/em&gt; 모든 경고 및 오류를 &lt;code&gt;System.err&lt;/code&gt; 에보 고하고 &lt;code&gt;Exception&lt;/code&gt; 을 발생 시키지 않는 기본 &lt;code&gt;ErrorListener&lt;/code&gt; 가 사용됩니다 . 응용 프로그램은 경고 및 오류에 대한 적절한 동작을 보장 하는 &lt;code&gt;ErrorListener&lt;/code&gt; 를 등록하고 사용 &lt;em&gt;하는&lt;/em&gt; 것이 좋습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dbacd8fdd96aa697bee57950998d0a96108abc1" translate="yes" xml:space="preserve">
          <source>If an application or a system is internationalized and provides localized resources for multiple locales, it sometimes needs to find one or more locales (or language tags) which meet each user's specific preferences. Note that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this locale matching documentation.</source>
          <target state="translated">응용 프로그램 또는 시스템이 국제화되어 있고 여러 로캘에 대한 지역화 된 리소스를 제공하는 경우 각 사용자의 특정 기본 설정을 충족하는 하나 이상의 로캘 (또는 언어 태그)을 찾아야하는 경우가 있습니다. 이 로케일 일치 문서에서 &quot;언어 태그&quot;라는 용어는 &quot;로케일&quot;과 상호 교환 적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="95627f13c311b8727d628cb2f5a559e1e571b551" translate="yes" xml:space="preserve">
          <source>If an application wants to perform some action based on a button being pressed and released, it should implement &lt;code&gt;ActionListener&lt;/code&gt; and register the new listener to receive events from this button, by calling the button's &lt;code&gt;addActionListener&lt;/code&gt; method. The application can make use of the button's action command as a messaging protocol.</source>
          <target state="translated">애플리케이션이 버튼을 눌렀다 놓는 것에 따라 어떤 작업을 수행 하려면 버튼의 &lt;code&gt;addActionListener&lt;/code&gt; 메서드를 호출하여 &lt;code&gt;ActionListener&lt;/code&gt; 를 구현 하고이 버튼에서 이벤트를 수신 할 새 리스너를 등록 해야합니다 . 응용 프로그램은 단추의 작업 명령을 메시징 프로토콜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2dd9b01f32a7dbe5dfc9a2ba9f8a990861694b9" translate="yes" xml:space="preserve">
          <source>If an application wants to perform some action based on an item in this list being selected or activated by the user, it should implement &lt;code&gt;ItemListener&lt;/code&gt; or &lt;code&gt;ActionListener&lt;/code&gt; as appropriate and register the new listener to receive events from this list.</source>
          <target state="translated">응용 프로그램이이 목록의 항목이 사용자에 의해 선택되거나 활성화되는 것을 기반으로 일부 작업을 수행하려면 &lt;code&gt;ItemListener&lt;/code&gt; 또는 &lt;code&gt;ActionListener&lt;/code&gt; 를 적절하게 구현 하고이 목록에서 이벤트를 수신 할 새 리스너를 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c765f1f20083db8a0a74030169afc641514a1ce" translate="yes" xml:space="preserve">
          <source>If an application wants to set the ErrorHandler or EntityResolver for an XMLReader used during a transformation, it should use a URIResolver to return the SAXSource which provides (with getXMLReader) a reference to the XMLReader.</source>
          <target state="translated">애플리케이션이 변환 중에 사용되는 XMLReader에 대해 ErrorHandler 또는 EntityResolver를 설정하려면 URIResolver를 사용하여 XMLReader에 대한 참조를 제공하는 SAXSource를 반환해야합니다 (getXMLReader 포함).</target>
        </trans-unit>
        <trans-unit id="f6d7860179acd56276c79c3590549cb4c6e64204" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the corresponding new format is used for all such format elements. If an argument index is not used for any format element in the pattern string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the formats for argument indices less than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</source>
          <target state="translated">패턴 문자열에서 둘 이상의 형식 요소에 인수 색인이 사용되면 해당하는 모든 형식 요소에 해당하는 새 형식이 사용됩니다. 패턴 문자열의 형식 요소에 인수 색인이 사용되지 않으면 해당하는 새 형식이 무시됩니다. 필요한 것보다 적은 형식이 제공되는 경우 인수 색인의 형식 만 &lt;code&gt;newFormats.length&lt;/code&gt; 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="1f72387046823cf7698e1a0b6d176b89054ec4a7" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the format used for the last such format element is returned in the array. If an argument index is not used for any format element in the pattern string, then null is returned in the array.</source>
          <target state="translated">패턴 문자열에서 둘 이상의 형식 요소에 인수 색인이 사용되면 마지막 형식 요소에 사용 된 형식이 배열에 리턴됩니다. 패턴 문자열의 형식 요소에 인수 색인이 사용되지 않으면 배열에서 널이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="60e1dcd8583415c6d79ee79aff279d16dea818d7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere.</source>
          <target state="translated">이미 다른 곳에서 사용중인 속성을 추가하려는 경우.</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">네임 스페이스와 관련하여 잘못된 방식으로 객체를 만들거나 변경하려는 경우</target>
        </trans-unit>
        <trans-unit id="24724cffc57a37c811ffa42d73d239354e6db8a1" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed.</source>
          <target state="translated">수정이 허용되지 않는 개체를 수정하려는 경우.</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">기본 개체의 유형을 수정하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="2a0bd5db21e0237af0e5f242375953f6a02b04f7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a &lt;code&gt;Node&lt;/code&gt; in a context where it does not exist.</source>
          <target state="translated">존재하지 않는 컨텍스트에서 &lt;code&gt;Node&lt;/code&gt; 를 참조하려는 경우 .</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">사용할 수 없거나 더 이상 사용할 수없는 객체를 사용하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="a897beabf4b5ef8fb695d39602ed612135397241" translate="yes" xml:space="preserve">
          <source>If an attempt was made to load a document, or an XML Fragment, using &lt;code&gt;LSParser&lt;/code&gt; and the processing has been stopped.</source>
          <target state="translated">&lt;code&gt;LSParser&lt;/code&gt; 를 사용하여 문서 또는 XML 단편을로드하려고 시도 하고 처리가 중지 된 경우.</target>
        </trans-unit>
        <trans-unit id="e5cccc7a6e78ca84d0519ccae83f8865c3f31cba" translate="yes" xml:space="preserve">
          <source>If an attempt was made to serialize a &lt;code&gt;Node&lt;/code&gt; using &lt;code&gt;LSSerializer&lt;/code&gt; and the processing has been stopped.</source>
          <target state="translated">&lt;code&gt;LSSerializer&lt;/code&gt; 를 사용하여 &lt;code&gt;Node&lt;/code&gt; 직렬화를 시도 하고 처리가 중지 된 경우.</target>
        </trans-unit>
        <trans-unit id="bd454c7aa8c21821eb903a4d4d4438d54e9d0c75" translate="yes" xml:space="preserve">
          <source>If an attribute class extends &lt;code&gt;EnumSyntax&lt;/code&gt;, and the value of the attribute is an IPP-compatible value, the attribute's &lt;code&gt;toString&lt;/code&gt; method returns the IPP string representation of the attribute value, such as &quot;processing-stopped&quot; for the &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; attribute. However, because the &lt;code&gt;EnumSyntax&lt;/code&gt; class is extensible, vendors can define their own attribute values. If an attribute uses the &lt;code&gt;EnumSyntax&lt;/code&gt; class and is set to one of these vendor-defined values then the &lt;code&gt;toString&lt;/code&gt; method will not return the IPP string representation of the value.</source>
          <target state="translated">속성 클래스가 &lt;code&gt;EnumSyntax&lt;/code&gt; 를 확장 하고 속성 값이 IPP 호환 값인 경우 속성의 &lt;code&gt;toString&lt;/code&gt; 메소드는 &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; 속성에 대한 &quot;processing-stopped&quot;와 같은 속성 값의 IPP 문자열 표시를 리턴 합니다. 그러나 &lt;code&gt;EnumSyntax&lt;/code&gt; 클래스는 확장 가능 하므로 공급 업체가 고유 한 속성 값을 정의 할 수 있습니다. 속성이 &lt;code&gt;EnumSyntax&lt;/code&gt; 클래스를 사용하고 이러한 공급 업체 정의 값 중 하나로 설정된 경우 &lt;code&gt;toString&lt;/code&gt; 메소드는 의 IPP 문자열 표시를 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4623c2eee5d41a35f73f5f405c0c8600ff819521" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as &lt;code&gt;PrintRequestAttribute&lt;/code&gt;, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">속성이 &lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;PrintRequestAttribute&lt;/code&gt; 를 구현하는 경우 클라이언트는 해당 문서에만 속하는 작업 설정을 지정하기 위해 &lt;code&gt;Doc&lt;/code&gt; 속성 집합에 속성을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2271d961817d69ed166f3999b4fca55a2a3bfd1" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as PrintRequestAttribute, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;}'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">속성이 &lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt; 및 PrintRequestAttribute를 구현하는 경우 클라이언트는 속성을 &lt;code&gt;Doc&lt;/code&gt; 해당 문서에만 관련된 작업 설정을 지정하기 위해 Doc 의 속성 세트에 .</target>
        </trans-unit>
        <trans-unit id="8553a6030a41f0e392620a86588d848a2d5646af" translate="yes" xml:space="preserve">
          <source>If an attribute of the given name already exists then its value is replaced. If the attribute does not exist then it is created. If it implementation specific if a test to check for the existence of the attribute and the creation of attribute are atomic with respect to other file system activities.</source>
          <target state="translated">주어진 이름의 속성이 이미 존재하면 그 값이 대체됩니다. 속성이 존재하지 않으면 작성됩니다. 속성의 존재와 속성의 생성을 검사하는 테스트가 다른 파일 시스템 활동과 관련하여 원자적인 경우 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="27440a763ede5ab8ba752691c8d7cfa12b2cc574" translate="yes" xml:space="preserve">
          <source>If an authority is given then the string &lt;code&gt;&quot;//&quot;&lt;/code&gt; is appended, followed by the authority. If the authority contains a literal IPv6 address then the address must be enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;). Any character not in the</source>
          <target state="translated">권한이 주어지면 문자열 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 이 추가되고 그 뒤에 권한이옵니다. 기관에 리터럴 IPv6 주소가 포함 된 경우 주소는 대괄호로 묶어야합니다 ( &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; ) . 에없는 모든 문자</target>
        </trans-unit>
        <trans-unit id="6b54c42030a2b2622209db57c79949e15fb60f06" translate="yes" xml:space="preserve">
          <source>If an child element is insert into a parent element, the parent element should report a change. If the child element also had elements inserted into it (grandchildren to the parent) these elements need not report change.</source>
          <target state="translated">하위 요소가 상위 요소에 삽입되는 경우 상위 요소는 변경 사항을보고해야합니다. 자식 요소에도 요소가 삽입 된 경우 (부모의 손자) 이러한 요소는 변경을보고 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="30c03b38fd51437f34d169d8c1845e0f976cba81" translate="yes" xml:space="preserve">
          <source>If an element &lt;code&gt;e&lt;/code&gt; is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of &lt;code&gt;Arrays.toString(e)&lt;/code&gt;. If an element &lt;code&gt;e&lt;/code&gt; is an array of a reference type, it is converted to a string as by invoking this method recursively.</source>
          <target state="translated">요소 &lt;code&gt;e&lt;/code&gt; 가 프리미티브 유형의 배열 인 경우, 적절한 &lt;code&gt;Arrays.toString(e)&lt;/code&gt; 오버로드를 호출하여 문자열로 변환됩니다 . 요소 &lt;code&gt;e&lt;/code&gt; 가 참조 유형의 배열 인 경우,이 메소드를 재귀 적으로 호출하여 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7fadd0956f2848503358e60b1e94c3a6c5020fa1" translate="yes" xml:space="preserve">
          <source>If an element is a path to a directory of modules then each entry in the directory is a packaged module or the top-level directory of an exploded module. It is an error if a directory contains more than one module with the same name. If an element is a path to a directory, and that directory contains a file named &lt;code&gt;module-info.class&lt;/code&gt;, then the directory is treated as an exploded module rather than a directory of modules.</source>
          <target state="translated">요소가 모듈 디렉토리의 경로 인 경우 디렉토리의 각 항목은 패키지 모듈이거나 분해 된 모듈의 최상위 디렉토리입니다. 디렉토리에 동일한 이름의 모듈이 둘 이상 포함되어 있으면 오류입니다. 요소가 디렉토리 경로이고 해당 디렉토리에 &lt;code&gt;module-info.class&lt;/code&gt; 라는 파일이 포함되어 있으면 해당 디렉토리는 모듈 디렉토리가 아닌 확장 된 모듈로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4c8b1aa9c76b0a6c06cd6d1249058d6819f7727d" translate="yes" xml:space="preserve">
          <source>If an element or attribute name has a prefix, but is not bound to any namespace URI, then the prefix will be removed during serialization.</source>
          <target state="translated">요소 또는 속성 이름에 접두사가 있지만 네임 스페이스 URI에 바인딩되지 않은 경우 접두사는 직렬화 중에 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9604ec88c64afb1d9f67cf4516415fedcdca634f" translate="yes" xml:space="preserve">
          <source>If an element or attribute name is bound to a prefix and there is a namespace declaration that binds that prefix to a different URI then that namespace declaration is either removed if the correct mapping is inherited from the parent context of that element, or changed to the namespace URI of the element or attribute using that prefix.</source>
          <target state="translated">요소 또는 속성 이름이 접두사에 바인딩되어 있고 해당 접두사를 다른 URI에 바인딩하는 네임 스페이스 선언이있는 경우 해당 요소의 부모 컨텍스트에서 올바른 매핑이 상속되면 해당 네임 스페이스 선언이 제거되거나 해당 접두사를 사용하는 요소 또는 속성의 네임 스페이스 URI입니다.</target>
        </trans-unit>
        <trans-unit id="c29918c5773fbdbf37d6f7f698f089f0789ff358" translate="yes" xml:space="preserve">
          <source>If an element or attribute name uses a prefix that is bound to a different URI than that inherited from the namespace context of the parent of that element and there is no namespace declaration in the context of the current element then such a namespace declaration is added.</source>
          <target state="translated">요소 또는 특성 이름이 해당 요소의 부모의 네임 스페이스 컨텍스트에서 상속 된 것과 다른 URI에 바인딩 된 접두사를 사용하고 현재 요소의 컨텍스트에 네임 스페이스 선언이없는 경우 이러한 네임 스페이스 선언이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="261e54ff065700a24467a3b37a05bc35f1bc1e0e" translate="yes" xml:space="preserve">
          <source>If an entry already exists for the specified alias, it is overridden.</source>
          <target state="translated">지정된 별명에 대한 항목이 이미 있으면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9f14cb55aec7f7c0b7e951ed92525cdc983689" translate="yes" xml:space="preserve">
          <source>If an error occurs during the initial handshake, this method returns an invalid session object which reports an invalid cipher suite of &quot;SSL_NULL_WITH_NULL_NULL&quot;.</source>
          <target state="translated">초기 핸드 셰이크 중에 오류가 발생하면이 메소드는 유효하지 않은 세션 스위트 &quot;SSL_NULL_WITH_NULL_NULL&quot;을보고하는 유효하지 않은 세션 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff4bf02a9e9b23d87b04df576e60bab4d6f37a68" translate="yes" xml:space="preserve">
          <source>If an error occurs in setting any of the client info properties, a &lt;code&gt;SQLClientInfoException&lt;/code&gt; is thrown. The &lt;code&gt;SQLClientInfoException&lt;/code&gt; contains information indicating which client info properties were not set. The state of the client information is unknown because some databases do not allow multiple client info properties to be set atomically. For those databases, one or more properties may have been set before the error occurred.</source>
          <target state="translated">클라이언트 정보 속성을 설정할 때 오류가 발생하면 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 이 throw됩니다. &lt;code&gt;SQLClientInfoException&lt;/code&gt; 에는,이 클라이언트 정보 속성이 설정되지 않은 있는지를 나타내는 정보가 포함되어 있습니다. 일부 데이터베이스에서는 여러 클라이언트 정보 속성을 원자 적으로 설정할 수 없기 때문에 클라이언트 정보의 상태를 알 수 없습니다. 이러한 데이터베이스의 경우 오류가 발생하기 전에 하나 이상의 속성이 설정되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1773b2b10f572a15df1a83f51dfc4260cdf90a56" translate="yes" xml:space="preserve">
          <source>If an error occurs then the SSL socket is closed and an IOException is thrown. The underlying connection remains intact.</source>
          <target state="translated">오류가 발생하면 SSL 소켓이 닫히고 IOException이 발생합니다. 기본 연결은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0571b6ce6440517f906763cbff3a06c35743d89b" translate="yes" xml:space="preserve">
          <source>If an error occurs while parsing, the caller is notified through the &lt;code&gt;ErrorHandler&lt;/code&gt; instance associated with the &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter of the &lt;code&gt;DOMConfiguration&lt;/code&gt;.</source>
          <target state="translated">구문 분석 중에 오류가 발생하면 호출자에게 &lt;code&gt;DOMConfiguration&lt;/code&gt; 의 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt; &quot;매개 변수 와 연관된 &lt;code&gt;ErrorHandler&lt;/code&gt; 인스턴스를 통해 알림을 받습니다.</target>
        </trans-unit>
        <trans-unit id="6560375df8c26d01983629f3966222dadc471a6f" translate="yes" xml:space="preserve">
          <source>If an event is cancelable, the &lt;code&gt;preventDefault&lt;/code&gt; method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur.</source>
          <target state="translated">이벤트가 취소 할 수있는 경우 &lt;code&gt;preventDefault&lt;/code&gt; 방법은 이벤트가 일반적으로 발생하지 않는 이벤트의 결과로 구현 취한 기본 동작을 의미 취소되어야 함을 의미하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="61a7893cf4ef57d2ac863b712446f1ad303120a8" translate="yes" xml:space="preserve">
          <source>If an event is cancelable, the &lt;code&gt;preventDefault&lt;/code&gt; method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur. If, during any stage of event flow, the &lt;code&gt;preventDefault&lt;/code&gt; method is called the event is canceled. Any default action associated with the event will not occur. Calling this method for a non-cancelable event has no effect. Once &lt;code&gt;preventDefault&lt;/code&gt; has been called it will remain in effect throughout the remainder of the event's propagation. This method may be used during any stage of event flow.</source>
          <target state="translated">이벤트가 취소 할 수있는 경우 &lt;code&gt;preventDefault&lt;/code&gt; 방법은 이벤트가 일반적으로 발생하지 않는 이벤트의 결과로 구현 취한 기본 동작을 의미 취소되어야 함을 의미하는 데 사용됩니다. 이벤트 흐름 단계에서 &lt;code&gt;preventDefault&lt;/code&gt; 메서드가 호출되면 이벤트가 취소됩니다. 이벤트와 관련된 기본 동작은 발생하지 않습니다. 취소 할 수없는 이벤트에 대해이 메서드를 호출해도 효과가 없습니다. &lt;code&gt;preventDefault&lt;/code&gt; 가 호출 되면 이벤트 전파의 나머지 기간 동안 계속 유효합니다. 이 방법은 이벤트 흐름의 모든 단계에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50c4239d3f5ba08fc26d40f5cf9ea945de22195" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by &lt;code&gt;RemoteRef.invoke&lt;/code&gt; and that exception is a checked exception that is not assignable to any exception in the &lt;code&gt;throws&lt;/code&gt; clause of the method implemented by the &lt;code&gt;proxy&lt;/code&gt;'s class, then that exception is wrapped in an &lt;a href=&quot;../unexpectedexception&quot;&gt;&lt;code&gt;UnexpectedException&lt;/code&gt;&lt;/a&gt; and the wrapped exception is thrown. Otherwise, the exception thrown by &lt;code&gt;invoke&lt;/code&gt; is thrown by this method.</source>
          <target state="translated">&lt;code&gt;RemoteRef.invoke&lt;/code&gt; 에 의해 예외가 발생 하고 해당 예외가 &lt;code&gt;proxy&lt;/code&gt; 클래스에 의해 구현 된 메서드 의 &lt;code&gt;throws&lt;/code&gt; 절 에서 예외에 할당 할 수없는 검사 된 예외 인 경우 해당 예외는 &lt;a href=&quot;../unexpectedexception&quot;&gt; &lt;code&gt;UnexpectedException&lt;/code&gt; &lt;/a&gt; 및 래핑 된 예외로 래핑됩니다. 던져집니다. 그렇지 않으면 &lt;code&gt;invoke&lt;/code&gt; 에 의해 발생 된 예외 가이 메소드에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0469e2eb38e10c985523abc8d2b5541786c72d7d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during an enumeration, the enumeration becomes invalid. Subsequent invocation of any method on that enumeration will yield undefined results.</source>
          <target state="translated">열거 중에 예외가 발생하면 열거가 유효하지 않게됩니다. 해당 열거에서 메소드를 계속 호출하면 정의되지 않은 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b9719db0ece122f09c48cc72299d47645e3e63" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from this method, it is considered to be equivalent of returning &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 메서드에서 예외가 발생하면 &lt;code&gt;true&lt;/code&gt; 를 반환하는 것과 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="baf28062714220f5e512946ca5d9f8fcc778ea9f" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from this method, resulting behavior is undefined.</source>
          <target state="translated">이 메서드에서 예외가 발생하면 결과 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4edf72f63744ff4e52753a8efa7493d7a0576ed0" translate="yes" xml:space="preserve">
          <source>If an exception type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">예외 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 예외 유형이 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="383733cb23b40d1a57028c685e2f09b242e4957b" translate="yes" xml:space="preserve">
          <source>If an exception, &lt;code&gt;E&lt;/code&gt; say, occurs during execution of the bootstrap method, then resolution fails and terminates abnormally. &lt;code&gt;E&lt;/code&gt; is rethrown if the type of &lt;code&gt;E&lt;/code&gt; is &lt;code&gt;Error&lt;/code&gt; or a subclass, otherwise a &lt;code&gt;BootstrapMethodError&lt;/code&gt; that wraps &lt;code&gt;E&lt;/code&gt; is thrown. If this happens, the same error will be thrown for all subsequent attempts to execute the &lt;code&gt;invokedynamic&lt;/code&gt; instruction or load the dynamically-computed constant.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 는 부트 스트랩 메소드 실행 중에 예외 가 발생하면 해결이 실패하고 비정상적으로 종료됩니다. &lt;code&gt;E&lt;/code&gt; 는 유형 경우 던져 준다 &lt;code&gt;E&lt;/code&gt; 가 인 &lt;code&gt;Error&lt;/code&gt; 또는 서브 클래스는 달리, &lt;code&gt;BootstrapMethodError&lt;/code&gt; 랩 &lt;code&gt;E&lt;/code&gt; 가 발생합니다. 이 경우 &lt;code&gt;invokedynamic&lt;/code&gt; 명령어 를 실행 하거나 동적으로 계산 된 상수를로드 하려는 모든 후속 시도에 대해 동일한 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="daaa77166dccaba4fc56b68f0c67338ce9025815" translate="yes" xml:space="preserve">
          <source>If an existing &lt;code&gt;Processor&lt;/code&gt; object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</source>
          <target state="translated">기존 &lt;code&gt;Processor&lt;/code&gt; 개체를 사용하지 않는 경우 프로세서 인스턴스를 만들기 위해 도구는 프로세서 클래스의 인수 없음 생성자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e6c975a8f1f73672a8298c66b4c9a0fbbf3cedc1" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;a href=&quot;httpclient.builder#executor(java.util.concurrent.Executor)&quot;&gt;executor&lt;/a&gt; has not been set for an &lt;code&gt;HttpClient&lt;/code&gt;, and a security manager has been installed, then the default executor will execute asynchronous and dependent tasks in a context that is granted no permissions. Custom &lt;a href=&quot;httprequest.bodypublisher&quot;&gt;request body publishers&lt;/a&gt;, &lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;response body handlers&lt;/a&gt;, &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;response body subscribers&lt;/a&gt;, and &lt;a href=&quot;websocket.listener&quot;&gt;WebSocket Listeners&lt;/a&gt;, if executing operations that require privileges, should do so within an appropriate &lt;a href=&quot;../../../../java.base/java/security/accesscontroller#doPrivileged(java.security.PrivilegedAction)&quot;&gt;privileged context&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HttpClient&lt;/code&gt; 에 대해 명시 적 &lt;a href=&quot;httpclient.builder#executor(java.util.concurrent.Executor)&quot;&gt;실행기&lt;/a&gt; 가 설정되지 않았고 보안 관리자가 설치된 경우 기본 실행기는 권한이 부여되지 않은 컨텍스트에서 비동기 및 종속 작업을 실행합니다. 사용자 지정 &lt;a href=&quot;httprequest.bodypublisher&quot;&gt;요청 본문 게시자&lt;/a&gt; , &lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;응답 본문 처리기&lt;/a&gt; 권한이 필요한 작업을 실행하는 경우 , &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;응답 본문 구독자&lt;/a&gt; 및 &lt;a href=&quot;websocket.listener&quot;&gt;WebSocket Listeners&lt;/a&gt; 는 적절한 &lt;a href=&quot;../../../../java.base/java/security/accesscontroller#doPrivileged(java.security.PrivilegedAction)&quot;&gt;권한이있는 컨텍스트&lt;/a&gt; 내에서 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7d315c92816e5851e4dc9c39278030e06b4e20d6" translate="yes" xml:space="preserve">
          <source>If an implementation does not support schemas, it should throw OperationNotSupportedException. If an implementation does support schemas, it should define this method to return the appropriate information.</source>
          <target state="translated">구현이 스키마를 지원하지 않으면 OperationNotSupportedException을 발생시켜야합니다. 구현이 스키마를 지원하는 경우 적절한 정보를 리턴하도록이 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4c73fde229aaf78d628130cf2dc942c93b26494" translate="yes" xml:space="preserve">
          <source>If an implementation has not been specified with the system property, then the system-default implementation class is instantiated, and the result is returned.</source>
          <target state="translated">시스템 특성으로 구현을 지정하지 않은 경우 시스템 기본 구현 클래스가 인스턴스화되고 결과가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0790bd1055cd2781acb9f390ec8d77d9efcbd487" translate="yes" xml:space="preserve">
          <source>If an implementation of this method returns &lt;code&gt;false&lt;/code&gt;, then the KeyEvent is passed to the next KeyEventDispatcher in the chain, ending with the current KeyboardFocusManager. If an implementation returns &lt;code&gt;true&lt;/code&gt;, the KeyEvent is assumed to have been dispatched (although this need not be the case), and the current KeyboardFocusManager will take no further action with regard to the KeyEvent. In such a case, &lt;code&gt;KeyboardFocusManager.dispatchEvent&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt; as well. If an implementation consumes the KeyEvent, but returns &lt;code&gt;false&lt;/code&gt;, the consumed event will still be passed to the next KeyEventDispatcher in the chain. It is important for developers to check whether the KeyEvent has been consumed before dispatching it to a target. By default, the current KeyboardFocusManager will not dispatch a consumed KeyEvent.</source>
          <target state="translated">이 메서드의 구현이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 KeyEvent는 현재 KeyboardFocusManager로 끝나는 체인의 다음 KeyEventDispatcher로 전달됩니다. 구현이 반환되는 경우 &lt;code&gt;true&lt;/code&gt; 를 하면 KeyEvent가 전달 된 것으로 간주되며 (이럴 필요는 없음) 현재 KeyboardFocusManager는 KeyEvent와 관련하여 추가 작업을 수행하지 않습니다. 이 경우 &lt;code&gt;KeyboardFocusManager.dispatchEvent&lt;/code&gt; 도 &lt;code&gt;true&lt;/code&gt; 를 반환해야 합니다. 구현에서 KeyEvent를 사용하지만 &lt;code&gt;false&lt;/code&gt; 를 반환하는 경우, 소비 된 이벤트는 여전히 체인의 다음 KeyEventDispatcher로 전달됩니다. 개발자는 KeyEvent를 대상에 전달하기 전에 사용되었는지 여부를 확인하는 것이 중요합니다. 기본적으로 현재 KeyboardFocusManager는 소비 된 KeyEvent를 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e13652b1c7db8e5309427a9d44bc7e8f9963245a" translate="yes" xml:space="preserve">
          <source>If an implementation of this method returns &lt;code&gt;false&lt;/code&gt;, then the KeyEvent is passed to the next KeyEventPostProcessor in the chain, ending with the current KeyboardFocusManager. If an implementation returns &lt;code&gt;true&lt;/code&gt;, the KeyEvent is assumed to have been fully handled (although this need not be the case), and the AWT will take no further action with regard to the KeyEvent. If an implementation consumes the KeyEvent but returns &lt;code&gt;false&lt;/code&gt;, the consumed event will still be passed to the next KeyEventPostProcessor in the chain. It is important for developers to check whether the KeyEvent has been consumed before performing any post-processing of the KeyEvent. By default, the current KeyboardFocusManager will perform no post- processing in response to a consumed KeyEvent.</source>
          <target state="translated">이 메서드의 구현이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 KeyEvent는 현재 KeyboardFocusManager로 끝나는 체인의 다음 KeyEventPostProcessor로 전달됩니다. 구현이 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우 KeyEvent는 완전히 처리 된 것으로 간주되며 (이럴 필요는 없음) AWT는 KeyEvent와 관련하여 추가 조치를 취하지 않습니다. 구현에서 KeyEvent를 사용하지만 &lt;code&gt;false&lt;/code&gt; 를 반환 하는 경우 사용 된 이벤트는 체인의 다음 KeyEventPostProcessor로 계속 전달됩니다. 개발자는 KeyEvent의 사후 처리를 수행하기 전에 KeyEvent가 사용되었는지 확인하는 것이 중요합니다. 기본적으로 현재 KeyboardFocusManager는 소비 된 KeyEvent에 대한 응답으로 사후 처리를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f55248539ebf4b603fcbf731a4a482fec2765dd7" translate="yes" xml:space="preserve">
          <source>If an implementation performs any type of modification or &quot;normalization&quot; of a path, it should never move the coordinates by more than half a pixel in any direction.</source>
          <target state="translated">구현에서 경로의 수정 또는 &quot;정규화&quot;를 수행하는 경우 어떤 방향으로도 좌표를 반 픽셀 이상 이동해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="043b26dca2264b1abb0bfae84593fcda3d702603" translate="yes" xml:space="preserve">
          <source>If an implementation represents a field that can be simplified, or combined with others, then this method must be implemented.</source>
          <target state="translated">구현이 단순화되거나 다른 필드와 결합 될 수있는 필드를 나타내는 경우이 방법을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1d164fb2f90283981eb219956ff98c6a957bd3f" translate="yes" xml:space="preserve">
          <source>If an implementation supports a mechanism to start agents sometime after the VM has started then this attribute specifies the agent class. That is, the class containing the &lt;code&gt;agentmain&lt;/code&gt; method. This attribute is required if it is not present the agent will not be started. Note: this is a class name, not a file name or path.</source>
          <target state="translated">구현이 VM이 시작된 후 에이전트를 시작하는 메커니즘을 지원하는 경우이 속성은 에이전트 클래스를 지정합니다. 즉, &lt;code&gt;agentmain&lt;/code&gt; 이 포함 된 클래스 메서드가 입니다. 이 속성이 없으면 에이전트가 시작되지 않습니다. 참고 : 이것은 파일 이름이나 경로가 아닌 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c11093045a54063bd397d3d34918f97a76bef04b" translate="yes" xml:space="preserve">
          <source>If an implementation supports a mechanism to start an application as an executable JAR then the main manifest may include this attribute to specify the class name of an agent to start before the application &lt;code&gt;main&lt;/code&gt; method is invoked.</source>
          <target state="translated">구현이 애플리케이션을 실행 가능한 JAR로 시작하는 메커니즘을 지원하는 경우 기본 매니페스트에이 속성을 포함하여 애플리케이션 &lt;code&gt;main&lt;/code&gt; 이전에 시작할 에이전트의 클래스 이름을 지정할 수 있습니다. 메서드가 호출 .</target>
        </trans-unit>
        <trans-unit id="c89b3cdaab7f58f456c7aa47faa134eee7f364ef" translate="yes" xml:space="preserve">
          <source>If an init function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the clause's iteration variable type.</source>
          <target state="translated">init 함수가 생략 된 경우 &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;기본값을&lt;/a&gt; 사용하십시오. 경우 절의 반복 변수 유형에 .</target>
        </trans-unit>
        <trans-unit id="3462188196e65e0014ae45d5a7fe6a01be0280ee" translate="yes" xml:space="preserve">
          <source>If an input method provides its own windows, it should make sure at this point that all necessary windows are open and visible.</source>
          <target state="translated">입력 방법이 자체 창을 제공하는 경우이 시점에서 필요한 모든 창이 열려 있고 표시되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf5c43ab6dc0cdfce9e73d966f2af0a3e27508c4" translate="yes" xml:space="preserve">
          <source>If an input method provides its own windows, only windows that relate to the current composition (such as a lookup choice window) should be closed at this point. It is possible that the input method will be immediately activated again for a different client component, and closing and reopening more persistent windows (such as a control panel) would create unnecessary screen flicker. Before an instance of a different input method class is activated, &lt;a href=&quot;#hideWindows()&quot;&gt;&lt;code&gt;hideWindows()&lt;/code&gt;&lt;/a&gt; is called on the current input method.</source>
          <target state="translated">입력 방법이 자체 창을 제공하는 경우 현재 컴포지션과 관련된 창 (예 : 조회 선택 창) 만이 시점에서 닫아야합니다. 다른 클라이언트 구성 요소에 대해 입력 방법이 즉시 다시 활성화 될 수 있으며 더 영구적 인 창 (예 : 제어판)을 닫았다가 다시 열면 불필요한 화면 깜박임이 발생할 수 있습니다. 다른 입력 메서드 클래스의 인스턴스가 활성화되기 전에 현재 입력 메서드에서 &lt;a href=&quot;#hideWindows()&quot;&gt; &lt;code&gt;hideWindows()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0b10ca0277b7493d6ebe1c11b70f79c82379ba" translate="yes" xml:space="preserve">
          <source>If an input stream is open for the current row, a call to the method &lt;code&gt;next&lt;/code&gt; will implicitly close it. A &lt;code&gt;ResultSet&lt;/code&gt; object's warning chain is cleared when a new row is read.</source>
          <target state="translated">현재 행에 대해 입력 스트림이 열려있는 경우 &lt;code&gt;next&lt;/code&gt; 메서드를 호출 하면 암시 적 으로 해당 행 이 닫힙니다. &lt;code&gt;ResultSet&lt;/code&gt; 새로운 행이 읽힐 때, 오브젝트의 경고 체인은 클리어됩니다.</target>
        </trans-unit>
        <trans-unit id="582a161abac221d4fa47ae48f7051334a4e87df5" translate="yes" xml:space="preserve">
          <source>If an input stream is open for the current row, a call to the method &lt;code&gt;previous&lt;/code&gt; will implicitly close it. A &lt;code&gt;ResultSet&lt;/code&gt; object's warning change is cleared when a new row is read.</source>
          <target state="translated">현재 행에 대해 입력 스트림이 열려있는 경우 &lt;code&gt;previous&lt;/code&gt; 메서드를 호출 하면 암시 적으로 닫힙니다. &lt;code&gt;ResultSet&lt;/code&gt; 새로운 행이 읽힐 때, 객체의 경고 변경은 지워집니다.</target>
        </trans-unit>
        <trans-unit id="f303c1f0d6c8117bfe8230a427e47b48a68363b7" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal character is specified, such as in an XML name.</source>
          <target state="translated">XML 이름과 같이 유효하지 않거나 잘못된 문자가 지정된 경우.</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">유효하지 않거나 잘못된 문자열이 지정된 경우</target>
        </trans-unit>
        <trans-unit id="3b30c559fc9c71304701a7f40146dfcf10b6d44b" translate="yes" xml:space="preserve">
          <source>If an object factory builder has been installed, it is used to create a factory for creating the object. Otherwise, the following rules are used to create the object:</source>
          <target state="translated">오브젝트 팩토리 빌더가 설치된 경우 오브젝트 작성을위한 팩토리를 작성하는 데 사용됩니다. 그렇지 않으면 다음 규칙을 사용하여 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4831201808691533c49676c4c6acf9ec77b746a0" translate="yes" xml:space="preserve">
          <source>If an operation that calculates the bounding box of this &lt;code&gt;Polygon&lt;/code&gt; has already been performed, such as &lt;code&gt;getBounds&lt;/code&gt; or &lt;code&gt;contains&lt;/code&gt;, then this method updates the bounding box.</source>
          <target state="translated">이 &lt;code&gt;Polygon&lt;/code&gt; 의 경계 상자를 계산하는 작업 ( 예 : &lt;code&gt;getBounds&lt;/code&gt; 또는 &lt;code&gt;contains&lt;/code&gt; ) 이 이미 수행 된 경우이 메서드는 경계 상자를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="8baf09fa7c9f197ad74c665fba2d5cc5c6506ab1" translate="yes" xml:space="preserve">
          <source>If an optional &lt;code&gt;AffineTransform&lt;/code&gt; is specified, the coordinates returned in the iteration are transformed accordingly.</source>
          <target state="translated">선택적 &lt;code&gt;AffineTransform&lt;/code&gt; 이 지정되면 반복에서 반환 된 좌표가 그에 따라 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2b3be881430739dc065ccc4b9432e347d8bc309f" translate="yes" xml:space="preserve">
          <source>If an override is added, then any date that is formatted or parsed will be affected.</source>
          <target state="translated">재정의가 추가되면 형식이 지정되거나 구문 분석 된 날짜가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="255c469340eb5e4421672d0f2a54c086d1b3a334" translate="yes" xml:space="preserve">
          <source>If an override is added, then any instant that is formatted or parsed will be affected.</source>
          <target state="translated">재정의가 추가되면 형식이 지정되거나 구문 분석 된 모든 인스턴트가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="0fbebb5dc8d306792468bfb85d5fadc68fc9bcac" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the method returns the raw offset value of the current date. In Honolulu, for example, its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and this method always returns -36000000 milliseconds (i.e., -10 hours).</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 히스토리 GMT 오프셋 변경을 지원 , 메소드는 현재 날짜의 원시 오프셋 값을 리턴합니다. 예를 들어, 호놀룰루에서는 1947 년에 원시 오프셋이 GMT-10 : 30에서 GMT-10 : 00으로 변경되었으며이 방법은 항상 -36000000 밀리 초 (예 : -10 시간)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a926ad586a71b3f84679e24d71e358a0ff83b65" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the specified GMT offset is set as the latest GMT offset and the difference from the known latest GMT offset value is used to adjust all historical GMT offset values.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 히스토리 GMT 오프셋 변경을 지원하는 경우 지정된 GMT 오프셋이 최신 GMT 오프셋으로 설정되고 알려진 최신 GMT 오프셋 값과의 차이가 모든 히스토리 GMT 오프셋 값을 조정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ceaf11fd23c3b657da62f21ad506f54d009695c" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;#observesDaylightTime()&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 구현 하위 클래스가 과거 및 미래의 일광 절약 시간 일정 변경을 지원하는 경우이 메서드는 미래 예측 일 수 있으며 현재 규칙과 동일하지 않을 수있는 마지막으로 알려진 일광 절약 시간 규칙을 참조합니다. 현재 규칙도 고려해야하는 경우 &lt;a href=&quot;#observesDaylightTime()&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt; 호출을 고려 하세요.</target>
        </trans-unit>
        <trans-unit id="e0ae28c236839ff6f2827de1f4455a2f8e23e12d" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 구현 서브 클래스가 과거 및 미래 일광 절약 시간제 스케줄 변경을 지원 하는 경우 ,이 방법은 미래 예측 일 수 있고 현재 규칙과 동일하지 않을 수있는 마지막으로 알려진 일광 절약 시간제 규칙을 참조합니다. 현재 규칙도 고려해야하는 경우 &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt; 호출을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceae883a33c038a59aa9297cd34719c700a68dfa" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method returns the amount of saving time of the last known Daylight Saving Time rule that can be a future prediction.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 과거 및 미래 일광 절약 시간제 스케줄 변경을 지원 ,이 메소드는 미래 예측이 될 수있는 마지막으로 알려진 일광 절약 시간제 규칙의 절약 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cdd60a91ecf0c51d8f3876be3d469659d44d29f5" translate="yes" xml:space="preserve">
          <source>If an update between a disconnected &lt;code&gt;RowSet&lt;/code&gt; object and a data source violates the original query or the underlying data source constraints, this will result in undefined behavior for all disconnected &lt;code&gt;RowSet&lt;/code&gt; implementations and their designated &lt;code&gt;SyncProvider&lt;/code&gt; implementations. Not defining the behavior when such violations occur offers greater flexibility for a &lt;code&gt;SyncProvider&lt;/code&gt; implementation to determine its own best course of action.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체와 데이터 소스 간의 업데이트가 원래 쿼리 또는 기본 데이터 소스 제약 조건을 위반하는 경우 연결이 끊어진 모든 &lt;code&gt;RowSet&lt;/code&gt; 구현 및 지정된 &lt;code&gt;SyncProvider&lt;/code&gt; 구현에 대해 정의되지 않은 동작이 발생 합니다. 이러한 위반이 발생할 때 동작을 정의하지 않으면 &lt;code&gt;SyncProvider&lt;/code&gt; 구현이 자신의 최선의 작업 과정을 결정 하는 데 더 큰 유연성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e6cdcb6abb3fe6a57aabba3c4945a777923f2bd3" translate="yes" xml:space="preserve">
          <source>If another thread is already waiting at the exchange point then it is resumed for thread scheduling purposes and receives the object passed in by the current thread. The current thread returns immediately, receiving the object passed to the exchange by that other thread.</source>
          <target state="translated">다른 스레드가 교환 지점에서 이미 대기중인 경우 스레드 스케줄링을 위해 재개되고 현재 스레드가 전달한 오브젝트를 수신합니다. 현재 스레드는 다른 스레드가 교환으로 전달한 오브젝트를 수신하여 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="864c1c31a0758e674e7daf1e62b8414fbaaecf21" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in a selection operation then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of a selection operation will return immediately unless &lt;a href=&quot;#selectNow()&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#selectNow(java.util.function.Consumer)&quot;&gt;&lt;code&gt;selectNow(Consumer)&lt;/code&gt;&lt;/a&gt; is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent selection operations will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">현재 선택 작업에서 다른 스레드가 차단 된 경우 해당 호출은 즉시 반환됩니다. 현재 진행중인 선택 작업이없는 경우 &lt;a href=&quot;#selectNow()&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#selectNow(java.util.function.Consumer)&quot;&gt; &lt;code&gt;selectNow(Consumer)&lt;/code&gt; &lt;/a&gt; 아니면 다음 선택 작업 호출이 즉시 반환됩니다. 그 동안 가 호출 됩니다. 어떤 경우에도 해당 호출에서 반환 된 값은 0이 아닐 수 있습니다. 그동안이 메서드를 다시 호출하지 않으면 후속 선택 작업이 평소와 같이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="55a602e52f31c6fce149aff8e6c8a2bb72960c45" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in an invocation of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of one of these methods will return immediately unless the &lt;a href=&quot;selector#selectNow--&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; method is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent invocations of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">다른 스레드가 현재 &lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt; 메소드 호출에서 차단 된 경우 해당 호출이 즉시 리턴됩니다. 현재 진행중인 선택 작업이 없으면 그 동안 &lt;a href=&quot;selector#selectNow--&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하지 않으면 이러한 메서드 중 하나를 다음에 호출하면 즉시 반환 됩니다. 어쨌든 해당 호출에 의해 리턴되는 값은 0이 아닐 수 있습니다. &lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt; 의 후속 호출 메소드 이 메소드가 다시 호출되지 않는 한 평소와 같이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="24dce4584d013d177ede8c23a6bf0925338f6147" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes) is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will be thrown the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">모든 경우 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; (또는 파생 된 클래스의 인스턴스)를으로부터 슬로우 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 를&lt;/a&gt; 상기 호출자 &lt;code&gt;newSchema&lt;/code&gt; 있어서 동일한 발생한다 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; 를&lt;/a&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="91666a635abb2638c7825fa9ea881422a3247df9" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the caller of the &lt;code&gt;validate&lt;/code&gt; method will be thrown the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">어떤 경우 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; 를&lt;/a&gt; 에서 슬로우 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 를&lt;/a&gt; 상기 호출자의 &lt;code&gt;validate&lt;/code&gt; 방법은 동일한 발생한다 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="e6031198ebfde35221603864bd5de80044d9f210" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object will be thrown toward the root of the call stack.</source>
          <target state="translated">어떤 경우 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 에서 발생합니다 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 를&lt;/a&gt; , 동일 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 객체는 호출 스택의 루트를 향해 던져 질 것이다.</target>
        </trans-unit>
        <trans-unit id="ce3583ad9e889a8cf74d60ff219db12bf7e3d646" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Node&lt;/code&gt; is inserted somewhere it doesn't belong.</source>
          <target state="translated">어떤 경우 &lt;code&gt;Node&lt;/code&gt; 어딘가에 삽입이 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cec544a5e88401b63adc132ef371ce82ab888d7" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;PropertyChangeListeners&lt;/code&gt; have been registered, the &lt;code&gt;changeSupport&lt;/code&gt; field describes them.</source>
          <target state="translated">어떤 경우 &lt;code&gt;PropertyChangeListeners&lt;/code&gt; 등록되었습니다 &lt;code&gt;changeSupport&lt;/code&gt; 필드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6d4dcb2cdde65186e714c3856839d4722a4381c8" translate="yes" xml:space="preserve">
          <source>If any Subscriber method throws an exception, its subscription is cancelled. If a handler is supplied as a constructor argument, it is invoked before cancellation upon an exception in method &lt;a href=&quot;flow.subscriber#onNext(T)&quot;&gt;&lt;code&gt;onNext&lt;/code&gt;&lt;/a&gt;, but exceptions in methods &lt;a href=&quot;flow.subscriber#onSubscribe(java.util.concurrent.Flow.Subscription)&quot;&gt;&lt;code&gt;onSubscribe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;flow.subscriber#onError(java.lang.Throwable)&quot;&gt;&lt;code&gt;onError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;flow.subscriber#onComplete()&quot;&gt;&lt;code&gt;onComplete&lt;/code&gt;&lt;/a&gt; are not recorded or handled before cancellation. If the supplied Executor throws &lt;a href=&quot;rejectedexecutionexception&quot;&gt;&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/a&gt; (or any other RuntimeException or Error) when attempting to execute a task, or a drop handler throws an exception when processing a dropped item, then the exception is rethrown. In these cases, not all subscribers will have been issued the published item. It is usually good practice to &lt;a href=&quot;#closeExceptionally(java.lang.Throwable)&quot;&gt;&lt;code&gt;closeExceptionally&lt;/code&gt;&lt;/a&gt; in these cases.</source>
          <target state="translated">Subscriber 메서드가 예외를 throw하면 해당 구독이 취소됩니다. 핸들러가 생성자 인수로 제공되는 경우 &lt;a href=&quot;flow.subscriber#onNext(T)&quot;&gt; &lt;code&gt;onNext&lt;/code&gt; &lt;/a&gt; 메서드의 예외가 발생하면 취소되기 전에 호출 되지만 &lt;a href=&quot;flow.subscriber#onSubscribe(java.util.concurrent.Flow.Subscription)&quot;&gt; &lt;code&gt;onSubscribe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;flow.subscriber#onError(java.lang.Throwable)&quot;&gt; &lt;code&gt;onError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;flow.subscriber#onComplete()&quot;&gt; &lt;code&gt;onComplete&lt;/code&gt; &lt;/a&gt; 메서드의 예외는 취소 전에 기록되거나 처리되지 않습니다. 제공된 Executor가 태스크 실행을 시도 할 때 &lt;a href=&quot;rejectedexecutionexception&quot;&gt; &lt;code&gt;RejectedExecutionException&lt;/code&gt; &lt;/a&gt; (또는 기타 RuntimeException 또는 오류)을 발생 시키거나 삭제 된 항목을 처리 할 때 삭제 핸들러가 예외를 발생 시키면 예외가 다시 발생합니다. 이 경우 모든 구독자에게 게시 된 항목이 발급되지는 않습니다. 이러한 경우에는 일반적으로 &lt;a href=&quot;#closeExceptionally(java.lang.Throwable)&quot;&gt; &lt;code&gt;closeExceptionally&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="21b5ebd6273984daf6721915e81fb9ec02d87b85" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="8b8c2ef8a9bb952f18badf3b5ecafae0a465fefa" translate="yes" xml:space="preserve">
          <source>If any attributes are unsupported only because they are in conflict with other attributes then it is at the discretion of the service to select the attribute(s) to be identified as the cause of the conflict.</source>
          <target state="translated">속성이 다른 속성과 충돌하여 지원되지 않는 속성 인 경우 서비스의 재량에 따라 충돌의 원인으로 식별 할 속성을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ebc8985caafe276614f95fc78ffd3e5249f1603" translate="yes" xml:space="preserve">
          <source>If any bits of a particular byte have never been set at the time the byte is flushed to the destination, those bits will be set to 0 automatically.</source>
          <target state="translated">바이트가 대상으로 플러시 될 때 특정 바이트의 비트가 설정되지 않은 경우 해당 비트는 자동으로 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="000b0cb48e2461281a9efe32d05592010817bcfd" translate="yes" xml:space="preserve">
          <source>If any element is a NaN, then the final sum will be NaN.</source>
          <target state="translated">요소가 NaN이면 최종 합계는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="7043446a887039defab2fc7d623983a8ed813ef6" translate="yes" xml:space="preserve">
          <source>If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.</source>
          <target state="translated">이 작업의 실행이 해당 기간보다 오래 걸리면 후속 실행이 늦게 시작될 수 있지만 동시에 실행되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="702be5b9ebfbe3a5f1d1aa77356733e4327d5c79" translate="yes" xml:space="preserve">
          <source>If any keys were added to the cancelled-key set while step (2) was in progress then they are processed as in step (1).</source>
          <target state="translated">단계 (2)가 진행되는 동안 취소 된 키 세트에 키가 추가되면 단계 (1)에서와 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="39449a473dc6d7f957e4a256a3a7386489d76cfc" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;
 lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">임의의 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 또는 &lt;code&gt;createTime&lt;/code&gt; 파라미터 값을 갖는 &lt;code&gt;null&lt;/code&gt; 그 대응하는 타임 스탬프는 변경되지 않는다. 구현시 타임 스탬프 속성 중 일부만 업데이트 할 때 파일 속성의 기존 값을 읽어야 할 수 있습니다. 따라서이 방법은 다른 파일 시스템 작업과 관련하여 원자 적 작업이 아닐 수 있습니다. 기존 값을 읽고 다시 쓰면 정밀도가 손실 될 수도 있습니다. 의 모든 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt; lastAccessTime&lt;/code&gt; 및 &lt;code&gt;createTime&lt;/code&gt; 매개 변수는 &lt;code&gt;null&lt;/code&gt; 이 메소드는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="51f61f6cbbe9d425e171c7d86f0b2ee40a25ba9f" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">임의의 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 또는 &lt;code&gt;createTime&lt;/code&gt; 파라미터 값을 갖는 &lt;code&gt;null&lt;/code&gt; 그 대응하는 타임 스탬프는 변경되지 않는다. 타임 스탬프 속성 중 일부만 업데이트 될 때 구현시 파일 속성의 기존 값을 읽어야 할 수도 있습니다. 결과적으로이 방법은 다른 파일 시스템 작업과 관련하여 원 자성 작업이 아닐 수 있습니다. 기존 값을 읽고 다시 쓰면 정밀도 손실이 발생할 수 있습니다. 의 모든 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 및 &lt;code&gt;createTime&lt;/code&gt; 매개 변수는 &lt;code&gt;null&lt;/code&gt; 이 메소드는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8c0135add7c8b60bb88502e1753b104e3e7777d" translate="yes" xml:space="preserve">
          <source>If any of the CA certificates contain the &lt;code&gt;BasicConstraintsExtension&lt;/code&gt;, the value of the &lt;code&gt;pathLenConstraint&lt;/code&gt; field of the extension overrides the maximum path length parameter whenever the result is a certification path of smaller length.</source>
          <target state="translated">CA 인증서 중 하나에 &lt;code&gt;BasicConstraintsExtension&lt;/code&gt; 이 포함 된 경우 확장 의 &lt;code&gt;pathLenConstraint&lt;/code&gt; 필드 값은 결과가 더 작은 길이의 인증 경로 일 때마다 최대 경로 길이 매개 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="2322580274e59c704b7ceb052b845f94fd2c310a" translate="yes" xml:space="preserve">
          <source>If any of the argument keys are not recognized and are not namespace qualified, the property will be ignored and not returned. In other words the behaviour is not orthogonal with &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수 키 중 하나라도 인식되지 않고 네임 스페이스가 한정되지 않은 경우 속성이 무시되고 반환되지 않습니다. 즉, 동작이 &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties&lt;/code&gt; &lt;/a&gt; 와 직교하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="782a50f5eb20d11713521429c1b0847fdaaf876b" translate="yes" xml:space="preserve">
          <source>If any of the following conditions occur in the readability graph, then resolution fails:</source>
          <target state="translated">가독성 그래프에서 다음 조건 중 하나가 발생하면 해결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8a96b6f648f1a586b2a9b7cb064808b149ba531a" translate="yes" xml:space="preserve">
          <source>If any of the following conditions occur, then resolution fails:</source>
          <target state="translated">다음 조건 중 하나가 발생하면 해결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3ec333633e17c9be083cec2c06b962a41326b457" translate="yes" xml:space="preserve">
          <source>If any of the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;s contain optional setting values not supported by this reader (</source>
          <target state="translated">제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에이 리더에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="76839c59491d34773c4207ef0c1d778a11ef3546" translate="yes" xml:space="preserve">
          <source>If any of these conversions proves impossible, fail with either a &lt;code&gt;ClassCastException&lt;/code&gt; if any trailing element cannot be cast to &lt;code&gt;A&lt;/code&gt; or a &lt;code&gt;NullPointerException&lt;/code&gt; if any trailing element is &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is not a reference type.</source>
          <target state="translated">이러한 변환 중 하나가 불가능 증명하는 경우 중 하나와 함께 실패 &lt;code&gt;ClassCastException&lt;/code&gt; 이 후행 요소로 캐스팅 할 수없는 경우 또는 &lt;code&gt;NullPointerException&lt;/code&gt; 이 후행 요소 인 경우, &lt;code&gt;null&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 참조 형식이 아닙니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21a8f6cbf8da0180ca327e40df0d37c1951e9068" translate="yes" xml:space="preserve">
          <source>If any of these restrictions are violated, &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. If the &lt;code&gt;interfaces&lt;/code&gt; array argument or any of its elements are &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">이러한 제한 사항 중 하나라도 위반하면 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 에서 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생 합니다. 는 IF &lt;code&gt;interfaces&lt;/code&gt; 배열 인수 또는 요소 중 하나가 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="ff3b12e4e909401d37518b8a3b2f0f268050f07d" translate="yes" xml:space="preserve">
          <source>If any one of the given (name, filter) pairs cannot be registered, then the operation fails with an exception, and no names or filters are registered.</source>
          <target state="translated">주어진 (이름, 필터) 쌍 중 하나를 등록 할 수 없으면 예외로 작업이 실패하고 이름이나 필터가 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aeed51a14c6f63342415cdd77d994dcbb7bd2135" translate="yes" xml:space="preserve">
          <source>If any recorded value is a NaN, then the final sum will be NaN.</source>
          <target state="translated">기록 된 값이 NaN이면 최종 합계는 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="c41f89efd65d6831c5b78321674605fbf8e57d9a" translate="yes" xml:space="preserve">
          <source>If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">스트림 요소가 NaN이거나 합계가 NaN 인 경우 합계는 NaN이됩니다. 부동 소수점 합의 값은 입력 값과 덧셈 연산 순서 모두의 함수입니다. 이 방법의 추가 연산 순서는 계산 결과의 속도와 정확성을 향상시키기 위해 구현 유연성을 허용하도록 의도적으로 정의되지 않았습니다. 특히,이 방법은 보상 된 합산 또는 다른 기술을 사용하여 구현되어 &lt;code&gt;double&lt;/code&gt; 값 의 단순한 합산과 비교하여 수치 합의 오차 한계를 감소시킬 수있다 .</target>
        </trans-unit>
        <trans-unit id="d6e5c13d5caa4d3b73ae2556eecfd7419724c86e" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">대기하는 동안 스레드가 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;중단&lt;/a&gt; 되면 다른 모든 대기 스레드는 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt; 을 발생시키고 장벽은 끊어진 상태에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="0366cecb1a7ed3c3842ffb9c2ca86a1363dd9a67" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">기다리는 동안 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 다른 모든 대기 스레드에서 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; 이 발생합니다.&lt;/a&gt; 을 발생시키고 장벽이 중단 된 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="4afdb9645427c72b2b449dab0d6dc64d70f5f7ed" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">이 상태에서 대기중인 스레드가 있으면 깨우기 위해 선택됩니다. 그러면 해당 스레드는 &lt;code&gt;await&lt;/code&gt; 에서 돌아 오기 전에 잠금을 다시 확보해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c78a7fa649adbc90dbb23129fc74d5e1c06006a" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">스레드가이 상태에서 대기중인 경우 모두 깨어납니다. 각 스레드는 &lt;code&gt;await&lt;/code&gt; 에서 복귀하기 전에 잠금을 다시 확보해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6def6409810618378abfde7ccc3db7a4a9969cbb" translate="yes" xml:space="preserve">
          <source>If any updates or modifications have been applied to the JoinRowSet the CachedRowSet returned by the method will not be able to persist it's changes back to the originating rows and tables in the in the datasource. The CachedRowSet instance returned should not contain modification data and it should clear all properties of it's originating SQL statement. An application should reset the SQL statement using the &lt;code&gt;RowSet.setCommand&lt;/code&gt; method.</source>
          <target state="translated">JoinRowSet에 업데이트 나 수정이 적용된 경우 메서드에서 반환 된 CachedRowSet은 데이터 소스의 원래 행과 테이블에 변경 사항을 다시 유지할 수 없습니다. 반환 된 CachedRowSet 인스턴스는 수정 데이터를 포함해서는 안되며 원래 SQL 문의 모든 속성을 지워야합니다. 애플리케이션은 &lt;code&gt;RowSet.setCommand&lt;/code&gt; 메소드를 사용하여 SQL 문을 재설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ad420704ce0b8b6310a781cf438247c5b08c1d6" translate="yes" xml:space="preserve">
          <source>If application-layer protocols are supported by the underlying SSL/TLS implementation, this method configures which values can be negotiated by protocols such as &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">기본 SSL / TLS 구현에서 응용 프로그램 계층 프로토콜을 지원하는 경우이 방법은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt; 과 같은 프로토콜에서 협상 할 수있는 값을 구성합니다. , ALPN (Application Layer Protocol Negotiation) .</target>
        </trans-unit>
        <trans-unit id="f0d6dca8e18fd60ae506385307a9dc90b88e0396" translate="yes" xml:space="preserve">
          <source>If arbitrary parameter type conversions are required, the method &lt;code&gt;setObject&lt;/code&gt; should be used with a target SQL type.</source>
          <target state="translated">임의의 매개 변수 유형 변환이 필요한 경우 &lt;code&gt;setObject&lt;/code&gt; 메소드를 대상 SQL 유형과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc5b8f67def8251eae02d8e53ae706abfba5145a" translate="yes" xml:space="preserve">
          <source>If argument to this function is null, any properties previously set are removed, and the value will revert to the value defined in the templates object.</source>
          <target state="translated">이 함수에 대한 인수가 null이면 이전에 설정 한 모든 속성이 제거되고 값이 템플릿 개체에 정의 된 값으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="b5244f53177f68a2b3ed5e4985bb324825bd1a66" translate="yes" xml:space="preserve">
          <source>If assistive technology service providers are not specified with a system property this implementation will look in a properties file located as follows:</source>
          <target state="translated">보조 기술 서비스 공급자가 시스템 속성으로 지정되지 않은 경우이 구현은 다음 위치에있는 속성 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="18a3bd0c38bccf34c6827e5596cec04cb57b5219" translate="yes" xml:space="preserve">
          <source>If at least one automatic module is enumerated by this algorithm, then every observable automatic module must be enumerated, regardless of whether any of their names are given by 'requires' directives of explicit module declarations.</source>
          <target state="translated">이 알고리즘에 의해 적어도 하나의 자동 모듈이 열거되는 경우, 명시 적 모듈 선언의 'requires'지시문에 의해 이름이 제공되는지 여부에 관계없이 모든 관찰 가능한 자동 모듈이 열거되어야합니다.</target>
        </trans-unit>
        <trans-unit id="39bc70b09921ff4ffa0b8bd08071b807a4a817ff" translate="yes" xml:space="preserve">
          <source>If at least one proxy interface is in a package that is &lt;em&gt;non-exported&lt;/em&gt; and &lt;em&gt;non-open&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;내보내기&lt;/em&gt; 및 &lt;em&gt;개방되지 &lt;/em&gt;&lt;em&gt;않은&lt;/em&gt; 패키지에 프록시 인터페이스가 하나 이상있는 경우 :</target>
        </trans-unit>
        <trans-unit id="2b0406f18bc56c48dc76b9e9165ced413b0430b2" translate="yes" xml:space="preserve">
          <source>If attachToInputContext is true, the new window will share the input context that corresponds to this input method context, so that events for components in the window are automatically dispatched to the input method. Also, when the window is opened using setVisible(true), the input context will prevent deactivate and activate calls to the input method that might otherwise be caused.</source>
          <target state="translated">attachToInputContext가 true 인 경우 새 창은이 입력 메서드 컨텍스트에 해당하는 입력 컨텍스트를 공유하므로 창의 구성 요소에 대한 이벤트가 자동으로 입력 메서드로 전달됩니다. 또한 setVisible (true)를 사용하여 창이 열리면 입력 컨텍스트는 다른 방법으로 발생할 수있는 입력 메서드에 대한 호출을 비활성화하고 활성화하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="47fbfc22f0224fd32a90e5910c55321028c1907f" translate="yes" xml:space="preserve">
          <source>If attribute already exists, replaces all existing values with new specified values. If the attribute does not exist, creates it. If no value is specified, deletes all the values of the attribute. Removal of the last value will remove the attribute if the attribute is required to have at least one value. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">속성이 이미 존재하는 경우 기존의 모든 값을 지정된 새 값으로 바꿉니다. 속성이 존재하지 않으면 작성합니다. 값을 지정하지 않으면 속성의 모든 값을 삭제합니다. 속성에 하나 이상의 값이 필요한 경우 마지막 값을 제거하면 속성이 제거됩니다. 단일 값 특성에 둘 이상의 값을 추가하려고하면 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="a71ec53a572d41f56b8978727aaa4319a3583553" translate="yes" xml:space="preserve">
          <source>If attribute does not exist, create the attribute. The resulting attribute has a union of the specified value set and the prior value set. Adding an attribute with no value will throw &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; if the attribute must have at least one value. For a single-valued attribute where that attribute already exists, throws &lt;code&gt;AttributeInUseException&lt;/code&gt;. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">속성이 존재하지 않으면 속성을 작성하십시오. 결과 속성에는 지정된 값 세트와 이전 값 세트의 합집합이 있습니다. 값이없는 속성을 추가하면 속성에 하나 이상의 값이 있어야하는 경우 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생합니다. 해당 속성이 이미 존재하는 단일 값 속성의 경우 &lt;code&gt;AttributeInUseException&lt;/code&gt; 을 발생 시킵니다. 단일 값 속성에 둘 이상의 값을 추가하려고 시도하면 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f3d3f8aee9c476b735dd96255aa064b6dd2f681b" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../../java.base/java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">인증이 성공하면 다음 인증 된 &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt; 관련으로 채워 &lt;a href=&quot;../../../../java.base/java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt; 반환됩니다. 그런 다음 주어진 주체 집합을 기반으로 권한 부여 확인이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3989b3dfcf79c0772b368fc99263d6921c534321" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">인증이 성공하면 연관된 &lt;a href=&quot;../../../java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt; 채워진 인증 된 주제가 리턴됩니다. 그런 다음 지정된 프린시 펄 세트를 기반으로 권한 확인이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="656e2a66175d25267b8bfdd6e344b28552a242bb" translate="yes" xml:space="preserve">
          <source>If auto-size is &lt;code&gt;false&lt;/code&gt;, and the image size doesn't match the tray icon space, the image is painted as-is inside that space &amp;mdash; if larger than the allocated space, it will be cropped.</source>
          <target state="translated">auto-size가 &lt;code&gt;false&lt;/code&gt; 이고 이미지 크기가 트레이 아이콘 공간과 일치하지 않으면 해당 공간 내부에있는 그대로 이미지가 그려집니다. 할당 된 공간보다 크면 잘립니다.</target>
        </trans-unit>
        <trans-unit id="291b41936e512575859370f076451751c340db33" translate="yes" xml:space="preserve">
          <source>If auto-size is &lt;code&gt;true&lt;/code&gt;, the image is stretched or shrunk to fit the tray icon space.</source>
          <target state="translated">자동 크기가 &lt;code&gt;true&lt;/code&gt; 인 경우 이미지가 트레이 아이콘 공간에 맞게 늘어나거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="384a750120cc655c818a55ff4a92437e6d8b5336" translate="yes" xml:space="preserve">
          <source>If automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL.</source>
          <target state="translated">자동 리디렉션이 활성화되어 있고이 요청이 다른 대상으로 리디렉션되면 호출자에게 리디렉션 된 호스트 / URL에 연결할 수있는 권한도 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e1a72e75cda6642170c4e7a072c7c777581c7f64" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">두 &lt;code&gt;Path&lt;/code&gt; 객체가 모두 &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt; 이 메서드는 파일이 있는지 확인하지 않고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 두 &lt;code&gt;Path&lt;/code&gt; 개체가 다른 공급자와 연결되어있는 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면이 메서드는 두 &lt;code&gt;Path&lt;/code&gt; 개체가 동일한 파일을 찾는 지 확인 하고 구현에 따라 두 파일을 모두 열거 나 액세스해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="214c67c3b5c1b48a5612e6002691988064bf0ec4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">두 &lt;code&gt;Path&lt;/code&gt; 객체가 &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt; 이 메서드는 파일이 있는지 확인하지 않고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 두 &lt;code&gt;Path&lt;/code&gt; 객체가 서로 다른 공급자와 연결되어 있으면 이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면이 메소드는 두 &lt;code&gt;Path&lt;/code&gt; 객체가 동일한 파일을 찾는 지 확인 하고 구현에 따라 두 파일을 열거 나 액세스해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4547af366065ff735c348a2ae9741324e8b7ac" translate="yes" xml:space="preserve">
          <source>If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power of the second argument if that result can in fact be represented exactly as a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">두 인수가 모두 정수인 경우 결과는 실제로 &lt;code&gt;double&lt;/code&gt; 인수로 거듭 제곱 할 수있는 경우 첫 번째 인수를 두 번째 인수의 거듭 제곱으로 올린 수학적 결과와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9e16fe4a0bb9164db40801221f5bd4724181b86e" translate="yes" xml:space="preserve">
          <source>If both arguments are negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -3*</source>
          <target state="translated">두 인수가 모두 음의 무한대이면 결과는 -3 *에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="bfd7882093d9bf21c1a62a7634c6a186d1b60176" translate="yes" xml:space="preserve">
          <source>If both arguments are positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">두 인수가 모두 양의 무한대이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="fc50ec0abca10e371c02173b94982f3dab4ec295" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, &lt;code&gt;direction&lt;/code&gt; is returned unchanged (as implied by the requirement of returning the second argument if the arguments compare as equal).</source>
          <target state="translated">두 인수 모두 0 &lt;code&gt;direction&lt;/code&gt; 부호 가 지정된 경우 방향 이 변경되지 않은 상태로 리턴됩니다 (인수가 동일한 것으로 비교되는 경우 두 번째 인수를 리턴해야 함을 의미 함).</target>
        </trans-unit>
        <trans-unit id="1ae942765abc7210f5202cbe952dc04cbb521ee9" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, a value equivalent to &lt;code&gt;direction&lt;/code&gt; is returned.</source>
          <target state="translated">두 인수 모두 0으로 부호가 지정된 경우 &lt;code&gt;direction&lt;/code&gt; 에 해당하는 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="70f5cab03df99b6ce504b587920dfb5e98d8aa1e" translate="yes" xml:space="preserve">
          <source>If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports.</source>
          <target state="translated">두 권한 구성 요소가 모두 서버 기반 인 경우 URI는 사용자 정보 구성 요소에 따라 정렬됩니다. 이러한 구성 요소가 동일하면 URI는 호스트의 순서에 따라 대소 문자를 구분하지 않고 정렬됩니다. 호스트가 동일하면 포트 순서에 따라 URI가 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="6f5d44c367ff5b5081fe504e77935fe0c93a1c15" translate="yes" xml:space="preserve">
          <source>If both date and time were parsed and either an offset or zone is present, the field &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; is created. If an offset was parsed then the offset will be combined with the &lt;code&gt;LocalDateTime&lt;/code&gt; to form the instant, with any zone ignored. If a &lt;code&gt;ZoneId&lt;/code&gt; was parsed without an offset then the zone will be combined with the &lt;code&gt;LocalDateTime&lt;/code&gt; to form the instant using the rules of &lt;a href=&quot;../chrono/chronolocaldatetime#atZone(java.time.ZoneId)&quot;&gt;&lt;code&gt;ChronoLocalDateTime.atZone(ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">날짜와 시간이 모두 구문 분석되고 오프셋 또는 영역이있는 경우 &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt; 필드 가 생성됩니다. 오프셋이 구문 분석 된 경우 오프셋은 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 결합되어 인스턴트를 형성하며 모든 영역은 무시됩니다. &lt;code&gt;ZoneId&lt;/code&gt; 가 오프셋없이 구문 분석 된 경우 영역은 &lt;a href=&quot;../chrono/chronolocaldatetime#atZone(java.time.ZoneId)&quot;&gt; &lt;code&gt;ChronoLocalDateTime.atZone(ZoneId)&lt;/code&gt; &lt;/a&gt; 규칙을 사용하여 순간을 형성하기 위해 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a0b7a5fda83b5b4e68fb0e1c58f9d3e3a0f17bf" translate="yes" xml:space="preserve">
          <source>If both functions are omitted, there is no iteration variable for the corresponding clause (&lt;code&gt;void&lt;/code&gt; is used as the type to indicate that). If one of them is omitted, the other's return type defines the clause's iteration variable type. If both are given, the common return type (they must be identical) defines the clause's iteration variable type.</source>
          <target state="translated">두 함수를 모두 생략하면 해당 절에 대한 반복 변수가 없습니다 ( &lt;code&gt;void&lt;/code&gt; 가이 를 나타내는 유형으로 사용됨). 그중 하나가 생략되면 다른 반환 유형이 절의 반복 변수 유형을 정의합니다. 둘 다 제공되는 경우 공통 반환 유형 (동일해야 함)이 절의 반복 변수 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="35daff90f12a3fdfb2ee7aaec5156a628122493a" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;' '&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">두 경우 &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;' '&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="77fe9618329cbe1c02136a891b425c89e9010bfc" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">두 경우 &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="86fead13194ade589a2825bc28cba12789046f04" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 플래그가 둘 다 제공되면 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37322522f6007d5f007c17ebbe89695f06d7d158" translate="yes" xml:space="preserve">
          <source>If both the PrincipalClass and &quot;PrincipalName&quot; are &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">PrincipalClass 및 &quot;PrincipalName&quot;이 모두 &quot;*&quot;이면 모든 &lt;code&gt;Subject&lt;/code&gt; 가 소유 한 지정된 신임 정보에 대한 액세스 권한이 부여됩니다 .</target>
        </trans-unit>
        <trans-unit id="905c92d5f8cc252cd790d5c0e9c59aa390231cea" translate="yes" xml:space="preserve">
          <source>If both the icon and text properties are set, this property defines the space between them.</source>
          <target state="translated">아이콘 및 텍스트 속성이 모두 설정된 경우이 속성은 둘 사이의 공간을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7f1f59b1990a9778560b4bab37a8896d7e2ca6a4" translate="yes" xml:space="preserve">
          <source>If both the language and country fields are missing, this function will return the empty string, even if the variant, script, or extensions field is present (you can't have a locale with just a variant, the variant must accompany a well-formed language or country code).</source>
          <target state="translated">언어 및 국가 필드가 모두 누락 된 경우 변형, 스크립트 또는 확장 필드가있는 경우에도이 함수는 빈 문자열을 반환합니다 (변형 만 포함하는 로캘을 가질 수없는 경우 변형은 형성된 언어 또는 국가 코드).</target>
        </trans-unit>
        <trans-unit id="198c8792365f76a0effc383dff9d0f2e3f4c671c" translate="yes" xml:space="preserve">
          <source>If button 1 is pressed, this is implemented to request focus on the associated text component, and to set the caret position.</source>
          <target state="translated">버튼 1을 누르면 연관된 텍스트 구성 요소에 포커스를 요청하고 캐럿 위치를 설정하기 위해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1c5cd838d41d438b8c0b687719a88a74c90d50" translate="yes" xml:space="preserve">
          <source>If button 1 is pressed, this is implemented to request focus on the associated text component, and to set the caret position. If the shift key is held down, the caret will be moved, potentially resulting in a selection, otherwise the caret position will be set to the new location. If the component is not enabled, there will be no request for focus.</source>
          <target state="translated">버튼 1을 누르면 연관된 텍스트 구성 요소에 포커스를 요청하고 캐럿 위치를 설정하기 위해 구현됩니다. Shift 키를 누르고 있으면 캐럿이 이동되어 잠재적으로 선택이되고 그렇지 않으면 캐럿 위치가 새 위치로 설정됩니다. 구성 요소가 활성화되지 않은 경우 포커스 요청이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f923d1532c20f84a25813e955834f5127ccc56bb" translate="yes" xml:space="preserve">
          <source>If c is a JRootPane descendant return its JRootPane ancestor.</source>
          <target state="translated">c가 JRootPane 자손이면 JRootPane 조상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4941c81aaff08fa305d979d6a292103fdf2015a" translate="yes" xml:space="preserve">
          <source>If c is a JRootPane descendant return its JRootPane ancestor. If c is a RootPaneContainer then return its JRootPane.</source>
          <target state="translated">c가 JRootPane 자손이면 JRootPane 조상을 반환합니다. c가 RootPaneContainer이면 JRootPane을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="297ea4154bf357de478f2a9da3045f4e48159d4d" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 풀에서 작동하는 ForkJoinTask에 의해 호출되면 &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt; 와 동일합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="3383616e30ed133f8b457a9e998c8762f65d5b51" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;#isQuiescent()&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">이 풀에서 작동하는 ForkJoinTask에 의해 호출되면 &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 그렇지 않으면이 풀이 &lt;a href=&quot;#isQuiescent()&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt; 될 때까지 대기 및 / 또는 작업 수행 지원을 시도합니다. 되거나 표시된 제한 시간이 경과 .</target>
        </trans-unit>
        <trans-unit id="f17a471a0efa20dccdfd9df73789528ef03ee4cd" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">이 풀에서 작동하는 ForkJoinTask에 의해 호출되면 &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 그렇지 않으면,이 풀이 &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt; 이거나 지정된 시간 종료가 경과 할 때까지 작업 수행을 대기 및 / 또는 지원하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5c8be13a39c3ce6b65d510654f24b14ebdee6bb3" translate="yes" xml:space="preserve">
          <source>If called on a connection that sets the same header multiple times with possibly different values, only the last value is returned.</source>
          <target state="translated">다른 값으로 동일한 헤더를 여러 번 설정하는 연결에서 호출 된 경우 마지막 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c482125ee1539de1724656d21516fd3060b7e464" translate="yes" xml:space="preserve">
          <source>If cipher suites have been set via &lt;code&gt;setEnabledCipherSuites&lt;/code&gt; then they are enabled before the TLS handshake begins.</source>
          <target state="translated">&lt;code&gt;setEnabledCipherSuites&lt;/code&gt; 를 통해 암호 스위트가 설정된 경우 TLS 핸드 셰이크가 시작되기 전에 활성화됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
