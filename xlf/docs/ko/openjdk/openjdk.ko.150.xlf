<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="04b4fe66babc8e1e2a91d1f915c13f553008f5e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt; Unicode code point&lt;/a&gt;, constant &lt;code&gt;U+0000&lt;/code&gt;.</source>
          <target state="translated">a의 최소 값 &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+0000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02d9afb81fad41f1b558fbf31a98f1c4c9ce720" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 코드 상위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uD800'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb8698589d666395f680bde3fffc23eb4f65729" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;. A high-surrogate is also known as a</source>
          <target state="translated">a의 최소값 &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 높은 대리 코드 단위&lt;/a&gt; 가 UTF-16 인코딩 상수 &lt;code&gt;'\uD800'&lt;/code&gt; . 높은 대리모는</target>
        </trans-unit>
        <trans-unit id="2d6cf70e24b8b0b8e2bc020ec9be76f98b9683d8" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDC00'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 하위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uDC00'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9341aef5dc8c567df1ec3d8097f6edae0ce1571d" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDC00'&lt;/code&gt;. A low-surrogate is also known as a</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uDC00'&lt;/code&gt; 의 &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 &lt;/a&gt;저서 로 게이트 코드 단위 의 최소값 입니다. 낮은 대리모는</target>
        </trans-unit>
        <trans-unit id="b8ea878708f2a3189c4f60757a5b8113d3717cbd" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_code_point&quot;&gt; Unicode supplementary code point&lt;/a&gt;, constant &lt;code&gt;U+10000&lt;/code&gt;.</source>
          <target state="translated">a의 최소 값 &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_code_point&quot;&gt;유니 코드 보조 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+10000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbc35eee66637501d6257be2b6fdd1c93811164" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uD800'&lt;/code&gt; 의 유니 코드 대리 코드 단위의 최소값 입니다.</target>
        </trans-unit>
        <trans-unit id="5fbe997ada48eff766f7cf7e14e58cec23e70059" translate="yes" xml:space="preserve">
          <source>The minimum value of this object.</source>
          <target state="translated">이 개체의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="95f09a7d9f34d60654550e620dc2ba2c912bf17e" translate="yes" xml:space="preserve">
          <source>The minimum width of a grid layout is the largest minimum width of all of the components in the container times the number of columns, plus the horizontal padding times the number of columns minus one, plus the left and right insets of the target container.</source>
          <target state="translated">그리드 레이아웃의 최소 너비는 컨테이너에있는 모든 구성 요소의 가장 큰 최소 너비에 열 수를 곱한 값에 가로 패딩을 곱한 열 수에서 1을 뺀 값에 대상 컨테이너의 왼쪽 및 오른쪽 삽입을 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="49fc53a3cdb40d046e3fb5b2728e5af5816b14a9" translate="yes" xml:space="preserve">
          <source>The minimum width of a pane.</source>
          <target state="translated">창의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="f827476283eaf54acaaba5a3b5e6f2d519b9e79c" translate="yes" xml:space="preserve">
          <source>The minimum width of the column.</source>
          <target state="translated">열의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="378c9bb2706a28db8c6368858d19c8a9e15f59df" translate="yes" xml:space="preserve">
          <source>The mininum height of &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JOptionPane&lt;/code&gt; 의 최소 ​​높이입니다 .</target>
        </trans-unit>
        <trans-unit id="a2d014de681dac8e9fa71ad11906b8b9b7ea7a1f" translate="yes" xml:space="preserve">
          <source>The mininum width of &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JOptionPane&lt;/code&gt; 의 최소 ​​너비입니다 .</target>
        </trans-unit>
        <trans-unit id="b71bf0a754c300b6fe868e1fa102af6d640d333b" translate="yes" xml:space="preserve">
          <source>The minor version of the profile.</source>
          <target state="translated">프로필의 부 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b66d25a3bcecafeb8650a51f2ee9c9377ad08d80" translate="yes" xml:space="preserve">
          <source>The minute of hour of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;, from 0 to 59.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 분 ( 0부터 59까지)입니다.</target>
        </trans-unit>
        <trans-unit id="667a30120007f381c89db949ed47ebe336fec88a" translate="yes" xml:space="preserve">
          <source>The minute-of-day.</source>
          <target state="translated">분.</target>
        </trans-unit>
        <trans-unit id="bdf3bd78cbbce8ca5c3b8eb81726aefb24544a82" translate="yes" xml:space="preserve">
          <source>The minute-of-hour.</source>
          <target state="translated">시간입니다.</target>
        </trans-unit>
        <trans-unit id="d1e01e9578c34a1b819c6910e06d54349322daab" translate="yes" xml:space="preserve">
          <source>The mnemonic keycode used for the approve button when a directory is selected and the current selection mode is FILES_ONLY.</source>
          <target state="translated">디렉토리가 선택되고 현재 선택 모드가 FILES_ONLY 일 때 승인 버튼에 사용되는 니모닉 키 코드입니다.</target>
        </trans-unit>
        <trans-unit id="6f280eaac6e54be7e34e3642f6ff855dccab09c2" translate="yes" xml:space="preserve">
          <source>The mode argument determines how the progression parameters are chosen, and must be either &lt;code&gt;MODE_DISABLED&lt;/code&gt;, &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;, or &lt;code&gt;MODE_DEFAULT&lt;/code&gt;. Otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">mode 인수는 진행 매개 변수 선택 방법을 결정하며 &lt;code&gt;MODE_DISABLED&lt;/code&gt; , &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 또는 &lt;code&gt;MODE_DEFAULT&lt;/code&gt; 중 하나 여야합니다 . 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b820834a96857a5b241fe95cf3e9cca22165efa9" translate="yes" xml:space="preserve">
          <source>The mode controlling compression settings, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.</source>
          <target state="translated">4 개의 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정되어야하는 압축 설정을 제어하는 ​​모드 입니다.</target>
        </trans-unit>
        <trans-unit id="7f15fced94f4787a730192e708c8082a30aebb9f" translate="yes" xml:space="preserve">
          <source>The mode controlling compression settings, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">압축 설정을 제어하는 ​​모드는 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정되어야 합니다. 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a8ab8dfa11b67a073fb291acb9e8e1dda7b1630" translate="yes" xml:space="preserve">
          <source>The mode controlling progressive encoding, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values, except &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 를 제외한 4 개의 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야하는 점진적 인코딩을 제어하는 ​​모드 입니다.</target>
        </trans-unit>
        <trans-unit id="3de7dfb6d10df1074cd5714724b32c3da19cb20a" translate="yes" xml:space="preserve">
          <source>The mode controlling progressive encoding, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values, except &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">점진적 인코딩을 제어하는 ​​모드 . &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 를 제외한 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다 . 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b4bf954229dabff064f394cda1a8fd6dbc2ddb7" translate="yes" xml:space="preserve">
          <source>The mode controlling tiling settings, which Must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.</source>
          <target state="translated">타일링 설정을 제어하는 ​​모드로, 4 개의 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f25060df8ca2f2296a1ced1bd3e2a4bdeb249eca" translate="yes" xml:space="preserve">
          <source>The mode controlling tiling settings, which Must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">타일링 설정을 제어하는 ​​모드로, 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다. 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fe32b2240e57a17879128135f9a453935908963" translate="yes" xml:space="preserve">
          <source>The model change type returned by getType() will be one of:</source>
          <target state="translated">getType ()에서 반환하는 모델 변경 유형은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="2616079c079dc951763eebae3bec223e413339d2" translate="yes" xml:space="preserve">
          <source>The model doesn't support indexed random access to sequence elements. Only three sequence values are accessible at a time: current, next and previous.</source>
          <target state="translated">모델은 시퀀스 요소에 대한 색인화 된 임의 액세스를 지원하지 않습니다. 한 번에 세 가지 시퀀스 값 (현재, 다음 및 이전) 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="168faef5c82b48acd963b7c9af4201a890453b16" translate="yes" xml:space="preserve">
          <source>The model is defined by the &lt;a href=&quot;document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; interface. This is intended to provide a flexible text storage mechanism that tracks change during edits and can be extended to more sophisticated models. The model interfaces are meant to capture the capabilities of expression given by SGML, a system used to express a wide variety of content. Each modification to the document causes notification of the details of the change to be sent to all observers in the form of a &lt;a href=&quot;../event/documentevent&quot;&gt;&lt;code&gt;DocumentEvent&lt;/code&gt;&lt;/a&gt; which allows the views to stay up to date with the model. This event is sent to observers that have implemented the &lt;a href=&quot;../event/documentlistener&quot;&gt;&lt;code&gt;DocumentListener&lt;/code&gt;&lt;/a&gt; interface and registered interest with the model being observed.</source>
          <target state="translated">모델은 &lt;a href=&quot;document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 인터페이스에 의해 정의됩니다 . 이는 편집 중 변경 사항을 추적하고보다 정교한 모델로 확장 할 수있는 유연한 텍스트 저장 메커니즘을 제공하기위한 것입니다. 모델 인터페이스는 다양한 콘텐츠를 표현하는 데 사용되는 시스템 인 SGML이 제공하는 표현 능력을 캡처하기위한 것입니다. 문서를 수정할 때마다 변경 사항의 세부 사항에 대한 알림이 &lt;a href=&quot;../event/documentevent&quot;&gt; &lt;code&gt;DocumentEvent&lt;/code&gt; &lt;/a&gt; 형식으로 모든 관찰자에게 전송되어 뷰가 모델에 대한 최신 상태를 유지할 수 있습니다. 이 이벤트는 &lt;a href=&quot;../event/documentlistener&quot;&gt; &lt;code&gt;DocumentListener&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하고 관찰중인 모델에 관심을 등록한 관찰자에게 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="8330843d459736e066acd92b3f008756fa5c7567" translate="yes" xml:space="preserve">
          <source>The model that defines the tree displayed by this object.</source>
          <target state="translated">이 개체가 표시하는 트리를 정의하는 모델입니다.</target>
        </trans-unit>
        <trans-unit id="5570617ef85dae7ecc2d0d0bb54d74a489ee7647" translate="yes" xml:space="preserve">
          <source>The model that represents the scrollbar's minimum, maximum, extent (aka &quot;visibleAmount&quot;) and current value.</source>
          <target state="translated">스크롤바의 최소, 최대, 범위 ( &quot;visibleAmount&quot;라고도 함) 및 현재 값을 나타내는 모델입니다.</target>
        </trans-unit>
        <trans-unit id="75a1b07f9515385c3a661861496a6b145b77de8a" translate="yes" xml:space="preserve">
          <source>The model used by &lt;code&gt;JTree&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTree&lt;/code&gt; 에서 사용하는 모델 입니다.</target>
        </trans-unit>
        <trans-unit id="3aa2540304cd41e4a19279ee3b3fa91e13a6535a" translate="yes" xml:space="preserve">
          <source>The modeling of HTML is provided by the class &lt;code&gt;HTMLDocument&lt;/code&gt;. Its documentation describes the details of how the HTML is modeled. The editing support leverages heavily off of the text package.</source>
          <target state="translated">HTML 모델링은 &lt;code&gt;HTMLDocument&lt;/code&gt; 클래스에서 제공합니다 . 문서는 HTML이 어떻게 모델링되는지에 대한 세부 사항을 설명합니다. 편집 지원은 텍스트 패키지를 많이 활용합니다.</target>
        </trans-unit>
        <trans-unit id="244c6099e5c9d507a776de051659ea7a5f6ced2a" translate="yes" xml:space="preserve">
          <source>The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds. Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and alterations to the length of the notional second. As of 2012, discussions are underway to change the definition of UTC again, with the potential to remove leap seconds or introduce other changes.</source>
          <target state="translated">현대 UTC 타임 스케일은 1972 년에 도입되어 전체 윤초 개념을 소개합니다. 1958 년에서 1972 년 사이에 UTC의 정의는 복잡했으며, 초 이하의 작은 도약과 명목 초의 길이로 변경되었습니다. 2012 년 현재, 윤초를 제거하거나 다른 변경 사항을 도입 할 가능성이있는 UTC 정의를 다시 변경하기위한 논의가 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="c9c8d93b57522e87b93d7fcd2ed2c2ba506c62e6" translate="yes" xml:space="preserve">
          <source>The modes are interpreted as follows:</source>
          <target state="translated">모드는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd9eb9b1298371443e0745698a19893708a9dc0" translate="yes" xml:space="preserve">
          <source>The modes are:</source>
          <target state="translated">모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3cc6805c08b8481a43ee22b87218eba5bf5978e2" translate="yes" xml:space="preserve">
          <source>The modification code. It is one of: DirContext.ADD_ATTRIBUTE DirContext.REPLACE_ATTRIBUTE DirContext.REMOVE_ATTRIBUTE</source>
          <target state="translated">수정 코드 DirContext.ADD_ATTRIBUTE DirContext.REPLACE_ATTRIBUTE DirContext.REMOVE_ATTRIBUTE 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3b8710293df9488348bad7d24782355247e162f4" translate="yes" xml:space="preserve">
          <source>The modification time and deflation hint attributes are not available, for the JAR manifest file and its containing directory.</source>
          <target state="translated">JAR Manifest 파일 및 포함 디렉토리에 수정 시간 및 수축 힌트 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae5392e591961cef35e6113a0d61745bb18d5cf2" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;abstract&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;abstract&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63ec4993c4772cec3247257c7af88444f99bd5d4" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;default&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b79ffc26fe09a60c57670ba9443868f3e378227" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;final&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;final&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4caecde01acdabdee3af4deddef05c9345eee88d" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;native&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d84914d32c0b59de560ef406f5fd476bb609a72" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;private&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca2a774915ce47a0621b004260cfcdf34bae0b19" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;protected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d5d79646fb8f27e87d578f47719e85be208200f" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;public&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;public&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0e06d76cb207037ed375002dc516a6bbcfd082" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;static&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="843644ccb0d5da6c49b878e18a5c3bf04e5a41bd" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;strictfp&lt;/code&gt;</source>
          <target state="translated">한정자 &lt;code&gt;strictfp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e064fce2e476a78dbc9a1b50a393aead551b075c" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;synchronized&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;synchronized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f0463dc16506480712ec2a64c8d394dc5a179d0" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;transient&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;transient&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8adc7b2e81a65197a52783e56e73bede59c438b8" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;volatile&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;volatile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53c43243f455d925c46f284aad81cc7fec157428" translate="yes" xml:space="preserve">
          <source>The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;, table 4.1.</source>
          <target state="translated">수정 자 인코딩은 &lt;em&gt;Java 가상 머신 스펙&lt;/em&gt; , 표 4.1에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea943ef7605756df7d4c1d9a2ba6aa05951d0cb1" translate="yes" xml:space="preserve">
          <source>The modifier flags for this parameter.</source>
          <target state="translated">이 매개 변수에 대한 수정 자 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="d9015ba8f3732b054992024e20f5e48c6d7fa0d5" translate="yes" xml:space="preserve">
          <source>The modifier names are returned in an order consistent with the suggested modifier orderings given in sections 8.1.1, 8.3.1, 8.4.3, 8.8.3, and 9.1.1 of</source>
          <target state="translated">수정 자 이름은 8.1.1, 8.3.1, 8.4.3, 8.8.3 및 9.1.1의 섹션 8.1.1에 제시된 제안 된 수정 자 순서와 일치하는 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c051f323123e2496ae8ef9f68dd6f61e20d85875" translate="yes" xml:space="preserve">
          <source>The modifiers are placed in canonical order as specified by &quot;The Java Language Specification&quot;. This is &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt; first, and then other modifiers in the following order: &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;transient&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">수정자는 &quot;The Java Language Specification&quot;에 지정된대로 정식 순서로 배치됩니다. 이것은 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 이며, 다음 순서로 &lt;code&gt;static&lt;/code&gt; , &lt;code&gt;final&lt;/code&gt; , &lt;code&gt;transient&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; 순서로 다른 수정 자입니다 .</target>
        </trans-unit>
        <trans-unit id="d9638f5a7a035d2e6544d680de5d3ab0daed7b22" translate="yes" xml:space="preserve">
          <source>The modifiers consist of any combination of:</source>
          <target state="translated">수정자는 다음의 조합으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff5d7370fd2f43b716be59ccc281e0ddf9dbf8a" translate="yes" xml:space="preserve">
          <source>The module declaration of the &lt;em&gt;consumer module&lt;/em&gt; that calls one of the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory methods to obtain a resource bundle from service providers must specify the following directive:</source>
          <target state="translated">&lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 팩토리 메소드 중 하나를 호출 하여 서비스 제공자로부터 자원 번들을 가져 오는 &lt;em&gt;소비자 모듈&lt;/em&gt; 의 모듈 선언은 다음 지시문을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd27a759db5930b6965b70e80e45ffbd273976e9" translate="yes" xml:space="preserve">
          <source>The module declaration of this provider module specifies the following directive:</source>
          <target state="translated">이 공급자 모듈의 모듈 선언은 다음 지시문을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f826091184fabed6c053393d124b02eeb394e90b" translate="yes" xml:space="preserve">
          <source>The module descriptor</source>
          <target state="translated">모듈 설명자</target>
        </trans-unit>
        <trans-unit id="9ffb9f109518cb257ecb641ae9e31b19f384e7d8" translate="yes" xml:space="preserve">
          <source>The module descriptor for this module</source>
          <target state="translated">이 모듈의 모듈 설명자</target>
        </trans-unit>
        <trans-unit id="d5697a7d44cd8d7587068252683fa19c81cde1d8" translate="yes" xml:space="preserve">
          <source>The module descriptor is read from the buffer starting at index &lt;code&gt;p&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is the buffer's &lt;a href=&quot;../../nio/buffer#position()&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; when this method is invoked. Upon return the buffer's position will be equal to &lt;code&gt;p + n&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of bytes read from the buffer.</source>
          <target state="translated">모듈 설명자는 인덱스 &lt;code&gt;p&lt;/code&gt; 에서 시작하는 버퍼에서 읽습니다 . 여기서 &lt;code&gt;p&lt;/code&gt; 는 이 메서드가 호출 될 때 버퍼의 &lt;a href=&quot;../../nio/buffer#position()&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 입니다. 반환시 버퍼의 위치는 &lt;code&gt;p + n&lt;/code&gt; 과 같을 것입니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 버퍼에서 읽은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="23823c03b5b1082b2e61b6362541194e29396b6d" translate="yes" xml:space="preserve">
          <source>The module finder locates modules by searching each directory, exploded module, or packaged module in array index order. It finds the first occurrence of a module with a given name and ignores other modules of that name that appear later in the sequence.</source>
          <target state="translated">모듈 파인더는 각 디렉토리, 확장 된 모듈 또는 패키지 된 모듈을 배열 인덱스 순서로 검색하여 모듈을 찾습니다. 주어진 이름을 가진 모듈의 첫 번째 발생을 찾고 순서에서 나중에 나타나는 해당 이름의 다른 모듈을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fd6e4f3b8e674aeca9b51d358b7f13e83c064b81" translate="yes" xml:space="preserve">
          <source>The module finder returned by this method supports modules packaged as JAR files. A JAR file with a &lt;code&gt;
 module-info.class&lt;/code&gt; in its top-level directory, or in a versioned entry in a &lt;a href=&quot;../../util/jar/jarfile#isMultiRelease()&quot;&gt;multi-release&lt;/a&gt; JAR file, is a modular JAR file and thus defines an &lt;em&gt;explicit&lt;/em&gt; module. A JAR file that does not have a &lt;code&gt;module-info.class&lt;/code&gt; in its top-level directory defines an &lt;em&gt;automatic module&lt;/em&gt;, as follows:</source>
          <target state="translated">이 메소드에서 반환 된 모듈 찾기는 JAR 파일로 패키지 된 모듈을 지원합니다. 기호가있는 JAR 파일 &lt;code&gt; module-info.class&lt;/code&gt; 최상위 디렉토리는, 또는에서 버전 항목에 &lt;a href=&quot;../../util/jar/jarfile#isMultiRelease()&quot;&gt;멀티 릴리스&lt;/a&gt; JAR 파일, 모듈 JAR 파일이며, 따라서 정의 &lt;em&gt;명시 적으로&lt;/em&gt; 모듈을. 최상위 디렉토리에 &lt;code&gt;module-info.class&lt;/code&gt; 가없는 JAR 파일 은 다음과 같이 &lt;em&gt;자동 모듈을&lt;/em&gt; 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1a9f6d24753f85c58f990e727273d60e2e67d1e6" translate="yes" xml:space="preserve">
          <source>The module layer that contains this module</source>
          <target state="translated">이 모듈을 포함하는 모듈 계층</target>
        </trans-unit>
        <trans-unit id="1635800c659f8343bb6f76cf0577b6d8050a774a" translate="yes" xml:space="preserve">
          <source>The module name</source>
          <target state="translated">모듈 이름</target>
        </trans-unit>
        <trans-unit id="53e0fa608612b58a9a810e4063bf16f58069901a" translate="yes" xml:space="preserve">
          <source>The module name of the initial/main module</source>
          <target state="translated">초기 / 주 모듈의 모듈 이름</target>
        </trans-unit>
        <trans-unit id="ac5d37ad4e53b906df01aa542b63a047cb5d7bde" translate="yes" xml:space="preserve">
          <source>The module names, package names, and class names that are parameters specified to the builder methods are the module names, package names, and qualified names of classes (in named packages) as defined in the</source>
          <target state="translated">빌더 메소드에 지정된 매개 변수 인 모듈 이름, 패키지 이름 및 클래스 이름은 모듈 이름, 패키지 이름 및 클래스의 규정 된 이름 (명명 된 패키지에 있음)입니다.</target>
        </trans-unit>
        <trans-unit id="11c2904d770fbc92f2522b07410930baefe40138" translate="yes" xml:space="preserve">
          <source>The module was implicitly declared.</source>
          <target state="translated">모듈이 암시 적으로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f251bc3c55d3066fc0f31b71e99d61fef714079" translate="yes" xml:space="preserve">
          <source>The module was not explicitly or implicitly declared.</source>
          <target state="translated">모듈이 명시 적으로 또는 암시 적으로 선언되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d3991d1b517dfde1e54a603f22fa164b96b0ed22" translate="yes" xml:space="preserve">
          <source>The module will require &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; even if the dependence has not been declared (the exception is when building a module named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; as it cannot require itself). The dependence on &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; will have the &lt;a href=&quot;moduledescriptor.requires.modifier#MANDATED&quot;&gt;&lt;code&gt;MANDATED&lt;/code&gt;&lt;/a&gt; modifier if the dependence was not declared.</source>
          <target state="translated">모듈은 &quot;필요 &lt;code&gt;java.base&lt;/code&gt; 의존도가 선언되지 않은 경우에도&quot;를 ( &quot;라는 이름의 모듈을 빌드 할 때 예외입니다 &lt;code&gt;java.base&lt;/code&gt; 그 자체를 필요로하지 수를&quot;). 종속성이 선언되지 않은 경우 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 에 대한 종속성 에는 &lt;a href=&quot;moduledescriptor.requires.modifier#MANDATED&quot;&gt; &lt;code&gt;MANDATED&lt;/code&gt; &lt;/a&gt; 수정자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="854f140d77f63016d257e0527ca134810276d2c2" translate="yes" xml:space="preserve">
          <source>The module with the given name or an empty &lt;code&gt;Optional&lt;/code&gt; if there isn't a module with this name in this layer or any parent layer</source>
          <target state="translated">주어진 이름을 가진 모듈 또는이 레이어 또는 상위 레이어에이 이름을 가진 모듈이없는 경우 빈 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62ab14799d4062196ce892d3b8d807e65d9fde90" translate="yes" xml:space="preserve">
          <source>The modulus value.</source>
          <target state="translated">모듈러스 값.</target>
        </trans-unit>
        <trans-unit id="3d08c37a4170b4dda9e34877ca839b2a5af939cc" translate="yes" xml:space="preserve">
          <source>The month of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;, from 1 to 12.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 월이며 1부터 12까지입니다.</target>
        </trans-unit>
        <trans-unit id="52e5f16469f41afd7f7f1a42b853a6034f970843" translate="yes" xml:space="preserve">
          <source>The month-of-year, such as March.</source>
          <target state="translated">3 월과 같은 달입니다.</target>
        </trans-unit>
        <trans-unit id="ad63462cba81985606db9ca1b76cff069f0f97bd" translate="yes" xml:space="preserve">
          <source>The months unit is not automatically normalized with the years unit. This means that a period of &quot;15 months&quot; is different to a period of &quot;1 year and 3 months&quot;.</source>
          <target state="translated">개월 단위는 년 단위로 자동 정규화되지 않습니다. 이것은 &quot;15 개월&quot;의 기간이 &quot;1 년 3 개월&quot;의 기간과 다르다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1808c8e9420488523fe90cca9d9f6edf6d79fa22" translate="yes" xml:space="preserve">
          <source>The most common example when the 'mixing-cutout' shape is needed is a glass pane component. The &lt;a href=&quot;../../javax/swing/jrootpane#setGlassPane(java.awt.Component)&quot;&gt;&lt;code&gt;JRootPane.setGlassPane(java.awt.Component)&lt;/code&gt;&lt;/a&gt; method automatically sets the</source>
          <target state="translated">'mixing-cutout'모양이 필요한 가장 일반적인 예는 유리창 구성 요소입니다. &lt;a href=&quot;../../javax/swing/jrootpane#setGlassPane(java.awt.Component)&quot;&gt; &lt;code&gt;JRootPane.setGlassPane(java.awt.Component)&lt;/code&gt; &lt;/a&gt; 방법을 자동 설정하는</target>
        </trans-unit>
        <trans-unit id="4513060ec32ffaef9ffecbdcf9d778476ec0f897" translate="yes" xml:space="preserve">
          <source>The most common implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional common queries are provided as static methods in &lt;a href=&quot;temporalqueries&quot;&gt;&lt;code&gt;TemporalQueries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 구현은 다음과 같은 메소드 참조입니다. &lt;code&gt;LocalDate::from&lt;/code&gt; 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 입니다 . 추가 일반 쿼리는 &lt;a href=&quot;temporalqueries&quot;&gt; &lt;code&gt;TemporalQueries&lt;/code&gt; &lt;/a&gt; 에서 정적 메소드로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e2c1befd40582f5a4726afbca33854db8dbfdc7" translate="yes" xml:space="preserve">
          <source>The most common implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional common queries are provided to return:</source>
          <target state="translated">가장 일반적인 구현은 &lt;code&gt;LocalDate::from&lt;/code&gt; 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 같은 메소드 참조 입니다 . 다음을 리턴하기 위해 추가 공통 조회가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3d41a4cbf15b731db6bda6714c5e00e992b9f579" translate="yes" xml:space="preserve">
          <source>The most common query implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional implementations are provided as static methods on &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 쿼리 구현은 &lt;code&gt;LocalDate::from&lt;/code&gt; 과 같은 메서드 참조 입니다. 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 입니다 . 추가 구현은 &lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; 에&lt;/a&gt; 정적 메소드로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c13dd68f0c8f57bb59ccd6903b4447f288e54694" translate="yes" xml:space="preserve">
          <source>The most commonly used units are defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. Further fields are supplied in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields&quot;&gt;&lt;code&gt;WeekFields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;julianfields&quot;&gt;&lt;code&gt;JulianFields&lt;/code&gt;&lt;/a&gt;. Fields can also be written by application code by implementing this interface.</source>
          <target state="translated">가장 일반적으로 사용되는 단위는 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 . 추가 필드는 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 에서 제공됩니다 .&lt;a href=&quot;weekfields&quot;&gt; &lt;code&gt;WeekFields&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;julianfields&quot;&gt; &lt;code&gt;JulianFields&lt;/code&gt; 에 제공&lt;/a&gt; 됩니다. 이 인터페이스를 구현하여 응용 프로그램 코드로 필드를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7dd9ea927fa70049276104e84510298e783b39" translate="yes" xml:space="preserve">
          <source>The most commonly used units are defined in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. Further units are supplied in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;. Units can also be written by application code by implementing this interface.</source>
          <target state="translated">가장 일반적으로 사용되는 단위는 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다. . 추가 단위는 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 에 제공됩니다 . 이 인터페이스를 구현하여 응용 프로그램 코드로 단위를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68bb9a4cb9aa2b82b423053d80b910869345efe3" translate="yes" xml:space="preserve">
          <source>The most condensed predefined width.</source>
          <target state="translated">가장 압축 된 미리 정의 된 너비입니다.</target>
        </trans-unit>
        <trans-unit id="40695de746ccbc2352bf8577be8e1cbb2b497820" translate="yes" xml:space="preserve">
          <source>The most extended predefined width.</source>
          <target state="translated">가장 확장 된 미리 정의 된 너비입니다.</target>
        </trans-unit>
        <trans-unit id="336862f66e49b850485d5a43840dcf02567602aa" translate="yes" xml:space="preserve">
          <source>The most significant 64 bits of this UUID's 128 bit value</source>
          <target state="translated">이 UUID 128 비트 값의 최상위 64 비트</target>
        </trans-unit>
        <trans-unit id="1b3a7b82d4c1e3494e08d3f8dcc14fcea3e3c83d" translate="yes" xml:space="preserve">
          <source>The mouse has entered a component.</source>
          <target state="translated">마우스가 구성 요소에 들어갔습니다.</target>
        </trans-unit>
        <trans-unit id="4300ff492f6761e54037896847250d58d9f7ca9a" translate="yes" xml:space="preserve">
          <source>The mouse has exited a component.</source>
          <target state="translated">마우스가 구성 요소를 종료했습니다.</target>
        </trans-unit>
        <trans-unit id="88d3dea421ee35681eb08ba780924b05a6ceba05" translate="yes" xml:space="preserve">
          <source>The mouse has moved with no button pressed.</source>
          <target state="translated">버튼을 누르지 않고 마우스가 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="ba08b5f18ed9ec07f7eba8ec350b383be83d9827" translate="yes" xml:space="preserve">
          <source>The move button text property.</source>
          <target state="translated">이동 버튼 텍스트 속성입니다.</target>
        </trans-unit>
        <trans-unit id="4ed52e635196ac91fbf685930c6ca399d0d5eae6" translate="yes" xml:space="preserve">
          <source>The move cursor type.</source>
          <target state="translated">이동 커서 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e5b6b0ee327c4dda6a29cf8a360a7d3afa18127d" translate="yes" xml:space="preserve">
          <source>The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;. If the move cannot be performed as an atomic file system operation then &lt;a href=&quot;atomicmovenotsupportedexception&quot;&gt;&lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt;&lt;/a&gt; is thrown. This can arise, for example, when the target location is on a different &lt;code&gt;FileStore&lt;/code&gt; and would require that the file be copied, or target location is associated with a different provider to this object.</source>
          <target state="translated">이동은 원자 파일 시스템 조작으로 수행되며 다른 모든 옵션은 무시됩니다. 대상 파일이 존재하는 경우 기존 파일이 교체되거나 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을&lt;/a&gt; 발생시켜이 메소드가 실패하면 구현 고유의 것입니다 . 원자 파일 시스템 조작으로 이동을 수행 할 수없는 경우 &lt;a href=&quot;atomicmovenotsupportedexception&quot;&gt; &lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 예를 들어, 대상 위치가 다른 &lt;code&gt;FileStore&lt;/code&gt; 에 있고 파일을 복사해야하거나 대상 위치가이 오브젝트에 대한 다른 제공자와 연관되어 있어야하는 경우가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf8d2bee39940d0f0e5b63f3da1a2f2575577f74" translate="yes" xml:space="preserve">
          <source>The msg string is localized using the named resource bundle. If the resource bundle name is null, or an empty String or invalid then the msg string is not localized.</source>
          <target state="translated">msg 문자열은 이름 지정된 자원 번들을 사용하여 현지화됩니다. 자원 번들 이름이 널이거나 비어있는 문자열이거나 유효하지 않은 경우 msg 문자열이 현지화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f37cfad4e06252721b39abc7c9955ec39b17924d" translate="yes" xml:space="preserve">
          <source>The multicast datagram socket class is useful for sending and receiving IP multicast packets.</source>
          <target state="translated">멀티 캐스트 데이터 그램 소켓 클래스는 IP 멀티 캐스트 패킷을 보내고받는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0c63c91d04a939fcd587cbc1f9e978924f9d2ad7" translate="yes" xml:space="preserve">
          <source>The multicast datagram socket class is useful for sending and receiving IP multicast packets. A MulticastSocket is a (UDP) DatagramSocket, with additional capabilities for joining &quot;groups&quot; of other multicast hosts on the internet.</source>
          <target state="translated">멀티 캐스트 데이터 그램 소켓 클래스는 IP 멀티 캐스트 패킷을 보내고받는 데 유용합니다. MulticastSocket은 인터넷에서 다른 멀티 캐스트 호스트의 &quot;그룹&quot;에 참여하기위한 추가 기능이있는 (UDP) DatagramSocket입니다.</target>
        </trans-unit>
        <trans-unit id="679be2f4ae9c2488715346a40d11f01c153c9386" translate="yes" xml:space="preserve">
          <source>The multicast implementation is intended to map directly to the native multicasting facility. Consequently, the following items should be considered when developing an application that receives IP multicast datagrams:</source>
          <target state="translated">멀티 캐스트 구현은 기본 멀티 캐스팅 기능에 직접 매핑하기위한 것입니다. 따라서 IP 멀티 캐스트 데이터 그램을 수신하는 응용 프로그램을 개발할 때는 다음 사항을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d9f399a6a76b061b084d9b4a009e3d8e36254d4" translate="yes" xml:space="preserve">
          <source>The multiple input documents are combined into a single output document. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on this single output document. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of this single output document to produce. The &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; values &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; and &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서가 하나의 출력 문서로 결합됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은이 단일 출력 문서에서 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성이 단일 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 값 &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; 와 &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; 은 이러한 가능성의 두 변형을 지정.</target>
        </trans-unit>
        <trans-unit id="ce7b19820280a66b240e2ab7bb11f5dc03d3553e" translate="yes" xml:space="preserve">
          <source>The multiple input documents are combined into a single output document. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on this single output document. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of this single output document to produce. The MultipleDocumentHandling values SINGLE_DOCUMENT and SINGLE_DOCUMENT_NEW_SHEET specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서가 단일 출력 문서로 결합됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은이 단일 출력 문서에서 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성이 단일 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. MultipleDocumentHandling 값 SINGLE_DOCUMENT 및 SINGLE_DOCUMENT_NEW_SHEET은이 가능성의 두 가지 변형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ebc205570873174d635db810e1ed9b34c248d113" translate="yes" xml:space="preserve">
          <source>The multiple input documents remain separate output documents. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on each output document separately. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of each separate output document to produce. The &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; values &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; and &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서는 별도의 출력 문서로 유지됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은 각 출력 문서에서 개별적으로 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성은 각각 별도의 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의이 값 &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; 및 &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; 은 이러한 가능성의 두 변형을 지정.</target>
        </trans-unit>
        <trans-unit id="028e483478001df55d9b96778a1edffa0bfb1289" translate="yes" xml:space="preserve">
          <source>The multiple input documents remain separate output documents. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on each output document separately. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of each separate output document to produce. The MultipleDocumentHandling values SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서는 별도의 출력 문서로 유지됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은 각 출력 문서에서 개별적으로 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성은 각각 별도의 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. MultipleDocumentHandling 값 SEPARATE_DOCUMENTS_UNCOLLATED_COPIES 및 SEPARATE_DOCUMENTS_COLLATED_COPIES는이 가능성의 두 가지 변형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d1a9befa918fd9fc042bb67e1599e6636d96288a" translate="yes" xml:space="preserve">
          <source>The mutable reduction operation is called &lt;a href=&quot;stream#collect(java.util.stream.Collector)&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt;, as it collects together the desired results into a result container such as a &lt;code&gt;Collection&lt;/code&gt;. A &lt;code&gt;collect&lt;/code&gt; operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another. The form of this is very similar to the general form of ordinary reduction:</source>
          <target state="translated">변경 가능한 축소 작업은 &lt;a href=&quot;stream#collect(java.util.stream.Collector)&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 라고 합니다. 원하는 결과를 &lt;code&gt;Collection&lt;/code&gt; 과 같은 결과 컨테이너로 모으기 때문 입니다. &lt;code&gt;collect&lt;/code&gt; 동작은 세 가지 기능을 필요 공급 기능을 다른 것으로 한 결과, 용기의 내용을 병합 한 결과 컨테이너 결과 용기에 입력 요소를 포함하는 누적 기 함수 및 합성 함수의 새로운 인스턴스를 생성하기. 이 형식은 일반적인 축소 형식과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="fc368dbc299b8ec9a50b33ed2e8162f1e9e9148a" translate="yes" xml:space="preserve">
          <source>The mutable reduction operation is called &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt;, as it collects together the desired results into a result container such as a &lt;code&gt;Collection&lt;/code&gt;. A &lt;code&gt;collect&lt;/code&gt; operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another. The form of this is very similar to the general form of ordinary reduction:</source>
          <target state="translated">변경 가능한 축소 연산은 원하는 결과를 &lt;code&gt;Collection&lt;/code&gt; 과 같은 결과 컨테이너로 수집하기 때문에 &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 라고 합니다 . &lt;code&gt;collect&lt;/code&gt; 동작은 세 가지 기능을 필요 공급 기능을 다른 것으로 한 결과, 용기의 내용을 병합 한 결과 컨테이너 결과 용기에 입력 요소를 포함하는 누적 기 함수 및 합성 함수의 새로운 인스턴스를 생성하기. 이것의 형태는 일반적인 형태의 일반 축소와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6bf363cc62a0d3c9d944fdceea262606a0bad8a4" translate="yes" xml:space="preserve">
          <source>The mutable source provides a late-binding and fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 후기 바인딩 및 페일 빠른 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d66e6381fee28dcc7d4fb931e8ee888e87c11040" translate="yes" xml:space="preserve">
          <source>The mutable source provides a late-binding and non-fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 후기 바인딩 및 실패하지 않은 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f78fc2805fc5d07a59044553456ac5cd7dd26fa" translate="yes" xml:space="preserve">
          <source>The mutable source provides a non-late-binding and non-fail-fast Spliterator.</source>
          <target state="translated">가변 소스는 비 지연 바인딩 및 비 고속 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dbe168307666cea493e681f1f4347bdcea853c7c" translate="yes" xml:space="preserve">
          <source>The mutable source provides a non-late-binding but fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 바인딩이 아닌 비 고속 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="76d403f1093a19ad1c9bb2d7114141c8b8dfd068" translate="yes" xml:space="preserve">
          <source>The n-th date which appears in the stream is equal to &lt;code&gt;this.plus(step.multipliedBy(n))&lt;/code&gt; (but the result of step multiplication never overflows). For example, if this date is &lt;code&gt;2015-01-31&lt;/code&gt;, the end date is &lt;code&gt;2015-05-01&lt;/code&gt; and the step is 1 month, then the stream contains &lt;code&gt;2015-01-31&lt;/code&gt;, &lt;code&gt;2015-02-28&lt;/code&gt;, &lt;code&gt;2015-03-31&lt;/code&gt;, and &lt;code&gt;2015-04-30&lt;/code&gt;.</source>
          <target state="translated">스트림에 나타나는 n 번째 날짜는 &lt;code&gt;this.plus(step.multipliedBy(n))&lt;/code&gt; (하지만 단계 곱셈의 결과는 절대 오버플로되지 않음). 예를 &lt;code&gt;2015-01-31&lt;/code&gt; 날짜가 2015-01-31 이고 종료 날짜가 &lt;code&gt;2015-05-01&lt;/code&gt; 이고 단계가 1 개월이면 스트림에 &lt;code&gt;2015-01-31&lt;/code&gt; , &lt;code&gt;2015-02-28&lt;/code&gt; , &lt;code&gt;2015-03-31&lt;/code&gt; 이 포함됩니다. , 및 &lt;code&gt;2015-04-30&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7bae1d90225c65e4241b4140c7e704c983e32a7" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;gc&lt;/code&gt; stands for &quot;garbage collector&quot;. The virtual machine performs this recycling process automatically as needed, in a separate thread, even if the &lt;code&gt;gc&lt;/code&gt; method is not invoked explicitly.</source>
          <target state="translated">&lt;code&gt;gc&lt;/code&gt; 라는 이름 은 &quot;가비지 수집기&quot;를 의미합니다. 가상 머신은 &lt;code&gt;gc&lt;/code&gt; 메소드가 명시 적으로 호출되지 않더라도 필요한 경우 별도의 스레드에서이 재활용 프로세스를 자동으로 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="544bf051094ed67f6eb578a4628c2bb2628ed3d9" translate="yes" xml:space="preserve">
          <source>The name as a list of RDNs which are instances of the class &lt;a href=&quot;rdn&quot;&gt;&lt;code&gt;Rdn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rdn&quot;&gt; &lt;code&gt;Rdn&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 인 RDN리스트로서의 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="c8650bd011ea0967d50e07bf395dc45c6981be8f" translate="yes" xml:space="preserve">
          <source>The name assigned to a tag with an unknown tag number.</source>
          <target state="translated">태그 번호를 알 수없는 태그에 할당 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22c0e5d40dd79969cd82e72465bb3fbde9230b74" translate="yes" xml:space="preserve">
          <source>The name assigned to a tag with an unknown tag number. Such a tag may be created for example when reading an IFD and a tag number is encountered which is not in any of the &lt;code&gt;TIFFTagSet&lt;/code&gt;s known to the reader.</source>
          <target state="translated">태그 번호를 알 수없는 태그에 할당 된 이름입니다. 이러한 태그는 예를 들어 IFD를 읽을 때 생성 될 수 있고 리더에게 알려진 &lt;code&gt;TIFFTagSet&lt;/code&gt; 에 없는 태그 번호가 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b0cc1239625455eae930e65603610fafed91c8" translate="yes" xml:space="preserve">
          <source>The name at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;NameList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if there is no name for the specified index or if the index is out of range.</source>
          <target state="translated">상기 이름 &lt;code&gt;index&lt;/code&gt; 의 위치 일 &lt;code&gt;NameList&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 인덱스가 범위를 벗어나 지정된 인덱스 또는 경우에 이름이없는 경우.</target>
        </trans-unit>
        <trans-unit id="504eb3737ea1138b3f84bac07b01bdfb6961254c" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식이 포함됩니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="211caa8f49b864cd1bbad3bd9135f34a8bd884f4" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setNameConstraints-byte:A-&quot;&gt;&lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식이 포함됩니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setNameConstraints-byte:A-&quot;&gt; &lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7035b9680ba2a5219acc362a95cb6bab9307b7a" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 표시되는 이름 제약 조건의 DER 인코딩 형식이 포함되어 있습니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="10ed19e6f99056d708df9e48318e76d1d9185711" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setNameConstraints(byte%5B%5D)&quot;&gt;&lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 표시되는 이름 제약 조건의 DER 인코딩 형식이 포함되어 있습니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setNameConstraints(byte%5B%5D)&quot;&gt; &lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="89d3f5a0a3d4ea6ce2bb9307cf0651027e621ab6" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식이 포함됩니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b28b918d68df290fd1b094f19e837f8390d6a4e" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 표시되는 이름 제약 조건의 DER 인코딩 형식이 포함되어 있습니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="524b24674014cc8494bd832aa5a756b964afc8ea" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt; and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt; 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약 조건의 DER 인코딩 형식을 포함해야합니다 . 이 구조의 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd71c93b574504f37799ee1431d64b7c869dace9" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280&quot;&gt;RFC 3280&lt;/a&gt; and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280&quot;&gt;RFC 3280&lt;/a&gt; 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함해야합니다 . 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e99975d51bf3d1c8399965f8cf3b760f5a960107" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함해야합니다. 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9e2a9452b3186e3009eca8a0d6a29d10082e447" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약 조건의 DER 인코딩 형식을 포함해야합니다. 이 구조의 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2a86ce9761888022d92a9c1c1d8d272ebe5b60b" translate="yes" xml:space="preserve">
          <source>The name constraints have been violated.</source>
          <target state="translated">이름 제약 조건이 위반되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb5609cf8ee988ed37ea8ec6d46d1aac96bcf30c" translate="yes" xml:space="preserve">
          <source>The name for a &lt;code&gt;SyncProvider&lt;/code&gt; implementation is its fully qualified class name.</source>
          <target state="translated">&lt;code&gt;SyncProvider&lt;/code&gt; 구현 의 이름 은 완전한 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="61219587bf820289ff27cf1e6a6218813200b244" translate="yes" xml:space="preserve">
          <source>The name for a BasicPermission is the name of the given permission (for example, &quot;exit&quot;, &quot;setFactory&quot;, &quot;print.queueJob&quot;, etc). The naming convention follows the hierarchical property naming convention. An asterisk may appear by itself, or if immediately preceded by a &quot;.&quot; may appear at the end of the name, to signify a wildcard match. For example, &quot;*&quot; and &quot;java.*&quot; signify a wildcard match, while &quot;*java&quot;, &quot;a*b&quot;, and &quot;java*&quot; do not.</source>
          <target state="translated">BasicPermission의 이름은 주어진 권한의 이름입니다 (예 : &quot;exit&quot;, &quot;setFactory&quot;, &quot;print.queueJob&quot;등). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 별표가 단독으로 표시되거나 바로 앞에 &quot;.&quot;가 표시 될 수 있습니다. 와일드 카드 일치를 나타 내기 위해 이름 끝에 표시 될 수 있습니다. 예를 들어, &quot;*&quot;및 &quot;java. *&quot;는 와일드 카드 일치를 나타내며 &quot;* java&quot;, &quot;a * b&quot;및 &quot;java *&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db9c2273c564987e782fbfec8a9e4358476a9138" translate="yes" xml:space="preserve">
          <source>The name given to the default logical style attached to paragraphs.</source>
          <target state="translated">단락에 첨부 된 기본 논리 스타일에 지정된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="82ff8cd92cff0415e94e8baa63e9f434898b77cd" translate="yes" xml:space="preserve">
          <source>The name in the binding is to be resolved relative to the event source &lt;code&gt;getEventContext()&lt;/code&gt;. The object returned by &lt;code&gt;Binding.getObject()&lt;/code&gt; may be null if such information is unavailable.</source>
          <target state="translated">바인딩의 이름은 이벤트 소스 &lt;code&gt;getEventContext()&lt;/code&gt; 됩니다. 이러한 정보를 사용할 수없는 경우 &lt;code&gt;Binding.getObject()&lt;/code&gt; 반환 한 객체 가 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc5a2efbe42dd82d80c8a01dba24d15cfd7bf55" translate="yes" xml:space="preserve">
          <source>The name is a &lt;code&gt;String&lt;/code&gt; that corresponds to the name of one of the static &lt;code&gt;SystemColor&lt;/code&gt; fields in the &lt;code&gt;
 SystemColor&lt;/code&gt; class. A name-color pair is created for every such &lt;code&gt;SystemColor&lt;/code&gt; field.</source>
          <target state="translated">이름은 &lt;code&gt; SystemColor&lt;/code&gt; 클래스 의 정적 &lt;code&gt;SystemColor&lt;/code&gt; 필드 중 하나의 이름에 해당 하는 &lt;code&gt;String&lt;/code&gt; 입니다 . 이러한 모든 &lt;code&gt;SystemColor&lt;/code&gt; 필드에 대해 이름-색상 쌍이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9f47c549f8f573a54eea31230a13704fa78151b" translate="yes" xml:space="preserve">
          <source>The name is a URL, or a name to be resolved relative to the initial context, or if the first character of the name is &quot;.&quot;, the name is relative to the context in which the link is bound.</source>
          <target state="translated">이름은 URL이거나 초기 컨텍스트를 기준으로 확인할 이름이거나 이름의 첫 문자가 &quot;.&quot;인 경우 이름은 링크가 바인딩 된 컨텍스트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61679979254cb486e82d74694afb2ea52ea52989" translate="yes" xml:space="preserve">
          <source>The name is finally normalized using normalization form KD, as described in the Unicode Standard and UAX #15</source>
          <target state="translated">이름은 유니 코드 표준 및 UAX # 15에 설명 된대로 정규화 양식 KD를 사용하여 최종적으로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="b349c489e66c9815159d8237cb45765e03ef77a1" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure appears in the documentation for &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열은 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 설명서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b968c3e471f5cb8bcebdf43477ac33f88899fb6" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure appears in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 X.501에 정의 된대로 단일 DER 인코딩 식별 이름이 포함되어야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 문서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d62c30e2e16759f0de7f148ea8688978e4f0848c" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 3280 and X.509. The ASN.1 definition of this structure appears in the documentation for &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 GeneralName 구조에 나타나는 DER 인코딩 이름이 포함되어야합니다. 이 구조의 ASN.1 정의는 &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c854a97c7935726ec4f0b93f3dec6e0b700626" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 3280 and X.509. The encoded byte array should only contain the encoded value of the name, and should not include the tag associated with the name in the GeneralName structure. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 GeneralName 구조에 나타나는 DER 인코딩 이름이 포함되어야합니다. 인코딩 된 바이트 배열은 이름의 인코딩 된 값만 포함해야하며 GeneralName 구조에서 이름과 연관된 태그를 포함하지 않아야합니다. 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a10bc1a5f5762d2806cabd36dd335f7b09913a3" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 5280 and X.509. The ASN.1 definition of this structure appears in the documentation for &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 GeneralName 구조에 나타나는 것처럼 DER로 인코딩 된 이름이 포함되어야합니다. 이 구조의 ASN.1 정의는 &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75d5f67ff4edcf9b1ce9b4351faaa0aba31a87d7" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 5280 and X.509. The encoded byte array should only contain the encoded value of the name, and should not include the tag associated with the name in the GeneralName structure. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 GeneralName 구조에 나타나는 것처럼 DER로 인코딩 된 이름이 포함되어야합니다. 인코딩 된 바이트 배열은 이름의 인코딩 된 값만 포함해야하며 GeneralName 구조의 이름과 관련된 태그를 포함해서는 안됩니다. 이 구조의 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b4157e3b20b0d08a63e804105869ab9b80b570f" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 3280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt; , DNS 및 URI 이름은 해당 유형에 대해 잘 설정된 문자열 형식을 사용합니다 (RFC 3280에 포함 된 제한 사항에 따라). IPv4 주소 이름은 점 쿼드 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉토리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 다른 유형의 이름에는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e0b384b9f6ffae73c057fe6ed3c6f704e7e1ee9" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 5280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt; , DNS 및 URI 이름은 이러한 유형에 대해 잘 설정된 문자열 형식을 사용합니다 (RFC 5280에 포함 된 제한 사항이 적용됨). IPv4 주소 이름은 점으로 된 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉터리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 기타 유형의 이름에 대해서는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="07a1eed59f77ed056220265851c4bb840c68eb88" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. RFC 822, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 3280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;x509certselector#addPathToName-int-byte:A-&quot;&gt;&lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. RFC 822, DNS 및 URI 이름은 RFC 3280에 포함 된 제한 사항에 따라 해당 유형에 대해 잘 설정된 문자열 형식을 사용합니다. IPv4 주소 이름은 점 쿼드 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉토리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 다른 유형의 이름에는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;x509certselector#addPathToName-int-byte:A-&quot;&gt; &lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6019cd3e2b1f21c1ba8c7668ed41fe65ddab9695" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. RFC 822, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 5280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;#addPathToName(int,byte%5B%5D)&quot;&gt;&lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. RFC 822, DNS 및 URI 이름은 이러한 유형에 대해 잘 확립 된 문자열 형식을 사용합니다 (RFC 5280에 포함 된 제한 사항이 적용됨). IPv4 주소 이름은 점으로 구분 된 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉터리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 기타 유형의 이름에 대해서는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;#addPathToName(int,byte%5B%5D)&quot;&gt; &lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="062b23aadb7d34d7c8b4e9c121e5a95a465b4012" translate="yes" xml:space="preserve">
          <source>The name is the name of the property (&quot;java.home&quot;, &quot;os.name&quot;, etc). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;java.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*java&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">이름은 속성의 이름입니다 ( &quot;java.home&quot;, &quot;os.name&quot;등). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어, &quot;java. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* java&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfa54156ec30f9bc348736a478f8a06c98b8284b" translate="yes" xml:space="preserve">
          <source>The name must conform to RFC 2965. That means it can contain only ASCII alphanumeric characters and cannot contain commas, semicolons, or white space or begin with a $ character. The cookie's name cannot be changed after creation.</source>
          <target state="translated">이름은 RFC 2965를 준수해야합니다. 즉, ASCII 영숫자 문자 만 포함 할 수 있으며 쉼표, 세미콜론 또는 공백을 포함하거나 $ 문자로 시작할 수 없습니다. 쿠키 이름은 생성 후 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="996c6de93ebccc7b84117ecaee62f38d7311a913" translate="yes" xml:space="preserve">
          <source>The name of DTD; i.e., the name immediately following the &lt;code&gt;DOCTYPE&lt;/code&gt; keyword.</source>
          <target state="translated">DTD의 이름. 즉, &lt;code&gt;DOCTYPE&lt;/code&gt; 키워드 바로 뒤에 오는 이름 .</target>
        </trans-unit>
        <trans-unit id="a0b966f42feea9c33f3253f299c07faeb601d6d2" translate="yes" xml:space="preserve">
          <source>The name of a generic type does not include any reference to its formal type parameters. For example, the fully qualified name of the interface &lt;code&gt;java.util.Set&amp;lt;E&amp;gt;&lt;/code&gt; is &quot;&lt;code&gt;java.util.Set&lt;/code&gt;&quot;. Nested types use &quot;&lt;code&gt;.&lt;/code&gt;&quot; as a separator, as in &quot;&lt;code&gt;java.util.Map.Entry&lt;/code&gt;&quot;.</source>
          <target state="translated">제네릭 형식의 이름에는 형식 형식 매개 변수에 대한 참조가 포함되어 있지 않습니다. 예를 들어, 인터페이스 &lt;code&gt;java.util.Set&amp;lt;E&amp;gt;&lt;/code&gt; 의 완전한 이름 은 &quot; &lt;code&gt;java.util.Set&lt;/code&gt; &quot;입니다. 중첩 유형 은 &quot; &lt;code&gt;java.util.Map.Entry&lt;/code&gt; &quot; 에서와 같이 &quot; &lt;code&gt;.&lt;/code&gt; &quot;을 분리 자로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="586a3e128f97fabfbfbfd557a68c800759fa8523" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the bound server name for an unbound server.</source>
          <target state="translated">바인딩되지 않은 서버의 바인딩 된 서버 이름을 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f50fffd870d393ff1d83992d3375d9ebcd02098f" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the bound server name for an unbound server. A server is created as an unbound server by setting the &lt;code&gt;serverName&lt;/code&gt; argument in &lt;a href=&quot;#createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)&quot;&gt;&lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt;&lt;/a&gt; as null. The property contains the bound host name after the authentication exchange has completed. It is only available on the server side.</source>
          <target state="translated">바인딩되지 않은 서버의 바인딩 된 서버 이름을 지정하는 속성의 이름입니다. 서버는 &lt;a href=&quot;#createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)&quot;&gt; &lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;serverName&lt;/code&gt; 인수를 설정하여 언 바운드 서버로 생성됩니다. .security.auth.callback.CallbackHandler) 를 null로 지정합니다. 속성에는 인증 교환이 완료된 후 바인딩 된 호스트 이름이 포함됩니다. 서버 측에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc7a8ad79c2d57c4b3606f2370da251a94ec44b" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the bound server name for an unbound server. A server is created as an unbound server by setting the &lt;code&gt;serverName&lt;/code&gt; argument in &lt;a href=&quot;sasl#createSaslServer-java.lang.String-java.lang.String-java.lang.String-java.util.Map-javax.security.auth.callback.CallbackHandler-&quot;&gt;&lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt;&lt;/a&gt; as null. The property contains the bound host name after the authentication exchange has completed. It is only available on the server side.</source>
          <target state="translated">바인딩되지 않은 서버에 대한 바인딩 된 서버 이름을 지정하는 속성의 이름입니다. 서버는 &lt;a href=&quot;sasl#createSaslServer-java.lang.String-java.lang.String-java.lang.String-java.util.Map-javax.security.auth.callback.CallbackHandler-&quot;&gt; &lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;serverName&lt;/code&gt; 인수를 설정하여 언 바운드 서버로 작성됩니다. .security.auth.callback.CallbackHandler) 를 null로 반환합니다 . 인증 교환이 완료된 후 속성에 바인딩 된 호스트 이름이 포함됩니다. 서버 측에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b55f9b70a02e260dfa3c61e0194b4235bd08a1d" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the cipher strength to use.</source>
          <target state="translated">사용할 암호 강도를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="31543f2d17616a509f1542da77a0190a933ae420" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the cipher strength to use. The property contains a comma-separated, ordered list of cipher strength values that the client or server is willing to support. A strength value is one of</source>
          <target state="translated">사용할 암호 강도를 지정하는 특성의 이름입니다. 이 속성에는 클라이언트 또는 서버가 지원할 쉼표로 구분 된 순서의 암호 수준 값 목록이 포함됩니다. 강도 값은</target>
        </trans-unit>
        <trans-unit id="a910b5b12f169a8c9e6299db186743853fa9fd06" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the credentials to use.</source>
          <target state="translated">사용할 자격 증명을 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="55e2920c36428c57f886e32853d1f39a8e1f86e0" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the credentials to use. The property contains a mechanism-specific Java credential object. Mechanism implementations may examine the value of this property to determine whether it is a class that they support. The property may be used to supply credentials to a mechanism that supports delegated authentication.</source>
          <target state="translated">사용할 자격 증명을 지정하는 속성의 이름입니다. 이 특성에는 메커니즘 별 Java 신임 오브젝트가 포함되어 있습니다. 메커니즘 구현에서는이 속성의 값을 검사하여 해당 속성이 지원하는 클래스인지 확인할 수 있습니다. 이 속성은 위임 된 인증을 지원하는 메커니즘에 자격 증명을 제공하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2501b67874585ca960fda8402bd14c813cfae62" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the raw send buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;.</source>
          <target state="translated">원시 전송 버퍼의 최대 크기 (바이트)를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 로 지정하는 속성의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="56b920153e04b83edb9986c955cfd7fb277a67ff" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the raw send buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;. The property contains the string representation of an integer. The value of this property is negotiated between the client and server during the authentication exchange.</source>
          <target state="translated">원시 전송 버퍼의 최대 크기를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 지정하는 특성의 이름입니다 . 이 속성에는 정수의 문자열 표현이 포함됩니다. 이 속성의 값은 인증 교환 중에 클라이언트와 서버간에 협상됩니다.</target>
        </trans-unit>
        <trans-unit id="50ebc98595175a09096a08393ea23c009230db69" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the receive buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 수신 버퍼의 최대 크기를 지정하는 속성의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="5e65556f8d43cf173606f56669dc9e1376a6357a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the receive buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;. The property contains the string representation of an integer.</source>
          <target state="translated">수신 버퍼의 최대 크기를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 지정하는 특성의 이름입니다 . 이 속성에는 정수의 문자열 표현이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1a5b3e7cc0cb1dea4bf1a55bf0bf2a3076634087" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the quality-of-protection to use.</source>
          <target state="translated">사용할 보호 품질을 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7c2208ad557360dbabcdcb1796613d7ab45b49c2" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the quality-of-protection to use. The property contains a comma-separated, ordered list of quality-of-protection values that the client or server is willing to support. A qop value is one of</source>
          <target state="translated">사용할 보호 수준을 지정하는 속성의 이름입니다. 이 속성에는 클라이언트 또는 서버가 지원할 쉼표로 구분 된 순서대로 보호 품질 값 목록이 포함됩니다. qop 값은</target>
        </trans-unit>
        <trans-unit id="cd8f19eb65ae48b796032fae90788d4c582fd1e0" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to active (non-dictionary) attacks are not permitted.</source>
          <target state="translated">활성 (사전이 아닌) 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b8d78b06c714a7846430cd85289564a8ba25548a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to active (non-dictionary) attacks are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms susceptible to active attacks are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">활성 (사전이 아닌) 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다. 활성 공격에 취약한 메커니즘이 허용되지 않으면 이 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ef96d0876dd10348f8c1f12dd21e6f2560d1563" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to passive dictionary attacks are not permitted.</source>
          <target state="translated">수동 사전 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7ccacffcd7e795c6f2158de9fc95195180770467" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to passive dictionary attacks are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms susceptible to dictionary attacks are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">수동 사전 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다. 사전 공격에 취약한 메커니즘이 허용되지 않으면 이 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="abaa82f841676a61897a58942179bb4b525225bf" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to simple plain passive attacks (e.g., &quot;PLAIN&quot;) are not permitted.</source>
          <target state="translated">단순 일반 수동 공격 (예 : &quot;PLAIN&quot;)에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6b6e642921edcbb0aeb070dc85a3fae28c660e0e" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to simple plain passive attacks (e.g., &quot;PLAIN&quot;) are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if such mechanisms are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">단순한 일반 수동 공격에 취약한 메커니즘 (예 : &quot;PLAIN&quot;)이 허용되지 않는지 여부를 지정하는 속성의 이름입니다. 이러한 메커니즘이 허용되지 않으면 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2be230b027b47e8ceacad313b7a595b8ba10cde" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that accept anonymous login are not permitted.</source>
          <target state="translated">익명 로그인을 허용하는 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f4fcba71a86df30c02372fc37f3f03794d3958d1" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that accept anonymous login are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that accept anonymous login are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">익명 로그인을 허용하는 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다. 익명 로그인을 허용하는 메커니즘이 허용되지 않으면 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="011a1d9f0a1619c5f4de3beca91ad9ce6660674c" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that implement forward secrecy between sessions are required.</source>
          <target state="translated">세션간에 순방향 보안을 구현하는 메커니즘이 필요한지 여부를 지정하는 특성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="06776ce760218a8bb3c69a553b99504e2368a22b" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that implement forward secrecy between sessions are required. Forward secrecy means that breaking into one session will not automatically provide information for breaking into future sessions. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that implement forward secrecy between sessions are required; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are not required. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">세션 사이에 포워드 보안을 구현하는 메커니즘이 필요한지 여부를 지정하는 특성의 이름입니다. 순방향 비밀은 한 세션으로 침입해도 향후 세션으로 침입하기위한 정보를 자동으로 제공하지 않음을 의미합니다. 세션간에 순방향 비밀을 구현하는 메커니즘이 필요한 경우이 속성에는 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 필요하지 않은 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ab394d56b4345203ccd73fb6be21a6d4fbda32a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that pass client credentials are required.</source>
          <target state="translated">클라이언트 자격 증명을 전달하는 메커니즘이 필요한지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0ce55bb11912a17b35cd30b5ec6b2d3629fbdf83" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that pass client credentials are required. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that pass client credentials are required; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are not required. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">클라이언트 자격 증명을 전달하는 메커니즘이 필요한지 여부를 지정하는 속성의 이름입니다. 클라이언트 자격 증명을 전달하는 메커니즘이 필요한 경우 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 필요하지 않은 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="576ff001ae8f0589bede75beb4f725c2066586f4" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether the server must authenticate to the client.</source>
          <target state="translated">서버가 클라이언트에 인증해야하는지 여부를 지정하는 특성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="11148564aae0a7b5ceb776e3ad9122d4f8cc5031" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether the server must authenticate to the client. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if the server must authenticate the to client; &lt;code&gt;&quot;false&quot;&lt;/code&gt; otherwise. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">서버가 클라이언트를 인증해야하는지 여부를 지정하는 특성의 이름입니다. 서버가 클라이언트를 인증해야하는 경우 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그렇지 않으면 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="832866552eccab3a6d070c63001ca0fadd95eee1" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether to reuse previously authenticated session information.</source>
          <target state="translated">이전에 인증 된 세션 정보를 재사용할지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f8afde55a67986c5517be4ac59b9842900fb0c1e" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether to reuse previously authenticated session information. The property contains &quot;true&quot; if the mechanism implementation may attempt to reuse previously authenticated session information; it contains &quot;false&quot; if the implementation must not reuse previously authenticated session information. A setting of &quot;true&quot; serves only as a hint: it does not necessarily entail actual reuse because reuse might not be possible due to a number of reasons, including, but not limited to, lack of mechanism support for reuse, expiration of reusable information, and the peer's refusal to support reuse. The property's default value is &quot;false&quot;. The value of this constant is &quot;javax.security.sasl.reuse&quot;. Note that all other parameters and properties required to create a SASL client/server instance must be provided regardless of whether this property has been supplied. That is, you cannot supply any less information in anticipation of reuse. Mechanism implementations that support reuse might allow customization of its implementation, for factors such as cache size, timeouts, and criteria for reusability. Such customizations are implementation-dependent.</source>
          <target state="translated">이전에 인증 된 세션 정보를 재사용할지 여부를 지정하는 특성의 이름입니다. 메커니즘 구현이 이전에 인증 된 세션 정보를 재사용하려고 시도 할 수있는 경우 특성에 &quot;true&quot;가 포함됩니다. 구현에서 이전에 인증 된 세션 정보를 재사용하지 않아야하는 경우 &quot;false&quot;를 포함합니다. &quot;true&quot;로 설정하면 힌트로만 사용됩니다. 재사용에 대한 메커니즘 지원 부족, 재사용 가능한 정보의 만료 등 여러 가지 이유로 재사용이 불가능할 수 있기 때문에 실제 재사용이 반드시 필요한 것은 아닙니다. , 동료의 재사용 지원 거부. 속성의 기본값은 &quot;false&quot;입니다. 이 상수의 값은 &quot;javax.security.sasl.reuse&quot;입니다.SASL 클라이언트 / 서버 인스턴스를 작성하는 데 필요한 다른 모든 매개 변수 및 특성은이 특성의 제공 여부에 관계없이 제공되어야합니다. 즉, 재사용을 예상 할 때 더 적은 정보를 제공 할 수 없습니다. 재사용을 지원하는 메커니즘 구현은 캐시 크기, 제한 시간 및 재사용 성 기준과 같은 요소에 대해 구현을 사용자 정의 할 수 있습니다. 이러한 사용자 지정은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="883225677e8f8e5b399c448f823a43abbfc061ea" translate="yes" xml:space="preserve">
          <source>The name of a resource is a '&lt;code&gt;/&lt;/code&gt;'-separated path name that identifies the resource.</source>
          <target state="translated">자원의 이름은 자원 을 식별 하는 ' &lt;code&gt;/&lt;/code&gt; '로 구분 된 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a515910aa70c3ebcc7ce4ca607dd0dd4f6d0da22" translate="yes" xml:space="preserve">
          <source>The name of a resource is a &lt;code&gt;/&lt;/code&gt;-separated path name that identifies the resource.</source>
          <target state="translated">자원의 이름은 자원 을 식별 하는 &lt;code&gt;/&lt;/code&gt; 로 구분 된 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6c6bde9766a09b2f3be7c967965b9ca843d70a67" translate="yes" xml:space="preserve">
          <source>The name of a type declared for the associated element or attribute, or &lt;code&gt;null&lt;/code&gt; if unknown.</source>
          <target state="translated">연관된 요소 또는 속성에 대해 선언 된 유형의 이름 또는 알 수없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fe25ce1fcf2cee52aa157f625ee02fa6e4aef934" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#defaultValue&quot;&gt;&lt;code&gt;
 defaultValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#defaultValue&quot;&gt; &lt;code&gt; defaultValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="02a87ad296b6a16e86ed792fcd23b2d436a8aa38" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#defaultValue&quot;&gt;&lt;code&gt;defaultValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#defaultValue&quot;&gt; &lt;code&gt;defaultValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="fb29c322db8f3271ac67d4a85fa88b1e19ea74b5" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;
 immutableInfo&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt; immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="21a7183405f994f4abb54ab06bb8d0ca6abd1b33" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;immutableInfo&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt;immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="28b747c7a3c7144aafa0ddadca50daced5ec5e60" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#interfaceClassName&quot;&gt;&lt;code&gt;
 interfaceClassName&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#interfaceClassName&quot;&gt; &lt;code&gt; interfaceClassName&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="4cae14c94ea437e28b95eb63b65b9dc19f3b9961" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#interfaceClassName&quot;&gt;&lt;code&gt;interfaceClassName&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#interfaceClassName&quot;&gt; &lt;code&gt;interfaceClassName&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="07f75e785cf9779fd44ac44a3329126cabda2bbe" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#legalValues&quot;&gt;&lt;code&gt;
 legalValues&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#legalValues&quot;&gt; &lt;code&gt; legalValues&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="9fe458bf94e08c2715db3ba7353f7b20a329fde6" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#legalValues&quot;&gt;&lt;code&gt;legalValues&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#legalValues&quot;&gt; &lt;code&gt;legalValues&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="95ff2b82f6409c0303045938f829f414f57885eb" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#maxValue&quot;&gt;&lt;code&gt;
 maxValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#maxValue&quot;&gt; &lt;code&gt; maxValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="7f056bc651ef11844698474a4860bfd2b3c8422c" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#maxValue&quot;&gt;&lt;code&gt;maxValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#maxValue&quot;&gt; &lt;code&gt;maxValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="20b8df24d89b15e474968793eeae1e9cf0905d5a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#minValue&quot;&gt;&lt;code&gt;
 minValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#minValue&quot;&gt; &lt;code&gt; minValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="b5458eeba59dcfbb2d86cb008e54ef4459974966" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#minValue&quot;&gt;&lt;code&gt;minValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#minValue&quot;&gt; &lt;code&gt;minValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="3c360c1088b36522f6e8ac159e1dc3bfafdadb44" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#mxbean&quot;&gt;&lt;code&gt;
 mxbean&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#mxbean&quot;&gt; &lt;code&gt; mxbean&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="3d12e5d2c43700fffd1f2acdcc9bfb6314cfa143" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#mxbean&quot;&gt;&lt;code&gt;mxbean&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#mxbean&quot;&gt; &lt;code&gt;mxbean&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="b2306786e35b8dc8113a90bb0b9bfcaebbbb4111" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#openType&quot;&gt;&lt;code&gt;
 openType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#openType&quot;&gt; &lt;code&gt; openType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="c0f4d31dececcf3cbe425b7676d150fa31bfc39e" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#openType&quot;&gt;&lt;code&gt;openType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#openType&quot;&gt; &lt;code&gt;openType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="ce2f69899ea3f7db305ee78fde5c0731069c8dcd" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#originalType&quot;&gt;&lt;code&gt;
 originalType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#originalType&quot;&gt; &lt;code&gt; originalType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="019614432873d92a45cf0bd7b968f9482692078a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#originalType&quot;&gt;&lt;code&gt;originalType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#originalType&quot;&gt; &lt;code&gt;originalType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="48744229149f107d48a57a9a32fe47303158d512" translate="yes" xml:space="preserve">
          <source>The name of the Cryptography Package Provider is designated also by the Signature parameter to the constructor and the &lt;code&gt;verify&lt;/code&gt; method. If the provider is not specified, the default provider is used. Each installation can be configured to use a particular provider as default.</source>
          <target state="translated">암호화 패키지 제공자의 이름은 Signature 매개 변수에 의해 생성자와 &lt;code&gt;verify&lt;/code&gt; 메소드 에도 지정됩니다 . 공급자를 지정하지 않으면 기본 공급자가 사용됩니다. 각 설치는 특정 공급자를 기본값으로 사용하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3374bc67db57b47fa67041ab369a402111b546bf" translate="yes" xml:space="preserve">
          <source>The name of the MBean within the MBean server to which methods are forwarded.</source>
          <target state="translated">메소드가 전달되는 MBean 서버 내의 MBean 이름.</target>
        </trans-unit>
        <trans-unit id="e603cbb804d9eb28de3e80c8071713281c1279aa" translate="yes" xml:space="preserve">
          <source>The name of the action for the key.</source>
          <target state="translated">키에 대한 작업의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c8664e99ba0ec714f65189ef121b50d48bf752bb" translate="yes" xml:space="preserve">
          <source>The name of the associated notation.</source>
          <target state="translated">연관된 표기법의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="097c841c5ffaa4f483a66be7178ea3a98d83fcc8" translate="yes" xml:space="preserve">
          <source>The name of the built-in system class loader is &lt;code&gt;&quot;app&quot;&lt;/code&gt;. The system property &quot;&lt;code&gt;java.class.path&lt;/code&gt;&quot; is read during early initialization of the VM to determine the class path. An empty value of &quot;&lt;code&gt;java.class.path&lt;/code&gt;&quot; property is interpreted differently depending on whether the initial module (the module containing the main class) is named or unnamed: If named, the built-in system class loader will have no class path and will search for classes and resources using the application module path; otherwise, if unnamed, it will set the class path to the current working directory.</source>
          <target state="translated">내장 시스템 클래스 로더의 이름은 &lt;code&gt;&quot;app&quot;&lt;/code&gt; 입니다. 클래스 경로를 판별하기 위해 VM의 초기 초기화 중에 시스템 특성 &quot; &lt;code&gt;java.class.path&lt;/code&gt; &quot;를 읽습니다. &quot; &lt;code&gt;java.class.path&lt;/code&gt; &quot;속성 의 빈 값은 초기 모듈 (메인 클래스를 포함하는 모듈)의 이름이 지정되었는지 여부에 따라 다르게 해석됩니다. 이름이 지정되면 내장 시스템 클래스 로더에 클래스 경로가 없으며 응용 프로그램 모듈 경로를 사용하여 클래스와 리소스를 검색합니다. 그렇지 않으면 이름이 지정되지 않은 경우 클래스 경로를 현재 작업 디렉토리로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="59571c11a8a61f5087536ca331e870fbc1bf9620" translate="yes" xml:space="preserve">
          <source>The name of the builtin platform class loader is &lt;code&gt;&quot;platform&quot;&lt;/code&gt;.</source>
          <target state="translated">내장 플랫폼 클래스 로더의 이름은 &lt;code&gt;&quot;platform&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a80646cd5cb31601fc4aac5527e3c066f071889e" translate="yes" xml:space="preserve">
          <source>The name of the class implementing &lt;code&gt;IIOMetadataFormat&lt;/code&gt; and representing the native metadata format, initialized to &lt;code&gt;null&lt;/code&gt; and set via the constructor.</source>
          <target state="translated">&lt;code&gt;IIOMetadataFormat&lt;/code&gt; 을 구현 하고 기본 메타 데이터 형식을 나타내는 클래스 이름 으로, &lt;code&gt;null&lt;/code&gt; 로 초기화되고 생성자를 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="87c36c4524553c04fdf7d1a5553c3ac41e742c7f" translate="yes" xml:space="preserve">
          <source>The name of the code generator</source>
          <target state="translated">코드 생성기의 이름</target>
        </trans-unit>
        <trans-unit id="14628be31dd329e555df1f6bfb10c67eaffa4605" translate="yes" xml:space="preserve">
          <source>The name of the country appropriate to the given locale.</source>
          <target state="translated">주어진 로케일에 적합한 국가 이름.</target>
        </trans-unit>
        <trans-unit id="4acb982db435eb2721de142ef807bacda4ac4425" translate="yes" xml:space="preserve">
          <source>The name of the country appropriate to the locale.</source>
          <target state="translated">로케일에 적합한 국가 이름.</target>
        </trans-unit>
        <trans-unit id="78358406b490b90c985dd9db549b2619ef569e50" translate="yes" xml:space="preserve">
          <source>The name of the default event set is used to calculate its &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of event sets defined in the annotated class.</source>
          <target state="translated">기본 이벤트 세트의 이름은 어노테이션이있는 클래스에 정의 된 이벤트 세트 의 &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 을 계산하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="04ac24816aef6488806c42c595d2915ed924cca8" translate="yes" xml:space="preserve">
          <source>The name of the default event set is used to calculate its &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of event sets defined in the annotated class. If the name is not set or the annotated class does not define an event set with the specified name, the default event set index will be calculated automatically by the &lt;a href=&quot;introspector&quot;&gt;&lt;code&gt;Introspector&lt;/code&gt;&lt;/a&gt; depending on its state.</source>
          <target state="translated">기본 이벤트 세트의 이름은 어노테이션이있는 클래스에 정의 된 이벤트 세트 의 &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 을 계산하는 데 사용됩니다 . 이름이 설정되지 않았거나 주석이 추가 된 클래스가 지정된 이름으로 이벤트 세트를 정의하지 않는 경우 기본 이벤트 세트 인덱스는 상태에 따라 &lt;a href=&quot;introspector&quot;&gt; &lt;code&gt;Introspector&lt;/code&gt; 에서&lt;/a&gt; 자동으로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ce6ce57d1833563bb66734286a352e834e326ed" translate="yes" xml:space="preserve">
          <source>The name of the default property is used to calculate its &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of properties defined in the annotated class.</source>
          <target state="translated">기본 속성의 이름은 계산하는 데 사용되는 &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 주석 클래스에 정의 된 속성.</target>
        </trans-unit>
        <trans-unit id="086957e2f5e5ccd35b93f7fa6892198bfd1505fe" translate="yes" xml:space="preserve">
          <source>The name of the default property is used to calculate its &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of properties defined in the annotated class. If the name is not set or the annotated class does not define a property with the specified name, the default property index will be calculated automatically by the &lt;a href=&quot;introspector&quot;&gt;&lt;code&gt;Introspector&lt;/code&gt;&lt;/a&gt; depending on its state.</source>
          <target state="translated">기본 속성의 이름은 계산하는 데 사용되는 &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 주석 클래스에 정의 된 속성. 이름이 설정되지 않았거나 주석이 달린 클래스가 지정된 이름을 가진 속성을 정의하지 않는 경우 기본 속성 인덱스는 상태에 따라 &lt;a href=&quot;introspector&quot;&gt; &lt;code&gt;Introspector&lt;/code&gt; 에서&lt;/a&gt; 자동으로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bb84751719d943c1bdfe595f0b620fdf05a9b4b" translate="yes" xml:space="preserve">
          <source>The name of the display language appropriate to the given locale.</source>
          <target state="translated">지정된 로케일에 적합한 표시 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="60b08c752ba73a8a294eb2dc32a69396a5bd0e3a" translate="yes" xml:space="preserve">
          <source>The name of the display language.</source>
          <target state="translated">표시 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0cef399fec1ed02c817bd26adc657c6bf0cd05e8" translate="yes" xml:space="preserve">
          <source>The name of the display variant code appropriate to the given locale.</source>
          <target state="translated">지정된 로케일에 적합한 디스플레이 변형 코드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c6f8f604377a983983396835745055e795e7955c" translate="yes" xml:space="preserve">
          <source>The name of the display variant code appropriate to the locale.</source>
          <target state="translated">로케일에 적합한 디스플레이 변형 코드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="24528e36b7470855aa32b59a5449546f41560454" translate="yes" xml:space="preserve">
          <source>The name of the element</source>
          <target state="translated">요소의 이름</target>
        </trans-unit>
        <trans-unit id="fc747a0011536738e1fa0490d7d958b96f02eb2a" translate="yes" xml:space="preserve">
          <source>The name of the element.</source>
          <target state="translated">요소의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6b3f6644531a48b6304ed514d2bea39651f0ab46" translate="yes" xml:space="preserve">
          <source>The name of the element. If &lt;code&gt;Node.localName&lt;/code&gt; is different from &lt;code&gt;null&lt;/code&gt;, this attribute is a qualified name. For example, in:</source>
          <target state="translated">요소의 이름입니다. 경우 &lt;code&gt;Node.localName&lt;/code&gt; 가 다른 &lt;code&gt;null&lt;/code&gt; ,이 속성은 수식 명입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="120a36a79f97ac5cca7e6072a7f24815aa4e4e51" translate="yes" xml:space="preserve">
          <source>The name of the engine implementation.</source>
          <target state="translated">엔진 구현의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f75476630adc7537ab0942d349040825c278cc3c" translate="yes" xml:space="preserve">
          <source>The name of the entity</source>
          <target state="translated">실체의 이름</target>
        </trans-unit>
        <trans-unit id="97d6f3b8c4207b3258c6fdf35439ec4e64a6b33f" translate="yes" xml:space="preserve">
          <source>The name of the entity.</source>
          <target state="translated">엔터티의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="47e223e8c5fe87dc2f017ef2eabcb21daf87ceb2" translate="yes" xml:space="preserve">
          <source>The name of the event (case-insensitive).</source>
          <target state="translated">이벤트 이름 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="e7cc9e48bd592ef36c17b71fc57758920bbb168c" translate="yes" xml:space="preserve">
          <source>The name of the event (case-insensitive). The name must be an XML name.</source>
          <target state="translated">이벤트 이름 (대소 문자 구분 안함). 이름은 XML 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d3af95a63e43cd17e9a6cea712564b8e6527a909" translate="yes" xml:space="preserve">
          <source>The name of the feature.</source>
          <target state="translated">기능의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9e5fd5b90df7480a7c2fc85c88ad6342ff889328" translate="yes" xml:space="preserve">
          <source>The name of the feature. It is recommended that subclasses call &lt;a href=&quot;#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; rather than reading this field, and that they not change it.</source>
          <target state="translated">기능의 이름입니다. 서브 클래스는 이 필드를 읽는 대신 &lt;a href=&quot;#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 호출 하고 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95a2547de9061a70c8901a9a9ae8316a19182943" translate="yes" xml:space="preserve">
          <source>The name of the feature. It is recommended that subclasses call &lt;a href=&quot;mbeanfeatureinfo#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; rather than reading this field, and that they not change it.</source>
          <target state="translated">기능의 이름입니다. 서브 클래스는 이 필드를 읽지 않고 &lt;a href=&quot;mbeanfeatureinfo#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 호출 하고 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="94428221f570bbc866fd9fb07f0332af0c0604fc" translate="yes" xml:space="preserve">
          <source>The name of the file or directory denoted by this abstract pathname, or the empty string if this pathname's name sequence is empty</source>
          <target state="translated">이 추상 경로명이 나타내는 파일 또는 디렉토리의 이름, 또는이 경로명의 이름 순서가 비어있는 경우는 빈 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="358d802fea6719e80e2748acb46d55d47944cf81" translate="yes" xml:space="preserve">
          <source>The name of the file. Normally this would be simply &lt;code&gt;f.getName()&lt;/code&gt;.</source>
          <target state="translated">파일의 이름입니다. 일반적으로 이것은 단순히 &lt;code&gt;f.getName()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01c9c4139ce4fa623ad1d25aaa2f563884a126a5" translate="yes" xml:space="preserve">
          <source>The name of the getter method in the annotated class, which returns the corresponding Swing container, if it is not recommended to add subcomponents to the annotated class directly.</source>
          <target state="translated">어노테이션이있는 클래스에 직접 하위 컴포넌트를 추가하는 것이 권장되지 않는 경우 해당하는 Swing 컨테이너를 리턴하는 어노테이션이있는 클래스의 getter 메소드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6184eca693cfe52fc5392fc61940fe51c58be9b4" translate="yes" xml:space="preserve">
          <source>The name of the indexed attribute, or null if the index is out of range.</source>
          <target state="translated">색인화 된 속성의 이름 또는 색인이 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="78e529e47375c2632b7b035e64454552347f35c2" translate="yes" xml:space="preserve">
          <source>The name of the keystore's JCE provider.</source>
          <target state="translated">키 스토어의 JCE 프로 바이더의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="710b3a74bf068fa8de9ebf8e26c80f7f253ab602" translate="yes" xml:space="preserve">
          <source>The name of the locale appropriate to display.</source>
          <target state="translated">표시 할 로케일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dc4668583967ec894c4fc99eff383fa78666fc18" translate="yes" xml:space="preserve">
          <source>The name of the log level of the specified logger; or an empty string if the log level of the specified logger is &lt;code&gt;null&lt;/code&gt;. If the specified logger does not exist, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 로거의 로그 레벨 이름입니다. 또는 지정된 로거의 로그 레벨은 빈 문자열 인 경우 &lt;code&gt;null&lt;/code&gt; . 지정된 로거가 없으면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb2d73104061df95f17818382bae8dff8ab298b0" translate="yes" xml:space="preserve">
          <source>The name of the m-let registered.</source>
          <target state="translated">등록 된 m-let의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="093ff0ae78d61a47dcf7ef6063cf858716b59de9" translate="yes" xml:space="preserve">
          <source>The name of the memory pool.</source>
          <target state="translated">메모리 풀의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c7ad1c87eb9dcdbd25ae935d16c25ad0f224ed52" translate="yes" xml:space="preserve">
          <source>The name of the method is denoted by the &quot;method&quot; attribute.</source>
          <target state="translated">메소드의 이름은 &quot;method&quot;속성으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a672ec3f5d7f1814d41e28cb442fc9ba334b3bdc" translate="yes" xml:space="preserve">
          <source>The name of the monitor MBean registered.</source>
          <target state="translated">등록 된 모니터 MBean의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c291f6decb6f8d5426876dff90ab34f56da868c4" translate="yes" xml:space="preserve">
          <source>The name of the native metadata format for this object, initialized to &lt;code&gt;null&lt;/code&gt; and set via the constructor.</source>
          <target state="translated">이 객체의 고유 메타 데이터 형식의 이름으로, &lt;code&gt;null&lt;/code&gt; 로 초기화되고 생성자를 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ac5280a7663692ad6dd0a6b4111143acc66a2b08" translate="yes" xml:space="preserve">
          <source>The name of the package is derived from the &lt;a href=&quot;class#getName()&quot;&gt;binary names&lt;/a&gt; of the classes. Since classes in a named module must be in a named package, the derived name is never empty.</source>
          <target state="translated">패키지 &lt;a href=&quot;class#getName()&quot;&gt;이름&lt;/a&gt; 은 클래스 의 이진 이름 에서 파생됩니다 . 명명 된 모듈의 클래스는 명명 된 패키지에 있어야하므로 파생 된 이름은 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b13ee813ed632277885f5a6dd137f0cfb5e8df51" translate="yes" xml:space="preserve">
          <source>The name of the package is either &lt;code&gt;&quot;&quot;&lt;/code&gt; (for classes in an unnamed package) or derived from the &lt;a href=&quot;class#getName()&quot;&gt;binary names&lt;/a&gt; of the classes (for classes in a named package).</source>
          <target state="translated">패키지 이름은 &lt;code&gt;&quot;&quot;&lt;/code&gt; (이름이 지정되지 않은 패키지에있는 클래스의 경우)이거나 클래스 의 &lt;a href=&quot;class#getName()&quot;&gt;이진 이름 (이름&lt;/a&gt; 이 지정된 패키지에있는 클래스의 경우) 에서 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec919114b57c6c6f0bddee6582f54e56c541ab2a" translate="yes" xml:space="preserve">
          <source>The name of the parameter, either provided by the class file or synthesized if the class file does not provide a name.</source>
          <target state="translated">클래스 파일에서 제공하거나 클래스 파일이 이름을 제공하지 않으면 합성되는 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="76dbce8fae53c29781d96a2d788eef7df5a5de9f" translate="yes" xml:space="preserve">
          <source>The name of the processing instruction that is sent if the result tree disables output escaping.</source>
          <target state="translated">결과 트리가 출력 이스케이프를 비활성화하는 경우 전송되는 처리 명령의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="16abcde6d38a72eae8ef0428bcfea1f17bf5c47a" translate="yes" xml:space="preserve">
          <source>The name of the processing instruction that is sent if the result tree enables output escaping at some point after having received a PI_DISABLE_OUTPUT_ESCAPING processing instruction.</source>
          <target state="translated">PI_DISABLE_OUTPUT_ESCAPING 처리 명령을 수신 한 후 결과 트리가 출력 이스케이프를 활성화하는 경우 전송되는 처리 명령의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ac3506b2a41d26429a561490d65dccec37908ee6" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
          <target state="translated">속성의 이름</target>
        </trans-unit>
        <trans-unit id="887faaf33b50c35d7b160d10047016054616f44d" translate="yes" xml:space="preserve">
          <source>The name of the provider is supplied on the command line, which will add the provider to the system properties. For example:</source>
          <target state="translated">공급자의 이름은 명령 줄에 제공되어 공급자를 시스템 속성에 추가합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="0fde951d6d267c7761faf39ef1278ab5b4594efa" translate="yes" xml:space="preserve">
          <source>The name of the resolved object, relative to &lt;code&gt;altNameCtx&lt;/code&gt;. It is a composite name. If null, then no name is specified.</source>
          <target state="translated">&lt;code&gt;altNameCtx&lt;/code&gt; 에 상대적인 해결 된 객체의 이름입니다 . 합성 이름입니다. null의 경우는 이름이 지정되지 않는다</target>
        </trans-unit>
        <trans-unit id="cd1bd73ac27aa215798a1528ac7cb6d12a80bc26" translate="yes" xml:space="preserve">
          <source>The name of the resource that the reference points to. It can link to any compatible resource using the global JNDI names.</source>
          <target state="translated">참조가 가리키는 자원의 이름입니다. 글로벌 JNDI 이름을 사용하여 호환 가능한 모든 자원에 링크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea9beb0c3bba4aa9b71ab429f16da92aee27b15" translate="yes" xml:space="preserve">
          <source>The name of the stub class to load is determined by concatenating the binary name of the root class with the suffix &lt;code&gt;_Stub&lt;/code&gt;.</source>
          <target state="translated">로드 할 스텁 클래스의 이름은 루트 클래스의 이진 이름을 접미사 &lt;code&gt;_Stub&lt;/code&gt; 과 연결하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1292f65aa82f44923949346d4e1e691d616e2a33" translate="yes" xml:space="preserve">
          <source>The name of the supported language.</source>
          <target state="translated">지원되는 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ea3ee1b66718d70c98586654a55a17d890a101c8" translate="yes" xml:space="preserve">
          <source>The name of the timer MBean registered.</source>
          <target state="translated">등록 된 타이머 MBean의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ac8d30e1489df051168dc38caa12a3e3879c648b" translate="yes" xml:space="preserve">
          <source>The name of the unsupported charset</source>
          <target state="translated">지원되지 않는 문자 집합의 이름</target>
        </trans-unit>
        <trans-unit id="2ea3029204b8563c2686223e0b30344df216cad0" translate="yes" xml:space="preserve">
          <source>The name of the vendor for this data type</source>
          <target state="translated">이 데이터 유형의 공급 업체 이름</target>
        </trans-unit>
        <trans-unit id="b104e9a9f317ddcff8d221e2af9f9bbcb518f76a" translate="yes" xml:space="preserve">
          <source>The name of the vendor for this data type which is java.sql for JDBCType.</source>
          <target state="translated">이 데이터 유형의 공급 업체 이름은 JDBCType의 경우 java.sql입니다.</target>
        </trans-unit>
        <trans-unit id="126564f90a129c4441e4a2c75da79a1d030e99b6" translate="yes" xml:space="preserve">
          <source>The name of the vendor who defined the SPI class and a brief description of the class are available via the &lt;code&gt;getVendorName&lt;/code&gt;, &lt;code&gt;getDescription&lt;/code&gt;, and &lt;code&gt;getVersion&lt;/code&gt; methods. These methods may be internationalized to provide locale-specific output. These methods are intended mainly to provide short, human-readable information that might be used to organize a pop-up menu or other list.</source>
          <target state="translated">SPI 클래스를 정의한 공급 업체 이름 및 클래스에 대한 간단한 설명은 &lt;code&gt;getVendorName&lt;/code&gt; , &lt;code&gt;getDescription&lt;/code&gt; 및 &lt;code&gt;getVersion&lt;/code&gt; 메소드 를 통해 사용할 수 있습니다 . 로케일 별 출력을 제공하기 위해 이러한 메소드를 국제화 할 수 있습니다. 이러한 방법은 주로 팝업 메뉴 또는 기타 목록을 구성하는 데 사용될 수있는 사람이 읽을 수있는 짧은 정보를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="962ba302c34f721b90ce31af44446e3c52ade33c" translate="yes" xml:space="preserve">
          <source>The name of the vendor who defined the SPI class and a brief description of the class are available via the &lt;code&gt;getVendorName&lt;/code&gt;, &lt;code&gt;getDescription&lt;/code&gt;, and &lt;code&gt;getVersion&lt;/code&gt; methods. These methods may be internationalized to provide locale-specific output. These methods are intended mainly to provide short, human-writable information that might be used to organize a pop-up menu or other list.</source>
          <target state="translated">SPI 클래스를 정의한 공급 업체 이름 및 클래스에 대한 간단한 설명은 &lt;code&gt;getVendorName&lt;/code&gt; , &lt;code&gt;getDescription&lt;/code&gt; 및 &lt;code&gt;getVersion&lt;/code&gt; 메소드 를 통해 사용할 수 있습니다 . 로케일 별 출력을 제공하기 위해 이러한 메소드를 국제화 할 수 있습니다. 이러한 방법은 주로 팝업 메뉴 또는 기타 목록을 구성하는 데 사용할 수있는 사람이 쓸 수있는 짧은 정보를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f00712a679d46359245fd53d36dcdc263f5f38cd" translate="yes" xml:space="preserve">
          <source>The name of this &lt;code&gt;SQLType&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;SQLType&lt;/code&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="8dd4993f396f86b98140b04a30ad081da0cc6b41" translate="yes" xml:space="preserve">
          <source>The name of this buffer pool.</source>
          <target state="translated">이 버퍼 풀의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8c533fca0bdf1847378d972e6408702bbaa3f035" translate="yes" xml:space="preserve">
          <source>The name of this class is taken from the terms used in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278&lt;/i&gt;&lt;/a&gt;. In that document a</source>
          <target state="translated">이 클래스의 이름은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278에&lt;/i&gt;&lt;/a&gt; 사용 된 용어에서 가져 왔습니다 . 그 문서에서</target>
        </trans-unit>
        <trans-unit id="a78d89e8c4c181d92cab5b241c2e56cfa0c8eb49" translate="yes" xml:space="preserve">
          <source>The name of this node, depending on its type; see the table above.</source>
          <target state="translated">유형에 따라이 노드의 이름입니다. 위의 표를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9724d1f38cc8445c96c102f929e30366b8968038" translate="yes" xml:space="preserve">
          <source>The name only contains alphanumeric characters or the character &quot;_&quot;</source>
          <target state="translated">이름에는 영숫자 또는 문자 &quot;_&quot;만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6879a68caf1d6a7ab9d9a4a53cc53b346d66fe6f" translate="yes" xml:space="preserve">
          <source>The name parameter in the &lt;code&gt;addNamingListener()&lt;/code&gt; methods is referred to as the &lt;em&gt;target&lt;/em&gt;. The target, along with the scope, identify the object(s) that the listener is interested in. It is possible to register interest in a target that does not exist, but there might be limitations in the extent to which this can be supported by the service provider and underlying protocol/service.</source>
          <target state="translated">&lt;code&gt;addNamingListener()&lt;/code&gt; 메소드 의 이름 매개 변수를 &lt;em&gt;target&lt;/em&gt; 이라고합니다 . 대상은 범위와 함께 리스너가 관심있는 오브젝트를 식별합니다. 존재하지 않는 대상에 관심을 등록 할 수는 있지만 대상이 지원할 수있는 범위에는 제한이있을 수 있습니다. 서비스 제공자 및 기본 프로토콜 / 서비스.</target>
        </trans-unit>
        <trans-unit id="860c4f0c945e8ceccccb8c32dcd64ba5a09ada9e" translate="yes" xml:space="preserve">
          <source>The name separator</source>
          <target state="translated">이름 구분자</target>
        </trans-unit>
        <trans-unit id="4513ba4813163f865c14e4ebc4f20c422d73d263" translate="yes" xml:space="preserve">
          <source>The name separator is used to separate names in a path string. An implementation may support multiple name separators in which case this method returns an implementation specific &lt;em&gt;default&lt;/em&gt; name separator. This separator is used when creating path strings by invoking the &lt;a href=&quot;path#toString()&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름 구분 기호는 경로 문자열에서 이름을 구분하는 데 사용됩니다. 구현은 여러 이름 구분 기호를 지원할 수 있으며이 경우이 메서드는 구현 특정 &lt;em&gt;기본&lt;/em&gt; 이름 구분 기호를 반환합니다 . 이 구분 기호는 &lt;a href=&quot;path#toString()&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 경로 문자열을 만들 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="35fd956615f3183b2a27cf861192a4328ba79011" translate="yes" xml:space="preserve">
          <source>The name separator is used to separate names in a path string. An implementation may support multiple name separators in which case this method returns an implementation specific &lt;em&gt;default&lt;/em&gt; name separator. This separator is used when creating path strings by invoking the &lt;a href=&quot;path#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름 구분 기호는 경로 문자열에서 이름을 구분하는 데 사용됩니다. 구현시 여러 이름 구분 기호를 지원할 수 있으며이 경우이 메서드는 구현 별 &lt;em&gt;기본&lt;/em&gt; 이름 구분 기호를 반환합니다 . 이 구분 기호는 &lt;a href=&quot;path#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 경로 문자열을 작성할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5428a05faaeaed33e2f9ec7686064395200f6cf6" translate="yes" xml:space="preserve">
          <source>The name under which the MBean is to be registered.</source>
          <target state="translated">MBean을 등록 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="52573a98988fd98ad0050a1dc9a6c1143b22efbf" translate="yes" xml:space="preserve">
          <source>The name under which the MBean is to be registered. This value must not be null. If the &lt;code&gt;name&lt;/code&gt; parameter is not null, it will usually but not necessarily be the returned value.</source>
          <target state="translated">MBean을 등록 할 이름입니다. 이 값은 null이 아니어야합니다. &lt;code&gt;name&lt;/code&gt; 매개 변수가 null이 아닌 경우 일반적으로 반환되는 값일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4ea4ead5eaedd88911039ea1b43c07d7392cc64" translate="yes" xml:space="preserve">
          <source>The named ClassLoader. If &lt;var&gt;l&lt;/var&gt; is the actual ClassLoader with that name, and &lt;var&gt;r&lt;/var&gt; is the returned value, then either:</source>
          <target state="translated">명명 된 ClassLoader 경우 &lt;var&gt;l&lt;/var&gt; 그 이름을 가진 실제 클래스 로더이고, &lt;var&gt;r&lt;/var&gt; 은 다음 중 반환 된 값입니다 :</target>
        </trans-unit>
        <trans-unit id="5c1d5b92b4e57a45a5307ad7f0334127b6e48d33" translate="yes" xml:space="preserve">
          <source>The named character construct, &lt;code&gt;\N{&lt;/code&gt;</source>
          <target state="translated">명명 된 문자 구조 &lt;code&gt;\N{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd3a4268a61dca16f11df59322f0d23569e1bd03" translate="yes" xml:space="preserve">
          <source>The named child node.</source>
          <target state="translated">명명 된 자식 노드</target>
        </trans-unit>
        <trans-unit id="3f8a750c331f2492d2d7adbdb43f580acc695902" translate="yes" xml:space="preserve">
          <source>The named class must exist and must implement the &lt;a href=&quot;../parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">명명 된 클래스가 존재해야하며 &lt;a href=&quot;../parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5845346cc0cc0f0d59912000c5fce352fb493340" translate="yes" xml:space="preserve">
          <source>The names in &lt;code&gt;newBd&lt;/code&gt; and &lt;code&gt;oldBd&lt;/code&gt; are to be resolved relative to the event source &lt;code&gt;source&lt;/code&gt;. For an &lt;code&gt;OBJECT_ADDED&lt;/code&gt; event type, &lt;code&gt;newBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; event type, &lt;code&gt;oldBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; event type, &lt;code&gt;newBd&lt;/code&gt; and &lt;code&gt;oldBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; event type, one of &lt;code&gt;newBd&lt;/code&gt; or &lt;code&gt;oldBd&lt;/code&gt; may be null if the new or old binding is outside of the scope for which the listener has registered.</source>
          <target state="translated">&lt;code&gt;newBd&lt;/code&gt; 및 &lt;code&gt;oldBd&lt;/code&gt; 의 이름 은 이벤트 소스 &lt;code&gt;source&lt;/code&gt; 기준으로 분석 됩니다. 를 들어 &lt;code&gt;OBJECT_ADDED&lt;/code&gt; 이벤트 유형, &lt;code&gt;newBd&lt;/code&gt; 는 널 (null)이 아니어야합니다. 를 들어 &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; 이벤트 유형, &lt;code&gt;oldBd&lt;/code&gt; 는 널 (null)이 아니어야합니다. 를 들어 &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; 이벤트 유형, &lt;code&gt;newBd&lt;/code&gt; 및 &lt;code&gt;oldBd&lt;/code&gt; 은 널 (null)이 아니어야합니다. 들어 &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; 이벤트 타입 중 하나 &lt;code&gt;newBd&lt;/code&gt; 또는 &lt;code&gt;oldBd&lt;/code&gt; 는 (가) 또는 새로운 결합 이전 리스너가 등록되어있는 범위를 벗어나면 널이 될 수있다.</target>
        </trans-unit>
        <trans-unit id="28e648943eed3d5bc718d5018d02e901c65f23c3" translate="yes" xml:space="preserve">
          <source>The names must be unique: the SAX parser shall not include the same attribute twice. Attributes without values (those declared #IMPLIED without a value specified in the start tag) will be omitted from the list.</source>
          <target state="translated">이름은 고유해야합니다. SAX 파서는 동일한 속성을 두 번 포함하지 않아야합니다. 값이없는 속성 (시작 태그에 값이 지정되지 않고 #IMPLIED로 선언 된 속성)은 목록에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a8616907b43c47c1c091877850ead64500f009" translate="yes" xml:space="preserve">
          <source>The names of the available metadata formats may be queried using the &lt;code&gt;getMetadataFormatNames&lt;/code&gt; method.</source>
          <target state="translated">사용 가능한 메타 데이터 형식의 이름은 &lt;code&gt;getMetadataFormatNames&lt;/code&gt; 메소드를 사용하여 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac3d983bd141120202d1d7f059bd758bd4ec98ba" translate="yes" xml:space="preserve">
          <source>The names specified in the assistive_technologies property are used to query each service provider implementation. If the requested name matches the &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#getName()&quot;&gt;name&lt;/a&gt; of the service provider, the &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#activate()&quot;&gt;&lt;code&gt;AccessibilityProvider.activate()&lt;/code&gt;&lt;/a&gt; method will be invoked to activate the matching service provider.</source>
          <target state="translated">assistive_technologies 특성에 지정된 이름은 각 서비스 제공자 구현을 조회하는 데 사용됩니다. 요청 된 이름이 일치하는 경우 &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#getName()&quot;&gt;이름&lt;/a&gt; 서비스 제공자의를의 &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#activate()&quot;&gt; &lt;code&gt;AccessibilityProvider.activate()&lt;/code&gt; &lt;/a&gt; 메서드는 일치하는 서비스 제공을 활성화하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="029f6a8be9fb510a5f766210b1e61cc783a3f358" translate="yes" xml:space="preserve">
          <source>The names used for bindings in a &lt;code&gt;Registry&lt;/code&gt; are pure strings, not parsed. A service which stores its remote reference in a &lt;code&gt;Registry&lt;/code&gt; may wish to use a package name as a prefix in the name binding to reduce the likelihood of name collisions in the registry.</source>
          <target state="translated">&lt;code&gt;Registry&lt;/code&gt; 에서 바인딩에 사용되는 이름 은 구문 분석되지 않은 순수한 문자열입니다. &lt;code&gt;Registry&lt;/code&gt; 원격 참조를 저장하는 서비스는 레지스트리 에서 이름 충돌 가능성을 줄이기 위해 이름 바인딩의 접두사로 패키지 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd6ee214aa3b9f4650a6b8ae8b104453e32f318" translate="yes" xml:space="preserve">
          <source>The namespace URI at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;NameList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if there is no name for the specified index or if the index is out of range.</source>
          <target state="translated">상기 네임 스페이스 URI &lt;code&gt;index&lt;/code&gt; 에 위치 일 &lt;code&gt;NameList&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 는, 인덱스가 범위를 벗어 지정된 인덱스 또는 경우에 이름이없는 경우.</target>
        </trans-unit>
        <trans-unit id="ad968aef2ce359adabcf4b06887f7b010100b12f" translate="yes" xml:space="preserve">
          <source>The namespace URI of this node, or &lt;code&gt;null&lt;/code&gt; if it is unspecified (see ).</source>
          <target state="translated">이 노드의 네임 스페이스 URI 또는 지정되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다 (참조).</target>
        </trans-unit>
        <trans-unit id="15319931b49f78d34365b7fe637c46e690880dd9" translate="yes" xml:space="preserve">
          <source>The namespace declaration URI as a constant.</source>
          <target state="translated">상수로서의 네임 스페이스 선언 URI입니다.</target>
        </trans-unit>
        <trans-unit id="228b61ea658e02a099b69880335433a98bae30ec" translate="yes" xml:space="preserve">
          <source>The namespace declaration URI as a constant. The value is &lt;code&gt;http://www.w3.org/xmlns/2000/&lt;/code&gt;, as defined in a backwards-incompatible erratum to the &quot;Namespaces in XML&quot; recommendation. Because that erratum postdated SAX2, SAX2 defaults to the original recommendation, and does not normally use this URI.</source>
          <target state="translated">상수로서의 네임 스페이스 선언 URI입니다. 값은 &lt;code&gt;http://www.w3.org/xmlns/2000/&lt;/code&gt; 입니다. &quot;XML의 네임 스페이스&quot;권장 사항에 대해 이전 버전과 호환되지 않는 정오표에 정의되어 있습니다. 이 정오표는 SAX2 이후에 게시되었으므로 SAX2는 기본 권장 사항을 기본으로하며 일반적으로이 URI를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="894c9ad401c48e80324e2a77b581833e9593381e" translate="yes" xml:space="preserve">
          <source>The namespace of the type declared for the associated element or attribute or &lt;code&gt;null&lt;/code&gt; if the element does not have declaration or if no namespace information is available.</source>
          <target state="translated">연관된 요소 또는 속성에 대해 선언 된 유형의 네임 스페이스 또는 요소에 선언이 없거나 사용 가능한 네임 스페이스 정보가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1535997202a921696d8786fcff8bc91e08cf6dc6" translate="yes" xml:space="preserve">
          <source>The namespace prefix of this node, or &lt;code&gt;null&lt;/code&gt; if it is unspecified.</source>
          <target state="translated">이 노드의 네임 스페이스 접두사 또는 지정되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bdb974fd4cde04fb21c7dccde9027bcf31610fc0" translate="yes" xml:space="preserve">
          <source>The namespace prefix of this node, or &lt;code&gt;null&lt;/code&gt; if it is unspecified. When it is defined to be &lt;code&gt;null&lt;/code&gt;, setting it has no effect, including if the node is read-only.</source>
          <target state="translated">이 노드의 네임 스페이스 접두사 또는 지정되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다. &lt;code&gt;null&lt;/code&gt; 로 정의 된 경우 노드가 읽기 전용인지 여부를 포함하여 설정해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="252ba1c56374166baaa96e269996326d63427fdf" translate="yes" xml:space="preserve">
          <source>The nano-of-day.</source>
          <target state="translated">오늘의 나노.</target>
        </trans-unit>
        <trans-unit id="5eab94f056909b0481546e3eec3879a8647f2fdf" translate="yes" xml:space="preserve">
          <source>The nano-of-second.</source>
          <target state="translated">나노초.</target>
        </trans-unit>
        <trans-unit id="2bb5963aab34db2c750039ae2c23921252e470b4" translate="yes" xml:space="preserve">
          <source>The nanosecond field is set to zero.</source>
          <target state="translated">나노초 필드는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1f9f634c617722a2cc7a183fbeaa32e432ed0a" translate="yes" xml:space="preserve">
          <source>The nanosecond in second field is set to zero.</source>
          <target state="translated">두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="76fd7e21a457011d726338242241f8903c347ee8" translate="yes" xml:space="preserve">
          <source>The nanosecond-of-second value measures the total number of nanoseconds from the second returned by &lt;a href=&quot;#getEpochSecond()&quot;&gt;&lt;code&gt;getEpochSecond()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나노초 값은 &lt;a href=&quot;#getEpochSecond()&quot;&gt; &lt;code&gt;getEpochSecond()&lt;/code&gt; &lt;/a&gt; 반환 된 초로부터 총 나노초 수를 측정합니다 .</target>
        </trans-unit>
        <trans-unit id="83d052126d41940b2289154ad002f598ff00e77e" translate="yes" xml:space="preserve">
          <source>The nanosecond-of-second value measures the total number of nanoseconds from the second returned by &lt;code&gt;getEpochSecond&lt;/code&gt;.</source>
          <target state="translated">나노초 값은 &lt;code&gt;getEpochSecond&lt;/code&gt; 가 리턴 한 초부터 총 나노초 수를 측정합니다 .</target>
        </trans-unit>
        <trans-unit id="8d9af2aeac2c5039b9c64536435d8f3fb400bacf" translate="yes" xml:space="preserve">
          <source>The native byte order of the hardware upon which this Java virtual machine is running</source>
          <target state="translated">이 Java 가상 머신이 실행되고있는 하드웨어의 원시 바이트 순서</target>
        </trans-unit>
        <trans-unit id="97bded427ee67f08fd9eb95689f83724ec8164db" translate="yes" xml:space="preserve">
          <source>The native character encoding of the Java programming language is UTF-16. A charset in the Java platform therefore defines a mapping between sequences of sixteen-bit UTF-16 code units (that is, sequences of chars) and sequences of bytes.</source>
          <target state="translated">Java 프로그래밍 언어의 기본 문자 인코딩은 UTF-16입니다. 따라서 Java 플랫폼의 문자 세트는 16 비트 UTF-16 코드 단위 시퀀스 (즉, 문자 시퀀스)와 바이트 시퀀스 간의 맵핑을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1219b90b3713ea6ffa550dbe0af918ae384ffcc9" translate="yes" xml:space="preserve">
          <source>The native platform print dialog should be used.</source>
          <target state="translated">기본 플랫폼 인쇄 대화 상자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="83686ff5a26a6fe617fa1acbc83be8300b5c6546" translate="yes" xml:space="preserve">
          <source>The native process ID is an identification number that the operating system assigns to the process. The range for process id values is dependent on the operating system. For example, an embedded system might use a 16-bit value. Status information about a process is retrieved from the native system and may change asynchronously; processes may be created or terminate spontaneously. The time between when a process terminates and the process id is reused for a new process is unpredictable. Race conditions can exist between checking the status of a process and acting upon it. When using ProcessHandles avoid assumptions about the liveness or identity of the underlying process.</source>
          <target state="translated">원시 프로세스 ID는 운영 체제가 프로세스에 할당하는 식별 번호입니다. 프로세스 ID 값의 범위는 운영 체제에 따라 다릅니다. 예를 들어, 임베디드 시스템은 16 비트 값을 사용할 수 있습니다. 프로세스에 대한 상태 정보는 기본 시스템에서 검색되며 비동기 적으로 변경 될 수 있습니다. 프로세스는 자발적으로 생성되거나 종료 될 수 있습니다. 프로세스가 종료되고 프로세스 ID가 새 프로세스에 재사용되는 사이의 시간은 예측할 수 없습니다. 프로세스의 상태를 확인하고 조치를 취하는 사이에 경쟁 조건이 존재할 수 있습니다. ProcessHandles를 사용할 때 기본 프로세스의 활성 또는 ID에 대한 가정을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="e72b8d07ae2a52493e69fa910beb1a9da83caf12" translate="yes" xml:space="preserve">
          <source>The natural ordering for a class &lt;code&gt;C&lt;/code&gt; is said to be</source>
          <target state="translated">클래스 &lt;code&gt;C&lt;/code&gt; 의 자연스러운 순서 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e26b92bd376c727cc9ae6d911fde6e70b291f7e3" translate="yes" xml:space="preserve">
          <source>The natural width/height of the component or component group, in pixels.</source>
          <target state="translated">구성 요소 또는 구성 요소 그룹의 기본 너비 / 높이 (픽셀 단위)입니다.</target>
        </trans-unit>
        <trans-unit id="b84120c20a6bdf6d7f5ae3856a89d9473555ad90" translate="yes" xml:space="preserve">
          <source>The negotiated SSL session</source>
          <target state="translated">협상 된 SSL 세션</target>
        </trans-unit>
        <trans-unit id="234a9e648b6468143062def34d6ca8f9dc630930" translate="yes" xml:space="preserve">
          <source>The net result of these issues is that if the &lt;code&gt;Math.sin()&lt;/code&gt; and &lt;code&gt;Math.cos()&lt;/code&gt; methods are used to directly generate the values for the matrix modifications during these radian-based rotation operations then the resulting transform is never strictly classifiable as a quadrant rotation even for a simple case like &lt;code&gt;rotate(Math.PI/2.0)&lt;/code&gt;, due to minor variations in the matrix caused by the non-0.0 values obtained for the sine and cosine. If these transforms are not classified as quadrant rotations then subsequent code which attempts to optimize further operations based upon the type of the transform will be relegated to its most general implementation.</source>
          <target state="translated">이러한 문제의 최종 결과는 &lt;code&gt;Math.sin()&lt;/code&gt; 및 &lt;code&gt;Math.cos()&lt;/code&gt; 메서드를 사용하여 이러한 라디안 기반 회전 작업 중에 행렬 수정 값을 직접 생성하는 경우 결과 변환을 절대로 엄격하게 분류 할 수 없습니다. 사인 및 코사인에 대해 얻은 0.0이 아닌 값으로 인한 행렬의 사소한 변화로 인해 &lt;code&gt;rotate(Math.PI/2.0)&lt;/code&gt; 와 같은 간단한 경우에도 사분면 회전 . 이러한 변환이 사분면 회전으로 분류되지 않으면 변환 유형에 따라 추가 작업을 최적화하려는 후속 코드가 가장 일반적인 구현으로 강등됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f46588995ed496d4911f8ff1d273d4a2dd3241" translate="yes" xml:space="preserve">
          <source>The network class loader subclass must define the methods &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;loadClassData&lt;/code&gt; to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method &lt;a href=&quot;#defineClass(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; to create a class instance. A sample implementation is:</source>
          <target state="translated">네트워크 클래스 로더 서브 클래스는 네트워크에서 클래스 를로드하기 위해 &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt; &lt;code&gt;findClass&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;loadClassData&lt;/code&gt; 메소드를 정의해야합니다 . 클래스를 구성하는 바이트를 다운로드 한 후에는 &lt;a href=&quot;#defineClass(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하여 클래스 인스턴스를 만들어야합니다. 샘플 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29d0ba30c08b06286e5f241683ca2b4246f089a6" translate="yes" xml:space="preserve">
          <source>The network class loader subclass must define the methods &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;loadClassData&lt;/code&gt; to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method &lt;a href=&quot;classloader#defineClass-byte:A-int-int-&quot;&gt;&lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; to create a class instance. A sample implementation is:</source>
          <target state="translated">네트워크 클래스 로더 서브 클래스는 &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;loadClassData&lt;/code&gt; 메소드를 정의하여 네트워크에서 클래스 를로드해야합니다. 클래스를 구성하는 바이트를 다운로드 한 후에는 메소드를 사용해야합니다.&lt;a href=&quot;classloader#defineClass-byte:A-int-int-&quot;&gt; &lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;를 사용하여 클래스 인스턴스를 작성합니다. 샘플 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60bdca0ec3065d96f7c4fa13ff060a6ac497223a" translate="yes" xml:space="preserve">
          <source>The network interface for Internet Protocol (IP) multicast datagrams</source>
          <target state="translated">인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램을위한 네트워크 인터페이스</target>
        </trans-unit>
        <trans-unit id="67864d43181467d0e750e9cf2430f7984db2145a" translate="yes" xml:space="preserve">
          <source>The network interface for Internet Protocol (IP) multicast datagrams.</source>
          <target state="translated">인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램을위한 네트워크 인터페이스.</target>
        </trans-unit>
        <trans-unit id="c1580356f22e412c53443664b7e31925aaa4d1af" translate="yes" xml:space="preserve">
          <source>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">네트워크 소프트웨어는 소켓에 의해 버퍼링 된 바이트를 삭제할 수 있습니다. 네트워크 소프트웨어에 의해 삭제되지 않은 바이트는 read를 사용하여 &lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6fe308b0ca1ecd4664a44845bd1ebbb9f779e7d" translate="yes" xml:space="preserve">
          <source>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">네트워크 소프트웨어는 소켓에 의해 버퍼링 된 바이트를 버릴 수 있습니다. 네트워크 소프트웨어에서 버리지 않은 바이트는 read를 사용하여 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55670e5d5dd2d95a1600413eeec6cbda76a343d6" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-int-java.math.RoundingMode-&quot;&gt;&lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 방법보다 새로운 &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-int-java.math.RoundingMode-&quot;&gt; &lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt; &lt;/a&gt; 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac784c4d64146b5dcf94b8e436a19a6c04e1010d" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-java.math.RoundingMode-&quot;&gt;&lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 방법보다 새로운 &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-java.math.RoundingMode-&quot;&gt; &lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt; &lt;/a&gt; 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2735dd48d8041cfacd708718becc725a951d4601" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#setScale-int-java.math.RoundingMode-&quot;&gt;&lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 메소드보다 새로운 &lt;a href=&quot;bigdecimal#setScale-int-java.math.RoundingMode-&quot;&gt; &lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt; &lt;/a&gt; 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ac33af37763a895fb45c8674bcd9b2f4195f026" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;CDATASection&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;CDATASection&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="21ab9f29997ac044ac786c27f5f4247505485231" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;Comment&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;Comment&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="3de7e88be2994a0198fc6b96016f6a661e41553f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;EntityReference&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;EntityReference&lt;/code&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="2ea1019c83ded3f69e80d30416950390eadbdebc" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;ProcessingInstruction&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;ProcessingInstruction&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="ba45d206f6ce10fd626fa94b5424cc97accbd485" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;Rectangle&lt;/code&gt; has &lt;code&gt;(x - h, y - v)&lt;/code&gt; as its upper-left corner, width of &lt;code&gt;(width + 2h)&lt;/code&gt;, and a height of &lt;code&gt;(height + 2v)&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Rectangle&lt;/code&gt; 은 &lt;code&gt;(x - h, y - v)&lt;/code&gt; 왼쪽 상단 모서리, 너비 &lt;code&gt;(width + 2h)&lt;/code&gt; 및 높이 &lt;code&gt;(height + 2v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b974fb076134f8a2b5e9c5d2e506d6b6d140c6b6" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialArray&lt;/code&gt; object contains the same elements as the &lt;code&gt;Array&lt;/code&gt; object from which it is built, except when the base type is the SQL type &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;, &lt;code&gt;DATALINK&lt;/code&gt; or &lt;code&gt;JAVA_OBJECT&lt;/code&gt;. In this case, each element in the new &lt;code&gt;SerialArray&lt;/code&gt; object is the appropriate serialized form, that is, a &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;, &lt;code&gt;SerialDatalink&lt;/code&gt;, or &lt;code&gt;SerialJavaObject&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 는 기본 유형이 SQL 유형 &lt;code&gt;BLOB&lt;/code&gt; , &lt;code&gt;CLOB&lt;/code&gt; , &lt;code&gt;DATALINK&lt;/code&gt; 또는 &lt;code&gt;JAVA_OBJECT&lt;/code&gt; 인 경우를 제외하고는 해당 객체가 빌드 된 &lt;code&gt;Array&lt;/code&gt; 객체 와 동일한 요소를 포함합니다 . 이 경우 새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 의 각 요소는 직렬화 된 적절한 형식, 즉 &lt;code&gt;SerialBlob&lt;/code&gt; , &lt;code&gt;SerialClob&lt;/code&gt; , &lt;code&gt;SerialDatalink&lt;/code&gt; 또는 &lt;code&gt;SerialJavaObject&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="80e0ce8f3d894008a7021d81d24aa60554c9d440" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialArray&lt;/code&gt; object contains the same elements as the &lt;code&gt;Array&lt;/code&gt; object from which it is built, except when the base type is the SQL type &lt;code&gt;STRUCT&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;, &lt;code&gt;DATALINK&lt;/code&gt; or &lt;code&gt;JAVA_OBJECT&lt;/code&gt;. In this case, each element in the new &lt;code&gt;SerialArray&lt;/code&gt; object is the appropriate serialized form, that is, a &lt;code&gt;SerialStruct&lt;/code&gt;, &lt;code&gt;SerialArray&lt;/code&gt;, &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;, &lt;code&gt;SerialDatalink&lt;/code&gt;, or &lt;code&gt;SerialJavaObject&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 는 기본 유형이 SQL 유형 &lt;code&gt;STRUCT&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;BLOB&lt;/code&gt; , &lt;code&gt;CLOB&lt;/code&gt; , &lt;code&gt;DATALINK&lt;/code&gt; 또는 &lt;code&gt;JAVA_OBJECT&lt;/code&gt; 인 경우를 제외하고는 해당 객체가 빌드 된 &lt;code&gt;Array&lt;/code&gt; 객체 와 동일한 요소를 포함합니다 . 이 경우 새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 의 각 요소는 직렬화 된 적절한 형식, 즉 &lt;code&gt;SerialStruct&lt;/code&gt; , &lt;code&gt;SerialArray&lt;/code&gt; , &lt;code&gt;SerialBlob&lt;/code&gt; , &lt;code&gt;SerialClob&lt;/code&gt; , &lt;code&gt;SerialDatalink&lt;/code&gt; 또는 &lt;code&gt;SerialJavaObject&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="06abd2075e2ed1721af0f48e630558bf700d5acf" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;Blob&lt;/code&gt; object; therefore, the &lt;code&gt;Blob&lt;/code&gt; object should have previously brought the SQL &lt;code&gt;BLOB&lt;/code&gt; value's data over to the client from the database. Otherwise, the new &lt;code&gt;SerialBlob&lt;/code&gt; object will contain no data.</source>
          <target state="translated">새 &lt;code&gt;SerialBlob&lt;/code&gt; 개체는 &lt;code&gt;Blob&lt;/code&gt; 개체 의 데이터로 초기화됩니다 . 따라서 &lt;code&gt;Blob&lt;/code&gt; 개체는 이전에 SQL &lt;code&gt;BLOB&lt;/code&gt; 값의 데이터를 데이터베이스에서 클라이언트로 가져 왔어 야 합니다. 그렇지 않으면 새 &lt;code&gt;SerialBlob&lt;/code&gt; 개체에 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a900d5f2ddce08647425d98d24a6bddafdbf9ba0" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;byte&lt;/code&gt; array, thus allowing disconnected &lt;code&gt;RowSet&lt;/code&gt; objects to establish serialized &lt;code&gt;Blob&lt;/code&gt; objects without touching the data source.</source>
          <target state="translated">새 &lt;code&gt;SerialBlob&lt;/code&gt; 개체는 &lt;code&gt;byte&lt;/code&gt; 배열 의 데이터로 초기화 되므로 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체가 데이터 소스를 건드리지 않고도 직렬화 된 &lt;code&gt;Blob&lt;/code&gt; 개체 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78aaae994b4dabb3fc80be4b84511dee256896b1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialClob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;Clob&lt;/code&gt; object; therefore, the &lt;code&gt;Clob&lt;/code&gt; object should have previously brought the SQL &lt;code&gt;CLOB&lt;/code&gt; value's data over to the client from the database. Otherwise, the new &lt;code&gt;SerialClob&lt;/code&gt; object object will contain no data.</source>
          <target state="translated">새 &lt;code&gt;SerialClob&lt;/code&gt; 개체는 &lt;code&gt;Clob&lt;/code&gt; 개체 의 데이터로 초기화됩니다 . 따라서 &lt;code&gt;Clob&lt;/code&gt; 개체는 이전에 SQL &lt;code&gt;CLOB&lt;/code&gt; 값의 데이터를 데이터베이스에서 클라이언트로 가져 왔어 야 합니다. 그렇지 않으면 새 &lt;code&gt;SerialClob&lt;/code&gt; 개체 개체에 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17353bad20748ceb3bfb756b24c2c22df6c4c460" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialClob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;char&lt;/code&gt; array, thus allowing disconnected &lt;code&gt;RowSet&lt;/code&gt; objects to establish a serialized &lt;code&gt;Clob&lt;/code&gt; object without touching the data source.</source>
          <target state="translated">새 &lt;code&gt;SerialClob&lt;/code&gt; 개체는 &lt;code&gt;char&lt;/code&gt; 배열 의 데이터로 초기화 되므로 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체가 데이터 소스를 건드리지 않고도 직렬화 된 &lt;code&gt;Clob&lt;/code&gt; 개체를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd289b7da3f8d0a5f7fe07055b8416ed256428d0" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;Text&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;Text&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="5d361a6c28b3a7b924134f4c2310c4356b571de7" translate="yes" xml:space="preserve">
          <source>The new Raster may additionally be translated to a different coordinate system for the plane than that used by the current Raster. The childMinX and childMinY parameters give the new (x, y) coordinate of the upper-left pixel of the returned Raster; the coordinate (childMinX, childMinY) in the new Raster will map to the same pixel as the coordinate (parentX, parentY) in the current Raster.</source>
          <target state="translated">새로운 Raster는 현재 Raster에서 사용하는 것과는 다른 평면 좌표계로 추가로 변환 될 수 있습니다. childMinX 및 childMinY 매개 변수는 반환 된 Raster의 왼쪽 위 픽셀의 새 (x, y) 좌표를 제공합니다. 새 Raster의 좌표 (childMinX, childMinY)는 현재 Raster의 좌표 (parentX, parentY)와 동일한 픽셀에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="82b647f77da8fc51c747ee0f20a9855467762c05" translate="yes" xml:space="preserve">
          <source>The new Raster may be defined to contain only a subset of the bands of the current Raster, possibly reordered, by means of the bandList parameter. If bandList is null, it is taken to include all of the bands of the current Raster in their current order.</source>
          <target state="translated">새로운 Raster는 bandList 매개 변수를 사용하여 현재 Raster 밴드의 하위 집합 만 포함하도록 정의 할 수 있습니다. bandList가 null이면 현재 Raster의 모든 밴드를 현재 순서대로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7265ccc5d623c310cc3ac47a66fc5eed1ffa49bf" translate="yes" xml:space="preserve">
          <source>The new URI</source>
          <target state="translated">새로운 URI</target>
        </trans-unit>
        <trans-unit id="5f405da8bbae6be9b41dfa9b6d7bbc89199565ba" translate="yes" xml:space="preserve">
          <source>The new WritableRaster may additionally be translated to a different coordinate system for the plane than that used by the current WritableRaster. The childMinX and childMinY parameters give the new (x, y) coordinate of the upper-left pixel of the returned WritableRaster; the coordinate (childMinX, childMinY) in the new WritableRaster will map to the same pixel as the coordinate (parentX, parentY) in the current WritableRaster.</source>
          <target state="translated">새로운 WritableRaster는 현재 WritableRaster에서 사용하는 것과는 다른 평면 좌표계로 추가로 변환 될 수 있습니다. childMinX 및 childMinY 매개 변수는 반환 된 WritableRaster의 왼쪽 위 픽셀의 새 (x, y) 좌표를 제공합니다. 새 WritableRaster의 좌표 (childMinX, childMinY)는 현재 WritableRaster의 좌표 (parentX, parentY)와 동일한 픽셀에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="ab5c193afbcca8cc582eca9bc77cb959c8b4bf3a" translate="yes" xml:space="preserve">
          <source>The new WritableRaster may be defined to contain only a subset of the bands of the current WritableRaster, possibly reordered, by means of the bandList parameter. If bandList is null, it is taken to include all of the bands of the current WritableRaster in their current order.</source>
          <target state="translated">새로운 WritableRaster는 bandList 매개 변수를 사용하여 현재 WritableRaster의 밴드의 부분 집합 만 포함하도록 정의 될 수 있습니다. bandList가 null이면 현재 WritableRaster의 모든 밴드를 현재 순서대로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a2b375f7ec337d0b7321744b498b77bbbb43dc04" translate="yes" xml:space="preserve">
          <source>The new binding: information about the object after the change.</source>
          <target state="translated">새로운 바인딩 : 변경 후 객체에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="811ee44cf7e2eeb64087a000511e1308ea7b319a" translate="yes" xml:space="preserve">
          <source>The new buffer</source>
          <target state="translated">새로운 버퍼</target>
        </trans-unit>
        <trans-unit id="a9f750a1ec47c53e6933e7367f0dd037a6159afe" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="90e1aff286e96d964a4b0f5b68af2f26432a8471" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량과 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b87cda267359dfa7e6d3c0f1f70075ab22125777" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="8379c53880b85933ce4a6ea8375b41465251bdc7" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="3a25bef4c13a14c4415962bc64f251e299155ad6" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 문자 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="c2482ceaa24382ea21ac8d5f908044a26e325543" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 char 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0d2674995ec7db927894a48c261ddea8d595a398" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 문자 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="735303f9844fa882ca8acee8fe46085bd77a959b" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 char 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="35306637861eed16af88b4e2dfb5c1e37c341a44" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="eb0dbfe7f7fa1cea1555c6a9994e13ed4e5283a8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="8dceaea7882e5d50ea82b5e02eaccd6768f24042" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="48e7d25898b00d2244ede003e69d1683b40c8061" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="a4320fd76f9f4ca139f58312ae6d89d82b8751b8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="23ca7ac0ad6d66ac718f1ac4f45677a5be8afe92" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="1e7911665bb7451ce6034993a67b89354cf0e0fe" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="aaee794f7a79d58138226cea2eb7241025e96893" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="3fd84a12e6c22a3ee3939f3f6a961f726d7f5c1a" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 int 배열은 지정된 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="542acab240cf7a91a0f009397f9d5e391547359c" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="c8228e64f023a9d3a8c7700654a22211275f6638" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 int 배열은 지정된 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="7a5777903d7dc4a8dd6a7b994da71372ebd61285" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b259e53add3a5528efdfbd8e55c0de407403a961" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="c025cebd020483c761ea0b9d2e34843256ba8160" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="78548868dc1648694724e198deaa1f84f096b4c8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="05e5d377bee49b4b9cb9eb2b7777b988471bf1d3" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="d08a08b839ac302da9552db1b3bb522b1eeb1ba6" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="938f79a566e736887d022dd209c93277878b1d06" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b7616ef26b29d3dbc28547aecc940e0b07b48cc8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="e50668684daefc59dbea18aaaf601a06240c643e" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="c14e82168abd4ac4df9c13b98e0a4c8e7cfc8643" translate="yes" xml:space="preserve">
          <source>The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;start&lt;/code&gt;, and its limit will be &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;end&lt;/code&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼는이 버퍼의 내용을 공유합니다. 즉,이 버퍼의 내용이 변경 가능한 경우 한 버퍼를 수정하면 다른 버퍼가 수정됩니다. 새로운 버퍼의 용량은이 버퍼의 용량이되고, 위치는 &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;start&lt;/code&gt; 이며, 한계는 &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;end&lt;/code&gt; 입니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2c8b2d7d20a9e7009df83e54bdc37e78f70e0d" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치 및 표시 값은이 버퍼의 값과 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="e41c4ae231a59cfcca0e03cc7c39edbc8d2edb92" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치 및 표시 값은이 버퍼의 값과 동일하며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49eb244b64c8d9a9ba9cd656fc24f8323f3eb0f6" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치 및 표시 값은이 버퍼의 값과 동일하며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="7d665df25b33f41e16e1676893f85747fee6206b" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.</source>
          <target state="translated">새로운 버퍼의 용량, 한계, 위치 및 마크 값은이 버퍼와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1441a0ea6ee677b09ef764abcace356aff8ffb6a" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 용량, 한계, 위치 및 마크 값은이 버퍼와 동일합니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="6550570fb9555c58e1cb0e5def73509b39966896" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, mark values, and byte order will be identical to those of this buffer.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치, 표시 값 및 바이트 순서는이 버퍼의 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f79d65af633493eb7a8e1c8f5a8b5b414b175153" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, mark values, and byte order will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치, 표시 값 및 바이트 순서는이 버퍼의 것과 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="a13d0be56226b191c2b44377cfe1a92626a44776" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 8로 나눈 값이되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="c02f03f90159f93e336df782d499064fb01da7f6" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, its mark will be undefined, and its byte order will be that of the byte buffer at the moment the view is created. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 8로 나눈 값이며, 마크는 정의되지 않으며, 바이트 순서는 뷰가 표시되는 순간의 바이트 버퍼의 순서가됩니다. 만들어진. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="90552048b6aa0101e52962a0d5b974862e391b43" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 4로 나눈 값이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="04d53bc931f3031cff24d274e2153cb0f909b287" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, its mark will be undefined, and its byte order will be that of the byte buffer at the moment the view is created. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 4로 나눈 값이고, 마크는 정의되지 않으며, 바이트 순서는 뷰가 표시되는 순간의 바이트 버퍼의 순서가됩니다. 만들어진. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="cfc7272e6b5899b3b2bcbd70bb498a4197e3a159" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 2로 나눈 값이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="a414db15894243d7fc9b87769d0b51664c13216d" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, its mark will be undefined, and its byte order will be that of the byte buffer at the moment the view is created. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 2로 나눈 값이고, 마크는 정의되지 않으며, 해당 바이트 순서는 뷰가 표시되는 순간의 바이트 버퍼의 순서가됩니다. 만들어진. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="b52b5dc3e863470f025e539f6bf77a5f3e4be8d9" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer or fewer subject to alignment, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0, 용량 및 한계는이 버퍼에 남아있는 바이트 수 또는 정렬 대상이 될 수있는 바이트 수이며, 마크는 정의되지 않으며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="9a09a10dc3d2fc25e63569ae94bfd86cd530afbc" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 바이트 수가되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="111bd5660eac942fbcac5519244714b2247bf80a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 바이트 수이며 마크는 정의되지 않으며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="fba588f426f87edc19c14d7f0682ef96259b59dd" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of chars remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 문자 수이며 표시는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="62b85884a696b76732cec9a21385d540addc262a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of chars remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 문자의 수이며 마크는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="f0973afd84caee05155e2681a55128180674a18a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of doubles remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 그 용량과 한계는이 버퍼에 남은 두 배의 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="f30e4a528cab353438c8c19e5c1f5da6f13e94ec" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of doubles remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 더블의 수이며, 마크는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="ea906443b3c3866a2da17662e0837ea4ceea532d" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of elements remaining in this buffer, its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 요소의 수이며 표시는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="8222a6605391ceeccd212b79d0de137bdee941ea" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of floats remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 그 용량과 한계는이 버퍼에 남아있는 플로트의 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="6e18af5ed60c263adba26d819e39f8be09733dac" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of floats remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 부동 소수점 수이며, 마크는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="409703dd3fa5e15595f45b7bfa97d23dfc879f75" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of ints remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 정수의 개수가되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b37217a2a5560896450794e316ea9ef8cba8b8" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of ints remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 정수의 수이며 마크는 정의되지 않으며 바이트 순서는이 버퍼의 바이트 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="184e102258e542a41b9bc5bd5712cf1b45f7ba82" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of longs remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 길이의 수이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="319703467b5cb1d899cc5f3b715fa5fcab517e87" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of longs remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 long의 수이며 표시는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="db4d05da05e11921709f2c45d3cc55f4a61dcdd8" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of shorts remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 쇼트 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="ca4a2b6104fd9c9d8887d29f3acd6594660e9a9a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of shorts remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 쇼트의 수이며 마크는 정의되지 않으며 바이트 순서는이 버퍼의 바이트 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="e873cc2a43337dc6d0f48726bcbfe54afbbbb3dd" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0bc120342e8b1870b356b3688bd19e6b6d771658" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="4499f8809b64cea17e4ae935e38e57b0f0d75938" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="98fcf6ac3b1e8e48717c044627e4568fcf5fbd06" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b824b2632dba5cfa58058d0964f1ea0de5c6b90e" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0f405c739bacda631028ecb69ab8e7e2935ea317" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="ab6d02b7d7ce9994222ab6506d8bcc54c8589506" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b9f0b692e41b510f435757041e930b3ca3d5e9be" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. Whether or not it has a &lt;a href=&quot;bytebuffer#hasArray--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; is unspecified.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. &lt;a href=&quot;bytebuffer#hasArray--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 이 있는지 여부 는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbc7cae7c2403b598dadadcb3b2ec2f7f72370c3" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, each of its elements will be initialized to zero, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. It will have a &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0, 한계는 용량, 마크는 정의되지 않고 각 요소는 0으로 초기화되며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. 그것은 것이다 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="7290acf9ff7e32a5e68089310685aad7a3175da4" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, each of its elements will be initialized to zero, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. Whether or not it has a &lt;a href=&quot;#hasArray()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; is unspecified.</source>
          <target state="translated">새 버퍼의 위치는 0, 한계는 용량, 마크는 정의되지 않고 각 요소는 0으로 초기화되며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. &lt;a href=&quot;#hasArray()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 가 있는지 여부 는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e20908b4684455a9d46aa45c5928acb89154e418" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, each of its elements will be initialized to zero, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. It will have a &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0, 한계는 용량, 마크는 정의되지 않고 각 요소는 0으로 초기화되며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그것은 것이다 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b1662b58ac08c19eb90fcbe51af1d61f93d2d097" translate="yes" xml:space="preserve">
          <source>The new byte buffer</source>
          <target state="translated">새로운 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="a45f4c65b0bb36650376b631e6594f501b8c823a" translate="yes" xml:space="preserve">
          <source>The new channel</source>
          <target state="translated">새로운 채널</target>
        </trans-unit>
        <trans-unit id="39988f7bd48bce3640ae9255ae58edd4d492d701" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;newFileChannel&lt;/code&gt;&lt;/a&gt; method on the provider that created the &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">새 채널은 &lt;code&gt;Path&lt;/code&gt; 를 만든 공급자 에서 &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;newFileChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a0c64b8684bdcf86946498ab7c59c1c46403fb26" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;newFileChannel&lt;/code&gt;&lt;/a&gt; method on the provider that created the &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">새 채널은 &lt;code&gt;Path&lt;/code&gt; 를 작성한 제공자 에서 &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;newFileChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3f0ccd9145e43381e62fd1685d01e3719c2f360" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt;&lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object that created the given group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">새 채널은 지정된 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 개체 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt; &lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만듭니다. 그룹 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널은 시스템 전체 기본 공급자에 의해 생성되고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30644cb35aeeea5e1c72b112f048cacccf59280e" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt;&lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object that created the given group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">지정된 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt; &lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 새 채널을 만듭니다. group 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널이 시스템 전체 기본 공급자에 의해 만들어지고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="562dfacb39e3312f09e9cc2dfa08d51de3d858cf" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt;&lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; that created the group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">새 채널은 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt; &lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 . 그룹 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널은 시스템 전체 기본 공급자에 의해 생성되고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa05ef1e428bfbeed57a213a4e34a9d9876bffe" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt;&lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; that created the group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">새 채널은 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt; &lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만듭니다. group 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널이 시스템 전체 기본 공급자에 의해 만들어지고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d32ddddfcc557792e2a3982412cb757082a83260" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel()&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새 채널은 시스템 전체 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel()&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="154c7f6ed3d5cc86652d699d9e0e59a008d31144" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel(java.net.ProtocolFamily)&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새 채널은 시스템 전체 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel(java.net.ProtocolFamily)&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a7232600a19d5c749f1ed775c91b5c69237ecde" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel--&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새로운 채널은 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel--&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것으로 작성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3805a8ad4425a07e7b9601f1dc5f49f6555fb05" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel-java.net.ProtocolFamily-&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새로운 채널은 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel-java.net.ProtocolFamily-&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것으로 작성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="959d7a0fafc989b56eed04d747893067826ef149" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel()&quot;&gt;&lt;code&gt;openServerSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel()&quot;&gt; &lt;code&gt;openServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="640a2a8aa11bc64a4a6a49aefd39e43c327cdc4d" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel--&quot;&gt;&lt;code&gt;openServerSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel--&quot;&gt; &lt;code&gt;openServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a091dfe7abb19d6eed31b9d441901fe7edd403a" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSocketChannel()&quot;&gt;&lt;code&gt;openSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openSocketChannel()&quot;&gt; &lt;code&gt;openSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3c960cf1b6fdeb74926d0f06d9ebb63c6b2bfe2" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSocketChannel--&quot;&gt;&lt;code&gt;openSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openSocketChannel--&quot;&gt; &lt;code&gt;openSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="ef5640ed0e3dd57e5904174d8dcc4cbd65edeff0" translate="yes" xml:space="preserve">
          <source>The new channel's socket is initially unbound; it must be bound to a specific address via one of its socket's &lt;a href=&quot;../../net/serversocket#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; methods before connections can be accepted.</source>
          <target state="translated">새 채널의 소켓은 처음에 바인딩 해제됩니다. 연결이 허용되기 전에 소켓의 &lt;a href=&quot;../../net/serversocket#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 통해 특정 주소에 바인드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4166a9ca9c991a66f299641f2e32e0fece1a98ba" translate="yes" xml:space="preserve">
          <source>The new channel's socket is initially unbound; it must be bound to a specific address via one of its socket's &lt;a href=&quot;../../net/serversocket#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; methods before connections can be accepted.</source>
          <target state="translated">새로운 채널의 소켓은 초기에 언 바운드입니다. 연결을 수락하기 전에 소켓의 &lt;a href=&quot;../../net/serversocket#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 통해 특정 주소에 바인드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="405a847e27c80c831a52b3ca25e1aee97b0b63cd" translate="yes" xml:space="preserve">
          <source>The new char buffer</source>
          <target state="translated">새로운 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="a3bfde5271747a153dbc45be6dd7b2fa8d92c106" translate="yes" xml:space="preserve">
          <source>The new character buffer</source>
          <target state="translated">새로운 캐릭터 버퍼</target>
        </trans-unit>
        <trans-unit id="105e02b325849c87768426ba794cd482fa2cf5d4" translate="yes" xml:space="preserve">
          <source>The new context has the same environment properties and connection request controls as this context. See the class description for details. Implementations might also allow this context and the new context to share the same network connection or other resources if doing so does not impede the independence of either context.</source>
          <target state="translated">새 컨텍스트에는이 컨텍스트와 동일한 환경 특성 및 연결 요청 제어가 있습니다. 자세한 내용은 수업 설명을 참조하십시오. 구현시이 컨텍스트와 새 컨텍스트가 동일한 네트워크 연결 또는 다른 리소스를 공유 할 수 있으므로 컨텍스트의 독립성을 방해하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32225c2b2a4cd61beeafae6360573239239143d8" translate="yes" xml:space="preserve">
          <source>The new directory stream, once created, is not dependent upon the directory stream used to create it. Closing this directory stream has no effect upon newly created directory stream.</source>
          <target state="translated">일단 작성된 새 디렉토리 스트림은이를 작성하는 데 사용 된 디렉토리 스트림에 종속되지 않습니다. 이 디렉토리 스트림을 닫아도 새로 작성된 디렉토리 스트림에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1472dd980957833880e469fd869da118a620a1d" translate="yes" xml:space="preserve">
          <source>The new double buffer</source>
          <target state="translated">새로운 더블 버퍼</target>
        </trans-unit>
        <trans-unit id="2f0532ed60ab4132dd9d65f7412ae3fdaace63d3" translate="yes" xml:space="preserve">
          <source>The new float buffer</source>
          <target state="translated">새로운 플로트 버퍼</target>
        </trans-unit>
        <trans-unit id="f60894a3ea95a69c84bc4b87c767e21d9aecdcf4" translate="yes" xml:space="preserve">
          <source>The new glass pane's visibility is changed to match that of the current glass pane. An implication of this is that care must be taken when you want to replace the glass pane and make it visible. Either of the following will work:</source>
          <target state="translated">새 유리창의 가시성이 현재 유리창의 가시성과 일치하도록 변경됩니다. 이것의 의미는 유리창을 교체하고 보이게 할 때주의를 기울여야한다는 것입니다. 다음 중 하나가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="40fa9d09acdee10a0a3b36ab9ea3d84678cccd77" translate="yes" xml:space="preserve">
          <source>The new graphics context has an additional clipping rectangle, in addition to whatever (translated) clipping rectangle it inherited from the original graphics context. The origin of the new clipping rectangle is at (&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;), and its size is specified by the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; arguments.</source>
          <target state="translated">새 그래픽 컨텍스트에는 원래 그래픽 컨텍스트에서 상속 된 (변환 된) 클리핑 사각형 외에 추가 클리핑 사각형이 있습니다. 새 클리핑 사각형의 원점은 ( &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; )이고 크기는 &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 인수로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1aad4607b7a4ff89c5cae016542628ea7e5e8cda" translate="yes" xml:space="preserve">
          <source>The new graphics context is translated by (</source>
          <target state="translated">새 그래픽 컨텍스트는 (</target>
        </trans-unit>
        <trans-unit id="351ce29e1a236701155b75e9b6605d4772412233" translate="yes" xml:space="preserve">
          <source>The new handlers are not implemented by the SAX2 &lt;code&gt;org.xml.sax.helpers.DefaultHandler&lt;/code&gt; or &lt;code&gt;org.xml.sax.helpers.XMLFilterImpl&lt;/code&gt; classes. You can subclass these if you need such behavior, or use the helper classes found here.</source>
          <target state="translated">새 핸들러는 SAX2 &lt;code&gt;org.xml.sax.helpers.DefaultHandler&lt;/code&gt; 또는 &lt;code&gt;org.xml.sax.helpers.XMLFilterImpl&lt;/code&gt; 클래스에 의해 구현되지 않습니다 . 이러한 동작이 필요한 경우 하위 클래스를 만들거나 여기에있는 도우미 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c7a2f2dd2b2712931e42cff9b291f698ae12a0" translate="yes" xml:space="preserve">
          <source>The new input source, or null to require the default behaviour.</source>
          <target state="translated">새 입력 소스 또는 기본 동작이 필요한 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="1f6194d825d6dc0688d142cdf98fae1e64221945" translate="yes" xml:space="preserve">
          <source>The new int buffer</source>
          <target state="translated">새로운 int 버퍼</target>
        </trans-unit>
        <trans-unit id="16916b8d2254968908c21ac68fdf72fdd3794032" translate="yes" xml:space="preserve">
          <source>The new iterator</source>
          <target state="translated">새로운 반복자</target>
        </trans-unit>
        <trans-unit id="779eee0d9cf7a611f52c9afc435db4ffc9a7b2aa" translate="yes" xml:space="preserve">
          <source>The new long buffer</source>
          <target state="translated">새로운 긴 버퍼</target>
        </trans-unit>
        <trans-unit id="a049a6df3cdeeeac083a1b0492d8837e20ab7728" translate="yes" xml:space="preserve">
          <source>The new method handle, when invoked, will perform the following steps:</source>
          <target state="translated">새 메소드 핸들은 호출 될 때 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="92e50b8ce0fbbc5d3ddc700f726a1f61541bb746" translate="yes" xml:space="preserve">
          <source>The new node, of the same type as this node.</source>
          <target state="translated">이 노드와 동일한 유형의 새 노드입니다.</target>
        </trans-unit>
        <trans-unit id="aad32c6be4c40289765349dc77371198d0722960" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no children in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적 뷰에 자식이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fa7f18ee056860588a84eb3540948e7621523f1" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no next node in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적보기 에 다음 노드가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08bee0f0cc7eaeddd7d01886f4661fa98348f038" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no next sibling. in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드 또는 현재 노드에 다음 형제가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다. 에서 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적보기.</target>
        </trans-unit>
        <trans-unit id="53979055d6a4dbf049878044d8f40a2525ff6d07" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no previous node in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리보기 에 이전 노드가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66d1991db11199cc0a752370830eb32dd53f1760" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no previous sibling. in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드 또는 현재 노드에 이전 형제가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다. 에서 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적보기.</target>
        </trans-unit>
        <trans-unit id="cc9bb88661ee58f520f7596174f8b9dbd4b0c604" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no visible children in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적 뷰 에 보이는 자식이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7edac962c9fdf5e1ed3e30ef75f9b85854bb6c3" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 2-argument constructor DeflaterOutputStream(out, false).</source>
          <target state="translated">새 출력 스트림 인스턴스는 2 개의 인수 생성자 DeflaterOutputStream (out, false)을 호출하여 것처럼 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="17e00405c9d859e5ea535348ea74cc91e9987eea" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 2-argument constructor GZIPOutputStream(out, false).</source>
          <target state="translated">새 출력 스트림 인스턴스는 2 인수 생성자 GZIPOutputStream (out, false)을 호출하여 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="eba31038050930f93163a540e115ac8b731c66f1" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 3-argument constructor DeflaterOutputStream(out, def, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 3- 인수 생성자 DeflaterOutputStream (out, def, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d9335ad9c012ce1f2b92b1f6698fcccb2cb17791" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 3-argument constructor GZIPOutputStream(out, size, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 3- 인수 생성자 GZIPOutputStream (out, size, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f12bbb4d87ec052fcf9300036f1e190a6c68064b" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 4-argument constructor DeflaterOutputStream(out, def, size, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 4 개의 인수 생성자 DeflaterOutputStream (out, def, size, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="51f264957ea16725861ee0b7f2549925bad1a95b" translate="yes" xml:space="preserve">
          <source>The new parent node, or &lt;code&gt;null&lt;/code&gt; if the current node has no parent in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새로운 부모 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리 뷰에 부모가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d884f874f7014685b458a4af3391ba4d45f11053" translate="yes" xml:space="preserve">
          <source>The new pipe</source>
          <target state="translated">새로운 파이프</target>
        </trans-unit>
        <trans-unit id="81743a0e516c888ca495a3379f63119c30a076d1" translate="yes" xml:space="preserve">
          <source>The new pipe is created by invoking the &lt;a href=&quot;spi/selectorprovider#openPipe()&quot;&gt;&lt;code&gt;openPipe&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 파이프는 시스템 전체 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openPipe()&quot;&gt; &lt;code&gt;openPipe&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c83e22c89152847eb837b14970d1ac61dec5b58" translate="yes" xml:space="preserve">
          <source>The new pipe is created by invoking the &lt;a href=&quot;spi/selectorprovider#openPipe--&quot;&gt;&lt;code&gt;openPipe&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openPipe--&quot;&gt; &lt;code&gt;openPipe&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 새 파이프를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ea7fad088fe017180a3cb702a40bcf125e3ccdc4" translate="yes" xml:space="preserve">
          <source>The new process will invoke the command and arguments given by &lt;a href=&quot;#command()&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by &lt;a href=&quot;#directory()&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by &lt;a href=&quot;#environment()&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 프로세스는 &lt;a href=&quot;#environment()&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt; 의해 주어진 프로세스 환경과 함께 &lt;a href=&quot;#directory()&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt; 의해 주어진 작업 디렉토리에서 &lt;a href=&quot;#command()&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 의해 주어진 명령과 인수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e219b1425b7017143bc6b763f1e3479269fe8f77" translate="yes" xml:space="preserve">
          <source>The new process will invoke the command and arguments given by &lt;a href=&quot;processbuilder#command--&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by &lt;a href=&quot;processbuilder#directory--&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by &lt;a href=&quot;processbuilder#environment--&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 프로세스는 &lt;a href=&quot;processbuilder#environment--&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt; 의해 주어진 프로세스 환경과 함께 &lt;a href=&quot;processbuilder#directory--&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt; 의해 주어진 작업 디렉토리에서 &lt;a href=&quot;processbuilder#command--&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 의해 주어진 명령과 인수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="95ac9042239c405df39132ca4d6a54dd4895fee9" translate="yes" xml:space="preserve">
          <source>The new selector</source>
          <target state="translated">새로운 선택기</target>
        </trans-unit>
        <trans-unit id="0afd52fcd7a3f4bc42d8190464378d5622d0a3f2" translate="yes" xml:space="preserve">
          <source>The new selector is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSelector()&quot;&gt;&lt;code&gt;openSelector&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 선택기는 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openSelector()&quot;&gt; &lt;code&gt;openSelector&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d90a5fbf3072fbdd10fb888cd77c2fecc69894d" translate="yes" xml:space="preserve">
          <source>The new selector is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSelector--&quot;&gt;&lt;code&gt;openSelector&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 선택기는 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openSelector--&quot;&gt; &lt;code&gt;openSelector&lt;/code&gt; &lt;/a&gt; 메소드를 호출함으로써 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="51a2e917f552d1b6e1f23856874476d3b036cddf" translate="yes" xml:space="preserve">
          <source>The new short buffer</source>
          <target state="translated">새로운 짧은 버퍼</target>
        </trans-unit>
        <trans-unit id="cdfb6de24569ebdf6e37ac2a01c85f6c9999b45a" translate="yes" xml:space="preserve">
          <source>The new string.</source>
          <target state="translated">새로운 문자열.</target>
        </trans-unit>
        <trans-unit id="256bfd55d3498eaaeab282ef6a86ba7b61007791" translate="yes" xml:space="preserve">
          <source>The new value for the preference, or &lt;code&gt;null&lt;/code&gt; if the preference was removed.</source>
          <target state="translated">환경 설정의 새 값 . 환경 설정이 제거 된 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca7055dc46762027e9a170faf3c4bd0af39a754d" translate="yes" xml:space="preserve">
          <source>The new value for the property, expressed as an Object. May be null if multiple properties have changed.</source>
          <target state="translated">속성의 새로운 값으로, Object로 표현됩니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fed342089a94d554987b9df830e98f728b84e13" translate="yes" xml:space="preserve">
          <source>The new, read-only byte buffer</source>
          <target state="translated">새로운 읽기 전용 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="051bb43b66b4c67456aad2b704f6aa6b0ddd97f5" translate="yes" xml:space="preserve">
          <source>The new, read-only char buffer</source>
          <target state="translated">새로운 읽기 전용 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="5f53d1fe5257c7586da9f701a660008b6cdc42d4" translate="yes" xml:space="preserve">
          <source>The new, read-only double buffer</source>
          <target state="translated">새로운 읽기 전용 이중 버퍼</target>
        </trans-unit>
        <trans-unit id="ab388d6a1900bbf211a8682234f0d28e544b3f90" translate="yes" xml:space="preserve">
          <source>The new, read-only float buffer</source>
          <target state="translated">새로운 읽기 전용 플로트 버퍼</target>
        </trans-unit>
        <trans-unit id="f25346b335ad55392706741def759dd809ecac74" translate="yes" xml:space="preserve">
          <source>The new, read-only int buffer</source>
          <target state="translated">새로운 읽기 전용 int 버퍼</target>
        </trans-unit>
        <trans-unit id="38c3e68c7e1d834b8bc5df3c59964660afd47865" translate="yes" xml:space="preserve">
          <source>The new, read-only long buffer</source>
          <target state="translated">새로운 읽기 전용 롱 버퍼</target>
        </trans-unit>
        <trans-unit id="9632c9f4a41cbd94b91ee4867c7f6daa96d1578b" translate="yes" xml:space="preserve">
          <source>The new, read-only short buffer</source>
          <target state="translated">새로운 읽기 전용 짧은 버퍼</target>
        </trans-unit>
        <trans-unit id="c2c6f911faa099e683e433008f099f0a9b73bf5d" translate="yes" xml:space="preserve">
          <source>The newline (line feed) character (&lt;code&gt;'\u000A'&lt;/code&gt;)</source>
          <target state="translated">줄 바꿈 (줄 바꿈) 문자 ( &lt;code&gt;'\u000A'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c7384c3bb09727310bc462bab676b4596e47e94b" translate="yes" xml:space="preserve">
          <source>The newly constructed Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions.</source>
          <target state="translated">새로 구성된 세트 는 후속 수정을 허용하기 전에이 &lt;code&gt;Subject&lt;/code&gt; 읽기 전용으로 설정되어 있는지 확인합니다 . 새로 생성 된 세트는 또한 발신자가 충분한 권한을 갖도록하여 불법적 인 수정을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="950cb6be1344fde9aef742cb8b54558cb32694c0" translate="yes" xml:space="preserve">
          <source>The newly constructed Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions. These Sets also prohibit null elements, and attempts to add or query a null element will result in a &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">새로 구성된 세트 는 후속 수정을 허용하기 전에이 &lt;code&gt;Subject&lt;/code&gt; 읽기 전용으로 설정 되었는지 확인합니다 . 새로 생성 된 세트는 또한 호출자가 충분한 권한을 갖도록하여 불법적 인 수정을 방지합니다. 이러한 집합은 또한 null 요소를 금지하고 null 요소를 추가하거나 쿼리하려고하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f25a3de7da474f19021bd8b53da04f971e190cc7" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;Event&lt;/code&gt;</source>
          <target state="translated">새로 생성 된 &lt;code&gt;Event&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28a3bbb5f8626699a4150b134c9da099d4f7b9f6" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;LSParser&lt;/code&gt; object. This &lt;code&gt;LSParser&lt;/code&gt; is either synchronous or asynchronous depending on the value of the &lt;code&gt;mode&lt;/code&gt; argument.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;LSParser&lt;/code&gt; 개체입니다. 이 &lt;code&gt;LSParser&lt;/code&gt; 는 &lt;code&gt;mode&lt;/code&gt; 인수 의 값에 따라 동기식 또는 비동기식 입니다.</target>
        </trans-unit>
        <trans-unit id="2e6864f451552ad1214b39d65e1af98daa80917f" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;LSSerializer&lt;/code&gt; object.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;LSSerializer&lt;/code&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="7e9c38638d5b2ca62e0875ef6d8d3c0e6198cf85" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;NodeIterator&lt;/code&gt;.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;NodeIterator&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63f62a75ff2d1bcae67829ab95de721785ef5e31" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;TreeWalker&lt;/code&gt;.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;TreeWalker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2a279a75cbfd1b2bc63caf566b30d4919609850" translate="yes" xml:space="preserve">
          <source>The newly created input object.</source>
          <target state="translated">새로 생성 된 입력 개체입니다.</target>
        </trans-unit>
        <trans-unit id="9ad3c1c06f2258bb8b0549b75e0edff7de06d15f" translate="yes" xml:space="preserve">
          <source>The newly created layer</source>
          <target state="translated">새로 생성 된 레이어</target>
        </trans-unit>
        <trans-unit id="fbcab23ed277974083f961513c6300581cc3dddd" translate="yes" xml:space="preserve">
          <source>The newly created output object.</source>
          <target state="translated">새로 생성 된 출력 개체입니다.</target>
        </trans-unit>
        <trans-unit id="3ecdb2179dd90bd6fc6af860dcdb167b3e9dd7a7" translate="yes" xml:space="preserve">
          <source>The newly created permission object replaces the UnresolvedPermission, which is removed.</source>
          <target state="translated">새로 만든 권한 개체가 제거 된 UnresolvedPermission을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="b0535665b03585361bf66e8fd5718be81ec47c1d" translate="yes" xml:space="preserve">
          <source>The newly created thread is initially marked as being a daemon thread if and only if the thread creating it is currently marked as a daemon thread. The method &lt;a href=&quot;#setDaemon(boolean)&quot;&gt;setDaemon&lt;/a&gt; may be used to change whether or not a thread is a daemon.</source>
          <target state="translated">새로 생성 된 스레드는이를 생성하는 스레드가 현재 데몬 스레드로 표시된 경우에만 처음에는 데몬 스레드로 표시됩니다. &lt;a href=&quot;#setDaemon(boolean)&quot;&gt;setDaemon&lt;/a&gt; 메소드를 사용하여 스레드가 데몬인지 여부를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="526425b0b2a6b0567b0294d2b4111ab89f47f622" translate="yes" xml:space="preserve">
          <source>The newly created thread is initially marked as being a daemon thread if and only if the thread creating it is currently marked as a daemon thread. The method &lt;a href=&quot;thread#setDaemon-boolean-&quot;&gt;setDaemon&lt;/a&gt; may be used to change whether or not a thread is a daemon.</source>
          <target state="translated">새로 작성된 스레드는 스레드를 작성하는 스레드가 현재 디먼 스레드로 표시되는 경우에만 데몬 스레드로 표시됩니다. &lt;a href=&quot;thread#setDaemon-boolean-&quot;&gt;setDaemon&lt;/a&gt; 메소드 는 스레드가 데몬인지 여부를 변경하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1012a0ca0d70327fd286d7c29cb6bd15b1c082" translate="yes" xml:space="preserve">
          <source>The newly defined &lt;code&gt;Package&lt;/code&gt; object</source>
          <target state="translated">새롭게 정의 된 &lt;code&gt;Package&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="e8a1d4d9b98ec9cdee82b685b8101093972dd311" translate="yes" xml:space="preserve">
          <source>The newly instantiated object.</source>
          <target state="translated">새로 인스턴스화 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="30faf9343c317b3c3d65da86c3ef8e7eeaeeebe8" translate="yes" xml:space="preserve">
          <source>The next &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.</source>
          <target state="translated">반복되는 집합 의 다음 &lt;code&gt;Node&lt;/code&gt; 또는 해당 집합에 더 이상 구성원이 없으면 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cfba659f68108a8eba88e4b742d7a0c443076d6" translate="yes" xml:space="preserve">
          <source>The next attribute in the list</source>
          <target state="translated">목록의 다음 속성</target>
        </trans-unit>
        <trans-unit id="7c190fdba16a43189c716408411071b0d121dcd8" translate="yes" xml:space="preserve">
          <source>The next code fragment shows populating a &lt;code&gt;CachedRowSet&lt;/code&gt; object using the method &lt;code&gt;execute&lt;/code&gt;, which may or may not take a &lt;code&gt;Connection&lt;/code&gt; object as a parameter. This code passes &lt;code&gt;execute&lt;/code&gt; the &lt;code&gt;Connection&lt;/code&gt; object</source>
          <target state="translated">다음 코드 조각은 &lt;code&gt;execute&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체를 채우는 것을 보여줍니다. 이 메서드 는 &lt;code&gt;Connection&lt;/code&gt; 개체를 매개 변수로 사용 하거나 사용하지 않을 수 있습니다 . 이 코드는 통과 &lt;code&gt;execute&lt;/code&gt; &lt;code&gt;Connection&lt;/code&gt; 객체를</target>
        </trans-unit>
        <trans-unit id="003d3922eea2d3f53c0b82cbc99650ac135666f8" translate="yes" xml:space="preserve">
          <source>The next content model (in a ',', '|' or '&amp;amp;' expression).</source>
          <target state="translated">다음 콘텐츠 모델 ( ',', '|'또는 '&amp;amp;'표현식).</target>
        </trans-unit>
        <trans-unit id="4226522b6020d9eb89363bd243677866f295b1c0" translate="yes" xml:space="preserve">
          <source>The next event.</source>
          <target state="translated">다음 이벤트.</target>
        </trans-unit>
        <trans-unit id="62b2f558f8d0a98b00fed91f851c07fa625e66bd" translate="yes" xml:space="preserve">
          <source>The next event. This field is set when putting events into a linked list. This has been replaced by EventQueue.</source>
          <target state="translated">다음 이벤트. 이 필드는 이벤트를 연결 목록에 넣을 때 설정됩니다. 이것은 EventQueue로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc8222d0239dcfe9d56e39f9cbd0bf5bc8aa8ac0" translate="yes" xml:space="preserve">
          <source>The next example demonstrates moving to the insert row, building a new row on the insert row, inserting it into the rowset, and then calling the method &lt;code&gt;acceptChanges&lt;/code&gt; to add the new row to the underlying data source. Note that as with the getter methods, the updater methods may take either a column index or a column name to designate the column being acted upon.</source>
          <target state="translated">다음 예제에서는 삽입 행으로 이동하고, 삽입 행에 새 행을 만들고, 행 집합에 삽입 한 다음, &lt;code&gt;acceptChanges&lt;/code&gt; 메서드를 호출 하여 새 행을 기본 데이터 원본에 추가하는 방법 을 보여줍니다. getter 메서드와 마찬가지로 업데이트 프로그램 메서드는 열 인덱스 또는 열 이름을 사용하여 작업중인 열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a97853b991192fa16b78639ad825e96e507ee6" translate="yes" xml:space="preserve">
          <source>The next example is useful in situations where you wish to process data as it is ready on the</source>
          <target state="translated">다음 예제는 데이터가 준비된대로 처리하려는 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6875bb5b5c807acc8e5c2fa49dd331b238e4ca8a" translate="yes" xml:space="preserve">
          <source>The next group of &lt;code&gt;JTree&lt;/code&gt; methods use &quot;visible&quot; to mean &quot;viewable&quot; (under an expanded parent):</source>
          <target state="translated">다음 &lt;code&gt;JTree&lt;/code&gt; 메소드 그룹은 &quot;표시&quot;를 사용하여 &quot;보기 가능&quot;(확장 된 상위 아래)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b1ca923fcbee792afab001c0bf4d34e084c719f" translate="yes" xml:space="preserve">
          <source>The next simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is to extract a property value from the first argument of the method in the listener interface (typically an event object) and use it to set the value of a property in the target object. In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that sets the &lt;code&gt;nextFocusableComponent&lt;/code&gt; property of the target (myButton) object to the value of the &quot;source&quot; property of the event.</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 의 다음으로 가장 간단한 용도 는 리스너 인터페이스에서 메소드의 첫 번째 인수 (일반적으로 이벤트 오브젝트)에서 특성 값을 추출하고이를 사용하여 대상 오브젝트에서 특성 값을 설정하는 것입니다. 다음 예제 에서는 대상 (myButton) 객체 의 &lt;code&gt;nextFocusableComponent&lt;/code&gt; 속성을 이벤트의 &quot;source&quot;속성 값으로 설정 하는 &lt;code&gt;ActionListener&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3823007117061ff42c1e7a6b40c6d8a19f34ccd0" translate="yes" xml:space="preserve">
          <source>The next time paint is invoked on the viewport, if the clip region is smaller than the viewport size a timer is kicked off to repaint the whole region.</source>
          <target state="translated">다음에 뷰포트에서 페인트를 호출 할 때 클립 영역이 뷰포트 크기보다 작 으면 타이머가 시작되어 전체 영역을 다시 페인트합니다.</target>
        </trans-unit>
        <trans-unit id="f9a2faf9fb3b9f8ae2040c7c4e5d190ce7ecc0af" translate="yes" xml:space="preserve">
          <source>The next type of ID are offset-style IDs with some form of prefix, such as 'GMT+2' or 'UTC+01:00'. The recognised prefixes are 'UTC', 'GMT' and 'UT'. The offset is the suffix and will be normalized during creation. These IDs can be normalized to a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;code&gt;normalized()&lt;/code&gt;.</source>
          <target state="translated">다음 유형의 ID는 'GMT + 2'또는 'UTC + 01 : 00'과 같은 접두사 형식의 오프셋 스타일 ID입니다. 인식되는 접두사는 'UTC', 'GMT'및 'UT'입니다. 오프셋은 접미사이며 작성 중에 정규화됩니다. 이 ID는 &lt;code&gt;normalized()&lt;/code&gt; 사용하여 &lt;code&gt;ZoneOffset&lt;/code&gt; 으로 정규화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86e912d40d864957a142854d170c406757cb0414" translate="yes" xml:space="preserve">
          <source>The node added.</source>
          <target state="translated">노드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e44f1d28b1ed0c6128cf75964dda2af57cb4bc43" translate="yes" xml:space="preserve">
          <source>The node at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;NodeList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">상기 노드 &lt;code&gt;index&lt;/code&gt; 번째 위치에서 상기 &lt;code&gt;NodeList&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 인덱스가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="8f08767eb41800bbfbde9bbe5607f86187a21279" translate="yes" xml:space="preserve">
          <source>The node at the &lt;code&gt;index&lt;/code&gt;th position in the map, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">맵에서 &lt;code&gt;index&lt;/code&gt; 번째 위치 의 노드 또는 유효한 색인이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25dcefb2a69d40c85715032a38d4c765b6ad7ec0" translate="yes" xml:space="preserve">
          <source>The node at which the &lt;code&gt;TreeWalker&lt;/code&gt; is currently positioned.</source>
          <target state="translated">&lt;code&gt;TreeWalker&lt;/code&gt; 가 현재 위치 하는 노드 입니다.</target>
        </trans-unit>
        <trans-unit id="25c2494a9062b0a4fec44eb9e5d8f2a5f7bf6cf4" translate="yes" xml:space="preserve">
          <source>The node being inserted.</source>
          <target state="translated">삽입되는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="eefd68869134b5c6003f67d668b41f50e9088f4b" translate="yes" xml:space="preserve">
          <source>The node contains the reference node.</source>
          <target state="translated">노드에는 참조 노드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="926d4c6c5c9641e6784d6df9d9121f96b518e1d8" translate="yes" xml:space="preserve">
          <source>The node contains the reference node. A node which contains is always preceding, too.</source>
          <target state="translated">노드에는 참조 노드가 포함됩니다. 포함하는 노드도 항상 선행합니다.</target>
        </trans-unit>
        <trans-unit id="72cdab6fabcb4973b8730812adba18d5fc92d324" translate="yes" xml:space="preserve">
          <source>The node follows the reference node.</source>
          <target state="translated">노드는 참조 노드를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5a40a86d7ba4c3fbae277f67eaa1edd72c64dac0" translate="yes" xml:space="preserve">
          <source>The node immediately following this node.</source>
          <target state="translated">이 노드 바로 다음 노드입니다.</target>
        </trans-unit>
        <trans-unit id="70e1299d21c7e340ff3f7d3d35f755d09b6b0a68" translate="yes" xml:space="preserve">
          <source>The node immediately following this node. If there is no such node, this returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 노드 바로 다음 노드입니다. 그러한 노드가 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="688be01f5e712790a2f07c91bccb3e81dc55084a" translate="yes" xml:space="preserve">
          <source>The node immediately preceding this node.</source>
          <target state="translated">The node immediately preceding this node.</target>
        </trans-unit>
        <trans-unit id="489a2f7876809d76036f44c18b0a6878267c599e" translate="yes" xml:space="preserve">
          <source>The node immediately preceding this node. If there is no such node, this returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">The node immediately preceding this node. If there is no such node, this returns &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d88a4ea137aa25d2bcdb9f0d29337d00d2719f5" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;CDATASection&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;CDATASection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3992c5decf9ee81e9249173454da0089170acc0c" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Comment&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;Comment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cfa4ce440134eec7d17e729483d88d0752609d0" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Document&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;Document&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1253bf6ce5e8d87245eb71c8e7995f7e9d2713a" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;DocumentFragment&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;DocumentFragment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="104e203c7a3beb38e0173d43a12cd8263e1662ab" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;DocumentType&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;DocumentType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70799baaed087daa78146fe3d2c82c5e97d198f8" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Notation&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;Notation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6959c6bb576b424cf20edc90de27e85139e0b7d6" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;ProcessingInstruction&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;ProcessingInstruction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82181fc9a25ccdbbaa459ae8ffabba3c6b011e07" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Text&lt;/code&gt; node.</source>
          <target state="translated">The node is a &lt;code&gt;Text&lt;/code&gt; node.</target>
        </trans-unit>
        <trans-unit id="a4f1fdcd6851b1862447156d36f1a8064edcbdef" translate="yes" xml:space="preserve">
          <source>The node is adopted, using &lt;code&gt;Document.adoptNode()&lt;/code&gt;.</source>
          <target state="translated">The node is adopted, using &lt;code&gt;Document.adoptNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652436729df0bb208fdc046aefbfa457dcae47c3" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;Attr&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;Attr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e118daebecbe6e623fcaf62887ad574669481e6b" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;Element&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;Element&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d8a8c8365746d5f22ab7e728d5b9e9461515cb7" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;Entity&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;Entity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c777aafc5adf73466ca4dc068f72c31fa299122" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;EntityReference&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;EntityReference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31d528f4cb617d25ed6bf587586d2e01a3d6d2b4" translate="yes" xml:space="preserve">
          <source>The node is cloned, using &lt;code&gt;Node.cloneNode()&lt;/code&gt;.</source>
          <target state="translated">The node is cloned, using &lt;code&gt;Node.cloneNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b94cbc6b4a584d6bdaedb2ccd9ce9afc37897036" translate="yes" xml:space="preserve">
          <source>The node is contained by the reference node.</source>
          <target state="translated">The node is contained by the reference node.</target>
        </trans-unit>
        <trans-unit id="d6ece946ea02ee3d159660f34819134d355f68bc" translate="yes" xml:space="preserve">
          <source>The node is contained by the reference node. A node which is contained is always following, too.</source>
          <target state="translated">The node is contained by the reference node. A node which is contained is always following, too.</target>
        </trans-unit>
        <trans-unit id="e47a628abe4bcb510d76413db50a34ada4a36683" translate="yes" xml:space="preserve">
          <source>The node is deleted.</source>
          <target state="translated">The node is deleted.</target>
        </trans-unit>
        <trans-unit id="83672ddfbdbb04e6267923061fcdb494f10ed227" translate="yes" xml:space="preserve">
          <source>The node is imported, using &lt;code&gt;Document.importNode()&lt;/code&gt;.</source>
          <target state="translated">The node is imported, using &lt;code&gt;Document.importNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be958ab1a3a5b153c7e4bd485baa0f017b8a0164" translate="yes" xml:space="preserve">
          <source>The node is renamed, using &lt;code&gt;Document.renameNode()&lt;/code&gt;.</source>
          <target state="translated">The node is renamed, using &lt;code&gt;Document.renameNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e411af71a3a83badf3b4023e66910b22ac252a" translate="yes" xml:space="preserve">
          <source>The node removed from this map if a node with such a local name and namespace URI exists.</source>
          <target state="translated">The node removed from this map if a node with such a local name and namespace URI exists.</target>
        </trans-unit>
        <trans-unit id="b661946dd93bda0e46530c86097ef476c83f10f5" translate="yes" xml:space="preserve">
          <source>The node removed from this map if a node with such a name exists.</source>
          <target state="translated">The node removed from this map if a node with such a name exists.</target>
        </trans-unit>
        <trans-unit id="e4ac372935e647fb4df00b130e6084b54ef6b1be" translate="yes" xml:space="preserve">
          <source>The node removed.</source>
          <target state="translated">The node removed.</target>
        </trans-unit>
        <trans-unit id="4bc33794277995ad7b77021ec5435f72d849a19b" translate="yes" xml:space="preserve">
          <source>The node replaced.</source>
          <target state="translated">The node replaced.</target>
        </trans-unit>
        <trans-unit id="7572680b2b80e8ffbe2e43845817ff3163683c09" translate="yes" xml:space="preserve">
          <source>The node that is the location for the event.</source>
          <target state="translated">The node that is the location for the event.</target>
        </trans-unit>
        <trans-unit id="e6c54c2549b66a4b21ce4b74222cef22b07b4422" translate="yes" xml:space="preserve">
          <source>The node that is to be transformed.</source>
          <target state="translated">The node that is to be transformed.</target>
        </trans-unit>
        <trans-unit id="2244b9f1c988f6ab45e1adc3aeaad05d28dd975b" translate="yes" xml:space="preserve">
          <source>The node that was added or removed.</source>
          <target state="translated">추가 또는 제거 된 노드입니다.</target>
        </trans-unit>
        <trans-unit id="ed73ee97c8cd24a6296d058a31d1ef9c51cf1abe" translate="yes" xml:space="preserve">
          <source>The node this locator is pointing to, or &lt;code&gt;null&lt;/code&gt; if no node is available.</source>
          <target state="translated">The node this locator is pointing to, or &lt;code&gt;null&lt;/code&gt; if no node is available.</target>
        </trans-unit>
        <trans-unit id="6d6f08034b2207c569504846755de13d16de0411" translate="yes" xml:space="preserve">
          <source>The node to which the transformation will be appended.</source>
          <target state="translated">The node to which the transformation will be appended.</target>
        </trans-unit>
        <trans-unit id="4c914679c177f8361a70044b7d9e5fed26293161" translate="yes" xml:space="preserve">
          <source>The node value associated with this UUID.</source>
          <target state="translated">이 UUID와 연관된 노드 값입니다.</target>
        </trans-unit>
        <trans-unit id="5bbeb5b168502d18da4f1fe9867711841ff15466" translate="yes" xml:space="preserve">
          <source>The node value is only meaningful in a time-based UUID, which has version type 1. If this UUID is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">노드 값은 버전 유형이 1 인 시간 기반 UUID에서만 의미가 있습니다.이 UUID가 시간 기반 UUID가 아닌 경우이 메소드는 UnsupportedOperationException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b2c083ad90bd1defea28a63436df660a7fd1208e" translate="yes" xml:space="preserve">
          <source>The node value of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 노드 치</target>
        </trans-unit>
        <trans-unit id="116e08dc3c5462998592161ec4267b36074a602d" translate="yes" xml:space="preserve">
          <source>The non-&lt;code&gt;void&lt;/code&gt; result from a step function call is used to update the corresponding value in the sequence &lt;code&gt;(v...)&lt;/code&gt; of loop variables. The updated value is immediately visible to all subsequent function calls.</source>
          <target state="translated">The non- &lt;code&gt;void&lt;/code&gt; result from a step function call is used to update the corresponding value in the sequence &lt;code&gt;(v...)&lt;/code&gt; of loop variables. The updated value is immediately visible to all subsequent function calls.</target>
        </trans-unit>
        <trans-unit id="b799d392c13f57a4244dc8cc1be985c89795fd60" translate="yes" xml:space="preserve">
          <source>The non-baseline tags included in this class are:</source>
          <target state="translated">The non-baseline tags included in this class are:</target>
        </trans-unit>
        <trans-unit id="dbb6f21cdd21b51f043b1d7e9cd850253fc91842" translate="yes" xml:space="preserve">
          <source>The non-baseline values of baseline tags included in this class are</source>
          <target state="translated">The non-baseline values of baseline tags included in this class are</target>
        </trans-unit>
        <trans-unit id="abbf56635d9b1770e8f377f88d7eb5625296e6d7" translate="yes" xml:space="preserve">
          <source>The non-negative number of components in this LDAP name.</source>
          <target state="translated">이 LDAP 이름에서 음수가 아닌 수의 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="0ec6632ce3dac4952c6d1e6de9a5a4ac96bd4964" translate="yes" xml:space="preserve">
          <source>The non-negative number of type/value pairs in this Rdn.</source>
          <target state="translated">이 Rdn에서 음수가 아닌 유형 / 값 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="04c40e79aa1d2b145632c16a6ba96e3ddd6f6561" translate="yes" xml:space="preserve">
          <source>The non-null &lt;code&gt;EventContext&lt;/code&gt; that fired this event.</source>
          <target state="translated">이 이벤트를 발생시킨 null 이외의 &lt;code&gt;EventContext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9835e454d9aa1da3cda1a5d111588c0dd9c03234" translate="yes" xml:space="preserve">
          <source>The non-null Attribute ID of the sort key.</source>
          <target state="translated">정렬 키의 널이 아닌 속성 ID.</target>
        </trans-unit>
        <trans-unit id="72f787f2a198f8fedf6cb84c6fe0b5e362381096" translate="yes" xml:space="preserve">
          <source>The non-null RDN at index posn.</source>
          <target state="translated">인덱스 위치에서 널이 아닌 RDN입니다.</target>
        </trans-unit>
        <trans-unit id="e27f3c4b638ce7540d85488b7dcdab9e1e5afc40" translate="yes" xml:space="preserve">
          <source>The non-null Reference of this object.</source>
          <target state="translated">이 객체의 null 이외의 Reference</target>
        </trans-unit>
        <trans-unit id="3a820348b05a92e3255fb97f0c53e3ffddc88be6" translate="yes" xml:space="preserve">
          <source>The non-null address type of this address.</source>
          <target state="translated">이 주소의 널이 아닌 주소 유형.</target>
        </trans-unit>
        <trans-unit id="d2201b95b88b6f901440dc4bbfb1317bf8e7ee42" translate="yes" xml:space="preserve">
          <source>The non-null attribute to use for the modification.</source>
          <target state="translated">수정에 사용할 널이 아닌 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c9313ebf57ec9424f831b52f67bbfc348328c4ee" translate="yes" xml:space="preserve">
          <source>The non-null attribute type.</source>
          <target state="translated">널이 아닌 속성 유형.</target>
        </trans-unit>
        <trans-unit id="e8b69252e6ee01638d108902e5793b76660660f5" translate="yes" xml:space="preserve">
          <source>The non-null attribute value.</source>
          <target state="translated">널이 아닌 속성 값.</target>
        </trans-unit>
        <trans-unit id="2715e88a065e5152070b841d877e00fdf01a9b7e" translate="yes" xml:space="preserve">
          <source>The non-null attributes containing the type/value mappings of this Rdn.</source>
          <target state="translated">이 Rdn의 형태 / 치의 매핑을 포함한 null 이외의 속성</target>
        </trans-unit>
        <trans-unit id="e7d5ad9946b78e64d8017c4154edc754f5fde616" translate="yes" xml:space="preserve">
          <source>The non-null attributes in this search result. Can be empty.</source>
          <target state="translated">이 검색 결과의 널이 아닌 속성입니다. 비워 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e85cdf81db9eeec068d8d09a8ef2fb4c407fd0" translate="yes" xml:space="preserve">
          <source>The non-null buffer containing this address's contents.</source>
          <target state="translated">이 주소의 내용을 포함한 null 이외의 버퍼</target>
        </trans-unit>
        <trans-unit id="3d9f08aa3696853e49ea210dd84b71a816664327" translate="yes" xml:space="preserve">
          <source>The non-null cached initial context.</source>
          <target state="translated">널이 아닌 캐시 된 초기 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="ff3c6126fdf1cc140a98a5cb1cbb91b07b9dae34" translate="yes" xml:space="preserve">
          <source>The non-null component at index posn.</source>
          <target state="translated">인덱스 위치에서 널이 아닌 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a0cd8693286f7ab03bf8dfc7ae7e3825ff062d8e" translate="yes" xml:space="preserve">
          <source>The non-null context at which to continue the method.</source>
          <target state="translated">메소드를 계속할 널이 아닌 컨텍스트.</target>
        </trans-unit>
        <trans-unit id="d451c4f1e3abd2fc769f4b6cdd808b41cafdf4b1" translate="yes" xml:space="preserve">
          <source>The non-null context that fired this event.</source>
          <target state="translated">이 이벤트를 발생시킨 null 이외의 컨텍스트</target>
        </trans-unit>
        <trans-unit id="6ccd0c9d630cefab9c9188537f5d448330d7fbd1" translate="yes" xml:space="preserve">
          <source>The non-null fully-qualified class name of the object. (e.g. &quot;java.lang.String&quot;)</source>
          <target state="translated">객체의 null이 아닌 정규화 된 클래스 이름입니다. (예 : &quot;java.lang.String&quot;)</target>
        </trans-unit>
        <trans-unit id="55a9d1f6cd92ef1fb0cc4c11ee02219bb6a9c640" translate="yes" xml:space="preserve">
          <source>The non-null name of this binding.</source>
          <target state="translated">이 바인딩의 null 이외의 이름</target>
        </trans-unit>
        <trans-unit id="379e7340b01855217e56feddfd0c3f522ce31421" translate="yes" xml:space="preserve">
          <source>The non-null name of this link.</source>
          <target state="translated">이 링크의 null 이외의 이름</target>
        </trans-unit>
        <trans-unit id="42b9a5b2a8d6c68424fd72083172c212655d9589" translate="yes" xml:space="preserve">
          <source>The non-null object identifier string representing the LDAP &lt;code&gt;ExtendedRequest.requestName&lt;/code&gt; component.</source>
          <target state="translated">LDAP &lt;code&gt;ExtendedRequest.requestName&lt;/code&gt; 구성 요소를 나타내는 널이 아닌 오브젝트 ID 문자열 .</target>
        </trans-unit>
        <trans-unit id="2cb882abf23a7aa368fb5faa23b533a76c55bbc5" translate="yes" xml:space="preserve">
          <source>The non-null object identifier string.</source>
          <target state="translated">널이 아닌 오브젝트 ID 문자열.</target>
        </trans-unit>
        <trans-unit id="b295dc0fd888ea6d48259db4af3e90633d18ef36" translate="yes" xml:space="preserve">
          <source>The non-null object representing &lt;code&gt;obj&lt;/code&gt;'s state for binding. It could be the object (&lt;code&gt;obj&lt;/code&gt;) itself.</source>
          <target state="translated">바인딩의 &lt;code&gt;obj&lt;/code&gt; 상태를 나타내는 null 이외의 객체 객체 ( &lt;code&gt;obj&lt;/code&gt; ) 자체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f69773c16095a881d10252c9218f6c6e3c34b88" translate="yes" xml:space="preserve">
          <source>The non-null string containing the string representation of this exception.</source>
          <target state="translated">이 예외의 캐릭터 라인 표현을 포함한 null 이외의 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="44e96a35fa5e2445cf72315bf35956f839cecc36" translate="yes" xml:space="preserve">
          <source>The non-null string containing the string representation.</source>
          <target state="translated">문자열 표현을 포함하는 널이 아닌 문자열.</target>
        </trans-unit>
        <trans-unit id="b5944a034b359b83174f56a2a7f96839e7b38494" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this address.</source>
          <target state="translated">이 주소의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c14b6c44d0bf24b5cea45b3da8630bae20b53ad4" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this attribute.</source>
          <target state="translated">이 속성의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="e489b76b389ad519e5854a5f41ece2a22837acbc" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this binding.</source>
          <target state="translated">이 바인딩의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="5bd52f1e3944566dde82d6b472de7f01b46708e3" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this exception.</source>
          <target state="translated">이 예외의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="42db8fc25d73e560ebf5468300a8bc2116164162" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this link exception.</source>
          <target state="translated">이 링크 예외의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="514dc42a6376eec82b1d1ca24105735005dbb207" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this modification item.</source>
          <target state="translated">이 수정 아이템의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c944d1dbf9885fa579e084db281b25ba8d8a9512" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this reference.</source>
          <target state="translated">이 참조의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="f67fe15778905975a7fa5a2327a8581b53a9f83e" translate="yes" xml:space="preserve">
          <source>The non-null unsolicited notification that caused this event to be fired.</source>
          <target state="translated">이 이벤트를 발생시키는 널이 아닌 원치 않는 알림입니다.</target>
        </trans-unit>
        <trans-unit id="d47f97097499b7920b445b44552f3b93fe502268" translate="yes" xml:space="preserve">
          <source>The nonnegative number of addresses in this reference.</source>
          <target state="translated">이 참조에서 음수가 아닌 주소 수입니다.</target>
        </trans-unit>
        <trans-unit id="763b0638d66b2e279fdcda534bfb0307f9e14a5c" translate="yes" xml:space="preserve">
          <source>The nonnegative number of attributes in this attribute set.</source>
          <target state="translated">이 속성 세트의 음수가 아닌 속성 수입니다.</target>
        </trans-unit>
        <trans-unit id="27a92262272f2e066164e4797757c92e88b495a7" translate="yes" xml:space="preserve">
          <source>The nonnegative number of components in this composite name.</source>
          <target state="translated">이 컴퍼 짓 이름의 음수가 아닌 수의 컴포넌트.</target>
        </trans-unit>
        <trans-unit id="2ae208f4c4b22b7904207d628361c77d6ba61f42" translate="yes" xml:space="preserve">
          <source>The nonnegative number of components in this compound name.</source>
          <target state="translated">이 화합물 명의 음수가 아닌 수의 성분.</target>
        </trans-unit>
        <trans-unit id="933031459aff054e43a842b4fd2dd5ed57b4a079" translate="yes" xml:space="preserve">
          <source>The nonnegative number of values in this attribute.</source>
          <target state="translated">이 속성의 음수가 아닌 값 수입니다.</target>
        </trans-unit>
        <trans-unit id="f552faffb0355ddf1b05a015bb7baf11154da3d5" translate="yes" xml:space="preserve">
          <source>The normal argument conversion rules for &lt;code&gt;MethodHandle.invoke&lt;/code&gt; apply to all stacked arguments. For example, if a pushed value is a primitive type, it may be converted to a reference by boxing conversion. If the bootstrap method is a variable arity method (its modifier bit &lt;code&gt;0x0080&lt;/code&gt; is set), then some or all of the arguments specified here may be collected into a trailing array parameter. (This is not a special rule, but rather a useful consequence of the interaction between &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constants, the modifier bit for variable arity methods, and the &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; transformation.)</source>
          <target state="translated">&lt;code&gt;MethodHandle.invoke&lt;/code&gt; 의 일반 인수 변환 규칙은 모든 누적 인수에 적용됩니다. 예를 들어, 푸시 된 값이 기본 유형 인 경우 복싱 변환을 통해 참조로 변환 될 수 있습니다. 부트 스트랩 방법이 가변 arity 방법 인 경우 (수정 자 비트 &lt;code&gt;0x0080&lt;/code&gt; 이 설정 됨) 여기에 지정된 인수 중 일부 또는 전부가 후행 배열 매개 변수로 수집 될 수 있습니다. (이것은 특별한 규칙이 아니라 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수, 변수 arity 메소드의 수정 자 비트 및 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt; 변환 간의 상호 작용으로 인한 유용한 결과입니다 .)</target>
        </trans-unit>
        <trans-unit id="92e831571304f766e53b7678f2c8bc953d39e95a" translate="yes" xml:space="preserve">
          <source>The normal use of the &quot;privileged&quot; feature is as follows. If you don't need to return a value from within the &quot;privileged&quot; block, do the following:</source>
          <target state="translated">&quot;권한있는&quot;기능의 일반적인 사용법은 다음과 같습니다. &quot;privileged&quot;블록 내에서 값을 반환 할 필요가 없으면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1713b6c492038d81b6717f471a6bc21770c3edef" translate="yes" xml:space="preserve">
          <source>The normalization checks if the rules of this &lt;code&gt;ZoneId&lt;/code&gt; have a fixed offset. If they do, then the &lt;code&gt;ZoneOffset&lt;/code&gt; equal to that offset is returned. Otherwise &lt;code&gt;this&lt;/code&gt; is returned.</source>
          <target state="translated">정규화는이 &lt;code&gt;ZoneId&lt;/code&gt; 의 규칙에 고정 오프셋 이 있는지 확인합니다 . 그렇게 하면 해당 오프셋과 같은 &lt;code&gt;ZoneOffset&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 &lt;code&gt;this&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2cd0ae79d9cf181d6f2f03a35a1f43855bdc7fd" translate="yes" xml:space="preserve">
          <source>The normalized String</source>
          <target state="translated">정규화 된 문자열</target>
        </trans-unit>
        <trans-unit id="1b1f85af4c6b9e902075539bd21a4b792674f3bd" translate="yes" xml:space="preserve">
          <source>The normative value constraint stated relative to month field's value is in &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D&lt;/a&gt;.</source>
          <target state="translated">The normative value constraint stated relative to month field's value is in &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4221fe7c43b2be1f1fe74901de3af60a78573671" translate="yes" xml:space="preserve">
          <source>The north layout constraint (top of container).</source>
          <target state="translated">The north layout constraint (top of container).</target>
        </trans-unit>
        <trans-unit id="c780ad14e7504360c8fafa2a94843c0740f74099" translate="yes" xml:space="preserve">
          <source>The north-east-resize cursor type.</source>
          <target state="translated">The north-east-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="239d8e4a2f499ca8854b5485f8b1ea607325532b" translate="yes" xml:space="preserve">
          <source>The north-resize cursor type.</source>
          <target state="translated">The north-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="2977eceb5994e17fa1f7c0dfe7bf3a323d5dcca6" translate="yes" xml:space="preserve">
          <source>The north-west-resize cursor type.</source>
          <target state="translated">The north-west-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="22d006471ccb7e48bf28b33ef811fdaa4f31ba30" translate="yes" xml:space="preserve">
          <source>The notation name.</source>
          <target state="translated">The notation name.</target>
        </trans-unit>
        <trans-unit id="46f4f42f6b54d68a6627b5ec7f9323ab37bbc2ac" translate="yes" xml:space="preserve">
          <source>The notation's public identifier, or null if none was given.</source>
          <target state="translated">The notation's public identifier, or null if none was given.</target>
        </trans-unit>
        <trans-unit id="c0a171fe5edbbdcd09395d7988a9b4e98a3f2976" translate="yes" xml:space="preserve">
          <source>The notation's system identifier, or null if none was given.</source>
          <target state="translated">The notation's system identifier, or null if none was given.</target>
        </trans-unit>
        <trans-unit id="78ac89e34bb33075084c8e8edd00338d1db15d21" translate="yes" xml:space="preserve">
          <source>The notification emitted is a &lt;a href=&quot;../../../javax/management/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; instance whose &lt;a href=&quot;../../../javax/management/notification#setUserData(java.lang.Object)&quot;&gt;&lt;code&gt;user data&lt;/code&gt;&lt;/a&gt; is set to a &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt; that represents a &lt;a href=&quot;memorynotificationinfo&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt; object containing information about the memory pool when the notification was constructed. The &lt;code&gt;CompositeData&lt;/code&gt; contains the attributes as described in &lt;a href=&quot;memorynotificationinfo#from(javax.management.openmbean.CompositeData)&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The notification emitted is a &lt;a href=&quot;../../../javax/management/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; instance whose &lt;a href=&quot;../../../javax/management/notification#setUserData(java.lang.Object)&quot;&gt; &lt;code&gt;user data&lt;/code&gt; &lt;/a&gt; is set to a &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; that represents a &lt;a href=&quot;memorynotificationinfo&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; object containing information about the memory pool when the notification was constructed. The &lt;code&gt;CompositeData&lt;/code&gt; contains the attributes as described in &lt;a href=&quot;memorynotificationinfo#from(javax.management.openmbean.CompositeData)&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b815b7a69fff83a89aecb794ceb17aa59e315dbf" translate="yes" xml:space="preserve">
          <source>The notification emitted is a &lt;a href=&quot;../../../javax/management/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; instance whose &lt;a href=&quot;../../../javax/management/notification#setUserData-java.lang.Object-&quot;&gt;&lt;code&gt;user data&lt;/code&gt;&lt;/a&gt; is set to a &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt; that represents a &lt;a href=&quot;memorynotificationinfo&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt; object containing information about the memory pool when the notification was constructed. The &lt;code&gt;CompositeData&lt;/code&gt; contains the attributes as described in &lt;a href=&quot;memorynotificationinfo#from-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성 된 알림은 &lt;a href=&quot;../../../javax/management/notification#setUserData-java.lang.Object-&quot;&gt; &lt;code&gt;user data&lt;/code&gt; &lt;/a&gt; 가 알림이 생성 될 때 메모리 풀에 대한 정보를 포함 하는 &lt;a href=&quot;memorynotificationinfo&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; 객체 를 나타내는 &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 로 설정된 &lt;a href=&quot;../../../javax/management/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; 인스턴스입니다 . &lt;code&gt;CompositeData&lt;/code&gt; 에은 에 설명 된대로 속성을 포함 &lt;a href=&quot;memorynotificationinfo#from-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d43792640468618be4943696b58814c5982d2f01" translate="yes" xml:space="preserve">
          <source>The notification sequence number within the source object. It's a serial number identifying a particular instance of notification in the context of the notification source. The notification model does not assume that notifications will be received in the same order that they are sent. The sequence number helps listeners to sort received notifications.</source>
          <target state="translated">소스 객체 내의 알림 시퀀스 번호입니다. 알림 소스와 관련하여 특정 알림 인스턴스를 식별하는 일련 번호입니다. 통지 모델은 통지가 송신 된 순서와 동일한 순서로 수신된다고 가정하지 않습니다. 시퀀스 번호는 리스너가 수신 된 알림을 정렬하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="047c41230a085945fb649a5ebbbac0f9cc2023e7" translate="yes" xml:space="preserve">
          <source>The notification source and a set of parameters concerning the monitor MBean's state need to be specified when creating a new object of this class. The list of notifications fired by the monitor MBeans is the following:</source>
          <target state="translated">이 클래스의 새 오브젝트를 작성할 때 모니터 MBean 상태에 관한 알림 소스 및 매개 변수 세트를 지정해야합니다. 모니터 MBean에 의해 발생 된 통지 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5e52f5aa1ac9e3d0cc53022642f1d2fa738c7f5" translate="yes" xml:space="preserve">
          <source>The notification timestamp.</source>
          <target state="translated">알림 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="1cc0bdffa957699c3503e9a21edd9c5510954093" translate="yes" xml:space="preserve">
          <source>The notification type is one of the following:</source>
          <target state="translated">알림 유형은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="54f36e19da8052d6b002a6408bea252c14dac4d8" translate="yes" xml:space="preserve">
          <source>The notification type. It's a string expressed in a dot notation similar to Java properties. It is recommended that the notification type should follow the reverse-domain-name convention used by Java package names. An example of a notification type is com.example.alarm.router.</source>
          <target state="translated">알림 유형 Java 특성과 유사한 점 표기법으로 표현 된 문자열입니다. 알림 유형은 Java 패키지 이름에서 사용하는 역 도메인 이름 규칙을 따라야합니다. 알림 유형의 예는 com.example.alarm.router입니다.</target>
        </trans-unit>
        <trans-unit id="1924a5b15b3249ce092a029bd89121d0f77e325f" translate="yes" xml:space="preserve">
          <source>The notification.</source>
          <target state="translated">알림.</target>
        </trans-unit>
        <trans-unit id="fab265b6684bbffb1f218488bc04b79bf0141ad3" translate="yes" xml:space="preserve">
          <source>The null byte &lt;code&gt;'\u0000'&lt;/code&gt; is encoded in 2-byte format rather than 1-byte, so that the encoded strings never have embedded nulls.</source>
          <target state="translated">널 바이트 &lt;code&gt;'\u0000'&lt;/code&gt; 은 1 바이트가 아닌 2 바이트 형식으로 인코딩되므로 인코딩 된 문자열에 널이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="556c462e53e5ab353ef562a0763b91624cdf0bb0" translate="yes" xml:space="preserve">
          <source>The null character &lt;code&gt;'\u0000'&lt;/code&gt; and characters in the range &lt;code&gt;'\u0080'&lt;/code&gt; to &lt;code&gt;'\u07FF'&lt;/code&gt; are represented by a pair of bytes.</source>
          <target state="translated">The null character &lt;code&gt;'\u0000'&lt;/code&gt; and characters in the range &lt;code&gt;'\u0080'&lt;/code&gt; to &lt;code&gt;'\u07FF'&lt;/code&gt; are represented by a pair of bytes.</target>
        </trans-unit>
        <trans-unit id="3b8e10011b092d252f9eb3176c082893795abb5d" translate="yes" xml:space="preserve">
          <source>The null character &lt;code&gt;'\u0000'&lt;/code&gt; and characters in the range &lt;code&gt;'\u0080'&lt;/code&gt; to &lt;code&gt;'\u07FF'&lt;/code&gt; are represented by a pair of bytes:</source>
          <target state="translated">널 문자 &lt;code&gt;'\u0000'&lt;/code&gt; 범위의 문자 &lt;code&gt;'\u0080'&lt;/code&gt; 에 &lt;code&gt;'\u07FF'&lt;/code&gt; 바이트 쌍으로 표현된다 :</target>
        </trans-unit>
        <trans-unit id="fdf012dbbee5e63f7359a0dcd636e783461bf0ec" translate="yes" xml:space="preserve">
          <source>The null type.</source>
          <target state="translated">널 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bfa4624adbb58928ef8efb29a2f80d2c80dac18c" translate="yes" xml:space="preserve">
          <source>The null value.</source>
          <target state="translated">널값</target>
        </trans-unit>
        <trans-unit id="72eeb7ae48294ef46081a7a538e4507ac50ff336" translate="yes" xml:space="preserve">
          <source>The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers in dates and times.</source>
          <target state="translated">The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers in dates and times.</target>
        </trans-unit>
        <trans-unit id="62bb929eddf4e5076a6c1af6a73ff7f12b318660" translate="yes" xml:space="preserve">
          <source>The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers in dates and times. Subclasses should initialize this to a number format appropriate for the locale associated with this &lt;code&gt;DateFormat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DateFormat&lt;/code&gt; 이 날짜 및 시간 의 숫자를 형식화하는 데 사용하는 숫자 형식 기입니다 . 서브 클래스는 이것을이 &lt;code&gt;DateFormat&lt;/code&gt; 에 관련한 로케일에 적절한 수치 형식으로 초기화 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e937f460d16c2dd03c469010edefe2fdea52818a" translate="yes" xml:space="preserve">
          <source>The number is equal to or greater than 70 and followed by a space, comma, slash, or end of string</source>
          <target state="translated">숫자는 70 이상이며 공백, 쉼표, 슬래시 또는 문자열 끝이 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="20c65393a3bac9d4d95cbcb35c3376b737c51fb4" translate="yes" xml:space="preserve">
          <source>The number is less than 70, and both a month and a day of the month have already been recognized</source>
          <target state="translated">숫자는 70보다 작으며 한 달과 한 달이 이미 인식되었습니다.</target>
        </trans-unit>
        <trans-unit id="1cc438c896ef962d5026bc123197b09edc413720" translate="yes" xml:space="preserve">
          <source>The number is regarded as a year number if one of the following conditions is true:</source>
          <target state="translated">다음 조건 중 하나에 해당하면 숫자는 연도 숫자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd17b0115dc526bf174fa810f72abf0661f26d1" translate="yes" xml:space="preserve">
          <source>The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below.</source>
          <target state="translated">The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below.</target>
        </trans-unit>
        <trans-unit id="75342f1094eb495c3aabd48425339086d2ad1cdf" translate="yes" xml:space="preserve">
          <source>The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below. This may have the value zero, i.e., &lt;code&gt;CharacterData&lt;/code&gt; nodes may be empty.</source>
          <target state="translated">The number of 16-bit units that are available through &lt;code&gt;data&lt;/code&gt; and the &lt;code&gt;substringData&lt;/code&gt; method below. This may have the value zero, i.e., &lt;code&gt;CharacterData&lt;/code&gt; nodes may be empty.</target>
        </trans-unit>
        <trans-unit id="0c4b5ddabaf56d5c4c36a5570d9d6d29d030dd4e" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMImplementation&lt;/code&gt;s in the list.</source>
          <target state="translated">The number of &lt;code&gt;DOMImplementation&lt;/code&gt; s in the list.</target>
        </trans-unit>
        <trans-unit id="9489088a467b83bdca0bfdbd7c936cad49d78114" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMImplementation&lt;/code&gt;s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of &lt;code&gt;DOMImplementation&lt;/code&gt; s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="3151dddf297321dd67d138ddf19d1b8fa0097bde" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMString&lt;/code&gt;s in the list.</source>
          <target state="translated">The number of &lt;code&gt;DOMString&lt;/code&gt; s in the list.</target>
        </trans-unit>
        <trans-unit id="675390bfaee708d77610d340d5e3baa3976e86f8" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;DOMString&lt;/code&gt;s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of &lt;code&gt;DOMString&lt;/code&gt; s in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="60a60822d38a3770fe364352a19792205d536947" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;TIFFField&lt;/code&gt;s in this &lt;code&gt;TIFFDirectory&lt;/code&gt;.</source>
          <target state="translated">The number of &lt;code&gt;TIFFField&lt;/code&gt; s in this &lt;code&gt;TIFFDirectory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df8cbf65b57833acddb4ff0a78d9a0353df9a3f4" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;char&lt;/code&gt; values added to the buffer, or -1 if this source of characters is at its end</source>
          <target state="translated">버퍼에 추가 된 &lt;code&gt;char&lt;/code&gt; 값 수 또는이 문자 소스가 끝에있는 경우 -1</target>
        </trans-unit>
        <trans-unit id="6a4fe6c9ed8723108cce0e192446f1016bb5190a" translate="yes" xml:space="preserve">
          <source>The number of DataBuffer data elements per pixel.</source>
          <target state="translated">The number of DataBuffer data elements per pixel.</target>
        </trans-unit>
        <trans-unit id="a13aedd88da9ff953a45546a659c446cf0d4bcbb" translate="yes" xml:space="preserve">
          <source>The number of array elements when deserializing an array of the class.</source>
          <target state="translated">The number of array elements when deserializing an array of the class.</target>
        </trans-unit>
        <trans-unit id="a9e565d04a934465ec5fead6c1f84b201f781fa2" translate="yes" xml:space="preserve">
          <source>The number of attributes in the list.</source>
          <target state="translated">The number of attributes in the list.</target>
        </trans-unit>
        <trans-unit id="f3a97128719266ddb790af1c18af9062d75593ec" translate="yes" xml:space="preserve">
          <source>The number of attributes in this attribute set.</source>
          <target state="translated">이 속성 세트의 속성 수입니다.</target>
        </trans-unit>
        <trans-unit id="6ec090dddd82f048df0c06bf0d557ff56e2af995" translate="yes" xml:space="preserve">
          <source>The number of audio channels in this format (1 for mono, 2 for stereo).</source>
          <target state="translated">이 형식의 오디오 채널 수입니다 (모노의 경우 1, 스테레오의 경우 2).</target>
        </trans-unit>
        <trans-unit id="afbe542c12a90a28a0f4b4b26ed2890e7aa85abd" translate="yes" xml:space="preserve">
          <source>The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;#getFreeSpace()&quot;&gt;&lt;code&gt;getFreeSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;#getFreeSpace()&quot;&gt; &lt;code&gt;getFreeSpace()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ebe508295acf5978d83f70bb43c4b3bd8b4274fb" translate="yes" xml:space="preserve">
          <source>The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;file#getFreeSpace--&quot;&gt;&lt;code&gt;getFreeSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션에서 사용 가능한 바이트 수 또는 추상 경로 이름으로 파티션 이름을 지정하지 않은 경우 &lt;code&gt;0L&lt;/code&gt; 이 정보를 사용할 수없는 시스템에서이 메소드는 &lt;a href=&quot;file#getFreeSpace--&quot;&gt; &lt;code&gt;getFreeSpace()&lt;/code&gt; &lt;/a&gt; 호출에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="986d228b1cb124a7f2771a51d5eedb83ae9e201a" translate="yes" xml:space="preserve">
          <source>The number of bands in the Raster.</source>
          <target state="translated">The number of bands in the Raster.</target>
        </trans-unit>
        <trans-unit id="ebe7d42d7d56efc03967bcfad1c053de532602df" translate="yes" xml:space="preserve">
          <source>The number of bands in this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.</source>
          <target state="translated">The number of bands in this &lt;code&gt;ComponentSampleModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0a45d9f8790184259c173f5fdc53836106419a" translate="yes" xml:space="preserve">
          <source>The number of banks in this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.</source>
          <target state="translated">The number of banks in this &lt;code&gt;ComponentSampleModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d71dc51d09a652590c4253e71d8987c66a2cdde" translate="yes" xml:space="preserve">
          <source>The number of banks in this DataBuffer.</source>
          <target state="translated">The number of banks in this DataBuffer.</target>
        </trans-unit>
        <trans-unit id="1130b4382f1b7fe878fe4148c6bceffdb27b5491" translate="yes" xml:space="preserve">
          <source>The number of bits in each sample of a sound that has this format.</source>
          <target state="translated">이 형식을 가진 각 사운드 샘플의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2c6ef0f30695893dbdb9d64573a808a0335d172d" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;byte&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;byte&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="15e790ed5a0a48d5374c994c58d90003c84875ca" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;char&lt;/code&gt; value in unsigned binary form, constant &lt;code&gt;16&lt;/code&gt;.</source>
          <target state="translated">부호없는 이진 형식으로 상수 &lt;code&gt;16&lt;/code&gt; 을 &lt;code&gt;char&lt;/code&gt; 값 으로 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="262c8f5ae61f9348f39f6db260ec423eb0e0fc41" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="db7608f15c88ac6b6517884137b2698cc2061366" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;float&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e0bfa0a3ed9120efd3be680d6da69e3fb3b7ff5a" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;long&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;long&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="8b6311d22d425e5b3c17619c262b0fb241a15127" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;short&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;short&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="11b4eca6a42f5c3d86eeb7e9b58d5fd4c96c3c69" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;int&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b5aa872ec500b92f693ae617360824bca852a7c7" translate="yes" xml:space="preserve">
          <source>The number of buffers</source>
          <target state="translated">The number of buffers</target>
        </trans-unit>
        <trans-unit id="b595b8a977d69a8109f568a8e86df5418ffc6011" translate="yes" xml:space="preserve">
          <source>The number of bytes allocated to read data from this stream and return the result is bounded by &lt;code&gt;2*(long)len&lt;/code&gt;, inclusive.</source>
          <target state="translated">The number of bytes allocated to read data from this stream and return the result is bounded by &lt;code&gt;2*(long)len&lt;/code&gt; , inclusive.</target>
        </trans-unit>
        <trans-unit id="17d4e70f10cd5538ecaddea27e5925f3b39b1260" translate="yes" xml:space="preserve">
          <source>The number of bytes in each frame of a sound that has this format.</source>
          <target state="translated">이 형식을 가진 사운드의 각 프레임에있는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="10ce5b479dd18c652ab8267df15337a3c496022c" translate="yes" xml:space="preserve">
          <source>The number of bytes in the MIDI message, including the status byte and any data bytes.</source>
          <target state="translated">상태 바이트 및 데이터 바이트를 포함한 MIDI 메시지의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d13a4622dc0f210135891bcff08ace66977b3820" translate="yes" xml:space="preserve">
          <source>The number of bytes of primitive data available to be read in the current buffer.</source>
          <target state="translated">현재 버퍼에서 읽을 수있는 기본 데이터의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="cfdd8b77cfc1f1b2a6f5515e18f818690cf800f0" translate="yes" xml:space="preserve">
          <source>The number of bytes read, or -1 if the end of the stream has already been reached</source>
          <target state="translated">읽은 바이트 수 또는 스트림 끝에 이미 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="cbcb5512c2972dbeb5124314fe8397ab9324ba4c" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero</source>
          <target state="translated">읽은 바이트 수, 아마도 0</target>
        </trans-unit>
        <trans-unit id="e54fa04ce29f88473805b5e56fe5895a6e99f815" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero, or &lt;code&gt;-1&lt;/code&gt; if the channel has reached end-of-stream</source>
          <target state="translated">읽은 바이트 수 (0 일 수 있음) 또는 채널이 스트림 끝에 도달 한 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2adccbd80eaab01d04b629a86d5b76357c7316e9" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero, or &lt;code&gt;-1&lt;/code&gt; if the given position is greater than or equal to the file's current size</source>
          <target state="translated">읽은 바이트 수 (0 또는 가능)- 주어진 위치가 파일의 현재 크기보다 크거나 같은 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57a7079e650bee5a8a354dd28ed5d308b1f47e06" translate="yes" xml:space="preserve">
          <source>The number of bytes sent, which will be either the number of bytes that were remaining in the source buffer when this method was invoked or, if this channel is non-blocking, may be zero if there was insufficient room for the datagram in the underlying output buffer</source>
          <target state="translated">전송 된 바이트 수.이 메소드가 호출 될 때 소스 버퍼에 남아있는 바이트 수이거나,이 채널이 비 블로킹 인 경우, 기본에 데이터 그램에 대한 공간이 충분하지 않으면 0이 될 수 있습니다. 출력 버퍼</target>
        </trans-unit>
        <trans-unit id="2255a94d1e2a76f353fed8a1d7b8e435de23cbd1" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be read without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be read without blocking, there is no guarantee that attempts to read additional data will block.)</source>
          <target state="translated">The number of bytes that can be read without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be read without blocking, there is no guarantee that attempts to read additional data will block.)</target>
        </trans-unit>
        <trans-unit id="9e97ccf1d843b3b3580662091dfd95f1358e8031" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be read without blocking can be ascertained using the &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be read without blocking, there is no guarantee that attempts to read additional data will block.)</source>
          <target state="translated">차단없이 읽을 수있는 바이트 수 는 &lt;code&gt;DataLine&lt;/code&gt; 인터페이스 의 &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드를 사용하여 확인할 수 있습니다 . (이 바이트 수를 차단하지 않고 읽을 수는 있지만 추가 데이터를 읽으려고하면 차단 될 것이라는 보장은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="fd338086f6f6b37beee7c38de457fa661d7d1f92" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.)</source>
          <target state="translated">The number of bytes that can be written without blocking can be ascertained using the &lt;a href=&quot;dataline#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.)</target>
        </trans-unit>
        <trans-unit id="f0013bec32edf3c0c9dad2765e90a066acc9e7ad" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written without blocking can be ascertained using the &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.)</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;DataLine&lt;/code&gt; 인터페이스 메소드를 사용하여 차단하지 않고 쓸 수있는 바이트 수를 확인할 수 있습니다 . (이 바이트 수를 차단하지 않고 기록 할 수 있지만 추가 데이터 쓰기 시도가 차단된다는 보장은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="80f6fef15a305bb856be09b4ef7409dc0dfb2fc8" translate="yes" xml:space="preserve">
          <source>The number of bytes to be read must represent an integral number of sample frames, such that:</source>
          <target state="translated">읽을 바이트 수는 다음과 같이 정수의 샘플 프레임 수를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="4523152343dab6798c93c7c3562ed8220c409f7a" translate="yes" xml:space="preserve">
          <source>The number of bytes to write must represent an integral number of sample frames, such that:</source>
          <target state="translated">쓸 바이트 수는 다음과 같이 정수의 샘플 프레임 수를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="a610a04d9530184116d0938a5b3f9e488bba7801" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;byte&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">바이트를 나타내는 데 사용 된 &lt;code&gt;byte&lt;/code&gt; 2의 보수 이진 형태 값 .</target>
        </trans-unit>
        <trans-unit id="1796e9529f51151f2a6f5b7fcdc6d4bd70c786af" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;char&lt;/code&gt; value in unsigned binary form.</source>
          <target state="translated">부호없는 이진 형식으로 &lt;code&gt;char&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="3d71b8f32cede9bbb676411377aebced3b7d4c67" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="229d3c03b3ae3c1ed8f12a7910a48a2be5adc533" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;float&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="aa4672a7d102168489149e5d5e7d36728647ebc6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;int&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="dcc8fa85fe3017a1bc6d96fbdb414b709a9b995c" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;long&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형식 으로 &lt;code&gt;long&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="d331db734169c052769944e176d28ab646bccf3a" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;short&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;short&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="fbddc6e94c7277988d661bc338017f0ceb95e132" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">The number of bytes used to represent an &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</target>
        </trans-unit>
        <trans-unit id="49cea9bc18d6128266132564ff26cd7bbad3f15a" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the data output stream so far.</source>
          <target state="translated">The number of bytes written to the data output stream so far.</target>
        </trans-unit>
        <trans-unit id="ccba44d3bc4162d753710c71c12cf8138d21d82d" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the data output stream so far. If this counter overflows, it will be wrapped to Integer.MAX_VALUE.</source>
          <target state="translated">지금까지 데이터 출력 스트림에 쓴 바이트 수입니다. 이 카운터가 오버플로되면 Integer.MAX_VALUE로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f42b4506dd9b1a24e0be2228b3cc5e5f34c15a" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the output byte array</source>
          <target state="translated">출력 바이트 배열에 쓴 바이트 수</target>
        </trans-unit>
        <trans-unit id="6624a626639ad8ac1c8cb97de741a539df918fa9" translate="yes" xml:space="preserve">
          <source>The number of bytes written, possibly zero</source>
          <target state="translated">쓴 바이트 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="2e83b9c69c8e5617a17c757bc7b8be745b27a54c" translate="yes" xml:space="preserve">
          <source>The number of bytes, possibly zero, that were actually transferred</source>
          <target state="translated">실제로 전송 된 바이트 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="af7ab7cd4f3072661b7c20abd685bf0c436d55bc" translate="yes" xml:space="preserve">
          <source>The number of capturing groups in this matcher's pattern</source>
          <target state="translated">이 매처의 패턴에있는 캡처 그룹 수</target>
        </trans-unit>
        <trans-unit id="2f329af4f477cd85e689456398c923d81cd9c8c1" translate="yes" xml:space="preserve">
          <source>The number of channels (1 for mono, 2 for stereo, etc.), or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;</source>
          <target state="translated">채널 수 (모노의 경우 1, 스테레오의 경우 2 등) 또는 &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="032b81eac6a8ead6bf3bea51101baeb3b3e0d8f0" translate="yes" xml:space="preserve">
          <source>The number of characters actually skipped</source>
          <target state="translated">실제로 건너 뛴 문자 수</target>
        </trans-unit>
        <trans-unit id="386f609288a9f0b220b6ac9838664b0f43846b2d" translate="yes" xml:space="preserve">
          <source>The number of characters added to the buffer, or -1 if this source of characters is at its end</source>
          <target state="translated">버퍼에 추가 된 문자 수 또는이 문자 소스가 끝에있는 경우 -1</target>
        </trans-unit>
        <trans-unit id="ecf5ab475eeef8fcb49643a9532fa7b4dc7af88a" translate="yes" xml:space="preserve">
          <source>The number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">읽은 문자 수 또는 스트림 끝에 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="205c7f1702ff1d1066de34202d523525add5dd9e" translate="yes" xml:space="preserve">
          <source>The number of chars in the buffer.</source>
          <target state="translated">버퍼의 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="6cce150dda936838801add841ddd847a738448a1" translate="yes" xml:space="preserve">
          <source>The number of color components in the profile's input color space.</source>
          <target state="translated">The number of color components in the profile's input color space.</target>
        </trans-unit>
        <trans-unit id="b27fe1795e395f12dea2f5b4c6f95e4dd635c4f5" translate="yes" xml:space="preserve">
          <source>The number of components in this &lt;code&gt;ColorSpace&lt;/code&gt;.</source>
          <target state="translated">The number of components in this &lt;code&gt;ColorSpace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5459d16fb3b7c8ed8621399fa51604616eecd04" translate="yes" xml:space="preserve">
          <source>The number of data items present in the field.</source>
          <target state="translated">The number of data items present in the field.</target>
        </trans-unit>
        <trans-unit id="929430c1d8c5ac6d7a42cbccdfc2c26fcd50c43a" translate="yes" xml:space="preserve">
          <source>The number of days considered to define the first week of a month or year varies by culture. For example, the ISO-8601 requires 4 days (more than half a week) to be present before counting the first week.</source>
          <target state="translated">월 또는 연도의 첫 주를 정의하는 것으로 간주되는 일 수는 문화에 따라 다릅니다. 예를 들어, ISO-8601은 첫 주를 계산하기 전에 4 일 (1 주일 이상)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="82d024cc379193ffdf9a30ee6d903c40b1cdc418" translate="yes" xml:space="preserve">
          <source>The number of days is multiplied by 86400 to obtain the number of seconds to add. This is based on the standard definition of a day as 24 hours.</source>
          <target state="translated">추가 할 초 수를 얻기 위해 일 수에 86400을 곱합니다. 이는 하루 24 시간의 표준 정의를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="080fc6c7c7c958c7b7e37d0533887be92a47406d" translate="yes" xml:space="preserve">
          <source>The number of days is multiplied by 86400 to obtain the number of seconds to subtract. This is based on the standard definition of a day as 24 hours.</source>
          <target state="translated">빼는 초 수를 얻기 위해 일 수에 86400을 곱합니다. 이는 하루 24 시간의 표준 정의를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="4c5a8510ea5cd109d91d0cd1e886868f35891a33" translate="yes" xml:space="preserve">
          <source>The number of digit characters after the exponent character gives the minimum exponent digit count. There is no maximum. Negative exponents are formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix from the pattern. This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.</source>
          <target state="translated">지수 문자 뒤의 숫자는 최소 지수 숫자를 나타냅니다. 최대 값이 없습니다. 음수 지수는 패턴의 접두사와 접미사가 &lt;em&gt;아닌&lt;/em&gt; 지역화 된 빼기 부호를 사용하여 형식이 지정됩니다 . 이것은 &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt; 와 같은 패턴을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="4b53b240407fd962e2dd3b27a91febfe24bbf171" translate="yes" xml:space="preserve">
          <source>The number of digits in the result for the fractional part of</source>
          <target state="translated">소수 부분에 대한 결과의 자릿수</target>
        </trans-unit>
        <trans-unit id="05d292761fd82f9f0dd80c9070f0ac52df331589" translate="yes" xml:space="preserve">
          <source>The number of dimensions of the new array must not exceed 255.</source>
          <target state="translated">새 배열의 차원 수는 255를 초과하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d6cd0b74c19721cb1208c561a00d8161cb59f302" translate="yes" xml:space="preserve">
          <source>The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a45d0d315d987c393e3a2c515c64048ccf875d3" translate="yes" xml:space="preserve">
          <source>The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. Field numbers range from &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 이 인식하는 고유 필드 수입니다 . 필드 번호 범위는 &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0dfd1950909619c9868b487a9d57d847c0cc29b" translate="yes" xml:space="preserve">
          <source>The number of elements covered by the stream source is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt;, does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is 4 and there is no need to execute the pipeline and, as a side-effect, print out the elements.</source>
          <target state="translated">The number of elements covered by the stream source is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt; , does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is 4 and there is no need to execute the pipeline and, as a side-effect, print out the elements.</target>
        </trans-unit>
        <trans-unit id="789ce93185a0e2beb4cc5bbc9f0b5bac9d5ce9c3" translate="yes" xml:space="preserve">
          <source>The number of elements covered by the stream source, a &lt;code&gt;List&lt;/code&gt;, is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt;, does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is the size of the &lt;code&gt;List&lt;/code&gt; and there is no need to execute the pipeline and, as a side-effect, print out the list elements.</source>
          <target state="translated">The number of elements covered by the stream source, a &lt;code&gt;List&lt;/code&gt; , is known and the intermediate operation, &lt;code&gt;peek&lt;/code&gt; , does not inject into or remove elements from the stream (as may be the case for &lt;code&gt;flatMap&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; operations). Thus the count is the size of the &lt;code&gt;List&lt;/code&gt; and there is no need to execute the pipeline and, as a side-effect, print out the list elements.</target>
        </trans-unit>
        <trans-unit id="9860eaa69c7abfda9de7a6d02811a1e3a1871e66" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;constants&lt;/code&gt; equals to number of \2 tags in &lt;code&gt;recipe&lt;/code&gt;</source>
          <target state="translated">The number of elements in &lt;code&gt;constants&lt;/code&gt; equals to number of \2 tags in &lt;code&gt;recipe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acd4fd691fac05bdf2d5e37af4276341169d50a8" translate="yes" xml:space="preserve">
          <source>The number of elements remaining in this buffer</source>
          <target state="translated">이 버퍼에 남아있는 요소의 수</target>
        </trans-unit>
        <trans-unit id="b2e83b34b6fc477f1ef053898329bc6fcb7133b3" translate="yes" xml:space="preserve">
          <source>The number of entries in the search result, or zero if unknown.</source>
          <target state="translated">검색 결과의 항목 수이거나 알 수없는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="a84c6c62b5a42df25220cabbfa4124476735b0f2" translate="yes" xml:space="preserve">
          <source>The number of formal parameters for the executable this object represents</source>
          <target state="translated">이 객체가 나타내는 실행 파일의 형식 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="dfefc77d44f13f44ad950d4ebe9a5e1dcbcc6e1d" translate="yes" xml:space="preserve">
          <source>The number of frames played or recorded per second, for sounds that have this format.</source>
          <target state="translated">이 형식의 사운드에 대해 초당 재생 또는 녹음 된 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="4edbcfc8aa45cc498cde3e783850921f5632be3c" translate="yes" xml:space="preserve">
          <source>The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.</source>
          <target state="translated">빼는 초 수를 얻기 위해 시간 수에 3600을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="307478f090dcd23f5ff03bb51efd07fb84315e34" translate="yes" xml:space="preserve">
          <source>The number of hours is multiplied by 60 to obtain the number of seconds to subtract.</source>
          <target state="translated">빼는 초 수를 얻기 위해 시간 수에 60을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="78247313d86cd76765e1c133a2b09bbb32f29107" translate="yes" xml:space="preserve">
          <source>The number of instances of a serializable &lt;code&gt;BeanContextServceProvider&lt;/code&gt;.</source>
          <target state="translated">직렬화 가능한 &lt;code&gt;BeanContextServceProvider&lt;/code&gt; 의 인스턴스 수입니다 .</target>
        </trans-unit>
        <trans-unit id="317369d1e0be16bc5ba4718d3219b54f3b09d26c" translate="yes" xml:space="preserve">
          <source>The number of items in the result</source>
          <target state="translated">The number of items in the result</target>
        </trans-unit>
        <trans-unit id="097f0a8d71914cb9c6dea77c3a145d38daa1e596" translate="yes" xml:space="preserve">
          <source>The number of iterations is determined by the &lt;code&gt;iterations&lt;/code&gt; handle evaluation result. The loop counter &lt;code&gt;i&lt;/code&gt; is an extra loop iteration variable of type &lt;code&gt;int&lt;/code&gt;. It will be initialized to 0 and incremented by 1 in each iteration.</source>
          <target state="translated">The number of iterations is determined by the &lt;code&gt;iterations&lt;/code&gt; handle evaluation result. The loop counter &lt;code&gt;i&lt;/code&gt; is an extra loop iteration variable of type &lt;code&gt;int&lt;/code&gt; . It will be initialized to 0 and incremented by 1 in each iteration.</target>
        </trans-unit>
        <trans-unit id="3e1adaf0033f7bba7e092443336bc7fbe43cefde" translate="yes" xml:space="preserve">
          <source>The number of keys, possibly zero, whose ready-operation sets were updated</source>
          <target state="translated">준비 작업 세트가 업데이트 된 키 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="4418abf384fb3ff1dd1752bbc4761bc8afef107c" translate="yes" xml:space="preserve">
          <source>The number of keys, possibly zero, whose ready-operation sets were updated by the selection operation</source>
          <target state="translated">준비 작업 세트가 선택 작업으로 업데이트 된 키 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="58599d8f7a9756bbcaa8cb541eec393ad429d292" translate="yes" xml:space="preserve">
          <source>The number of nodes in the list.</source>
          <target state="translated">The number of nodes in the list.</target>
        </trans-unit>
        <trans-unit id="10c3a3ca6ddaa4e8f11f7782659de88cb00a5425" translate="yes" xml:space="preserve">
          <source>The number of nodes in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">목록의 노드 수 유효한 자식 노드 인덱스의 범위는 0에서 &lt;code&gt;length-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="c7ccd76fa8856f04dcd4795c012af0ade0677dc3" translate="yes" xml:space="preserve">
          <source>The number of nodes in this map.</source>
          <target state="translated">The number of nodes in this map.</target>
        </trans-unit>
        <trans-unit id="99714a0533e48c069f5d0251fb069318d7bc8ed0" translate="yes" xml:space="preserve">
          <source>The number of nodes in this map. The range of valid child node indices is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of nodes in this map. The range of valid child node indices is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="2ae7dea8f5d3421534529bc5cc4c84ee7b852657" translate="yes" xml:space="preserve">
          <source>The number of pairs (name and namespaceURI) in the list.</source>
          <target state="translated">The number of pairs (name and namespaceURI) in the list.</target>
        </trans-unit>
        <trans-unit id="c3847744dd637bbb831cfd22ebd7a7b7aa4dd88e" translate="yes" xml:space="preserve">
          <source>The number of pairs (name and namespaceURI) in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">The number of pairs (name and namespaceURI) in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</target>
        </trans-unit>
        <trans-unit id="555261104557ed52a03a89935ea1fbf0b6fdc34b" translate="yes" xml:space="preserve">
          <source>The number of parameter slots in &lt;code&gt;concatType&lt;/code&gt; is less than or equal to 200</source>
          <target state="translated">The number of parameter slots in &lt;code&gt;concatType&lt;/code&gt; is less than or equal to 200</target>
        </trans-unit>
        <trans-unit id="d0b15529b633a23cd3e86f0403d34390bbda7486" translate="yes" xml:space="preserve">
          <source>The number of parameters (parameter_count) is wrong for the method</source>
          <target state="translated">메소드의 매개 변수 수 (parameter_count)가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="305a1cc134b6c645204fd4641631706c7a3bf073" translate="yes" xml:space="preserve">
          <source>The number of pixels and scanlines to be used are calculated as follows.</source>
          <target state="translated">사용되는 픽셀 수와 스캔 라인은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b09023fb617952757d1c12c7474a0c419e6159" translate="yes" xml:space="preserve">
          <source>The number of samples played or recorded per second, for sounds that have this format.</source>
          <target state="translated">이 형식의 사운드에 대해 초당 재생 또는 녹음 된 샘플 수입니다.</target>
        </trans-unit>
        <trans-unit id="9bbc1ff0553b0381a0869f137c83f31dcb608500" translate="yes" xml:space="preserve">
          <source>The number of scanlines to be used can be computed similarly.</source>
          <target state="translated">사용될 스캔 라인의 수는 유사하게 계산 될 수있다.</target>
        </trans-unit>
        <trans-unit id="afe45a69b86f3105c28dbba507ef13df1b6571f1" translate="yes" xml:space="preserve">
          <source>The number of seconds is calculated using the era, year-of-era, month, day-of-month, hour, minute, second, and zoneOffset.</source>
          <target state="translated">The number of seconds is calculated using the era, year-of-era, month, day-of-month, hour, minute, second, and zoneOffset.</target>
        </trans-unit>
        <trans-unit id="2e29a6191dda7aba6c2290709789914d31fdc135" translate="yes" xml:space="preserve">
          <source>The number of seconds is calculated using the proleptic-year, month, day-of-month, hour, minute, second, and zoneOffset.</source>
          <target state="translated">The number of seconds is calculated using the proleptic-year, month, day-of-month, hour, minute, second, and zoneOffset.</target>
        </trans-unit>
        <trans-unit id="27d50337df7b10c0b2a7bea6efd93de22a290207" translate="yes" xml:space="preserve">
          <source>The number of seconds is calculated using the year, month, day-of-month, hour, minute, second, and zoneOffset.</source>
          <target state="translated">The number of seconds is calculated using the year, month, day-of-month, hour, minute, second, and zoneOffset.</target>
        </trans-unit>
        <trans-unit id="7ba563126126250d6b36a8f34204fd2b8961d6b5" translate="yes" xml:space="preserve">
          <source>The number of sequence elements isn't necessarily bounded.</source>
          <target state="translated">The number of sequence elements isn't necessarily bounded.</target>
        </trans-unit>
        <trans-unit id="be3893e01cc76c096f13435ff5df0b674f3d85d4" translate="yes" xml:space="preserve">
          <source>The number of sessions that can be stored in context can be limited.</source>
          <target state="translated">컨텍스트에 저장할 수있는 세션 수는 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc312459807625f373e756dee442f9bfa948a13e" translate="yes" xml:space="preserve">
          <source>The number of significant digits in the mantissa is the sum of the &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is unaffected by the maximum integer digits. For example, 12345 formatted with &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set the significant digits count to zero. The number of significant digits does not affect parsing.</source>
          <target state="translated">가수의 유효 자릿수는 &lt;em&gt;최소 정수&lt;/em&gt; 와 &lt;em&gt;최대 소수&lt;/em&gt; 자릿수 의 합이며 최대 정수 자릿수의 영향을받지 않습니다. 예를 들어 &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; 으로 형식이 지정된 12345 는 &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt; 입니다. 입니다. 모든 자릿수를 표시하려면 유효 자릿수를 0으로 설정하십시오. 유효 자릿수는 구문 분석에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d91005939f84137a8df80f671cacf84df36e6b8" translate="yes" xml:space="preserve">
          <source>The number of subsampled pixels in a scanline is given by</source>
          <target state="translated">스캔 라인에서 서브 샘플링 된 픽셀 수는</target>
        </trans-unit>
        <trans-unit id="dcd109508ee8f3a6f378ef74aa92b469fe67d4fc" translate="yes" xml:space="preserve">
          <source>The number of system colors in the array.</source>
          <target state="translated">The number of system colors in the array.</target>
        </trans-unit>
        <trans-unit id="ff212c63b39ca97d00e31f372ba96ac08c1c2239" translate="yes" xml:space="preserve">
          <source>The number of timer notifications.</source>
          <target state="translated">타이머 알림 수입니다.</target>
        </trans-unit>
        <trans-unit id="a99c933e31e58e2b2effa06d1ecd99e60ab9562d" translate="yes" xml:space="preserve">
          <source>The number of times that the memory usage has crossed a threshold when the notification was constructed. For usage threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount()&quot;&gt;&lt;code&gt;usage threshold
       count&lt;/code&gt;&lt;/a&gt;. For collection threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount()&quot;&gt;&lt;code&gt;collection usage threshold count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The number of times that the memory usage has crossed a threshold when the notification was constructed. For usage threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount()&quot;&gt; &lt;code&gt;usage threshold count&lt;/code&gt; &lt;/a&gt;. For collection threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount()&quot;&gt; &lt;code&gt;collection usage threshold count&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="19bd983290a225549adc50288431558c89bf12d7" translate="yes" xml:space="preserve">
          <source>The number of times that the memory usage has crossed a threshold when the notification was constructed. For usage threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;usage threshold
       count&lt;/code&gt;&lt;/a&gt;. For collection threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount--&quot;&gt;&lt;code&gt;collection usage threshold count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">알림이 생성 될 때 메모리 사용량이 임계 값을 초과 한 횟수입니다. 사용 임계 값 알림의 경우이 수는 &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;usage threshold count&lt;/code&gt; &lt;/a&gt; 입니다. 수집 임계 값 알림의 경우이 수는 &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount--&quot;&gt; &lt;code&gt;collection usage threshold count&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d5233e312eca4b40bdcfff8caabd2847f926280" translate="yes" xml:space="preserve">
          <source>The number of times that the thread has blocked for synchronization or waited for notification.</source>
          <target state="translated">스레드가 동기화를 차단하거나 알림을 기다린 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="3736904d09a27872b02330b53922aff48808ffef" translate="yes" xml:space="preserve">
          <source>The number of times this list has been</source>
          <target state="translated">이 목록의 횟수</target>
        </trans-unit>
        <trans-unit id="357ec448a341d2b228db1dbd27bc9cf72c53aabb" translate="yes" xml:space="preserve">
          <source>The number of type arguments must either equal the number of the type element's formal type parameters, or must be zero. If zero, and if the type element is generic, then the type element's raw type is returned.</source>
          <target state="translated">형식 인수의 수는 형식 요소의 형식 형식 매개 변수의 수와 같거나 0이어야합니다. 0이고 유형 요소가 일반이면 유형 요소의 원시 유형이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="668af3c185c4b261a4b5f605aa7eb30233f7fa80" translate="yes" xml:space="preserve">
          <source>The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;#getTotalSpace()&quot;&gt;&lt;code&gt;getTotalSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;#getTotalSpace()&quot;&gt; &lt;code&gt;getTotalSpace()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bb5dcdeeed728c559a3fe4b12406c534b1b7846c" translate="yes" xml:space="preserve">
          <source>The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;file#getTotalSpace--&quot;&gt;&lt;code&gt;getTotalSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션에서 할당되지 않은 바이트 수 또는 추상 경로 이름으로 파티션 이름을 지정하지 않은 경우 &lt;code&gt;0L&lt;/code&gt; 이 값은 다음으로 반환되는 총 파일 시스템 크기보다 작거나 같습니다.&lt;a href=&quot;file#getTotalSpace--&quot;&gt; &lt;code&gt;getTotalSpace()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="43d617bb62a7a18964f7ca8a27418ffb89cf70e0" translate="yes" xml:space="preserve">
          <source>The number of unique keys consumed, possibly zero</source>
          <target state="translated">The number of unique keys consumed, possibly zero</target>
        </trans-unit>
        <trans-unit id="87c541a3e7a17d1566331ea8f74b8b01cec37942" translate="yes" xml:space="preserve">
          <source>The number of valid bytes in the buffer.</source>
          <target state="translated">버퍼에서 유효한 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="24896816bf723dc5a3b4b2e1bd2ca0f9074de51b" translate="yes" xml:space="preserve">
          <source>The number of valid bytes in the buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;buf.length&lt;/code&gt;; elements &lt;code&gt;buf[0]&lt;/code&gt; through &lt;code&gt;buf[count-1]&lt;/code&gt; contain valid byte data.</source>
          <target state="translated">버퍼에서 유효한 바이트 수입니다. 이 값의 범위는 항상 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;buf.length&lt;/code&gt; 입니다 . 요소 &lt;code&gt;buf[0]&lt;/code&gt; 통해 &lt;code&gt;buf[count-1]&lt;/code&gt; 유효 바이트 데이터를 포함한다.</target>
        </trans-unit>
        <trans-unit id="2e96ff8f9eedefb579c2382e0dc82d928321f101" translate="yes" xml:space="preserve">
          <source>The number of valid characters in the input stream buffer.</source>
          <target state="translated">입력 스트림 버퍼의 유효한 문자 수</target>
        </trans-unit>
        <trans-unit id="e57f66c301a924e445314f3299d3af941360076b" translate="yes" xml:space="preserve">
          <source>The number of valid components in the vector of observed objects.</source>
          <target state="translated">관찰 된 객체의 벡터에서 유효한 구성 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="d8ec9845a21a8802586d218cdb961c9632ff679e" translate="yes" xml:space="preserve">
          <source>The number of valid components in this &lt;code&gt;Vector&lt;/code&gt; object.</source>
          <target state="translated">The number of valid components in this &lt;code&gt;Vector&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="f6b3f8e949ab3c4c73047ca1f7e1396e53ad0edf" translate="yes" xml:space="preserve">
          <source>The number of valid components in this &lt;code&gt;Vector&lt;/code&gt; object. Components &lt;code&gt;elementData[0]&lt;/code&gt; through &lt;code&gt;elementData[elementCount-1]&lt;/code&gt; are the actual items.</source>
          <target state="translated">이 &lt;code&gt;Vector&lt;/code&gt; 객체 의 유효한 구성 요소 수입니다 . 부품 &lt;code&gt;elementData[0]&lt;/code&gt; 내지 &lt;code&gt;elementData[elementCount-1]&lt;/code&gt; 의 실제 항목이다.</target>
        </trans-unit>
        <trans-unit id="d36405cf1838f4623a0028cc40d5619b16565f33" translate="yes" xml:space="preserve">
          <source>The number of values between the major tick marks -- the larger marks that break up the minor tick marks.</source>
          <target state="translated">The number of values between the major tick marks -- the larger marks that break up the minor tick marks.</target>
        </trans-unit>
        <trans-unit id="6f14995f2deadbb2d0a053c0fbe4ed6a82bd8ff5" translate="yes" xml:space="preserve">
          <source>The number of values between the minor tick marks -- the smaller marks that occur between the major tick marks.</source>
          <target state="translated">The number of values between the minor tick marks -- the smaller marks that occur between the major tick marks.</target>
        </trans-unit>
        <trans-unit id="bc51c3cdfd5086e82cbbf9f7edebb6104b8eb202" translate="yes" xml:space="preserve">
          <source>The number, types and properties of a &lt;code&gt;ResultSet&lt;/code&gt; object's columns are provided by the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object returned by the &lt;code&gt;ResultSet.getMetaData&lt;/code&gt; method.</source>
          <target state="translated">The number, types and properties of a &lt;code&gt;ResultSet&lt;/code&gt; object's columns are provided by the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object returned by the &lt;code&gt;ResultSet.getMetaData&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="f57f709838bfc1167d3aa24e20f38dfd74e18c34" translate="yes" xml:space="preserve">
          <source>The numerically largest constant representing a TIFF data type.</source>
          <target state="translated">The numerically largest constant representing a TIFF data type.</target>
        </trans-unit>
        <trans-unit id="7b270a943d9f7ce2a2bc2099cd7e009b0695ba7c" translate="yes" xml:space="preserve">
          <source>The numerically smallest constant representing a TIFF data type.</source>
          <target state="translated">The numerically smallest constant representing a TIFF data type.</target>
        </trans-unit>
        <trans-unit id="9bc6965ff85bb150de99e69a5605bbc312ce5005" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;crs&lt;/code&gt; now contains the data from the table &lt;code&gt;EMPLOYEES&lt;/code&gt;, just as the object &lt;code&gt;rs&lt;/code&gt; does. The difference is that the cursor for &lt;code&gt;crs&lt;/code&gt; can be moved forward, backward, or to a particular row even if the cursor for &lt;code&gt;rs&lt;/code&gt; can move only forward. In addition, &lt;code&gt;crs&lt;/code&gt; is updatable even if &lt;code&gt;rs&lt;/code&gt; is not because by default, a &lt;code&gt;CachedRowSet&lt;/code&gt; object is both scrollable and updatable.</source>
          <target state="translated">The object &lt;code&gt;crs&lt;/code&gt; now contains the data from the table &lt;code&gt;EMPLOYEES&lt;/code&gt; , just as the object &lt;code&gt;rs&lt;/code&gt; does. The difference is that the cursor for &lt;code&gt;crs&lt;/code&gt; can be moved forward, backward, or to a particular row even if the cursor for &lt;code&gt;rs&lt;/code&gt; can move only forward. In addition, &lt;code&gt;crs&lt;/code&gt; is updatable even if &lt;code&gt;rs&lt;/code&gt; is not because by default, a &lt;code&gt;CachedRowSet&lt;/code&gt; object is both scrollable and updatable.</target>
        </trans-unit>
        <trans-unit id="8e1ec64095853fe197aa6cf41100bd72f0b70a53" translate="yes" xml:space="preserve">
          <source>The object acts as a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt;&lt;code&gt;Flow.Subscriber&lt;/code&gt;&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;&amp;gt;&amp;gt; to the HTTP Client implementation, which publishes lists of ByteBuffers containing the response body. The Flow of data, as well as the order of ByteBuffers in the Flow lists, is a strictly ordered representation of the response body. Both the Lists and the ByteBuffers, once passed to the subscriber, are no longer used by the HTTP Client. The subscriber converts the incoming buffers of data to some higher-level Java type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">The object acts as a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt; &lt;code&gt;Flow.Subscriber&lt;/code&gt; &lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;&amp;lt;&lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; &lt;/a&gt;&amp;gt;&amp;gt; to the HTTP Client implementation, which publishes lists of ByteBuffers containing the response body. The Flow of data, as well as the order of ByteBuffers in the Flow lists, is a strictly ordered representation of the response body. Both the Lists and the ByteBuffers, once passed to the subscriber, are no longer used by the HTTP Client. The subscriber converts the incoming buffers of data to some higher-level Java type &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee52cc4a979dfa290de71fa0d59778b99e3b2595" translate="yes" xml:space="preserve">
          <source>The object at the top of this stack (the last item of the &lt;code&gt;Vector&lt;/code&gt; object).</source>
          <target state="translated">이 스택의 맨 위에있는 객체입니다 ( &lt;code&gt;Vector&lt;/code&gt; 객체 의 마지막 항목 ).</target>
        </trans-unit>
        <trans-unit id="94b3742377d13942b81c18e1127b983561a8c3d5" translate="yes" xml:space="preserve">
          <source>The object being edited</source>
          <target state="translated">The object being edited</target>
        </trans-unit>
        <trans-unit id="e3463f0dce6f74d0351102935f5ca5c5e97f8ec9" translate="yes" xml:space="preserve">
          <source>The object being observed.</source>
          <target state="translated">관찰되는 물체.</target>
        </trans-unit>
        <trans-unit id="549576c93743bbc010ab0c4c1c93ac04bc78070c" translate="yes" xml:space="preserve">
          <source>The object bound; null if this binding does not contain an object.</source>
          <target state="translated">개체가 바인딩되었습니다. 이 바인딩에 객체가없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="449d3598041a294afe3399942437e9f97f025dcf" translate="yes" xml:space="preserve">
          <source>The object contains some &lt;code&gt;Accessible&lt;/code&gt; information, but its role is not known.</source>
          <target state="translated">The object contains some &lt;code&gt;Accessible&lt;/code&gt; information, but its role is not known.</target>
        </trans-unit>
        <trans-unit id="ab8401c61b78ecc0ded2083081b9915784d7e095" translate="yes" xml:space="preserve">
          <source>The object created; null if an object cannot be created.</source>
          <target state="translated">생성 된 객체; 객체를 작성할 수없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="25101b399f33f9945d69632115c3f921d4a373f9" translate="yes" xml:space="preserve">
          <source>The object currently attached to this key, or &lt;code&gt;null&lt;/code&gt; if there is no attachment</source>
          <target state="translated">현재이 키에 연결된 객체 또는 &lt;code&gt;null&lt;/code&gt; 첨부가없는 경우는</target>
        </trans-unit>
        <trans-unit id="83e78860e5f6b1711764595fee4d0cebd5f6dd80" translate="yes" xml:space="preserve">
          <source>The object factories tried must implement either &lt;code&gt;ObjectFactory&lt;/code&gt; or &lt;code&gt;DirObjectFactory&lt;/code&gt;. If it implements &lt;code&gt;DirObjectFactory&lt;/code&gt;, &lt;code&gt;DirObjectFactory.getObjectInstance()&lt;/code&gt; is used, otherwise, &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; is used.</source>
          <target state="translated">시도한 객체 팩토리는 &lt;code&gt;ObjectFactory&lt;/code&gt; 또는 &lt;code&gt;DirObjectFactory&lt;/code&gt; 를 구현해야합니다 . 그것을 구현하는 경우 &lt;code&gt;DirObjectFactory&lt;/code&gt; 를 , &lt;code&gt;DirObjectFactory.getObjectInstance()&lt;/code&gt; 사용하고, 그렇지 않으면 &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="ab1ce82fc4930728131e5f5b4937333efd1a4cdb" translate="yes" xml:space="preserve">
          <source>The object identifier string, &quot;1.3.6.1.4.1.1466.20037&quot;.</source>
          <target state="translated">개체 식별자 문자열 &quot;1.3.6.1.4.1.1466.20037&quot;</target>
        </trans-unit>
        <trans-unit id="d1a4549046096f69268afef4b505824d9f29c7f1" translate="yes" xml:space="preserve">
          <source>The object implementing the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface returns from its &lt;code&gt;getProduct&lt;/code&gt; method an object implementing the &lt;code&gt;ProductMXBean&lt;/code&gt; interface. The &lt;code&gt;ModuleMXBean&lt;/code&gt; object and the returned &lt;code&gt;
      ProductMXBean&lt;/code&gt; objects must both be registered as MXBeans in the same MBean Server.</source>
          <target state="translated">The object implementing the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface returns from its &lt;code&gt;getProduct&lt;/code&gt; method an object implementing the &lt;code&gt;ProductMXBean&lt;/code&gt; interface. The &lt;code&gt;ModuleMXBean&lt;/code&gt; object and the returned &lt;code&gt; ProductMXBean&lt;/code&gt; objects must both be registered as MXBeans in the same MBean Server.</target>
        </trans-unit>
        <trans-unit id="d478c804036047e663cb169378cb0113711a662b" translate="yes" xml:space="preserve">
          <source>The object implementing the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface returns from its &lt;code&gt;getProduct&lt;/code&gt; method an object implementing the &lt;code&gt;ProductMXBean&lt;/code&gt; interface. The &lt;code&gt;ModuleMXBean&lt;/code&gt; object and the returned &lt;code&gt;ProductMXBean&lt;/code&gt; objects must both be registered as MXBeans in the same MBean Server.</source>
          <target state="translated">구현하는 객체 &lt;code&gt;ModuleMXBean&lt;/code&gt; 의에서 인터페이스를 반환 &lt;code&gt;getProduct&lt;/code&gt; 의 메소드 구현하는 객체 &lt;code&gt;ProductMXBean&lt;/code&gt; 인터페이스를. &lt;code&gt;ModuleMXBean&lt;/code&gt; 의 객체와 반환되는 &lt;code&gt;ProductMXBean&lt;/code&gt; 은 반드시 모두 동일한의 MBean 서버에 MXBean에로 등록 객체.</target>
        </trans-unit>
        <trans-unit id="3dd2f9f197debe54b55c044ebc8513127ed88c2f" translate="yes" xml:space="preserve">
          <source>The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays.</source>
          <target state="translated">The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays.</target>
        </trans-unit>
        <trans-unit id="acbe0492ed2a56ae25a5b225e810323a17ee9567" translate="yes" xml:space="preserve">
          <source>The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays. The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.</source>
          <target state="translated">객체는 readExternal 메소드를 구현하여 기본 유형에 대해서는 DataInput 메소드를, 객체, 문자열 및 배열에 대해서는 readObject 메소드를 호출하여 컨텐츠를 복원합니다. readExternal 메소드는 writeExternal이 작성한 것과 동일한 순서 및 유형으로 값을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="c660c0ad9f3d328f1f20a48dcdf28911ebb8dafe" translate="yes" xml:space="preserve">
          <source>The object implements the writeExternal method to save its contents by calling the methods of DataOutput for its primitive values or calling the writeObject method of ObjectOutput for objects, strings, and arrays.</source>
          <target state="translated">객체는 기본 값으로 DataOutput의 메소드를 호출하거나 객체, 문자열 및 배열에 대해 ObjectOutput의 writeObject 메소드를 호출하여 컨텐츠를 저장하기 위해 writeExternal 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="49b3c7a825f5c8fce74e67a564c0c3afebb0bbd2" translate="yes" xml:space="preserve">
          <source>The object is converted to a &lt;code&gt;String&lt;/code&gt; by calling its &lt;code&gt;toString&lt;/code&gt; method. The result is wrapped in a &lt;code&gt;JLabel&lt;/code&gt; and displayed.</source>
          <target state="translated">The object is converted to a &lt;code&gt;String&lt;/code&gt; by calling its &lt;code&gt;toString&lt;/code&gt; method. The result is wrapped in a &lt;code&gt;JLabel&lt;/code&gt; and displayed.</target>
        </trans-unit>
        <trans-unit id="416c57a91832721c9f5aceb6449ffd3e9e13e27e" translate="yes" xml:space="preserve">
          <source>The object is exported with a server socket created using the &lt;a href=&quot;rmisocketfactory&quot;&gt;&lt;code&gt;RMISocketFactory&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">객체는 &lt;a href=&quot;rmisocketfactory&quot;&gt; &lt;code&gt;RMISocketFactory&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 생성 된 서버 소켓과 함께 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="38b36518730fd2c13f206fa344da4fbf71908e2b" translate="yes" xml:space="preserve">
          <source>The object name is written using the usual syntax for &lt;a href=&quot;objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt;. It may contain any legal characters, including &lt;code&gt;]&lt;/code&gt;. It is terminated by a &lt;code&gt;]&lt;/code&gt; character that is the last character in the string.</source>
          <target state="translated">객체 이름은 일반적인 &lt;a href=&quot;objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; 구문을 사용하여 작성 됩니다 . &lt;code&gt;]&lt;/code&gt; 를 포함하여 유효한 문자를 포함 할 수 있습니다 . 문자열에서 마지막 문자 인 &lt;code&gt;]&lt;/code&gt; 문자 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcd8b487cf6c43869dd95c8f0bff1303f6f407e8" translate="yes" xml:space="preserve">
          <source>The object on which the Event initially occurred.</source>
          <target state="translated">이벤트가 처음 발생한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a1808bbdd8fe581c5b3453a2a271ffb2f9d6c722" translate="yes" xml:space="preserve">
          <source>The object reference returned from &lt;code&gt;Transferable.getTransferData&lt;/code&gt; for a &lt;code&gt;DataFlavor&lt;/code&gt; with this MIME Content-Type is required to be an instance of the representation Class of the &lt;code&gt;DataFlavor&lt;/code&gt;.</source>
          <target state="translated">이 MIME Content-Type 을 가진 &lt;code&gt;DataFlavor&lt;/code&gt; 에 대해 &lt;code&gt;Transferable.getTransferData&lt;/code&gt; 에서 반환 된 객체 참조 는 DataFlavor 표현 클래스의 인스턴스 여야 &lt;code&gt;DataFlavor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81130672cbc8ff967d42b441aaca30a9b8bdf723" translate="yes" xml:space="preserve">
          <source>The object returned by the action, which represents the result of invoking the action on the MBean specified.</source>
          <target state="translated">액션이 돌려주는 오브젝트. 지정된 MBean상에서 액션을 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36afb72a7b72fb42fa69bd024e797eb65658034c" translate="yes" xml:space="preserve">
          <source>The object returned by the method, which represents the result of invoking the method on the specified managed resource.</source>
          <target state="translated">메소드가 리턴 한 오브젝트. 지정된 관리 자원에서 메소드를 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4aed1f261990252b69271a77a6e7502c08d201c0" translate="yes" xml:space="preserve">
          <source>The object returned by the operation, which represents the result of invoking the operation on the MBean specified.</source>
          <target state="translated">오퍼레이션에 의해 돌려 주어지는 오브젝트. 지정된 MBean상에서 오퍼레이션을 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6c93f62d51e3b2cfddc806818f63e0d7ad31bfac" translate="yes" xml:space="preserve">
          <source>The object returned by this method is a &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is an &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt;&lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 객체는 &lt;code&gt;InvocationHandler&lt;/code&gt; 가 &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt; &lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt; &lt;/a&gt; 인 &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="19c49d417b2958f22cd9e8d59294bafdefc26984" translate="yes" xml:space="preserve">
          <source>The object returned by this method is a &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is an &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt;&lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 돌려 주어진 오브젝트는 , &lt;code&gt;InvocationHandler&lt;/code&gt; 가 &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt; &lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt; &lt;/a&gt; 인 &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="2fd75977ed6de60086bb423f950b0a7c4c202381" translate="yes" xml:space="preserve">
          <source>The object returned by this method is owned by the caller. The implementation will not subsequently modify it. It will contain either a new &lt;code&gt;Attributes&lt;/code&gt; object that is likewise owned by the caller, or a reference to the original &lt;code&gt;attrs&lt;/code&gt; parameter.</source>
          <target state="translated">이 메소드에 의해 리턴 된 오브젝트는 호출자가 소유합니다. 구현은 나중에 수정하지 않습니다. 호출자가 소유 한 새로운 &lt;code&gt;Attributes&lt;/code&gt; 객체 또는 원래 &lt;code&gt;attrs&lt;/code&gt; 매개 변수에 대한 참조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="de60c4905cdacdd6d8601ccdfcd944817e444f9d" translate="yes" xml:space="preserve">
          <source>The object that holds the data for the progress bar.</source>
          <target state="translated">진행률 표시 줄에 대한 데이터를 보유하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="592ac681baf8df60b8a9b00bdcd506d4334a9175" translate="yes" xml:space="preserve">
          <source>The object that implements the &lt;code&gt;ActionListener&lt;/code&gt; interface gets this &lt;code&gt;ActionEvent&lt;/code&gt; when the event occurs. The listener is therefore spared the details of processing individual mouse movements and mouse clicks, and can instead process a &quot;meaningful&quot; (semantic) event like &quot;button pressed&quot;.</source>
          <target state="translated">&lt;code&gt;ActionListener&lt;/code&gt; 인터페이스 를 구현하는 객체 는 이벤트가 발생할 때이 &lt;code&gt;ActionEvent&lt;/code&gt; 를 가져 옵니다. 따라서 청취자는 개별 마우스 움직임 및 마우스 클릭 처리에 대한 세부 사항을 아끼지 않고 대신 &quot;버튼 누름&quot;과 같은 &quot;의미있는&quot;(의미있는) 이벤트를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="378268adb2f0c5ea9f44ef1d220ef0a45f3c5690" translate="yes" xml:space="preserve">
          <source>The object that implements the &lt;code&gt;ItemListener&lt;/code&gt; interface gets this &lt;code&gt;ItemEvent&lt;/code&gt; when the event occurs. The listener is spared the details of processing individual mouse movements and mouse clicks, and can instead process a &quot;meaningful&quot; (semantic) event like &quot;item selected&quot; or &quot;item deselected&quot;.</source>
          <target state="translated">&lt;code&gt;ItemListener&lt;/code&gt; 인터페이스 를 구현하는 객체 는 이벤트가 발생할 때이 &lt;code&gt;ItemEvent&lt;/code&gt; 를 가져 옵니다. 리스너는 개별 마우스 이동 및 마우스 클릭 처리에 대한 세부 사항을 아끼지 않고 대신 &quot;선택된 항목&quot;또는 &quot;선택 취소 된 항목&quot;과 같은 &quot;의미있는&quot;(의미있는) 이벤트를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="722913fb70b4d355c5461a06c046ff754baedd55" translate="yes" xml:space="preserve">
          <source>The object that implements the &lt;code&gt;TextListener&lt;/code&gt; interface gets this &lt;code&gt;TextEvent&lt;/code&gt; when the event occurs. The listener is spared the details of processing individual mouse movements and key strokes Instead, it can process a &quot;meaningful&quot; (semantic) event like &quot;text changed&quot;.</source>
          <target state="translated">&lt;code&gt;TextListener&lt;/code&gt; 인터페이스 를 구현하는 객체 는 이벤트가 발생할 때이 &lt;code&gt;TextEvent&lt;/code&gt; 를 가져 옵니다. 청취자는 개별 마우스 움직임 및 키 입력 처리에 대한 세부 사항을 아끼지 않고 대신 &quot;텍스트 변경&quot;과 같은 &quot;의미있는&quot;(의미 적) 이벤트를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="3a04190473c4b64ec143351918e9e15b033c0e14" translate="yes" xml:space="preserve">
          <source>The object that will generate the parameters can be initialized in two different ways: in an algorithm-independent manner, or in an algorithm-specific manner:</source>
          <target state="translated">매개 변수를 생성하는 오브젝트는 알고리즘 독립적 방식 또는 알고리즘 고유 방식의 두 가지 방식으로 초기화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0bfa8896361883de50652f049a3abf89fa5b629" translate="yes" xml:space="preserve">
          <source>The object to which this reference refers, or &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</source>
          <target state="translated">이 참조가 참조하는 객체 또는 &lt;code&gt;null&lt;/code&gt; 이 참조가 참조하는 오브젝트.이 참조 오브젝트가 클리어 된 경우</target>
        </trans-unit>
        <trans-unit id="479e4c581de3dc9c3988355f57b5a21b657c8262" translate="yes" xml:space="preserve">
          <source>The object upon which the thread is blocked due to:</source>
          <target state="translated">다음으로 인해 스레드가 차단 된 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="59e05639dc4486cdfe5ff6a8dce8bd4e58ea0a79" translate="yes" xml:space="preserve">
          <source>The object used for executing a static SQL statement and returning the results it produces.</source>
          <target state="translated">정적 SQL 문을 실행하고 생성 된 결과를 반환하는 데 사용되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="6d7b9c42317e2e24d3b3dab9ab7fe4afbf8756cb" translate="yes" xml:space="preserve">
          <source>The object used to synchronize operations on this stream.</source>
          <target state="translated">이 스트림에서 작업을 동기화하는 데 사용되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="47d5085633f8d27160804ec39a21ef33e1d60c26" translate="yes" xml:space="preserve">
          <source>The object used to synchronize operations on this stream. For efficiency, a character-stream object may use an object other than itself to protect critical sections. A subclass should therefore use the object in this field rather than &lt;code&gt;this&lt;/code&gt; or a synchronized method.</source>
          <target state="translated">이 스트림의 조작을 동기화하는데 사용되는 객체입니다. 효율을 높이기 위해 캐릭터 스트림 객체는 중요한 섹션을 보호하기 위해 자체 이외의 객체를 사용할 수 있습니다. 따라서 서브 클래스보다는이 분야에서 객체를 사용해야 &lt;code&gt;this&lt;/code&gt; 또는 동기화 방법.</target>
        </trans-unit>
        <trans-unit id="c7cc5f2db4bc998308c976129ab12d35d38dc95c" translate="yes" xml:space="preserve">
          <source>The object's remote reference.</source>
          <target state="translated">개체의 원격 참조입니다.</target>
        </trans-unit>
        <trans-unit id="a07b833139a6ad3c188a63203fee507e5dfad4ab" translate="yes" xml:space="preserve">
          <source>The object's state for binding; null if the factory is not returning any changes.</source>
          <target state="translated">바인딩을위한 객체의 상태. 팩토리가 변경을 돌려주지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="66b636c530e62514647286e66dec68718239aedb" translate="yes" xml:space="preserve">
          <source>The object, null if the object has not been seen before.</source>
          <target state="translated">객체. 이전에 객체를 보지 못한 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="4b2eb00905a91560fe1394f171982be773d4da7b" translate="yes" xml:space="preserve">
          <source>The objects being observed.</source>
          <target state="translated">관찰되는 물체.</target>
        </trans-unit>
        <trans-unit id="31a9cc545d293e2f13a000cd7cec43d84ee2b3fc" translate="yes" xml:space="preserve">
          <source>The objects of the classes implementing &lt;code&gt;Stroke&lt;/code&gt; must be read-only because &lt;code&gt;Graphics2D&lt;/code&gt; does not clone these objects either when they are set as an attribute with the &lt;code&gt;setStroke&lt;/code&gt; method or when the &lt;code&gt;Graphics2D&lt;/code&gt; object is itself cloned. If a &lt;code&gt;Stroke&lt;/code&gt; object is modified after it is set in the &lt;code&gt;Graphics2D&lt;/code&gt; context then the behavior of subsequent rendering would be undefined.</source>
          <target state="translated">&lt;code&gt;Stroke&lt;/code&gt; 를 구현하는 클래스의 개체는 읽기 전용이어야합니다. &lt;code&gt;Graphics2D&lt;/code&gt; 는 &lt;code&gt;setStroke&lt;/code&gt; 메서드 를 사용하여 특성으로 설정 되거나 &lt;code&gt;Graphics2D&lt;/code&gt; 개체가 자체적으로 복제 될 때 이러한 개체를 복제하지 않기 때문 입니다. &lt;code&gt;Stroke&lt;/code&gt; 객체가 &lt;code&gt;Graphics2D&lt;/code&gt; 컨텍스트에 설정된 후 수정 되면 후속 렌더링의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebe728976b073c45bf744821ca6ba80ce51a0da6" translate="yes" xml:space="preserve">
          <source>The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM Mechanism Requirements&lt;/a&gt; section of the API overview. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for more information.</source>
          <target state="translated">이 팩토리가 생성하는 객체는 DOM을 기반으로 하며 API 개요 의 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM 메커니즘 요구 사항&lt;/a&gt; 섹션에 정의 된 DOM 상호 운용성 요구 사항을 준수합니다 . 자세한 정보는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#xml-signature-xmlsignaturefactorykeyinfofactorytransformservice-mechanisms&quot;&gt;Java Security Standard Algorithm Names&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d122f0c0cc63ee07c0c1d3a3a38f8a6e6ad5a6b" translate="yes" xml:space="preserve">
          <source>The objects that this factory produces will be based on DOM and abide by the DOM interoperability requirements as defined in the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM Mechanism Requirements&lt;/a&gt; section of the API overview. See the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_provider&quot;&gt;Service Providers&lt;/a&gt; section of the API overview for a list of standard mechanism types.</source>
          <target state="translated">이 팩토리가 생성하는 객체는 DOM을 기반으로 하며 API 개요 의 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_rqmts&quot;&gt;DOM 메커니즘 요구 사항&lt;/a&gt; 섹션에 정의 된 DOM 상호 운용성 요구 사항을 준수합니다 . 표준 메커니즘 유형 목록은 API 개요 의 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_xmldsig_provider&quot;&gt;서비스 제공 업체&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="429abc75cd4f81d9b58c4ca6b602d61ef39ec33b" translate="yes" xml:space="preserve">
          <source>The observed attribute has differed from the &quot;string to compare&quot; value.</source>
          <target state="translated">관찰 된 속성이 &quot;string to compare&quot;값과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="871c7770e55cdc1bbf71029ab54209655d703ea8" translate="yes" xml:space="preserve">
          <source>The observed attribute has exceeded the threshold high value.</source>
          <target state="translated">관찰 된 속성이 임계 값 상한값을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="672d698adf676e55830651a3e0dd447d91d839f5" translate="yes" xml:space="preserve">
          <source>The observed attribute has exceeded the threshold low value.</source>
          <target state="translated">관찰 된 속성이 임계 값 하한값을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="999e98019d02c1e1a5253c17913dd0ced4ce971f" translate="yes" xml:space="preserve">
          <source>The observed attribute has matched the &quot;string to compare&quot; value.</source>
          <target state="translated">관찰 된 속성이 &quot;string to compare&quot;값과 일치했습니다.</target>
        </trans-unit>
        <trans-unit id="46421981f801d958da0b6eee8f1acb3f27c41fd9" translate="yes" xml:space="preserve">
          <source>The observed attribute has reached the threshold value.</source>
          <target state="translated">관찰 된 속성이 임계 값에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="fca6efcbf0300595dc90421a5999ce724786f218" translate="yes" xml:space="preserve">
          <source>The observed attribute is not contained in the observed object.</source>
          <target state="translated">관찰 된 속성은 관찰 된 개체에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a495e45796ee85b6f7b4712f3dc6b44dbd9667b" translate="yes" xml:space="preserve">
          <source>The observed attribute is not initialized by default (set to null).</source>
          <target state="translated">관찰 된 속성은 기본적으로 초기화되지 않습니다 (null로 설정).</target>
        </trans-unit>
        <trans-unit id="01626b79ebba8880f72349668f94f078b89c13bd" translate="yes" xml:space="preserve">
          <source>The observed attribute.</source>
          <target state="translated">관찰 된 속성.</target>
        </trans-unit>
        <trans-unit id="0a9f956d167d7d6dbfd3e8ba63d5548489a146e8" translate="yes" xml:space="preserve">
          <source>The observed object is not registered in the MBean server.</source>
          <target state="translated">관찰 된 오브젝트가 MBean 서버에 등록되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="416b7e765f8103a9eb70b7e15edec19bb2ecc0e9" translate="yes" xml:space="preserve">
          <source>The observed object.</source>
          <target state="translated">관찰 된 물체.</target>
        </trans-unit>
        <trans-unit id="45dc8c9c6ea7bb9a99fef1fccbc3548f32fa1a9e" translate="yes" xml:space="preserve">
          <source>The obtained &lt;a href=&quot;typeinfoprovider&quot;&gt;&lt;code&gt;TypeInfoProvider&lt;/code&gt;&lt;/a&gt; can be queried during a parse to access the type information determined by the validator.</source>
          <target state="translated">획득 한 &lt;a href=&quot;typeinfoprovider&quot;&gt; &lt;code&gt;TypeInfoProvider&lt;/code&gt; &lt;/a&gt; 는 유효성 검사기가 결정한 유형 정보에 액세스하기 위해 구문 분석 중에 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="57e624d8b36b41f9dc5b92485a65e92541347bbe" translate="yes" xml:space="preserve">
          <source>The official ISO-8601 standard does not define eras, however &lt;code&gt;IsoChronology&lt;/code&gt; does. It defines two eras, 'CE' from year one onwards and 'BCE' from year zero backwards. Since dates before the Julian-Gregorian cutover are not in line with history, the cutover between 'BCE' and 'CE' is also not aligned with the commonly used eras, often referred to using 'BC' and 'AD'.</source>
          <target state="translated">공식 ISO-8601 표준은 시대를 정의 하지 않지만 &lt;code&gt;IsoChronology&lt;/code&gt; 는 시대를 정의하지 않습니다 . 1 년부터 'CE', 0 년부터 'BCE'의 두 시대를 정의합니다. Julian-Gregorian 컷 오버 이전 날짜는 역사와 일치하지 않기 때문에 'BCE'와 'CE'사이의 컷 오버는 흔히 'BC'와 'AD'를 사용하는 데 사용되는 일반적으로 사용되는 시대와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="702e5e5fb4fee8a147a291965da3b8b686cd784a" translate="yes" xml:space="preserve">
          <source>The official XML Namespace name URI.</source>
          <target state="translated">공식 XML 네임 스페이스 이름 URI입니다.</target>
        </trans-unit>
        <trans-unit id="ffab6be2401ae307b4e44045f56125a67011b1bb" translate="yes" xml:space="preserve">
          <source>The official XML Namespace prefix.</source>
          <target state="translated">공식 XML 네임 스페이스 접두사.</target>
        </trans-unit>
        <trans-unit id="a4a7af578f6f669ed14b4164a2625019a1a64582" translate="yes" xml:space="preserve">
          <source>The official XML attribute used for specifying XML Namespace declarations, &lt;a href=&quot;#XMLNS_ATTRIBUTE&quot;&gt;&lt;code&gt;XMLConstants.XMLNS_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;, Namespace name URI.</source>
          <target state="translated">XML 네임 스페이스 선언, &lt;a href=&quot;#XMLNS_ATTRIBUTE&quot;&gt; &lt;code&gt;XMLConstants.XMLNS_ATTRIBUTE&lt;/code&gt; &lt;/a&gt; , 네임 스페이스 이름 URI 를 지정하는 데 사용되는 공식 XML 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="7c5ea6d3db745c887e7f367926242e325c40c6a6" translate="yes" xml:space="preserve">
          <source>The official XML attribute used for specifying XML Namespace declarations.</source>
          <target state="translated">XML 네임 스페이스 선언을 지정하는 데 사용되는 공식 XML 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9aa0cbb0971f94ec243f04bed4069fee72927eed" translate="yes" xml:space="preserve">
          <source>The offset</source>
          <target state="translated">오프셋</target>
        </trans-unit>
        <trans-unit id="7452b72544afe4ea17383b9c1a0ddd335f187953" translate="yes" xml:space="preserve">
          <source>The offset after the last character captured by the group, or &lt;code&gt;-1&lt;/code&gt; if the match was successful but the group itself did not match anything</source>
          <target state="translated">그룹이 마지막으로 캡처 한 문자 이후의 오프셋 또는 &lt;code&gt;-1&lt;/code&gt; 일치하지만 그룹 자체가 아무 것도 일치하지 않으면</target>
        </trans-unit>
        <trans-unit id="a6a514a96e4c706169df1bae50ab993a34ff2649" translate="yes" xml:space="preserve">
          <source>The offset after the last character matched</source>
          <target state="translated">마지막 문자 이후의 오프셋</target>
        </trans-unit>
        <trans-unit id="95184cd7d4878804e4744550fed5412ac87a781a" translate="yes" xml:space="preserve">
          <source>The offset does not affect the calculation and will be the same in the result.</source>
          <target state="translated">오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8d0ea8f68c9762891010ddff46c446503f293682" translate="yes" xml:space="preserve">
          <source>The offset from UTC/Greenwich.</source>
          <target state="translated">UTC / 그리니치와의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="187e2b59cf9b7d7beab7161e59a7d3c2b6d648e0" translate="yes" xml:space="preserve">
          <source>The offset in the destination where the upper-left decoded pixel should be placed.</source>
          <target state="translated">디코딩 된 왼쪽 상단 픽셀이 배치되어야하는 대상의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="f5e45443bbef26f421b83a68935e17782face615" translate="yes" xml:space="preserve">
          <source>The offset in the destination where the upper-left decoded pixel should be placed. By default, the value is (0, 0).</source>
          <target state="translated">왼쪽 상단의 디코딩 된 픽셀을 배치 할 대상의 오프셋입니다. 기본적으로 값은 (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="bcad531c02ce778e413b93f44d2a73d86d13c97e" translate="yes" xml:space="preserve">
          <source>The offset must be in the range &lt;code&gt;-18:00&lt;/code&gt; to &lt;code&gt;+18:00&lt;/code&gt;, which corresponds to -64800 to +64800.</source>
          <target state="translated">오프셋은 &lt;code&gt;-18:00&lt;/code&gt; ~ &lt;code&gt;+18:00&lt;/code&gt; 범위에 있어야하며 이는 -64800 ~ +64800에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="1779234f1100c3b7e70e689137679a16d92bfee0" translate="yes" xml:space="preserve">
          <source>The offset of the caret is relative to the current composed text; that is, the composed text within getText() if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within getText() of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.</source>
          <target state="translated">캐럿의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 이것이 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 인 경우 getText () 내의 작성된 텍스트, 그렇지 않은 경우 이전 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 의 getText () 내의 작성된 텍스트 입니다.</target>
        </trans-unit>
        <trans-unit id="298942ecb904f06c2e9ab9e10fc0a7a6f6c5d93f" translate="yes" xml:space="preserve">
          <source>The offset of the divider.</source>
          <target state="translated">구분선의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="bc4e0b22e164423e697bcbfa93e4a52b80e4ded8" translate="yes" xml:space="preserve">
          <source>The offset of the visible position is relative to the current composed text; that is, the composed text within getText() if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within getText() of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.</source>
          <target state="translated">보이는 위치의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 이것이 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 인 경우 getText () 내의 작성된 텍스트, 그렇지 않은 경우 이전 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트 의 getText () 내의 작성된 텍스트 입니다.</target>
        </trans-unit>
        <trans-unit id="dbff04852ae6dc7f91ef52e4416eeb9c4bdba3f8" translate="yes" xml:space="preserve">
          <source>The offset value.</source>
          <target state="translated">오프셋 값.</target>
        </trans-unit>
        <trans-unit id="1ee05bd1235e40acbee8bde4cc93361e017df6f0" translate="yes" xml:space="preserve">
          <source>The offset within this buffer's array of the first element of the buffer</source>
          <target state="translated">버퍼의 첫 번째 요소에 대한이 버퍼의 배열 내 오프셋</target>
        </trans-unit>
        <trans-unit id="c2f54cdf947745f8f0b6ab00403e70f969ef9fcc" translate="yes" xml:space="preserve">
          <source>The offset-based date-time types &lt;code&gt;OffsetTime&lt;/code&gt; and &lt;code&gt;OffsetDateTime&lt;/code&gt;, are intended primarily for use with network protocols and database access. For example, most databases cannot automatically store a time-zone like 'Europe/Paris', but they can store an offset like '+02:00'.</source>
          <target state="translated">오프셋 기반 날짜-시간 유형 &lt;code&gt;OffsetTime&lt;/code&gt; 및 &lt;code&gt;OffsetDateTime&lt;/code&gt; 은 주로 네트워크 프로토콜 및 데이터베이스 액세스에 사용하기위한 것입니다. 예를 들어, 대부분의 데이터베이스는 '유럽 / 파리'와 같은 시간대를 자동으로 저장할 수 없지만 '+02 : 00'과 같은 오프셋을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118a1e86d2011a80aabb35687d2f8db1fc48e418" translate="yes" xml:space="preserve">
          <source>The offsets are compared in the order that they occur for the same time of day around the world. Thus, an offset of &lt;code&gt;+10:00&lt;/code&gt; comes before an offset of &lt;code&gt;+09:00&lt;/code&gt; and so on down to &lt;code&gt;-18:00&lt;/code&gt;.</source>
          <target state="translated">오프셋은 전 세계 동일한 시간에 발생하는 순서대로 비교됩니다. 따라서 &lt;code&gt;+10:00&lt;/code&gt; 오프셋은 &lt;code&gt;+09:00&lt;/code&gt; 오프셋 앞에오고 &lt;code&gt;-18:00&lt;/code&gt; 까지 내려갑니다 .</target>
        </trans-unit>
        <trans-unit id="b9fdfa406d3d4cfc6d0cc44eef8e628beb67c6ec" translate="yes" xml:space="preserve">
          <source>The offsets of &lt;code&gt;caret&lt;/code&gt; and &lt;code&gt;visiblePosition&lt;/code&gt; are relative to the current composed text; that is, the composed text within the &lt;code&gt;text&lt;/code&gt; of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event if the event being constructed as a &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt; event. For an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event without text, &lt;code&gt;caret&lt;/code&gt; and &lt;code&gt;visiblePosition&lt;/code&gt; must be &lt;code&gt;null&lt;/code&gt;. The time stamp for this event is initialized by invoking &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt;&lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;caret&lt;/code&gt; 및 &lt;code&gt;visiblePosition&lt;/code&gt; 의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 내부 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 앞의 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트는 이벤트로 구성되는 경우 &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt; 이벤트. 를 들어 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 텍스트없이 이벤트 &lt;code&gt;caret&lt;/code&gt; 및 &lt;code&gt;visiblePosition&lt;/code&gt; 이 있어야합니다 &lt;code&gt;null&lt;/code&gt; . 이 이벤트의 타임 스탬프는 &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt; &lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt; &lt;/a&gt; 을 호출하여 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9615764801bc7f0118b08c3cedefd1d207963ebd" translate="yes" xml:space="preserve">
          <source>The offsets of caret and visiblePosition are relative to the current composed text; that is, the composed text within &lt;code&gt;text&lt;/code&gt; if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within the &lt;code&gt;text&lt;/code&gt; of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.</source>
          <target state="translated">caret 및 visiblePosition의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 내 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 이는 경우 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트는 내의 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 앞의 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 그렇지 않으면 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="e3efed3cce04acecd68237e471d78f4ab8c10742" translate="yes" xml:space="preserve">
          <source>The offsets of caret and visiblePosition are relative to the current composed text; that is, the composed text within &lt;code&gt;text&lt;/code&gt; if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event, the composed text within the &lt;code&gt;text&lt;/code&gt; of the preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise. The time stamp for this event is initialized by invoking &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt;&lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">caret 및 visiblePosition의 오프셋은 현재 작성된 텍스트를 기준으로합니다. 즉, 내 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 이는 경우 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 이벤트는 내의 변환 텍스트 &lt;code&gt;text&lt;/code&gt; 앞의 &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; 그렇지 않으면 이벤트입니다. 이 이벤트의 타임 스탬프는 &lt;a href=&quot;../eventqueue#getMostRecentEventTime()&quot;&gt; &lt;code&gt;EventQueue.getMostRecentEventTime()&lt;/code&gt; &lt;/a&gt; 을 호출하여 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e102309a5333ab2237cebc7d402fc7f4a95ad222" translate="yes" xml:space="preserve">
          <source>The old binding: information about the object before the change.</source>
          <target state="translated">기존 바인딩 : 변경 전 객체에 대한 정보</target>
        </trans-unit>
        <trans-unit id="d5f61ec25f174a0aa0e3e129763ffbe8890fd5d4" translate="yes" xml:space="preserve">
          <source>The old modifiers</source>
          <target state="translated">이전 수정 자</target>
        </trans-unit>
        <trans-unit id="d09e0e17113c933353bdc17d7b91ac2797ae7090" translate="yes" xml:space="preserve">
          <source>The old modifiers listed below also can be used, but they are mapped to _DOWN_ modifiers.</source>
          <target state="translated">아래에 나열된 이전 수정 자도 사용할 수 있지만 _DOWN_ 수정 자에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="eaa830de2cd1ee40ef0e64424b6658b54dfedf50" translate="yes" xml:space="preserve">
          <source>The old value for the property, expressed as an Object. May be null if multiple properties have changed.</source>
          <target state="translated">속성의 이전 값으로, Object로 표시됩니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8804e2adfeaa4e67e196991549e2b345ab8e8bf" translate="yes" xml:space="preserve">
          <source>The old/new binding in &lt;code&gt;NamingEvent&lt;/code&gt; may be null if the old name or new name is outside of the scope for which the listener has registered.</source>
          <target state="translated">이전 이름 ​​또는 새 이름이 리스너가 등록한 범위를 벗어나면 &lt;code&gt;NamingEvent&lt;/code&gt; 의 이전 / 새 바인딩 이 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="100741ba84acd0a7c97819d3b1fe9d00db066275" translate="yes" xml:space="preserve">
          <source>The one exception to this is a treeNodesChanged event that is to identify the root, in which case this will return the root and &lt;code&gt;getChildIndices&lt;/code&gt; will return null.</source>
          <target state="translated">이에 대한 한 가지 예외는 루트를 식별하는 treeNodesChanged 이벤트입니다.이 경우 루트 를 반환 하고 &lt;code&gt;getChildIndices&lt;/code&gt; 는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8fe09a5500bade693b5533a5b93beed8253b86c" translate="yes" xml:space="preserve">
          <source>The one variation from Java language access control is that the checks by reflected objects assume readability. That is, the module containing the use of a reflected object is assumed to read the module in which the underlying field, method, or constructor is declared.</source>
          <target state="translated">Java 언어 액세스 제어의 한 가지 변형은 반사 된 객체에 의한 검사가 가독성을 가정한다는 것입니다. 즉, 리플렉션 된 객체의 사용을 포함하는 모듈은 기본 필드, 메서드 또는 생성자가 선언 된 모듈을 읽는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3680a0d410cbf7c86a348b63caf1fd252cbc022a" translate="yes" xml:space="preserve">
          <source>The only characters in attribute values that are escaped are those which section 2.4 of RFC 2253 states must be escaped (they are escaped using a preceding backslash character)</source>
          <target state="translated">이스케이프되는 속성 값의 유일한 문자는 RFC 2253 상태의 2.4 섹션을 이스케이프해야하는 문자입니다 (앞의 백 슬래시 문자를 사용하여 이스케이프됩니다).</target>
        </trans-unit>
        <trans-unit id="295fb6b399f1423277a11d5a7f557688d118f6dd" translate="yes" xml:space="preserve">
          <source>The only dataTypes supported currently are TYPE_BYTE and TYPE_USHORT.</source>
          <target state="translated">현재 지원되는 유일한 데이터 유형은 TYPE_BYTE 및 TYPE_USHORT입니다.</target>
        </trans-unit>
        <trans-unit id="e7143ae9d93c0b9dfc0aad9a9d7d22c047ec7cdb" translate="yes" xml:space="preserve">
          <source>The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT, and TYPE_INT.</source>
          <target state="translated">현재 지원되는 유일한 데이터 유형은 TYPE_BYTE, TYPE_USHORT 및 TYPE_INT입니다.</target>
        </trans-unit>
        <trans-unit id="2e9ed2799ba6b886f681d8689a9cf0acba5d537b" translate="yes" xml:space="preserve">
          <source>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using &quot;&lt;code&gt;parallelStream()&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;stream()&lt;/code&gt;&quot;. The stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which the terminal operation is invoked. The sequential or parallel mode of a stream can be determined with the &lt;a href=&quot;basestream#isParallel()&quot;&gt;&lt;code&gt;BaseStream.isParallel()&lt;/code&gt;&lt;/a&gt; method, and the stream's mode can be modified with the &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basestream#parallel()&quot;&gt;&lt;code&gt;BaseStream.parallel()&lt;/code&gt;&lt;/a&gt; operations. The most recent sequential or parallel mode setting applies to the execution of the entire stream pipeline.</source>
          <target state="translated">이 예제의 직렬 버전과 병렬 버전의 유일한 차이점 은 &quot; &lt;code&gt;stream()&lt;/code&gt; &quot; 대신 &quot; &lt;code&gt;parallelStream()&lt;/code&gt; &quot;을 사용하여 초기 스트림을 생성 한다는 것입니다 . 스트림 파이프 라인은 터미널 작업이 호출되는 스트림의 모드에 따라 순차적으로 또는 병렬로 실행됩니다. 스트림의 순차 또는 병렬 모드는 &lt;a href=&quot;basestream#isParallel()&quot;&gt; &lt;code&gt;BaseStream.isParallel()&lt;/code&gt; &lt;/a&gt; 메서드 로 결정될 수 있으며 스트림의 모드는 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;basestream#parallel()&quot;&gt; &lt;code&gt;BaseStream.parallel()&lt;/code&gt; &lt;/a&gt; 작업 으로 수정할 수 있습니다 . 가장 최근의 순차 또는 병렬 모드 설정은 전체 스트림 파이프 라인의 실행에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c196d72932e1d175e571f345ae61f12d79c6347" translate="yes" xml:space="preserve">
          <source>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using &quot;&lt;code&gt;parallelStream()&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;stream()&lt;/code&gt;&quot;. When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the orientation of the stream on which it is invoked. Whether a stream will execute in serial or parallel can be determined with the &lt;code&gt;isParallel()&lt;/code&gt; method, and the orientation of a stream can be modified with the &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basestream#parallel--&quot;&gt;&lt;code&gt;BaseStream.parallel()&lt;/code&gt;&lt;/a&gt; operations. When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which it is invoked.</source>
          <target state="translated">이 예제의 직렬 버전과 병렬 버전의 유일한 차이점은 &quot; &lt;code&gt;parallelStream()&lt;/code&gt; 사용하여 초기 스트림을 만드는 것입니다. 은 &quot; &lt;code&gt;stream()&lt;/code&gt; &quot; 대신 &quot;을 . 터미널 작업이 시작되면 스트림 파이프 라인은 호출 된 스트림의 방향에 따라 순차적으로 또는 병렬로 실행됩니다. 직렬 또는 병렬로 스트림을 실행할지 여부는 &lt;code&gt;isParallel()&lt;/code&gt; 메서드로 확인할 수 있으며 &lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;basestream#parallel--&quot;&gt; &lt;code&gt;BaseStream.parallel()&lt;/code&gt; &lt;/a&gt; 작업 을 사용하여 스트림 방향을 수정할 수 있습니다 . 터미널 동작이 시작될 때, 스트림 파이프 라인은 그것이 호출되는 스트림의 모드에 따라 순차적으로 또는 병렬로 실행된다.</target>
        </trans-unit>
        <trans-unit id="30c57e209d37493c24bd2337628683ad099f2c41" translate="yes" xml:space="preserve">
          <source>The only features recognized are namespaces and namespace-prefixes.</source>
          <target state="translated">인식되는 유일한 기능은 네임 스페이스와 네임 스페이스 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="f349a38007f0fe5c739a24493c39f2bc7e05087f" translate="yes" xml:space="preserve">
          <source>The only possible modifiers for constructors are the access modifiers &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;. Only one of these may appear, or none if the constructor has default (package) access.</source>
          <target state="translated">생성자에 가능한 유일한 수정자는 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 액세스 수정 자 입니다. 이 중 하나만 표시되거나 생성자가 기본 (패키지) 액세스 권한을 가진 경우 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89b452c765bdde7f50f7ca76fd6cb50b91fd636" translate="yes" xml:space="preserve">
          <source>The opacity value is in the range [0..1]. Note that setting the opacity level of 0 may or may not disable the mouse event handling on this window. This is a platform-dependent behavior.</source>
          <target state="translated">불투명도 값은 [0..1] 범위에 있습니다. 불투명도 수준을 0으로 설정하면이 창에서 마우스 이벤트 처리가 비활성화되거나 비활성화되지 않을 수 있습니다. 이것은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="be1c279f5e78386178da2165b50da21200087330" translate="yes" xml:space="preserve">
          <source>The open package was implicitly declared in the source of the module declaration.</source>
          <target state="translated">오픈 패키지는 모듈 선언의 소스에서 암시 적으로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="bcc4bb5d73de91ce75aba43acec34215a0639c91" translate="yes" xml:space="preserve">
          <source>The open package was not explicitly or implicitly declared in the source of the module declaration.</source>
          <target state="translated">열린 패키지가 모듈 선언의 소스에서 명시 적으로 또는 암시 적으로 선언되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8ede533a4ed0afa29ef99e43a7a5d5449c703aa3" translate="yes" xml:space="preserve">
          <source>The operable part of the drop site for the &lt;code&gt;DropTarget&lt;/code&gt; is the part of the associated &lt;code&gt;Component&lt;/code&gt;'s geometry that is not obscured by an overlapping top-level window or by another &lt;code&gt;Component&lt;/code&gt; higher in the Z-order that has an associated active &lt;code&gt;DropTarget&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DropTarget&lt;/code&gt; 에 대한 드롭 사이트의 작동 가능한 부분은 겹치는 최상위 창이나 연결된 활성 &lt;code&gt;DropTarget&lt;/code&gt; 이있는 Z 순서에서 상위에있는 다른 &lt;code&gt;Component&lt;/code&gt; 의해 가려지지 않는 연결된 &lt;code&gt;Component&lt;/code&gt; 의 지오메트리 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="757cee3ea404c7279f0c6b75405f9e5d965d2914" translate="yes" xml:space="preserve">
          <source>The operating system program file was not found.</source>
          <target state="translated">운영 체제 프로그램 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="47390cdf3b88c3e58ad9e0ae77f10ad59aa1eaf6" translate="yes" xml:space="preserve">
          <source>The operation just closed this side of the &lt;code&gt;SSLEngine&lt;/code&gt;, or the operation could not be completed because it was already closed.</source>
          <target state="translated">작업이 &lt;code&gt;SSLEngine&lt;/code&gt; 의 이면을 닫았 거나 이미 닫혀서 작업을 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d716f5e6eb73ca33a6b17f0e7fa84479a8ab34c7" translate="yes" xml:space="preserve">
          <source>The operation of this method is slightly different to similar methods using &lt;code&gt;ParsePosition&lt;/code&gt; on &lt;code&gt;java.text.Format&lt;/code&gt;. That class will return errors using the error index on the &lt;code&gt;ParsePosition&lt;/code&gt;. By contrast, this method will throw a &lt;a href=&quot;datetimeparseexception&quot;&gt;&lt;code&gt;DateTimeParseException&lt;/code&gt;&lt;/a&gt; if an error occurs, with the exception containing the error index. This change in behavior is necessary due to the increased complexity of parsing and resolving dates/times in this API.</source>
          <target state="translated">이 메소드의 조작은 &lt;code&gt;java.text.Format&lt;/code&gt; 에서 &lt;code&gt;ParsePosition&lt;/code&gt; 을 사용하는 유사한 메소드와 약간 다릅니다. . 해당 클래스는 &lt;code&gt;ParsePosition&lt;/code&gt; 의 오류 인덱스를 사용하여 오류를 반환합니다 . 반대로,이 메서드는 오류 인덱스가 포함 된 예외를 제외하고 오류가 발생 하면 &lt;a href=&quot;datetimeparseexception&quot;&gt; &lt;code&gt;DateTimeParseException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다. 이 동작의 변경은이 API에서 구문 분석 및 날짜 / 시간의 복잡성이 증가함에 따라 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8c2dbe5cb88129c338520227f951d5d21bc3adc0" translate="yes" xml:space="preserve">
          <source>The operation proceeds as follows:</source>
          <target state="translated">작업은 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="6229974772e67797588385f119266fb6e2f20834" translate="yes" xml:space="preserve">
          <source>The operation to perform when this action is triggered.</source>
          <target state="translated">이 작업이 트리거 될 때 수행 할 작업입니다.</target>
        </trans-unit>
        <trans-unit id="385a016e839d895d961c9b7fc691a93ab6bd727c" translate="yes" xml:space="preserve">
          <source>The operation will be performed field by field with the precision of &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt;. Since all the fields except seconds are restricted to hold integers, any fraction produced by the computation will be carried down toward the next lower unit. For example, if you multiply &quot;P1D&quot; (1 day) with &quot;0.5&quot;, then it will be 0.5 day, which will be carried down to &quot;PT12H&quot; (12 hours). When fractions of month cannot be meaningfully carried down to days, or year to months, this will cause an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; to be thrown. For example if you multiple one month by 0.5.</source>
          <target state="translated">작업은 &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt; 정밀도로 필드별로 수행됩니다 . 초를 제외한 모든 필드는 정수를 보유하도록 제한되므로 계산에 의해 생성 된 모든 분수는 다음 하위 단위로 전달됩니다. 예를 들어 &quot;P1D&quot;(1 일)에 &quot;0.5&quot;를 곱하면 0.5 일이되고 &quot;PT12H&quot;(12 시간)로 이월됩니다. 월의 분수가 의미있게 일 또는 연 단위로 이월 될 수없는 경우 &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 예를 들어 한 달에 0.5를 곱한 경우.</target>
        </trans-unit>
        <trans-unit id="1e9b100e7d6bf71d9d81c5cf765dd6e9312adf7f" translate="yes" xml:space="preserve">
          <source>The optical photo conductor is near end of life.</source>
          <target state="translated">광학 포토 컨덕터의 수명이 거의 다되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc98736e760491006a9169783a49bc78538cc3ca" translate="yes" xml:space="preserve">
          <source>The optical photo conductor is no longer functioning.</source>
          <target state="translated">광학 포토 컨덕터가 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c62ce663f6e5bbb6451017676b19762e1fbf3161" translate="yes" xml:space="preserve">
          <source>The option must be set prior to entering a blocking operation to take effect. If the timeout expires and the operation would continue to block, &lt;b&gt;java.io.InterruptedIOException&lt;/b&gt; is raised. The Socket is not closed in this case.</source>
          <target state="translated">차단 작업을 시작하기 전에 옵션을 설정해야 적용됩니다. 시간 초과가 만료되고 작업이 계속 차단되면&lt;b&gt; java.io.InterruptedIOException&lt;/b&gt; 이 발생합니다. 이 경우 소켓이 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="780ff6733d087d7bf446709714c8ebb00a2cffdb" translate="yes" xml:space="preserve">
          <source>The optional build information is compared lexicographically. During this comparison, a version with optional build information is considered to be greater than a version without one.</source>
          <target state="translated">선택적 빌드 정보는 사전 식으로 비교됩니다. 이 비교 중에 선택적 빌드 정보가있는 버전은없는 버전보다 큰 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7d31088ebde33203706fda6d4531c19f262ae377" translate="yes" xml:space="preserve">
          <source>The optional build number.</source>
          <target state="translated">선택적 빌드 번호입니다.</target>
        </trans-unit>
        <trans-unit id="7fde895ca15e28398e2093122f9b0e89dd2c837e" translate="yes" xml:space="preserve">
          <source>The optional capacity bound constructor argument serves as a way to prevent excessive expansion. The capacity, if unspecified, is equal to &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity.</source>
          <target state="translated">선택적 용량 바운드 생성자 인수는 과도한 확장을 방지하는 방법으로 사용됩니다. 지정되지 않은 경우 용량은 &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 같습니다 .MAX_VALUE . 링크 노드는 용량을 초과하지 않는 한 각 삽입시 동적으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1b391ca196a239752a071899940b30e945c7e626" translate="yes" xml:space="preserve">
          <source>The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.</source>
          <target state="translated">선택적 용량 바운드 생성자 인수는 과도한 큐 확장을 방지하는 방법으로 사용됩니다. 지정되지 않은 경우 용량은 &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 같습니다 .MAX_VALUE . 큐가 용량을 초과하지 않는 한 링크 된 노드는 각 삽입시 동적으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="40329cb44fef466069a746e7e8616ce88f318acf" translate="yes" xml:space="preserve">
          <source>The optional interface implemented by ScriptEngines whose methods allow the invocation of procedures in scripts that have previously been executed.</source>
          <target state="translated">이전에 실행 된 스크립트에서 프로 시저를 호출 할 수있는 메소드를 가진 ScriptEngine에 의해 구현 된 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="af44167d5098cd1640942f676f56da64386bc769" translate="yes" xml:space="preserve">
          <source>The optional interface implemented by ScriptEngines whose methods compile scripts to a form that can be executed repeatedly without recompilation.</source>
          <target state="translated">스크립트 엔진이 다시 컴파일하지 않고 반복적으로 실행할 수있는 형식으로 스크립트를 컴파일하는 ScriptEngine에서 구현 한 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bc1b7b35aca1d8eeff15523a95ddf328b6c781ce" translate="yes" xml:space="preserve">
          <source>The optional module name is prefixed to the type name or package name and separated using a &quot;&lt;code&gt;/&lt;/code&gt;&quot; character. For example, to create a class file for type &lt;code&gt;a.B&lt;/code&gt; in module &lt;code&gt;foo&lt;/code&gt;, use a &lt;code&gt;name&lt;/code&gt; argument of &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt;.</source>
          <target state="translated">선택적 모듈 이름은 유형 이름 또는 패키지 이름 앞에 붙고 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자를 사용하여 구분됩니다 . 예를 들어, &lt;code&gt;foo&lt;/code&gt; 모듈에서 &lt;code&gt;a.B&lt;/code&gt; 유형에 대한 클래스 파일을 생성 하려면 &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7b05f568bb77158d95ed44eb1b1ee848f1cc15e" translate="yes" xml:space="preserve">
          <source>The optional module name is prefixed to the type name or package name and separated using a &quot;&lt;code&gt;/&lt;/code&gt;&quot; character. For example, to create a source file for type &lt;code&gt;a.B&lt;/code&gt; in module &lt;code&gt;foo&lt;/code&gt;, use a &lt;code&gt;name&lt;/code&gt; argument of &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt;.</source>
          <target state="translated">선택적 모듈 이름은 유형 이름 또는 패키지 이름 앞에 붙고 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자를 사용하여 구분됩니다 . 예를 들어, &lt;code&gt;foo&lt;/code&gt; 모듈에서 &lt;code&gt;a.B&lt;/code&gt; 유형에 대한 소스 파일을 만들려면 &lt;code&gt;&quot;foo/a.B&quot;&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d5829c87f129903c32edbc130685e2ce1d68c681" translate="yes" xml:space="preserve">
          <source>The optional pre-release information as a String</source>
          <target state="translated">선택적 시험판 정보 (문자열)</target>
        </trans-unit>
        <trans-unit id="fc3f9d6f338a5687d0aaac4c1e2d14791c14a93e" translate="yes" xml:space="preserve">
          <source>The options objects should contain either instances of &lt;code&gt;Component&lt;/code&gt;s, (which are added directly) or &lt;code&gt;Strings&lt;/code&gt; (which are wrapped in a &lt;code&gt;JButton&lt;/code&gt;). If you provide &lt;code&gt;Component&lt;/code&gt;s, you must ensure that when the &lt;code&gt;Component&lt;/code&gt; is clicked it messages &lt;code&gt;setValue&lt;/code&gt; in the created &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">옵션 객체는 &lt;code&gt;Component&lt;/code&gt; 의 인스턴스 (직접 추가됨) 또는 &lt;code&gt;Strings&lt;/code&gt; ( &lt;code&gt;JButton&lt;/code&gt; 에 래핑 됨 ) 중 하나를 포함해야합니다 . &lt;code&gt;Component&lt;/code&gt; 를 제공 하는 경우 &lt;code&gt;Component&lt;/code&gt; 를 클릭하면 생성 된 &lt;code&gt;JOptionPane&lt;/code&gt; 에 &lt;code&gt;setValue&lt;/code&gt; 메시지가 표시 되는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d323759d66423b856604e1ca269cc6f1231f8e4" translate="yes" xml:space="preserve">
          <source>The order in which notifications will be delivered is unspecified. The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose.</source>
          <target state="translated">알림이 전달되는 순서는 지정되지 않았습니다. Observable 클래스에서 제공되는 기본 구현은 Observer에게 관심 등록 된 순서대로 통지하지만 서브 클래스는이 순서를 변경하거나 보장 된 순서를 사용하지 않으며 별도의 스레드에 알림을 전달하거나 서브 클래스가이 순서를 따르도록 보장 할 수 있습니다 고르다.</target>
        </trans-unit>
        <trans-unit id="6143ddfdc758405eea52fe688b165bfc50d049e2" translate="yes" xml:space="preserve">
          <source>The order in which the certificates are presented to the &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; may be either in the forward direction (from target to most-trusted CA) or in the reverse direction (from most-trusted CA to target). A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; implementation &lt;b&gt;must&lt;/b&gt; support reverse checking (the ability to perform its checks when it is presented with certificates in the reverse direction) and &lt;b&gt;may&lt;/b&gt; support forward checking (the ability to perform its checks when it is presented with certificates in the forward direction). The &lt;a href=&quot;#isForwardCheckingSupported()&quot;&gt;&lt;code&gt;isForwardCheckingSupported&lt;/code&gt;&lt;/a&gt; method indicates whether forward checking is supported.</source>
          <target state="translated">인증서가 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 에 제공되는 순서 는 순방향 (대상에서 가장 신뢰할 수있는 CA로) 또는 역방향 (가장 신뢰할 수있는 CA에서 대상으로) 일 수 있습니다. &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 구현 &lt;b&gt;한다&lt;/b&gt; (이 역방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 역방향 확인을 지원하고 &lt;b&gt;있다&lt;/b&gt; (이 순방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 검사 전방지지한다. &lt;a href=&quot;#isForwardCheckingSupported()&quot;&gt; &lt;code&gt;isForwardCheckingSupported&lt;/code&gt; &lt;/a&gt; 방법 방향의 체크가 지원되는지 여부를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="786679264f791da220873f1e88f2073a40d4300a" translate="yes" xml:space="preserve">
          <source>The order in which the certificates are presented to the &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; may be either in the forward direction (from target to most-trusted CA) or in the reverse direction (from most-trusted CA to target). A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; implementation &lt;b&gt;must&lt;/b&gt; support reverse checking (the ability to perform its checks when it is presented with certificates in the reverse direction) and &lt;b&gt;may&lt;/b&gt; support forward checking (the ability to perform its checks when it is presented with certificates in the forward direction). The &lt;a href=&quot;pkixcertpathchecker#isForwardCheckingSupported--&quot;&gt;&lt;code&gt;isForwardCheckingSupported&lt;/code&gt;&lt;/a&gt; method indicates whether forward checking is supported.</source>
          <target state="translated">인증서가 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 에 제공되는 순서 는 정방향 (대상에서 가장 신뢰할 수있는 CA로) 또는 역방향 (가장 신뢰할 수있는 CA에서 대상으로) 일 수 있습니다. &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 구현 &lt;b&gt;한다&lt;/b&gt; (이 역방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 역방향 확인을 지원하고 &lt;b&gt;있다&lt;/b&gt; (이 순방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 검사 전방지지한다. &lt;a href=&quot;pkixcertpathchecker#isForwardCheckingSupported--&quot;&gt; &lt;code&gt;isForwardCheckingSupported&lt;/code&gt; &lt;/a&gt; 방법 방향의 체크가 지원되는지 여부를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="d2f8d57b1d164c84e4b4ac092f45d02503e996db" translate="yes" xml:space="preserve">
          <source>The order of Catalogs in the returned stream is the same as the order in which the corresponding &lt;code&gt;nextCatalog&lt;/code&gt; entries appear in the current catalog. The alternative catalogs from the input file list are appended to the end of the stream in the order they are entered.</source>
          <target state="translated">리턴 된 스트림의 카탈로그 순서 는 현재 카탈로그에 해당 &lt;code&gt;nextCatalog&lt;/code&gt; 항목이 나타나는 순서와 동일 합니다. 입력 파일 목록의 대체 카탈로그는 입력 된 순서대로 스트림 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3b0a1444d580fbd23f88a9b291fb618ecf7e54" translate="yes" xml:space="preserve">
          <source>The order of MBeans in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt; is significant. For any two MBeans &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;, &lt;em&gt;X&lt;/em&gt; must appear before &lt;em&gt;Y&lt;/em&gt; if the registration of &lt;em&gt;X&lt;/em&gt; was completed before the registration of &lt;em&gt;Y&lt;/em&gt; started. If &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; were registered concurrently, their order is indeterminate. The registration of an MBean corresponds to the call to &lt;a href=&quot;../mbeanserver#registerMBean(java.lang.Object,javax.management.ObjectName)&quot;&gt;&lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt;&lt;/a&gt; or one of the &lt;a href=&quot;../mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.createMBean&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에서 MBean의 순서 는 중요합니다. 두 MBean의 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;Y&lt;/em&gt; 에서 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에 , &lt;em&gt;X는&lt;/em&gt; 이전에 나타나야 &lt;em&gt;Y&lt;/em&gt; 의 등록하면 &lt;em&gt;X가&lt;/em&gt; 의 등록 이전에 완료 &lt;em&gt;Y는&lt;/em&gt; 시작했다. &lt;em&gt;X&lt;/em&gt; 와 &lt;em&gt;Y&lt;/em&gt; 가 동시에 등록 된 경우 순서는 확정되지 않습니다. MBean 등록은 &lt;a href=&quot;../mbeanserver#registerMBean(java.lang.Object,javax.management.ObjectName)&quot;&gt; &lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.createMBean&lt;/code&gt; 메소드 중 하나에 대한 호출에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="3007914f7a4138270cf5fa55368f3ef46fd6ca3f" translate="yes" xml:space="preserve">
          <source>The order of MBeans in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt; is significant. For any two MBeans &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;, &lt;em&gt;X&lt;/em&gt; must appear before &lt;em&gt;Y&lt;/em&gt; if the registration of &lt;em&gt;X&lt;/em&gt; was completed before the registration of &lt;em&gt;Y&lt;/em&gt; started. If &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; were registered concurrently, their order is indeterminate. The registration of an MBean corresponds to the call to &lt;a href=&quot;../mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt;&lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt;&lt;/a&gt; or one of the &lt;a href=&quot;../mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.createMBean&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;ClassLoaderRepository&lt;/code&gt; 의 MBean 순서 는 중요합니다. 두 MBean의 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;Y&lt;/em&gt; 에서 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에 , &lt;em&gt;X는&lt;/em&gt; 이전에 나타나야 &lt;em&gt;Y&lt;/em&gt; 의 등록하면 &lt;em&gt;X가&lt;/em&gt; 의 등록 이전에 완료 &lt;em&gt;Y는&lt;/em&gt; 시작했다. &lt;em&gt;X&lt;/em&gt; 와 &lt;em&gt;Y&lt;/em&gt; 가 동시에 등록 된 경우 순서가 불확실합니다. MBean 등록은 &lt;a href=&quot;../mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt; &lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.createMBean&lt;/code&gt; 중 하나에 대한 호출에 해당합니다. 메소드 합니다.</target>
        </trans-unit>
        <trans-unit id="69b59e9b859e1a5e657654408c45f91692763d5e" translate="yes" xml:space="preserve">
          <source>The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. For predictable results, the accumulator function should be associative and commutative. The function is applied with an existing value (or identity) as one argument, and a given update as the other argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;
 Long::max&lt;/code&gt; along with &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; as the identity.</source>
          <target state="translated">스레드 내 또는 스레드 간의 누적 순서는 보장되지 않으며 의존 할 수 없으므로이 클래스는 누적 순서가 중요하지 않은 함수에만 적용됩니다. 제공된 누산기 함수는 스레드 간의 경합으로 인해 업데이트 시도가 실패 할 때 다시 적용될 수 있으므로 부작용이 없어야합니다. 예측 가능한 결과를 위해 누산기 함수는 연관 및 교환이어야합니다. 함수는 기존 값 (또는 ID)을 하나의 인수로 적용하고 주어진 업데이트를 다른 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하려면 &lt;code&gt; Long::max&lt;/code&gt; 와 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 를 ID로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6726bce2cabc5276351a481e6e10cf57a7fb4a23" translate="yes" xml:space="preserve">
          <source>The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Long::max&lt;/code&gt; along with &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; as the identity.</source>
          <target state="translated">스레드 내에서 또는 스레드 간 누적 순서는 보장되지 않으며 의존 할 수 없으므로이 클래스는 누적 순서가 중요하지 않은 함수에만 적용 할 수 있습니다. 제공된 누산기 기능은 부작용이 없어야합니다. 스레드 간의 경합으로 인해 업데이트 시도가 실패하면 다시 적용될 수 있습니다. 이 함수는 현재 값을 첫 번째 인수로, 지정된 업데이트를 두 번째 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하기 위해 &lt;code&gt;Long::max&lt;/code&gt; 와 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 를 제공 할 수 있습니다. ID로 있습니다.</target>
        </trans-unit>
        <trans-unit id="85066ede09274b9f9c61cffaf82980ac01b16326" translate="yes" xml:space="preserve">
          <source>The order of attributes in the list is unspecified, and will vary from implementation to implementation.</source>
          <target state="translated">목록의 속성 순서는 지정되지 않으며 구현마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ec494cb7fce413a23ae1b9813822d9a7c9181642" translate="yes" xml:space="preserve">
          <source>The order of elements in the list is the same as the order of the provided arguments, or of the elements in the provided array.</source>
          <target state="translated">목록의 요소 순서는 제공된 인수 또는 제공된 배열의 요소 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c8d2c884b5e85c4c029c8b772764cc9802c52974" translate="yes" xml:space="preserve">
          <source>The order of events in this interface is very important, and mirrors the order of information in the document itself. For example, all of an element's content (character data, processing instructions, and/or subelements) will appear, in order, between the startElement event and the corresponding endElement event.</source>
          <target state="translated">이 인터페이스의 이벤트 순서는 매우 중요하며 문서 자체의 정보 순서를 반영합니다. 예를 들어 모든 요소의 콘텐츠 (문자 데이터, 처리 명령 및 / 또는 하위 요소)는 startElement 이벤트와 해당 endElement 이벤트 사이에 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9ec7a44975564e560e5ebfd67d34b556640a1ec3" translate="yes" xml:space="preserve">
          <source>The order of the color indices is specified by the &lt;code&gt;ColorSpace&lt;/code&gt;. Typically, this reflects the name of the color space type (for example, TYPE_RGB), index 0 corresponds to red, index 1 to green, and index 2 to blue.</source>
          <target state="translated">색 인덱스의 순서는 &lt;code&gt;ColorSpace&lt;/code&gt; 에 의해 지정됩니다 . 일반적으로 이것은 색 공간 유형의 이름 (예 : TYPE_RGB)을 반영하고 인덱스 0은 빨간색, 인덱스 1은 녹색, 인덱스 2는 파란색에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e39109fa74536dbd205739a657a79c8c946a6365" translate="yes" xml:space="preserve">
          <source>The order of the list specifies the preference order of the client or server. An implementation should allow configuration of the meaning of these values. An application may use the Java Cryptography Extension (JCE) with JCE-aware mechanisms to control the selection of cipher suites that match the strength values.</source>
          <target state="translated">목록의 순서는 클라이언트 또는 서버의 기본 설정 순서를 지정합니다. 구현시 이러한 값의 의미를 구성 할 수 있어야합니다. 애플리케이션은 JCE 인식 메커니즘과 함께 JCE (Java Cryptography Extension)를 사용하여 강도 값과 일치하는 암호 스위트 선택을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7e2a675c70b61b722a61131dcca11cbc86fea1" translate="yes" xml:space="preserve">
          <source>The order of the list specifies the preference order of the client or server. If this property is absent, the default qop is &lt;code&gt;&quot;auth&quot;&lt;/code&gt;. The value of this constant is &lt;code&gt;&quot;javax.security.sasl.qop&quot;&lt;/code&gt;.</source>
          <target state="translated">목록의 순서는 클라이언트 또는 서버의 기본 설정 순서를 지정합니다. 이 특성이 없으면 기본 qop는 &lt;code&gt;&quot;auth&quot;&lt;/code&gt; 입니다. 이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.qop&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f55568d5954bb088575a4a35d0388cb5151097fe" translate="yes" xml:space="preserve">
          <source>The order of transformation is described in &lt;a href=&quot;classfiletransformer&quot;&gt;&lt;code&gt;ClassFileTransformer&lt;/code&gt;&lt;/a&gt;. This same order is used in the automatic reapplication of retransformation incapable transforms.</source>
          <target state="translated">변환 순서는 &lt;a href=&quot;classfiletransformer&quot;&gt; &lt;code&gt;ClassFileTransformer&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다. 이 동일한 순서는 재 변환 불가능 변환의 자동 재 적용에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f586d409022fb2da015fb1af6296fa734a0d31fd" translate="yes" xml:space="preserve">
          <source>The order of transformation is described in the &lt;a href=&quot;classfiletransformer#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; method. This same order is used in the automatic reapplication of retransformation incapable transforms.</source>
          <target state="translated">변환 순서는 &lt;a href=&quot;classfiletransformer#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; 방법에 설명되어 있습니다. 동일한 순서가 재 변환 불가능 변환의 자동 재 적용에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b636074ef1a5a271212dd8309cd64648a786776" translate="yes" xml:space="preserve">
          <source>The order of views relative to the model is up to the implementation. Although child views will typically be arranged in the same order that they occur in the model, they may be visually arranged in an entirely different order. View implementations may have Z-Order associated with them if the children are overlapping.</source>
          <target state="translated">모델과 관련된 뷰의 순서는 구현에 달려 있습니다. 일반적으로 하위 뷰는 모델에서 발생하는 순서와 동일한 순서로 배열되지만 시각적으로 완전히 다른 순서로 배열 될 수 있습니다. 뷰 구현에는 자식이 겹치는 경우 Z-Order가 연결되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="218227e103dee75adf30e33cccee9cc838d6df1c" translate="yes" xml:space="preserve">
          <source>The ordering imposed by a comparator &lt;code&gt;c&lt;/code&gt; on a set of elements &lt;code&gt;S&lt;/code&gt; is said to be</source>
          <target state="translated">요소 집합 &lt;code&gt;S&lt;/code&gt; 에 비교기 &lt;code&gt;c&lt;/code&gt; 에 의해 부과 된 순서 는</target>
        </trans-unit>
        <trans-unit id="35ceedf75591c16657215454c74762f532506371" translate="yes" xml:space="preserve">
          <source>The ordering is based on the order that the class loader's &lt;code&gt;
   getResources&lt;/code&gt; method finds the service configuration files and within that, the order that the class names are listed in the file.</source>
          <target state="translated">순서는 클래스 로더의 &lt;code&gt; getResources&lt;/code&gt; 메소드가 서비스 구성 파일을 찾는 순서와 그 안에서 클래스 이름이 파일에 나열되는 순서를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="fa90a160007f418563c4b70e7a41641e8b8af99c" translate="yes" xml:space="preserve">
          <source>The ordering of URIs is defined as follows:</source>
          <target state="translated">URI의 순서는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="10e213727ab1efb66ce40fdac2f168fd5ab6e836" translate="yes" xml:space="preserve">
          <source>The ordering of cards is determined by the container's own internal ordering of its component objects. &lt;code&gt;CardLayout&lt;/code&gt; defines a set of methods that allow an application to flip through these cards sequentially, or to show a specified card. The &lt;a href=&quot;#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;addLayoutComponent(java.awt.Component, java.lang.Object)&lt;/code&gt;&lt;/a&gt; method can be used to associate a string identifier with a given card for fast random access.</source>
          <target state="translated">카드의 순서는 구성 요소 개체의 컨테이너 자체 내부 순서에 의해 결정됩니다. &lt;code&gt;CardLayout&lt;/code&gt; 은 애플리케이션이 이러한 카드를 순차적으로 넘기거나 지정된 카드를 표시 할 수 있도록하는 일련의 메서드를 정의합니다. &lt;a href=&quot;#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;addLayoutComponent(java.awt.Component, java.lang.Object)&lt;/code&gt; &lt;/a&gt; 방법은 빠른 랜덤 액세스에 대해 주어진 카드 문자열 식별자를 연결하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d740108fcacd8b33f949d001977d3ba5521ae114" translate="yes" xml:space="preserve">
          <source>The ordering of lock reacquisition for threads returning from waiting methods is the same as for threads initially acquiring the lock, which is in the default case not specified, but for &lt;em&gt;fair&lt;/em&gt; locks favors those threads that have been waiting the longest.</source>
          <target state="translated">대기 메소드에서 리턴하는 스레드에 대한 잠금 재 취득 순서는 기본적으로 지정되지 않은 초기 잠금을 획득하는 스레드의 순서와 동일하지만 &lt;em&gt;공정&lt;/em&gt; 잠금의 경우 가장 오래 기다린 스레드를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="ebe3338db3779264959a01c896fab9cc8151a384" translate="yes" xml:space="preserve">
          <source>The ordering of modules in a module layer is not defined.</source>
          <target state="translated">모듈 계층의 모듈 순서는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2d4dae6bc907437ac679c9f1928886b7eb910aa2" translate="yes" xml:space="preserve">
          <source>The ordering of side-effects may be surprising. Even when a pipeline is constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream source (for example, &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; must produce &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt;), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</source>
          <target state="translated">부작용의 순서는 놀랍습니다. 파이프 라인이 스트림 소스의 발생 순서와 일치 하는 &lt;em&gt;결과&lt;/em&gt; 를 생성하도록 제한되어있는 경우에도 (예 : &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; 는 &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt; )을 생성해야 하며, 매퍼 함수가 개별 요소에 적용되는 순서 또는 특정 요소에 대해 실행되는 동작 매개 변수가 어떤 스레드에서 실행되는지에 대해서는 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c351a0d0a5c5fd7fc6873693e09a2f6e8d0c8198" translate="yes" xml:space="preserve">
          <source>The ordering will be used by the &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">순서는 &lt;code&gt;useOrdering&lt;/code&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 일 때 &lt;code&gt;getServiceProviders&lt;/code&gt; 메소드에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="828902195e00ef436aff70e49094916ecb581eee" translate="yes" xml:space="preserve">
          <source>The orientations are:</source>
          <target state="translated">방향은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2fbbc68a36c3656118ddcba9b24016a519952e2" translate="yes" xml:space="preserve">
          <source>The origin and dimensions are the same.</source>
          <target state="translated">원점과 치수는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="81d54722d0f9366f127e5a540eef57cf4be51315" translate="yes" xml:space="preserve">
          <source>The origin is at the bottom left of the paper with x running bottom to top and y running left to right.</source>
          <target state="translated">원점은 용지의 왼쪽 하단에 있으며 x는 아래에서 위로, y는 왼쪽에서 오른쪽으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="34aadd941b0e6c46830a2cf7051a8e604ce18ba2" translate="yes" xml:space="preserve">
          <source>The origin is at the bottom left of the paper with x running bottom to top and y running left to right. Note that this is not the Macintosh landscape but is the Window's and PostScript landscape.</source>
          <target state="translated">원점은 용지의 왼쪽 하단에 있으며 x는 아래에서 위로, y는 왼쪽에서 오른쪽으로 이어집니다. 이것은 매킨토시 풍경이 아니라 윈도우와 포스트 스크립트 풍경입니다.</target>
        </trans-unit>
        <trans-unit id="c72397f47fc72fd8faede6be39606ce7c37d8165" translate="yes" xml:space="preserve">
          <source>The origin is at the top left of the paper with x running to the right and y running down the paper.</source>
          <target state="translated">원점은 용지의 왼쪽 상단에 있으며 x는 오른쪽으로, y는 용지 아래로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="eb105468c81962a0b3b369302414b0041b7e6d52" translate="yes" xml:space="preserve">
          <source>The origin is at the top right of the paper with x running top to bottom and y running right to left.</source>
          <target state="translated">원점은 용지의 오른쪽 상단에 있으며 x는 위에서 아래로, y는 오른쪽에서 왼쪽으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="b915e1ffee25bb4cdc2df24182c61b8d2216ac89" translate="yes" xml:space="preserve">
          <source>The origin is at the top right of the paper with x running top to bottom and y running right to left. Note that this is the Macintosh landscape.</source>
          <target state="translated">원점은 용지의 오른쪽 상단에 있으며 x는 위에서 아래로, y는 오른쪽에서 왼쪽으로 이어집니다. 이것은 매킨토시 풍경입니다.</target>
        </trans-unit>
        <trans-unit id="e8ca3c4aef86396c5b74dd72923a67612e1f1e7b" translate="yes" xml:space="preserve">
          <source>The origin of the graphics context, its (&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;) coordinate point, is the top-left corner of this component. The clipping region of the graphics context is the bounding rectangle of this component.</source>
          <target state="translated">그래픽 컨텍스트의 원점 인 ( &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; ) 좌표 점은이 구성 요소의 왼쪽 상단 모서리입니다. 그래픽 컨텍스트의 클리핑 영역은이 구성 요소의 경계 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="e0ce8e8ef1bf8c243508ecd5bf030b1224183b7e" translate="yes" xml:space="preserve">
          <source>The origin point.</source>
          <target state="translated">원점.</target>
        </trans-unit>
        <trans-unit id="0a55863e7f795e02d36c068a0988bdb81b7439eb" translate="yes" xml:space="preserve">
          <source>The original Java type of this element as it appeared in the &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt; interface method that produced this &lt;code&gt;
 MBeanAttributeInfo&lt;/code&gt; (etc). For example, a method</source>
          <target state="translated">이 &lt;code&gt; MBeanAttributeInfo&lt;/code&gt; (etc) 를 생성 한 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 인터페이스 메소드에 나타난이 요소의 원래 Java 유형 . 예를 들어, 방법</target>
        </trans-unit>
        <trans-unit id="03642eebd1c6e8a163c4a73ff3af624d3fa4e141" translate="yes" xml:space="preserve">
          <source>The original Java type of this element as it appeared in the &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt; interface method that produced this &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; (etc). For example, a method</source>
          <target state="translated">이 &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; 를 생성 한 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 인터페이스 메소드에 나타난이 요소의 원래 Java 유형 등 . 예를 들어, 방법</target>
        </trans-unit>
        <trans-unit id="1bb7eb8c45dbc81d8fd70bf5884b22ccd1f62cb9" translate="yes" xml:space="preserve">
          <source>The original object that was sealed can be recovered in two different ways:</source>
          <target state="translated">봉인 된 원본 개체는 두 가지 방법으로 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b954e893a1f95170dfb211c586d111b9c39c9144" translate="yes" xml:space="preserve">
          <source>The original raw name.</source>
          <target state="translated">원래의 원시 이름.</target>
        </trans-unit>
        <trans-unit id="1e848f08eb459ca9bd9f3d3751f204b11ef04d87" translate="yes" xml:space="preserve">
          <source>The original value for a &lt;code&gt;RowSet&lt;/code&gt; object is the value it had before the last synchronization with the underlying data source. If there have been no synchronizations, the original value will be the value with which the &lt;code&gt;RowSet&lt;/code&gt; object was populated. This method is called internally when an application calls the method &lt;code&gt;acceptChanges&lt;/code&gt; and the &lt;code&gt;SyncProvider&lt;/code&gt; object has been implemented to check for conflicts. If this is the case, the writer compares the original value with the value currently in the data source to check for conflicts.</source>
          <target state="translated">&lt;code&gt;RowSet&lt;/code&gt; 개체 의 원래 값 은 기본 데이터 소스와의 마지막 동기화 이전에 있었던 값입니다. 동기화가없는 경우 원래 값은 &lt;code&gt;RowSet&lt;/code&gt; 개체가 채워진 값이됩니다 . 이 메서드는 응용 프로그램이 &lt;code&gt;acceptChanges&lt;/code&gt; 메서드를 호출 하고 &lt;code&gt;SyncProvider&lt;/code&gt; 개체가 충돌을 확인하기 위해 구현 된 경우 내부적으로 호출 됩니다. 이 경우 작성기는 원래 값을 현재 데이터 소스에있는 값과 비교하여 충돌을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bd50ee8db6416b8715b2e6cbee3cc76bfde62e5b" translate="yes" xml:space="preserve">
          <source>The original version.</source>
          <target state="translated">원래 버전.</target>
        </trans-unit>
        <trans-unit id="506f78a81958986cbe8e40931c749b16889f1e47" translate="yes" xml:space="preserve">
          <source>The original version. The language described in</source>
          <target state="translated">원본 버전. 에 설명 된 언어</target>
        </trans-unit>
        <trans-unit id="9d75d36090eb242306d69c88b761090a66976467" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치 방법에 따라 작동합니다 . 이 경우 오프셋은 계산의 일부가 아니므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e747f59a3b61038baf891aa64aa8fe5a1fd4ec43" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. The zone is not part of the calculation and will be unchanged. When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치 방법에 따라 작동합니다 . 영역은 계산의 일부가 아니며 변경되지 않습니다. &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환 할 때 로컬 날짜-시간이 겹치는 경우 오프셋은 가능하면 유지되고 그렇지 않으면 이전 오프셋이 사용됩니다. 간격이있는 경우 로컬 날짜-시간은 간격의 길이만큼 앞으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="3bcf7353bed6c5b27e8d630d4c511ddeea17f3d5" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; LocalTime}. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; LocalTime} 의 일치 방법에 따라 작동합니다 . 이 경우 오프셋은 계산의 일부가 아니므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b3f2a40bb0908a20b25677701f7f3b90d224d0" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치하는 메소드에 따라 작동합니다 . 이 경우 오프셋은 계산에 포함되지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68ee463661f375d777c74d840458ef8c9dd98143" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; LocalTime}. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; LocalTime} 에서 일치하는 방법에 따라 동작합니다 . 이 경우 오프셋은 계산에 포함되지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="485d2eb713590b6bb807248ee4372d5241f39e32" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. The zone is not part of the calculation and will be unchanged. When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치하는 메소드에 따라 작동합니다 . 영역은 계산의 일부가 아니며 변경되지 않습니다. &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환 할 때 로컬 날짜-시간이 겹치는 경우 가능한 경우 오프셋이 유지되고, 그렇지 않으면 이전 오프셋이 사용됩니다. 간격이 있으면 현지 날짜-시간이 간격의 길이만큼 앞으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="731e6c57f9e5ae4ccf59a456cb37bb4538303681" translate="yes" xml:space="preserve">
          <source>The other approach initializes a parameter generator object using algorithm-specific semantics, which are represented by a set of algorithm-specific parameter generation values. To generate Diffie-Hellman system parameters, for example, the parameter generation values usually consist of the size of the prime modulus and the size of the random exponent, both specified in number of bits.</source>
          <target state="translated">다른 접근 방식은 알고리즘 별 시맨틱을 사용하여 매개 변수 생성기 객체를 초기화하며, 이는 알고리즘 별 매개 변수 생성 값 세트로 표시됩니다. 예를 들어, Diffie-Hellman 시스템 매개 변수를 생성하기 위해 매개 변수 생성 값은 일반적으로 비트 수로 지정된 소수 지수와 랜덤 지수의 크기로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="55d2cad5bd07439d3de3adc5deca101f2c106f10" translate="yes" xml:space="preserve">
          <source>The other syntaxes defined by RFC 2609 are not currently supported by this class.</source>
          <target state="translated">RFC 2609에 의해 정의 된 다른 구문은 현재이 클래스에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4fd3d8cfa50630b0e53099a212e26fef3d644784" translate="yes" xml:space="preserve">
          <source>The other techniques all use the following approach: if the &lt;code&gt;java.rmi.server.ignoreStubClasses&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt; (case insensitive) or if a static stub cannot be found, stubs are generated dynamically using &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; objects. Otherwise, static stubs are used.</source>
          <target state="translated">다른 기술은 모두 다음 접근 방식을 사용합니다. &lt;code&gt;java.rmi.server.ignoreStubClasses&lt;/code&gt; 속성이 &lt;code&gt;true&lt;/code&gt; (대소 문자 구분 안 함)이거나 정적 스텁을 찾을 수없는 경우 &lt;a href=&quot;../../../../java.base/java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 개체를 사용하여 스텁이 동적으로 생성 됩니다. 그렇지 않으면 정적 스텁이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f670b4981f0a114b5c79dad80bac9bc5c125b90" translate="yes" xml:space="preserve">
          <source>The other type of pairs consists of those that create Java language Bindings, the values are usually represented in scripts by the corresponding keys or by decorated forms of them.</source>
          <target state="translated">다른 유형의 쌍은 Java 언어 바인딩을 작성하는 쌍으로 구성되며, 값은 일반적으로 해당 키 또는 장식 된 형식으로 스크립트에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57d3406bf2a697594830c4ab80c8c1b86765dcee" translate="yes" xml:space="preserve">
          <source>The other version of the &lt;code&gt;acceptChanges&lt;/code&gt; method is not passed a connection because it uses the &lt;code&gt;Connection&lt;/code&gt; object already defined within the &lt;code&gt;RowSet&lt;/code&gt; object, which is the connection used for populating it initially.</source>
          <target state="translated">&lt;code&gt;acceptChanges&lt;/code&gt; 메소드 의 다른 버전은 처음에이를 채우는 데 사용되는 연결 인 &lt;code&gt;RowSet&lt;/code&gt; 오브젝트 내에 이미 정의 된 &lt;code&gt;Connection&lt;/code&gt; 오브젝트를 사용하기 때문에 연결이 전달되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5b004cd696742da98b715116f439633a968fa96c" translate="yes" xml:space="preserve">
          <source>The other way to create a thread is to declare a class that implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can then be allocated, passed as an argument when creating &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other style looks like the following:</source>
          <target state="translated">스레드를 작성하는 다른 방법은 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스 를 구현하는 클래스를 선언하는 것 입니다. 그런 다음 해당 클래스는 &lt;code&gt;run&lt;/code&gt; 을 구현합니다. 메소드 . 그런 다음 클래스의 인스턴스를 할당하고 &lt;code&gt;Thread&lt;/code&gt; 를 만들 때 인수로 전달한 다음 시작할 수 있습니다. 이 다른 스타일의 동일한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="583eff28c5b619ca29d9ec50a582a7ac4826c09b" translate="yes" xml:space="preserve">
          <source>The outer range is &lt;code&gt;minimum,maximum&lt;/code&gt; and the inner range is &lt;code&gt;value,value+extent&lt;/code&gt;. The inner range must lie within the outer one, i.e. &lt;code&gt;value&lt;/code&gt; must be less than or equal to &lt;code&gt;maximum&lt;/code&gt; and &lt;code&gt;value+extent&lt;/code&gt; must greater than or equal to &lt;code&gt;minimum&lt;/code&gt;, and &lt;code&gt;maximum&lt;/code&gt; must be greater than or equal to &lt;code&gt;minimum&lt;/code&gt;. There are a few features of this model that one might find a little surprising. These quirks exist for the convenience of the Swing BoundedRangeModel clients, such as &lt;code&gt;Slider&lt;/code&gt; and &lt;code&gt;ScrollBar&lt;/code&gt;.</source>
          <target state="translated">외부 범위는 &lt;code&gt;minimum,maximum&lt;/code&gt; 이고 내부 범위는 &lt;code&gt;value,value+extent&lt;/code&gt; 입니다. 외측 하나에 내부 범위 필수 거짓말 즉 &lt;code&gt;value&lt;/code&gt; 미만이거나 동일해야 &lt;code&gt;maximum&lt;/code&gt; 및 &lt;code&gt;value+extent&lt;/code&gt; 보다 반드시 더 크거나 같은 &lt;code&gt;minimum&lt;/code&gt; 및 &lt;code&gt;maximum&lt;/code&gt; 보다 크거나 동일해야 &lt;code&gt;minimum&lt;/code&gt; . 이 모델에는 약간 놀라운 점이 몇 가지 있습니다. 이러한 단점은 &lt;code&gt;Slider&lt;/code&gt; 및 &lt;code&gt;ScrollBar&lt;/code&gt; 와 같은 Swing BoundedRangeModel 클라이언트의 편의를 위해 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="f2bff297e85d996a4c78e24eb08ae10d924ada6b" translate="yes" xml:space="preserve">
          <source>The outline of the &lt;code&gt;Shape&lt;/code&gt; is extracted using the &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform)&quot;&gt;&lt;code&gt;getPathIterator&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Shape&lt;/code&gt;, which returns a &lt;a href=&quot;geom/pathiterator&quot;&gt;&lt;code&gt;PathIterator&lt;/code&gt;&lt;/a&gt; object that iterates along the boundary of the &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">의 윤곽 &lt;code&gt;Shape&lt;/code&gt; 은 USING 추출 &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform)&quot;&gt; &lt;code&gt;getPathIterator&lt;/code&gt; 의&lt;/a&gt; 방법 &lt;code&gt;Shape&lt;/code&gt; 반환 &lt;a href=&quot;geom/pathiterator&quot;&gt; &lt;code&gt;PathIterator&lt;/code&gt; &lt;/a&gt; 오브젝트를 그 경계를 따라 반복 &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c8adc64c31daab6de1a7235e69f69308c772876" translate="yes" xml:space="preserve">
          <source>The output IO stream is buffered, but is flushed after each &lt;code&gt;LogRecord&lt;/code&gt; is written.</source>
          <target state="translated">출력 IO 스트림은 버퍼링되지만 각각 후에 플러시됩니다. &lt;code&gt;LogRecord&lt;/code&gt; 가 작성된 됩니다.</target>
        </trans-unit>
        <trans-unit id="26459ea2edbcfd100c25cd1785eb8ab10711495d" translate="yes" xml:space="preserve">
          <source>The output device is marking media.</source>
          <target state="translated">출력 장치가 미디어를 표시하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eca022c3bb2070b54c1b4b8f2c8671145a20cab" translate="yes" xml:space="preserve">
          <source>The output device is marking media. This value is useful for printers which spend a great deal of time processing (1) when no marking is happening and then want to show that marking is now happening or (2) when the job is in the process of being canceled or aborted while the job remains in the &lt;code&gt;PROCESSING&lt;/code&gt; state, but the marking has not yet stopped so that impression or sheet counts are still increasing for the job.</source>
          <target state="translated">출력 장치가 미디어를 표시하고 있습니다. 이 값은 처리하는 데 많은 시간을 소비하는 프린터에 유용합니다. 작업은 &lt;code&gt;PROCESSING&lt;/code&gt; 상태로 유지 되지만 마킹이 아직 중지되지 않았으므로 작업에 대한 임프레션 또는 시트 수가 계속 증가합니다.</target>
        </trans-unit>
        <trans-unit id="84e58d292a5274ac7143c456712868ef9a668dc0" translate="yes" xml:space="preserve">
          <source>The output device is marking media. This value is useful for printers which spend a great deal of time processing (1) when no marking is happening and then want to show that marking is now happening or (2) when the job is in the process of being canceled or aborted while the job remains in the PROCESSING state, but the marking has not yet stopped so that impression or sheet counts are still increasing for the job.</source>
          <target state="translated">출력 장치가 미디어를 표시하고 있습니다. 이 값은 (1) 마킹이 발생하지 않았을 때 마킹이 진행 중이거나 (2) 작업이 취소 또는 중단되는 중일 때 표시하는 데 많은 시간을 소비하는 프린터에 유용합니다. 작업이 처리 중 상태로 유지되지만 표시가 아직 중지되지 않아 작업에 대한 인상 또는 시트 수가 계속 증가합니다.</target>
        </trans-unit>
        <trans-unit id="688afe174c47eb9329383daa0efbfa513f94d552" translate="yes" xml:space="preserve">
          <source>The output is right-justified within the &lt;code&gt;width&lt;/code&gt;</source>
          <target state="translated">출력은 &lt;code&gt;width&lt;/code&gt; 내에서 오른쪽으로 정렬됩니다</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="804ab937140ab8aceea397468da48794c9e5c156" translate="yes" xml:space="preserve">
          <source>The output must have been set beforehand using either the &lt;code&gt;setOutput&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;setOutput&lt;/code&gt; 메소드를 사용하여 출력을 미리 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5834d251964586e73d7e57cd4080802c92b44a58" translate="yes" xml:space="preserve">
          <source>The output must have been set beforehand using the &lt;code&gt;setOutput&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;setOutput&lt;/code&gt; 메소드를 사용하여 출력을 미리 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f7bcdd198ccdce248e7f31e3c4dc8fb9ab43140" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling &lt;a href=&quot;#optionalStart()&quot;&gt;&lt;code&gt;optionalStart()&lt;/code&gt;&lt;/a&gt; and ended using this method (or at the end of the builder).</source>
          <target state="translated">서식 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은 &lt;a href=&quot;#optionalStart()&quot;&gt; &lt;code&gt;optionalStart()&lt;/code&gt; &lt;/a&gt; 를 호출하여 시작 되고이 메소드를 사용하여 종료됩니다 (또는 빌더의 끝에서).</target>
        </trans-unit>
        <trans-unit id="0c137f9ad4568084e0eada82e7dc19a7e9d63517" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt;&lt;code&gt;optionalStart()&lt;/code&gt;&lt;/a&gt; and ended using this method (or at the end of the builder).</source>
          <target state="translated">서식의 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은 &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt; &lt;code&gt;optionalStart()&lt;/code&gt; &lt;/a&gt; 를 호출하여 시작 되고이 메소드 (또는 빌더의 끝)를 사용하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="30bee059122c0e2413c350a5135e567ef038d6df" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling this method and ended by calling &lt;a href=&quot;#optionalEnd()&quot;&gt;&lt;code&gt;optionalEnd()&lt;/code&gt;&lt;/a&gt; or by ending the build process.</source>
          <target state="translated">서식 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은이 메서드를 호출하여 시작되고 &lt;a href=&quot;#optionalEnd()&quot;&gt; &lt;code&gt;optionalEnd()&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 빌드 프로세스를 종료하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4ace7699a2d9bc0b73e1579908c8e14ceff6a861" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling this method and ended by calling &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt;&lt;code&gt;optionalEnd()&lt;/code&gt;&lt;/a&gt; or by ending the build process.</source>
          <target state="translated">서식의 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은이 메소드를 호출하여 시작하고 &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt; &lt;code&gt;optionalEnd()&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 빌드 프로세스를 종료하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b15ced407c23c236dd27a5b8940ab033961526" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a custom mapped user-defined type (UDT) back to the database. The driver uses this interface internally, and its methods are never directly invoked by an application programmer.</source>
          <target state="translated">사용자 지정 매핑 된 사용자 정의 형식 (UDT)의 특성을 다시 데이터베이스에 쓰기위한 출력 스트림입니다. 드라이버는이 인터페이스를 내부적으로 사용하며 해당 메서드는 응용 프로그램 프로그래머가 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2644bde300cd9bee2aafe476022bed0d8f7f809" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a custom-mapped user-defined type (UDT) back to the database.</source>
          <target state="translated">사용자 지정 매핑 된 UDT (사용자 정의 형식)의 특성을 다시 데이터베이스에 쓰기위한 출력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="5291fc4ff823e118140880807207e4a84cdb270e" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a custom-mapped user-defined type (UDT) back to the database. The driver uses this interface internally, and its methods are never directly invoked by an application programmer.</source>
          <target state="translated">사용자 지정 매핑 된 UDT (사용자 정의 형식)의 특성을 다시 데이터베이스에 쓰기위한 출력 스트림입니다. 드라이버는이 인터페이스를 내부적으로 사용하며 해당 메서드는 응용 프로그램 프로그래머가 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c5cc4efa6ae535ea715a0ada32fc5dd1b98a681" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a user-defined type back to the database.</source>
          <target state="translated">사용자 정의 유형의 속성을 데이터베이스에 다시 쓰기위한 출력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="bf44ebf553c6d8e04b4e02abdc3300d8ca5d0e43" translate="yes" xml:space="preserve">
          <source>The output stream for writing the attributes of a user-defined type back to the database. This interface, used only for custom mapping, is used by the driver, and its methods are never directly invoked by a programmer.</source>
          <target state="translated">사용자 정의 유형의 속성을 데이터베이스에 다시 쓰기위한 출력 스트림입니다. 사용자 지정 매핑에만 사용되는이 인터페이스는 드라이버에서 사용되며 해당 메서드는 프로그래머가 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c86979c68dfa75a5ea8a4fa4ebc1ad3a84cf42c6" translate="yes" xml:space="preserve">
          <source>The output will be in the ISO-8601 format &lt;code&gt;uuuu-MM-dd&lt;/code&gt;.</source>
          <target state="translated">출력은 ISO-8601 형식 &lt;code&gt;uuuu-MM-dd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b633ef40153b0f7e5fd9c57a4eaf98a09ebc8bd" translate="yes" xml:space="preserve">
          <source>The output will be in the ISO-8601 period format. A zero period will be represented as zero days, 'P0D'.</source>
          <target state="translated">출력은 ISO-8601 기간 형식입니다. 0 기간은 0 일 'P0D'로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="68588c3b93830eb7b05eaa2a32bd88e2e6401d4a" translate="yes" xml:space="preserve">
          <source>The output will be in the format &lt;code&gt;--MM-dd&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;--MM-dd&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="bdf3023f62cba73bbd1a514729bd330ebd38319c" translate="yes" xml:space="preserve">
          <source>The output will be in the format &lt;code&gt;uuuu-MM&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;uuuu-MM&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="dd014c7d6b437b473d734099818c5531d372f334" translate="yes" xml:space="preserve">
          <source>The output will be one of the following ISO-8601 formats:</source>
          <target state="translated">출력은 다음 ISO-8601 형식 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="705acc7715ef6cf8f5d79566a8f63147ba3837f5" translate="yes" xml:space="preserve">
          <source>The output will include the full local date-time.</source>
          <target state="translated">출력에는 전체 현지 날짜-시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2e50f340847768af08514b08ccbbc3cfbeecb6" translate="yes" xml:space="preserve">
          <source>The output will include the full local date.</source>
          <target state="translated">출력에는 전체 현지 날짜가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="569b52322e6eb839ec665dce679a13d3f5ed0afe" translate="yes" xml:space="preserve">
          <source>The output will include the full zoned date-time.</source>
          <target state="translated">출력에는 전체 영역 날짜-시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc58e9e7951c47f5031287fcfab530275c088ee0" translate="yes" xml:space="preserve">
          <source>The output will include the period amounts and chronology.</source>
          <target state="translated">출력에는 기간과 연대기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="234157b711ff9b8171f42b7b203bce27d2d2b18a" translate="yes" xml:space="preserve">
          <source>The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fileCount&lt;/code&gt; 에 다른 값을 가진 출력 :</target>
        </trans-unit>
        <trans-unit id="e695466f61d86736de0f15cfe8d369fc29207abf" translate="yes" xml:space="preserve">
          <source>The outside border.</source>
          <target state="translated">바깥 쪽 경계.</target>
        </trans-unit>
        <trans-unit id="7efda311ebc629dc550cc733ff5c1932095ad7e5" translate="yes" xml:space="preserve">
          <source>The oval covers an area that is &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels wide and &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; pixels tall.</source>
          <target state="translated">타원은 &lt;code&gt;width&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 너비 및 &lt;code&gt;height&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 픽셀 높이 의 영역을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="a40c1fc8cccf601ed7cf89f2562ee058faba7bf0" translate="yes" xml:space="preserve">
          <source>The overall authentication succeeds only if all</source>
          <target state="translated">전체 인증은 모든 경우에만 성공</target>
        </trans-unit>
        <trans-unit id="afc837de431bba096268be7bd23f007fce85a68b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars(int)&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;#append(char%5B%5D)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 정확히 인수가 &lt;a href=&quot;character#toChars(int)&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 되고 해당 배열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(char%5B%5D)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f59ea59df05be113fd52c10e956f63fb5a862338" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars-int-&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;stringbuffer#append-char:A-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;character#toChars-int-&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 인수를 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 한 다음 해당 배열의 문자 를이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-char:A-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be6d5695ee207edc76227a4e67c6ab0ba325ae3c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars-int-&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;stringbuilder#append-char:A-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;character#toChars-int-&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 인수를 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 한 다음 해당 배열의 문자 를이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-char:A-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63d704d3e8a8db51d045134a1bf4500866ab995c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a3d22124f42c4fcc9202445b436eaf6b2b6492d0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c9906a666b00f6a09e068c9e5c534ed752c25f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char)&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(char)&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같고 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="19c75e21f2598dc94c7d1497d11bff7a1f046139" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="310cb9a994c29cdc77dae7305d38d1b15d9afe1f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(float)&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(float)&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1d6aa9e36873bbad4c0d33292b2e0cafa71c5e92" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(int)&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(int)&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8cae7457cdd163d073210668c444483abb9018f0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e107f2f3b6c5daae645f36d7c1aef0539272701e" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf(long)&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf(long)&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 인수가 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="57cba855e92025ba54d5320f086b0dbf8cfec25b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7df0f951a6156117783dfb422bf5ed58fb06623" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="845b434e13a8aaf2c9d866bceb0cd542c9f36bae" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07f151c65ac0110f86fef11dd3f3f19d05c7cbc5" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4fdc466e4bb623ea414c11f74ab2ab2710302ca" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="157765951de65cc003ce1491b4ef26e8c342399d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c95847b7e89b7021cc6b64b5b06284de479600b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e4e8c68ad219b2ca4384b64637aee75cfb33a09" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="047be1cada456ef70fd59c3ee3f044b4b3346662" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5533d40c6ced212dd75bac0fd6a34c6fac9422b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55f999bd369940307c24bebb765ca5b872fb76b7" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b879652398b41d309d1476f2c2e969058129bf6" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27d2cb16c3fe6c766ce861a61273f35f95a4220f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f3315b830429e7a9bc3e205fa95bae92504588c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5885c63fcfaae322b7ea095a9fac9b6f29e099cc" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7336e95827ca7bca837791a580e9cd1b62d7c706" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e1c324e343a3702507d78ac2247b82a2b6c6bd4" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D,int,int)&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#append(java.lang.String)&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전체적인 효과는 인수가 &lt;a href=&quot;string#valueOf(char%5B%5D,int,int)&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환되고 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;#append(java.lang.String)&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="6f590370647a03195ad36ca13c3dafc9d17830de" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="667446b3ce7a38fb13fed317aa887df961ff9edc" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3431e2061cfa7271649a78b90242cab86e4bea3" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="9046f217f1dadf54f1e0afa4a10e802011cf9b14" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(char%5B%5D)&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c3a3f0eefdc6cd0623ccb4427387514024d89d5" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(char)&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(char)&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c70945df54158f189337be144bc0908fcb472348" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(double)&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(double)&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="56b66fbd5988862f4b6fb8d4aa435376a0f89711" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(float)&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(float)&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="245c9230d35217221e075ed545abf2fbc8278dc0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(int)&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(int)&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a313be5db64537c2a2628855eb4e85e00683feb9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(java.lang.Object)&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같고 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="59d643a3df0c9b21da2bb822cd6057390f54e373" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf(long)&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 두 번째 인수가 &lt;a href=&quot;string#valueOf(long)&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 문자열로 변환 된 것과 똑같습니다. 그러면 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;#insert(int,java.lang.String)&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e3ad882f1370e6a19c92030d372ebea043ac08c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7af047a811aea03c7cfb551fb7745eca0c8286b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5d50176eafd06dde20c9510416b4ea1abd05817" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="99669c326a383e25b074e12ce49230f42dee9d3d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="73138bb845b641098da27eae98dd3fcc96960e8a" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c64220b96dbb589d7148353f7e1cfad95e5e608f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="2e313b4e5bbaa022d9225aca73fc6c42986754cf" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="cce5181b8ce0af8aa47d1fcfeb79ba05fe223d1d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="324cc7be6c9dedfbe10fe3f90387bf61ecd27c01" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="db08c56eaebf244ff3142963ce2d28f1d66ab880" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="38951459bdb968fe8d267a2144f2daab8015b7ff" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5fc542b259600a887b19200ae27aaaa00be8b9a0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f58159ca31b8acb9ea067910b0f31bafe22b3cbe" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f522c3927d765d22340b0bebf81d5e0e71e191d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="01523b80576e2b49f83dc67247fbc3f9819c22d9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b87b84c4a13dc2c6e5e702e25ec10a27e27371fe" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="31f8064daed292501f356d518545df44d51455b3" translate="yes" xml:space="preserve">
          <source>The overall effect is that the total size moves that same percentage, k, towards the total minimum or maximum and that percentage guarantees accommodation of the required space, DELTA.</source>
          <target state="translated">전체적인 효과는 전체 크기가 동일한 백분율 k를 총 최소값 또는 최대 값으로 이동하고 해당 백분율이 필요한 공간 DELTA의 수용을 보장한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f770b2501486fad821354a61f138150a2a3b6c92" translate="yes" xml:space="preserve">
          <source>The overall effect is to force all future readers of each call site's target to accept the most recently stored value. (&quot;Most recently&quot; is reckoned relative to the &lt;code&gt;syncAll&lt;/code&gt; itself.) Conversely, the &lt;code&gt;syncAll&lt;/code&gt; call may block until all readers have (somehow) decached all previous versions of each call site's target.</source>
          <target state="translated">전반적인 효과는 각 콜 사이트 대상의 미래의 모든 독자가 가장 최근에 저장된 값을 수락하도록하는 것입니다. ( &quot;가장 최근&quot;은 &lt;code&gt;syncAll&lt;/code&gt; 자체 와 관련하여 계산 됩니다.) 반대로, &lt;code&gt;syncAll&lt;/code&gt; 호출은 모든 독자가 각 호출 사이트 대상의 이전 버전을 모두 캐시 해제 할 때까지 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a597f7fe2186deb83b3832d157681941badccc8" translate="yes" xml:space="preserve">
          <source>The overall height of the &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ellipse2D&lt;/code&gt; 의 전체 높이 입니다 .</target>
        </trans-unit>
        <trans-unit id="c51d680650336bbcd98a1a70650e114d30b07a9f" translate="yes" xml:space="preserve">
          <source>The overall height of the full ellipse of which this arc is a partial section (not considering the angular extents).</source>
          <target state="translated">이 호가 부분 단면 인 전체 타원의 전체 높이입니다 (각도 범위는 고려하지 않음).</target>
        </trans-unit>
        <trans-unit id="08d345304e88691848ec39f0e8e15128680f7442" translate="yes" xml:space="preserve">
          <source>The overall height of this &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Ellipse2D&lt;/code&gt; 의 전체 높이 입니다 .</target>
        </trans-unit>
        <trans-unit id="3870ccb10e3ab8d6ce4a4e513b761343c57f1158" translate="yes" xml:space="preserve">
          <source>The overall orientation of the grid depends on the container's &lt;a href=&quot;componentorientation&quot;&gt;&lt;code&gt;ComponentOrientation&lt;/code&gt;&lt;/a&gt; property. For horizontal left-to-right orientations, grid coordinate (0,0) is in the upper left corner of the container with x increasing to the right and y increasing downward. For horizontal right-to-left orientations, grid coordinate (0,0) is in the upper right corner of the container with x increasing to the left and y increasing downward.</source>
          <target state="translated">그리드의 전체 방향은 컨테이너의 &lt;a href=&quot;componentorientation&quot;&gt; &lt;code&gt;ComponentOrientation&lt;/code&gt; &lt;/a&gt; 속성 에 따라 다릅니다 . 수평 왼쪽에서 오른쪽 방향의 경우 그리드 좌표 (0,0)는 컨테이너의 왼쪽 상단 모서리에 있으며 x는 오른쪽으로 증가하고 y는 아래로 증가합니다. 수평 오른쪽에서 왼쪽 방향의 경우 그리드 좌표 (0,0)는 컨테이너의 오른쪽 위 모서리에 있으며 x는 왼쪽으로 증가하고 y는 아래로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="7129641fb17ee86ae98bd9910e56b0d7e0292b8b" translate="yes" xml:space="preserve">
          <source>The overall width of the full ellipse of which this arc is a partial section (not considering the angular extents).</source>
          <target state="translated">이 호가 부분 단면 인 전체 타원의 전체 폭입니다 (각도 범위는 고려하지 않음).</target>
        </trans-unit>
        <trans-unit id="3fa89a83d7b23289a758aae24c69fb19d0825627" translate="yes" xml:space="preserve">
          <source>The overall width of this &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Ellipse2D&lt;/code&gt; 의 전체 너비 입니다 .</target>
        </trans-unit>
        <trans-unit id="b81d6288655d85e74abf1180320ee72013eb469e" translate="yes" xml:space="preserve">
          <source>The overloads that accept &lt;code&gt;Name&lt;/code&gt; are useful for applications that need to manipulate names: composing them, comparing components, and so on. The overloads that accept string names are likely to be more useful for simple applications, such as those that simply read in a name and look up the corresponding object.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 을 허용하는 오버로드는 이름을 구성하고 구성 요소를 비교하는 등의 이름을 조작해야하는 응용 프로그램에 유용합니다. 문자열 이름을 허용하는 오버로드는 단순히 이름을 읽고 해당 객체를 찾는 것과 같은 간단한 응용 프로그램에 더 유용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f3afd76a6a4ce3c69d50d9e42513b3e98bae449" translate="yes" xml:space="preserve">
          <source>The owner of the clipboard.</source>
          <target state="translated">클립 보드의 소유자입니다.</target>
        </trans-unit>
        <trans-unit id="cf7fb65cedad5b648dd187476b8ae459f6736b04" translate="yes" xml:space="preserve">
          <source>The owner of this decoder.</source>
          <target state="translated">이 디코더의 소유자</target>
        </trans-unit>
        <trans-unit id="960d60a6630ecd199aafa78b55469fbc9767c71b" translate="yes" xml:space="preserve">
          <source>The owner of this encoder.</source>
          <target state="translated">이 인코더의 소유자</target>
        </trans-unit>
        <trans-unit id="fc34151ce94888d998373a80767db73331183bd7" translate="yes" xml:space="preserve">
          <source>The pack engine is initialized to an initial state as described by their properties below. The initial state can be manipulated by getting the engine properties (using &lt;a href=&quot;#properties()&quot;&gt;&lt;code&gt;properties()&lt;/code&gt;&lt;/a&gt;) and storing the modified properties on the map. The resource files will be passed through with no changes at all. The class files will not contain identical bytes, since the unpacker is free to change minor class file features such as constant pool order. However, the class files will be semantically identical, as specified in</source>
          <target state="translated">팩 엔진은 아래 속성에 설명 된대로 초기 상태로 초기화됩니다. 초기 상태는 엔진 속성을 가져오고 ( &lt;a href=&quot;#properties()&quot;&gt; &lt;code&gt;properties()&lt;/code&gt; &lt;/a&gt; 사용하여 ) 수정 된 속성을지도에 저장 하여 조작 할 수 있습니다 . 리소스 파일은 변경없이 전달됩니다. 언 패커는 상수 풀 순서와 같은 부 클래스 파일 기능을 자유롭게 변경할 수 있으므로 클래스 파일에는 동일한 바이트가 포함되지 않습니다. 그러나 클래스 파일은 다음과 같이 의미 상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1f5a4430fc7ac0d6794758f4e8205b46eb2301e9" translate="yes" xml:space="preserve">
          <source>The pack engine is initialized to an initial state as described by their properties below. The initial state can be manipulated by getting the engine properties (using &lt;a href=&quot;pack200.packer#properties--&quot;&gt;&lt;code&gt;properties()&lt;/code&gt;&lt;/a&gt;) and storing the modified properties on the map. The resource files will be passed through with no changes at all. The class files will not contain identical bytes, since the unpacker is free to change minor class file features such as constant pool order. However, the class files will be semantically identical, as specified in</source>
          <target state="translated">팩 엔진은 아래 속성에 설명 된대로 초기 상태로 초기화됩니다. 엔진 속성을 가져오고 ( &lt;a href=&quot;pack200.packer#properties--&quot;&gt; &lt;code&gt;properties()&lt;/code&gt; &lt;/a&gt; ) 수정 된 속성을 맵에 저장하여 초기 상태를 조작 할 수 있습니다 . 리소스 파일은 전혀 변경되지 않고 전달됩니다. 언 패커는 상수 풀 순서와 같은 부 클래스 파일 기능을 자유롭게 변경할 수 있으므로 클래스 파일에는 동일한 바이트가 포함되지 않습니다. 그러나 클래스 파일은 다음과 같이 의미 상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="63b42ec2ae764de42f4fa6aaac0f55d562803652" translate="yes" xml:space="preserve">
          <source>The package and module in which a proxy class is defined is specified &lt;a href=&quot;#membership&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">프록시 클래스가 정의 된 패키지 및 모듈은 다음 &lt;a href=&quot;#membership&quot;&gt;과 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17e0bdff2945c2edfc2026d2ce087b6253e4a1f0" translate="yes" xml:space="preserve">
          <source>The package and module to which a proxy class belongs are chosen such that the accessibility of the proxy class is in line with the accessibility of the proxy interfaces. Specifically, the package and the module membership of a proxy class defined via the &lt;a href=&quot;#getProxyClass(java.lang.ClassLoader,java.lang.Class...)&quot;&gt;&lt;code&gt;getProxyClass(ClassLoader, Class[])&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt;&lt;code&gt;newProxyInstance(ClassLoader, Class[], InvocationHandler)&lt;/code&gt;&lt;/a&gt; methods is specified as follows:</source>
          <target state="translated">프록시 클래스가 속한 패키지 및 모듈은 프록시 클래스의 액세스 가능성이 프록시 인터페이스의 액세스 가능성과 일치하도록 선택됩니다. 특히 &lt;a href=&quot;#getProxyClass(java.lang.ClassLoader,java.lang.Class...)&quot;&gt; &lt;code&gt;getProxyClass(ClassLoader, Class[])&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt; &lt;code&gt;newProxyInstance(ClassLoader, Class[], InvocationHandler)&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 정의 된 프록시 클래스의 패키지 및 모듈 멤버십은 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="cf2c096bf56c3be8d88ff1f521bec6265e7d4dd6" translate="yes" xml:space="preserve">
          <source>The package is not sealed.</source>
          <target state="translated">패키지가 밀봉되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="872f4daa7a794af63f1ae3e925cc2ccdb7956cff" translate="yes" xml:space="preserve">
          <source>The package is sealed with the &lt;a href=&quot;module/modulereference#location()&quot;&gt;module location&lt;/a&gt; as the code source, if known.</source>
          <target state="translated">패키지는 알려진 경우 코드 소스로 &lt;a href=&quot;module/modulereference#location()&quot;&gt;모듈 위치&lt;/a&gt; 로 봉인됩니다 .</target>
        </trans-unit>
        <trans-unit id="fbcd298d448956ef76e9c32f1274449606412ec1" translate="yes" xml:space="preserve">
          <source>The package name</source>
          <target state="translated">패키지 이름</target>
        </trans-unit>
        <trans-unit id="a6f33a2d9b883f2e9494c80ac5a2a02df51ac287" translate="yes" xml:space="preserve">
          <source>The package names that are parameters or returned by methods defined in this class are the fully-qualified names of the packages as defined in section 6.5.3 of</source>
          <target state="translated">매개 변수이거나이 클래스에 정의 된 메서드에 의해 반환되는 패키지 이름은 섹션 6.5.3에 정의 된 패키지의 정규화 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d825e3d7dabee111214c86ef931cdc1b54776a9a" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기로 압축 가능한 압축 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aa7b79f15d60b49360866c20e996ad65f58d66e0" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newPacker()&quot;&gt;&lt;code&gt;Pack200.newPacker()&lt;/code&gt;&lt;/a&gt;. The high degree of compression is achieved by using a number of techniques described in the JSR 200 specification. Some of the techniques are sorting, re-ordering and co-location of the constant pool.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기를 통해 팩 스트림을 압축 할 수 있도록합니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newPacker()&quot;&gt; &lt;code&gt;Pack200.newPacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 . 높은 수준의 압축은 JSR 200 사양에 설명 된 여러 기술을 사용하여 달성됩니다. 기술 중 일부는 상수 풀의 정렬, 재정렬 및 ​​공동 배치입니다.</target>
        </trans-unit>
        <trans-unit id="e60248a43a81f58023b88492a2d08616c29b5dfb" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newPacker--&quot;&gt;&lt;code&gt;Pack200.newPacker()&lt;/code&gt;&lt;/a&gt;. The high degree of compression is achieved by using a number of techniques described in the JSR 200 specification. Some of the techniques are sorting, re-ordering and co-location of the constant pool.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기로 압축 가능한 압축 스트림을 만듭니다. 엔진의 인스턴스를 이용하여 얻을 수있다 &lt;a href=&quot;pack200#newPacker--&quot;&gt; &lt;code&gt;Pack200.newPacker()&lt;/code&gt; &lt;/a&gt; . 높은 압축률은 JSR 200 사양에 설명 된 여러 기술을 사용하여 달성됩니다. 기술 중 일부는 상수 풀의 정렬, 재정렬 및 ​​배치입니다.</target>
        </trans-unit>
        <trans-unit id="30ee921e8de863d2bf5c9f554ad216859c719f2f" translate="yes" xml:space="preserve">
          <source>The packer's progress as a percentage, as periodically updated by the packer.</source>
          <target state="translated">패커가 주기적으로 업데이트하는 패커의 진행률 (백분율)입니다.</target>
        </trans-unit>
        <trans-unit id="821c9b2be3513399d24ae8026376ff5c4cd964d7" translate="yes" xml:space="preserve">
          <source>The packer's progress as a percentage, as periodically updated by the packer. Values of 0 - 100 are normal, and -1 indicates a stall. Progress can be monitored by polling the value of this property.</source>
          <target state="translated">패커가 주기적으로 업데이트하는 패커의 진행률 (백분율)입니다. 0-100의 값은 정상이고 -1은 중단을 나타냅니다. 이 속성 값을 폴링하여 진행 상황을 모니터링 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
