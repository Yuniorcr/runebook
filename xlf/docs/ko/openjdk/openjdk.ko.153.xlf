<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="315f63d583a4676ef18933ae7199a0ed0f9a00e4" translate="yes" xml:space="preserve">
          <source>The timer notifications are created and handled by the timer MBean.</source>
          <target state="translated">타이머 통지는 타이머 MBean에 의해 작성되어 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="cd191085be187917516f28d90bc41b5e0e055de2" translate="yes" xml:space="preserve">
          <source>The timer service relies on the system date of the host where the &lt;code&gt;Timer&lt;/code&gt; class is loaded. Listeners may receive untimely notifications if their host has a different system date. To avoid such problems, synchronize the system date of all host machines where timing is needed.</source>
          <target state="translated">타이머 서비스는 &lt;code&gt;Timer&lt;/code&gt; 클래스가로드 된 호스트의 시스템 날짜에 의존합니다 . 호스트의 시스템 날짜가 다른 경우 리스너가시기 적절하지 않은 알림을받을 수 있습니다. 이러한 문제를 피하려면 타이밍이 필요한 모든 호스트 시스템의 시스템 날짜를 동기화하십시오.</target>
        </trans-unit>
        <trans-unit id="60a7b8fc73dec0735c0c82b6db258aba41d55181" translate="yes" xml:space="preserve">
          <source>The timestamp of this &lt;code&gt;UUID&lt;/code&gt;.</source>
          <target state="translated">이것의 타임 스탬프 &lt;code&gt;UUID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d91c8abe6606f2a3d89bcf82e749e9e60f3b44c" translate="yes" xml:space="preserve">
          <source>The timestamp or &lt;code&gt;null&lt;/code&gt; if none is present.</source>
          <target state="translated">타임 스탬프 . 존재하지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a65048c31509f7e0113cb6ea8961ee3f79f086" translate="yes" xml:space="preserve">
          <source>The timestamp value associated with this UUID.</source>
          <target state="translated">이 UUID와 연관된 시간 소인 값입니다.</target>
        </trans-unit>
        <trans-unit id="77858a6a5789b904ad06d6e90ad129b1b4ed75fb" translate="yes" xml:space="preserve">
          <source>The timestamp value is only meaningful in a time-based UUID, which has version type 1. If this &lt;code&gt;UUID&lt;/code&gt; is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">시간 소인 값은 버전 유형이 1 인 시간 기반 UUID에서만 의미가 있습니다.이 &lt;code&gt;UUID&lt;/code&gt; 가 시간 기반 UUID가 아닌 경우이 메소드는 UnsupportedOperationException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="562d9979ad13d306cfdc69375e27b692b4c4e6be" translate="yes" xml:space="preserve">
          <source>The timestamp's date and time.</source>
          <target state="translated">타임 스탬프의 날짜 및 시간</target>
        </trans-unit>
        <trans-unit id="2f99efc0a5831891f40ab823d3bf06354b6d699f" translate="yes" xml:space="preserve">
          <source>The timing division type of the sequence.</source>
          <target state="translated">시퀀스의 타이밍 분할 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b61d7655e56c95f2266c2fad01803ab318ea6674" translate="yes" xml:space="preserve">
          <source>The timing information and resolution for a track is controlled by and stored in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt; is considered to belong to the particular &lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; that maintains its timing. For this reason, a new (empty) track is created by calling the &lt;a href=&quot;sequence#createTrack()&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt; method, rather than by directly invoking a &lt;code&gt;Track&lt;/code&gt; constructor.</source>
          <target state="translated">트랙의 타이밍 정보와 해상도는 트랙을 포함하는 시퀀스에 의해 제어되고 저장됩니다. 주어진 &lt;code&gt;Track&lt;/code&gt; 은 타이밍을 유지 하는 특정 &lt;a href=&quot;sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt; 에 속하는 것으로 간주됩니다 . 따라서 &lt;code&gt;Track&lt;/code&gt; 생성자를 직접 호출하는 대신 &lt;a href=&quot;sequence#createTrack()&quot;&gt; &lt;code&gt;Sequence.createTrack()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 새 (빈) 트랙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d0374fbf6438fbc3467dbf34b4e05683b94595c3" translate="yes" xml:space="preserve">
          <source>The timing information and resolution for a track is controlled by and stored in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt; is considered to belong to the particular &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; that maintains its timing. For this reason, a new (empty) track is created by calling the &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method, rather than by directly invoking a &lt;code&gt;Track&lt;/code&gt; constructor.</source>
          <target state="translated">트랙의 타이밍 정보 및 해상도는 트랙을 포함하는 시퀀스에 의해 제어되고 저장됩니다. 주어진 &lt;code&gt;Track&lt;/code&gt; 은 타이밍을 유지 하는 특정 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 에 속하는 것으로 간주됩니다 . 이러한 이유로 &lt;code&gt;Track&lt;/code&gt; 생성자를 직접 호출하지 않고 &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메서드 를 호출하여 새 (빈) 트랙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6e6d3880f415cd4ec5def31690bbd751de4d2179" translate="yes" xml:space="preserve">
          <source>The timing resolution of the MIDI file.</source>
          <target state="translated">MIDI 파일의 타이밍 해상도</target>
        </trans-unit>
        <trans-unit id="94d8255f666f78ba91e4c0653d1ddca333f07432" translate="yes" xml:space="preserve">
          <source>The timing resolution of the sequence.</source>
          <target state="translated">시퀀스의 타이밍 해상도.</target>
        </trans-unit>
        <trans-unit id="5ea038093e385d3d5e2fd57f0725ac3f67c851e4" translate="yes" xml:space="preserve">
          <source>The title displayed in this internal frame's title bar.</source>
          <target state="translated">이 내부 프레임의 제목 표시 줄에 표시되는 제목입니다.</target>
        </trans-unit>
        <trans-unit id="acaeefe50cb5c6ee79bdfe6165ed6efca1e633ed" translate="yes" xml:space="preserve">
          <source>The title for the dialog box.</source>
          <target state="translated">대화 상자의 제목입니다.</target>
        </trans-unit>
        <trans-unit id="3a3106a5519a4cc49f3d21712c3f6fa49becfeb4" translate="yes" xml:space="preserve">
          <source>The title may or may not be displayed, depending on the actual type of window created.</source>
          <target state="translated">생성 된 실제 창의 유형에 따라 제목이 표시되거나 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8120bf9b224de89c2920e1546dcda46c8b1f8843" translate="yes" xml:space="preserve">
          <source>The title pane component used in the desktop icon.</source>
          <target state="translated">데스크탑 아이콘에 사용되는 제목 창 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="53048a7dfc38ea7b3d5b7194f51d45f9a8b221a2" translate="yes" xml:space="preserve">
          <source>The title the border should display.</source>
          <target state="translated">테두리에 표시 할 제목입니다.</target>
        </trans-unit>
        <trans-unit id="6c8e5b4d5d69012c519b74be2af0f0e1bad6f4c4" translate="yes" xml:space="preserve">
          <source>The token was a duplicate of an earlier token.</source>
          <target state="translated">토큰은 이전 토큰의 중복입니다.</target>
        </trans-unit>
        <trans-unit id="469511f0f8c8e5bb2c80808eab9d90b35b66e458" translate="yes" xml:space="preserve">
          <source>The token was a duplicate of an earlier token. This is a fatal error code that may occur during context establishment. It is not used to indicate supplementary status values. The MessageProp object is used for that purpose.</source>
          <target state="translated">토큰은 이전 토큰의 중복입니다. 이는 컨텍스트 설정 중에 발생할 수있는 치명적인 오류 코드입니다. 보충 상태 값을 나타내는 데 사용되지 않습니다. MessageProp 개체는 이러한 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="309f8befb903508c4999847b0b027aa02db2ad23" translate="yes" xml:space="preserve">
          <source>The token's validity period has expired.</source>
          <target state="translated">토큰의 유효 기간이 만료되었습니다.</target>
        </trans-unit>
        <trans-unit id="c12371230e30f66f3a76ec6704bded2a17df9644" translate="yes" xml:space="preserve">
          <source>The token's validity period has expired. This is a fatal error code that may occur during context establishment. It is not used to indicate supplementary status values. The MessageProp object is used for that purpose.</source>
          <target state="translated">토큰의 유효 기간이 만료되었습니다. 이는 컨텍스트 설정 중에 발생할 수있는 치명적인 오류 코드입니다. 보충 상태 값을 나타내는 데 사용되지 않습니다. MessageProp 개체는 이러한 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46bd53fc951ee54ff26208f7f7d6b401775175dc" translate="yes" xml:space="preserve">
          <source>The tool environment is not required to support annotation processors that access environmental resources, either &lt;a href=&quot;roundenvironment&quot;&gt;per round&lt;/a&gt; or &lt;a href=&quot;processingenvironment&quot;&gt;cross-round&lt;/a&gt;, in a multi-threaded fashion.</source>
          <target state="translated">이 도구 환경을 지원 주석 프로세서에 필요하지 않습니다 대한 액세스 환경 자원, 중 &lt;a href=&quot;roundenvironment&quot;&gt;라운드 당&lt;/a&gt; 또는 &lt;a href=&quot;processingenvironment&quot;&gt;크로스 라운드&lt;/a&gt; 멀티 스레드 방식으로 .</target>
        </trans-unit>
        <trans-unit id="475033ec07ec172731d36e8e1a8c4e34cb1c0c10" translate="yes" xml:space="preserve">
          <source>The tool uses a</source>
          <target state="translated">이 도구는</target>
        </trans-unit>
        <trans-unit id="60edabc59c6f9e62a5a0fdea67fe30d15095591d" translate="yes" xml:space="preserve">
          <source>The tooltip text displayed on the approve button when a directory is selected and the current selection mode is FILES_ONLY.</source>
          <target state="translated">디렉토리가 선택되고 현재 선택 모드가 FILES_ONLY 일 때 승인 버튼에 표시되는 도구 설명 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="6ee07dce8496ccc8327ec779a3d953aaa0190c20" translate="yes" xml:space="preserve">
          <source>The top input tray in the printer.</source>
          <target state="translated">프린터의 상단 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="401590292bf1267b8c693854dc6321d52720a8be" translate="yes" xml:space="preserve">
          <source>The top inset of the border.</source>
          <target state="translated">테두리의 상단 삽입.</target>
        </trans-unit>
        <trans-unit id="42a671ce68c829c9c3682af0e642fe256fbef14d" translate="yes" xml:space="preserve">
          <source>The top-level error handler that reacts to otherwise uncaught exceptions does not print out a message or otherwise notify the application if the uncaught exception is an instance of &lt;code&gt;ThreadDeath&lt;/code&gt;.</source>
          <target state="translated">캐치되지 않은 예외에 반응하는 최상위 레벨 오류 처리기는 캐치되지 않은 예외가 &lt;code&gt;ThreadDeath&lt;/code&gt; 의 인스턴스 인 경우 메시지를 인쇄하거나 애플리케이션에 알리지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="46f6d47ae13aad5695f239448bb57766c13e2aa1" translate="yes" xml:space="preserve">
          <source>The total length of the message in bytes (the status byte plus any data bytes)</source>
          <target state="translated">메시지의 총 길이 (바이트) (상태 바이트 + 모든 데이터 바이트)</target>
        </trans-unit>
        <trans-unit id="17fecdd4ddcdb8672f8d5932951da08117bd4dd0" translate="yes" xml:space="preserve">
          <source>The total number of bits in the pixel.</source>
          <target state="translated">픽셀의 총 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="05917e7da6988078054932792c0c5486cd4b1b28" translate="yes" xml:space="preserve">
          <source>The total number of points.</source>
          <target state="translated">총 포인트 수입니다.</target>
        </trans-unit>
        <trans-unit id="f62e7ead83f7b630f60dc2cbbcf456264118e6c3" translate="yes" xml:space="preserve">
          <source>The total number of points. The value of &lt;code&gt;npoints&lt;/code&gt; represents the number of valid points in this &lt;code&gt;Polygon&lt;/code&gt; and might be less than the number of elements in &lt;a href=&quot;#xpoints&quot;&gt;&lt;code&gt;xpoints&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ypoints&quot;&gt;&lt;code&gt;ypoints&lt;/code&gt;&lt;/a&gt;. This value can be 0.</source>
          <target state="translated">총 포인트 수입니다. &lt;code&gt;npoints&lt;/code&gt; 값은 이 &lt;code&gt;Polygon&lt;/code&gt; 의 유효한 포인트 수를 나타내며 &lt;a href=&quot;#xpoints&quot;&gt; &lt;code&gt;xpoints&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ypoints&quot;&gt; &lt;code&gt;ypoints&lt;/code&gt; &lt;/a&gt; 의 요소 수보다 적을 수 있습니다 . 이 값은 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ad0ea114ec1ddf71f5fe2d46d0cb9e7197a57a0" translate="yes" xml:space="preserve">
          <source>The total number of significant digits in</source>
          <target state="translated">유효 유효 자릿수의 총계</target>
        </trans-unit>
        <trans-unit id="e8f848286d69d23ec4b7259715c33925c847df30" translate="yes" xml:space="preserve">
          <source>The total size of the document including all external resources, this number might change as a document is being parsed if references to more external resources are seen.</source>
          <target state="translated">모든 외부 리소스를 포함한 문서의 총 크기입니다.이 숫자는 더 많은 외부 리소스에 대한 참조가 표시되는 경우 문서가 구문 분석 될 때 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a52eb79799de442c045f35d0474d14d18b85672" translate="yes" xml:space="preserve">
          <source>The total size of the document including all external resources, this number might change as a document is being parsed if references to more external resources are seen. A value of &lt;code&gt;0&lt;/code&gt; is returned if the total size cannot be determined or estimated.</source>
          <target state="translated">모든 외부 리소스를 포함한 문서의 총 크기입니다.이 숫자는 더 많은 외부 리소스에 대한 참조가 표시되는 경우 문서가 구문 분석 될 때 변경 될 수 있습니다. 총 크기를 판별하거나 추정 할 수없는 경우 &lt;code&gt;0&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cfb3d21fdcbe867349c0a9b8497b711e26d212" translate="yes" xml:space="preserve">
          <source>The total size of the list.</source>
          <target state="translated">목록의 전체 크기입니다.</target>
        </trans-unit>
        <trans-unit id="6b5d7d5da983bf443ff8b0d755377059b977f35d" translate="yes" xml:space="preserve">
          <source>The tracking value is multiplied by the font point size and passed through the font transform to determine an additional amount to add to the advance of each glyph cluster. Positive tracking values will inhibit formation of optional ligatures. Tracking values are typically between &lt;code&gt;-0.1&lt;/code&gt; and &lt;code&gt;0.3&lt;/code&gt;; values outside this range are generally not desirable.</source>
          <target state="translated">추적 값에 글꼴 포인트 크기를 곱하고 글꼴 변환을 통해 전달하여 각 글리프 클러스터의 진행에 추가 할 추가 양을 결정합니다. 양의 추적 값은 선택적 합자의 형성을 억제합니다. 추적 값은 일반적으로 &lt;code&gt;-0.1&lt;/code&gt; 에서 &lt;code&gt;0.3&lt;/code&gt; 사이입니다 . 이 범위를 벗어난 값은 일반적으로 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="703deab7518e04de6cf78487901807570cefd5e8" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically committed and rolled back.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 커밋되고 롤백되었습니다.</target>
        </trans-unit>
        <trans-unit id="14b4d7ed7740cc11b56bff202adfa6d5c222e033" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically committed.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 커밋되었습니다.</target>
        </trans-unit>
        <trans-unit id="da0babcbf37a3af594d97dc69b6bf086d7544d2c" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically rolled back.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 롤백되었습니다.</target>
        </trans-unit>
        <trans-unit id="050d9fced3f39f16dd7abd1393e7514ef1ce5372" translate="yes" xml:space="preserve">
          <source>The transaction branch has been read-only and has been committed.</source>
          <target state="translated">트랜잭션 분기가 읽기 전용이고 커밋되었습니다.</target>
        </trans-unit>
        <trans-unit id="33db632dad51ea9ae41ea3cf6edbcd4f22719c4e" translate="yes" xml:space="preserve">
          <source>The transaction branch may have been heuristically completed.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 완료되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861c2375e08c3476b0904853fa18832f2c36bb4e" translate="yes" xml:space="preserve">
          <source>The transaction branch was read-only and has been committed.</source>
          <target state="translated">트랜잭션 분기가 읽기 전용이고 커밋되었습니다.</target>
        </trans-unit>
        <trans-unit id="b793d2f86bb5ddf2929ec67d8f137dd2ab9dd816" translate="yes" xml:space="preserve">
          <source>The transaction work has been prepared normally.</source>
          <target state="translated">거래 작업이 정상적으로 준비되었습니다.</target>
        </trans-unit>
        <trans-unit id="9df96b47070ad60931e75c25b6080817de2717a9" translate="yes" xml:space="preserve">
          <source>The transfer &lt;em&gt;will not necessarily&lt;/em&gt; have been completed at the return of this call (i.e. the call does not block waiting for the drop). The transfer will take place through the Swing implementation of the &lt;code&gt;java.awt.dnd&lt;/code&gt; mechanism, requiring no further effort from the developer. The &lt;code&gt;exportDone&lt;/code&gt; method will be called when the transfer has completed.</source>
          <target state="translated">이 호출이 반환 &lt;em&gt;될 때&lt;/em&gt; 전송 &lt;em&gt;이 반드시&lt;/em&gt; 완료 &lt;em&gt;되지는 않습니다&lt;/em&gt; (즉, 호출이 드롭 대기를 차단하지 않음). 전송은 &lt;code&gt;java.awt.dnd&lt;/code&gt; 메커니즘 의 Swing 구현을 통해 이루어 지므로 개발자의 추가 노력이 필요하지 않습니다. &lt;code&gt;exportDone&lt;/code&gt; 전송이 완료되면 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c4e8eb43c79370beb6a0b967d482c111e1ea42" translate="yes" xml:space="preserve">
          <source>The transfer will take place using the &lt;code&gt;java.awt.datatransfer&lt;/code&gt; mechanism, requiring no further effort from the developer. Any data transfer &lt;em&gt;will&lt;/em&gt; be complete and the &lt;code&gt;exportDone&lt;/code&gt; method will be called with the action that occurred, before this method returns. Should the clipboard be unavailable when attempting to place data on it, the &lt;code&gt;IllegalStateException&lt;/code&gt; thrown by &lt;a href=&quot;../../../java.datatransfer/java/awt/datatransfer/clipboard#setContents(java.awt.datatransfer.Transferable,java.awt.datatransfer.ClipboardOwner)&quot;&gt;&lt;code&gt;Clipboard.setContents(Transferable, ClipboardOwner)&lt;/code&gt;&lt;/a&gt; will be propagated through this method. However, &lt;code&gt;exportDone&lt;/code&gt; will first be called with an action of &lt;code&gt;NONE&lt;/code&gt; for consistency.</source>
          <target state="translated">전송은 &lt;code&gt;java.awt.datatransfer&lt;/code&gt; 메커니즘을 사용하여 이루어 지므로 개발자의 추가 노력이 필요하지 않습니다. 모든 데이터 전송 &lt;em&gt;이&lt;/em&gt; 완료 &lt;code&gt;exportDone&lt;/code&gt; 메서드가 반환되기 전에 발생한 작업과 함께 exportDone 메서드가 호출됩니다. 거기에 장소 데이터를 시도 할 때 클립 보드에 사용할 수 만일, &lt;code&gt;IllegalStateException&lt;/code&gt; 이 에 의해 throw &lt;a href=&quot;../../../java.datatransfer/java/awt/datatransfer/clipboard#setContents(java.awt.datatransfer.Transferable,java.awt.datatransfer.ClipboardOwner)&quot;&gt; &lt;code&gt;Clipboard.setContents(Transferable, ClipboardOwner)&lt;/code&gt; &lt;/a&gt; 이 방법을 통해 전파됩니다. 그러나 일관성을 위해 먼저 &lt;code&gt;exportDone&lt;/code&gt; 이 &lt;code&gt;NONE&lt;/code&gt; 조치로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="d87f3db630bd4bc1d40103fa67e3e1b3f2db8546" translate="yes" xml:space="preserve">
          <source>The transformation API throw three types of specialized exceptions. A &lt;a href=&quot;transformerfactoryconfigurationerror&quot;&gt;&lt;code&gt;TransformerFactoryConfigurationError&lt;/code&gt;&lt;/a&gt; is parallel to the &lt;a href=&quot;../parsers/factoryconfigurationerror&quot;&gt;&lt;code&gt;FactoryConfigurationError&lt;/code&gt;&lt;/a&gt;, and is thrown when a configuration problem with the TransformerFactory exists. This error will typically be thrown when the transformation factory class specified with the &quot;javax.xml.transform.TransformerFactory&quot; system property cannot be found or instantiated.</source>
          <target state="translated">변환 API는 세 가지 유형의 특수 예외를 발생시킵니다. &lt;a href=&quot;transformerfactoryconfigurationerror&quot;&gt; &lt;code&gt;TransformerFactoryConfigurationError&lt;/code&gt; 가&lt;/a&gt; 받는 평행 &lt;a href=&quot;../parsers/factoryconfigurationerror&quot;&gt; &lt;code&gt;FactoryConfigurationError&lt;/code&gt; &lt;/a&gt; 과의 TransformerFactory 구성 문제가 존재할 때 발생한다. 이 오류는 일반적으로 &quot;javax.xml.transform.TransformerFactory&quot;시스템 특성으로 지정된 변환 팩토리 클래스를 찾거나 인스턴스화 할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe701db82a538a1330d479e42d071cac878afdf3" translate="yes" xml:space="preserve">
          <source>The transformed &lt;code&gt;Raster&lt;/code&gt;.</source>
          <target state="translated">변형 된 &lt;code&gt;Raster&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d806ee0a87e3109095fc859ea8eb5cc5532045bc" translate="yes" xml:space="preserve">
          <source>The transformer must continue to try and provide normal transformation after invoking this method. It should still be possible for the application to process the document through to the end if no other errors are encountered.</source>
          <target state="translated">변환기는이 메서드를 호출 한 후 계속해서 정상적인 변환을 시도하고 제공해야합니다. 다른 오류가 발생하지 않으면 애플리케이션이 문서를 끝까지 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5fa423bbef1d4f0ed7a551ce1858b400fcccf4df" translate="yes" xml:space="preserve">
          <source>The transition may be represented as occurring at 24:00.</source>
          <target state="translated">전환은 24:00에 발생하는 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bbbaf76aec7f9bf6cba6b78d515bbb3bf05d201" translate="yes" xml:space="preserve">
          <source>The translation between a parent and child Raster may be determined by subtracting the child's sampleModelTranslateX and sampleModelTranslateY values from those of the parent.</source>
          <target state="translated">부모와 자식 Raster 간의 변환은 부모의 값에서 자식의 sampleModelTranslateX 및 sampleModelTranslateY 값을 빼서 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d3c8c5c72b6b96fb6f59ecad375ecd5b5124beb" translate="yes" xml:space="preserve">
          <source>The translation from pixel sample values to color/alpha components for display or processing purposes is based on a one-to-one correspondence of samples to components. Depending on the transfer type used to create an instance of &lt;code&gt;ComponentColorModel&lt;/code&gt;, the pixel sample values represented by that instance may be signed or unsigned and may be of integral type or float or double (see below for details). The translation from sample values to normalized color/alpha components must follow certain rules. For float and double samples, the translation is an identity, i.e. normalized component values are equal to the corresponding sample values. For integral samples, the translation should be only a simple scale and offset, where the scale and offset constants may be different for each component. The result of applying the scale and offset constants is a set of color/alpha component values, which are guaranteed to fall within a certain range. Typically, the range for a color component will be the range defined by the &lt;code&gt;getMinValue&lt;/code&gt; and &lt;code&gt;getMaxValue&lt;/code&gt; methods of the &lt;code&gt;ColorSpace&lt;/code&gt; class. The range for an alpha component should be 0.0 to 1.0.</source>
          <target state="translated">디스플레이 또는 처리 목적을 위해 픽셀 샘플 값에서 색상 / 알파 구성 요소로의 변환은 구성 요소에 대한 샘플의 일대일 대응을 기반으로합니다. &lt;code&gt;ComponentColorModel&lt;/code&gt; 의 인스턴스를 만드는 데 사용되는 전송 유형에 따라, 해당 인스턴스가 나타내는 픽셀 샘플 값은 부호가 있거나 부호가 없을 수 있으며 정수 유형 또는 부동 또는 이중 일 수 있습니다 (자세한 내용은 아래 참조). 샘플 값에서 정규화 된 색상 / 알파 성분으로의 변환은 특정 규칙을 따라야합니다. float 및 double 샘플의 경우 변환은 동일합니다. 즉, 정규화 된 구성 요소 값은 해당 샘플 값과 동일합니다. 적분 샘플의 경우 변환은 단순 스케일 및 오프셋이어야하며 스케일 및 오프셋 상수는 각 구성 요소에 대해 다를 수 있습니다. 배율 및 오프셋 상수를 적용한 결과는 특정 범위에 속하도록 보장되는 색상 / 알파 구성 요소 값 집합입니다. 일반적으로 색상 구성 요소의 범위는 &lt;code&gt;getMinValue&lt;/code&gt; 및 &lt;code&gt;getMaxValue&lt;/code&gt; 로 정의 된 범위입니다. &lt;code&gt;ColorSpace&lt;/code&gt; 클래스의 메서드 . 알파 성분의 범위는 0.0에서 1.0 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b65a261d80d53542a10bedce8edbc81f70d91963" translate="yes" xml:space="preserve">
          <source>The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components. A &lt;code&gt;DirectColorModel&lt;/code&gt; is typically used with image data which uses masks to define packed samples. For example, a &lt;code&gt;DirectColorModel&lt;/code&gt; can be used in conjunction with a &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; to construct a &lt;a href=&quot;bufferedimage&quot;&gt;&lt;code&gt;BufferedImage&lt;/code&gt;&lt;/a&gt;. Normally the masks used by the &lt;a href=&quot;samplemodel&quot;&gt;&lt;code&gt;SampleModel&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;ColorModel&lt;/code&gt; would be the same. However, if they are different, the color interpretation of pixel data will be done according to the masks of the &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">디스플레이 또는 처리 목적을 위해 픽셀 값에서 색상 / 알파 구성 요소로의 변환은 구성 요소에 대한 샘플의 일대일 대응입니다. &lt;code&gt;DirectColorModel&lt;/code&gt; 를는 일반적으로 포장 샘플을 정의하기 위해 마스크를 사용하는 화상 데이터와 함께 사용된다. 예를 들어 &lt;code&gt;DirectColorModel&lt;/code&gt; 을 &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; 과 함께 사용 하여 &lt;a href=&quot;bufferedimage&quot;&gt; &lt;code&gt;BufferedImage&lt;/code&gt; &lt;/a&gt; 를 생성 할 수 있습니다 . 일반적으로 &lt;a href=&quot;samplemodel&quot;&gt; &lt;code&gt;SampleModel&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;ColorModel&lt;/code&gt; 에서 사용하는 마스크 는 동일합니다. 단, 다른 경우에는 &lt;code&gt;ColorModel&lt;/code&gt; 마스크에 따라 픽셀 데이터의 색상 해석이 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="168b1d4ef4c25a61d82bab781cf817cb6ee6ff78" translate="yes" xml:space="preserve">
          <source>The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components. A &lt;code&gt;PackedColorModel&lt;/code&gt; is typically used with image data that uses masks to define packed samples. For example, a &lt;code&gt;PackedColorModel&lt;/code&gt; can be used in conjunction with a &lt;a href=&quot;singlepixelpackedsamplemodel&quot;&gt;&lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt;&lt;/a&gt; to construct a &lt;a href=&quot;bufferedimage&quot;&gt;&lt;code&gt;BufferedImage&lt;/code&gt;&lt;/a&gt;. Normally the masks used by the &lt;a href=&quot;samplemodel&quot;&gt;&lt;code&gt;SampleModel&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;ColorModel&lt;/code&gt; would be the same. However, if they are different, the color interpretation of pixel data is done according to the masks of the &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">디스플레이 또는 처리 목적을 위해 픽셀 값에서 색상 / 알파 구성 요소로의 변환은 구성 요소에 대한 샘플의 일대일 대응입니다. &lt;code&gt;PackedColorModel&lt;/code&gt; 와는 일반적으로 포장 샘플들을 정의하는 마스크를 사용하는 화상 데이터와 함께 사용된다. 예를 들어 &lt;code&gt;PackedColorModel&lt;/code&gt; 을 &lt;a href=&quot;singlepixelpackedsamplemodel&quot;&gt; &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; &lt;/a&gt; 과 함께 사용 하여 &lt;a href=&quot;bufferedimage&quot;&gt; &lt;code&gt;BufferedImage&lt;/code&gt; &lt;/a&gt; 를 생성 할 수 있습니다 . 일반적으로 &lt;a href=&quot;samplemodel&quot;&gt; &lt;code&gt;SampleModel&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;ColorModel&lt;/code&gt; 에서 사용하는 마스크 는 동일합니다. 단, 다른 경우에는 &lt;code&gt;ColorModel&lt;/code&gt; 마스크에 따라 픽셀 데이터의 색상 해석이 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="b5d7a0a9a5aa913b72a0d7dce956d6a2d0147d1c" translate="yes" xml:space="preserve">
          <source>The translucency levels of individual pixels may also be effected by the alpha component of their color (see &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt;&lt;code&gt;setBackground(Color)&lt;/code&gt;&lt;/a&gt;) and the current shape of this window (see &lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt;&lt;code&gt;setShape(Shape)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">개별 픽셀의 반투명도 수준은 색상의 알파 구성 요소 ( &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt; &lt;code&gt;setBackground(Color)&lt;/code&gt; &lt;/a&gt; 참조 ) 및이 창의 현재 모양 ( &lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt; &lt;code&gt;setShape(Shape)&lt;/code&gt; &lt;/a&gt; 참조) 에 의해 영향을받을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2749ff4c08edcd16b069e9cf4d2ed0371273c113" translate="yes" xml:space="preserve">
          <source>The translucency levels of individual pixels may also be effected by the alpha component of their color (see &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt;&lt;code&gt;setBackground(Color)&lt;/code&gt;&lt;/a&gt;) and the opacity value (see &lt;a href=&quot;#setOpacity(float)&quot;&gt;&lt;code&gt;setOpacity(float)&lt;/code&gt;&lt;/a&gt;). See &lt;a href=&quot;graphicsdevice.windowtranslucency&quot;&gt;&lt;code&gt;GraphicsDevice.WindowTranslucency&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">개별 픽셀의 반투명도 수준은 색상의 알파 구성 요소 ( &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt; &lt;code&gt;setBackground(Color)&lt;/code&gt; &lt;/a&gt; 참조 )와 불투명도 값 ( &lt;a href=&quot;#setOpacity(float)&quot;&gt; &lt;code&gt;setOpacity(float)&lt;/code&gt; &lt;/a&gt; 참조) 에 의해 영향을받을 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;graphicsdevice.windowtranslucency&quot;&gt; &lt;code&gt;GraphicsDevice.WindowTranslucency&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c1306905f8e445cab20995e9caae10676aed4f2" translate="yes" xml:space="preserve">
          <source>The transparency of an &lt;code&gt;IndexColorModel&lt;/code&gt; object is determined by examining the alpha components of the colors in the colormap and choosing the most specific value after considering the optional alpha values and any transparent index specified. The transparency value is &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; only if all valid colors in the colormap are opaque and there is no valid transparent pixel. If all valid colors in the colormap are either completely opaque (alpha = 1.0) or completely transparent (alpha = 0.0), which typically occurs when a valid transparent pixel is specified, the value is &lt;code&gt;Transparency.BITMASK&lt;/code&gt;. Otherwise, the value is &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;, indicating that some valid color has an alpha component that is neither completely transparent nor completely opaque (0.0 &amp;lt; alpha &amp;lt; 1.0).</source>
          <target state="translated">&lt;code&gt;IndexColorModel&lt;/code&gt; 객체 의 투명도는 컬러 맵에있는 색상의 알파 구성 요소를 검사하고 선택적 알파 값과 지정된 투명 인덱스를 고려한 후 가장 구체적인 값을 선택하여 결정됩니다. 투명도 값은 &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; 가 칼라 맵의 모든 유효한 색이 불투명하고 유효한 투명 픽셀이없는 경우에만 가능합니다. 컬러 맵의 모든 유효한 색상이 완전히 불투명하거나 (알파 = 1.0) 완전히 투명한 경우 (알파 = 0.0), 일반적으로 유효한 투명 픽셀을 지정할 때 발생하는 경우 값은 &lt;code&gt;Transparency.BITMASK&lt;/code&gt; 입니다. 그렇지 않은 경우 값은 &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt; 입니다., 일부 유효한 색상에 완전히 투명하거나 완전히 불투명하지 않은 (0.0 &amp;lt;알파 &amp;lt;1.0) 알파 구성 요소가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c891870f2397ea5ffc5f4c8aade7bd8d1dab8055" translate="yes" xml:space="preserve">
          <source>The transparency value with which this image was created.</source>
          <target state="translated">이 이미지가 생성 된 투명도 값입니다.</target>
        </trans-unit>
        <trans-unit id="a2e25a1118ce8877391b5f01b4a57a8df400e4ba" translate="yes" xml:space="preserve">
          <source>The tree has no model</source>
          <target state="translated">나무에는 모델이 없습니다</target>
        </trans-unit>
        <trans-unit id="dd6f791fb336426f0b5c534f66eae3384f79ccf9" translate="yes" xml:space="preserve">
          <source>The trigger.</source>
          <target state="translated">방아쇠</target>
        </trans-unit>
        <trans-unit id="19d46a2a9ae7b495f51fc356027feaf3becd628d" translate="yes" xml:space="preserve">
          <source>The truth value returned by this method is equivalent to: &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt;</source>
          <target state="translated">이 메소드에 의해 돌려 주어지는 진실 &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt; 다음과 같습니다. getAnnotation (annotationClass)! = null</target>
        </trans-unit>
        <trans-unit id="8c46d6198c957c6c25b841cf0f4dfb6d6cb250b3" translate="yes" xml:space="preserve">
          <source>The ttl &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt; 0 &amp;lt;= ttl &amp;lt;=
 255&lt;/code&gt; or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Multicast packets sent with a TTL of &lt;code&gt;0&lt;/code&gt; are not transmitted on the network but may be delivered locally.</source>
          <target state="translated">ttl &lt;b&gt;은 &lt;/b&gt; &lt;code&gt; 0 &amp;lt;= ttl &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. TTL이 &lt;code&gt;0&lt;/code&gt; 인 멀티 캐스트 패킷 은 네트워크에서 전송되지 않지만 로컬로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2485bd279a135141b31dd6331097ba469508ddf1" translate="yes" xml:space="preserve">
          <source>The ttl &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;=
 255&lt;/code&gt; or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Multicast packets sent with a TTL of &lt;code&gt;0&lt;/code&gt; are not transmitted on the network but may be delivered locally.</source>
          <target state="translated">ttl &lt;b&gt;은 &lt;/b&gt; &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. TTL &lt;code&gt;0&lt;/code&gt; 으로 전송 된 멀티 캐스트 패킷 은 네트워크에서 전송되지 않지만 로컬로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6940391f4a3596501f2f3676ceed69996fe5b256" translate="yes" xml:space="preserve">
          <source>The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt;.</source>
          <target state="translated">ttl은 &lt;b&gt; 부호없는&lt;/b&gt; 8 비트 수량이므로 &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt; 범위에 &lt;b&gt;있어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="969fb09f0d47cbd4ef59365982ee80f259c1e668" translate="yes" xml:space="preserve">
          <source>The twelve methods described above are summarized in the following table:</source>
          <target state="translated">위에서 설명한 12 가지 방법이 다음 표에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="60737d50d1714cdb7c9a212137135f035cb7e133" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;Component&lt;/code&gt;s in a split pane can be aligned left to right using &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt;, or top to bottom using &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;. The preferred way to change the size of the &lt;code&gt;Component&lt;/code&gt;s is to invoke &lt;code&gt;setDividerLocation&lt;/code&gt; where &lt;code&gt;location&lt;/code&gt; is either the new x or y position, depending on the orientation of the &lt;code&gt;JSplitPane&lt;/code&gt;.</source>
          <target state="translated">두 &lt;code&gt;Component&lt;/code&gt; 의 분리 창의 사용은 왼쪽에서 오른쪽으로 정렬 될 수 &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt; 를 사용하거나 위에서 아래로 &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt; 를 . &lt;code&gt;Component&lt;/code&gt; 의 크기를 변경하는 선호되는 방법 은 &lt;code&gt;setDividerLocation&lt;/code&gt; 을 호출하는 것입니다. 여기서 &lt;code&gt;location&lt;/code&gt; 은 &lt;code&gt;JSplitPane&lt;/code&gt; 의 방향에 따라 새로운 x 또는 y 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="a3593155b51237a7085bf75da2140fc0fe3e8c66" translate="yes" xml:space="preserve">
          <source>The two calls have the same effect.</source>
          <target state="translated">두 통화의 효과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b92a8d153cce49ff845ddf50531191cd3a963be7" translate="yes" xml:space="preserve">
          <source>The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially, see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.</source>
          <target state="translated">두 경우 ( &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) 및 ( &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;)는 특수하게 처리 됩니다. 자세한 내용 은 &lt;a href=&quot;#special_cases_constructor&quot;&gt;특수 사례&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28393cbfd67002d6ad36a08762b2e38653599b68" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the &lt;code&gt;==&lt;/code&gt; operator)</source>
          <target state="translated">두 문자는 동일합니다 ( &lt;code&gt;==&lt;/code&gt; 연산자 와 비교하여 )</target>
        </trans-unit>
        <trans-unit id="733cbbaea42ad75e1ffe40db5e03f1fed7b55f41" translate="yes" xml:space="preserve">
          <source>The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the indicated offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.</source>
          <target state="translated">두 좌표 배열 섹션은 정확히 동일하거나 결과의 유효성에 영향을주지 않고 동일한 배열의 섹션을 겹칠 수 있습니다. 이 방법을 사용하면 원본 좌표를 변환하기 전에 이전 작업으로 덮어 쓰지 않습니다. 좌표는 표시된 오프셋에서 시작하여 &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt; 순서로 배열에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f19211fbe1e7f4c1e87ed754cadc6b0cc14be4e6" translate="yes" xml:space="preserve">
          <source>The two nodes are disconnected.</source>
          <target state="translated">두 노드의 연결이 끊어졌습니다.</target>
        </trans-unit>
        <trans-unit id="f398c8744bfdea0ef40d2e2e1377fe86aabbce87" translate="yes" xml:space="preserve">
          <source>The two nodes are disconnected. Order between disconnected nodes is always implementation-specific.</source>
          <target state="translated">두 노드의 연결이 끊어졌습니다. 연결이 끊긴 노드 간의 순서는 항상 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1ec974b380762a0bf9692b16ac0cfa7083a8a76b" translate="yes" xml:space="preserve">
          <source>The two nodes are of the same type.</source>
          <target state="translated">두 노드는 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4a8e8cdc02eb816448907e6ad7e73c37517a03bf" translate="yes" xml:space="preserve">
          <source>The two possible authentication types for a resource.</source>
          <target state="translated">자원에 대한 두 가지 가능한 인증 유형.</target>
        </trans-unit>
        <trans-unit id="8562722983b5297a255d72d065fc4efeeada15b3" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d9e7a9794b9c62912ab9b974fd3e586ad8ce077c" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/double#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Double.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 간주되는 나머지 요소의 두 시퀀스는 점이 동일합니다. 이 방법은 두 개의 이중 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 같은 것으로 간주합니다 if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/double#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Double.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e9cc57517a9438e11a17414782fcda2ca6c93d7" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Double.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다. 이 방법은 두 개의 이중 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Double.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다. .</target>
        </trans-unit>
        <trans-unit id="677d0a0fc0aa5495b5b9a1ef2701a071bddcad42" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/float#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Float.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 간주되는 나머지 요소의 두 시퀀스는 점이 동일합니다. 이 방법은 두 개의 float 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 같은 것으로 간주합니다. if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/float#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Float.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f74bb945ec6a22ab7838a324a183e657cee9de65" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Float.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다. 이 방법은 두 개의 float 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Float.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="97983c767ff42d4647c2b3d8afd3922e461ec55b" translate="yes" xml:space="preserve">
          <source>The type</source>
          <target state="translated">유형</target>
        </trans-unit>
        <trans-unit id="8ac14b02e6f129743d1f8a28d779dc984a66b294" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; may be either a primitive or reference. Since type &lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt; is erased in the method handle representation to the raw type &lt;code&gt;Iterator&lt;/code&gt;, the &lt;code&gt;iteratedLoop&lt;/code&gt; combinator adjusts the leading argument type for &lt;code&gt;body&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt; as if by the &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; conversion method. Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur as the result of dynamic conversions performed by &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandle.asType(MethodType)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 기본 또는 참조 일 수 있습니다. 타입 때문에 &lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt; 원시 형태에있어서 핸들 표현 소거 &lt;code&gt;Iterator&lt;/code&gt; 상기 &lt;code&gt;iteratedLoop&lt;/code&gt; 의 연결자위한 주요한 인자 타입 조정 &lt;code&gt;body&lt;/code&gt; 에 &lt;code&gt;Object&lt;/code&gt; 바이 것처럼 &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 의&lt;/a&gt; 변환 방법. 따라서 루프가 실행될 때 잘못된 유형의 반복자가 나타나면 &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandle.asType(MethodType)&lt;/code&gt; &lt;/a&gt; 의해 수행 된 동적 변환의 결과로 런타임 예외가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d9c3e5a2e1ee1b8623092bbd4a2ad433a0d8102" translate="yes" xml:space="preserve">
          <source>The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain &lt;code&gt;invoke&lt;/code&gt; and &lt;code&gt;asType&lt;/code&gt; requests can lead to trailing positional arguments being collected into target's trailing parameter. Also, the &lt;a href=&quot;methodtype#lastParameterType()&quot;&gt;last parameter type&lt;/a&gt; of the adapter will be &lt;code&gt;arrayType&lt;/code&gt;, even if the target has a different last parameter type.</source>
          <target state="translated">어댑터의 유형 및 동작은 특정 &lt;code&gt;invoke&lt;/code&gt; 및 &lt;code&gt;asType&lt;/code&gt; 요청이 대상의 후행 매개 변수에 수집되는 후행 위치 인수로 이어질 수 있다는 점을 제외하면 대상의 유형 및 동작 과 동일 합니다. 또한 대상에 다른 마지막 매개 변수 유형이 있더라도 어댑터 의 &lt;a href=&quot;methodtype#lastParameterType()&quot;&gt;마지막 매개 변수 유형&lt;/a&gt; 은 &lt;code&gt;arrayType&lt;/code&gt; 이됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0ea19c65ec77bbed855a0ec57d24fe61a6f3cfc" translate="yes" xml:space="preserve">
          <source>The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain &lt;code&gt;invoke&lt;/code&gt; and &lt;code&gt;asType&lt;/code&gt; requests can lead to trailing positional arguments being collected into target's trailing parameter. Also, the last parameter type of the adapter will be &lt;code&gt;arrayType&lt;/code&gt;, even if the target has a different last parameter type.</source>
          <target state="translated">어댑터의 유형 및 작동은 대상의 유형 및 작동과 동일하지만 특정 &lt;code&gt;invoke&lt;/code&gt; 및 &lt;code&gt;asType&lt;/code&gt; 요청으로 인해 후행 위치 인수가 대상의 후행 매개 변수로 수집 될 수 있습니다. 또한 어댑터의 마지막 매개 변수 유형은 &lt;code&gt;arrayType&lt;/code&gt; 입니다. 대상의 마지막 매개 변수 유형이 다른 경우에도 입니다.</target>
        </trans-unit>
        <trans-unit id="b9274643a3bf4ca4addb78cb6a98b74268f87044" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">유형과 인코딩은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt;CertificateFactory 섹션&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt;CertPath Encodings 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 유형 또는 인코딩이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff6bb0cadf07db39ec6be40e5dae1eed885b4134" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">유형 및 인코딩은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt;CertificateFactory 섹션&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt;CertPath 인코딩 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 문서를 참조하여 다른 유형 또는 인코딩이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c6b186bc7aea698445dc40383caf4bf30781283e" translate="yes" xml:space="preserve">
          <source>The type associated with all custom cursors.</source>
          <target state="translated">모든 사용자 정의 커서와 연관된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8a0aad1afcd781464b76996d424e8348249f28ac" translate="yes" xml:space="preserve">
          <source>The type fingerprint that is set to indicate serialization compatibility with a previous version of the type.</source>
          <target state="translated">이전 버전의 유형과의 직렬화 호환성을 나타내도록 설정된 유형 지문입니다.</target>
        </trans-unit>
        <trans-unit id="93dbc281a6a1652e30aac933243bf7afad98e3d0" translate="yes" xml:space="preserve">
          <source>The type information associated with this attribute.</source>
          <target state="translated">이 속성과 연관된 유형 정보입니다.</target>
        </trans-unit>
        <trans-unit id="6035b72b31597b588131e4a84cda217fb3253aca" translate="yes" xml:space="preserve">
          <source>The type information associated with this attribute. While the type information contained in this attribute is guarantee to be correct after loading the document or invoking &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;, &lt;code&gt;schemaTypeInfo&lt;/code&gt; may not be reliable if the node was moved.</source>
          <target state="translated">이 속성과 연관된 유형 정보입니다. 이 속성에 포함되는 타입 정보가 보증 문서를 로딩하거나 발신 한 후 올바른 것으로 동안 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; , &lt;code&gt;schemaTypeInfo&lt;/code&gt; 는 노드가 이동 한 경우 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e61ac73041fcfd164a7302e03c2c4eb5aa4c9644" translate="yes" xml:space="preserve">
          <source>The type information associated with this element.</source>
          <target state="translated">이 요소와 관련된 유형 정보입니다.</target>
        </trans-unit>
        <trans-unit id="47aacc9e53df6990e6cd21e34ac8f46081f60e02" translate="yes" xml:space="preserve">
          <source>The type is a &lt;code&gt;String&lt;/code&gt; that identifies the type of &lt;code&gt;Certificate&lt;/code&gt;s in the certification path. For each certificate &lt;code&gt;cert&lt;/code&gt; in a certification path &lt;code&gt;certPath&lt;/code&gt;, &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">유형은 인증 경로에서 &lt;code&gt;Certificate&lt;/code&gt; 유형을 식별 하는 &lt;code&gt;String&lt;/code&gt; 입니다 . 각 인증서의 경우 &lt;code&gt;cert&lt;/code&gt; 인증 경로에서 &lt;code&gt;certPath&lt;/code&gt; , &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; 해야 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3992f3a6c4f1b89ac824af3b12e6534482315701" translate="yes" xml:space="preserve">
          <source>The type is an interface type and not an annotation type, enum, or class.</source>
          <target state="translated">형식은 인터페이스 형식이며 주석 형식, 열거 형 또는 클래스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e26cf268f40425be61bd9fa65b49f0d6fe506153" translate="yes" xml:space="preserve">
          <source>The type name corresponding to the supplied type constant.</source>
          <target state="translated">제공된 유형 상수에 해당하는 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dbbee8087c3ba28222fa95426623818374828807" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt;&lt;code&gt;Redirect.INHERIT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt; &lt;code&gt;Redirect.INHERIT&lt;/code&gt; &lt;/a&gt; 의 유형입니다. .</target>
        </trans-unit>
        <trans-unit id="c0ad9640a3999591dd1d2029f7ecfcb72b0d98b2" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; 의 유형 .</target>
        </trans-unit>
        <trans-unit id="e8d2db58ec658df2f7f6c171781a38ba46c53399" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;JOIN&lt;/code&gt; to be established is determined by setting one of the &lt;code&gt;JoinRowSet&lt;/code&gt; constants using the method &lt;code&gt;setJoinType&lt;/code&gt;. The following SQL &lt;code&gt;JOIN&lt;/code&gt; types can be set:</source>
          <target state="translated">설정할 &lt;code&gt;JOIN&lt;/code&gt; 의 유형은 &lt;code&gt;setJoinType&lt;/code&gt; 메소드를 사용하여 &lt;code&gt;JoinRowSet&lt;/code&gt; 상수 중 하나를 설정하여 결정 됩니다 . 다음 SQL &lt;code&gt;JOIN&lt;/code&gt; 유형을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56f95d6997ec10a60d61b49368aad5c85b0c93d" translate="yes" xml:space="preserve">
          <source>The type of MIDI file.</source>
          <target state="translated">MIDI 파일의 타입입니다.</target>
        </trans-unit>
        <trans-unit id="127e2dcfa435659f04a5c90d26c476f9ace2f0e1" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;processbuilder.redirect&quot;&gt;&lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect&quot;&gt; &lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt; &lt;/a&gt; 의 유형 .</target>
        </trans-unit>
        <trans-unit id="19a111fbf1a4085482090a96e6a31a6562e4dbf5" translate="yes" xml:space="preserve">
          <source>The type of a metric, one of the strings &quot;counter&quot; or &quot;gauge&quot;. A metric is a measurement exported by an MBean, usually an attribute but sometimes the result of an operation. A metric that is a &lt;em&gt;counter&lt;/em&gt; has a value that never decreases except by being reset to a starting value. Counter metrics are almost always non-negative integers. An example might be the number of requests received. A metric that is a &lt;em&gt;gauge&lt;/em&gt; has a numeric value that can increase or decrease. Examples might be the number of open connections or a cache hit rate or a temperature reading.</source>
          <target state="translated">문자열 &quot;counter&quot;또는 &quot;gauge&quot;중 하나의 메트릭 유형입니다. 메트릭은 일반적으로 속성이지만 때로는 작업 결과 인 MBean에서 내 보낸 측정 값입니다. &lt;em&gt;카운터 인&lt;/em&gt; 메트릭 은 시작 값으로 재설정하지 않는 한 절대 감소하지 않는 값을 갖습니다. 카운터 메트릭은 거의 항상 음이 아닌 정수입니다. 수신 된 요청 수를 예로들 수 있습니다. &lt;em&gt;게이지 인&lt;/em&gt; 측정 항목&lt;em&gt;&lt;/em&gt; 에는 증가 또는 감소 할 수있는 숫자 값이 있습니다. 열린 연결 수 또는 캐시 적중률 또는 온도 판독 값이 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="516804b0e5437ce278d19350e7c4ad6ec7d75a1d" translate="yes" xml:space="preserve">
          <source>The type of etch to be drawn by the border.</source>
          <target state="translated">테두리로 그릴 에칭 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a72a6dcb29c4761d0c066bb8800e0746542672cb" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#appendTo(java.io.File)&quot;&gt;&lt;code&gt;Redirect.appendTo(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#appendTo(java.io.File)&quot;&gt; &lt;code&gt;Redirect.appendTo(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="aa5066ac5677ba94a729db439698f3123b5e4800" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt;&lt;code&gt;Redirect.appendTo(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt; &lt;code&gt;Redirect.appendTo(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3a8c1186e5832691f4a75427966c37b78296c9e6" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#from(java.io.File)&quot;&gt;&lt;code&gt;Redirect.from(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#from(java.io.File)&quot;&gt; &lt;code&gt;Redirect.from(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="b6c13fdf29d3471638747b7836301b890025ac8d" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt;&lt;code&gt;Redirect.from(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt; &lt;code&gt;Redirect.from(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="23b43930e30ca0b29892d575065e9b7d29d48983" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#to(java.io.File)&quot;&gt;&lt;code&gt;Redirect.to(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#to(java.io.File)&quot;&gt; &lt;code&gt;Redirect.to(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="1b7eaaee0ed7fe469cb15b4032d95ee3779bbd61" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt;&lt;code&gt;Redirect.to(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt; &lt;code&gt;Redirect.to(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형 .</target>
        </trans-unit>
        <trans-unit id="62d360876f66c4619f7a66dbb6e3f42e2c3d1fb3" translate="yes" xml:space="preserve">
          <source>The type of the call site is permanently set to the given type.</source>
          <target state="translated">호출 사이트의 유형은 지정된 유형으로 영구적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="84d0df6847a2c34f170737cbf47a403351061610" translate="yes" xml:space="preserve">
          <source>The type of the context is implementation-dependent. If the value is null, the operation must have no dependency on the context, otherwise an XPathExpressionException will be thrown. For the purposes of evaluating XPath expressions, a DocumentFragment is treated like a Document node.</source>
          <target state="translated">컨텍스트 유형은 구현에 따라 다릅니다. 값이 null이면 작업에 컨텍스트에 대한 종속성이 없어야합니다. 그렇지 않으면 XPathExpressionException이 throw됩니다. XPath 표현식을 평가하기 위해 DocumentFragment는 Document 노드처럼 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="85c774280ae0c09e2cb54be7281c7ab8c6b5e39a" translate="yes" xml:space="preserve">
          <source>The type of the context is usually &lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 유형은 일반적으로 &lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f38c67fdfb625338235f720fe145ed3f504d4e9" translate="yes" xml:space="preserve">
          <source>The type of the entity requesting authentication.</source>
          <target state="translated">인증을 요청하는 엔티티의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c4ac73bf470d2de540cc66c6d49c584580982b87" translate="yes" xml:space="preserve">
          <source>The type of the entity.</source>
          <target state="translated">엔티티의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="978109c7e8978b8fd7fbcdabcf48636f10ce3310" translate="yes" xml:space="preserve">
          <source>The type of the event.</source>
          <target state="translated">이벤트 유형</target>
        </trans-unit>
        <trans-unit id="05a0aedd8679b410dfd61aa7d127e3dcd930c83d" translate="yes" xml:space="preserve">
          <source>The type of the new method handle will drop the types for the bound parameters from the original target type, since the new method handle will no longer require those arguments to be supplied by its callers.</source>
          <target state="translated">새로운 메소드 핸들은 호출자가 호출 한 인수를 더 이상 제공 할 필요가 없으므로 새로운 메소드 핸들의 유형은 원래 대상 유형에서 바운드 매개 변수의 유형을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8627cf93d9b68632081d77f43eec00b2a809ba9f" translate="yes" xml:space="preserve">
          <source>The type of the new target must be &lt;a href=&quot;methodtype#equals(java.lang.Object)&quot;&gt;equal to&lt;/a&gt; the type of the old target.</source>
          <target state="translated">새 대상 의 유형은 이전 대상의 유형 &lt;a href=&quot;methodtype#equals(java.lang.Object)&quot;&gt;과 동일&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="689485c1e5985a3231bd5ec529f55e5aa04a546f" translate="yes" xml:space="preserve">
          <source>The type of the new target must be &lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;equal to&lt;/a&gt; the type of the old target.</source>
          <target state="translated">새 대상 의 유형은 이전 대상의 유형 &lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;과 같아야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a890ec2d11b23f48d0302a6f1ff678bb8116b7db" translate="yes" xml:space="preserve">
          <source>The type of the observed attribute is not correct.</source>
          <target state="translated">관찰 된 속성의 유형이 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c37d7b8236ac8a0ff81b6ebd996e68b65203530e" translate="yes" xml:space="preserve">
          <source>The type of the returned invoker will not be the given &lt;code&gt;type&lt;/code&gt;, but rather will have all parameters except the first &lt;code&gt;leadingArgCount&lt;/code&gt; replaced by a single array of type &lt;code&gt;Object[]&lt;/code&gt;, which will be the final parameter.</source>
          <target state="translated">반환 된 호출자의 유형은 지정된 &lt;code&gt;type&lt;/code&gt; 이 아니라 첫 번째 &lt;code&gt;leadingArgCount&lt;/code&gt; 제외한 모든 매개 변수를 &lt;code&gt;Object[]&lt;/code&gt; 유형의 단일 배열로 대체 하며 최종 매개 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="3713b00b65f5a644a274c8162bd2331606919143" translate="yes" xml:space="preserve">
          <source>The type of this event.</source>
          <target state="translated">이 이벤트의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="efb86a4d23b927b4d7779a5f3229d3b046c17f0c" translate="yes" xml:space="preserve">
          <source>The types are compared for equality with their case ignored.</source>
          <target state="translated">유형은 대소 문자를 무시하고 동일한 지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="59391c7d69614504e0086f4dff6684db3e9ee2b5" translate="yes" xml:space="preserve">
          <source>The types of notifications emitted by &lt;code&gt;MemoryMXBean&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;MemoryMXBean&lt;/code&gt; 에서 생성 된 알림 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="444baca227e7a21fbc93ead1d887a79a164df63b" translate="yes" xml:space="preserve">
          <source>The typical language value is a two or three-letter language code as defined in ISO639.</source>
          <target state="translated">일반적인 언어 값은 ISO639에 정의 된 2 자리 또는 3 자리 언어 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5c660145e6f646b3735ac4f7205ca9ace38822eb" translate="yes" xml:space="preserve">
          <source>The typical region value is a two-letter ISO 3166 code or a three-digit UN M.49 area code.</source>
          <target state="translated">일반적인 지역 값은 2 자리 ISO 3166 코드 또는 3 자리 UN M.49 지역 코드입니다.</target>
        </trans-unit>
        <trans-unit id="17cdcc250877b85946cb955da511369645e967cc" translate="yes" xml:space="preserve">
          <source>The typical script value is a four-letter script code as defined by ISO 15924.</source>
          <target state="translated">일반적인 스크립트 값은 ISO 15924에 의해 정의 된 4 자리 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="e493e7eb7efdddc83f3fbdc66df8a51d56849ee7" translate="yes" xml:space="preserve">
          <source>The underline affects both the visual bounds and the outline of the text.</source>
          <target state="translated">밑줄은 텍스트의 시각적 경계와 윤곽 모두에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="20b0ef642374b714b39ebc2873baf17c5b426b78" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;BoundedRangeModel&lt;/code&gt; handles any mathematical issues arising from assigning faulty values. See the &lt;code&gt;BoundedRangeModel&lt;/code&gt; documentation for details.</source>
          <target state="translated">기본 &lt;code&gt;BoundedRangeModel&lt;/code&gt; 은 잘못된 값을 할당하여 발생하는 모든 수학적 문제를 처리합니다. 자세한 내용은 &lt;code&gt;BoundedRangeModel&lt;/code&gt; 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="121414ae83882d6978c3061ae2ccaf0b4cd3a7f5" translate="yes" xml:space="preserve">
          <source>The underlying character-input stream.</source>
          <target state="translated">기본 문자 입력 스트림</target>
        </trans-unit>
        <trans-unit id="66e9f85ce07195fbd2dc5d2f06d3273076e5b33d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream of this &lt;code&gt;PrintWriter&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;PrintWriter&lt;/code&gt; 기본이되는 문자 출력 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="997090c1014b7704de737ddf5326441d3f6eab7d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream.</source>
          <target state="translated">기본 문자 출력 스트림</target>
        </trans-unit>
        <trans-unit id="48e3e0bfbed1be484de7c256629bbfc344226e62" translate="yes" xml:space="preserve">
          <source>The underlying field's value is obtained as follows:</source>
          <target state="translated">기본 필드의 값은 다음과 같이 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6b7dedd2916acda5e4ddd9bf5218b5756a52e4ca" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dsts ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 및 &lt;code&gt;dsts ByteBuffer&lt;/code&gt; 가 사용하는 기본 메모리 는 동일하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="028d275e77138b148a731ed31ec7168887398dc7" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;srcs&lt;/code&gt; and &lt;code&gt;dst ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;srcs&lt;/code&gt; 및 &lt;code&gt;dst ByteBuffer&lt;/code&gt; 에서 사용하는 기본 메모리 는 동일하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b2dd44c58a8235d0ae8f513f91b8369937ea3aba" translate="yes" xml:space="preserve">
          <source>The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began.</source>
          <target state="translated">기본 운영 체제는 선택 작업이 시작된 시점에 키의 관심 세트로 식별 된 작업을 수행하기 위해 나머지 각 채널의 준비 상태에 대한 업데이트를 위해 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="8bcc6a3ebcd69bf1c22f30e41fee2405130dbb8f" translate="yes" xml:space="preserve">
          <source>The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began. For a channel that is ready for at least one such operation, one of the following two actions is performed:</source>
          <target state="translated">기본 오퍼레이팅 시스템은 선택 조작이 시작된 순간 키의 관심 세트로 식별 된 오퍼레이션을 수행하기 위해 나머지 각 채널의 준비 상태에 대한 업데이트를 쿼리합니다. 이러한 작업을 하나 이상 준비한 채널의 경우 다음 두 작업 중 하나가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5fac40f1f061f6b657772e9f893915f23de48bf5" translate="yes" xml:space="preserve">
          <source>The underlying output stream to be filtered.</source>
          <target state="translated">필터링 할 기본 출력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="1a5764b11a39a7b859946ca022bc7546c2758d6c" translate="yes" xml:space="preserve">
          <source>The underlying signing algorithm is designated by the Signature object passed to the constructor and the &lt;code&gt;verify&lt;/code&gt; method. A typical usage for signing is the following:</source>
          <target state="translated">기본 서명 알고리즘은 생성자 및 &lt;code&gt;verify&lt;/code&gt; 메서드에 전달 된 Signature 객체로 지정됩니다 . 서명의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a0c62e15b608a731329638c7175e259e5b752ff" translate="yes" xml:space="preserve">
          <source>The underscore character &lt;code&gt;'_'&lt;/code&gt; (&lt;code&gt;'\u005f'&lt;/code&gt;, &lt;small&gt;LOW LINE&lt;/small&gt;).</source>
          <target state="translated">밑줄 문자 &lt;code&gt;'_'&lt;/code&gt; ( &lt;code&gt;'\u005f'&lt;/code&gt; , &lt;small&gt;LOW LINE&lt;/small&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c1ffa4ad50bf6adcf296f52ce5cec96c22f7318" translate="yes" xml:space="preserve">
          <source>The undo/redo presentation name</source>
          <target state="translated">실행 취소 / 다시 실행 프레젠테이션 이름</target>
        </trans-unit>
        <trans-unit id="c48b40a9584e8f5d48650d23e68347fe38a9dee0" translate="yes" xml:space="preserve">
          <source>The union filter operation.</source>
          <target state="translated">통합 필터 작업입니다.</target>
        </trans-unit>
        <trans-unit id="cae92f9fce61041c312223fede1e34d5be987d37" translate="yes" xml:space="preserve">
          <source>The uniquely named method is allowed to be multiply declared, with distinct type descriptors. (E.g., it can be overloaded, or can possess bridge methods.) All such declarations are connected directly to the target method handle. Argument and return types are adjusted by &lt;code&gt;asType&lt;/code&gt; for each individual declaration.</source>
          <target state="translated">고유 한 이름의 메소드는 고유 한 유형 설명 자로 여러 번 선언 될 수 있습니다. (예를 들어, 오버로드되거나 브릿지 메소드를 소유 할 수 있습니다.) 이러한 모든 선언은 대상 메소드 핸들에 직접 연결됩니다. 인수 및 반환 유형은 &lt;code&gt;asType&lt;/code&gt; 에 의해 조정됩니다 . 각 개별 선언에 대해 .</target>
        </trans-unit>
        <trans-unit id="e2f80b55f26435dc0cbc6eebb8950484c5bf36aa" translate="yes" xml:space="preserve">
          <source>The unit decrement adjustment type.</source>
          <target state="translated">단위 감소 조정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="52717aab8cd685857c2c2638d23ee7812a035e0d" translate="yes" xml:space="preserve">
          <source>The unit increment adjustment type.</source>
          <target state="translated">단위 증분 조정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1c7bdb009b913ad14ea197d918b5e289949be56f" translate="yes" xml:space="preserve">
          <source>The unit increment is the value that is added or subtracted when the user activates the unit increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The unit increment must be greater than zero.</source>
          <target state="translated">단위 증분은 일반적으로 스크롤 막대가 조정 이벤트로 수신하는 마우스 또는 키보드 제스처를 통해 사용자가 스크롤 막대의 단위 증분 영역을 활성화 할 때 더하거나 빼는 값입니다. 단위 증분은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="701b9e479da0e3a00cf653bd228ba4360e20dee1" translate="yes" xml:space="preserve">
          <source>The unit increment is the value that is added or subtracted when the user activates the unit increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The unit increment must be greater than zero. Attempts to set the unit increment to a value lower than 1 will result in a value of 1 being set.</source>
          <target state="translated">단위 증분은 일반적으로 스크롤 막대가 조정 이벤트로 수신하는 마우스 또는 키보드 제스처를 통해 사용자가 스크롤 막대의 단위 증분 영역을 활성화 할 때 더하거나 빼는 값입니다. 단위 증분은 0보다 커야합니다. 단위 증분을 1보다 낮은 값으로 설정하려고하면 값 1이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="de9b1e61ecdfc95fda63a3a7e8d69c26ea6cf658" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all &lt;a href=&quot;temporal/chronounit#isTimeBased()&quot;&gt;time-based units on {@code ChronoUnit}&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other ChronoUnits throw an exception.</source>
          <target state="translated">단위는 나머지없이 표준 일의 길이로 분할 되는 &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;기간&lt;/a&gt; 을 가져야합니다 . 여기에는 &lt;a href=&quot;temporal/chronounit#isTimeBased()&quot;&gt;{@code ChronoUnit}&lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; 의&lt;/a&gt; 모든 시간 기반 단위가 포함됩니다 . 다른 ChronoUnit은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="234aa0f061723f0a03a2a6d208b3bc5bcf171626" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all supplied time units on &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other units throw an exception.</source>
          <target state="translated">단위는 나머지없이 표준 일의 길이로 분할 되는 &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;기간&lt;/a&gt; 을 가져야합니다 . 여기에는 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 에 제공된 모든 시간 단위가 포함됩니다 . 다른 유닛은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5191f12612fb84b7bbf9829ac12d3dce772f7d2d" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all supplied time units on &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other units throw an exception.</source>
          <target state="translated">단위는 남은 시간없이 표준 날짜의 길이로 나눌 수있는 &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;기간&lt;/a&gt; 이 있어야합니다 . 여기에는 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 에 제공된 모든 시간 단위가 포함됩니다 . 다른 부대는 예외를 던진다.</target>
        </trans-unit>
        <trans-unit id="968e96267f6d7165d1ebba6675f71b714928a68b" translate="yes" xml:space="preserve">
          <source>The unit of structure (i.e. a node of the tree) is referred to by the &lt;a href=&quot;element&quot;&gt;Element&lt;/a&gt; interface. Each Element can be tagged with a set of attributes. These attributes (name/value pairs) are defined by the &lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt; interface.</source>
          <target state="translated">구조 단위 (즉, 트리의 노드)는 &lt;a href=&quot;element&quot;&gt;Element&lt;/a&gt; 인터페이스에서 참조됩니다. 각 요소는 속성 세트로 태그를 지정할 수 있습니다. 이러한 속성 (이름 / 값 쌍)은 &lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt; 인터페이스에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b14bacca6f7c6b6b2bf4f146f5a2674ddf076dea" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;#getRangeUnit()&quot;&gt;&lt;code&gt;getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변하는 기간입니다. 예를 들어 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;#getRangeUnit()&quot;&gt; &lt;code&gt;getRangeUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5122174d5f83d404ea9a42f52e7c1c4179e0a65a" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변화하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ac0d6412e7c41ea9d12640bb3ba8932b0b5834" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변화하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;getRangeUnit()&lt;/code&gt; &lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="1f111a51a42acb493693efa131e93c6ce9b6b10b" translate="yes" xml:space="preserve">
          <source>The unit that represents week-based-years for the purpose of addition and subtraction.</source>
          <target state="translated">덧셈과 뺄셈의 목적으로 주별 연도를 나타내는 단위입니다.</target>
        </trans-unit>
        <trans-unit id="27ed7bbeff7184c6ce008c19d55f08c8ed276069" translate="yes" xml:space="preserve">
          <source>The unit works using double dispatch. Client code calls methods on a date-time like &lt;code&gt;LocalDateTime&lt;/code&gt; which check if the unit is a &lt;code&gt;ChronoUnit&lt;/code&gt;. If it is, then the date-time must handle it. Otherwise, the method call is re-dispatched to the matching method in this interface.</source>
          <target state="translated">이 장치는 이중 디스패치를 ​​사용하여 작동합니다. 클라이언트 코드 는 단위가 &lt;code&gt;ChronoUnit&lt;/code&gt; 인지 확인하는 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 같은 날짜-시간에 메소드를 호출합니다 . 그렇다면 날짜-시간이 처리해야합니다. 그렇지 않은 경우, 메소드 호출은이 인터페이스에서 일치하는 메소드로 다시 디스패치됩니다.</target>
        </trans-unit>
        <trans-unit id="81a001136d3eb214fc80d07847b64a02ef39f1b1" translate="yes" xml:space="preserve">
          <source>The units in which an attribute, parameter, or operation return value is measured, for example &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; or &lt;code&gt;
 &quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">속성, 매개 변수 또는 작업 반환 값이 측정되는 &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; 입니다 (예 : &quot;bytes&quot; 또는 &lt;code&gt; &quot;seconds&quot;&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="337c6ca2e533607b16bd03301e040526d12b467c" translate="yes" xml:space="preserve">
          <source>The units in which an attribute, parameter, or operation return value is measured, for example &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; or &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">속성은, 파라미터 또는 동작 리턴 값은, 예를 들어, 측정 된 단위 &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3bd78e3001a8947a68a5cbb3ac87fe1fde628c2" translate="yes" xml:space="preserve">
          <source>The units used for the attributes &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;totalSize&lt;/code&gt; are not specified and can be implementation and input dependent.</source>
          <target state="translated">속성 &lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;totalSize&lt;/code&gt; 에 사용되는 단위 는 지정되지 않았으며 구현 및 입력에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5d174c8b0683065fbf044b493c3ef8ed79dc428" translate="yes" xml:space="preserve">
          <source>The unknown conversion.</source>
          <target state="translated">알 수없는 변환입니다.</target>
        </trans-unit>
        <trans-unit id="c132eeb914111eef836f7b17954aa6d06ab7144e" translate="yes" xml:space="preserve">
          <source>The unmatched format specifier</source>
          <target state="translated">일치하지 않는 형식 지정자</target>
        </trans-unit>
        <trans-unit id="9c3ed1d8f9191384bc27e1c770f53546798ad3be" translate="yes" xml:space="preserve">
          <source>The unnamed Module for this class loader</source>
          <target state="translated">이 클래스 로더의 이름없는 모듈</target>
        </trans-unit>
        <trans-unit id="89d7d1f2a0c6d2d00918acd6dc9254422a7dc31f" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file.</source>
          <target state="translated">압축 해제 엔진은 압축 된 스트림을 JAR 파일로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f17f3d929a42461873323e53b16339238f41d1f2" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newUnpacker()&quot;&gt;&lt;code&gt;Pack200.newUnpacker()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">언 패커 엔진은 압축 된 스트림을 JAR 파일로 변환합니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newUnpacker()&quot;&gt; &lt;code&gt;Pack200.newUnpacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2a58d4aa16389063e1d4593b8080b538ec67075" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newUnpacker--&quot;&gt;&lt;code&gt;Pack200.newUnpacker()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">압축 해제 엔진은 압축 된 스트림을 JAR 파일로 변환합니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newUnpacker--&quot;&gt; &lt;code&gt;Pack200.newUnpacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b7887467cb1970d34f42e962bd76f284036d6cd" translate="yes" xml:space="preserve">
          <source>The unpacker's progress as a percentage, as periodically updated by the unpacker.</source>
          <target state="translated">언 패커가 주기적으로 업데이트하는 언 패커의 진행률 (백분율)입니다.</target>
        </trans-unit>
        <trans-unit id="101f5ee99703bb9848ebdb64b9a981d2574364ad" translate="yes" xml:space="preserve">
          <source>The unpacker's progress as a percentage, as periodically updated by the unpacker. Values of 0 - 100 are normal, and -1 indicates a stall. Progress can be monitored by polling the value of this property.</source>
          <target state="translated">언 팩커가 주기적으로 업데이트 한 언 팩커 진행률 (백분율)입니다. 0-100의 값은 정상이며 -1은 중단을 나타냅니다. 이 특성의 값을 폴링하여 진행 상황을 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b61a518de7509b59d212e291756906cb8ecb6f4" translate="yes" xml:space="preserve">
          <source>The unqualified name of a proxy class is unspecified. The space of class names that begin with the string &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; should be, however, reserved for proxy classes.</source>
          <target state="translated">프록시 클래스의 규정되지 않은 이름이 지정되지 않았습니다. 문자열 &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; 시작하는 클래스 이름의 공간 프록시 클래스 용으로 예약되어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb7964c4b4dc617463023ff4866e3bcc872cfffc" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 음수가 있으면 2에 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 추가 선행 &lt;code&gt;0&lt;/code&gt; 없이 2 진수 (기본 2)의 ASCII 숫자 문자열로 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="90b3bb257b666565307d76750b50c74e6f924841" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 음수가 있으면 2에 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 16 진수 (기본 16)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="43fc0c46437e63e9c1bc27fd8276c60615fc1eec" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 음수가 있으면 2에 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 추가 선행 &lt;code&gt;0&lt;/code&gt; 없이 8 진수 (기본 8)의 ASCII 숫자 문자열로 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="9ef8dc1e7e596de25447c72effc2b78e2e9eda78" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값 인수 플러스 2 &lt;sup&gt;32&lt;/sup&gt; 인자가 음수이면; 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 2 진수 (기본 2)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="054a6f2331c22a50fc40ea825d5bbe23a0c2752a" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값 인수 플러스 2 &lt;sup&gt;32&lt;/sup&gt; 인자가 음수이면; 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 16 진수 (기본 16)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4adf2f37edf13f4b7e5a873d42af291756d4bd27" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값 인수 플러스 2 &lt;sup&gt;32&lt;/sup&gt; 인자가 음수이면; 그렇지 않으면 인수와 같습니다. 이 값은 추가 선행 &lt;code&gt;0&lt;/code&gt; 없이 8 진수 (기본 8)의 ASCII 숫자 문자열로 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="6060d22783b5de73678a070487c0c6a5f000dbdf" translate="yes" xml:space="preserve">
          <source>The unusual compilation and linkage behavior of &lt;code&gt;invokeExact&lt;/code&gt; and plain &lt;code&gt;invoke&lt;/code&gt; is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;. As defined in the Java Language Specification, a signature polymorphic method is one which can operate with any of a wide range of call signatures and return types.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 및 일반 &lt;code&gt;invoke&lt;/code&gt; 의 비정상적인 컴파일 및 연결 동작은 &lt;em&gt;시그니처 다형성&lt;/em&gt; 이라는 용어로 참조됩니다 . Java 언어 사양에 정의 된대로 서명 다형성 방법은 광범위한 호출 서명 및 반환 유형과 함께 작동 할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="40b4d5652cfa127fc330a96253acd13ba3551734" translate="yes" xml:space="preserve">
          <source>The update event type.</source>
          <target state="translated">업데이트 이벤트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="29059f1033a4f76e60bdc626ae645add4bfc3353" translate="yes" xml:space="preserve">
          <source>The update level.</source>
          <target state="translated">업데이트 수준입니다.</target>
        </trans-unit>
        <trans-unit id="d313d97487f3c7f3cbc749779eb54e77639e2d72" translate="yes" xml:space="preserve">
          <source>The updated CompositeName, not a new one. Cannot be null.</source>
          <target state="translated">새 이름이 아닌 업데이트 된 CompositeName입니다. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a42c811bccd6dd7e2f5a6b9d96175190ed03196" translate="yes" xml:space="preserve">
          <source>The updated CompoundName, not a new one. Cannot be null.</source>
          <target state="translated">새로운 CompoundName이 아닌 업데이트 된 CompoundName. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0a53b9e80856c6692659d4301653ca2c511f3f2" translate="yes" xml:space="preserve">
          <source>The updated LdapName, not a new instance. Cannot be null.</source>
          <target state="translated">새 인스턴스가 아닌 업데이트 된 LdapName null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ff1724ae2775960bc3b129d71cefa43e6c05193" translate="yes" xml:space="preserve">
          <source>The updated name (not a new instance).</source>
          <target state="translated">업데이트 된 이름 (새 인스턴스가 아님).</target>
        </trans-unit>
        <trans-unit id="355083b7f57eecb4574c96df4e2dcb55b6e39ceb" translate="yes" xml:space="preserve">
          <source>The updated time instant is then converted back into a &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object and used to update the given &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">업데이트 된 시간 인스턴트는 다시 &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 로 변환 되고 주어진 &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 를 업데이트하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0baad8b72ddb35a83879b234fb143110d6defdf2" translate="yes" xml:space="preserve">
          <source>The updater methods are used to update column values in the current row or the insert row. The updater methods do not update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.</source>
          <target state="translated">업데이트 프로그램 메서드는 현재 행 또는 삽입 행의 열 값을 업데이트하는 데 사용됩니다. 업데이터 메서드는 기본 데이터베이스를 업데이트하지 않습니다. 대신 &lt;code&gt;updateRow&lt;/code&gt; 또는 &lt;code&gt;insertRow&lt;/code&gt; 메소드가 데이터베이스를 업데이트하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f2bcc2d49c180e5baf0e82f6c9fcc3ed64f68df8" translate="yes" xml:space="preserve">
          <source>The updater methods may be used in two ways:</source>
          <target state="translated">업데이터 메서드는 두 가지 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c660520ce3264961f8c352c1ced2cca916613b71" translate="yes" xml:space="preserve">
          <source>The upgrade module path</source>
          <target state="translated">업그레이드 모듈 경로</target>
        </trans-unit>
        <trans-unit id="7e25e2dbc84508e95baa5cc07d894f889b8081b4" translate="yes" xml:space="preserve">
          <source>The upgrade module path. This path contains compiled definitions of modules that will be observed in preference to the compiled definitions of any</source>
          <target state="translated">업그레이드 모듈 경로. 이 경로에는 모든 모듈의 컴파일 된 정의보다 우선적으로 관찰되는 모듈의 컴파일 된 정의가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="52b9900dc95e3fff929d15c46c76d6028fddcc38" translate="yes" xml:space="preserve">
          <source>The upper left corner of the Raster is given by the location argument. If location is null, (0, 0) will be used. The dataType parameter should be one of the enumerated values defined in the DataBuffer class.</source>
          <target state="translated">Raster의 왼쪽 상단은 location 인수에 의해 제공됩니다. 위치가 null이면 (0, 0)이 사용됩니다. dataType 매개 변수는 DataBuffer 클래스에 정의 된 열거 값 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="67d6b1496d85bc73b81c00c805158bd666f5dfae" translate="yes" xml:space="preserve">
          <source>The upper left corner of the Raster is given by the location argument. The dataType parameter should be one of the enumerated values defined in the DataBuffer class.</source>
          <target state="translated">Raster의 왼쪽 상단은 location 인수에 의해 제공됩니다. dataType 매개 변수는 DataBuffer 클래스에 정의 된 열거 값 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9e5507eac7b1c8f8528ce3b0b75192849c664597" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'a'&lt;/code&gt;. The entire string representing the number will be converted to upper case including the &lt;code&gt;'x'&lt;/code&gt; (&lt;code&gt;'\u0078'&lt;/code&gt;) and &lt;code&gt;'p'&lt;/code&gt; (&lt;code&gt;'\u0070'&lt;/code&gt; and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'a'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 캐릭터 라인 전체가 대문자로 변환 될 &lt;code&gt;'x'&lt;/code&gt; ( &lt;code&gt;'\u0078'&lt;/code&gt; )와 &lt;code&gt;'p'&lt;/code&gt; ( &lt;code&gt;'\u0070'&lt;/code&gt; 모두 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13c5bb73738331e23e3b8d0a094ce01abeb63f19" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'b'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'b'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="322e75fb849065f4ca52a6addf60e0ac9b017449" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'c'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'c'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="a34a284aaae73cba16fd4c94692a85c43d38c457" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'e'&lt;/code&gt;. The exponent symbol will be &lt;code&gt;'E'&lt;/code&gt; (&lt;code&gt;'\u0045'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'e'&lt;/code&gt; 의 대문자 변형입니다 . 지수 기호는 &lt;code&gt;'E'&lt;/code&gt; ( &lt;code&gt;'\u0045'&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="8e4023159140f742a67dc9be0c2aef26ca29decf" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'g'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'g'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="0a797a98a3e9c41bf7072b33c0c5562f599482a3" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'h'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'h'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="07e68ff070c96b0a5cf38a9497cd5a90681077a0" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'s'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'s'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="6d089cd4117c5c549f52accd43d02871b2e37215" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'t'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'t'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="3c81156a71ca9fedc956a7ac507aef205ed19e69" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'x'&lt;/code&gt;. The entire string representing the number will be converted to &lt;a href=&quot;../lang/string#toUpperCase(java.util.Locale)&quot;&gt;upper case&lt;/a&gt; including the &lt;code&gt;'x'&lt;/code&gt; (if any) and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 전체 문자열로 변환한다 &lt;a href=&quot;../lang/string#toUpperCase(java.util.Locale)&quot;&gt;상부 케이스&lt;/a&gt; 포함 &lt;code&gt;'x'&lt;/code&gt; (있는 경우) 모든 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a786ff8547a2a8f3e96b122c7d43bbbbe0cec7bd" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'x'&lt;/code&gt;. The entire string representing the number will be converted to &lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;upper case&lt;/a&gt; including the &lt;code&gt;'x'&lt;/code&gt; (if any) and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 전체 문자열로 변환한다 &lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;상부 케이스&lt;/a&gt; 포함 &lt;code&gt;'x'&lt;/code&gt; (있는 경우) 모든 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="654f2289487545b8f3928941dfdc0d162440284e" translate="yes" xml:space="preserve">
          <source>The uppercase letters &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; (&lt;code&gt;'\u0041'&lt;/code&gt; through &lt;code&gt;'\u005a'&lt;/code&gt;),</source>
          <target state="translated">대문자 &lt;code&gt;'A'&lt;/code&gt; ~ &lt;code&gt;'Z'&lt;/code&gt; ( &lt;code&gt;'\u0041'&lt;/code&gt; ~ &lt;code&gt;'\u005a'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4330d8d1977e43b23dd07bee2099b3f4b622bfa6" translate="yes" xml:space="preserve">
          <source>The url string has the following expected structure.</source>
          <target state="translated">URL 문자열의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cf7c2a834de05ed4f93377051cbab9b134c7cbe" translate="yes" xml:space="preserve">
          <source>The usage of the pseudo/hidden column cannot be determined.</source>
          <target state="translated">의사 / 숨겨진 열의 사용을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4af9a221919250af2a20e619455ccc9a51cf8601" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;synchronized&lt;/code&gt; methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired.</source>
          <target state="translated">의 사용 &lt;code&gt;synchronized&lt;/code&gt; 방법이나 문은 모든 객체와 관련된 암묵의 감시 락에의 액세스를 제공하지만, 힘 모든 잠금 획득 및 해제는 블록 구조의 방법으로 발생 : 여러 잠금 취득 할 때 반대 순서로 발표되어야 모든 잠금은 잠금을 획득 한 동일한 어휘 범위에서 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="f768e19a63b5119836728427dc1a9e6eab8e5416" translate="yes" xml:space="preserve">
          <source>The use of Object is conventional, and because the lookup modes are limited, there is no special access provided to the internals of Object, its package or its module. Consequently, the lookup context of this lookup object will be the bootstrap class loader, which means it cannot find user classes.</source>
          <target state="translated">Object의 사용은 일반적이며 조회 모드가 제한되어 있기 때문에 Object의 내부, 패키지 또는 모듈에 대한 특별한 액세스가 제공되지 않습니다. 결과적으로이 조회 객체의 조회 컨텍스트는 부트 스트랩 클래스 로더가되므로 사용자 클래스를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="63a7e152cb80dbfba69bf4ce931d07a2966b3c06" translate="yes" xml:space="preserve">
          <source>The use of a &lt;code&gt;Supplier&lt;/code&gt; in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See &lt;a href=&quot;package-summary#NonInterference&quot;&gt;Non-Interference&lt;/a&gt; for more details.</source>
          <target state="translated">이 형식 으로 &lt;code&gt;Supplier&lt;/code&gt; 를 사용 하면 소스와의 잠재적 인 간섭 범위를 줄이는 간접적 인 수준을 제공 할 수 있습니다. 공급 업체는 터미널 작업이 시작된 후에 만 ​​호출되므로 터미널 작업이 시작될 때까지 소스에 대한 모든 수정 사항이 스트림 결과에 반영됩니다. 자세한 내용은 &lt;a href=&quot;package-summary#NonInterference&quot;&gt;비 간섭&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="454af7b03b7693d82fd0e4233351ee60b0851423" translate="yes" xml:space="preserve">
          <source>The user can also, when creating his own MBean relation class, have it extending RelationSupport, to retrieve the implementations of required interfaces (see below).</source>
          <target state="translated">사용자는 자신의 MBean 관계 클래스를 작성할 때 RelationSupport를 확장하여 필요한 인터페이스의 구현을 검색 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="df61ad83755512938c568feb25a069781cb800fc" translate="yes" xml:space="preserve">
          <source>The user data object. It is used for whatever data the notification source wishes to communicate to its consumers.</source>
          <target state="translated">사용자 데이터 객체. 알림 소스가 소비자와 통신하고자하는 모든 데이터에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3db14b3d19120ebd8508e01afa1c48fe94d62e5d" translate="yes" xml:space="preserve">
          <source>The user drop action is chosen for a drop as described in the documentation for &lt;a href=&quot;../../java/awt/dnd/droptargetdragevent&quot;&gt;&lt;code&gt;DropTargetDragEvent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../java/awt/dnd/droptargetdropevent&quot;&gt;&lt;code&gt;DropTargetDropEvent&lt;/code&gt;&lt;/a&gt;. A different action may be chosen as the drop action by way of the &lt;code&gt;setDropAction&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../../java/awt/dnd/droptargetdragevent&quot;&gt; &lt;code&gt;DropTargetDragEvent&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../java/awt/dnd/droptargetdropevent&quot;&gt; &lt;code&gt;DropTargetDropEvent&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 설명 된대로 드롭에 대해 사용자 드롭 동작이 선택됩니다 . &lt;code&gt;setDropAction&lt;/code&gt; 메서드 를 통해 드롭 동작으로 다른 동작을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ded37dd355a5696c21e0eddb21f83620c05ca906" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;line down&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤 막대 의 &lt;em&gt;줄 아래&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="a39c75ca8c5af9e1d6071e0c53aa08a01e2ada67" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;line up&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤바 의 &lt;em&gt;라인업&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="173345745a92c74955436882d12492db2df03cd8" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;page down&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤 막대 의 &lt;em&gt;페이지 아래&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="193d0a150699d577c9a383562d0f5b4713e8495f" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;page up&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤 막대 의 &lt;em&gt;페이지 위로&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="5e0125de9eae2e97f0496830f88ba461cb0bd321" translate="yes" xml:space="preserve">
          <source>The user has asked the window manager to de-iconify the window.</source>
          <target state="translated">사용자가 창 관리자에게 창 아이콘을 해제하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="56242cc07cfff1cbe77e752555cb055840f3b2e4" translate="yes" xml:space="preserve">
          <source>The user has asked the window manager to expose the window.</source>
          <target state="translated">사용자가 창 관리자에게 창을 노출하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="563dcb0f90c61b1caa7310cce78c1757d7f585c3" translate="yes" xml:space="preserve">
          <source>The user has asked the window manager to iconify the window.</source>
          <target state="translated">사용자가 창 관리자에게 창을 아이콘 화하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="45e5f9d7b2d37a80979047ad0518fe4e6c2633b7" translate="yes" xml:space="preserve">
          <source>The user has asked the window manager to kill the window.</source>
          <target state="translated">사용자가 창 관리자에게 창을 종료하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="014e44e3d624db2665350901310ffbe64ac20fb5" translate="yes" xml:space="preserve">
          <source>The user has asked the window manager to move the window.</source>
          <target state="translated">사용자가 창 관리자에게 창을 이동하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="764c2fd6c39c249418224b29ac8f824541a679bd" translate="yes" xml:space="preserve">
          <source>The user has moved the bubble (thumb) in a scroll bar, moving to an &quot;absolute&quot; position, rather than to an offset from the last position.</source>
          <target state="translated">사용자가 마지막 위치에서 오프셋이 아닌 &quot;절대&quot;위치로 이동하면서 스크롤 막대에서 거품 (엄지 손가락)을 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="ff728aa953bcf2dfb607b42f34ca43619a0f611c" translate="yes" xml:space="preserve">
          <source>The user has moved the frame.</source>
          <target state="translated">사용자가 프레임을 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="041cfcebf87ffdf1af9afcebade80777aa0d5bda" translate="yes" xml:space="preserve">
          <source>The user has moved the frame. Calls to this method will be preceded by calls to beginDraggingFrame(). Normally &lt;b&gt;f&lt;/b&gt; will be a JInternalFrame.</source>
          <target state="translated">사용자가 프레임을 이동했습니다. 이 메서드에 대한 호출은 beginDraggingFrame () 호출이 선행됩니다. 일반적으로 &lt;b&gt;f&lt;/b&gt; 는 JInternalFrame입니다.</target>
        </trans-unit>
        <trans-unit id="6484fec4987e0f61783465b90329b2c62fb8a22a" translate="yes" xml:space="preserve">
          <source>The user has moved the mouse with a button pressed.</source>
          <target state="translated">사용자가 버튼을 누른 상태에서 마우스를 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="a0e022e701f05a9e192909dba1a6d7ed9a2e61d4" translate="yes" xml:space="preserve">
          <source>The user has moved the mouse with a button pressed. The &lt;code&gt;ALT_MASK&lt;/code&gt; flag indicates that the middle button is being pressed. The &lt;code&gt;META_MASK&lt;/code&gt; flag indicates that the right button is being pressed.</source>
          <target state="translated">사용자가 버튼을 누른 상태에서 마우스를 이동했습니다. &lt;code&gt;ALT_MASK&lt;/code&gt; 의 플래그는 중앙의 버튼이 밀리고있는 것을 나타냅니다. &lt;code&gt;META_MASK&lt;/code&gt; 의 플래그는 오른쪽 버튼이 밀리고있는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9478517673152b0a188ebd7f695a6909a35068ba" translate="yes" xml:space="preserve">
          <source>The user has pressed a non-ASCII &lt;em&gt;action&lt;/em&gt; key.</source>
          <target state="translated">사용자가 비 ASCII &lt;em&gt;조치&lt;/em&gt; 키를 눌렀습니다 .</target>
        </trans-unit>
        <trans-unit id="e8eebbabc6469cffd8745a8a7fbd45d53446ac29" translate="yes" xml:space="preserve">
          <source>The user has pressed a non-ASCII &lt;em&gt;action&lt;/em&gt; key. The &lt;code&gt;key&lt;/code&gt; field contains a value that indicates that the event occurred on one of the action keys, which comprise the 12 function keys, the arrow (cursor) keys, Page Up, Page Down, Home, End, Print Screen, Scroll Lock, Caps Lock, Num Lock, Pause, and Insert.</source>
          <target state="translated">사용자가 비 ASCII &lt;em&gt;조치&lt;/em&gt; 키를 눌렀습니다 . &lt;code&gt;key&lt;/code&gt; 필드는 이벤트가 12 개의 기능 키, 화살표 (커서) 키, 페이지 업, 페이지 다운, 홈, 종료, 화면 인쇄, 스크롤 잠금, 모자를 포함하는 동작 키 중 하나에 발생했음을 나타내는 값을 포함 잠금, Num Lock, 일시 중지 및 삽입.</target>
        </trans-unit>
        <trans-unit id="67a001a3e9546194c18bfef01f6d9b32cdeb3c0a" translate="yes" xml:space="preserve">
          <source>The user has pressed a normal key.</source>
          <target state="translated">사용자가 일반 키를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="2d8b4cb6c68d277da7928ca096027c71cc6a3f73" translate="yes" xml:space="preserve">
          <source>The user has pressed the mouse button.</source>
          <target state="translated">사용자가 마우스 버튼을 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="9302404500330950cae7bd068446039128943bbe" translate="yes" xml:space="preserve">
          <source>The user has pressed the mouse button. The &lt;code&gt;ALT_MASK&lt;/code&gt; flag indicates that the middle button has been pressed. The &lt;code&gt;META_MASK&lt;/code&gt; flag indicates that the right button has been pressed.</source>
          <target state="translated">사용자가 마우스 버튼을 눌렀습니다. &lt;code&gt;ALT_MASK&lt;/code&gt; 의 플래그는 중앙의 버튼이 밀린 것을 나타냅니다. &lt;code&gt;META_MASK&lt;/code&gt; 의 플래그는 오른쪽 버튼이 눌러 진 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33613d59d46f5c2208ee6543cbb932f56e91df53" translate="yes" xml:space="preserve">
          <source>The user has released a non-ASCII &lt;em&gt;action&lt;/em&gt; key.</source>
          <target state="translated">사용자가 비 ASCII &lt;em&gt;작업&lt;/em&gt; 키를 해제했습니다 .</target>
        </trans-unit>
        <trans-unit id="59718788e158ca787b42a083c1cb7ebd55667f8c" translate="yes" xml:space="preserve">
          <source>The user has released a non-ASCII &lt;em&gt;action&lt;/em&gt; key. The &lt;code&gt;key&lt;/code&gt; field contains a value that indicates that the event occurred on one of the action keys, which comprise the 12 function keys, the arrow (cursor) keys, Page Up, Page Down, Home, End, Print Screen, Scroll Lock, Caps Lock, Num Lock, Pause, and Insert.</source>
          <target state="translated">사용자가 비 ASCII &lt;em&gt;작업&lt;/em&gt; 키를 해제했습니다 . &lt;code&gt;key&lt;/code&gt; 필드는 이벤트가 12 개의 기능 키, 화살표 (커서) 키, 페이지 업, 페이지 다운, 홈, 종료, 화면 인쇄, 스크롤 잠금, 모자를 포함하는 동작 키 중 하나에 발생했음을 나타내는 값을 포함 잠금, Num Lock, 일시 중지 및 삽입.</target>
        </trans-unit>
        <trans-unit id="c0a1a4af92c498ba1b109389e3aabef5125e5708" translate="yes" xml:space="preserve">
          <source>The user has released a normal key.</source>
          <target state="translated">사용자가 일반 키를 놓았습니다.</target>
        </trans-unit>
        <trans-unit id="e6720fdb33a7ffd5f47af56f5476bc8ec7c9b8c7" translate="yes" xml:space="preserve">
          <source>The user has released the mouse button.</source>
          <target state="translated">사용자가 마우스 버튼을 놓았습니다.</target>
        </trans-unit>
        <trans-unit id="8fb58f16edfb98f8014f0785412ed9cbc1597d4c" translate="yes" xml:space="preserve">
          <source>The user has released the mouse button. The &lt;code&gt;ALT_MASK&lt;/code&gt; flag indicates that the middle button has been released. The &lt;code&gt;META_MASK&lt;/code&gt; flag indicates that the right button has been released.</source>
          <target state="translated">사용자가 마우스 버튼을 놓았습니다. &lt;code&gt;ALT_MASK&lt;/code&gt; 의 플래그는 중앙의 버튼이 해제되었음을 나타냅니다. &lt;code&gt;META_MASK&lt;/code&gt; 의 플래그는 오른쪽 버튼이 해제되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df69537d6480670d27808a2b57db35ab1f8d7fff" translate="yes" xml:space="preserve">
          <source>The user has resized the component.</source>
          <target state="translated">사용자가 구성 요소의 크기를 조정했습니다.</target>
        </trans-unit>
        <trans-unit id="7d370243bff4516c98576e2fc9b139692a201877" translate="yes" xml:space="preserve">
          <source>The user has resized the component. Calls to this method will be preceded by calls to beginResizingFrame(). Normally &lt;b&gt;f&lt;/b&gt; will be a JInternalFrame.</source>
          <target state="translated">사용자가 구성 요소의 크기를 조정했습니다. 이 메서드에 대한 호출은 beginResizingFrame ()에 대한 호출이 선행됩니다. 일반적으로 &lt;b&gt;f&lt;/b&gt; 는 JInternalFrame입니다.</target>
        </trans-unit>
        <trans-unit id="8d09d4d514c51533f230bb3360a834a0337884b5" translate="yes" xml:space="preserve">
          <source>The user may also select what action the &lt;code&gt;LinearGradientPaint&lt;/code&gt; object takes when it is filling the space outside the start and end points by setting &lt;code&gt;CycleMethod&lt;/code&gt; to either &lt;code&gt;REFLECTION&lt;/code&gt; or &lt;code&gt;REPEAT&lt;/code&gt;. The distances between any two colors in any of the reflected or repeated copies of the gradient are the same as the distance between those same two colors between the start and end points. Note that some minor variations in distances may occur due to sampling at the granularity of a pixel. If no cycle method is specified, &lt;code&gt;NO_CYCLE&lt;/code&gt; will be chosen by default, which means the endpoint colors will be used to fill the remaining area.</source>
          <target state="translated">사용자는 &lt;code&gt;CycleMethod&lt;/code&gt; 를 &lt;code&gt;REFLECTION&lt;/code&gt; 또는 &lt;code&gt;REPEAT&lt;/code&gt; 로 설정하여 시작점과 끝점 외부의 공간을 채울 때 &lt;code&gt;LinearGradientPaint&lt;/code&gt; 객체가 수행하는 작업을 선택할 수도 있습니다 . 그라디언트의 반사되거나 반복되는 복사본에서 두 색상 사이의 거리는 시작점과 끝점 사이의 동일한 두 색상 사이의 거리와 동일합니다. 픽셀 단위의 샘플링으로 인해 약간의 거리 차이가 발생할 수 있습니다. 순환 방법을 지정하지 않으면 기본적으로 &lt;code&gt;NO_CYCLE&lt;/code&gt; 이 선택되며, 이는 끝점 색상이 나머지 영역을 채우는 데 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9a2632db7e1748002c562fd4ecddc561007b40d0" translate="yes" xml:space="preserve">
          <source>The user may also select what action the &lt;code&gt;RadialGradientPaint&lt;/code&gt; object takes when it is filling the space outside the circle's radius by setting &lt;code&gt;CycleMethod&lt;/code&gt; to either &lt;code&gt;REFLECTION&lt;/code&gt; or &lt;code&gt;REPEAT&lt;/code&gt;. The gradient color proportions are equal for any particular line drawn from the focus point. The following figure shows that the distance AB is equal to the distance BC, and the distance AD is equal to the distance DE.</source>
          <target state="translated">사용자는 &lt;code&gt;CycleMethod&lt;/code&gt; 를 &lt;code&gt;REFLECTION&lt;/code&gt; 또는 &lt;code&gt;REPEAT&lt;/code&gt; 로 설정 하여 &lt;code&gt;RadialGradientPaint&lt;/code&gt; 객체가 원의 반경 외부 공간을 채울 때 수행 할 작업을 선택할 수도 있습니다 . 그라디언트 색상 비율은 초점 포인트에서 그린 특정 선에 대해 동일합니다. 다음 그림은 거리 AB가 거리 BC와 같고 거리 AD가 거리 DE와 같음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="590a075b469a4f56c53bc731a726c007392423a0" translate="yes" xml:space="preserve">
          <source>The user must provide an array of floats specifying how to distribute the colors along the gradient. These values should range from 0.0 to 1.0 and act like keyframes along the gradient (they mark where the gradient should be exactly a particular color).</source>
          <target state="translated">사용자는 그라디언트를 따라 색상을 배포하는 방법을 지정하는 부동 소수점 배열을 제공해야합니다. 이러한 값의 범위는 0.0에서 1.0 사이 여야하며 그래디언트를 따라 키 프레임처럼 작동해야합니다 (그래디언트가 정확히 특정 색상이어야하는 위치를 표시 함).</target>
        </trans-unit>
        <trans-unit id="2f92c89b3e1ea6558173650f9d78d79a1fd2e5a3" translate="yes" xml:space="preserve">
          <source>The user must specify the circle controlling the gradient pattern, which is described by a center point and a radius. The user can also specify a separate focus point within that circle, which controls the location of the first color of the gradient. By default the focus is set to be the center of the circle.</source>
          <target state="translated">사용자는 중심점과 반경으로 설명되는 그라데이션 패턴을 제어하는 ​​원을 지정해야합니다. 사용자는 해당 원 내에 별도의 초점 포인트를 지정하여 그라디언트의 첫 번째 색상 위치를 제어 할 수도 있습니다. 기본적으로 초점은 원의 중심으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a90065a65c9a5ea16238f84c083e26d1b911ff17" translate="yes" xml:space="preserve">
          <source>The user-defined authenticator instance is passed to the connector server in the environment map as the value of the attribute &lt;a href=&quot;jmxconnectorserver#AUTHENTICATOR&quot;&gt;&lt;code&gt;JMXConnectorServer.AUTHENTICATOR&lt;/code&gt;&lt;/a&gt;. For connector servers that use only this authentication system, if this attribute is not present or its value is &lt;code&gt;null&lt;/code&gt; then no user authentication will be performed and full access to the methods exported by the &lt;code&gt;MBeanServerConnection&lt;/code&gt; object will be allowed.</source>
          <target state="translated">사용자 정의 인증 자 인스턴스는 &lt;a href=&quot;jmxconnectorserver#AUTHENTICATOR&quot;&gt; &lt;code&gt;JMXConnectorServer.AUTHENTICATOR&lt;/code&gt; &lt;/a&gt; 속성 값으로 환경 맵의 커넥터 서버에 전달됩니다 . 이 인증 시스템만을 사용하는 커넥터 서버의 경우,이 속성이 없거나 해당 값이 &lt;code&gt;null&lt;/code&gt; 이면 사용자 인증이 수행되지 않으며 &lt;code&gt;MBeanServerConnection&lt;/code&gt; 오브젝트가 내 보낸 메소드에 대한 전체 액세스 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c914f1ee26eb2ebcd79dbec38073d9056bf25e3d" translate="yes" xml:space="preserve">
          <source>The user-information component of a URI, if defined, only contains characters in the</source>
          <target state="translated">URI의 사용자 정보 구성 요소 (정의 된 경우)에는</target>
        </trans-unit>
        <trans-unit id="cecb19734468bf88cd49f4e0c07a6289251ea9f3" translate="yes" xml:space="preserve">
          <source>The user-visible name of the cursor.</source>
          <target state="translated">사용자에게 표시되는 커서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3fcb03e77d59691b4c3374ea557ceea588b9a5f2" translate="yes" xml:space="preserve">
          <source>The username/password, or &lt;code&gt;null&lt;/code&gt; if one can't be gotten.</source>
          <target state="translated">사용자 이름 / 비밀번호 또는 가져올 수없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="852bcbc69c682da592bdc81c14977bb3eb3a85b8" translate="yes" xml:space="preserve">
          <source>The username/password, or null if one can't be gotten</source>
          <target state="translated">사용자 이름 / 비밀번호 또는 가져올 수없는 경우 null</target>
        </trans-unit>
        <trans-unit id="03440d126078d0084be21d674c68227ce0cda463" translate="yes" xml:space="preserve">
          <source>The username/password, or null if one can't be gotten.</source>
          <target state="translated">사용자 이름 / 비밀번호. 또는 아이디를 얻을 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="17d6793bf33f91782b645959d723e53a09498647" translate="yes" xml:space="preserve">
          <source>The usual way to create an RMI connector server is to supply an RMI connector address to the method &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorserverfactory#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt;&lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt;&lt;/a&gt;. The MBean server to which the connector server is attached can be specified as a parameter to that method. Alternatively, the connector server can be registered as an MBean in that MBean server.</source>
          <target state="translated">RMI 커넥터 서버를 생성하는 일반적인 방법은 &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorserverfactory#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt; &lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; 메소드에 RMI 커넥터 주소를 제공하는 것 입니다. 커넥터 서버가 연결된 MBean 서버는 해당 메소드에 대한 매개 변수로 지정할 수 있습니다. 또는 커넥터 서버를 해당 MBean 서버에 MBean으로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffbb7618ff4fd4460738f69cf1f76b5b5baf3e9a" translate="yes" xml:space="preserve">
          <source>The usual way to create an RMI connector server is to supply an RMI connector address to the method &lt;a href=&quot;../jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt;&lt;/a&gt;. The MBean server to which the connector server is attached can be specified as a parameter to that method. Alternatively, the connector server can be registered as an MBean in that MBean server.</source>
          <target state="translated">RMI 커넥터 서버를 작성하는 일반적인 방법은 &lt;a href=&quot;../jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; 메소드에 RMI 커넥터 주소를 제공하는 것 입니다. 커넥터 서버가 연결된 MBean 서버는 해당 메소드의 매개 변수로 지정할 수 있습니다. 또는 커넥터 서버를 해당 MBean 서버에서 MBean으로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8fbb7c2ff253065f61fe611df6643442f33374" translate="yes" xml:space="preserve">
          <source>The utility method to check whether a host name is in a domain or not.</source>
          <target state="translated">호스트 이름이 도메인에 있는지 여부를 확인하는 유틸리티 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ec277891051115eca19f87e67b309f58b25f882b" translate="yes" xml:space="preserve">
          <source>The valid-operation set</source>
          <target state="translated">유효한 작업 세트</target>
        </trans-unit>
        <trans-unit id="6da16c658a7a0e79e77c0c1ee20586931f71b8d4" translate="yes" xml:space="preserve">
          <source>The validity period consists of two date/time values: the first and last dates (and times) on which the certificate is valid. It is defined in ASN.1 as:</source>
          <target state="translated">유효 기간은 두 가지 날짜 / 시간 값으로 구성됩니다. 인증서가 유효한 첫 번째 날짜와 마지막 날짜 (및 시간). ASN.1에서 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9c29678c035dc87e004d700016db31124565f565" translate="yes" xml:space="preserve">
          <source>The value 0, with a scale of 0.</source>
          <target state="translated">스케일이 0 인 값 0</target>
        </trans-unit>
        <trans-unit id="7ba5543468adcdfdcdc64230eac64e84fb598f9f" translate="yes" xml:space="preserve">
          <source>The value 1, with a scale of 0.</source>
          <target state="translated">스케일이 0 인 값 1</target>
        </trans-unit>
        <trans-unit id="88131b97bd60cff8f031f2c61496c018172d0043" translate="yes" xml:space="preserve">
          <source>The value 10, with a scale of 0.</source>
          <target state="translated">스케일이 0 인 값 10</target>
        </trans-unit>
        <trans-unit id="6b104bf32cf4f6c1285966d49e578247ca454b86" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;1&lt;/code&gt; is associated with the 'Showa' era, because it contains 1970-01-01 (ISO calendar system).</source>
          <target state="translated">값 &lt;code&gt;1&lt;/code&gt; 은 1970-01-01 (ISO 달력 시스템)을 포함하기 때문에 'Showa'시대와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93f2d941a20476418b0f5aa42a7a3c8ce886eed" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;isPalette&lt;/code&gt;</source>
          <target state="translated">값은 다음과 &lt;code&gt;isPalette&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b914b287cb7e897169cbfac3e22ac4976186ab0" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;null&lt;/code&gt; is treated the same as the default value and results in the default behavior.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 값 은 기본값과 동일하게 처리되며 기본 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ce28ca4a1d075cf5e8885c1cb0efc02a543555e" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;theme&lt;/code&gt; corresponds to the current &lt;code&gt;MetalTheme&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;theme&lt;/code&gt; 는 현재 &lt;code&gt;MetalTheme&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="a0f7d33ccbee8c89c02bfac3ad06568c31157384" translate="yes" xml:space="preserve">
          <source>The value and extent set methods &quot;correct&quot; their argument to fit within the limits defined by the other three properties. For example if &lt;code&gt;value == maximum&lt;/code&gt;, &lt;code&gt;setExtent(10)&lt;/code&gt; would change the extent (back) to zero.</source>
          <target state="translated">값 및 범위 설정 메서드는 다른 세 가지 속성에 정의 된 한계 내에 맞도록 인수를 &quot;수정&quot;합니다. 예를 들어 &lt;code&gt;value == maximum&lt;/code&gt; 이면 &lt;code&gt;setExtent(10)&lt;/code&gt; 는 범위 (뒤로)를 0으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2493c3149038a8c099fab7e9e4311ce1d4deb4f4" translate="yes" xml:space="preserve">
          <source>The value associated with the key must be a non-empty string. A provider satisfies this selection criterion iff the provider implements the specified algorithm or type for the specified cryptographic service and its implementation meets the constraint expressed by the specified attribute name/value pair.</source>
          <target state="translated">키와 연관된 값은 비어 있지 않은 문자열이어야합니다. 제공자는 지정된 암호화 서비스에 대해 지정된 알고리즘 또는 유형을 구현하고 해당 구현이 지정된 속성 이름 / 값 쌍으로 표시되는 제한 조건을 충족하는 경우이 선택 기준을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="391e2180db915adfa1b2cf6e71bfe20db996f02f" translate="yes" xml:space="preserve">
          <source>The value associated with the key must be an empty string.</source>
          <target state="translated">키와 연관된 값은 빈 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7bb6a82fa77874feef436d7637c68a730afd2083" translate="yes" xml:space="preserve">
          <source>The value being monitored can be a simple value contained within a complex type. For example, the &lt;a href=&quot;../../../java/lang/management/memorymxbean&quot;&gt;&lt;code&gt;MemoryMXBean&lt;/code&gt;&lt;/a&gt; defined in &lt;code&gt;java.lang.management&lt;/code&gt; has an attribute &lt;code&gt;HeapMemoryUsage&lt;/code&gt; of type &lt;a href=&quot;../../../java/lang/management/memoryusage&quot;&gt;&lt;code&gt;MemoryUsage&lt;/code&gt;&lt;/a&gt;. To monitor the amount of</source>
          <target state="translated">모니터링되는 값은 복합 유형에 포함 된 간단한 값일 수 있습니다. 예를 들어, &lt;code&gt;java.lang.management&lt;/code&gt; 에 정의 된 &lt;a href=&quot;../../../java/lang/management/memorymxbean&quot;&gt; &lt;code&gt;MemoryMXBean&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;../../../java/lang/management/memoryusage&quot;&gt; &lt;code&gt;MemoryUsage&lt;/code&gt; &lt;/a&gt; 유형의 &lt;code&gt;HeapMemoryUsage&lt;/code&gt; 속성이 있습니다. 의 양을 모니터링하려면</target>
        </trans-unit>
        <trans-unit id="22671dbb3a2fc0af5749f79de99c08b7020ea924" translate="yes" xml:space="preserve">
          <source>The value can also be set with a security property using the same name, but setting a system property will override the security property value.</source>
          <target state="translated">동일한 이름을 사용하는 보안 속성으로 값을 설정할 수도 있지만 시스템 속성을 설정하면 보안 속성 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="79fbee1710c4e5fba3cf79c5bfcda285dfaed740" translate="yes" xml:space="preserve">
          <source>The value can be anything the server chooses to send. Its value is probably of interest only to the server. The cookie's value can be changed after creation with the &lt;code&gt;setValue&lt;/code&gt; method.</source>
          <target state="translated">값은 서버가 전송하도록 선택한 모든 것이 될 수 있습니다. 그 값은 아마도 서버에만 관심이 있습니다. 쿠키 값은 &lt;code&gt;setValue&lt;/code&gt; 메소드로 작성 후 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0402397f26735b2ed2400f8ddcfcc924e0ce9a91" translate="yes" xml:space="preserve">
          <source>The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a key that is equal to the original key.</source>
          <target state="translated">원래 키와 동일한 키로 &lt;code&gt;get&lt;/code&gt; 메소드를 호출하여 값을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca37fc0349fbf46d676537c35886a71febcb4b0e" translate="yes" xml:space="preserve">
          <source>The value element MUST have the name of the code generator.</source>
          <target state="translated">값 요소에는 코드 생성기의 이름이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b5bc78cb08fd63a200b521c8e2cfc74829815209" translate="yes" xml:space="preserve">
          <source>The value element MUST have the name of the code generator. The name is the fully qualified name of the code generator.</source>
          <target state="translated">값 요소에는 코드 생성기의 이름이 있어야합니다. 이름은 코드 생성기의 완전한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b849d5ab1b9e466df1b5b353714d586423cc336" translate="yes" xml:space="preserve">
          <source>The value element MUST have the name of the code generator. The recommended convention is to use the fully qualified name of the code generator. For example: com.acme.generator.CodeGen.</source>
          <target state="translated">value 요소는 반드시 코드 생성기의 이름을 가져야합니다. 권장되는 규칙은 완전한 코드 생성기 이름을 사용하는 것입니다. 예를 들면 다음과 같습니다. com.acme.generator.CodeGen.</target>
        </trans-unit>
        <trans-unit id="92457a36cc7103fbd6b5d7894167b1422c935465" translate="yes" xml:space="preserve">
          <source>The value for the Domain attribute contains no embedded dots, and the value is not .local.</source>
          <target state="translated">Domain 특성 값에 포함 된 점이없고 값이 .local이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0d5997f3b8a866c24134b984ca931d64c1fadf66" translate="yes" xml:space="preserve">
          <source>The value for the given parameter. Returns &lt;code&gt;null&lt;/code&gt; if no value is assigned to the key.</source>
          <target state="translated">주어진 매개 변수의 값입니다. 키에 값이 할당되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="42d264b983e7f353bc8ad5829d7a8cba44eb4f1c" translate="yes" xml:space="preserve">
          <source>The value for the specified key.</source>
          <target state="translated">지정된 키의 값</target>
        </trans-unit>
        <trans-unit id="637e19f1d9d66194c3a5ef081d059355661838ba" translate="yes" xml:space="preserve">
          <source>The value from invoking &lt;code&gt;getToolTipText&lt;/code&gt; on the UI will be returned.</source>
          <target state="translated">UI 에서 &lt;code&gt;getToolTipText&lt;/code&gt; 를 호출 한 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ed7f25d795cf27390131c4366e7a9398ee24222" translate="yes" xml:space="preserve">
          <source>The value in the data source that caused a conflict</source>
          <target state="translated">충돌을 일으킨 데이터 소스의 값</target>
        </trans-unit>
        <trans-unit id="342ca9859d12367903ff6777b29ff28319123dc1" translate="yes" xml:space="preserve">
          <source>The value is a hint and may not be applicable to all types of chooser panel.</source>
          <target state="translated">값은 힌트이며 모든 유형의 선택기 패널에 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16eb1ebbc57d65829c8ea71ba8f13bcf76d6b4be" translate="yes" xml:space="preserve">
          <source>The value is a sequence of 12 month lengths, for example: &quot;29 30 29 30 29 30 30 30 29 30 29 29&quot;</source>
          <target state="translated">값은 12 개월 길이의 시퀀스입니다 (예 : &quot;29 30 29 30 29 30 30 30 29 30 29 29&quot;).</target>
        </trans-unit>
        <trans-unit id="5bb9d71b0461f94e69808933b8398c479395ae01" translate="yes" xml:space="preserve">
          <source>The value is returned.</source>
          <target state="translated">값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a7de0a0d8ecc433a6e77aa5ef4e35000e3ea661f" translate="yes" xml:space="preserve">
          <source>The value is roughly the ratio of the advance width to that of the regular width.</source>
          <target state="translated">이 값은 대략 일반 너비에 대한 진행 너비의 비율입니다.</target>
        </trans-unit>
        <trans-unit id="fa1b2acf323d87e30788931ca04eec85714d2e07" translate="yes" xml:space="preserve">
          <source>The value is roughly the ratio of the stem width to that of the regular weight.</source>
          <target state="translated">이 값은 대략 스템 너비와 일반 무게의 비율입니다.</target>
        </trans-unit>
        <trans-unit id="066682b7ba9301c7bf0f1d401bddfaf27780415b" translate="yes" xml:space="preserve">
          <source>The value is roughly the slope of the stems of the font, expressed as the run over the rise. Positive values lean right.</source>
          <target state="translated">이 값은 대략 라이즈 오버로 표현되는 글꼴 줄기의 기울기입니다. 양수 값은 오른쪽으로 기울어집니다.</target>
        </trans-unit>
        <trans-unit id="aa7c0a226aead4605a5359d73bc37df988ab8233" translate="yes" xml:space="preserve">
          <source>The value is set to &lt;code&gt;HIDE_ON_CLOSE&lt;/code&gt; by default. Changes to the value of this property cause the firing of a property change event, with property name &quot;defaultCloseOperation&quot;.</source>
          <target state="translated">이 값은 기본적 으로 &lt;code&gt;HIDE_ON_CLOSE&lt;/code&gt; 로 설정됩니다. 이 속성 값을 변경하면 속성 이름이 &quot;defaultCloseOperation&quot;인 속성 변경 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4a9485366d4d3e9e98f4eb98c47c6e965d85121" translate="yes" xml:space="preserve">
          <source>The value may be unavailable (&lt;code&gt;null&lt;/code&gt;) if this exception has been serialized and then deserialized.</source>
          <target state="translated">이 예외가 직렬화 된 다음 역 직렬화 된 경우 값을 사용할 수 없습니다 ( &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d4656bc7f215cf6f15fb76158e42016f85338cb8" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt;&lt;code&gt;SO_RCVBUF&lt;/code&gt;&lt;/a&gt; is also used to set the TCP receive window that is advertized to the remote peer. Generally, the window size can be modified at any time when a socket is connected. However, if a receive window larger than 64K is required then this must be requested &lt;b&gt;before&lt;/b&gt; the socket is connected to the remote peer. There are two cases to be aware of:</source>
          <target state="translated">&lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt; &lt;code&gt;SO_RCVBUF&lt;/code&gt; &lt;/a&gt; 의 값 은 또한 원격 피어에 알리는 TCP 수신 창을 설정하는 데 사용됩니다. 일반적으로 창 크기는 소켓이 연결될 때 언제든지 수정할 수 있습니다. 그러나 64K보다 큰 수신 창이 필요한 경우 소켓을 원격 피어에 연결 &lt;b&gt;하기 전에&lt;/b&gt; 요청해야합니다 . 알아야 할 두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b85d520eb7eadb3694e23d56197be67f17133e54" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt;&lt;code&gt;SO_RCVBUF&lt;/code&gt;&lt;/a&gt; is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertized to the remote peer.</source>
          <target state="translated">&lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt; &lt;code&gt;SO_RCVBUF&lt;/code&gt; &lt;/a&gt; 의 값은 내부 소켓 수신 버퍼의 크기를 설정하고 원격 피어에 알리는 TCP 수신 창의 크기를 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c4ff5577d151859242031a667b9521d4b7db2c5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;get(uidClassID)&lt;/code&gt; must be the &lt;code&gt;String&lt;/code&gt; name of a class that implements the corresponding &lt;code&gt;ComponentUI&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;get(uidClassID)&lt;/code&gt; 의 값은 해당 &lt;code&gt;ComponentUI&lt;/code&gt; 클래스 를 구현하는 클래스 의 &lt;code&gt;String&lt;/code&gt; 이름 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d7d9b9e9d3e50f723e3431d3e8e8aa5f40dcb83" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;get(uidClassID)&lt;/code&gt; must be the &lt;code&gt;String&lt;/code&gt; name of a class that implements the corresponding &lt;code&gt;ComponentUI&lt;/code&gt; class. If the class hasn't been loaded before, this method looks up the class with &lt;code&gt;uiClassLoader.loadClass()&lt;/code&gt; if a non &lt;code&gt;null&lt;/code&gt; class loader is provided, &lt;code&gt;classForName()&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;get(uidClassID)&lt;/code&gt; 의 값은 해당 &lt;code&gt;ComponentUI&lt;/code&gt; 클래스 를 구현하는 클래스 의 &lt;code&gt;String&lt;/code&gt; 이름 이어야합니다 . 클래스가 이전에로드되지 않은 경우이 메서드는 &lt;code&gt;null&lt;/code&gt; 이 아닌 클래스 로더가 제공 되면 &lt;code&gt;uiClassLoader.loadClass()&lt;/code&gt; 하여 클래스를 검색하고 그렇지 않으면 &lt;code&gt;classForName()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5a87ea63bb29fff9712ea9d7adb6cb32c825530f" translate="yes" xml:space="preserve">
          <source>The value of a &lt;code&gt;QName&lt;/code&gt; contains a &lt;strong&gt;Namespace URI&lt;/strong&gt;, &lt;strong&gt;local part&lt;/strong&gt; and &lt;strong&gt;prefix&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;QName&lt;/code&gt; 의 값 에는 &lt;strong&gt;네임 스페이스 URI&lt;/strong&gt; , &lt;strong&gt;로컬 부분&lt;/strong&gt; 및 &lt;strong&gt;접두사가 포함&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="47901eb75b98cda41165efa4708755552728c44a" translate="yes" xml:space="preserve">
          <source>The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">부동 소수점 합의 값은 입력 값과 덧셈 연산 순서 모두의 함수입니다. 이 방법의 추가 연산 순서는 계산 결과의 속도와 정확성을 향상시키기 위해 구현 유연성을 허용하도록 의도적으로 정의되지 않았습니다. 특히,이 방법은 보상 된 합산 또는 다른 기술을 사용하여 구현되어 &lt;code&gt;double&lt;/code&gt; 값 의 단순한 합산과 비교하여 수치 합의 오차 한계를 감소시킬 수있다 .</target>
        </trans-unit>
        <trans-unit id="dbca91d177ed0205782c0c48a8895e3015b456f7" translate="yes" xml:space="preserve">
          <source>The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values. Because of the unspecified order of operations and the possibility of using differing summation schemes, the output of this method may vary on the same input elements.</source>
          <target state="translated">부동 소수점 합계의 값은 입력 값과 더하기 연산의 순서 모두에 대한 함수입니다. 이 방법의 추가 작업 순서는 계산 된 결과의 속도와 정확성을 향상시키기위한 구현 유연성을 허용하기 위해 의도적으로 정의되지 않았습니다. 특히,이 방법은 보상 된 합산 또는 다른 기술을 사용하여 구현 될 수있어 단순한 &lt;code&gt;double&lt;/code&gt; 값 합산에 비해 수치 합의 오차 한계를 줄일 수 있습니다. 지정되지 않은 작업 순서와 다른 합산 체계를 사용할 수 있기 때문에이 방법의 출력은 동일한 입력 요소에서 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1818b0cb32425fd7ada740f672d59ec05fcd88bb" translate="yes" xml:space="preserve">
          <source>The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values. Because of the unspecified order of operations and the possibility of using differing summation schemes, the output of this method may vary on the same input values.</source>
          <target state="translated">부동 소수점 합계의 값은 입력 값과 더하기 연산의 순서 모두에 대한 함수입니다. 이 방법의 추가 작업 순서는 계산 된 결과의 속도와 정확성을 향상시키기위한 구현 유연성을 허용하기 위해 의도적으로 정의되지 않았습니다. 특히,이 방법은 보상 된 합산 또는 다른 기술을 사용하여 구현 될 수있어 단순한 &lt;code&gt;double&lt;/code&gt; 값 합산에 비해 수치 합의 오차 한계를 줄일 수 있습니다. 지정되지 않은 작업 순서와 다른 합산 체계를 사용할 수 있기 때문에이 방법의 출력은 동일한 입력 값에서 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="257716e5f7261a724275793b4cede7634e4a94a2" translate="yes" xml:space="preserve">
          <source>The value of either the &lt;code&gt;engineScope&lt;/code&gt; or &lt;code&gt;globalScope&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;engineScope&lt;/code&gt; 또는 &lt;code&gt;globalScope&lt;/code&gt; 필드 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="cc44f2ec78c81b386a8c310e62b47b764873b9be" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;CODE&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;CODE&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="8ed71c2de4c7b018d8c2009db367a1d0adf781b3" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;NAME&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;NAME&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="33a0213d4d41d39ffcaba8745b73f4b11a491bc0" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;OBJECT&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;OBJECT&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="959bfb062f0baa61d452078c0860aff55768dad8" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;VERSION&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;VERSION&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6095c30c12ae59a730bdf5e89a5c5930d5296d54" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;agentArgs&lt;/code&gt; parameter is always the empty string.</source>
          <target state="translated">&lt;code&gt;agentArgs&lt;/code&gt; 매개 변수 의 값 은 항상 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="db253ce5afdfcb3423a0685c3f7a274daac0f99b" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;calendarField&lt;/code&gt; property must be one of the &lt;code&gt;java.util.Calendar&lt;/code&gt; constants that specify a field within a &lt;code&gt;Calendar&lt;/code&gt;. The &lt;code&gt;getNextValue&lt;/code&gt; and &lt;code&gt;getPreviousValue&lt;/code&gt; methods change the date forward or backwards by this amount. For example, if &lt;code&gt;calendarField&lt;/code&gt; is &lt;code&gt;Calendar.DAY_OF_WEEK&lt;/code&gt;, then &lt;code&gt;nextValue&lt;/code&gt; produces a &lt;code&gt;Date&lt;/code&gt; that's 24 hours after the current &lt;code&gt;value&lt;/code&gt;, and &lt;code&gt;previousValue&lt;/code&gt; produces a &lt;code&gt;Date&lt;/code&gt; that's 24 hours earlier.</source>
          <target state="translated">&lt;code&gt;calendarField&lt;/code&gt; 속성 의 값은 &lt;code&gt;Calendar&lt;/code&gt; 내의 필드를 지정하는 &lt;code&gt;java.util.Calendar&lt;/code&gt; 상수 중 하나 여야합니다 . &lt;code&gt;getNextValue&lt;/code&gt; 메소드 와 &lt;code&gt;getPreviousValue&lt;/code&gt; 방법은이 양만큼 앞으로 또는 뒤로 날짜를 변경합니다. 예를 들어, &lt;code&gt;calendarField&lt;/code&gt; 가 있다 &lt;code&gt;Calendar.DAY_OF_WEEK&lt;/code&gt; 의 다음 &lt;code&gt;nextValue&lt;/code&gt; 는 생성 &lt;code&gt;Date&lt;/code&gt; 24 시간 후, 현재의 &lt;code&gt;value&lt;/code&gt; 과 &lt;code&gt;previousValue&lt;/code&gt; 생성 &lt;code&gt;Date&lt;/code&gt; 24시간 이전이다.</target>
        </trans-unit>
        <trans-unit id="794cfe6b23a4d9ae5e0b56d35ae27d70aacb7d7e" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;initialSize&lt;/code&gt; parameter for the default group (see &lt;a href=&quot;#withCachedThreadPool(java.util.concurrent.ExecutorService,int)&quot;&gt;&lt;code&gt;withCachedThreadPool&lt;/code&gt;&lt;/a&gt;). The value of the property is taken to be the &lt;code&gt;String&lt;/code&gt; representation of an &lt;code&gt;Integer&lt;/code&gt; that is the initial size parameter. If the value cannot be parsed as an &lt;code&gt;Integer&lt;/code&gt; it causes an unspecified error to be thrown during the construction of the default group.</source>
          <target state="translated">기본 그룹에 대한 &lt;code&gt;initialSize&lt;/code&gt; 매개 변수 의 값 ( &lt;a href=&quot;#withCachedThreadPool(java.util.concurrent.ExecutorService,int)&quot;&gt; &lt;code&gt;withCachedThreadPool&lt;/code&gt; &lt;/a&gt; 참조 ). 속성 값은 초기 크기 매개 변수 인 &lt;code&gt;Integer&lt;/code&gt; 의 &lt;code&gt;String&lt;/code&gt; 표현 으로 간주 됩니다. 값을 &lt;code&gt;Integer&lt;/code&gt; 로 구문 분석 할 수없는 경우 기본 그룹을 구성하는 동안 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7db15370f7c34a2470defe5752a0b701343b9aa" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;initialSize&lt;/code&gt; parameter for the default group (see &lt;a href=&quot;asynchronouschannelgroup#withCachedThreadPool-java.util.concurrent.ExecutorService-int-&quot;&gt;&lt;code&gt;withCachedThreadPool&lt;/code&gt;&lt;/a&gt;). The value of the property is taken to be the &lt;code&gt;String&lt;/code&gt; representation of an &lt;code&gt;Integer&lt;/code&gt; that is the initial size parameter. If the value cannot be parsed as an &lt;code&gt;Integer&lt;/code&gt; it causes an unspecified error to be thrown during the construction of the default group.</source>
          <target state="translated">기본 그룹 의 &lt;code&gt;initialSize&lt;/code&gt; 매개 변수 값입니다 ( &lt;a href=&quot;asynchronouschannelgroup#withCachedThreadPool-java.util.concurrent.ExecutorService-int-&quot;&gt; &lt;code&gt;withCachedThreadPool&lt;/code&gt; &lt;/a&gt; 참조 ). 속성 값은 초기 크기 매개 변수 인 &lt;code&gt;Integer&lt;/code&gt; 의 &lt;code&gt;String&lt;/code&gt; 표현 으로 간주 됩니다. 값을 &lt;code&gt;Integer&lt;/code&gt; 로 구문 분석 할 수 없으면 기본 그룹을 구성하는 동안 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6dc8151f529dc33a68ca2fcf1cb579a5177476f4" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;pos&lt;/code&gt; field at the time the last &lt;code&gt;mark&lt;/code&gt; method was called.</source>
          <target state="translated">마지막 &lt;code&gt;mark&lt;/code&gt; 메소드가 호출 된 시점 의 &lt;code&gt;pos&lt;/code&gt; 필드 값</target>
        </trans-unit>
        <trans-unit id="3d7b6a331016128368d223794882c3c73304be01" translate="yes" xml:space="preserve">
          <source>The value of the alignment argument must be one of &lt;code&gt;FlowLayout.LEFT&lt;/code&gt;, &lt;code&gt;FlowLayout.RIGHT&lt;/code&gt;, &lt;code&gt;FlowLayout.CENTER&lt;/code&gt;, &lt;code&gt;FlowLayout.LEADING&lt;/code&gt;, or &lt;code&gt;FlowLayout.TRAILING&lt;/code&gt;.</source>
          <target state="translated">정렬 인수의 값은 &lt;code&gt;FlowLayout.LEFT&lt;/code&gt; , &lt;code&gt;FlowLayout.RIGHT&lt;/code&gt; , &lt;code&gt;FlowLayout.CENTER&lt;/code&gt; , &lt;code&gt;FlowLayout.LEADING&lt;/code&gt; 또는 &lt;code&gt;FlowLayout.TRAILING&lt;/code&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd7c2e09ab2e7c092b2a7976a1eb466d93a6e429" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;#parseUnsignedInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 16)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 &lt;a href=&quot;#parseUnsignedInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 16)&lt;/code&gt; &lt;/a&gt; 호출 하여 반환 된 문자열 &lt;code&gt;s&lt;/code&gt; 에서 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e21e5913fb02bfd63d5ded2134431d5afbd21c2f" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;#parseUnsignedInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 &lt;a href=&quot;#parseUnsignedInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 2)&lt;/code&gt; &lt;/a&gt; 호출 하여 반환 된 문자열 &lt;code&gt;s&lt;/code&gt; 에서 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b52dd7472776a922558cf8749735520a09027482" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;#parseUnsignedInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 8)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 &lt;a href=&quot;#parseUnsignedInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 8)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 반환 된 문자열 &lt;code&gt;s&lt;/code&gt; 에서 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5f367de23aed8fdc5d40501bc07e4493f43a22c" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;#parseUnsignedLong(java.lang.String,int)&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 16)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 &lt;a href=&quot;#parseUnsignedLong(java.lang.String,int)&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 16)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 반환 된 문자열 &lt;code&gt;s&lt;/code&gt; 에서 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5f6ffb0b89f7ca3945ffdc8c9f746c806b1febf" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;#parseUnsignedLong(java.lang.String,int)&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 &lt;a href=&quot;#parseUnsignedLong(java.lang.String,int)&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 2)&lt;/code&gt; &lt;/a&gt; 호출 하여 반환 된 문자열 &lt;code&gt;s&lt;/code&gt; 에서 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ef526b3a382f98770d90dab5e5ee23080eaf9c1" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;#parseUnsignedLong(java.lang.String,int)&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 8)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 &lt;a href=&quot;#parseUnsignedLong(java.lang.String,int)&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 8)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 반환 된 문자열 &lt;code&gt;s&lt;/code&gt; 에서 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83b12208c67365cc9a87568927cbc140c553a51c" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 16)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값이 반환 된 문자열로부터 회수 될 수 &lt;code&gt;s&lt;/code&gt; 호출 &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 16)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7c96fb72306b59eb6e27bbb68b4960125a44ad5" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 2)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea713c8dbe3bbb434d598cf92fbf26c0ccad22fb" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 8)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 8)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="002109f6f0e34deda860d2f8c13101257bd26010" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 16)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값이 반환 된 문자열로부터 회수 될 수 &lt;code&gt;s&lt;/code&gt; 호출 &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 16)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8bd9a5106b83006a5daa1344bcf9fab6f821e2" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 2)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85fe9464ad74c5e36e8aac8096c9a27cbff3e7e2" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 8)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 8)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="944418cefa750e284562a352c57c1ac108123c86" translate="yes" xml:space="preserve">
          <source>The value of the attribute &lt;code&gt;Attr.isId&lt;/code&gt; for all &lt;code&gt;Attr&lt;/code&gt; nodes;</source>
          <target state="translated">모든 &lt;code&gt;Attr&lt;/code&gt; 노드에 대한 속성 &lt;code&gt;Attr.isId&lt;/code&gt; 의 값 .</target>
        </trans-unit>
        <trans-unit id="a40df0d23a4275511eaaef080d1d315aca0bfdb7" translate="yes" xml:space="preserve">
          <source>The value of the attribute &lt;code&gt;Text.isElementContentWhitespace&lt;/code&gt; for all &lt;code&gt;Text&lt;/code&gt; nodes;</source>
          <target state="translated">모든 &lt;code&gt;Text&lt;/code&gt; 노드에 대한 속성 &lt;code&gt;Text.isElementContentWhitespace&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="92420401b1a66eb9d260a1d33bbda978b19012bf" translate="yes" xml:space="preserve">
          <source>The value of the attribute in the lowest scope for which an attribute with the given name is defined. Returns null if no attribute with the name exists in any scope.</source>
          <target state="translated">지정된 이름의 속성이 정의 된 가장 낮은 범위의 속성 값입니다. 이름을 가진 속성이 범위에 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3da50d92e176dc63b5da07ccab80504daf8a1e18" translate="yes" xml:space="preserve">
          <source>The value of the attribute retrieved.</source>
          <target state="translated">검색된 속성의 값입니다.</target>
        </trans-unit>
        <trans-unit id="92991f2b467a9dd9be161ffe7219ec382620ce83" translate="yes" xml:space="preserve">
          <source>The value of the attribute. May be null if the attribute is unknown.</source>
          <target state="translated">속성의 값 속성을 알 수없는 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="466e384c29b6463845ff35c548a12774880047a9" translate="yes" xml:space="preserve">
          <source>The value of the attribute. Returns &lt;code&gt;null&lt;/code&gt; is the name does not exist in the given scope.</source>
          <target state="translated">속성의 값 주어진 범위에 이름이없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="74cdc8bebf5f468278c81d960a0037a2414259ba" translate="yes" xml:space="preserve">
          <source>The value of the client info property specified</source>
          <target state="translated">지정된 클라이언트 정보 속성의 값</target>
        </trans-unit>
        <trans-unit id="91e403e2eb1c324930b4e35dae6fc81cb5073836" translate="yes" xml:space="preserve">
          <source>The value of the data source name property can be used to do a lookup of a &lt;code&gt;DataSource&lt;/code&gt; object that has been registered with a naming service. After being retrieved, the &lt;code&gt;DataSource&lt;/code&gt; object can be used to create a connection to the data source that it represents.</source>
          <target state="translated">데이터 소스 이름 속성의 값은 이름 지정 서비스에 등록 된 &lt;code&gt;DataSource&lt;/code&gt; 개체를 조회하는 데 사용할 수 있습니다 . 검색된 후 &lt;code&gt;DataSource&lt;/code&gt; 개체를 사용하여 해당 개체가 나타내는 데이터 소스에 대한 연결을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89153ece260b7dfb644e9861ccd90ff459f98fed" translate="yes" xml:space="preserve">
          <source>The value of the entry corresponds to the &lt;code&gt;color&lt;/code&gt; of the &lt;code&gt;name-color&lt;/code&gt; pair. The value of the entry is calculated in one of two ways. With either approach the value is always a &lt;code&gt;ColorUIResource&lt;/code&gt;.</source>
          <target state="translated">항목의 값은 &lt;code&gt;name-color&lt;/code&gt; 쌍 의 &lt;code&gt;color&lt;/code&gt; 에 해당합니다 . 항목 값은 두 가지 방법 중 하나로 계산됩니다. 두 방법 모두 값은 항상 &lt;code&gt;ColorUIResource&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a29338eb8aef71785b10debb2f0b72aa45d3ef71" translate="yes" xml:space="preserve">
          <source>The value of the feature element</source>
          <target state="translated">기능 요소의 가치</target>
        </trans-unit>
        <trans-unit id="e49deabc177c53d0801c439c0df42c2b5ea401a4" translate="yes" xml:space="preserve">
          <source>The value of the field will be output during a format. If the value cannot be obtained then an exception will be thrown.</source>
          <target state="translated">필드 값은 포맷 중에 출력됩니다. 값을 얻을 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f09895cfba5ef0e576e6f82bf3ed884e2defea3" translate="yes" xml:space="preserve">
          <source>The value of the horizontalAlignment property, one of the following constants defined in &lt;code&gt;SwingConstants&lt;/code&gt;: &lt;code&gt;LEFT&lt;/code&gt;, &lt;code&gt;CENTER&lt;/code&gt;, &lt;code&gt;RIGHT&lt;/code&gt;, &lt;code&gt;LEADING&lt;/code&gt; or &lt;code&gt;TRAILING&lt;/code&gt;.</source>
          <target state="translated">horizontalAlignment 속성의 값, &lt;code&gt;SwingConstants&lt;/code&gt; 에 정의 된 다음 상수 중 하나 : &lt;code&gt;LEFT&lt;/code&gt; , &lt;code&gt;CENTER&lt;/code&gt; , &lt;code&gt;RIGHT&lt;/code&gt; , &lt;code&gt;LEADING&lt;/code&gt; 또는 &lt;code&gt;TRAILING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aee812e8129cf619830b9c5ca742d61c7a90b98" translate="yes" xml:space="preserve">
          <source>The value of the interim element, or zero</source>
          <target state="translated">중간 요소의 값 또는 0</target>
        </trans-unit>
        <trans-unit id="87be2e085969e0b67e47a39ebaf8ecadcab9540e" translate="yes" xml:space="preserve">
          <source>The value of the job's &lt;a href=&quot;jobholduntil&quot;&gt;&lt;code&gt;JobHoldUntil&lt;/code&gt;&lt;/a&gt; attribute was specified with a date-time that is still in the future.</source>
          <target state="translated">작업의 &lt;a href=&quot;jobholduntil&quot;&gt; &lt;code&gt;JobHoldUntil&lt;/code&gt; &lt;/a&gt; 속성 값 이 아직 미래인 날짜-시간으로 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="48e435e7bad97cf8759c8bed3884e0e05a6ca6c6" translate="yes" xml:space="preserve">
          <source>The value of the job's &lt;a href=&quot;jobholduntil&quot;&gt;&lt;code&gt;JobHoldUntil&lt;/code&gt;&lt;/a&gt; attribute was specified with a date-time that is still in the future. The job must not be a candidate for processing until this reason is removed and there are no other reasons to hold the job. This value should be supported if the &lt;a href=&quot;jobholduntil&quot;&gt;&lt;code&gt;JobHoldUntil&lt;/code&gt;&lt;/a&gt; job template attribute is supported.</source>
          <target state="translated">작업의 &lt;a href=&quot;jobholduntil&quot;&gt; &lt;code&gt;JobHoldUntil&lt;/code&gt; &lt;/a&gt; 속성 값 이 여전히 미래의 날짜-시간으로 지정되었습니다. 이 이유가 제거되고 작업을 보유 할 다른 이유가 없을 때까지 작업이 처리 후보가되어서는 안됩니다. &lt;a href=&quot;jobholduntil&quot;&gt; &lt;code&gt;JobHoldUntil&lt;/code&gt; &lt;/a&gt; 작업 템플리트 속성이 지원 되는 경우이 값이 지원되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa775d6651b666f860fc718e770f26380a796a79" translate="yes" xml:space="preserve">
          <source>The value of the method property identifies the overall method that should be used for outputting the result tree. Other non-namespaced values may be used, such as &quot;xhtml&quot;, but, if accepted, the handling of such values is implementation defined. If any of the method values are not accepted and are not namespace qualified, then &lt;a href=&quot;transformer#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;Transformer.setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;transformer#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;Transformer.setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">method 속성의 값은 결과 트리를 출력하는 데 사용해야하는 전체 메서드를 식별합니다. &quot;xhtml&quot;과 같이 네임 스페이스가 지정되지 않은 다른 값을 사용할 수 있지만 허용되는 경우 이러한 값의 처리가 구현에 정의됩니다. 메소드 값 중 하나라도 허용되지 않고 네임 스페이스가 규정되지 않은 경우 &lt;a href=&quot;transformer#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;Transformer.setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;transformer#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;Transformer.setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9603d0dd485012e1f4fbb07ab95058c5884e0871" translate="yes" xml:space="preserve">
          <source>The value of the negotiated property. If null, the property was not negotiated or is not applicable to this mechanism.</source>
          <target state="translated">협상 된 속성의 값입니다. null 인 경우, 속성이 협상되지 않았거나이 메커니즘에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96910b37863aa5f498f86d670ce5a0f5a3e1171c" translate="yes" xml:space="preserve">
          <source>The value of the orientation property, one of the following constants defined in &lt;code&gt;SwingConstants&lt;/code&gt;: &lt;code&gt;VERTICAL&lt;/code&gt;, or &lt;code&gt;HORIZONTAL&lt;/code&gt;.</source>
          <target state="translated">방향 속성의 값으로 &lt;code&gt;SwingConstants&lt;/code&gt; 에 정의 된 상수 중 하나 : &lt;code&gt;VERTICAL&lt;/code&gt; 또는 &lt;code&gt;HORIZONTAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="122991b3abd0c365b5f861b9586921865f40f102" translate="yes" xml:space="preserve">
          <source>The value of the patch element, or zero</source>
          <target state="translated">패치 요소의 값 또는 0</target>
        </trans-unit>
        <trans-unit id="99ce23bc16d5210c1930a80ad3c2fe63bc0077c1" translate="yes" xml:space="preserve">
          <source>The value of the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; attribute ia &lt;code&gt;STOPPED&lt;/code&gt;.</source>
          <target state="translated">프린터의 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 속성 값 ia &lt;code&gt;STOPPED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1375a6bafbe98e90e4d0729db426a82bac246c11" translate="yes" xml:space="preserve">
          <source>The value of the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; attribute ia STOPPED.</source>
          <target state="translated">프린터의 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 속성 값은 STOPPED입니다.</target>
        </trans-unit>
        <trans-unit id="bd845a6682621e89df372f59113cf70e4aa903b3" translate="yes" xml:space="preserve">
          <source>The value of the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attribute contains a &lt;a href=&quot;printerstatereason&quot;&gt;&lt;code&gt;PrinterStateReason&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;STOPPED_PARTLY&lt;/code&gt;.</source>
          <target state="translated">프린터의 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 속성 값에는 &lt;code&gt;STOPPED_PARTLY&lt;/code&gt; 의 &lt;a href=&quot;printerstatereason&quot;&gt; &lt;code&gt;PrinterStateReason&lt;/code&gt; &lt;/a&gt; 값이 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="db78b0d3523e7732321ffc791c71a38c96846c14" translate="yes" xml:space="preserve">
          <source>The value of the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attribute contains a &lt;a href=&quot;printerstatereason&quot;&gt;&lt;code&gt;PrinterStateReason&lt;/code&gt;&lt;/a&gt; value of STOPPED_PARTLY.</source>
          <target state="translated">프린터의 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 속성 값 에는 &lt;a href=&quot;printerstatereason&quot;&gt; &lt;code&gt;PrinterStateReason&lt;/code&gt; &lt;/a&gt; 값 STOPPED_PARTLY가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="694f6250ebd4b21e919f2ce2a0c6bc377ef96abc" translate="yes" xml:space="preserve">
          <source>The value of the property</source>
          <target state="translated">재산의 가치</target>
        </trans-unit>
        <trans-unit id="6ad83955fc29c77c3dc843a219e4ba3bc203ece9" translate="yes" xml:space="preserve">
          <source>The value of the property &lt;code&gt;JScrollBar.isFreeStanding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JScrollBar.isFreeStanding&lt;/code&gt; 속성의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="fb8346a856c58379f326dd0f040b72de62a3110f" translate="yes" xml:space="preserve">
          <source>The value of the property &lt;code&gt;JSlider.isFilled&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSlider.isFilled&lt;/code&gt; 속성의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d641a6d0cde426cfc0af9e3645444ea302f54a9b" translate="yes" xml:space="preserve">
          <source>The value of the property &lt;code&gt;JSlider.isFilled&lt;/code&gt;. By default, &lt;code&gt;false&lt;/code&gt; if the property is not set, &lt;code&gt;true&lt;/code&gt; for Ocean theme.</source>
          <target state="translated">&lt;code&gt;JSlider.isFilled&lt;/code&gt; 속성의 값입니다 . 기본적으로 속성이 설정되지 않은 경우 &lt;code&gt;false&lt;/code&gt; , Ocean 테마의 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a27d5104e8734003866e124ec7ac94839d9fdbf" translate="yes" xml:space="preserve">
          <source>The value of the property is not inherited by owned windows.</source>
          <target state="translated">속성 값은 소유 된 창에서 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7acadd9356fd0eed465f05edbb22ae5050736f1" translate="yes" xml:space="preserve">
          <source>The value of the property, or null if there is no such property in this ObjectName.</source>
          <target state="translated">프로퍼티의 값.이 ObjectName에 그러한 프로퍼티이없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="8e6b1a6d6df9caa879e4a52b4aef13f1d4aeeca5" translate="yes" xml:space="preserve">
          <source>The value of the property.</source>
          <target state="translated">속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="7c68b6061bfa99862e097c1bb571847be45f5a36" translate="yes" xml:space="preserve">
          <source>The value of the property. Primitive types such as &quot;int&quot; will be wrapped as the corresponding object type such as &quot;java.lang.Integer&quot;.</source>
          <target state="translated">속성 값입니다. &quot;int&quot;와 같은 기본 유형은 &quot;java.lang.Integer&quot;와 같은 해당 오브젝트 유형으로 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ce8c1b4a0539cb032514fafac80fbdabadd594" translate="yes" xml:space="preserve">
          <source>The value of the protected &lt;code&gt;context&lt;/code&gt; field.</source>
          <target state="translated">보호 된 &lt;code&gt;context&lt;/code&gt; 필드 의 값</target>
        </trans-unit>
        <trans-unit id="fb83c5f6d070a52b005abe4eb82a7b90aa2658ad" translate="yes" xml:space="preserve">
          <source>The value of the result.</source>
          <target state="translated">결과의 값입니다.</target>
        </trans-unit>
        <trans-unit id="a5c45270efc048e5f1b9cd9f6afbcaa1274b9a65" translate="yes" xml:space="preserve">
          <source>The value of the retrieved attribute from the descriptor 'value' field or from the invocation of the operation in the 'getMethod' field of the descriptor.</source>
          <target state="translated">디스크립터 'value'필드 또는 디스크립터의 'getMethod'필드에서 오퍼레이션 호출에서 검색된 속성의 값입니다.</target>
        </trans-unit>
        <trans-unit id="b348eeda39c4d1e3238a0258085bfeb71a22ed5d" translate="yes" xml:space="preserve">
          <source>The value of the retrieved attribute.</source>
          <target state="translated">검색된 속성의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e2285df145b3c9ae26df5020d927db2f64460ec3" translate="yes" xml:space="preserve">
          <source>The value of the returned &lt;code&gt;BigDecimal&lt;/code&gt; is equal to</source>
          <target state="translated">리턴 값 &lt;code&gt;BigDecimal&lt;/code&gt; 와 같다</target>
        </trans-unit>
        <trans-unit id="7150f328ed1ab9b34e2676e12c0ca0d1ef0ff8f7" translate="yes" xml:space="preserve">
          <source>The value of the socket option.</source>
          <target state="translated">소켓 옵션의 값입니다.</target>
        </trans-unit>
        <trans-unit id="535d078962378e613737dbb726452780163b4074" translate="yes" xml:space="preserve">
          <source>The value of the socket option. A value of &lt;code&gt;null&lt;/code&gt; may be a valid value for some socket options.</source>
          <target state="translated">소켓 옵션의 값입니다. 값 &lt;code&gt;null&lt;/code&gt; 는, 일부 소켓 옵션에 대한 유효한 값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28d58f88eab8d9000d0c4ea336fd00f10e3fc44d" translate="yes" xml:space="preserve">
          <source>The value of the update element, or zero</source>
          <target state="translated">업데이트 요소의 값 또는 0</target>
        </trans-unit>
        <trans-unit id="7ae629426bd23caed26fa79e25619a881141187e" translate="yes" xml:space="preserve">
          <source>The value of the verticalAlignment property, one of the following constants defined in &lt;code&gt;SwingConstants&lt;/code&gt;: &lt;code&gt;TOP&lt;/code&gt;, &lt;code&gt;CENTER&lt;/code&gt;, or &lt;code&gt;BOTTOM&lt;/code&gt;.</source>
          <target state="translated">verticalAlignment 속성의 값으로 &lt;code&gt;SwingConstants&lt;/code&gt; 에 정의 된 다음 상수 중 하나 : &lt;code&gt;TOP&lt;/code&gt; , &lt;code&gt;CENTER&lt;/code&gt; , &lt;code&gt;BOTTOM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d50cdb99a13d27827b534e10ac604af9967b5a1" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;cert.provider.x509v1&lt;/code&gt; property has to be changed to instantiate another implementation. If this security property is not set, a default implementation will be used. Currently, due to possible security restrictions on access to Security properties, this value is looked up and cached at class initialization time and will fallback on a default implementation if the Security property is not accessible.</source>
          <target state="translated">이 &lt;code&gt;cert.provider.x509v1&lt;/code&gt; 특성 의 값은 다른 구현을 인스턴스화하도록 변경되어야합니다. 이 보안 속성을 설정하지 않으면 기본 구현이 사용됩니다. 현재 보안 특성에 대한 액세스에 대한 보안 제한 사항으로 인해이 값은 클래스 초기화시 조회 및 캐시되며 보안 특성에 액세스 할 수없는 경우 기본 구현에서 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0c1f825aa92de1380fa42da421fb94dab064632a" translate="yes" xml:space="preserve">
          <source>The value of this cell.</source>
          <target state="translated">이 셀의 값입니다.</target>
        </trans-unit>
        <trans-unit id="b60a5da34c192f58211cc46053f1f572c4bcdf56" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.applet&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.applet&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="70be25b63d854a9373d506112dfd3d18c4830bec" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.authoritative&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.authoritative&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b330540296e7168a688d0fb69bbfb34bf899dd2a" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.batchsize&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.batchsize&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f985e2167f0d965a15bc9d49973d2222a40eafb6" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.dns.url&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.dns.url&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="505f54502cd8d68ab0da6463ca38a0fec91385e7" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.control&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.control&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="7151f0bb014c7a5ab1e3e977660775d91a8bd76c" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.initial&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.initial&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="db62ad09fcd4f30699d9b514e5ba9db02ab135dd" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.object&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.object&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e9295a43ecaf172542c1bc89cc562dadd505eb4e" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.state&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.state&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="72e77db2979cf3c5d5df8c1f312fdcb7e3cf0dd8" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.url.pkgs&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.url.pkgs&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c23367e5ddc754ace44be4965849c443f3d3cf88" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.language&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.language&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="debafaf87500101460cf58fe25d46bd025885114" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.provider.url&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.provider.url&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="89c2070cd88436218f7f16bf66cb4edf6ba490b2" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.referral&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.referral&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="9cc48d1c5ca0afebb5ebfd310dd2dbd8487ff419" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.authentication&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.authentication&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4c0573f6efaba0c512fbcff0c36d7e5b791eae7f" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.credentials&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.credentials&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d87cc085dd14ae23c4bfcf35065e84615877a976" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.principal&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.principal&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="faea59681e2f4d68a14cc8e707a0f644a7fab244" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.protocol&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.protocol&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1eea6e7406196f98194d7dc4149b557304e5b765" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.spi.CannotProceedException&quot;.</source>
          <target state="translated">이 상수의 값은 &quot;java.naming.spi.CannotProceedException&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ca2029255b18ef7fc07dffc1f1d98d2c4a798dec" translate="yes" xml:space="preserve">
          <source>The value of this constant is 0.</source>
          <target state="translated">이 상수의 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9e4a7844333ec948b380e774556e82eb6fe0c6a9" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.bound.server.name&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.bound.server.name&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9f28810068395a3fbd50259cbc462fa2359430a" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.credentials&quot;&lt;/code&gt;.</source>
          <target state="translated">이 정수의 값은 &lt;code&gt;&quot;javax.security.sasl.credentials&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="470d84324d3f7fbd7bbb9ea4bcbc9b6b988c1568" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.maxbuffer&quot;&lt;/code&gt;.</source>
          <target state="translated">이 정수의 값은 &lt;code&gt;&quot;javax.security.sasl.maxbuffer&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31211a3383721cd0f9f3b326fde5e252995d83ce" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.credentials&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.credentials&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="959a445f01f7aad3ebc64b3b1f531a15a4e437ce" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.forward&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.forward&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e431aa384161ffc86b3e1453b5fb9e26219c7419" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.noactive&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.noactive&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a51b4b91f4b66398378907c088b0e7d664796c9" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.noanonymous&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.noanonymous&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0452024b914f4b0596371c42d90bfa7fba3f64b0" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.nodictionary&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.nodictionary&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa422d1fabd0c76c81a41c9fb85f540e36c02f2b" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.noplaintext&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.noplaintext&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ecd04d0142b9d176d5021d06e7368dededa7b0b" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.rawsendsize&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.rawsendsize&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ac4a332444a4793633faa0cd515cf9f64bef452" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.server.authentication&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.server.authentication&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03055235b2244f2e81fee5ab8a46b3ccf4c6c844" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5451c528917161e845b65a9600deb14a63245379" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f1f15de420d3f3cb04487857617eafedff4b7f93" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ddb9709927414a9036f3f779734e11c829be7e35" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbdd77c61d7d11ab57c8e33e4d6f179994662c3b" translate="yes" xml:space="preserve">
          <source>The value of this field can be accessed by the &lt;code&gt;getURL&lt;/code&gt; method.</source>
          <target state="translated">이 필드의 값은 &lt;code&gt;getURL&lt;/code&gt; 메소드 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fddbead7df76c109d78f7a8ca445c61cc40955f1" translate="yes" xml:space="preserve">
          <source>The value of this field can be set by the &lt;code&gt;setAllowUserInteraction&lt;/code&gt; method. Its value is returned by the &lt;code&gt;getAllowUserInteraction&lt;/code&gt; method. Its default value is the value of the argument in the last invocation of the &lt;code&gt;setDefaultAllowUserInteraction&lt;/code&gt; method.</source>
          <target state="translated">이 필드의 값은 &lt;code&gt;setAllowUserInteraction&lt;/code&gt; 메소드 로 설정할 수 있습니다 . 그 값은 &lt;code&gt;getAllowUserInteraction&lt;/code&gt; 메소드에 의해 리턴됩니다 . 기본값은 &lt;code&gt;setDefaultAllowUserInteraction&lt;/code&gt; 메소드 의 마지막 호출에서 인수의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4b53899ba2aa37cfd5864abd51817769da4f0c3d" translate="yes" xml:space="preserve">
          <source>The value of this flag determines whether the children of entity reference nodes are visible to the &lt;code&gt;NodeIterator&lt;/code&gt;.</source>
          <target state="translated">이 플래그의 값은 엔티티 참조 노드의 자식이 &lt;code&gt;NodeIterator&lt;/code&gt; 에 표시되는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="8285f8fddd872b1ccac016aa24e9ffe794588d80" translate="yes" xml:space="preserve">
          <source>The value of this flag determines whether the children of entity reference nodes are visible to the &lt;code&gt;NodeIterator&lt;/code&gt;. If false, these children and their descendants will be rejected. Note that this rejection takes precedence over &lt;code&gt;whatToShow&lt;/code&gt; and the filter. Also note that this is currently the only situation where &lt;code&gt;NodeIterators&lt;/code&gt; may reject a complete subtree rather than skipping individual nodes.</source>
          <target state="translated">이 플래그의 값은 엔티티 참조 노드의 자식이 &lt;code&gt;NodeIterator&lt;/code&gt; 에 표시되는지 여부를 결정합니다 . 거짓이면 이러한 자녀와 그 후손은 거부됩니다. 이 거부는 &lt;code&gt;whatToShow&lt;/code&gt; 및 필터 보다 우선 합니다. 또한 이것은 현재 &lt;code&gt;NodeIterators&lt;/code&gt; 가 개별 노드를 건너 뛰지 않고 전체 하위 트리를 거부 할 수 있는 유일한 상황 입니다.</target>
        </trans-unit>
        <trans-unit id="4c87ec24eaccea0ae40777eb6ee299a01ac437b4" translate="yes" xml:space="preserve">
          <source>The value of this flag determines whether the children of entity reference nodes are visible to the &lt;code&gt;TreeWalker&lt;/code&gt;.</source>
          <target state="translated">이 플래그의 값은 엔티티 참조 노드의 자식이 &lt;code&gt;TreeWalker&lt;/code&gt; 에 표시되는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="acc960da8ff95973951c52d5661c52e0624a7cec" translate="yes" xml:space="preserve">
          <source>The value of this flag determines whether the children of entity reference nodes are visible to the &lt;code&gt;TreeWalker&lt;/code&gt;. If false, these children and their descendants will be rejected. Note that this rejection takes precedence over &lt;code&gt;whatToShow&lt;/code&gt; and the filter, if any.</source>
          <target state="translated">이 플래그의 값은 엔티티 참조 노드의 자식이 &lt;code&gt;TreeWalker&lt;/code&gt; 에 표시되는지 여부를 결정합니다 . 거짓이면 이러한 자녀와 그 후손은 거부됩니다. 이 거부는 &lt;code&gt;whatToShow&lt;/code&gt; 및 필터 (있는 경우) 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="93e24fa416e38a6bf716c88887bf8da3c12c88a3" translate="yes" xml:space="preserve">
          <source>The value of this is updated as the properties relating to the mnemonic change (such as the mnemonic itself, the text...). You should only ever have to call this if you do not wish the default character to be underlined. For example, if the text at tab index 3 was 'Apple Price', with a mnemonic of 'p', and you wanted the 'P' to be decorated, as 'Apple &lt;u&gt;P&lt;/u&gt;rice', you would have to invoke &lt;code&gt;setDisplayedMnemonicIndex(3, 6)&lt;/code&gt; after invoking &lt;code&gt;setMnemonicAt(3, KeyEvent.VK_P)&lt;/code&gt;.</source>
          <target state="translated">이 값은 니모닉 변경과 관련된 속성 (예 : 니모닉 자체, 텍스트 ...)으로 업데이트됩니다. 기본 문자에 밑줄을 표시하지 않으려는 경우에만 이것을 호출해야합니다. 예를 들어 탭 인덱스 3의 텍스트가 'p'의 니모닉이있는 'Apple Price'이고 'P'를 'Apple &lt;u&gt;P&lt;/u&gt; rice' 로 장식하기를 원하면 &lt;code&gt;setDisplayedMnemonicIndex(3, 6)&lt;/code&gt; 를 호출해야합니다. , 6) &lt;code&gt;setMnemonicAt(3, KeyEvent.VK_P)&lt;/code&gt; 를 호출 한 후 .</target>
        </trans-unit>
        <trans-unit id="93e56d2a01d42f52c3a1f9fe48b9bdb10a596a95" translate="yes" xml:space="preserve">
          <source>The value of this is updated as the properties relating to the mnemonic change (such as the mnemonic itself, the text...). You should only ever have to call this if you do not wish the default character to be underlined. For example, if the text was 'Save As', with a mnemonic of 'a', and you wanted the 'A' to be decorated, as 'Save &lt;u&gt;A&lt;/u&gt;s', you would have to invoke &lt;code&gt;setDisplayedMnemonicIndex(5)&lt;/code&gt; after invoking &lt;code&gt;setDisplayedMnemonic(KeyEvent.VK_A)&lt;/code&gt;.</source>
          <target state="translated">이 값은 니모닉 변경과 관련된 속성 (예 : 니모닉 자체, 텍스트 ...)으로 업데이트됩니다. 기본 문자에 밑줄을 표시하지 않으려는 경우에만 이것을 호출해야합니다. 텍스트의 니모닉과 '다른 이름으로 저장', 'A',이었고, 예를 들어, 당신은 'A'는 '다른 이름으로 저장, 장식를 원 들', 당신이 호출 할 것이다 &lt;code&gt;setDisplayedMnemonicIndex(5)&lt;/code&gt; 호출 한 후에 &lt;code&gt;setDisplayedMnemonic(KeyEvent.VK_A)&lt;/code&gt; .&lt;u&gt;&lt;/u&gt;</target>
        </trans-unit>
        <trans-unit id="f4c672312363cd18956c41222b2c48a20cdcbcaf" translate="yes" xml:space="preserve">
          <source>The value of this is updated as the properties relating to the mnemonic change (such as the mnemonic itself, the text...). You should only ever have to call this if you do not wish the default character to be underlined. For example, if the text was 'Save As', with a mnemonic of 'a', and you wanted the 'A' to be decorated, as 'Save &lt;u&gt;A&lt;/u&gt;s', you would have to invoke &lt;code&gt;setDisplayedMnemonicIndex(5)&lt;/code&gt; after invoking &lt;code&gt;setMnemonic(KeyEvent.VK_A)&lt;/code&gt;.</source>
          <target state="translated">이 값은 니모닉 변경과 관련된 속성 (예 : 니모닉 자체, 텍스트 ...)으로 업데이트됩니다. 기본 문자에 밑줄을 표시하지 않으려는 경우에만 이것을 호출해야합니다. 텍스트의 니모닉과 '다른 이름으로 저장', 'A',이었고, 예를 들어, 당신은 'A'는 '다른 이름으로 저장, 장식를 원 들', 당신이 호출 할 것이다 &lt;code&gt;setDisplayedMnemonicIndex(5)&lt;/code&gt; 호출 한 후에 &lt;code&gt;setMnemonic(KeyEvent.VK_A)&lt;/code&gt; .&lt;u&gt;&lt;/u&gt;</target>
        </trans-unit>
        <trans-unit id="22e401b025a50784c8e45c2a0eed127a5b70d2f8" translate="yes" xml:space="preserve">
          <source>The value of this node, depending on its type; see the table above.</source>
          <target state="translated">유형에 따라이 노드의 값입니다. 위의 표를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c2086f3c26756452a9cb73220e9e49cabcfd876f" translate="yes" xml:space="preserve">
          <source>The value of this node, depending on its type; see the table above. When it is defined to be &lt;code&gt;null&lt;/code&gt;, setting it has no effect, including if the node is read-only.</source>
          <target state="translated">유형에 따라이 노드의 값입니다. 위의 표를 참조하십시오. &lt;code&gt;null&lt;/code&gt; 로 정의 된 경우 노드가 읽기 전용인지 여부를 포함하여 설정해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e9b5b9176900e2f7e73fa51e5d189eb641207bb" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.counter.threshold&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.counter.threshold&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="805bc0f84fb9bc3c7c29e277899cba9c75088a9e" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.attribute&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.error.attribute&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="8aae8963b9d0d4c118706ad729d8d7101e29ded5" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.mbean&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.error.mbean&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="96f76369ba45bc9c5be134158fd29b7c372302c9" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.runtime&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.error.runtime&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="aff36f8311add070b34ea295a25633a58a58c2a0" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.threshold&lt;/code&gt;.</source>
          <target state="translated">이 통지 유형의 값은 &lt;code&gt;jmx.monitor.error.threshold&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ed9ee71b1f970d4866364bbcf548b29ac9080a87" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.type&lt;/code&gt;.</source>
          <target state="translated">이 통지 유형의 값은 &lt;code&gt;jmx.monitor.error.type&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3d5fc439fac56d5a0fb765bacfd4d488c995be13" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.gauge.high&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.gauge.high&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="16b9f89192e3138677e5519341c20486c7c08f31" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.gauge.low&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.gauge.low&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="07d0c2e7618db99121021ce2e78af95512f4d70e" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.string.differs&lt;/code&gt;.</source>
          <target state="translated">이 통지 유형의 값은 &lt;code&gt;jmx.monitor.string.differs&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="99445c3c77b537173304b9ebd614ce3cc4025612" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.string.matches&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.string.matches&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="1c36785e4a19cb7ed48b6e59925e37acea61cb50" translate="yes" xml:space="preserve">
          <source>The value of this property is taken to be the fully-qualified name of a concrete &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/a&gt; class. The class is loaded using the system class loader and instantiated. The factory's &lt;a href=&quot;../../util/concurrent/threadfactory#newThread(java.lang.Runnable)&quot;&gt;&lt;code&gt;newThread&lt;/code&gt;&lt;/a&gt; method is invoked to create each thread for the default group's thread pool. If the process to load and instantiate the value of the property fails then an unspecified error is thrown during the construction of the default group.</source>
          <target state="translated">이 속성의 값은 구체적인 &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt; &lt;code&gt;ThreadFactory&lt;/code&gt; &lt;/a&gt; 클래스 의 정규화 된 이름으로 간주 됩니다. 클래스는 시스템 클래스 로더를 사용하여로드되고 인스턴스화됩니다. 팩토리의 &lt;a href=&quot;../../util/concurrent/threadfactory#newThread(java.lang.Runnable)&quot;&gt; &lt;code&gt;newThread&lt;/code&gt; &lt;/a&gt; 메서드가 호출되어 기본 그룹의 스레드 풀에 대한 각 스레드를 만듭니다. 속성 값을로드하고 인스턴스화하는 프로세스가 실패하면 기본 그룹을 구성하는 동안 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac0faf0ee35ba6f9fe8a29efe20b4f587e920230" translate="yes" xml:space="preserve">
          <source>The value of this property is taken to be the fully-qualified name of a concrete &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/a&gt; class. The class is loaded using the system class loader and instantiated. The factory's &lt;a href=&quot;../../util/concurrent/threadfactory#newThread-java.lang.Runnable-&quot;&gt;&lt;code&gt;newThread&lt;/code&gt;&lt;/a&gt; method is invoked to create each thread for the default group's thread pool. If the process to load and instantiate the value of the property fails then an unspecified error is thrown during the construction of the default group.</source>
          <target state="translated">이 프로퍼티의 값은, 구체적인 &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt; &lt;code&gt;ThreadFactory&lt;/code&gt; &lt;/a&gt; 클래스 의 완전한 이름이 됩니다. 클래스는 시스템 클래스 로더를 사용하여로드되고 인스턴스화됩니다. 팩토리의 &lt;a href=&quot;../../util/concurrent/threadfactory#newThread-java.lang.Runnable-&quot;&gt; &lt;code&gt;newThread&lt;/code&gt; &lt;/a&gt; 메소드는 기본 그룹의 스레드 풀에 대한 각 스레드를 작성하기 위해 호출됩니다. 속성 값을로드하고 인스턴스화하는 프로세스가 실패하면 기본 그룹을 구성하는 동안 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="faedb6e636b2c0bf3f25486ce02c8a4b90b5e19e" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;a href=&quot;networkinterface&quot;&gt;&lt;code&gt;NetworkInterface&lt;/code&gt;&lt;/a&gt; that represents the outgoing interface for multicast datagrams sent by the datagram-oriented socket. For &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; sockets then it is system dependent whether setting this option also sets the outgoing interface for multicast datagrams sent to IPv4 addresses.</source>
          <target state="translated">이 소켓 옵션의 값은 데이터 그램 지향 소켓에 의해 전송 된 멀티 캐스트 데이터 그램에 대한 발신 인터페이스를 나타내는 &lt;a href=&quot;networkinterface&quot;&gt; &lt;code&gt;NetworkInterface&lt;/code&gt; &lt;/a&gt; 입니다. 대한 &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 소켓 다음이 옵션을 설정하면 또한 IPv4 주소로 전송 멀티 캐스트 데이터 그램에 대한 나가는 인터페이스를 설정할지 여부를 의존하는 시스템이다.</target>
        </trans-unit>
        <trans-unit id="52d41017b39ecaa0454385d328f3b6bd932b4bc4" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that controls the &lt;em&gt;loopback&lt;/em&gt; of multicast datagrams. The value of the socket option represents if the option is enabled or disabled.</source>
          <target state="translated">이 소켓 옵션의 값은 멀티 캐스트 데이터 그램 의 &lt;em&gt;루프백&lt;/em&gt; 을 제어 하는 &lt;code&gt;Boolean&lt;/code&gt; 입니다 . 소켓 옵션의 값은 옵션의 활성화 여부를 나타냅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0782095e27c4f63c26addb4f4b586af5276685e2" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. The exact semantics of this socket option are socket type and system dependent.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 활성화 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 이 소켓 옵션의 정확한 의미는 소켓 유형 및 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c799a28ae4a75daf519e682a26de2c11c010df2a" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. The option is specific to datagram-oriented sockets sending to &lt;a href=&quot;inet4address&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; broadcast addresses. When the socket option is enabled then the socket can be used to send &lt;em&gt;broadcast datagrams&lt;/em&gt;.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 사용 가능 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 이 옵션은 &lt;a href=&quot;inet4address&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 브로드 캐스트 주소로 보내는 데이터 그램 지향 소켓에 따라 다릅니다 . 소켓 옵션이 활성화되면 소켓을 사용하여 &lt;em&gt;브로드 캐스트 데이터 그램&lt;/em&gt; 을 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="378a8b74d2abd11578002c1e83ca787b93b99699" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. The socket option is specific to stream-oriented sockets using the TCP/IP protocol. TCP/IP uses an algorithm known as &lt;em&gt;The Nagle Algorithm&lt;/em&gt; to coalesce short segments and improve network efficiency.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 사용 가능 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 소켓 옵션은 TCP / IP 프로토콜을 사용하는 스트림 지향 소켓에 따라 다릅니다. TCP / IP는 &lt;em&gt;Nagle 알고리즘&lt;/em&gt; 이라는 알고리즘을 사용하여 짧은 세그먼트를 통합하고 네트워크 효율성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="f111eca53be5c4a77e641dab1abf0b374fefe83a" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. When the &lt;code&gt;SO_KEEPALIVE&lt;/code&gt; option is enabled the operating system may use a &lt;em&gt;keep-alive&lt;/em&gt; mechanism to periodically probe the other end of a connection when the connection is otherwise idle. The exact semantics of the keep alive mechanism is system dependent and therefore unspecified.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 사용 가능 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 때 &lt;code&gt;SO_KEEPALIVE&lt;/code&gt; 옵션은 운영 체제가 사용할 수 있습니다 사용할 수 있습니다 &lt;em&gt;연결 유지&lt;/em&gt; 주기적으로 연결의 다른 쪽 끝을 조사하는기구를 연결이 유휴 상태 일 때. 연결 유지 메커니즘의 정확한 의미는 시스템에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ff8b71c0be896401e7f25bf544169440736d7ac" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; in the range &lt;code&gt;0 &amp;lt;= value &amp;lt;= 255&lt;/code&gt;. It is used to control the scope of multicast datagrams sent by the datagram-oriented socket. In the case of an &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket the option is the time-to-live (TTL) on multicast datagrams sent by the socket. Datagrams with a TTL of zero are not transmitted on the network but may be delivered locally. In the case of an &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket the option is the &lt;em&gt;hop limit&lt;/em&gt; which is number of &lt;em&gt;hops&lt;/em&gt; that the datagram can pass through before expiring on the network. For IPv6 sockets it is system dependent whether the option also sets the &lt;em&gt;time-to-live&lt;/em&gt; on multicast datagrams sent to IPv4 addresses.</source>
          <target state="translated">이 소켓 옵션의 값은 &lt;code&gt;0 &amp;lt;= value &amp;lt;= 255&lt;/code&gt; 범위 의 &lt;code&gt;Integer&lt;/code&gt; 입니다 . 데이터 그램 지향 소켓에 의해 전송 된 멀티 캐스트 데이터 그램의 범위를 제어하는 ​​데 사용됩니다. 의 경우 &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; 의&lt;/a&gt; 옵션이 소켓에서 보낸 멀티 캐스트 데이터 그램의 시간 (TTL)이다 소켓. TTL이 0 인 데이터 그램은 네트워크에서 전송되지 않지만 로컬로 전달 될 수 있습니다. 의 경우 &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; 의&lt;/a&gt; 옵션이있다 소켓 &lt;em&gt;홉 제한&lt;/em&gt; 의 수입니다 &lt;em&gt;홉&lt;/em&gt; 데이터 그램이 네트워크에 만료되기 전에 통과 할 수있는가. IPv6 소켓의 경우, 옵션 이 IPv4 주소로 전송 된 멀티 캐스트 데이터 그램에서 &lt;em&gt;수명&lt;/em&gt; 을 설정하는지 여부는 시스템에 따라 다릅니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0aaeb374d470c89144bd7d473179b01228a3931" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; representing the value of the ToS octet in IP packets sent by sockets to an &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket. The interpretation of the ToS octet is network specific and is not defined by this class. Further information on the ToS octet can be found in &lt;a href=&quot;http://www.ietf.org/rfc/rfc1349.txt&quot;&gt;RFC 1349&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2474.txt&quot;&gt;RFC 2474&lt;/a&gt;. The value of the socket option is a &lt;em&gt;hint&lt;/em&gt;. An implementation may ignore the value, or ignore specific values.</source>
          <target state="translated">이 소켓 옵션 의 값은 소켓이 &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 소켓으로 보낸 IP 패킷의 ToS 옥텟 값을 나타내는 &lt;code&gt;Integer&lt;/code&gt; 입니다. ToS 옥텟의 해석은 네트워크에 따라 다르며이 클래스에 의해 정의되지 않습니다. ToS 옥텟에 대한 추가 정보는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1349.txt&quot;&gt;RFC 1349&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2474.txt&quot;&gt;RFC 2474&lt;/a&gt; 에서 찾을 수 있습니다 . 소켓 옵션의 값은 &lt;em&gt;힌트&lt;/em&gt; 입니다. 구현시 값을 무시하거나 특정 값을 무시할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9f336d96465d1b5cce00d70fe23ba02abe6c752" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; that controls the action taken when unsent data is queued on the socket and a method to close the socket is invoked. If the value of the socket option is zero or greater, then it represents a timeout value, in seconds, known as the &lt;em&gt;linger interval&lt;/em&gt;. The linger interval is the timeout for the &lt;code&gt;close&lt;/code&gt; method to block while the operating system attempts to transmit the unsent data or it decides that it is unable to transmit the data. If the value of the socket option is less than zero then the option is disabled. In that case the &lt;code&gt;close&lt;/code&gt; method does not wait until unsent data is transmitted; if possible the operating system will transmit any unsent data before the connection is closed.</source>
          <target state="translated">이 소켓 옵션의 값은 보내지 않은 데이터가 소켓에 대기하고 소켓을 닫는 메소드가 호출 될 때 수행되는 조치를 제어 하는 &lt;code&gt;Integer&lt;/code&gt; 입니다. socket 옵션의 값이 0 이상인 경우, 시간 초과 값을 초 단위로 표시합니다 ( &lt;em&gt;링거 간격)&lt;/em&gt; . 느린 간격은 운영 체제가 보내지 않은 데이터를 전송하려고 시도하거나 데이터를 전송할 수없는 것으로 결정하는 동안 &lt;code&gt;close&lt;/code&gt; 메서드가 차단되는 시간 초과입니다 . 소켓 옵션의 값이 0보다 작 으면 옵션이 비활성화됩니다. 이 경우 &lt;code&gt;close&lt;/code&gt; 메소드는 전송되지 않은 데이터가 전송 될 때까지 기다리지 않습니다. 가능하면 운영 체제는 연결을 닫기 전에 보내지 않은 데이터를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="aa78f370acd97919109586e7fab1f967828d0cb4" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; that is the size of the socket receive buffer in bytes. The socket receive buffer is an input buffer used by the networking implementation. It may need to be increased for high-volume connections or decreased to limit the possible backlog of incoming data. The value of the socket option is a &lt;em&gt;hint&lt;/em&gt; to the implementation to size the buffer and the actual size may differ.</source>
          <target state="translated">이 소켓 옵션의 값은 소켓 수신 버퍼의 크기 (바이트 ) 인 &lt;code&gt;Integer&lt;/code&gt; 입니다. 소켓 수신 버퍼는 네트워킹 구현에서 사용되는 입력 버퍼입니다. 대량 연결의 경우 증가하거나 들어오는 데이터의 백 로그를 제한하기 위해 감소해야 할 수 있습니다. 소켓 옵션의 값은 버퍼 크기를 조정하는 구현에 대한 &lt;em&gt;힌트&lt;/em&gt; 이며 실제 크기는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3964a21153626d6dca5ee91d3e140a157ee18420" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; that is the size of the socket send buffer in bytes. The socket send buffer is an output buffer used by the networking implementation. It may need to be increased for high-volume connections. The value of the socket option is a &lt;em&gt;hint&lt;/em&gt; to the implementation to size the buffer and the actual size may differ. The socket option can be queried to retrieve the actual size.</source>
          <target state="translated">이 소켓 옵션의 값은 소켓 송신 버퍼의 크기 (바이트 ) 인 &lt;code&gt;Integer&lt;/code&gt; 입니다. 소켓 송신 버퍼는 네트워킹 구현에서 사용되는 출력 버퍼입니다. 대용량 연결의 경우이 값을 늘려야 할 수 있습니다. 소켓 옵션의 값은 버퍼 크기를 조정하는 구현에 대한 &lt;em&gt;힌트&lt;/em&gt; 이며 실제 크기는 다를 수 있습니다. 실제 크기를 검색하기 위해 소켓 옵션을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e29e94ffa50d1811c8c377fed262ac17b18615" translate="yes" xml:space="preserve">
          <source>The value of this type string is &lt;code&gt;jmx.attribute.change&lt;/code&gt;.</source>
          <target state="translated">이 유형 문자열의 값은 &lt;code&gt;jmx.attribute.change&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eae86827f3a1e6e6b1a2cc87015f797db0fbc402" translate="yes" xml:space="preserve">
          <source>The value passed in is converted to a byte, which may lose information.</source>
          <target state="translated">전달 된 값은 바이트로 변환되어 정보가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b9d68f8861a0f3a1d298ab379faa4e96b2ee1c" translate="yes" xml:space="preserve">
          <source>The value previously associated with the given name. Returns null if no value was previously associated with the name.</source>
          <target state="translated">주어진 이름과 이전에 연결된 값입니다. 이전에 이름과 연결된 값이 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="193e10e740caf76fa19a1f3cbe75690884cfc899" translate="yes" xml:space="preserve">
          <source>The value property of an &lt;code&gt;Expression&lt;/code&gt; is set to a unique private (non-&lt;code&gt;null&lt;/code&gt;) value by default and this value is used as an internal indication that the method has not yet been called. A return value of &lt;code&gt;null&lt;/code&gt; replaces this default value in the same way that any other value would, ensuring that expressions are never evaluated more than once.</source>
          <target state="translated">&lt;code&gt;Expression&lt;/code&gt; 의 value 속성은 기본적으로 고유 한 private ( &lt;code&gt;null&lt;/code&gt; 이 아닌 ) 값으로 설정 되며이 값은 메서드가 아직 호출되지 않았 음을 나타내는 내부 표시로 사용됩니다. &lt;code&gt;null&lt;/code&gt; 값을 반환 하면 다른 모든 값과 동일한 방식으로이 기본값이 바뀌므로식이 두 번 이상 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56062e980fc25005712c46d7b85ed054b65b96fe" translate="yes" xml:space="preserve">
          <source>The value range represented by the bubble in this example is the &lt;em&gt;visible amount&lt;/em&gt;. The horizontal scroll bar in this example could be created with code like the following:</source>
          <target state="translated">이 예에서 거품으로 표시되는 값 범위는 &lt;em&gt;가시적 양&lt;/em&gt; 입니다. 이 예제의 가로 스크롤 막대는 다음과 같은 코드로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31f5093977dcc1cdd4697dab36dd10971db541b7" translate="yes" xml:space="preserve">
          <source>The value represented by the string is larger than the largest unsigned &lt;code&gt;int&lt;/code&gt;, 2&lt;sup&gt;32&lt;/sup&gt;-1.</source>
          <target state="translated">문자열로 표시되는 값이 가장 큰 부호없는 &lt;code&gt;int&lt;/code&gt; 2 &lt;sup&gt;32&lt;/sup&gt; -1 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="d6f78b1ec9763b41e7fb9ba7f86d098e20d6f9a2" translate="yes" xml:space="preserve">
          <source>The value represented by the string is larger than the largest unsigned &lt;code&gt;long&lt;/code&gt;, 2&lt;sup&gt;64&lt;/sup&gt;-1.</source>
          <target state="translated">문자열로 표시되는 값이 가장 큰 부호없는 &lt;code&gt;long&lt;/code&gt; , 2 &lt;sup&gt;64&lt;/sup&gt; -1 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="7ec8c505fdb637aca2b4b00c43e241fdc3c70c56" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값이 &lt;code&gt;byte&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2dd516c49699030c6a86876fa65104bf2bacc9c3" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값이 &lt;code&gt;int&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="080e00aed4fe6d75b4b9f01ff131e35f0a26ccd4" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값이 &lt;code&gt;long&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="dd537294351459ff10862aaa7bdcdb05b16e77a1" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값이 &lt;code&gt;short&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5e06dbc0376f2c39b3d860c99781e7379ae01651" translate="yes" xml:space="preserve">
          <source>The value represents changes to &lt;code&gt;JList&lt;/code&gt; model.</source>
          <target state="translated">값은 &lt;code&gt;JList&lt;/code&gt; 모델의 변경 사항을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0f12330d9fb9c44cda30304a94bf0247a7def212" translate="yes" xml:space="preserve">
          <source>The value represents if the old border is painted.</source>
          <target state="translated">값은 이전 테두리가 그려 졌는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7461020eda03ffb8a4938984caf8473bc3d329d5" translate="yes" xml:space="preserve">
          <source>The value represents if the width of children should be synchronized.</source>
          <target state="translated">값은 자식 너비가 동기화되어야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e116924436bf7c8d4007129887075eebdca3586" translate="yes" xml:space="preserve">
          <source>The value returned by the procedure or function</source>
          <target state="translated">프로 시저 또는 함수가 리턴 한 값</target>
        </trans-unit>
        <trans-unit id="a4624000eb901432b19900a8426561fff4b2b375" translate="yes" xml:space="preserve">
          <source>The value returned by the procedure. The rules for converting the scripting variable returned by the script method to a Java Object are implementation-specific.</source>
          <target state="translated">프로 시저가 리턴 한 값. 스크립트 메소드가 리턴 한 스크립팅 변수를 Java 오브젝트로 변환하는 규칙은 구현마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="67e56c1928fd73288739bc1a971b0ef8da9c3a99" translate="yes" xml:space="preserve">
          <source>The value returned by the script execution, if any. Should return &lt;code&gt;null&lt;/code&gt; if no value is returned by the script execution.</source>
          <target state="translated">스크립트 실행에 의해 반환되는 값입니다 (있는 경우). 스크립트 실행에서 값이 반환되지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="110307d8995a99466a52bbbf0e1fd931923962c2" translate="yes" xml:space="preserve">
          <source>The value returned by the script.</source>
          <target state="translated">스크립트가 반환 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="232a4c3688c018a1f715de261ad24f1b8ccdde7a" translate="yes" xml:space="preserve">
          <source>The value returned by this method is equal to the value that would be returned by &lt;code&gt;Arrays.asList(a).hashCode()&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, in which case &lt;code&gt;0&lt;/code&gt; is returned.</source>
          <target state="translated">이 메소드가 돌려주는 값은 , &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 가 아닌 한 , &lt;code&gt;0&lt;/code&gt; 이 돌려 &lt;code&gt;Arrays.asList(a).hashCode()&lt;/code&gt; 지지 않는 한 , Arrays.asList (a) .hashCode ()에 의해 돌려 주어지는 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4830ed24165ee75d854121d512ff4c6287d16823" translate="yes" xml:space="preserve">
          <source>The value returned by this method is equal to the value that would be returned by &lt;code&gt;Arrays.asList(a).toString()&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, in which case &lt;code&gt;&quot;null&quot;&lt;/code&gt; is returned.</source>
          <target state="translated">이 방법에 의해 리턴되는 값에 의해 반환되는 값과 동일 &lt;code&gt;Arrays.asList(a).toString()&lt;/code&gt; 않으면, &lt;code&gt;a&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 되는 경우, &lt;code&gt;&quot;null&quot;&lt;/code&gt; 복귀된다.</target>
        </trans-unit>
        <trans-unit id="232dc690dfd39932093a041bd1c51386276914f0" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcb0889a89cf753f196944afc79bf5930394212e" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/byte&quot;&gt;&lt;code&gt;Byte&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/byte&quot;&gt; &lt;code&gt;Byte&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c247535daa5438a006bd4fe6cb6a927686d1475" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f70659dc298bb8fc9204c5ab38fee74c2fad99a" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/double&quot;&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/double&quot;&gt; &lt;code&gt;Double&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d72a0c9ed70e30930effbed3603918ae9c5b9c7c" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/float&quot;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/float&quot;&gt; &lt;code&gt;Float&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89e5930314a96e3dbf717f46716dfe509ba77c35" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8879341be0438371ec7102d7cde11423f91f127" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2baaebdb48a83638b0d0d8218eefc93c58d95bff" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode()&quot;&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/short&quot;&gt;&lt;code&gt;Short&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode()&quot;&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/short&quot;&gt; &lt;code&gt;Short&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="497f48c5d27b5d369d6b9d0a0e986992c79396f5" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d9dbfc6d6211692de527549b2fcd5858a66bb72" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/byte&quot;&gt;&lt;code&gt;Byte&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/byte&quot;&gt; &lt;code&gt;Byte&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61e555fbf6ad7db5b6071c0b6b9e1c1677c17310" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="202f92c2c1f2690fa3631974cac693f1c7bc62a6" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/double&quot;&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/double&quot;&gt; &lt;code&gt;Double&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c915104330624d5c65626efa3aeedf957b1ba02" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/float&quot;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/float&quot;&gt; &lt;code&gt;Float&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6086d722cb980f02f1d9be10f9049cb0b95e719" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05c957e2b334ef39fa0169c9d7f5a824127ab492" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="630057fa5af0e23dd224c2a30f87a15dcf29fe3f" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/short&quot;&gt;&lt;code&gt;Short&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/short&quot;&gt; &lt;code&gt;Short&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3446146db6ab390bdd9c3f968d4d845281bdb3a" translate="yes" xml:space="preserve">
          <source>The value returned from the execution of the script.</source>
          <target state="translated">스크립트 실행에서 반환 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="9e9bb57019f994d2e6cdaaaf2694c5939552e475" translate="yes" xml:space="preserve">
          <source>The value returned is &lt;code&gt;count - pos&lt;/code&gt;, which is the number of bytes remaining to be read from the input buffer.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;count - pos&lt;/code&gt; 이며, 이는 입력 버퍼에서 읽을 남은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="55349d45b1798417fa58a2e4c3952f10780b9ff0" translate="yes" xml:space="preserve">
          <source>The value returned is &lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;, which is the number of bytes remaining to be read from the input buffer.</source>
          <target state="translated">리턴 된 값은 &lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt; . 이는 입력 버퍼에서 읽을 나머지 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2036e23bfa2dc5e8d0a1aee47cc9e89872df1136" translate="yes" xml:space="preserve">
          <source>The value returned is a two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;, where &lt;em&gt;m&lt;/em&gt; is at least 5. Each of the &lt;em&gt;n&lt;/em&gt; rows is an entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;. Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from 0..&lt;em&gt;n&lt;/em&gt;-1):</source>
          <target state="translated">리턴 된 값은 크기가 &lt;em&gt;n&lt;/em&gt; x &lt;em&gt;m&lt;/em&gt; 인 2 차원 문자열 배열이며 , 여기서 &lt;em&gt;m&lt;/em&gt; 은 5 이상입니다. 각 &lt;em&gt;n&lt;/em&gt; 행은 단일 &lt;code&gt;TimeZone&lt;/code&gt; 의 현지화 된 이름을 포함하는 항목 입니다. 이러한 각 행에는 다음이 포함됩니다 ( &lt;code&gt;i&lt;/code&gt; 범위는 0 .. &lt;em&gt;n&lt;/em&gt; -1 임).</target>
        </trans-unit>
        <trans-unit id="03c9efb8c5db2500c4c240fcd8666dee938e1da7" translate="yes" xml:space="preserve">
          <source>The value returned is only an estimate because the number of thread groups may change dynamically while this method traverses internal data structures. This method is intended primarily for debugging and monitoring purposes.</source>
          <target state="translated">이 메소드가 내부 데이터 구조를 순회하는 동안 스레드 그룹의 수가 동적으로 변경 될 수 있으므로 리턴 된 값은 추정치입니다. 이 방법은 주로 디버깅 및 모니터링 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="852cc356c26f432ab42fcc161a95ca76132880ee" translate="yes" xml:space="preserve">
          <source>The value returned is only an estimate because the number of threads may change dynamically while this method traverses internal data structures, and might be affected by the presence of certain system threads. This method is intended primarily for debugging and monitoring purposes.</source>
          <target state="translated">리턴 된 값은이 메소드가 내부 데이터 구조를 순회하는 동안 스레드 수가 동적으로 변경 될 수 있고 특정 시스템 스레드의 존재에 영향을받을 수 있으므로 추정치 일뿐입니다. 이 방법은 주로 디버깅 및 모니터링 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d0dcb8fef06003ce60cc41e24ee714539bc408" translate="yes" xml:space="preserve">
          <source>The value specified for the client info property was not valid.</source>
          <target state="translated">클라이언트 정보 속성에 지정된 값이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f34120cadaae7df3f69e5f2c0ac389c7948d108b" translate="yes" xml:space="preserve">
          <source>The value specified for the client info property was too large.</source>
          <target state="translated">클라이언트 정보 속성에 지정된 값이 너무 큽니다.</target>
        </trans-unit>
        <trans-unit id="b84a0253c5b3c6f11eea15293b58032f1c52ac87" translate="yes" xml:space="preserve">
          <source>The value specified is not valid for the attribute.</source>
          <target state="translated">지정된 값이 속성에 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14c8a2bbd1f24dad039061a5555c60e31d69ae69" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the annotated class can be used as a container for other Swing components or not.</source>
          <target state="translated">주석이 달린 클래스를 다른 Swing 구성 요소의 컨테이너로 사용할 수 있는지 여부를 나타내는 값입니다.</target>
        </trans-unit>
        <trans-unit id="7ae014891d799c92b6efbd397ed8cc4ce73acb48" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the annotated property can be a &lt;a href=&quot;propertydescriptor#isBound()&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; property or not.</source>
          <target state="translated">주석이 추가 된 속성이 &lt;a href=&quot;propertydescriptor#isBound()&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 된 속성 일 수 있는지 여부를 나타내는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="24115412120085dcaf4f07f5548ba65079e68f69" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the annotated property can be a &lt;a href=&quot;propertydescriptor#isBound()&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; property or not. This value applies only to the beans that have the &lt;a href=&quot;propertychangelistener&quot;&gt;&lt;code&gt;propertyChange&lt;/code&gt;&lt;/a&gt; event set.</source>
          <target state="translated">주석이 추가 된 속성이 &lt;a href=&quot;propertydescriptor#isBound()&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 된 속성 일 수 있는지 여부를 나타내는 값입니다 . 이 값은 &lt;a href=&quot;propertychangelistener&quot;&gt; &lt;code&gt;propertyChange&lt;/code&gt; &lt;/a&gt; 이벤트가 설정된 Bean에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfc34c213af513bebf9467c68fef45126a00b778" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the annotated property is a &lt;a href=&quot;featuredescriptor#isHidden()&quot;&gt;&lt;code&gt;hidden&lt;/code&gt;&lt;/a&gt; property or not.</source>
          <target state="translated">주석이 달린 속성이 &lt;a href=&quot;featuredescriptor#isHidden()&quot;&gt; &lt;code&gt;hidden&lt;/code&gt; &lt;/a&gt; 속성 인지 여부를 나타내는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="aa6846c638215ea81b5c65296d28f66917b392d1" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the annotated property is a &lt;a href=&quot;featuredescriptor#isPreferred()&quot;&gt;&lt;code&gt;preferred&lt;/code&gt;&lt;/a&gt; property or not.</source>
          <target state="translated">주석이 달린 속성이 &lt;a href=&quot;featuredescriptor#isPreferred()&quot;&gt; &lt;code&gt;preferred&lt;/code&gt; &lt;/a&gt; 속성 인지 여부를 나타내는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="12269a6d0972fe1a940494817904c29acecac4e9" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the annotated property is a required property or not.</source>
          <target state="translated">주석이 달린 속성이 필수 속성인지 여부를 나타내는 값입니다.</target>
        </trans-unit>
        <trans-unit id="a376114d4264e56522dce880ed537c8755a33a20" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the annotated property is an &lt;a href=&quot;featuredescriptor#isExpert()&quot;&gt;&lt;code&gt;expert&lt;/code&gt;&lt;/a&gt; property or not.</source>
          <target state="translated">주석이 달린 속성이 &lt;a href=&quot;featuredescriptor#isExpert()&quot;&gt; &lt;code&gt;expert&lt;/code&gt; &lt;/a&gt; 속성 인지 여부를 나타내는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="35079b9749d7066ba0ecc06aa3a23c3be2022203" translate="yes" xml:space="preserve">
          <source>The value that indicates whether the corresponding component is repainted after the annotated property got changed or not.</source>
          <target state="translated">주석이 달린 속성이 변경된 후 해당 구성 요소가 다시 그려 지는지 여부를 나타내는 값입니다.</target>
        </trans-unit>
        <trans-unit id="500cac38ba0a7780ed53053b9886791f008d3156" translate="yes" xml:space="preserve">
          <source>The value will be printed as per the normal format of an integer value. Only negative numbers will be signed. No padding will be added.</source>
          <target state="translated">정수 값의 일반 형식에 따라 값이 인쇄됩니다. 음수 만 서명됩니다. 패딩이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="077fed1deaf9df7e8c41edbc6bfae89dbe78a3a1" translate="yes" xml:space="preserve">
          <source>The value will be the value as reported to applications, appropriately normalized and with entity and character references expanded.</source>
          <target state="translated">값은 애플리케이션에보고되고 적절하게 정규화되고 엔티티 및 문자 참조가 확장 된 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="9e6acd3ee9804ea2240ae60fd89170c2a1ca81d0" translate="yes" xml:space="preserve">
          <source>The value will be zero-padded on the left. If the size of the value means that it cannot be printed within the width then an exception is thrown. If the value of the field is negative then an exception is thrown during formatting.</source>
          <target state="translated">왼쪽에 값이 0으로 채워집니다. 값의 크기가 너비 내에서 인쇄 할 수 없음을 의미하면 예외가 발생합니다. 필드 값이 음수이면 서식 지정 중에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="96d7319e3b7d2f8db393dc70b5fe04dbc970989d" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; are associated with two earlier eras, Meiji and Taisho, respectively.</source>
          <target state="translated">값 &lt;code&gt;-1&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 은 각각 이전의 두 시대 인 메이지와 다이쇼와 연관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="031c945b382d2bfa8a375b39b12c9b937e2dbd2c" translate="yes" xml:space="preserve">
          <source>The values are equal.</source>
          <target state="translated">값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c207ea95e8a56f3038b875f5e458580dce26ff8" translate="yes" xml:space="preserve">
          <source>The values are key/value pairs of two types. The first type of pairs consists of those whose keys are reserved and defined in this specification or by individual implementations. The values in the pairs with reserved keys have specified meanings.</source>
          <target state="translated">값은 두 가지 유형의 키 / 값 쌍입니다. 첫 번째 유형의 쌍은 키가이 사양에서 예약되고 정의 된 개별 구성 또는 개별 구현으로 구성됩니다. 예약 된 키가있는 쌍의 값에는 지정된 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36e9ac0d41a47dcc5adf02d33d70256195d6bc3" translate="yes" xml:space="preserve">
          <source>The values are numbered following the ISO-8601 standard, from 1 (January) to 12 (December).</source>
          <target state="translated">값은 ISO-8601 표준에 따라 1 (1 월)에서 12 (12 월)까지 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="4fbf2c5d52494af17a1c11cea5070baeda03267c" translate="yes" xml:space="preserve">
          <source>The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday). See &lt;a href=&quot;temporal/weekfields#dayOfWeek()&quot;&gt;&lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt;&lt;/a&gt; for localized week-numbering.</source>
          <target state="translated">값은 ISO-8601 표준에 따라 1 (월요일)에서 7 (일요일)까지 번호가 지정됩니다. 지역화 된 주 번호 지정 은 &lt;a href=&quot;temporal/weekfields#dayOfWeek()&quot;&gt; &lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f7227c6c87280051d32783be85f72f98db78fec" translate="yes" xml:space="preserve">
          <source>The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday). See &lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt;&lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt;&lt;/a&gt; for localized week-numbering.</source>
          <target state="translated">값은 ISO-8601 표준에 따라 1 (월요일)에서 7 (일요일)까지 번호가 매겨집니다. 현지화 된 주 번호 매기기에 대해서는 &lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt; &lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4964f5f7d03897a69f31da6fe78d8fc1cf06ae6c" translate="yes" xml:space="preserve">
          <source>The values are only read out of UIManager once, and then cached. If you need to read the values again (for example, if the UI is being reloaded), then discard this NimbusStyle and read a new one from NimbusLookAndFeel using NimbusLookAndFeel.getStyle.</source>
          <target state="translated">값은 UIManager에서 한 번만 읽혀진 다음 캐시됩니다. 값을 다시 읽어야하는 경우 (예 : UI가 다시로드되는 경우)이 NimbusStyle을 버리고 NimbusLookAndFeel.getStyle을 사용하여 NimbusLookAndFeel에서 새 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="33b7873b8936786df23727b9369a432b05e1d503" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;WEIGHT&lt;/code&gt;, &lt;code&gt;WIDTH&lt;/code&gt;, and &lt;code&gt;POSTURE&lt;/code&gt; are interpolated by the system, which can select the 'nearest available' font or use other techniques to approximate the user's request.</source>
          <target state="translated">&lt;code&gt;WEIGHT&lt;/code&gt; , &lt;code&gt;WIDTH&lt;/code&gt; 및 &lt;code&gt;POSTURE&lt;/code&gt; 값 은 시스템에 의해 보간되며, 시스템은 '가장 가까운 사용 가능한'글꼴을 선택하거나 다른 기술을 사용하여 사용자의 요청에 근접 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103d4a4344917ad71ffdead36a1faff6de82ef17" translate="yes" xml:space="preserve">
          <source>The values for an attribute are immutable, or must not be mutated by clients or storage. They are always passed by reference, and not cloned.</source>
          <target state="translated">속성 값은 변경 불가능하거나 클라이언트 나 스토리지에서 변경해서는 안됩니다. 그것들은 항상 참조로 전달되며 복제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e249ae9bc2f78685ef11b72e309449abc9a2d7e" translate="yes" xml:space="preserve">
          <source>The values for these keys are the Strings returned by &lt;code&gt;getEngineName&lt;/code&gt;, &lt;code&gt;getEngineVersion&lt;/code&gt;, &lt;code&gt;getLanguageName&lt;/code&gt;, &lt;code&gt;getLanguageVersion&lt;/code&gt; for the first four keys respectively. For NAME, one of the Strings returned by &lt;code&gt;getNames&lt;/code&gt; is returned.</source>
          <target state="translated">이 키의 값은 각각 처음 네 개의 키에 대해 &lt;code&gt;getEngineName&lt;/code&gt; , &lt;code&gt;getEngineVersion&lt;/code&gt; , &lt;code&gt;getLanguageName&lt;/code&gt; , &lt;code&gt;getLanguageVersion&lt;/code&gt; 에 의해 리턴되는 문자열 입니다. NAME의 경우 &lt;code&gt;getNames&lt;/code&gt; 에서 리턴 한 문자열 중 하나 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9d10cc6e037fca6d3a56f31579dd60f8183de2" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;nodeName&lt;/code&gt;, &lt;code&gt;nodeValue&lt;/code&gt;, and &lt;code&gt;attributes&lt;/code&gt; vary according to the node type as follows:</source>
          <target state="translated">&lt;code&gt;nodeName&lt;/code&gt; , &lt;code&gt;nodeValue&lt;/code&gt; 및 &lt;code&gt;attributes&lt;/code&gt; 값은 다음과 같이 노드 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2a6a30969ed7a3364bae7b1eb735da94f1e68e29" translate="yes" xml:space="preserve">
          <source>The values of attributes must always be immutable.</source>
          <target state="translated">속성 값은 항상 불변이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed1518f76cd5c7850d1ed62e39ed9fbf6f653dda" translate="yes" xml:space="preserve">
          <source>The values of cipherSuites, protocols, cryptographic algorithm constraints, endpoint identification algorithm, server names and server name matchers are set to &lt;code&gt;null&lt;/code&gt;, useCipherSuitesOrder, wantClientAuth and needClientAuth are set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">cipherSuites, 프로토콜, 암호화 알고리즘 제한 조건, 엔드 포인트 식별 알고리즘, 서버 이름 및 서버 이름 매처의 값은 &lt;code&gt;null&lt;/code&gt; 로 설정되고 useCipherSuitesOrder, wantClientAuth 및 needClientAuth는 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8ffb3bbf31cf82ee6ccc1322bcc6cb436298fdc" translate="yes" xml:space="preserve">
          <source>The values of cipherSuites, protocols, cryptographic algorithm constraints, endpoint identification algorithm, server names and server name matchers are set to &lt;code&gt;null&lt;/code&gt;; useCipherSuitesOrder, wantClientAuth and needClientAuth are set to &lt;code&gt;false&lt;/code&gt;; enableRetransmissions is set to &lt;code&gt;true&lt;/code&gt;; maximum network packet size is set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">cipherSuites, 프로토콜, 암호화 알고리즘 제약 조건, 엔드 포인트 식별 알고리즘, 서버 이름 및 서버 이름 일치 자의 값은 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . useCipherSuitesOrder, wantClientAuth 및 needClientAuth가 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 . enableRetransmissions는 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 . 최대 네트워크 패킷 크기는 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="22711e927c4fe40a1d59a1b1a36e30db0d55cca6" translate="yes" xml:space="preserve">
          <source>The values of other calendar fields may be taken into account to determine a set of display names. For example, if this &lt;code&gt;Calendar&lt;/code&gt; is a lunisolar calendar system and the year value given by the &lt;a href=&quot;#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; field has a leap month, this method would return month names containing the leap month name, and month names are mapped to their values specific for the year.</source>
          <target state="translated">다른 달력 필드의 값을 고려하여 표시 이름 집합을 결정할 수 있습니다. 예를 들어,이 &lt;code&gt;Calendar&lt;/code&gt; 이 태음력 달력 시스템이고 &lt;a href=&quot;#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 필드에 제공된 연도 값 에 윤월이있는 경우이 메서드는 윤월 이름이 포함 된 월 이름을 반환하고 월 이름은 해당 연도에 대한 값에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="01f68b856f41bbdd549e5ce9ce35a7c9be9bec94" translate="yes" xml:space="preserve">
          <source>The values of other calendar fields may be taken into account to determine a set of display names. For example, if this &lt;code&gt;Calendar&lt;/code&gt; is a lunisolar calendar system and the year value given by the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; field has a leap month, this method would return month names containing the leap month name, and month names are mapped to their values specific for the year.</source>
          <target state="translated">일련의 표시 이름을 결정하기 위해 다른 캘린더 필드의 값을 고려할 수 있습니다. 예를 들어,이 &lt;code&gt;Calendar&lt;/code&gt; 이 음력 달력 시스템이고 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 필드에서 제공 한 연도 값 에 윤월이있는 경우이 방법은 윤월 이름을 포함하는 월 이름을 반환하고 월 이름은 해당 연도에 해당하는 값에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="9d66b37b53dfcf424a1c05306ea08bd465982359" translate="yes" xml:space="preserve">
          <source>The values of some &lt;code&gt;TextAttributes&lt;/code&gt; are not serializable, and therefore attempting to serialize an instance of &lt;code&gt;Font&lt;/code&gt; that has such values will not serialize them. This means a Font deserialized from such a stream will not compare equal to the original Font that contained the non-serializable attributes. This should very rarely pose a problem since these attributes are typically used only in special circumstances and are unlikely to be serialized.</source>
          <target state="translated">일부 &lt;code&gt;TextAttributes&lt;/code&gt; 의 값은 직렬화 할 수 없으므로 이러한 값을 가진 &lt;code&gt;Font&lt;/code&gt; 인스턴스를 직렬화하려고하면 해당 값이 직렬화되지 않습니다. 즉, 이러한 스트림에서 역 직렬화 된 글꼴은 직렬화 할 수없는 속성을 포함하는 원래 글꼴과 비교되지 않습니다. 이러한 속성은 일반적으로 특수한 상황에서만 사용되며 직렬화 될 가능성이 낮기 때문에 거의 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="465f58c72b3a6f0d702e1f81a258c44981222924" translate="yes" xml:space="preserve">
          <source>The values returned by this method become meaningful only when the difference between two such values, obtained within the same instance of a Java virtual machine, is computed.</source>
          <target state="translated">이 메소드에 의해 리턴 된 값은 Java 가상 머신의 동일한 인스턴스 내에서 얻은 두 값 간의 차이가 계산 될 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d19b69d59e11ca8f292d0de69a6446d6b6629e" translate="yes" xml:space="preserve">
          <source>The values that will be used to set the command's placeholder parameters are contained in the &lt;code&gt;RowSet&lt;/code&gt; object's &lt;code&gt;params&lt;/code&gt; field, which is a &lt;code&gt;Vector&lt;/code&gt; object. The &lt;code&gt;CachedRowSet&lt;/code&gt; class provides a set of setter methods for setting the elements in its &lt;code&gt;params&lt;/code&gt; field. The following code fragment demonstrates setting the two parameters in the query from the previous example.</source>
          <target state="translated">명령의 자리 표시 자 매개 변수를 설정하는 데 사용될 값 은 &lt;code&gt;Vector&lt;/code&gt; 객체 인 &lt;code&gt;RowSet&lt;/code&gt; 객체의 &lt;code&gt;params&lt;/code&gt; 필드에 포함되어 있습니다. &lt;code&gt;CachedRowSet&lt;/code&gt; 클래스는 요소에 설정하기위한 설정 메소드들을 제공 &lt;code&gt;params&lt;/code&gt; 필드. 다음 코드 조각은 이전 예제의 쿼리에서 두 매개 변수를 설정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="079a4a19841585ed45b6bc0604118fa1b0d2a88a" translate="yes" xml:space="preserve">
          <source>The values used to index into the colormap are taken from the least significant &lt;em&gt;n&lt;/em&gt; bits of pixel representations where &lt;em&gt;n&lt;/em&gt; is based on the pixel size specified in the constructor. For pixel sizes smaller than 8 bits, &lt;em&gt;n&lt;/em&gt; is rounded up to a power of two (3 becomes 4 and 5,6,7 become 8). For pixel sizes between 8 and 16 bits, &lt;em&gt;n&lt;/em&gt; is equal to the pixel size. Pixel sizes larger than 16 bits are not supported by this class. Higher order bits beyond &lt;em&gt;n&lt;/em&gt; are ignored in pixel representations. Index values greater than or equal to the map size, but less than 2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;, are undefined and return 0 for all color and alpha components.</source>
          <target state="translated">컬러 맵으로 인덱싱하는 데 사용되는 값은 &lt;em&gt;n&lt;/em&gt; 이 생성자에 지정된 픽셀 크기를 기반으로하는 픽셀 표현의 최하위 &lt;em&gt;n&lt;/em&gt; 비트 에서 가져옵니다 . 8 비트보다 작은 픽셀 크기의 경우 &lt;em&gt;n&lt;/em&gt; 은 2의 거듭 제곱으로 반올림됩니다 (3은 4가되고 5,6,7은 8이됩니다). 8 비트에서 16 비트 사이의 픽셀 크기의 경우 &lt;em&gt;n&lt;/em&gt; 은 픽셀 크기와 같습니다. 16 비트보다 큰 픽셀 크기는이 클래스에서 지원되지 않습니다. &lt;em&gt;n&lt;/em&gt; 보다 높은 순서의 비트 는 픽셀 표현에서 무시됩니다. 지도 크기보다 크거나 같지만 2 &lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; 보다 작은 인덱스 값 은 정의되지 않으며 모든 색 및 알파 구성 요소에 대해 0을 반환합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;sup&gt;&lt;em&gt;&lt;/em&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="435a1cf9400bda5077ae76839f8ca846728da561" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;jrs&lt;/code&gt; now represents an instance of &lt;code&gt;JdbcRowSetImpl&lt;/code&gt; that is a thin wrapper around the &lt;code&gt;ResultSet&lt;/code&gt; object containing all the rows in the table &lt;code&gt;TITLES&lt;/code&gt; where the type of book is biography. At this point, operations called on &lt;code&gt;jrs&lt;/code&gt; will affect the rows in the result set, which is effectively a JavaBeans component.</source>
          <target state="translated">이제 변수 &lt;code&gt;jrs&lt;/code&gt; 는 책 유형이 전기 인 테이블 &lt;code&gt;TITLES&lt;/code&gt; 의 모든 행을 포함 하는 &lt;code&gt;ResultSet&lt;/code&gt; 오브젝트 주위의 얇은 랩퍼 인 &lt;code&gt;JdbcRowSetImpl&lt;/code&gt; 의 인스턴스를 나타냅니다 . 이 시점에서 &lt;code&gt;jrs&lt;/code&gt; 에서 호출 된 작업 은 결과 집합의 행에 영향을 미치며 이는 사실상 JavaBeans 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="5cd18fd2ae18c7b303b9ff07577197ac1e8f395b" translate="yes" xml:space="preserve">
          <source>The variable arity parameter has a reifiable element type, which includes primitive types, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;String&lt;/code&gt;. (The unchecked warnings this annotation type suppresses already do not occur for a reifiable element type.)</source>
          <target state="translated">변수 arity 매개 변수에는 기본 유형, &lt;code&gt;Object&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 을 포함하는 수정 가능한 요소 유형이 있습니다 . (이 주석 유형이 억제하는 확인되지 않은 경고는 수정 가능한 요소 유형에 대해 이미 발생하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="764870fc9e8aa42169b55363170e3518f28153a0" translate="yes" xml:space="preserve">
          <source>The variables value, or &lt;code&gt;null&lt;/code&gt; if no variable named &lt;code&gt;variableName&lt;/code&gt; exists. The value returned must be of a type appropriate for the underlying object model.</source>
          <target state="translated">변수 값 또는 variableName이라는 &lt;code&gt;variableName&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 경우 null 입니다. 반환 된 값은 기본 개체 모델에 적합한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d3705f4b80513e86c1fef983b33a0e581672d50" translate="yes" xml:space="preserve">
          <source>The variant code, or the empty string if none is defined.</source>
          <target state="translated">변형 코드 또는 정의되지 않은 경우 빈 문자열</target>
        </trans-unit>
        <trans-unit id="34fe545ab25916df903f5bea78d9449c53a8699c" translate="yes" xml:space="preserve">
          <source>The variant field contains a value which identifies the layout of the &lt;code&gt;UUID&lt;/code&gt;. The bit layout described above is valid only for a &lt;code&gt;
 UUID&lt;/code&gt; with a variant value of 2, which indicates the Leach-Salz variant.</source>
          <target state="translated">변형 필드에는 &lt;code&gt;UUID&lt;/code&gt; 의 레이아웃을 식별하는 값이 포함 됩니다 . 위에서 설명한 비트 레이아웃 은 Leach-Salz 변형을 나타내는 변형 값이 2 인 &lt;code&gt; UUID&lt;/code&gt; 에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="e1f53b3a3ade84d5fdc041ae16475767cdbbf2af" translate="yes" xml:space="preserve">
          <source>The variant field contains a value which identifies the layout of the &lt;code&gt;UUID&lt;/code&gt;. The bit layout described above is valid only for a &lt;code&gt;UUID&lt;/code&gt; with a variant value of 2, which indicates the Leach-Salz variant.</source>
          <target state="translated">variant 필드에는 &lt;code&gt;UUID&lt;/code&gt; 의 레이아웃을 식별하는 값이 포함 됩니다 . 위에서 설명한 비트 레이아웃 은 변형 값이 2 인 &lt;code&gt;UUID&lt;/code&gt; 에만 유효하며 이는 Leach-Salz 변형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e259995f0509c3e3cb7f29e838fd983cda7d7bae" translate="yes" xml:space="preserve">
          <source>The variant number associated with this &lt;code&gt;UUID&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 와 관련된 변형 번호 입니다.</target>
        </trans-unit>
        <trans-unit id="9ff76ceb354bc3cf76d2cc94fa0c1aadbaba32d0" translate="yes" xml:space="preserve">
          <source>The variant number associated with this &lt;code&gt;UUID&lt;/code&gt;. The variant number describes the layout of the &lt;code&gt;UUID&lt;/code&gt;. The variant number has the following meaning:</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 와 관련된 변형 번호 입니다. 변형 번호는 &lt;code&gt;UUID&lt;/code&gt; 의 레이아웃을 설명합니다 . 변형 번호는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0759d3d03dbf7321713ed34def228b0638c5dab2" translate="yes" xml:space="preserve">
          <source>The variant number of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 변형 번호</target>
        </trans-unit>
        <trans-unit id="1a899fd2ca276c66ee25e17717f728ddba571308" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;add&lt;/code&gt; methods return the caller. This allows for easy chaining of invocations. For example, &lt;code&gt;group.addComponent(label1).addComponent(label2);&lt;/code&gt; is equivalent to &lt;code&gt;group.addComponent(label1); group.addComponent(label2);&lt;/code&gt;.</source>
          <target state="translated">다양한 &lt;code&gt;add&lt;/code&gt; 메서드가 호출자를 반환합니다. 이렇게하면 호출을 쉽게 연결할 수 있습니다. 예 : &lt;code&gt;group.addComponent(label1).addComponent(label2);&lt;/code&gt; 동등 &lt;code&gt;group.addComponent(label1); group.addComponent(label2);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a2987ccd904a7fa0f3359a297d67001c957cc55" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;next&lt;/code&gt; methods of &lt;code&gt;Scanner&lt;/code&gt; make a match result available if they complete without throwing an exception. For instance, after an invocation of the &lt;a href=&quot;#nextInt()&quot;&gt;&lt;code&gt;nextInt()&lt;/code&gt;&lt;/a&gt; method that returned an int, this method returns a &lt;code&gt;MatchResult&lt;/code&gt; for the search of the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above. Similarly the &lt;a href=&quot;#findInLine(java.lang.String)&quot;&gt;&lt;code&gt;findInLine()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#findWithinHorizon(java.lang.String,int)&quot;&gt;&lt;code&gt;findWithinHorizon()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#skip(java.util.regex.Pattern)&quot;&gt;&lt;code&gt;skip()&lt;/code&gt;&lt;/a&gt; methods will make a match available if they succeed.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; &lt;code&gt;Scanner&lt;/code&gt; 의 다양한 방법은 예외를 발생시키지 않고 완료되면 일치 결과를 사용할 수 있도록합니다. 예를 들어, int를 반환 한 &lt;a href=&quot;#nextInt()&quot;&gt; &lt;code&gt;nextInt()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 한 &lt;code&gt;MatchResult&lt;/code&gt; 메서드는 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; 정규식 검색에 대한 MatchResult 를 반환합니다 . 마찬가지로 &lt;a href=&quot;#findInLine(java.lang.String)&quot;&gt; &lt;code&gt;findInLine()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#findWithinHorizon(java.lang.String,int)&quot;&gt; &lt;code&gt;findWithinHorizon()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#skip(java.util.regex.Pattern)&quot;&gt; &lt;code&gt;skip()&lt;/code&gt; &lt;/a&gt; 메서드는 성공하면 일치 항목을 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4f651a70a37a4814efdb6f28d7a64f3a1d099f21" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;next&lt;/code&gt;methods of &lt;code&gt;Scanner&lt;/code&gt; make a match result available if they complete without throwing an exception. For instance, after an invocation of the &lt;a href=&quot;scanner#nextInt--&quot;&gt;&lt;code&gt;nextInt()&lt;/code&gt;&lt;/a&gt; method that returned an int, this method returns a &lt;code&gt;MatchResult&lt;/code&gt; for the search of the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above. Similarly the &lt;a href=&quot;scanner#findInLine-java.lang.String-&quot;&gt;&lt;code&gt;findInLine(java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;scanner#findWithinHorizon-java.lang.String-int-&quot;&gt;&lt;code&gt;findWithinHorizon(java.lang.String, int)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;scanner#skip-java.util.regex.Pattern-&quot;&gt;&lt;code&gt;skip(java.util.regex.Pattern)&lt;/code&gt;&lt;/a&gt; methods will make a match available if they succeed.</source>
          <target state="translated">&lt;code&gt;Scanner&lt;/code&gt; 의 다양한 &lt;code&gt;next&lt;/code&gt; 방법은 예외를 발생시키지 않고 완료되면 일치 결과를 사용할 수있게합니다. 예를 들어, int를 반환 한 &lt;a href=&quot;scanner#nextInt--&quot;&gt; &lt;code&gt;nextInt()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 한 &lt;code&gt;MatchResult&lt;/code&gt; 메서드는 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; 정규식을 검색하기 위해 MatchResult 를 반환합니다 . 마찬가지로 &lt;a href=&quot;scanner#findInLine-java.lang.String-&quot;&gt; &lt;code&gt;findInLine(java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;scanner#findWithinHorizon-java.lang.String-int-&quot;&gt; &lt;code&gt;findWithinHorizon(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;scanner#skip-java.util.regex.Pattern-&quot;&gt; &lt;code&gt;skip(java.util.regex.Pattern)&lt;/code&gt; &lt;/a&gt; 메소드는 성공하면 일치하는 항목을 작성합니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="66a3528f0c1b55451a824e991967067e69ff6040" translate="yes" xml:space="preserve">
          <source>The vector containing the real UIs.</source>
          <target state="translated">실제 UI를 포함하는 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="788eff506f4bfe4a0b3cd5df0f47b7e6cc4e70f0" translate="yes" xml:space="preserve">
          <source>The vector containing the real UIs. This is populated in the call to &lt;code&gt;createUI&lt;/code&gt;, and can be obtained by calling the &lt;code&gt;getUIs&lt;/code&gt; method. The first element is guaranteed to be the real UI obtained from the default look and feel.</source>
          <target state="translated">실제 UI를 포함하는 벡터입니다. 이는 &lt;code&gt;createUI&lt;/code&gt; 호출에 채워 지며 &lt;code&gt;getUIs&lt;/code&gt; 메소드 를 호출하여 얻을 수 있습니다 . 첫 번째 요소는 기본 룩앤필에서 얻은 실제 UI입니다.</target>
        </trans-unit>
        <trans-unit id="1180351e5247e4780b4dc25a40f38943b4896262" translate="yes" xml:space="preserve">
          <source>The vector is empty if there is no timer notification registered for this timer MBean.</source>
          <target state="translated">이 타이머 MBean에 등록 된 타이머 통지가없는 경우는 벡터는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9e2d6864ec2b83e2c1a64a7dd7faed626bbda83" translate="yes" xml:space="preserve">
          <source>The vector is empty if there is no timer notifications registered for this timer MBean with the specified &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;type&lt;/code&gt; 으로이 타이머 MBean에 등록 된 타이머 통지가없는 경우는 벡터는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca17252692aed15c11d9f3da80840809cf0c1f83" translate="yes" xml:space="preserve">
          <source>The vector of elements</source>
          <target state="translated">요소로 구성된 벡터</target>
        </trans-unit>
        <trans-unit id="58462e7fd48bf8ac3b31199fbf9a449a7280a048" translate="yes" xml:space="preserve">
          <source>The vendor might supply the following &lt;code&gt;ChangeIDControl&lt;/code&gt; and &lt;code&gt;VendorXControlFactory&lt;/code&gt; classes. The &lt;code&gt;VendorXControlFactory&lt;/code&gt; will be used by the service provider when the provider receives response controls from the LDAP server.</source>
          <target state="translated">공급 업체는 다음 &lt;code&gt;ChangeIDControl&lt;/code&gt; 및 &lt;code&gt;VendorXControlFactory&lt;/code&gt; 클래스를 제공 할 수 있습니다. &lt;code&gt;VendorXControlFactory&lt;/code&gt; 를이 공급자가 LDAP 서버로부터 응답 컨트롤을 수신 서비스 제공자에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="275585627b99c17300f68809698efafe7b5722ce" translate="yes" xml:space="preserve">
          <source>The version field holds a value that describes the type of this &lt;code&gt;
 UUID&lt;/code&gt;. There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs. These types have a version value of 1, 2, 3 and 4, respectively.</source>
          <target state="translated">버전 필드에는이 &lt;code&gt; UUID&lt;/code&gt; 유형을 설명하는 값이 있습니다. UUID에는 시간 기반, DCE 보안, 이름 기반 및 임의로 생성 된 UUID의 네 가지 기본 유형이 있습니다. 이러한 유형의 버전 값은 각각 1, 2, 3 및 4입니다.</target>
        </trans-unit>
        <trans-unit id="92b9d2715811e51e997d7d4ca0742429f1579adf" translate="yes" xml:space="preserve">
          <source>The version field holds a value that describes the type of this &lt;code&gt;UUID&lt;/code&gt;. There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs. These types have a version value of 1, 2, 3 and 4, respectively.</source>
          <target state="translated">버전 필드에는이 &lt;code&gt;UUID&lt;/code&gt; 유형을 설명하는 값이 있습니다. UUID에는 시간 기반, DCE 보안, 이름 기반 및 무작위로 생성 된 UUID의 네 가지 기본 유형이 있습니다. 이러한 유형의 버전 값은 각각 1, 2, 3 및 4입니다.</target>
        </trans-unit>
        <trans-unit id="4d21175da4b48cbc3923c0f8323407a231d63c76" translate="yes" xml:space="preserve">
          <source>The version number associated with this &lt;code&gt;UUID&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 와 관련된 버전 번호 입니다.</target>
        </trans-unit>
        <trans-unit id="05fd679ec54a555aaf6a087d093ec8e9634ec69d" translate="yes" xml:space="preserve">
          <source>The version number associated with this &lt;code&gt;UUID&lt;/code&gt;. The version number describes how this &lt;code&gt;UUID&lt;/code&gt; was generated. The version number has the following meaning:</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 와 관련된 버전 번호 입니다. 버전 번호는이 &lt;code&gt;UUID&lt;/code&gt; 생성 방법을 설명합니다 . 버전 번호는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6cff03f566dfbcc1da388f423a088498b0bfb75e" translate="yes" xml:space="preserve">
          <source>The version number of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 버전 번호</target>
        </trans-unit>
        <trans-unit id="248333294329c0197bb12d0f6a414ff121dcbcff" translate="yes" xml:space="preserve">
          <source>The version of a file</source>
          <target state="translated">파일 버전</target>
        </trans-unit>
        <trans-unit id="f960447e30249f093071e1177d67cf04bcbfa430" translate="yes" xml:space="preserve">
          <source>The version of the Hijrah variant data</source>
          <target state="translated">Hijrah 변형 데이터의 버전</target>
        </trans-unit>
        <trans-unit id="a1a162c92dcdf70e3ab7e12651d184a634c2e241" translate="yes" xml:space="preserve">
          <source>The version of the RMI Connector Protocol understood by this connector server.</source>
          <target state="translated">이 커넥터 서버에서 인식하는 RMI 커넥터 프로토콜의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="cf8368aa8f5f9b58b1196c5b1361941f6ebe95f2" translate="yes" xml:space="preserve">
          <source>The version of the RMI Connector Protocol understood by this connector server. This is a string with the following format:</source>
          <target state="translated">이 커넥터 서버가 이해하는 RMI 커넥터 프로토콜의 버전. 다음 형식의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="67c46c943cb161ebaf61561a24251c325c38dcc4" translate="yes" xml:space="preserve">
          <source>The version of the information model in which this element was introduced. A set of MBeans defined by an application is collectively called an &lt;em&gt;information model&lt;/em&gt;. The application may also define versions of this model, and use the &lt;code&gt;&quot;since&quot;&lt;/code&gt; field to record the version in which an element first appeared.</source>
          <target state="translated">이 요소가 소개 된 정보 모델의 버전. 어플리케이션에 의해 정의 된 MBean 세트를 통칭하여 &lt;em&gt;정보 모델&lt;/em&gt; 이라고합니다 . 응용 프로그램은이 모델의 버전을 정의하고 &lt;code&gt;&quot;since&quot;&lt;/code&gt; 필드를 사용하여 요소가 처음 나타난 버전을 기록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0fb3351dd31095a4bced4cb99f1b7abda02c059" translate="yes" xml:space="preserve">
          <source>The version of the module if recorded at compile-time, or an empty &lt;code&gt;Optional&lt;/code&gt; if no version was recorded or the version string recorded is &lt;a href=&quot;moduledescriptor.version#parse(java.lang.String)&quot;&gt;unparseable&lt;/a&gt;</source>
          <target state="translated">컴파일 시간에 기록 된 경우 모듈의 버전, 기록 된 버전이 없거나 기록 된 버전 문자열이 &lt;a href=&quot;moduledescriptor.version#parse(java.lang.String)&quot;&gt;구문 분석&lt;/a&gt; 할 수없는 경우 빈 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3685bfd8924e2e12ab202fe7572e0fc113f3c96f" translate="yes" xml:space="preserve">
          <source>The version of the supported language.</source>
          <target state="translated">지원되는 언어의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="52422ac233670bbc923e26fc3ae16e5038fe1990" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition 5.0.</source>
          <target state="translated">Java 2 Platform, Standard Edition 5.0에서 인식하는 버전입니다.</target>
        </trans-unit>
        <trans-unit id="493ae14aa8bda8f4cbb42c55258a1945f011ee02" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition 5.0. The language described in</source>
          <target state="translated">Java 2 플랫폼, Standard Edition 5.0에서 인식되는 버전입니다. 에 설명 된 언어</target>
        </trans-unit>
        <trans-unit id="3022af772ae57790fa2262e880d2c67797961cc2" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.2.</source>
          <target state="translated">Java 2 Platform, Standard Edition, v 1.2에서 인식되는 버전입니다.</target>
        </trans-unit>
        <trans-unit id="6c8ee4fc6c4ec0e899d656f5815ce54f62279899" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.2. The language described in</source>
          <target state="translated">Java 2 플랫폼, Standard Edition, v 1.2에서 인식되는 버전입니다. 에 설명 된 언어</target>
        </trans-unit>
        <trans-unit id="c87429de5c2eea03bf3209808e67bffa7ff396a8" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.3.</source>
          <target state="translated">The version recognized by the Java 2 Platform, Standard Edition, v 1.3.</target>
        </trans-unit>
        <trans-unit id="60485dd1cd7fcf936094d3c03d7336c18a555a23" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.3. No major changes from &lt;code&gt;RELEASE_2&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼, Standard Edition, v 1.3에서 인식되는 버전입니다. &lt;code&gt;RELEASE_2&lt;/code&gt; 에서 큰 변화가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2e78a2f2926d700f4cd6d5f37fd5c574b8ae34c6" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.4.</source>
          <target state="translated">The version recognized by the Java 2 Platform, Standard Edition, v 1.4.</target>
        </trans-unit>
        <trans-unit id="33e65cacac89fcf14c1fb1ffd5441c1fd46da791" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.4. Added a simple assertion facility.</source>
          <target state="translated">Java 2 플랫폼, Standard Edition, v 1.4에서 인식되는 버전입니다. 간단한 어설 션 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="efc94a5521bf14056c2a9e3e2badd893ae0879f0" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform 1.1.</source>
          <target state="translated">The version recognized by the Java Platform 1.1.</target>
        </trans-unit>
        <trans-unit id="2af496d830b8e85fb7bdac6006a960dc011931da" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform 1.1. The language is &lt;code&gt;RELEASE_0&lt;/code&gt; augmented with nested classes as described in the 1.1 update to</source>
          <target state="translated">Java 플랫폼 1.1에서 인식하는 버전입니다. 이 언어는 1.1 업데이트에 설명 된대로 중첩 클래스로 보강 된 &lt;code&gt;RELEASE_0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="831db96026fb5941758d6c84583e8162540fbe70" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 10.</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 10.</target>
        </trans-unit>
        <trans-unit id="d6737b50578e3baae7a758261a87c9177a3409a0" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 10. Additions in this release include local-variable type inference (&lt;code&gt;var&lt;/code&gt;).</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 10. Additions in this release include local-variable type inference ( &lt;code&gt;var&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="780b27fad1bbf4d75231ae700daf5fdc1d45d5d9" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 11.</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 11.</target>
        </trans-unit>
        <trans-unit id="3737ca22e2eb55bfafd4b8dc1f5fba8c8b1cfd22" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 6.</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 6.</target>
        </trans-unit>
        <trans-unit id="5a1c95c42d35f8469c63a9001750d4f9ec2552bd" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 6. No major changes from &lt;code&gt;RELEASE_5&lt;/code&gt;.</source>
          <target state="translated">Java 플랫폼, Standard Edition 6에 의해 인식되는 버전 &lt;code&gt;RELEASE_5&lt;/code&gt; . RELEASE_5 에서 큰 변화가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="00fc5992d9212219bc2dec2239671cfcbfca7361" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 7.</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 7.</target>
        </trans-unit>
        <trans-unit id="dc1600019466bdbd05352dcab9d2cc9fbdf36863" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 7. Additions in this release include, diamond syntax for constructors, &lt;code&gt;try&lt;/code&gt;-with-resources, strings in switch, binary literals, and multi-catch.</source>
          <target state="translated">Java 플랫폼, Standard Edition 7에서 인식하는 버전입니다.이 릴리스의 추가 기능에는 생성자를위한 다이아몬드 구문, 리소스를 사용하여 &lt;code&gt;try&lt;/code&gt; , 스위치의 문자열, 이진 리터럴 및 멀티 캐치가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ddcec7b2e0cef17b40c165b719411e9636873a" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 8.</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 8.</target>
        </trans-unit>
        <trans-unit id="ba5437ac950badfe9820695aa51943c8ac51fd94" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 8. Additions in this release include lambda expressions and default methods.</source>
          <target state="translated">Java 플랫폼, Standard Edition 8에서 인식하는 버전입니다.이 릴리스의 추가 기능에는 람다 식 및 기본 방법이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="efdb5b38e63a12574a24d7ffd6e4d9afa0313bd2" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 9.</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 9.</target>
        </trans-unit>
        <trans-unit id="78798c9f8e8b2a50b0939b7a9df6df4d870d7e92" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 9. Additions in this release include modules and removal of a single underscore from the set of legal identifier names.</source>
          <target state="translated">The version recognized by the Java Platform, Standard Edition 9. Additions in this release include modules and removal of a single underscore from the set of legal identifier names.</target>
        </trans-unit>
        <trans-unit id="0fa716a4f4a4c3e8cddf93a190ba1e2de52a5f5d" translate="yes" xml:space="preserve">
          <source>The version string</source>
          <target state="translated">버전 문자열</target>
        </trans-unit>
        <trans-unit id="290af8b85b4cefbf054a388df69f2a0ce52ddc54" translate="yes" xml:space="preserve">
          <source>The version string contains a version number optionally followed by other information separated by one of the characters of '+', '-'. The format for the version number is:</source>
          <target state="translated">The version string contains a version number optionally followed by other information separated by one of the characters of '+', '-'. The format for the version number is:</target>
        </trans-unit>
        <trans-unit id="572d44d97596be5977ef90937f3f79c89dc77e3c" translate="yes" xml:space="preserve">
          <source>The vertical axis consists of a sequential group containing two parallel groups. The parallel groups are configured to align their components along the baseline. The first parallel group contains the first label and first text field, and the second group consists of the second label and second text field.</source>
          <target state="translated">The vertical axis consists of a sequential group containing two parallel groups. The parallel groups are configured to align their components along the baseline. The first parallel group contains the first label and first text field, and the second group consists of the second label and second text field.</target>
        </trans-unit>
        <trans-unit id="d8dfff5b2076edab9e59d1c3378eba1d08acb891" translate="yes" xml:space="preserve">
          <source>The vertical coordinate at which the event occurred relative to the DOM implementation's client area.</source>
          <target state="translated">The vertical coordinate at which the event occurred relative to the DOM implementation's client area.</target>
        </trans-unit>
        <trans-unit id="a9239559621a77e540b5123e5d9c8d02e0b0b013" translate="yes" xml:space="preserve">
          <source>The vertical coordinate at which the event occurred relative to the origin of the screen coordinate system.</source>
          <target state="translated">The vertical coordinate at which the event occurred relative to the origin of the screen coordinate system.</target>
        </trans-unit>
        <trans-unit id="108c69e8dffb80e19f78043abb75707aa45231ef" translate="yes" xml:space="preserve">
          <source>The vertical element of legs between nodes starts at the bottom of the parent node by default.</source>
          <target state="translated">The vertical element of legs between nodes starts at the bottom of the parent node by default.</target>
        </trans-unit>
        <trans-unit id="e5fd69e750d794eef8525d7ead631d0c3df0865f" translate="yes" xml:space="preserve">
          <source>The vertical element of legs between nodes starts at the bottom of the parent node by default. This method makes the leg start below that.</source>
          <target state="translated">The vertical element of legs between nodes starts at the bottom of the parent node by default. This method makes the leg start below that.</target>
        </trans-unit>
        <trans-unit id="1e86ac051433774659dea2eec70d74d2b9919890" translate="yes" xml:space="preserve">
          <source>The view and parent view are checked to see if they are &lt;code&gt;JComponents&lt;/code&gt;, if they aren't, stop and repaint the whole viewport.</source>
          <target state="translated">The view and parent view are checked to see if they are &lt;code&gt;JComponents&lt;/code&gt; , if they aren't, stop and repaint the whole viewport.</target>
        </trans-unit>
        <trans-unit id="5ddeed9a4cf1044b6266e92a5f9f81d60ede6f4a" translate="yes" xml:space="preserve">
          <source>The view gets its allocation from the parent at paint time, so it must be prepared to redo layout if the allocated area is different from what it is prepared to deal with.</source>
          <target state="translated">The view gets its allocation from the parent at paint time, so it must be prepared to redo layout if the allocated area is different from what it is prepared to deal with.</target>
        </trans-unit>
        <trans-unit id="62ac9cabb4ddf5d3df84c9f5b8fed3ec3e8cf875" translate="yes" xml:space="preserve">
          <source>The view has a &lt;code&gt;setSize&lt;/code&gt; method which is like &lt;code&gt;doLayout&lt;/code&gt; and &lt;code&gt;setSize&lt;/code&gt; in &lt;code&gt;Component&lt;/code&gt; combined. The view has a &lt;code&gt;preferenceChanged&lt;/code&gt; method which is like &lt;code&gt;invalidate&lt;/code&gt; in &lt;code&gt;Component&lt;/code&gt; except that one can invalidate just one axis and the child requesting the change is identified.</source>
          <target state="translated">The view has a &lt;code&gt;setSize&lt;/code&gt; method which is like &lt;code&gt;doLayout&lt;/code&gt; and &lt;code&gt;setSize&lt;/code&gt; in &lt;code&gt;Component&lt;/code&gt; combined. The view has a &lt;code&gt;preferenceChanged&lt;/code&gt; method which is like &lt;code&gt;invalidate&lt;/code&gt; in &lt;code&gt;Component&lt;/code&gt; except that one can invalidate just one axis and the child requesting the change is identified.</target>
        </trans-unit>
        <trans-unit id="21bb89aacbc297246eff848668efb03c947a2c22" translate="yes" xml:space="preserve">
          <source>The view hierarchy is painted.</source>
          <target state="translated">The view hierarchy is painted.</target>
        </trans-unit>
        <trans-unit id="c0baa902c30bbd5cd33ababaff1f531cda16a474" translate="yes" xml:space="preserve">
          <source>The view image used for a backing store.</source>
          <target state="translated">The view image used for a backing store.</target>
        </trans-unit>
        <trans-unit id="cd24d98b37b0f6f9781bc0653637b62644fed069" translate="yes" xml:space="preserve">
          <source>The view invokes the following methods on the &lt;code&gt;RowSorter&lt;/code&gt;:</source>
          <target state="translated">The view invokes the following methods on the &lt;code&gt;RowSorter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c631dab429ccbd9fa24264a600e66db40fdd0678" translate="yes" xml:space="preserve">
          <source>The view of a file provided by an instance of this class is guaranteed to be consistent with other views of the same file provided by other instances in the same program. The view provided by an instance of this class may or may not, however, be consistent with the views seen by other concurrently-running programs due to caching performed by the underlying operating system and delays induced by network-filesystem protocols. This is true regardless of the language in which these other programs are written, and whether they are running on the same machine or on some other machine. The exact nature of any such inconsistencies are system-dependent and are therefore unspecified.</source>
          <target state="translated">이 클래스의 인스턴스에서 제공하는 파일보기는 동일한 프로그램의 다른 인스턴스에서 제공 한 동일한 파일의 다른보기와 일치해야합니다. 그러나이 클래스의 인스턴스가 제공하는보기는 기본 운영 체제에서 수행하는 캐싱 및 네트워크 파일 시스템 프로토콜에 의해 유발 된 지연으로 인해 동시에 실행중인 다른 프로그램에서 보는보기와 일치 할 수도 있고 일치하지 않을 수도 있습니다. 이는 다른 프로그램이 작성되는 언어 및 동일한 시스템에서 실행되는지 또는 다른 시스템에서 실행되는지에 관계없이 적용됩니다. 이러한 불일치의 정확한 특성은 시스템에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e69e4b05faf63e778871c0d3850aefc9998b9588" translate="yes" xml:space="preserve">
          <source>The view of the files and file system provided by classes in this package are guaranteed to be consistent with other views provided by other instances in the same Java virtual machine. The view may or may not, however, be consistent with the view of the file system as seen by other concurrently running programs due to caching performed by the underlying operating system and delays induced by network-filesystem protocols. This is true regardless of the language in which these other programs are written, and whether they are running on the same machine or on some other machine. The exact nature of any such inconsistencies are system-dependent and are therefore unspecified.</source>
          <target state="translated">이 패키지의 클래스가 제공하는 파일 및 파일 시스템의보기는 동일한 Java 가상 머신의 다른 인스턴스가 제공하는 다른보기와 일치하도록 보장됩니다. 그러나보기는 기본 운영 체제에서 수행하는 캐싱 및 네트워크 파일 시스템 프로토콜에 의해 유발 된 지연으로 인해 동시에 실행중인 다른 프로그램에서 볼 수있는 파일 시스템의보기와 일치 할 수도 있고 일치하지 않을 수도 있습니다. 이는 다른 프로그램이 작성되는 언어 및 동일한 시스템에서 실행되는지 또는 다른 시스템에서 실행되는지에 관계없이 적용됩니다. 이러한 불일치의 정확한 특성은 시스템에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="750b216e6591d42be7752c1ccc334f74dd8f12aa" translate="yes" xml:space="preserve">
          <source>The view supports breaking for the purpose of formatting. The fragments produced by breaking share the view that has primary responsibility for the element (i.e. they are nested classes and carry only a small amount of state of their own) so they can share its resources.</source>
          <target state="translated">The view supports breaking for the purpose of formatting. The fragments produced by breaking share the view that has primary responsibility for the element (i.e. they are nested classes and carry only a small amount of state of their own) so they can share its resources.</target>
        </trans-unit>
        <trans-unit id="dcf26d7eb7f2b3b9db64cfa5669c95b2c00b65af" translate="yes" xml:space="preserve">
          <source>The view's &lt;code&gt;spliterator&lt;/code&gt; reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뷰의 &lt;code&gt;spliterator&lt;/code&gt; 는 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; 을&lt;/a&gt; 보고합니다 .</target>
        </trans-unit>
        <trans-unit id="7f5166b266b10230b8c5577f5d6f553331cc4405" translate="yes" xml:space="preserve">
          <source>The view's &lt;code&gt;spliterator&lt;/code&gt; reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#DISTINCT&quot;&gt;&lt;code&gt;Spliterator.DISTINCT&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뷰의 &lt;code&gt;spliterator&lt;/code&gt; 는 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#DISTINCT&quot;&gt; &lt;code&gt;Spliterator.DISTINCT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; 을보고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e180456519029a61110027d18c36a686018713ed" translate="yes" xml:space="preserve">
          <source>The view's iterators and spliterators are &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">뷰의 이터레이터와 스플리터는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;일관성&lt;/i&gt;&lt;/a&gt; 이 &lt;i&gt;약&lt;/i&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4ab5f11baa74f707b7bb224c5de26ca66525f0ad" translate="yes" xml:space="preserve">
          <source>The viewport &quot;scrolls&quot; its child (called the &quot;view&quot;) by the normal parent/child clipping (typically the view is moved in the opposite direction of the scroll).</source>
          <target state="translated">The viewport &quot;scrolls&quot; its child (called the &quot;view&quot;) by the normal parent/child clipping (typically the view is moved in the opposite direction of the scroll).</target>
        </trans-unit>
        <trans-unit id="bc5cd82fcf166d9089fa7c633eeca4ed35d0fe95" translate="yes" xml:space="preserve">
          <source>The viewport &quot;scrolls&quot; its child (called the &quot;view&quot;) by the normal parent/child clipping (typically the view is moved in the opposite direction of the scroll). A non-&lt;code&gt;null&lt;/code&gt; border, or non-zero insets, isn't supported, to prevent the geometry of this component from becoming complex enough to inhibit subclassing. To create a &lt;code&gt;JViewport&lt;/code&gt; with a border, add it to a &lt;code&gt;JPanel&lt;/code&gt; that has a border.</source>
          <target state="translated">The viewport &quot;scrolls&quot; its child (called the &quot;view&quot;) by the normal parent/child clipping (typically the view is moved in the opposite direction of the scroll). A non- &lt;code&gt;null&lt;/code&gt; border, or non-zero insets, isn't supported, to prevent the geometry of this component from becoming complex enough to inhibit subclassing. To create a &lt;code&gt;JViewport&lt;/code&gt; with a border, add it to a &lt;code&gt;JPanel&lt;/code&gt; that has a border.</target>
        </trans-unit>
        <trans-unit id="6e9d0cf31c26e384ef599b5f9b6d0f271a301375" translate="yes" xml:space="preserve">
          <source>The viewport gets the space available after accounting for the previous constraints.</source>
          <target state="translated">The viewport gets the space available after accounting for the previous constraints.</target>
        </trans-unit>
        <trans-unit id="c1f582e06f3b6e62c7c1e3d34a0b9a3c408789c8" translate="yes" xml:space="preserve">
          <source>The virtual machine is</source>
          <target state="translated">가상 머신은</target>
        </trans-unit>
        <trans-unit id="e9f9a3839ed2055f08a26dbd35178cd5a027df29" translate="yes" xml:space="preserve">
          <source>The virtual machine is free to treat the &lt;code&gt;stackSize&lt;/code&gt; parameter as a suggestion. If the specified value is unreasonably low for the platform, the virtual machine may instead use some platform-specific minimum value; if the specified value is unreasonably high, the virtual machine may instead use some platform-specific maximum. Likewise, the virtual machine is free to round the specified value up or down as it sees fit (or to ignore it completely).</source>
          <target state="translated">가상 머신은 &lt;code&gt;stackSize&lt;/code&gt; 매개 변수를 제안으로 자유롭게 처리 할 수 있습니다. 플랫폼에 대해 지정된 값이 부당하게 낮은 경우 가상 시스템은 일부 플랫폼 별 최소값을 대신 사용할 수 있습니다. 지정된 값이 부당하게 높은 경우 가상 시스템은 일부 플랫폼 별 최대 값을 대신 사용할 수 있습니다. 마찬가지로, 가상 머신은 지정된대로 적절하게 지정된 값을 올림 또는 내림하거나 자유롭게 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c721c30f38fc2edaadd8b6106e60056792e573" translate="yes" xml:space="preserve">
          <source>The virtual machine performs the finalization process automatically as needed, in a separate thread, if the &lt;code&gt;runFinalization&lt;/code&gt; method is not invoked explicitly.</source>
          <target state="translated">&lt;code&gt;runFinalization&lt;/code&gt; 메소드가 명시 적으로 호출되지 않은 경우 가상 머신은 필요에 따라 별도의 스레드에서 종료 프로세스를 자동으로 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="8642fbcebaba07b4669d35a2e26b8bad16051e94" translate="yes" xml:space="preserve">
          <source>The virtual machine's shutdown sequence consists of two phases. In the first phase all registered &lt;a href=&quot;runtime#addShutdownHook-java.lang.Thread-&quot;&gt;&lt;code&gt;shutdown hooks&lt;/code&gt;&lt;/a&gt;, if any, are started in some unspecified order and allowed to run concurrently until they finish. In the second phase all uninvoked finalizers are run if &lt;a href=&quot;runtime#runFinalizersOnExit-boolean-&quot;&gt;&lt;code&gt;finalization-on-exit&lt;/code&gt;&lt;/a&gt; has been enabled. Once this is done the virtual machine &lt;a href=&quot;runtime#halt-int-&quot;&gt;&lt;code&gt;halts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가상 머신의 종료 순서는 두 단계로 구성됩니다. 첫 번째 단계에서는 등록 된 모든 &lt;a href=&quot;runtime#addShutdownHook-java.lang.Thread-&quot;&gt; &lt;code&gt;shutdown hooks&lt;/code&gt; &lt;/a&gt; (있는 경우)가 지정되지 않은 순서로 시작되어 완료 될 때까지 동시에 실행될 수 있습니다. 두 번째 단계에서는 종료시 &lt;a href=&quot;runtime#runFinalizersOnExit-boolean-&quot;&gt; &lt;code&gt;finalization-on-exit&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 모든 호출되지 않은 종료 자가 실행됩니다 . 이 작업이 완료되면 가상 머신이 &lt;a href=&quot;runtime#halt-int-&quot;&gt; &lt;code&gt;halts&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="110918cc802a82b32ab393a11c540ffeccef7a5c" translate="yes" xml:space="preserve">
          <source>The visual behavior is platform and &lt;a href=&quot;taskbar.state&quot;&gt;&lt;code&gt;Taskbar.State&lt;/code&gt;&lt;/a&gt; dependent.</source>
          <target state="translated">The visual behavior is platform and &lt;a href=&quot;taskbar.state&quot;&gt; &lt;code&gt;Taskbar.State&lt;/code&gt; &lt;/a&gt; dependent.</target>
        </trans-unit>
        <trans-unit id="49e03a8c2947801534530d04e65fd591f525fbb8" translate="yes" xml:space="preserve">
          <source>The visual bounds of the text is extended to include the logical bounds, if necessary. The outline is not affected.</source>
          <target state="translated">The visual bounds of the text is extended to include the logical bounds, if necessary. The outline is not affected.</target>
        </trans-unit>
        <trans-unit id="6ae8e7cd4a0bb7e3290fc509b4004aec986be05c" translate="yes" xml:space="preserve">
          <source>The volatile write to &lt;code&gt;V&lt;/code&gt; is placed (in an implementation specific manner) in the global synchronization order.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 에 대한 휘발성 쓰기 는 (구체적 특정 방식으로) 글로벌 동기화 순서로 배치된다.</target>
        </trans-unit>
        <trans-unit id="de91da87d01e67078d8c18c3dfd783009a74b736" translate="yes" xml:space="preserve">
          <source>The wait cursor type.</source>
          <target state="translated">The wait cursor type.</target>
        </trans-unit>
        <trans-unit id="efd3407160c3ea0bff7fb2266c59d70afc3c6de5" translate="yes" xml:space="preserve">
          <source>The warning chain is automatically cleared each time a new row is read. This method may not be called on a &lt;code&gt;ResultSet&lt;/code&gt; object that has been closed; doing so will cause an &lt;code&gt;SQLException&lt;/code&gt; to be thrown.</source>
          <target state="translated">The warning chain is automatically cleared each time a new row is read. This method may not be called on a &lt;code&gt;ResultSet&lt;/code&gt; object that has been closed; doing so will cause an &lt;code&gt;SQLException&lt;/code&gt; to be thrown.</target>
        </trans-unit>
        <trans-unit id="43dffe00128f153c82de100cf774d69299ce1261" translate="yes" xml:space="preserve">
          <source>The warning chain is automatically cleared each time a statement is (re)executed. This method may not be called on a closed &lt;code&gt;Statement&lt;/code&gt; object; doing so will cause an &lt;code&gt;SQLException&lt;/code&gt; to be thrown.</source>
          <target state="translated">The warning chain is automatically cleared each time a statement is (re)executed. This method may not be called on a closed &lt;code&gt;Statement&lt;/code&gt; object; doing so will cause an &lt;code&gt;SQLException&lt;/code&gt; to be thrown.</target>
        </trans-unit>
        <trans-unit id="9e36f89b79c84c0caeedbd5793c33c4704e7fb40" translate="yes" xml:space="preserve">
          <source>The way attribute value normalization is performed by the DOM implementation depends on how much the implementation knows about the schema in use. Typically, the &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;nodeValue&lt;/code&gt; attributes of an &lt;code&gt;Attr&lt;/code&gt; node initially returns the normalized value given by the parser. It is also the case after &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; is called (assuming the right options have been set). But this may not be the case after mutation, independently of whether the mutation is performed by setting the string value directly or by changing the &lt;code&gt;Attr&lt;/code&gt; child nodes. In particular, this is true when &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204#dt-charref&quot;&gt;character references&lt;/a&gt; are involved, given that they are not represented in the DOM and they impact attribute value normalization. On the other hand, if the implementation knows about the schema in use when the attribute value is changed, and it is of a different type than CDATA, it may normalize it again at that time. This is especially true of specialized DOM implementations, such as SVG DOM implementations, which store attribute values in an internal form different from a string.</source>
          <target state="translated">The way attribute value normalization is performed by the DOM implementation depends on how much the implementation knows about the schema in use. Typically, the &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;nodeValue&lt;/code&gt; attributes of an &lt;code&gt;Attr&lt;/code&gt; node initially returns the normalized value given by the parser. It is also the case after &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; is called (assuming the right options have been set). But this may not be the case after mutation, independently of whether the mutation is performed by setting the string value directly or by changing the &lt;code&gt;Attr&lt;/code&gt; child nodes. In particular, this is true when &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204#dt-charref&quot;&gt;character references&lt;/a&gt; are involved, given that they are not represented in the DOM and they impact attribute value normalization. On the other hand, if the implementation knows about the schema in use when the attribute value is changed, and it is of a different type than CDATA, it may normalize it again at that time. This is especially true of specialized DOM implementations, such as SVG DOM implementations, which store attribute values in an internal form different from a string.</target>
        </trans-unit>
        <trans-unit id="c21a8aed036bbcc185b5b957c5388bff363a670b" translate="yes" xml:space="preserve">
          <source>The week-based-year itself is defined relative to the standard ISO proleptic year. It differs from the standard year in that it always starts on a Monday.</source>
          <target state="translated">주별 연도 자체는 표준 ISO proleptic 연도를 기준으로 정의됩니다. 항상 월요일에 시작한다는 점에서 표준 연도와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f875440be2605b4d9cefd62818b6c9405a8581de" translate="yes" xml:space="preserve">
          <source>The weight of this glyph.</source>
          <target state="translated">The weight of this glyph.</target>
        </trans-unit>
        <trans-unit id="df83281e755db0d0e327d674ce9bd650e8591ff9" translate="yes" xml:space="preserve">
          <source>The weight to indicate a view is a bad break opportunity for the purpose of formatting.</source>
          <target state="translated">The weight to indicate a view is a bad break opportunity for the purpose of formatting.</target>
        </trans-unit>
        <trans-unit id="6a445c04d72e116df0c559fdabcc3127aec707f0" translate="yes" xml:space="preserve">
          <source>The weight to indicate a view is a bad break opportunity for the purpose of formatting. This value indicates that no attempt should be made to break the view into fragments as the view has not been written to support fragmenting.</source>
          <target state="translated">The weight to indicate a view is a bad break opportunity for the purpose of formatting. This value indicates that no attempt should be made to break the view into fragments as the view has not been written to support fragmenting.</target>
        </trans-unit>
        <trans-unit id="76874f67f43cc55af0d99866288189641d99cbec" translate="yes" xml:space="preserve">
          <source>The weight to indicate a view supports breaking, and must be broken to be represented properly when placed in a view that formats its children by breaking them.</source>
          <target state="translated">The weight to indicate a view supports breaking, and must be broken to be represented properly when placed in a view that formats its children by breaking them.</target>
        </trans-unit>
        <trans-unit id="66a46bf518e93456d81e1cc1896c3ea4c02d290a" translate="yes" xml:space="preserve">
          <source>The weight to indicate a view supports breaking, and this represents a very attractive place to break.</source>
          <target state="translated">The weight to indicate a view supports breaking, and this represents a very attractive place to break.</target>
        </trans-unit>
        <trans-unit id="eefcb368b9c72ba9550bf89a198ccfc8f734dd00" translate="yes" xml:space="preserve">
          <source>The weight to indicate a view supports breaking, but better opportunities probably exist.</source>
          <target state="translated">The weight to indicate a view supports breaking, but better opportunities probably exist.</target>
        </trans-unit>
        <trans-unit id="3af0e31f3b0fc4344fe81ef46aca3c58ce22d30a" translate="yes" xml:space="preserve">
          <source>The west layout constraint (left side of container).</source>
          <target state="translated">The west layout constraint (left side of container).</target>
        </trans-unit>
        <trans-unit id="73c5131fb0d3b07f411026b85ee08ba507a1e260" translate="yes" xml:space="preserve">
          <source>The west-resize cursor type.</source>
          <target state="translated">The west-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="d336c8b0105b02d9ce73f7d6cc89eeb2f4a9e56e" translate="yes" xml:space="preserve">
          <source>The width</source>
          <target state="translated">넓이</target>
        </trans-unit>
        <trans-unit id="a5b89877fef3d4ce5b6e34c401295d24a5b1ecc1" translate="yes" xml:space="preserve">
          <source>The width dimension; negative values can be used.</source>
          <target state="translated">The width dimension; negative values can be used.</target>
        </trans-unit>
        <trans-unit id="7fe9b320764e1c259d500225d7d4be176cd3d638" translate="yes" xml:space="preserve">
          <source>The width is defined as for &lt;a href=&quot;#genWidth&quot;&gt;General conversions&lt;/a&gt;.</source>
          <target state="translated">너비는 &lt;a href=&quot;#genWidth&quot;&gt;일반 변환&lt;/a&gt; 과 같이 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9b89fd07215f56373dd23dc6888317dc590ecf4" translate="yes" xml:space="preserve">
          <source>The width is the minimum number of characters to be written to the output including the &lt;code&gt;'%'&lt;/code&gt;. If the length of the converted value is less than the &lt;code&gt;width&lt;/code&gt; then the output will be padded by spaces (&lt;code&gt;'\u0020'&lt;/code&gt;) until the total number of characters equals width. The padding is on the left. If width is not specified then just the &lt;code&gt;'%'&lt;/code&gt; is output.</source>
          <target state="translated">너비는 &lt;code&gt;'%'&lt;/code&gt; 를 포함하여 출력에 쓸 최소 문자 수입니다 . 변환 된 값의 길이가 &lt;code&gt;width&lt;/code&gt; 보다 작 으면 총 문자 수가 너비와 같아 질 때까지 공백 ( &lt;code&gt;'\u0020'&lt;/code&gt; )으로 출력이 채워집니다 . 패딩은 왼쪽에 있습니다. 너비를 지정하지 않으면 &lt;code&gt;'%'&lt;/code&gt; 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="08497cb4ffc4de43dc36a3a7a1421b6649c24786" translate="yes" xml:space="preserve">
          <source>The width is the minimum number of characters to be written to the output. For the line separator conversion, width is not applicable; if it is provided, an exception will be thrown.</source>
          <target state="translated">너비는 출력에 쓸 최소 문자 수입니다. 행 구분 기호 변환의 경우 너비를 적용 할 수 없습니다. 제공되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93c895f38cd814a0586673133f90d150b89f6aeb" translate="yes" xml:space="preserve">
          <source>The width is the minimum number of characters to be written to the output. If the length of the converted value is less than the &lt;code&gt;width&lt;/code&gt; then the output will be padded by spaces (&lt;code&gt;'\u0020'&lt;/code&gt;) until the total number of characters equals width. The padding is on the left by default. If the &lt;code&gt;'-'&lt;/code&gt; flag is given then the padding will be on the right. If width is not specified then there is no minimum.</source>
          <target state="translated">너비는 출력에 쓸 최소 문자 수입니다. 변환 된 값의 길이가 &lt;code&gt;width&lt;/code&gt; 보다 작 으면 총 문자 수가 너비와 같아 질 때까지 공백 ( &lt;code&gt;'\u0020'&lt;/code&gt; )으로 출력이 채워집니다 . 패딩은 기본적으로 왼쪽에 있습니다. 경우 &lt;code&gt;'-'&lt;/code&gt; 플래그가 지정되었을 경우, 우측으로 패딩됩니다. 너비를 지정하지 않으면 최소값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a00be530872f28f11ef8e1267f18a7a37490125" translate="yes" xml:space="preserve">
          <source>The width of a track.</source>
          <target state="translated">The width of a track.</target>
        </trans-unit>
        <trans-unit id="6cc9b1c619988f1a9026823b7d1be753d92f5b87" translate="yes" xml:space="preserve">
          <source>The width of cell.</source>
          <target state="translated">The width of cell.</target>
        </trans-unit>
        <trans-unit id="11573fd74f145064e80c81a509d0d28ecf0a475c" translate="yes" xml:space="preserve">
          <source>The width of each tile if tiling has been set, or 0 otherwise.</source>
          <target state="translated">바둑판 식 배열이 설정된 경우 각 타일의 너비이거나 그렇지 않은 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="26111ab9024cede0c7bcbac839d8d72eb95603f2" translate="yes" xml:space="preserve">
          <source>The width of the &lt;code&gt;Rectangle&lt;/code&gt;.</source>
          <target state="translated">The width of the &lt;code&gt;Rectangle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dbd0ce0b12788f8c6fe1a25c7715a5920af2e2f" translate="yes" xml:space="preserve">
          <source>The width of the arc that rounds off the corners.</source>
          <target state="translated">The width of the arc that rounds off the corners.</target>
        </trans-unit>
        <trans-unit id="2be9ff6eba22ed6f1a2440bbf3a39091a6762172" translate="yes" xml:space="preserve">
          <source>The width of the column.</source>
          <target state="translated">The width of the column.</target>
        </trans-unit>
        <trans-unit id="ae74f194e7fe200808fa53b00965283e7837c271" translate="yes" xml:space="preserve">
          <source>The width of the matrix must be equal to the number of bands in the source &lt;code&gt;Raster&lt;/code&gt;, optionally plus one. If there is one more column in the matrix than the number of bands, there is an implied 1 at the end of the vector of band samples representing a pixel. The height of the matrix must be equal to the number of bands in the destination.</source>
          <target state="translated">The width of the matrix must be equal to the number of bands in the source &lt;code&gt;Raster&lt;/code&gt; , optionally plus one. If there is one more column in the matrix than the number of bands, there is an implied 1 at the end of the vector of band samples representing a pixel. The height of the matrix must be equal to the number of bands in the destination.</target>
        </trans-unit>
        <trans-unit id="ec49c197d43c64b4897761f6df266e5358ba460b" translate="yes" xml:space="preserve">
          <source>The width of the printed fraction can be controlled. Setting the minimum width to zero will cause no output to be generated. The printed fraction will have the minimum width necessary between the minimum and maximum widths - trailing zeroes are omitted. No rounding occurs due to the maximum width - digits are simply dropped.</source>
          <target state="translated">인쇄 된 부분의 너비를 제어 할 수 있습니다. 최소 너비를 0으로 설정하면 출력이 생성되지 않습니다. 인쇄 된 분수는 최소 너비와 최대 너비 사이에 필요한 최소 너비를 갖습니다. 후행 0은 생략됩니다. 최대 너비로 인해 반올림이 발생하지 않습니다. 숫자는 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4db7f10432db004de2848eb50eb2f97f278b4bde" translate="yes" xml:space="preserve">
          <source>The width of the scroll bar.</source>
          <target state="translated">The width of the scroll bar.</target>
        </trans-unit>
        <trans-unit id="bba108bcc6b63cc2c45f5b2bc0acff2a33d32159" translate="yes" xml:space="preserve">
          <source>The width of the source image.</source>
          <target state="translated">The width of the source image.</target>
        </trans-unit>
        <trans-unit id="467664440e728cd0513b8119f412e4725d00fa48" translate="yes" xml:space="preserve">
          <source>The width of this &lt;code&gt;Rectangle2D&lt;/code&gt;.</source>
          <target state="translated">The width of this &lt;code&gt;Rectangle2D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f129436c32d43b679e1dc40b1904538aab43a278" translate="yes" xml:space="preserve">
          <source>The width of this &lt;code&gt;RoundRectangle2D&lt;/code&gt;.</source>
          <target state="translated">The width of this &lt;code&gt;RoundRectangle2D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da2e476462af867fea4cbe849e1dc3d400f5f75b" translate="yes" xml:space="preserve">
          <source>The width of this Raster.</source>
          <target state="translated">The width of this Raster.</target>
        </trans-unit>
        <trans-unit id="e6ca716e5e2fbbd59657bd7119f1d5b63fdfb718" translate="yes" xml:space="preserve">
          <source>The winding rule constant for specifying a non-zero rule for determining the interior of a path.</source>
          <target state="translated">The winding rule constant for specifying a non-zero rule for determining the interior of a path.</target>
        </trans-unit>
        <trans-unit id="17dd3723cfa6dddf3c10b7ea71c1c9ec63bc0dd5" translate="yes" xml:space="preserve">
          <source>The winding rule constant for specifying a non-zero rule for determining the interior of a path. The non-zero rule specifies that a point lies inside the path if a ray drawn in any direction from that point to infinity is crossed by path segments a different number of times in the counter-clockwise direction than the clockwise direction.</source>
          <target state="translated">The winding rule constant for specifying a non-zero rule for determining the interior of a path. The non-zero rule specifies that a point lies inside the path if a ray drawn in any direction from that point to infinity is crossed by path segments a different number of times in the counter-clockwise direction than the clockwise direction.</target>
        </trans-unit>
        <trans-unit id="42897bc85e90af955b1b036d68df3ede0520e2d7" translate="yes" xml:space="preserve">
          <source>The winding rule constant for specifying an even-odd rule for determining the interior of a path.</source>
          <target state="translated">The winding rule constant for specifying an even-odd rule for determining the interior of a path.</target>
        </trans-unit>
        <trans-unit id="3ff56485c7b54311de67fa6367a706a77de06072" translate="yes" xml:space="preserve">
          <source>The winding rule constant for specifying an even-odd rule for determining the interior of a path. The even-odd rule specifies that a point lies inside the path if a ray drawn in any direction from that point to infinity is crossed by path segments an odd number of times.</source>
          <target state="translated">The winding rule constant for specifying an even-odd rule for determining the interior of a path. The even-odd rule specifies that a point lies inside the path if a ray drawn in any direction from that point to infinity is crossed by path segments an odd number of times.</target>
        </trans-unit>
        <trans-unit id="cb3dac7693e4da51d74dd397d6ac8d2f8822d5fb" translate="yes" xml:space="preserve">
          <source>The window closed event.</source>
          <target state="translated">The window closed event.</target>
        </trans-unit>
        <trans-unit id="0ef1e15cdf59bfc15e5c7c19ba66a29ba977331a" translate="yes" xml:space="preserve">
          <source>The window closed event. This event is delivered after the displayable window has been closed as the result of a call to dispose.</source>
          <target state="translated">The window closed event. This event is delivered after the displayable window has been closed as the result of a call to dispose.</target>
        </trans-unit>
        <trans-unit id="de02df67bc85e91662c4c591736b87f0cd0353a9" translate="yes" xml:space="preserve">
          <source>The window deiconified event type.</source>
          <target state="translated">The window deiconified event type.</target>
        </trans-unit>
        <trans-unit id="9235256e89888414156b55feb8b39098b5ff03cd" translate="yes" xml:space="preserve">
          <source>The window deiconified event type. This event is delivered when the window has been changed from a minimized to a normal state.</source>
          <target state="translated">The window deiconified event type. This event is delivered when the window has been changed from a minimized to a normal state.</target>
        </trans-unit>
        <trans-unit id="0e372d5a8465caac9411c2c0cf1477139b398aee" translate="yes" xml:space="preserve">
          <source>The window iconified event.</source>
          <target state="translated">The window iconified event.</target>
        </trans-unit>
        <trans-unit id="61db558573486e08d4a937e6a29ea7a159147807" translate="yes" xml:space="preserve">
          <source>The window iconified event. This event is delivered when the window has been changed from a normal to a minimized state. For many platforms, a minimized window is displayed as the icon specified in the window's iconImage property.</source>
          <target state="translated">The window iconified event. This event is delivered when the window has been changed from a normal to a minimized state. For many platforms, a minimized window is displayed as the icon specified in the window's iconImage property.</target>
        </trans-unit>
        <trans-unit id="46898a0da1924e8243f2efb4d772e66f635671da" translate="yes" xml:space="preserve">
          <source>The window meets the requirements outlined in the &lt;a href=&quot;#isFocusableWindow()&quot;&gt;&lt;code&gt;isFocusableWindow()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">The window meets the requirements outlined in the &lt;a href=&quot;#isFocusableWindow()&quot;&gt; &lt;code&gt;isFocusableWindow()&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="8013fd08c38b0c136b4c63192fdf704c335236e9" translate="yes" xml:space="preserve">
          <source>The window must be undecorated (see &lt;a href=&quot;frame#setUndecorated(boolean)&quot;&gt;&lt;code&gt;Frame.setUndecorated(boolean)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;dialog#setUndecorated(boolean)&quot;&gt;&lt;code&gt;Dialog.setUndecorated(boolean)&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">The window must be undecorated (see &lt;a href=&quot;frame#setUndecorated(boolean)&quot;&gt; &lt;code&gt;Frame.setUndecorated(boolean)&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;dialog#setUndecorated(boolean)&quot;&gt; &lt;code&gt;Dialog.setUndecorated(boolean)&lt;/code&gt; &lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="c31a61d56f8fbb4d525dfbb6bfb6163a1fc40d51" translate="yes" xml:space="preserve">
          <source>The window must not be in full-screen mode (see &lt;a href=&quot;graphicsdevice#setFullScreenWindow(java.awt.Window)&quot;&gt;&lt;code&gt;GraphicsDevice.setFullScreenWindow(Window)&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">The window must not be in full-screen mode (see &lt;a href=&quot;graphicsdevice#setFullScreenWindow(java.awt.Window)&quot;&gt; &lt;code&gt;GraphicsDevice.setFullScreenWindow(Window)&lt;/code&gt; &lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="12179198884def542b1e63dec6891ae3478228aa" translate="yes" xml:space="preserve">
          <source>The window opened event.</source>
          <target state="translated">The window opened event.</target>
        </trans-unit>
        <trans-unit id="d9c403769bb1b8ddcb5ee7eb7efd4dc97f5ba17c" translate="yes" xml:space="preserve">
          <source>The window opened event. This event is delivered only the first time a window is made visible.</source>
          <target state="translated">The window opened event. This event is delivered only the first time a window is made visible.</target>
        </trans-unit>
        <trans-unit id="ccb573daae62a72c29efc1daca58ce1f319b8f8b" translate="yes" xml:space="preserve">
          <source>The window which appears during dragging the &lt;code&gt;JToolBar&lt;/code&gt;.</source>
          <target state="translated">The window which appears during dragging the &lt;code&gt;JToolBar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="627ea3aec1aad90747aca022b53aff37eb58e0f4" translate="yes" xml:space="preserve">
          <source>The window will be shown at (10, 10) and &lt;code&gt;flag&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">The window will be shown at (10, 10) and &lt;code&gt;flag&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="486d407655bd0137b66e348fad418045e32a3045" translate="yes" xml:space="preserve">
          <source>The window will be shown at platform's default location and &lt;code&gt;flag&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">The window will be shown at platform's default location and &lt;code&gt;flag&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b482607b5b7693f411bfff481c78b79313d1cd0f" translate="yes" xml:space="preserve">
          <source>The window's property &lt;code&gt;autoRequestFocus&lt;/code&gt; is of the &lt;code&gt;true&lt;/code&gt; value.</source>
          <target state="translated">The window's property &lt;code&gt;autoRequestFocus&lt;/code&gt; is of the &lt;code&gt;true&lt;/code&gt; value.</target>
        </trans-unit>
        <trans-unit id="e9d1953e7c545d68c018dccb254a551ad30edc99" translate="yes" xml:space="preserve">
          <source>The window-activated event type.</source>
          <target state="translated">The window-activated event type.</target>
        </trans-unit>
        <trans-unit id="05a1d8f582a9cb48572066d44594f6f9a0e95350" translate="yes" xml:space="preserve">
          <source>The window-activated event type. This event is delivered when the Window becomes the active Window. Only a Frame or a Dialog can be the active Window. The native windowing system may denote the active Window or its children with special decorations, such as a highlighted title bar. The active Window is always either the focused Window, or the first Frame or Dialog that is an owner of the focused Window.</source>
          <target state="translated">The window-activated event type. This event is delivered when the Window becomes the active Window. Only a Frame or a Dialog can be the active Window. The native windowing system may denote the active Window or its children with special decorations, such as a highlighted title bar. The active Window is always either the focused Window, or the first Frame or Dialog that is an owner of the focused Window.</target>
        </trans-unit>
        <trans-unit id="620aac9452d22064e93f456a4ba7a240878b4cb2" translate="yes" xml:space="preserve">
          <source>The window-closing listener for the popup.</source>
          <target state="translated">The window-closing listener for the popup.</target>
        </trans-unit>
        <trans-unit id="5937c89c2aa1fabf6fb823ab66cb280051f96c32" translate="yes" xml:space="preserve">
          <source>The window-deactivated event type.</source>
          <target state="translated">The window-deactivated event type.</target>
        </trans-unit>
        <trans-unit id="c822528e2cae65479b7ced58d2f8ee70b3b6c23d" translate="yes" xml:space="preserve">
          <source>The window-deactivated event type. This event is delivered when the Window is no longer the active Window. Only a Frame or a Dialog can be the active Window. The native windowing system may denote the active Window or its children with special decorations, such as a highlighted title bar. The active Window is always either the focused Window, or the first Frame or Dialog that is an owner of the focused Window.</source>
          <target state="translated">The window-deactivated event type. This event is delivered when the Window is no longer the active Window. Only a Frame or a Dialog can be the active Window. The native windowing system may denote the active Window or its children with special decorations, such as a highlighted title bar. The active Window is always either the focused Window, or the first Frame or Dialog that is an owner of the focused Window.</target>
        </trans-unit>
        <trans-unit id="32c0b2bab232cd7fa45a3c809b9858ff0a4d0ccc" translate="yes" xml:space="preserve">
          <source>The window-gained-focus event type.</source>
          <target state="translated">The window-gained-focus event type.</target>
        </trans-unit>
        <trans-unit id="fe95f333af206a0b02ba68561b21bf9f4477533d" translate="yes" xml:space="preserve">
          <source>The window-gained-focus event type. This event is delivered when the Window becomes the focused Window, which means that the Window, or one of its subcomponents, will receive keyboard events.</source>
          <target state="translated">The window-gained-focus event type. This event is delivered when the Window becomes the focused Window, which means that the Window, or one of its subcomponents, will receive keyboard events.</target>
        </trans-unit>
        <trans-unit id="c7d4bb6299e2996b5c2fb075d5e44b4b1bd3efac" translate="yes" xml:space="preserve">
          <source>The window-lost-focus event type.</source>
          <target state="translated">The window-lost-focus event type.</target>
        </trans-unit>
        <trans-unit id="8524907cf338f83d544d4af56f4cc171c3a5e3d6" translate="yes" xml:space="preserve">
          <source>The window-lost-focus event type. This event is delivered when a Window is no longer the focused Window, which means keyboard events will no longer be delivered to the Window or any of its subcomponents.</source>
          <target state="translated">The window-lost-focus event type. This event is delivered when a Window is no longer the focused Window, which means keyboard events will no longer be delivered to the Window or any of its subcomponents.</target>
        </trans-unit>
        <trans-unit id="30ca39d08748f017be96913aa3f733ae5da76227" translate="yes" xml:space="preserve">
          <source>The window-state-changed event type.</source>
          <target state="translated">The window-state-changed event type.</target>
        </trans-unit>
        <trans-unit id="7e5dbb9cc1f4ebccc0d301342951c952d5b9192f" translate="yes" xml:space="preserve">
          <source>The window-state-changed event type. This event is delivered when a Window's state is changed by virtue of it being iconified, maximized etc.</source>
          <target state="translated">The window-state-changed event type. This event is delivered when a Window's state is changed by virtue of it being iconified, maximized etc.</target>
        </trans-unit>
        <trans-unit id="87463d379aacb015b2b5b4467fead7e3636e854d" translate="yes" xml:space="preserve">
          <source>The working directory does not exist.</source>
          <target state="translated">작업 디렉토리가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="149ba28788d40521e03aae86481799a4aad8958e" translate="yes" xml:space="preserve">
          <source>The working directory of the new subprocess is specified by &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the subprocess inherits the current working directory of the current process.</source>
          <target state="translated">새 하위 프로세스의 작업 디렉토리는 &lt;code&gt;dir&lt;/code&gt; 로 지정됩니다 . 경우 &lt;code&gt;dir&lt;/code&gt; 있습니다 &lt;code&gt;null&lt;/code&gt; , 서브 프로세스는 현재의 프로세스의 현재 작업 디렉토리를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="9d7e42ba8563b4861562d9fedd9c297c3c802ae3" translate="yes" xml:space="preserve">
          <source>The wrapper instance will implement the requested interface and its super-types, but no other single-method interfaces. This means that the instance will not unexpectedly pass an &lt;code&gt;instanceof&lt;/code&gt; test for any unrequested type.</source>
          <target state="translated">랩퍼 인스턴스는 요청 된 인터페이스 및 해당 수퍼 유형을 구현하지만 다른 단일 메소드 인터페이스는 구현하지 않습니다. 이는 요청되지 않은 유형에 대해 인스턴스가 예기치 않게 테스트 &lt;code&gt;instanceof&lt;/code&gt; 통과하지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="15818e243ca25bb45bac35d277861523076bc5b5" translate="yes" xml:space="preserve">
          <source>The wrapper pattern is employed by many JDBC driver implementations to provide extensions beyond the traditional JDBC API that are specific to a data source. Developers may wish to gain access to these resources that are wrapped (the delegates) as proxy class instances representing the the actual resources. This interface describes a standard mechanism to access these wrapped resources represented by their proxy, to permit direct access to the resource delegates.</source>
          <target state="translated">The wrapper pattern is employed by many JDBC driver implementations to provide extensions beyond the traditional JDBC API that are specific to a data source. Developers may wish to gain access to these resources that are wrapped (the delegates) as proxy class instances representing the the actual resources. This interface describes a standard mechanism to access these wrapped resources represented by their proxy, to permit direct access to the resource delegates.</target>
        </trans-unit>
        <trans-unit id="3c15fc629a9a44eeca7f4fece2da5b14c32ef837" translate="yes" xml:space="preserve">
          <source>The wrapper will allow data to be collected on the native method call, but now the problem becomes linking up the wrapped method with the native implementation. That is, the method &lt;code&gt;wrapped_foo&lt;/code&gt; needs to be resolved to the native implementation of &lt;code&gt;foo&lt;/code&gt;, which might be:</source>
          <target state="translated">랩퍼는 원시 메소드 호출에서 데이터를 수집 할 수 있지만 이제 문제점은 랩핑 된 메소드를 원시 구현과 링크합니다. 즉, &lt;code&gt;wrapped_foo&lt;/code&gt; 메소드는 다음과 같은 &lt;code&gt;foo&lt;/code&gt; 기본 구현으로 분석 되어야합니다.</target>
        </trans-unit>
        <trans-unit id="16ec3748a6bad8d0fc41d7ba859a56b2513c46d9" translate="yes" xml:space="preserve">
          <source>The write end of a pipe</source>
          <target state="translated">파이프의 쓰기 끝</target>
        </trans-unit>
        <trans-unit id="8f8bfaf5e08009c50abac22b29c0466e9561af91" translate="yes" xml:space="preserve">
          <source>The write lock is acquired by the current thread; or</source>
          <target state="translated">쓰기 잠금은 현재 스레드에 의해 획득됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="0abe4db30711536753fa1129b368626382d73332" translate="yes" xml:space="preserve">
          <source>The write lock provides a &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; implementation that behaves in the same way, with respect to the write lock, as the &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; implementation provided by &lt;a href=&quot;reentrantlock#newCondition()&quot;&gt;&lt;code&gt;ReentrantLock.newCondition()&lt;/code&gt;&lt;/a&gt; does for &lt;a href=&quot;reentrantlock&quot;&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; can, of course, only be used with the write lock.</source>
          <target state="translated">The write lock provides a &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; implementation that behaves in the same way, with respect to the write lock, as the &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; implementation provided by &lt;a href=&quot;reentrantlock#newCondition()&quot;&gt; &lt;code&gt;ReentrantLock.newCondition()&lt;/code&gt; &lt;/a&gt; does for &lt;a href=&quot;reentrantlock&quot;&gt; &lt;code&gt;ReentrantLock&lt;/code&gt; &lt;/a&gt;. This &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; can, of course, only be used with the write lock.</target>
        </trans-unit>
        <trans-unit id="4479644870cc0b6de23ac32560cf11f5241f6aec" translate="yes" xml:space="preserve">
          <source>The write lock provides a &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; implementation that behaves in the same way, with respect to the write lock, as the &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; implementation provided by &lt;a href=&quot;reentrantlock#newCondition--&quot;&gt;&lt;code&gt;ReentrantLock.newCondition()&lt;/code&gt;&lt;/a&gt; does for &lt;a href=&quot;reentrantlock&quot;&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; can, of course, only be used with the write lock.</source>
          <target state="translated">기입 로크는 제공 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 은 AS 쓰기 잠금에 대하여 동일한 방식으로 동작, 구현한다는 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 에 의해 제공 구현 &lt;a href=&quot;reentrantlock#newCondition--&quot;&gt; &lt;code&gt;ReentrantLock.newCondition()&lt;/code&gt; &lt;/a&gt; 에 대해 수행 &lt;a href=&quot;reentrantlock&quot;&gt; &lt;code&gt;ReentrantLock&lt;/code&gt; 와이&lt;/a&gt; . 물론 이 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 은 쓰기 잠금에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02bad978674eb6748c2b65fbeda2a59a87a1171a" translate="yes" xml:space="preserve">
          <source>The write operation may write up to</source>
          <target state="translated">쓰기 작업은 최대</target>
        </trans-unit>
        <trans-unit id="848f53cc5fb27d051b03412fae86949bd08f9ecd" translate="yes" xml:space="preserve">
          <source>The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The default mechanism for saving the Object's fields can be invoked by calling out.defaultWriteObject. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.</source>
          <target state="translated">writeObject 메소드는 해당 readObject 메소드가이를 복원 할 수 있도록 특정 클래스에 대한 오브젝트 상태를 작성합니다. out.defaultWriteObject를 호출하여 객체 필드를 저장하는 기본 메커니즘을 호출 할 수 있습니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. writeObject 메소드를 사용하거나 DataOutput에서 지원하는 기본 데이터 유형의 메소드를 사용하여 개별 필드를 ObjectOutputStream에 기록하여 상태가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="0bfd2d3d4a572740437c98d7a9b174fefaf95ccd" translate="yes" xml:space="preserve">
          <source>The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The method does not need to concern itself with the state belonging to the object's superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.</source>
          <target state="translated">writeObject 메소드는 해당 readObject 메소드가 복원 할 수 있도록 특정 클래스에 대한 오브젝트 상태를 작성합니다. 이 메소드는 객체의 슈퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. writeObject 메소드를 사용하거나 DataOutput에서 지원하는 기본 데이터 유형의 메소드를 사용하여 개별 필드를 ObjectOutputStream에 기록하여 상태가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="32895c9078e9c0d94dfbce29bcfd1e45f1dd1f75" translate="yes" xml:space="preserve">
          <source>The writeStreamHeader method is provided so subclasses can append or prepend their own header to the stream.</source>
          <target state="translated">The writeStreamHeader method is provided so subclasses can append or prepend their own header to the stream.</target>
        </trans-unit>
        <trans-unit id="12162856e28a75771ac79f11fb7626d43e724abb" translate="yes" xml:space="preserve">
          <source>The writeStreamHeader method is provided so subclasses can append or prepend their own header to the stream. It writes the magic number and version to the stream.</source>
          <target state="translated">writeStreamHeader 메소드가 제공되어 서브 클래스가 자체 헤더를 스트림에 추가하거나 추가 할 수 있습니다. 매직 넘버와 버전을 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="275389c2830a7db9582b391c6c5af66340e673db" translate="yes" xml:space="preserve">
          <source>The writer's default action for malformed-input and unmappable-character errors is to &lt;a href=&quot;../charset/codingerroraction#REPORT&quot;&gt;report&lt;/a&gt; them. When more control over the error handling is required, the constructor that takes a &lt;a href=&quot;../charset/charsetencoder&quot;&gt;CharsetEncoder&lt;/a&gt; should be used.</source>
          <target state="translated">The writer's default action for malformed-input and unmappable-character errors is to &lt;a href=&quot;../charset/codingerroraction#REPORT&quot;&gt;report&lt;/a&gt; them. When more control over the error handling is required, the constructor that takes a &lt;a href=&quot;../charset/charsetencoder&quot;&gt;CharsetEncoder&lt;/a&gt; should be used.</target>
        </trans-unit>
        <trans-unit id="62a34851e79619261706f169067b1e8ae983bacb" translate="yes" xml:space="preserve">
          <source>The writing is not complete until a call to &lt;code&gt;endWriteEmpty&lt;/code&gt; occurs. Calls to &lt;code&gt;prepareReplacePixels&lt;/code&gt;, &lt;code&gt;replacePixels&lt;/code&gt;, and &lt;code&gt;endReplacePixels&lt;/code&gt; may occur between calls to &lt;code&gt;prepareWriteEmpty&lt;/code&gt; and &lt;code&gt;endWriteEmpty&lt;/code&gt;. However, calls to &lt;code&gt;prepareWriteEmpty&lt;/code&gt; cannot be nested, and calls to &lt;code&gt;prepareWriteEmpty&lt;/code&gt; and &lt;code&gt;prepareInsertEmpty&lt;/code&gt; may not be interspersed.</source>
          <target state="translated">&lt;code&gt;endWriteEmpty&lt;/code&gt; 에 대한 호출이 발생할 때까지 쓰기가 완료되지 않습니다 . 를 호출 &lt;code&gt;prepareReplacePixels&lt;/code&gt; , &lt;code&gt;replacePixels&lt;/code&gt; 및 &lt;code&gt;endReplacePixels&lt;/code&gt; 는 호출 사이에 발생할 수 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; 와 &lt;code&gt;endWriteEmpty&lt;/code&gt; . 그러나 호출 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; 중첩 될 수 없으며, 호출 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; 와 &lt;code&gt;prepareInsertEmpty&lt;/code&gt; 산재되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f340ab186950cff3443ac085c8bde6bcffa4a47" translate="yes" xml:space="preserve">
          <source>The writing of interlaced images can be controlled by the progressive mode of the provided &lt;code&gt;ImageWriteParam&lt;/code&gt; instance. If progressive mode is &lt;code&gt;MODE_DISABLED&lt;/code&gt; then a non-interlaced image will be written. If progressive mode is &lt;code&gt;MODE_DEFAULT&lt;/code&gt; then an interlaced image will be written. If progressive mode is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;, then the metadata setting is used (if it is provided, otherwise an interlaced image will be written).</source>
          <target state="translated">인터레이스 이미지 쓰기는 제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 인스턴스 의 프로그레시브 모드로 제어 할 수 있습니다 . 프로그레시브 모드가 &lt;code&gt;MODE_DISABLED&lt;/code&gt; 이면 비 인터레이스 이미지가 기록됩니다. 프로그레시브 모드가 &lt;code&gt;MODE_DEFAULT&lt;/code&gt; 이면 인터레이스 이미지가 기록됩니다. 프로그레시브 모드가 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 이면 메타 데이터 설정이 사용됩니다 (제공된 경우 인터레이스 이미지가 기록됨).</target>
        </trans-unit>
        <trans-unit id="470f5ef5b9bb159907b73cd224384f1fb1f65e99" translate="yes" xml:space="preserve">
          <source>The year 1AD/CE is represented by 1.</source>
          <target state="translated">1AD / CE 연도는 1로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="94efbba691fdae1a9f89ed9e390e5077e5ec1212" translate="yes" xml:space="preserve">
          <source>The year 1BC/BCE is represented by 0.</source>
          <target state="translated">1BC / BCE 연도는 0으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a4166e71717478dfbab468797a5aaf46cfd05d82" translate="yes" xml:space="preserve">
          <source>The year 2AD/CE is represented by 2.</source>
          <target state="translated">2AD / CE 연도는 2로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="109099de288ae4e09256b7ba426e8999e6a15a2f" translate="yes" xml:space="preserve">
          <source>The year 2BC/BCE is represented by -1.</source>
          <target state="translated">2BC / BCE 연도는 -1로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="07ec242f131c9a27b1dbfd15fa2dc1ccc37871eb" translate="yes" xml:space="preserve">
          <source>The year can be divided into four quarters. This method returns the first month of the quarter for the base month. January, February and March return January. April, May and June return April. July, August and September return July. October, November and December return October.</source>
          <target state="translated">연도는 4 분기로 나눌 수 있습니다. 이 방법은 기준 월에 대한 분기의 첫 번째 달을 반환합니다. 1 월, 2 월 및 3 월은 1 월에 돌아옵니다. 4 월, 5 월 및 6 월은 4 월에 돌아옵니다. 7 월, 8 월, 9 월은 7 월에 돌아옵니다. 10 월, 11 월 및 12 월은 10 월에 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="afab05cb473c717daf7febfb9975eb7cefe918aa" translate="yes" xml:space="preserve">
          <source>The year of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;.</source>
          <target state="translated">The year of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63b23bd5415b33a1dd713df991700a20700f76a3" translate="yes" xml:space="preserve">
          <source>The year returned by this method is proleptic as per &lt;code&gt;get(YEAR)&lt;/code&gt;.</source>
          <target state="translated">이 방법으로 반환 된 연도는 &lt;code&gt;get(YEAR)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6358c1cf0f427abe2556c16331c59f4b8d32da2" translate="yes" xml:space="preserve">
          <source>The year returned by this method is proleptic as per &lt;code&gt;get(YEAR)&lt;/code&gt;. To obtain the year-of-era, use &lt;code&gt;get(YEAR_OF_ERA)&lt;/code&gt;.</source>
          <target state="translated">이 메소드에 의해 반환 된 &lt;code&gt;get(YEAR)&lt;/code&gt; 는 get (YEAR)에 따라 다산 입니다. 연도를 얻으려면 &lt;code&gt;get(YEAR_OF_ERA)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbff7fe10e8b9cf90167f0d75f706532355546dc" translate="yes" xml:space="preserve">
          <source>The year within the era.</source>
          <target state="translated">시대의 해.</target>
        </trans-unit>
        <trans-unit id="41d3f4e85bc99f5353fb949c0b4b1e34eb530da9" translate="yes" xml:space="preserve">
          <source>The year, month, and day are checked against the new requested HijrahChronology. If the chronology has a shorter month length for the month, the day is reduced to be the last day of the month.</source>
          <target state="translated">새로운 요청 된 HijrahChronology에 대해 년, 월 및 일이 점검됩니다. 연대기의 월 길이가 더 짧으면 해당 월의 마지막 날로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="f49394166860fac852827d9d4a7948593a920114" translate="yes" xml:space="preserve">
          <source>The zeroed destination &lt;code&gt;Raster&lt;/code&gt;.</source>
          <target state="translated">The zeroed destination &lt;code&gt;Raster&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61c023d679e1c8ed9ff9b485125a4b40e5e8821a" translate="yes" xml:space="preserve">
          <source>The zeroed destination image.</source>
          <target state="translated">The zeroed destination image.</target>
        </trans-unit>
        <trans-unit id="95823fc22286c4941f6416c1b3d8f9df75024a4b" translate="yes" xml:space="preserve">
          <source>The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it's one of the valid IDs of the &lt;a href=&quot;../util/timezone&quot;&gt;&lt;code&gt;TimeZone&lt;/code&gt;&lt;/a&gt; class that are not &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;custom IDs&lt;/a&gt;. All other entries are localized names.</source>
          <target state="translated">영역 ID가 현지화 &lt;em&gt;되지 않았습니다&lt;/em&gt; . &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;사용자 정의 ID&lt;/a&gt; 가 아닌 &lt;a href=&quot;../util/timezone&quot;&gt; &lt;code&gt;TimeZone&lt;/code&gt; &lt;/a&gt; 클래스 의 유효한 ID 중 하나입니다. . 다른 모든 항목은 현지화 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="12a91a95938b30a6f68ad5300194d7afd44011e4" translate="yes" xml:space="preserve">
          <source>The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it's one of the valid IDs of the &lt;a href=&quot;../util/timezone&quot;&gt;&lt;code&gt;TimeZone&lt;/code&gt;&lt;/a&gt; class that are not &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;custom IDs&lt;/a&gt;. All other entries are localized names. If a zone does not implement daylight saving time, the daylight saving time names should not be used.</source>
          <target state="translated">영역 ID가 현지화 &lt;em&gt;되지 않았습니다&lt;/em&gt; . &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;사용자 정의 ID&lt;/a&gt; 가 아닌 &lt;a href=&quot;../util/timezone&quot;&gt; &lt;code&gt;TimeZone&lt;/code&gt; &lt;/a&gt; 클래스 의 유효한 ID 중 하나입니다 . 다른 모든 항목은 현지화 된 이름입니다. 영역이 일광 절약 시간제를 구현하지 않으면 일광 절약 시간제 이름을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="1e74dc8e4aa7b15926d1c952bce85e5bbf3526d8" translate="yes" xml:space="preserve">
          <source>The zone ID may be same as the &lt;a href=&quot;#getOffset()&quot;&gt;offset&lt;/a&gt;. If this is true, then any future calculations, such as addition or subtraction, have no complex edge cases due to time-zone rules. See also &lt;a href=&quot;#withFixedOffsetZone()&quot;&gt;&lt;code&gt;withFixedOffsetZone()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The zone ID may be same as the &lt;a href=&quot;#getOffset()&quot;&gt;offset&lt;/a&gt;. If this is true, then any future calculations, such as addition or subtraction, have no complex edge cases due to time-zone rules. See also &lt;a href=&quot;#withFixedOffsetZone()&quot;&gt; &lt;code&gt;withFixedOffsetZone()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ef072be235e128f4417bff8f2ecc9a9fd327d55d" translate="yes" xml:space="preserve">
          <source>The zone ID may be same as the &lt;a href=&quot;zoneddatetime#getOffset--&quot;&gt;offset&lt;/a&gt;. If this is true, then any future calculations, such as addition or subtraction, have no complex edge cases due to time-zone rules. See also &lt;a href=&quot;zoneddatetime#withFixedOffsetZone--&quot;&gt;&lt;code&gt;withFixedOffsetZone()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">영역 ID는 &lt;a href=&quot;zoneddatetime#getOffset--&quot;&gt;오프셋&lt;/a&gt; 과 동일 할 수 있습니다 . 이것이 사실이라면, 시간대 규칙으로 인해 더하기 나 빼기와 같은 미래 계산에는 복잡한 경우가 없습니다. &lt;a href=&quot;zoneddatetime#withFixedOffsetZone--&quot;&gt; &lt;code&gt;withFixedOffsetZone()&lt;/code&gt; &lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="0e5541312fac30d6776b7c47cc8181f1f41befb2" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;implies&lt;/code&gt; checks each of the following, in order, and for each returns true if the stated condition is true:</source>
          <target state="translated">그런 다음 &lt;code&gt;implies&lt;/code&gt; 위해 검사 다음의 각을, 각각의 반환을 위해 명시된 조건이 참에 해당하는 경우 :</target>
        </trans-unit>
        <trans-unit id="9548fcc35b330bbac33c7968b3c68d3a8baf60b6" translate="yes" xml:space="preserve">
          <source>Then every entry in this &lt;code&gt;Properties&lt;/code&gt; table is written out, one per line. For each entry the key string is written, then an ASCII &lt;code&gt;=&lt;/code&gt;, then the associated element string. For the key, all space characters are written with a preceding &lt;code&gt;\&lt;/code&gt; character. For the element, leading space characters, but not embedded or trailing space characters, are written with a preceding &lt;code&gt;\&lt;/code&gt; character. The key and element characters &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; are written with a preceding backslash to ensure that they are properly loaded.</source>
          <target state="translated">그런 다음이 &lt;code&gt;Properties&lt;/code&gt; 테이블의 모든 항목이 한 줄에 하나씩 작성됩니다. 각 항목에 대해 키 문자열이 작성된 다음 ASCII &lt;code&gt;=&lt;/code&gt; , 관련 요소 문자열이 작성됩니다. 키의 경우 모든 공백 문자는 앞에 &lt;code&gt;\&lt;/code&gt; 문자 로 기록됩니다 . 요소의 경우 선행 또는 공백 문자가 아닌 선행 공백 문자는 앞에 &lt;code&gt;\&lt;/code&gt; 문자 로 기록됩니다 . 키와 요소의 문자 &lt;code&gt;#&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; 및 &lt;code&gt;:&lt;/code&gt; 은 백 슬래시로 작성되어 올바르게로드되도록합니다.</target>
        </trans-unit>
        <trans-unit id="f2515634c238092ca6ab3e114e72af7420724d4f" translate="yes" xml:space="preserve">
          <source>Then it calls &lt;code&gt;newMBeanServer(defaultDomain,outer,delegate)&lt;/code&gt; passing the &lt;var&gt;delegate&lt;/var&gt; that should be used by the MBeanServer implementation.</source>
          <target state="translated">그런 다음 MBeanServer 구현에서 사용해야 하는 &lt;var&gt;delegate&lt;/var&gt; 를 전달하여 &lt;code&gt;newMBeanServer(defaultDomain,outer,delegate)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5c9c219ad93a3973cb2bece1cad4c707c4e984e8" translate="yes" xml:space="preserve">
          <source>Then the floating-point result equals the value of the mathematical expression</source>
          <target state="translated">그런 다음 부동 소수점 결과는 수학 표현식의 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2305112f3cfd47ec6189ee9ae9aff82a3050640c" translate="yes" xml:space="preserve">
          <source>Then the following linkage invariants must hold:</source>
          <target state="translated">그런 다음 다음 연결 불변 값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed9c8aedb6a288d80aca27bb2abdd611ccdaa129" translate="yes" xml:space="preserve">
          <source>Then the method &lt;code&gt;doIt&lt;/code&gt; is overloaded. EventHandler will invoke the method that is appropriate based on the source. If the source is null, then either method is appropriate and the one that is invoked is undefined. For that reason we recommend against targeting overloaded methods.</source>
          <target state="translated">그런 다음 &lt;code&gt;doIt&lt;/code&gt; 메소드 가 오버로드됩니다. EventHandler는 소스를 기반으로 적절한 메소드를 호출합니다. 소스가 널인 경우, 두 메소드 중 하나가 적합하고 호출 된 메소드가 정의되지 않습니다. 따라서 오버로드 된 메소드를 타겟팅하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2b4072d84089ea555465f4ab10a4485f817372e1" translate="yes" xml:space="preserve">
          <source>Then two durations are subtracted field by field. If the sign of any non-zero field &lt;code&gt;F&lt;/code&gt; is different from the sign of the most significant field, 1 (if &lt;code&gt;F&lt;/code&gt; is negative) or -1 (otherwise) will be borrowed from the next bigger unit of &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">Then two durations are subtracted field by field. If the sign of any non-zero field &lt;code&gt;F&lt;/code&gt; is different from the sign of the most significant field, 1 (if &lt;code&gt;F&lt;/code&gt; is negative) or -1 (otherwise) will be borrowed from the next bigger unit of &lt;code&gt;F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf6134715d80b46ffde96271931c92751bbdaf3f" translate="yes" xml:space="preserve">
          <source>Then you can execute:</source>
          <target state="translated">그런 다음 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63c81bede51f6179d36f078fe8cba0feafc1e55" translate="yes" xml:space="preserve">
          <source>Then, before sending a notification to a listener registered with a filter, the notification broadcaster compares this notification type with all notification types enabled by the filter. The notification will be sent to the listener only if its filter enables this notification type.</source>
          <target state="translated">그런 다음 필터로 등록 된 리스너에 알림을 보내기 전에 알림 브로드 캐스터는이 알림 유형을 필터에서 사용 가능한 모든 알림 유형과 비교합니다. 필터에서이 알림 유형을 활성화 한 경우에만 알림이 리스너에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="d356dd80aaac6fd043102b988a584a6fc2fbf218" translate="yes" xml:space="preserve">
          <source>There are 3 HTTP cookie specifications:</source>
          <target state="translated">3 가지 HTTP 쿠키 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da791d8e9fec115ce104b9f6b089536088c3804" translate="yes" xml:space="preserve">
          <source>There are 52 weeks in most week-based years, however on occasion there are 53 weeks.</source>
          <target state="translated">대부분의 주 단위로 52 주가 있지만 때로는 53 주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea75d499786717edf2fd9174e48f8b5e056e64a9" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;SSLSessionContext&lt;/code&gt; parameters that affect how sessions are stored:</source>
          <target state="translated">세션 저장 방법에 영향을주는 &lt;code&gt;SSLSessionContext&lt;/code&gt; 매개 변수 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba07541dea0c364ec56d1886e075be191732b860" translate="yes" xml:space="preserve">
          <source>There are a couple of things to notice in this code:</source>
          <target state="translated">There are a couple of things to notice in this code:</target>
        </trans-unit>
        <trans-unit id="368828561f4d9578233a778592c44861ba54cf6a" translate="yes" xml:space="preserve">
          <source>There are a number of classes and interfaces in this package which are designed to ease the implementation of the SPI to customize the behavior of a compiler:</source>
          <target state="translated">이 패키지에는 SPI의 구현을 용이하게하여 컴파일러의 동작을 사용자 정의하도록 설계된 많은 클래스와 인터페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="789da43f79f8e944dda13f428ba88942656ee3f5" translate="yes" xml:space="preserve">
          <source>There are a number of implementation choices in implementing a spliterator, nearly all of which are tradeoffs between simplicity of implementation and runtime performance of streams using that spliterator. The simplest, but least performant, way to create a spliterator is to create one from an iterator using &lt;a href=&quot;../spliterators#spliteratorUnknownSize(java.util.Iterator,int)&quot;&gt;&lt;code&gt;Spliterators.spliteratorUnknownSize(java.util.Iterator, int)&lt;/code&gt;&lt;/a&gt;. While such a spliterator will work, it will likely offer poor parallel performance, since we have lost sizing information (how big is the underlying data set), as well as being constrained to a simplistic splitting algorithm.</source>
          <target state="translated">There are a number of implementation choices in implementing a spliterator, nearly all of which are tradeoffs between simplicity of implementation and runtime performance of streams using that spliterator. The simplest, but least performant, way to create a spliterator is to create one from an iterator using &lt;a href=&quot;../spliterators#spliteratorUnknownSize(java.util.Iterator,int)&quot;&gt; &lt;code&gt;Spliterators.spliteratorUnknownSize(java.util.Iterator, int)&lt;/code&gt; &lt;/a&gt;. While such a spliterator will work, it will likely offer poor parallel performance, since we have lost sizing information (how big is the underlying data set), as well as being constrained to a simplistic splitting algorithm.</target>
        </trans-unit>
        <trans-unit id="ef8f158deb14b7be2cf0d4efa8baefda6a71922f" translate="yes" xml:space="preserve">
          <source>There are a number of implementation choices in implementing a spliterator, nearly all of which are tradeoffs between simplicity of implementation and runtime performance of streams using that spliterator. The simplest, but least performant, way to create a spliterator is to create one from an iterator using &lt;a href=&quot;../spliterators#spliteratorUnknownSize-java.util.Iterator-int-&quot;&gt;&lt;code&gt;Spliterators.spliteratorUnknownSize(java.util.Iterator, int)&lt;/code&gt;&lt;/a&gt;. While such a spliterator will work, it will likely offer poor parallel performance, since we have lost sizing information (how big is the underlying data set), as well as being constrained to a simplistic splitting algorithm.</source>
          <target state="translated">스플리터를 구현할 때 여러 가지 구현 선택 사항이 있으며, 그 대부분은 구현의 단순성과 해당 스플리터를 사용하는 스트림의 런타임 성능 간의 절충점입니다. 스플리터를 만드는 가장 단순하지만 성능이 가장 낮은 방법은 &lt;a href=&quot;../spliterators#spliteratorUnknownSize-java.util.Iterator-int-&quot;&gt; &lt;code&gt;Spliterators.spliteratorUnknownSize(java.util.Iterator, int)&lt;/code&gt; &lt;/a&gt; 사용하여 이터레이터에서 하나를 만드는 것입니다. . 이러한 스플리터는 작동하지만 사이징 정보 (기본 데이터 세트의 크기)가 손실되고 단순한 스 플리 팅 알고리즘으로 제한되어 있기 때문에 병렬 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a48b716f28d61331736d2cc5791d878c15965b6" translate="yes" xml:space="preserve">
          <source>There are a number of popular technologies available for creating an XML schema. Some of the most popular ones include:</source>
          <target state="translated">There are a number of popular technologies available for creating an XML schema. Some of the most popular ones include:</target>
        </trans-unit>
        <trans-unit id="9d878f03d7f9c2dbc33d5fa733c11fe1634d11ad" translate="yes" xml:space="preserve">
          <source>There are a set of &quot;log&quot; methods that take a log level, a message string, and optionally some parameters to the message string.</source>
          <target state="translated">로그 레벨, 메시지 문자열 및 선택적으로 메시지 문자열에 대한 일부 매개 변수를 취하는 &quot;log&quot;메소드 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f67ebc693e84bdf0873eac0e73efeaa82c19a53" translate="yes" xml:space="preserve">
          <source>There are a set of &quot;logp&quot; methods (for &quot;log precise&quot;) that are like the &quot;log&quot; methods, but also take an explicit source class name and method name.</source>
          <target state="translated">&quot;log&quot;메소드와 유사한 &quot;logp&quot;메소드 세트 ( &quot;정확한 로그&quot;)가 있지만 명시적인 소스 클래스 이름 및 메소드 이름도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="15b0598156ef25c63a8ccf779a6fbebb01022f73" translate="yes" xml:space="preserve">
          <source>There are a set of &quot;logrb&quot; method (for &quot;log with resource bundle&quot;) that are like the &quot;logp&quot; method, but also take an explicit resource bundle object for use in localizing the log message.</source>
          <target state="translated">&quot;logp&quot;메소드와 유사한 &quot;logrb&quot;메소드 세트 ( &quot;자원 번들이있는 로그&quot;)가 있지만 로그 메시지를 지역화하는 데 사용할 명시 적 자원 번들 오브젝트도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3f937ce785a3bb7dfa8db17d663a42dbcf532f75" translate="yes" xml:space="preserve">
          <source>There are a variety of interactions depending on the current platform such as displaying progress of some task, appending user-specified menu to the application icon context menu, etc.</source>
          <target state="translated">There are a variety of interactions depending on the current platform such as displaying progress of some task, appending user-specified menu to the application icon context menu, etc.</target>
        </trans-unit>
        <trans-unit id="8342705b4ecbd7ef35248ece786679b644377bc2" translate="yes" xml:space="preserve">
          <source>There are adapters available to convert a SAX1 Parser to a SAX2 XMLReader and vice-versa.</source>
          <target state="translated">There are adapters available to convert a SAX1 Parser to a SAX2 XMLReader and vice-versa.</target>
        </trans-unit>
        <trans-unit id="198896f4bb32a48314969671e1a0bed9b57f85c9" translate="yes" xml:space="preserve">
          <source>There are additional derived function shapes which extend the basic function shapes, including &lt;a href=&quot;unaryoperator&quot;&gt;&lt;code&gt;UnaryOperator&lt;/code&gt;&lt;/a&gt; (extends &lt;code&gt;Function&lt;/code&gt;) and &lt;a href=&quot;binaryoperator&quot;&gt;&lt;code&gt;BinaryOperator&lt;/code&gt;&lt;/a&gt; (extends &lt;code&gt;BiFunction&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;unaryoperator&quot;&gt; &lt;code&gt;UnaryOperator&lt;/code&gt; &lt;/a&gt; (extends &lt;code&gt;Function&lt;/code&gt; ) 및 &lt;a href=&quot;binaryoperator&quot;&gt; &lt;code&gt;BinaryOperator&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;BiFunction&lt;/code&gt; 확장 )를 포함하여 기본 함수 모양을 확장하는 추가 파생 함수 모양이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da12f2c258a3714932bec19ffbde602032cd7a0d" translate="yes" xml:space="preserve">
          <source>There are also times where you don't know a priori which permissions to check the context against. In these cases you can use the doPrivileged method that takes a context. You can also limit the scope of the privileged code by passing additional &lt;code&gt;Permission&lt;/code&gt; parameters.</source>
          <target state="translated">컨텍스트를 확인할 권한을 사전에 모르는 경우도 있습니다. 이 경우 컨텍스트를 취하는 doPrivileged 메소드를 사용할 수 있습니다. 추가 &lt;code&gt;Permission&lt;/code&gt; 매개 변수 를 전달하여 권한있는 코드의 범위를 제한 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ad81b6256410272632fc61cc04e04833c122dd8" translate="yes" xml:space="preserve">
          <source>There are cases, however, when applications need to use prefixes in character data or in attribute values, where they cannot safely be expanded automatically; the start/endPrefixMapping event supplies the information to the application to expand prefixes in those contexts itself, if necessary.</source>
          <target state="translated">There are cases, however, when applications need to use prefixes in character data or in attribute values, where they cannot safely be expanded automatically; the start/endPrefixMapping event supplies the information to the application to expand prefixes in those contexts itself, if necessary.</target>
        </trans-unit>
        <trans-unit id="a3fe717a4310bd251c07830ac0f0685c5d479c19" translate="yes" xml:space="preserve">
          <source>There are certain methods in which the name must resolve to a context (for example, when searching a single level context). The documentation of such methods use the term &lt;em&gt;named context&lt;/em&gt; to describe their name parameter. For these methods, if the named object is not a DirContext, &lt;code&gt;NotContextException&lt;/code&gt; is thrown. Aside from these methods, there is no requirement that the &lt;em&gt;named object&lt;/em&gt; be a DirContext.</source>
          <target state="translated">이름이 컨텍스트로 해석되어야하는 특정 방법이 있습니다 (예 : 단일 레벨 컨텍스트를 검색 할 때). 이러한 메소드의 문서에서는 &lt;em&gt;이름이 지정된 context라는&lt;/em&gt; 용어를 사용하여 이름 매개 변수를 설명합니다. 이러한 메소드의 경우, 이름 지정된 오브젝트가 DirContext가 아닌 경우 &lt;code&gt;NotContextException&lt;/code&gt; 이 발생합니다. 이러한 메소드 외에, &lt;em&gt;명명 된 객체&lt;/em&gt; 가 DirContext 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="94b019709222f6854929818bf02c4b3e4fa68677" translate="yes" xml:space="preserve">
          <source>There are convenience methods for tracing method entries (the &quot;entering&quot; methods), method returns (the &quot;exiting&quot; methods) and throwing exceptions (the &quot;throwing&quot; methods).</source>
          <target state="translated">메소드 항목 추적 ( &quot;enter&quot;메소드), 메소드 리턴 ( &quot;exiting&quot;메소드) 및 예외 발생 ( &quot;throwing&quot;메소드)에 대한 편리한 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="618db28d57aed6ef38b8a1dbeb663ce327ce97c2" translate="yes" xml:space="preserve">
          <source>There are currently, as of 2013, two segments in the Java time-scale.</source>
          <target state="translated">현재 2013 년 현재 Java 시간 규모에는 두 개의 세그먼트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69e5a8ce5effcab765b8137f9fe4d6de4c52414d" translate="yes" xml:space="preserve">
          <source>There are eight ways to export remote objects:</source>
          <target state="translated">There are eight ways to export remote objects:</target>
        </trans-unit>
        <trans-unit id="dc705dd39680a046181dbb1861c4932a0e3881d7" translate="yes" xml:space="preserve">
          <source>There are five distinct phases to an &lt;code&gt;SSLEngine&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 에는 5 가지 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0a4f63088373d76505ee3e5710b2bb4d1a2d15" translate="yes" xml:space="preserve">
          <source>There are five kinds of printing attributes: doc attributes, print request attributes, print job attributes, print service attributes, and supported-values attributes.</source>
          <target state="translated">인쇄 속성에는 문서 속성, 인쇄 요청 속성, 인쇄 작업 속성, 인쇄 서비스 속성 및 지원되는 값 속성의 5 가지 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3074d45ed46a8a3d42300fcfe8ebb5db5bf3aa93" translate="yes" xml:space="preserve">
          <source>There are four different orientations used in modern languages as in the following table.</source>
          <target state="translated">There are four different orientations used in modern languages as in the following table.</target>
        </trans-unit>
        <trans-unit id="cad932612288aaada09723e6430aa6935c07b669" translate="yes" xml:space="preserve">
          <source>There are four main target uses of the logs:</source>
          <target state="translated">로그는 다음과 같은 네 가지 주요 대상 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3229708e8f565466bb07ef07847c54b18ae5a8fb" translate="yes" xml:space="preserve">
          <source>There are four possible types of icons: 16 x 16 color, 32 x 32 color, 16 x 16 mono, and 32 x 32 mono. If you implement a bean so that it supports a single icon, it is recommended to use 16 x 16 color. Another recommendation is to set a transparent background for the icons.</source>
          <target state="translated">16 x 16 컬러, 32 x 32 컬러, 16 x 16 모노 및 32 x 32 모노의 네 가지 아이콘 유형이 있습니다. 단일 아이콘을 지원하도록 Bean을 구현하는 경우 16 x 16 색상을 사용하는 것이 좋습니다. 다른 권장 사항은 아이콘의 투명한 배경을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="98c7cab3315e49a24f27fa42a75adda139b73fd1" translate="yes" xml:space="preserve">
          <source>There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to &lt;code&gt;collect()&lt;/code&gt;. For example, the following will accumulate strings into an &lt;code&gt;ArrayList&lt;/code&gt;:</source>
          <target state="translated">JDK에는 서명이 &lt;code&gt;collect()&lt;/code&gt; 인수로 메소드 참조와 함께 사용하기에 적합한 기존 클래스가 많이 있습니다 . 예를 들어, 다음은 문자열을 &lt;code&gt;ArrayList&lt;/code&gt; 에 누적합니다 .</target>
        </trans-unit>
        <trans-unit id="6c8289dd97666af301b4b43ef1d06a9b97088c1a" translate="yes" xml:space="preserve">
          <source>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of &lt;code&gt;toConcurrentMap&lt;/code&gt; simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of &lt;code&gt;Person&lt;/code&gt;, and you want to produce a &quot;phone book&quot; mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a &lt;code&gt;ConcurrentMap&lt;/code&gt; mapping names to a concatenated list of addresses:</source>
          <target state="translated">동일한 키에 매핑되는 여러 요소 간의 충돌을 처리하는 방법에는 여러 가지가 있습니다. 다른 형태의 &lt;code&gt;toConcurrentMap&lt;/code&gt; 은 단순히 무조건 던지는 병합 함수를 사용하지만보다 유연한 병합 정책을 쉽게 작성할 수 있습니다. 예를 들어, &lt;code&gt;Person&lt;/code&gt; 스트림이 있고 주소에 &quot;전화 번호부&quot;매핑 이름을 생성하고 싶지만 두 사람이 같은 이름을 가질 수있는 경우 다음과 같이 이러한 충돌을 정상적으로 처리 할 수 ​​있습니다. 연결된 주소 목록에 &lt;code&gt;ConcurrentMap&lt;/code&gt; 매핑 이름을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="50c2a67a49e9e5ccc44a9144a8b2fa11e175cf65" translate="yes" xml:space="preserve">
          <source>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of &lt;code&gt;toConcurrentMap&lt;/code&gt; simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of &lt;code&gt;Person&lt;/code&gt;, and you want to produce a &quot;phone book&quot; mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deals with these collisions, and produce a &lt;code&gt;Map&lt;/code&gt; mapping names to a concatenated list of addresses:</source>
          <target state="translated">동일한 키에 매핑 된 여러 요소 간의 충돌을 처리하는 방법에는 여러 가지가 있습니다. &lt;code&gt;toConcurrentMap&lt;/code&gt; 의 다른 형식은 무조건 던지는 병합 함수를 사용하지만보다 유연한 병합 정책을 쉽게 작성할 수 있습니다. 예를 들어 &lt;code&gt;Person&lt;/code&gt; 스트림이 있고 주소로 &quot;전화 번호부&quot;매핑 이름을 생성하려고하지만 두 사람이 같은 이름을 가질 수있는 경우 이러한 충돌을 정상적으로 처리하기 위해 다음과 같이 할 수 있습니다. 연결된 주소 목록에 대한 &lt;code&gt;Map&lt;/code&gt; 매핑 이름을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="c1aa27dde80e55b2bf98bf31198222073cec87e8" translate="yes" xml:space="preserve">
          <source>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of &lt;code&gt;toMap&lt;/code&gt; simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of &lt;code&gt;Person&lt;/code&gt;, and you want to produce a &quot;phone book&quot; mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a &lt;code&gt;Map&lt;/code&gt; mapping names to a concatenated list of addresses:</source>
          <target state="translated">동일한 키에 매핑되는 여러 요소 간의 충돌을 처리하는 방법에는 여러 가지가 있습니다. 다른 형태의 &lt;code&gt;toMap&lt;/code&gt; 은 단순히 무조건 던지는 병합 함수를 사용하지만보다 유연한 병합 정책을 쉽게 작성할 수 있습니다. 예를 들어, &lt;code&gt;Person&lt;/code&gt; 스트림이 있고 주소에 &quot;전화 번호부&quot;매핑 이름을 생성하고 싶지만 두 사람이 같은 이름을 가질 수있는 경우 다음과 같이 이러한 충돌을 정상적으로 처리 할 수 ​​있습니다. 과 생산 &lt;code&gt;Map&lt;/code&gt; 주소 연결된 목록에 매핑 이름 :</target>
        </trans-unit>
        <trans-unit id="d570df6b0a511d807488f697e8fff67205fb8ca7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of &lt;code&gt;toMap&lt;/code&gt; simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of &lt;code&gt;Person&lt;/code&gt;, and you want to produce a &quot;phone book&quot; mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deals with these collisions, and produce a &lt;code&gt;Map&lt;/code&gt; mapping names to a concatenated list of addresses:</source>
          <target state="translated">동일한 키에 매핑 된 여러 요소 간의 충돌을 처리하는 방법에는 여러 가지가 있습니다. 다른 형태의 &lt;code&gt;toMap&lt;/code&gt; 은 무조건 던지는 병합 함수를 사용하지만보다 유연한 병합 정책을 쉽게 작성할 수 있습니다. 예를 들어 &lt;code&gt;Person&lt;/code&gt; 스트림이 있고 주소로 &quot;전화 번호부&quot;매핑 이름을 생성하려고하지만 두 사람이 같은 이름을 가질 수있는 경우 이러한 충돌을 정상적으로 처리하기 위해 다음과 같이 할 수 있습니다. 연결된 주소 목록에 대한 &lt;code&gt;Map&lt;/code&gt; 매핑 이름을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="4a26e68d8323da83a3aa42c70d8de93ca6b801fe" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get a character set mapping to happen with &lt;code&gt;JEditorPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JEditorPane&lt;/code&gt; 에서 발생하는 문자 집합 매핑을 얻는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49355ea4a7f0de6774fce9fba4ed5392d62aa873" translate="yes" xml:space="preserve">
          <source>There are nine predefined &lt;code&gt;Class&lt;/code&gt; objects to represent the eight primitive types and void. These are created by the Java Virtual Machine, and have the same names as the primitive types that they represent, namely &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">8 가지 기본 유형과 void를 나타내는 9 개의 사전 정의 된 &lt;code&gt;Class&lt;/code&gt; 객체가 있습니다. 이것들은 Java Virtual Machine에 의해 만들어지며, 그것들이 나타내는 기본 타입과 같은 이름, 즉 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52dc29f92c1eac2b7d037b3580f08c6d5a292dc7" translate="yes" xml:space="preserve">
          <source>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. For example, typical implementations will cancel via &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;&lt;code&gt;Thread.interrupt()&lt;/code&gt;&lt;/a&gt;, so any task that fails to respond to interrupts may never terminate.</source>
          <target state="translated">적극적으로 실행중인 작업의 처리를 중지하려는 최선의 시도 이상의 보장은 없습니다. 예를 들어, 일반적인 구현은 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt; &lt;code&gt;Thread.interrupt()&lt;/code&gt; &lt;/a&gt; 를 통해 취소 되므로 인터럽트에 응답하지 않는 작업은 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5073f2e7c4323e6ba19e16f32d668e2082db861a" translate="yes" xml:space="preserve">
          <source>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. For example, typical implementations will cancel via &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;Thread.interrupt()&lt;/code&gt;&lt;/a&gt;, so any task that fails to respond to interrupts may never terminate.</source>
          <target state="translated">적극적으로 실행중인 작업 처리를 중지하려는 최선의 노력 외에는 보장 할 수 없습니다. 예를 들어 일반적인 구현은 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;Thread.interrupt()&lt;/code&gt; &lt;/a&gt; 를 통해 취소 되므로 인터럽트에 응답하지 않는 모든 작업은 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f38732315c805219d239e42cbc8fc17be7b03f5" translate="yes" xml:space="preserve">
          <source>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation cancels tasks via &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;Thread.interrupt()&lt;/code&gt;&lt;/a&gt;, so any task that fails to respond to interrupts may never terminate.</source>
          <target state="translated">적극적으로 실행중인 작업 처리를 중지하려는 최선의 노력 외에는 보장 할 수 없습니다. 이 구현은 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;Thread.interrupt()&lt;/code&gt; &lt;/a&gt; 를 통해 작업을 취소 하므로 인터럽트에 응답하지 않는 작업은 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9e7f533a1a283b4006daee725e1916b5e57352" translate="yes" xml:space="preserve">
          <source>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation interrupts tasks via &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;&lt;code&gt;Thread.interrupt()&lt;/code&gt;&lt;/a&gt;; any task that fails to respond to interrupts may never terminate.</source>
          <target state="translated">적극적으로 실행중인 작업의 처리를 중지하려는 최선의 시도 이상의 보장은 없습니다. 이 구현은 &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt; &lt;code&gt;Thread.interrupt()&lt;/code&gt; &lt;/a&gt; 를 통해 작업을 중단합니다 . 인터럽트에 응답하지 않는 작업은 절대로 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9431ed708548e238ef515ee1cc518fdf2c9717e" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, or serializability of the &lt;code&gt;ConcurrentMap&lt;/code&gt; or &lt;code&gt;List&lt;/code&gt; objects returned, or of the thread-safety of the &lt;code&gt;List&lt;/code&gt; objects returned.</source>
          <target state="translated">거기의 종류, 가변성, 또는 직렬화에 대한 보장하지 않습니다 &lt;code&gt;ConcurrentMap&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 반환되는 객체는, 또는의 스레드 안전성의 &lt;code&gt;List&lt;/code&gt; 반환 객체.</target>
        </trans-unit>
        <trans-unit id="0c59bce881980b812857f878712f5790533cee11" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, or serializability of the &lt;code&gt;ConcurrentMap&lt;/code&gt; returned.</source>
          <target state="translated">반환 된 &lt;code&gt;ConcurrentMap&lt;/code&gt; 의 유형, 변경 가능성 또는 직렬화 가능성에 대한 보장이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c152317dbceb46ecf06e80209421468af5e327b5" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, or serializability of the &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;List&lt;/code&gt; objects returned, or of the thread-safety of the &lt;code&gt;List&lt;/code&gt; objects returned.</source>
          <target state="translated">거기의 종류, 가변성, 또는 직렬화에 대한 보장없는 &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 반환되는 객체는, 또는의 스레드 안전성의 &lt;code&gt;List&lt;/code&gt; 반환 객체.</target>
        </trans-unit>
        <trans-unit id="bb964f47cb21418a605ea5141958b9590922fa27" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, serializability, or thread-safety of the &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;List&lt;/code&gt; objects returned.</source>
          <target state="translated">반환 된 &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 객체 의 유형, 변경 가능성, 직렬화 가능성 또는 스레드 안전성에 대한 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9cea59dafa3fd974f0fd6fa4fbe89e4cbe017d69" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, serializability, or thread-safety of the &lt;code&gt;Map&lt;/code&gt; returned.</source>
          <target state="translated">리턴 된 &lt;code&gt;Map&lt;/code&gt; 의 유형, 변경 가능성, 직렬화 가능성 또는 스레드 안전성에 대한 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1b67b3f63cb8b0663e32aff4b81efd7144d13836" translate="yes" xml:space="preserve">
          <source>There are no modeling restrictions on what the agent &lt;code&gt;premain&lt;/code&gt; method may do. Anything application &lt;code&gt;main&lt;/code&gt; can do, including creating threads, is legal from &lt;code&gt;premain&lt;/code&gt;.</source>
          <target state="translated">에이전트 &lt;code&gt;premain&lt;/code&gt; 메서드가 수행 할 수있는 작업 에는 모델링 제한이 없습니다 . 스레드 생성을 포함하여 애플리케이션 &lt;code&gt;main&lt;/code&gt; 할 수있는 모든 작업은 &lt;code&gt;premain&lt;/code&gt; 에서 합법적입니다 .</target>
        </trans-unit>
        <trans-unit id="3af5183ddfe22ad90f82d0d2dcd147ae509134d5" translate="yes" xml:space="preserve">
          <source>There are no more results when the following is true:</source>
          <target state="translated">다음이 참이면 더 이상 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="48317d12afba8c65510a05ff0506a5d0b8e6169e" translate="yes" xml:space="preserve">
          <source>There are no public constructors for &lt;code&gt;Group&lt;/code&gt;s; instead use the create methods of &lt;code&gt;GroupLayout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Group&lt;/code&gt; 에 대한 공용 생성자는 없습니다 . 대신 &lt;code&gt;GroupLayout&lt;/code&gt; 의 생성 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="11eaa1b9730ffafb16c98ceedb286b10423b443b" translate="yes" xml:space="preserve">
          <source>There are no restrictions on the usage of the pseudo/hidden columns.</source>
          <target state="translated">의사 / 숨겨진 열의 사용에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f86a858cb19185fc92cb0a1478447942a9e681e" translate="yes" xml:space="preserve">
          <source>There are occasions when a &lt;code&gt;RowSet&lt;/code&gt; object has a need to provide a degree of filtering to its contents. One possible solution is to provide a query language for all standard &lt;code&gt;RowSet&lt;/code&gt; implementations; however, this is an impractical approach for lightweight components such as disconnected &lt;code&gt;RowSet&lt;/code&gt; objects. The &lt;code&gt;FilteredRowSet&lt;/code&gt; interface seeks to address this need without supplying a heavyweight query language along with the processing that such a query language would require.</source>
          <target state="translated">하는 경우가 있습니다 &lt;code&gt;RowSet&lt;/code&gt; 객체가 내용을 필터링의 정도를 제공 할 필요가있다. 한 가지 가능한 솔루션은 모든 표준 &lt;code&gt;RowSet&lt;/code&gt; 구현에 대한 쿼리 언어를 제공하는 것입니다. 그러나 이것은 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체 와 같은 경량 구성 요소에 대한 비실용적 접근 방식입니다 . &lt;code&gt;FilteredRowSet&lt;/code&gt; 인터페이스는 이러한 쿼리 언어가 필요로하는 처리와 함께 헤비급 쿼리 언어를 제공하지 않고 이러한 요구를 해결하기 위해 노력한다.</target>
        </trans-unit>
        <trans-unit id="fb1f2720f5e4869f1d5aa33e3942c41021d10b1b" translate="yes" xml:space="preserve">
          <source>There are several basic function shapes, including &lt;a href=&quot;function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;), &lt;a href=&quot;consumer&quot;&gt;&lt;code&gt;Consumer&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;predicate&quot;&gt;&lt;code&gt;Predicate&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;), and &lt;a href=&quot;supplier&quot;&gt;&lt;code&gt;Supplier&lt;/code&gt;&lt;/a&gt; (nilary function to &lt;code&gt;R&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 단항 함수 ), &lt;a href=&quot;consumer&quot;&gt; &lt;code&gt;Consumer&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;void&lt;/code&gt; 로의 단항 함수 ), &lt;a href=&quot;predicate&quot;&gt; &lt;code&gt;Predicate&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;boolean&lt;/code&gt; 까지의 단항 함수 ) 및 &lt;a href=&quot;supplier&quot;&gt; &lt;code&gt;Supplier&lt;/code&gt; &lt;/a&gt; (일부 함수는 &lt;code&gt;R&lt;/code&gt; ) 를 포함하여 몇 가지 기본 함수 모양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a63d5f151634cfa4901bd743c74eb6cb121b4d4" translate="yes" xml:space="preserve">
          <source>There are several basic function shapes, including &lt;a href=&quot;function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;), &lt;a href=&quot;consumer&quot;&gt;&lt;code&gt;Consumer&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;predicate&quot;&gt;&lt;code&gt;Predicate&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;), and &lt;a href=&quot;supplier&quot;&gt;&lt;code&gt;Supplier&lt;/code&gt;&lt;/a&gt; (nullary function to &lt;code&gt;R&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 단항 함수 ), &lt;a href=&quot;consumer&quot;&gt; &lt;code&gt;Consumer&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;void&lt;/code&gt; 로의 단항 함수 ), &lt;a href=&quot;predicate&quot;&gt; &lt;code&gt;Predicate&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;boolean&lt;/code&gt; 으로의 단항 함수 ) 및 &lt;a href=&quot;supplier&quot;&gt; &lt;code&gt;Supplier&lt;/code&gt; &lt;/a&gt; (Nullary 함수에서 &lt;code&gt;R&lt;/code&gt; 로 ) 등 몇 가지 기본 함수 모양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2da96ddea93cc96c7a3493bc185e3b88403db18" translate="yes" xml:space="preserve">
          <source>There are several compatibility concerns to keep in mind if an annotation type</source>
          <target state="translated">주석 유형 인 경우 명심해야 할 호환성 문제가 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6b76f15b787736c9401a42c8c4bb8a7e713611" translate="yes" xml:space="preserve">
          <source>There are several different ways to create a &lt;code&gt;Locale&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Locale&lt;/code&gt; 오브젝트 를 작성하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7060bfcb421675b4266cd9db4d3a9cd95d172c8" translate="yes" xml:space="preserve">
          <source>There are several goals of the HTML EditorKit provided, that have an effect upon the way that HTML is modeled. These have influenced its design in a substantial way.</source>
          <target state="translated">HTML이 모델링되는 방식에 영향을 미치는 HTML EditorKit의 몇 가지 목표가 있습니다. 이것들은 디자인에 상당한 영향을 미쳤습니다.</target>
        </trans-unit>
        <trans-unit id="9ad010658753417b64166337fccfa2064b4e7316" translate="yes" xml:space="preserve">
          <source>There are several reasons why an enabled cipher suite might not actually be used. For example: the server socket might not have appropriate private keys available to it or the cipher suite might be anonymous, precluding the use of client authentication, while the server socket has been told to require that sort of authentication.</source>
          <target state="translated">활성화 된 암호 제품군이 실제로 사용되지 않는 데는 몇 가지 이유가 있습니다. 예를 들어, 서버 소켓에 사용 가능한 적절한 개인 키가 없거나 암호 제품군이 익명 일 수 있으며 클라이언트 인증 사용을 제외하고 서버 소켓에 이러한 종류의 인증이 필요하다는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="06a988002378eef1c65c03ab8ae35ac92c999ee3" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the parameters that may be passed to &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 에 전달 될 수있는 매개 변수에는 몇 가지 제한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7849eb124160ec5f6f98e9369d9e1fccc3c10479" translate="yes" xml:space="preserve">
          <source>There are several types of complex buffer strategies, including sequential ring buffering and blit buffering. Sequential ring buffering (i.e., double or triple buffering) is the most common; an application draws to a single</source>
          <target state="translated">순차 링 버퍼링 및 블릿 버퍼링을 포함하여 여러 유형의 복잡한 버퍼 전략이 있습니다. 순차 링 버퍼링 (즉, 이중 또는 삼중 버퍼링)이 가장 일반적입니다. 응용 프로그램은 단일에 그립니다</target>
        </trans-unit>
        <trans-unit id="065674b7ad4255710f31cf384fdf0ef078f22e00" translate="yes" xml:space="preserve">
          <source>There are several ways to load content into this component.</source>
          <target state="translated">이 구성 요소에 콘텐츠를로드하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bab2a8d3e9688f6ae91f468c2fa96062036606d4" translate="yes" xml:space="preserve">
          <source>There are three different names that you can get from a &lt;code&gt;Font&lt;/code&gt; object. The &lt;em&gt;logical font name&lt;/em&gt; is simply the name that was used to construct the font. The &lt;em&gt;font face name&lt;/em&gt;, or just &lt;em&gt;font name&lt;/em&gt; for short, is the name of a particular font face, like Helvetica Bold. The &lt;em&gt;family name&lt;/em&gt; is the name of the font family that determines the typographic design across several faces, like Helvetica.</source>
          <target state="translated">&lt;code&gt;Font&lt;/code&gt; 개체 에서 얻을 수있는 세 가지 이름이 있습니다 . &lt;em&gt;논리 폰트 이름은&lt;/em&gt; 단순히 글꼴을 구성하는 데 사용 된 이름입니다. &lt;em&gt;폰트 페이스 명&lt;/em&gt; , 또는 단지 &lt;em&gt;폰트 이름&lt;/em&gt; 줄여서, Helvetica Bold 등의 특정의 폰트 명이다. &lt;em&gt;가족의 이름은&lt;/em&gt; 헬 베티, 복수의 페이스의 문자 체재의 디자인을 결정하는 폰트 패밀리의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3bd6f67a832bd215f4e92e1b7ec5044236848741" translate="yes" xml:space="preserve">
          <source>There are three general strategies for queuing:</source>
          <target state="translated">큐잉을위한 세 가지 일반적인 전략이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75f24f0c160cfac7adb08056cdce581127cc3e7" translate="yes" xml:space="preserve">
          <source>There are three kinds of Monitors:</source>
          <target state="translated">세 가지 종류의 모니터가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b0b5cd9acd8eb019e375df17f00020fb7070078d" translate="yes" xml:space="preserve">
          <source>There are three kinds of possible values: orientation relative, baseline relative and absolute. Orientation relative values are interpreted relative to the container's component orientation property, baseline relative values are interpreted relative to the baseline and absolute values are not. The absolute values are: &lt;code&gt;CENTER&lt;/code&gt;, &lt;code&gt;NORTH&lt;/code&gt;, &lt;code&gt;NORTHEAST&lt;/code&gt;, &lt;code&gt;EAST&lt;/code&gt;, &lt;code&gt;SOUTHEAST&lt;/code&gt;, &lt;code&gt;SOUTH&lt;/code&gt;, &lt;code&gt;SOUTHWEST&lt;/code&gt;, &lt;code&gt;WEST&lt;/code&gt;, and &lt;code&gt;NORTHWEST&lt;/code&gt;. The orientation relative values are: &lt;code&gt;PAGE_START&lt;/code&gt;, &lt;code&gt;PAGE_END&lt;/code&gt;, &lt;code&gt;LINE_START&lt;/code&gt;, &lt;code&gt;LINE_END&lt;/code&gt;, &lt;code&gt;FIRST_LINE_START&lt;/code&gt;, &lt;code&gt;FIRST_LINE_END&lt;/code&gt;, &lt;code&gt;LAST_LINE_START&lt;/code&gt; and &lt;code&gt;LAST_LINE_END&lt;/code&gt;. The baseline relative values are: &lt;code&gt;BASELINE&lt;/code&gt;, &lt;code&gt;BASELINE_LEADING&lt;/code&gt;, &lt;code&gt;BASELINE_TRAILING&lt;/code&gt;, &lt;code&gt;ABOVE_BASELINE&lt;/code&gt;, &lt;code&gt;ABOVE_BASELINE_LEADING&lt;/code&gt;, &lt;code&gt;ABOVE_BASELINE_TRAILING&lt;/code&gt;, &lt;code&gt;BELOW_BASELINE&lt;/code&gt;, &lt;code&gt;BELOW_BASELINE_LEADING&lt;/code&gt;, and &lt;code&gt;BELOW_BASELINE_TRAILING&lt;/code&gt;. The default value is &lt;code&gt;CENTER&lt;/code&gt;.</source>
          <target state="translated">가능한 값에는 방향 상대, 기준선 상대 및 절대의 세 가지 종류가 있습니다. 방향 상대 값은 컨테이너의 구성 요소 방향 속성을 기준으로 해석되고 기준선 상대 값은 기준선을 기준으로 해석되며 절대 값은 해석되지 않습니다. 절대 값은 &lt;code&gt;CENTER&lt;/code&gt; , &lt;code&gt;NORTH&lt;/code&gt; , &lt;code&gt;NORTHEAST&lt;/code&gt; , &lt;code&gt;EAST&lt;/code&gt; , &lt;code&gt;SOUTHEAST&lt;/code&gt; , &lt;code&gt;SOUTH&lt;/code&gt; , &lt;code&gt;SOUTHWEST&lt;/code&gt; , &lt;code&gt;WEST&lt;/code&gt; 및 &lt;code&gt;NORTHWEST&lt;/code&gt; 입니다. 방향 상대 값은 &lt;code&gt;PAGE_START&lt;/code&gt; , &lt;code&gt;PAGE_END&lt;/code&gt; , &lt;code&gt;LINE_START&lt;/code&gt; , &lt;code&gt;LINE_END&lt;/code&gt; , &lt;code&gt;FIRST_LINE_START&lt;/code&gt; , &lt;code&gt;FIRST_LINE_END&lt;/code&gt; , &lt;code&gt;LAST_LINE_START&lt;/code&gt; 및 &lt;code&gt;LAST_LINE_END&lt;/code&gt; . 기준 상대 값은 &lt;code&gt;BASELINE&lt;/code&gt; , &lt;code&gt;BASELINE_LEADING&lt;/code&gt; , &lt;code&gt;BASELINE_TRAILING&lt;/code&gt; , &lt;code&gt;ABOVE_BASELINE&lt;/code&gt; , &lt;code&gt;ABOVE_BASELINE_LEADING&lt;/code&gt; , &lt;code&gt;ABOVE_BASELINE_TRAILING&lt;/code&gt; , &lt;code&gt;BELOW_BASELINE&lt;/code&gt; , &lt;code&gt;BELOW_BASELINE_LEADING&lt;/code&gt; 및 &lt;code&gt;BELOW_BASELINE_TRAILING&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;CENTER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c25e15fc967b546c584ccdefa3b60e5531758f54" translate="yes" xml:space="preserve">
          <source>There are three main models for triggering a push of the buffer:</source>
          <target state="translated">버퍼 푸시를 트리거하기위한 세 가지 주요 모델이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b997529c7c84200f70fc10cb9c45ebe777ca580" translate="yes" xml:space="preserve">
          <source>There are three phases to the use of a Signature object for either signing data or verifying a signature:</source>
          <target state="translated">데이터 서명 또는 서명 확인을 위해 Signature 객체를 사용하는 데는 3 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="727bc37c42491a711f91a5d5785d8bca4a3a886a" translate="yes" xml:space="preserve">
          <source>There are three possible events for a &lt;code&gt;RowSet&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;RowSet&lt;/code&gt; 객체 에는 세 가지 가능한 이벤트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a114e0c5ecd87e992d3fcc0bb2519744081844d" translate="yes" xml:space="preserve">
          <source>There are three predefined modes that specify possible masters for a sequencer: &lt;code&gt;INTERNAL_CLOCK&lt;/code&gt;, &lt;code&gt;MIDI_SYNC&lt;/code&gt;, and &lt;code&gt;MIDI_TIME_CODE&lt;/code&gt;. The latter two work if the sequencer receives MIDI messages from another device. In these two modes, the sequencer's time gets reset based on system real-time timing clock messages or MIDI time code (MTC) messages, respectively. These two modes can also be used as slave modes, in which case the sequencer sends the corresponding types of MIDI messages to its receiver (whether or not the sequencer is also receiving them from a master). A fourth mode, &lt;code&gt;NO_SYNC&lt;/code&gt;, is used to indicate that the sequencer should not control its receiver's timing.</source>
          <target state="translated">시퀀서의 가능한 마스터를 지정하는 사전 정의 된 세 가지 모드가 있습니다 : &lt;code&gt;INTERNAL_CLOCK&lt;/code&gt; , &lt;code&gt;MIDI_SYNC&lt;/code&gt; 및 &lt;code&gt;MIDI_TIME_CODE&lt;/code&gt; . 후자는 시퀀서가 다른 장치에서 MIDI 메시지를 수신하면 작동합니다. 이 두 가지 모드에서 시퀀서의 시간은 각각 시스템 실시간 타이밍 클럭 메시지 또는 MIDI 타임 코드 (MTC) 메시지에 따라 재설정됩니다. 이 두 가지 모드는 슬레이브 모드로도 사용할 수 있습니다.이 경우 시퀀서는 해당 유형의 MIDI 메시지를 리시버로 보냅니다 (시퀀서도 마스터에서 수신하는지 여부). 네 번째 모드 인 &lt;code&gt;NO_SYNC&lt;/code&gt; 는 시퀀서가 수신기의 타이밍을 제어해서는 안됨을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06fc3adaa09a9dc4abdad7a4769f286bc1581a6a" translate="yes" xml:space="preserve">
          <source>There are three threads involved in the life cycle of a &lt;code&gt;SwingWorker&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;SwingWorker&lt;/code&gt; 의 수명주기에는 세 가지 스레드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9f4282a0141a82a2de17fffc9351d57e318a288" translate="yes" xml:space="preserve">
          <source>There are three ways in which connection request controls are set:</source>
          <target state="translated">연결 요청 제어는 세 가지 방법으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b25b98bbf1bed6a0ab1c73f9a3229fba6803ca" translate="yes" xml:space="preserve">
          <source>There are two basic models of what attributes should be associated with. First, attributes may be directly associated with a DirContext object. In this model, an attribute operation on the named object is roughly equivalent to a lookup on the name (which returns the DirContext object), followed by the attribute operation invoked on the DirContext object in which the caller supplies an empty name. The attributes can be viewed as being stored along with the object (note that this does not imply that the implementation must do so).</source>
          <target state="translated">어떤 속성을 연관시켜야하는지에 대한 두 가지 기본 모델이 있습니다. 먼저, 속성은 DirContext 객체와 직접 연관 될 수 있습니다. 이 모델에서, 명명 된 객체에 대한 속성 연산은 이름에 대한 조회 (DirContext 객체를 반환 함)와 거의 동일하며 호출자가 빈 이름을 제공하는 DirContext 객체에 대해 호출 된 속성 연산이 뒤 따릅니다. 속성은 객체와 함께 저장된 것으로 볼 수 있습니다 (이것은 구현이 그렇게해야 함을 의미하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="6277a3c91d311327a3eead7b7d8b16a596430d2c" translate="yes" xml:space="preserve">
          <source>There are two broad categories of print data, client formatted print data and service formatted print data.</source>
          <target state="translated">클라이언트 형식 인쇄 데이터와 서비스 형식 인쇄 데이터의 두 가지 범주의 인쇄 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e053f696696474cc554e2ee656c6df0dd65d2bd6" translate="yes" xml:space="preserve">
          <source>There are two common implementations. &lt;a href=&quot;../period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; is a date-based implementation, storing years, months and days. &lt;a href=&quot;../duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is a time-based implementation, storing seconds and nanoseconds, but providing some access using other duration based units such as minutes, hours and fixed 24-hour days.</source>
          <target state="translated">일반적인 두 가지 구현이 있습니다. &lt;a href=&quot;../period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 은 년, 월 및 일을 저장하는 날짜 기반 구현입니다. &lt;a href=&quot;../duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 은 초와 나노초를 저장하는 시간 기반 구현이지만 분, 시간 및 고정 24 시간과 같은 다른 지속 시간 기반 단위를 사용하여 일부 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ebfd465408d113172e53262f7239645338b176ec" translate="yes" xml:space="preserve">
          <source>There are two distinguished supported locations (subtrees within the logical file system) where newly created files are placed: one for &lt;a href=&quot;../../tools/standardlocation#SOURCE_OUTPUT&quot;&gt;new source files&lt;/a&gt;, and one for &lt;a href=&quot;../../tools/standardlocation#CLASS_OUTPUT&quot;&gt;new class files&lt;/a&gt;. (These might be specified on a tool's command line, for example, using flags such as &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt;.) The actual locations for new source files and new class files may or may not be distinct on a particular run of the tool. Resource files may be created in either location. The methods for reading and writing resources take a relative name argument. A relative name is a non-null, non-empty sequence of path segments separated by &lt;code&gt;'/'&lt;/code&gt;; &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; are invalid path segments. A valid relative name must match the &quot;path-rootless&quot; rule of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;, section 3.3.</source>
          <target state="translated">새로 작성된 파일이 배치되는 두 가지 구별되는 지원 위치 (논리 파일 시스템 내의 서브 트리)가 있습니다. 하나는 &lt;a href=&quot;../../tools/standardlocation#SOURCE_OUTPUT&quot;&gt;새 소스 파일&lt;/a&gt; 용이고 다른 하나는 &lt;a href=&quot;../../tools/standardlocation#CLASS_OUTPUT&quot;&gt;새 클래스 파일 용&lt;/a&gt; 입니다. (예를 들어, &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-d&lt;/code&gt; 와 같은 플래그를 사용하여 도구의 명령 행에 지정할 수 있습니다 .) 새 소스 파일 및 새 클래스 파일의 실제 위치는 특정 도구 실행에서 구별되거나 구분되지 않을 수 있습니다. 리소스 파일은 어느 위치 에나 생성 될 수 있습니다. 리소스를 읽고 쓰는 방법에는 상대적인 이름 인수가 사용됩니다. 상대 이름은 &lt;code&gt;'/'&lt;/code&gt; 로 구분 된 null이 아닌 비어 있지 않은 경로 세그먼트 시퀀스입니다 . &lt;code&gt;'.'&lt;/code&gt; 과 &lt;code&gt;'..'&lt;/code&gt; 유효하지 않은 경로 세그먼트입니다. 유효한 상대 이름은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; 의 &quot;경로 루트없는&quot;규칙 , 섹션 3.3 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d63c8b5fdaabf726c4340f0c67e85e581f64ce1a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalAdjuster&lt;/code&gt;. The first is to invoke the method on the interface directly. The second is to use &lt;a href=&quot;temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는 인터페이스에서 직접 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="72119fc16750a087fcef97d6993f73e9c9d8b934" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalAdjuster&lt;/code&gt;. The first is to invoke the method on the interface directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 사용하는 동등한 방법이 두 가지 있습니다. 첫 번째는 인터페이스에서 직접 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c33eab314554bc07e34728c7b5c68f5a205347ba" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalAdjuster&lt;/code&gt;. The first is to invoke the method on this interface directly. The second is to use &lt;a href=&quot;temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 인터페이스에서 직접 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="122c9761aea7bb48c6b202253cc10ffaf3858a78" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalAdjuster&lt;/code&gt;. The first is to invoke the method on this interface directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 사용하는 동등한 방법이 두 가지 있습니다. 첫 번째는이 인터페이스에서 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c9cf902b16106608a1ec02f9c62ad6970669fa9a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalQuery&lt;/code&gt;. The first is to invoke the method on this interface directly. The second is to use &lt;a href=&quot;temporalaccessor#query(java.time.temporal.TemporalQuery)&quot;&gt;&lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalQuery&lt;/code&gt; 를 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 인터페이스에서 직접 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#query(java.time.temporal.TemporalQuery)&quot;&gt; &lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="221c7636be87b0733017baa83864b434059c108b" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalQuery&lt;/code&gt;. The first is to invoke the method on this interface directly. The second is to use &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt;&lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalQuery&lt;/code&gt; 를 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 인터페이스에서 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt; &lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="28a74aa077d1efbd4dc327f7482aa6c4fdf7ca7d" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4f6ddab868b4d8af37cbc5e13d59377eb7bc1e1b" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e233a0092aeb3207a767441e598623c26eda0016" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3912c8fc49848c13654d6a3b29033b645f8eab63" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;Temporal.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;Temporal.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9f36371a08c9e03929b3d371a732fe25c15a1a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="19622de3e1de5aa717583d3f58905f5525534b2a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;Temporal.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;Temporal.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf8faaa49b113ace9e8d9f3f14fb0866233d417" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#until(java.time.temporal.Temporal,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;Temporal.until(Temporal, TemporalUnit)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#until(java.time.temporal.Temporal,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;Temporal.until(Temporal, TemporalUnit)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc7049dde645017bc74c4cfbcd545b88a0f9312c" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#until-java.time.temporal.Temporal-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;Temporal.until(Temporal, TemporalUnit)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#until-java.time.temporal.Temporal-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;Temporal.until(Temporal, TemporalUnit)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="085d9b02cf26b7e6f7c300c589e8f64694fdb61d" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9a0eb55a617a2c0898ebdaf88068239d76f9dcdc" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14641be0ebbb10666cf02dfef66e60e2e24f19de" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="23c7abacd277c7c67a02cfdac67f8ec2ddb1e2a7" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f050118cb156fd672c72e9416109da76aa7bc843" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#getLong(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;TemporalAccessor.getLong(TemporalField)&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;temporalaccessor#get(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;TemporalAccessor.get(TemporalField)&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#getLong(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;TemporalAccessor.getLong(TemporalField)&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;temporalaccessor#get(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;TemporalAccessor.get(TemporalField)&lt;/code&gt; &lt;/a&gt; )를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d131f4265fdeb909d228a96a8cfb3506d44f7ffe" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#getLong-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.getLong(TemporalField)&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.get(TemporalField)&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#getLong-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.getLong(TemporalField)&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.get(TemporalField)&lt;/code&gt; &lt;/a&gt; )를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="718e19b86f1c018be2151c92c4d105c8f339ffb5" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;TemporalAccessor.isSupported(TemporalField)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;TemporalAccessor.isSupported(TemporalField)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="69e761971c5e4cae8513f296453b2fac6111a7fc" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.isSupported(TemporalField)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.isSupported(TemporalField)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="71169b1735c1b9aa5050cda8d9ec6f930958721b" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#query(java.time.temporal.TemporalQuery)&quot;&gt;&lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#query(java.time.temporal.TemporalQuery)&quot;&gt; &lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="7a30794131e2de9a5dbaf4c9a1f6157f885e685a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt;&lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt; &lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ec76f64ef6ab13faacb8097462f1b044aecfde13" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#range(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;TemporalAccessor.range(TemporalField)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#range(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;TemporalAccessor.range(TemporalField)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b82d66ee70b01eb4f8a3cda3c1d15d8275ac3e27" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.range(TemporalField)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.range(TemporalField)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="dff5d0eaca16b70485b61e851f9043fbb98d46b2" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalunit#between(java.time.temporal.Temporal,java.time.temporal.Temporal)&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalunit#between(java.time.temporal.Temporal,java.time.temporal.Temporal)&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f81056ea2c2becde1c2107f4139e24e0e6b5fd30" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="267ab52c267ee1476943eb4633898b3fdbd746d6" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;../temporal/temporalunit#between(java.time.temporal.Temporal,java.time.temporal.Temporal)&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;../temporal/temporalunit#between(java.time.temporal.Temporal,java.time.temporal.Temporal)&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01700b17f3c068ac68e900641c6f6a6834b85ea7" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;../temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;../temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d8f7a23531eed743941483834a3922f9197390" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;period#between(java.time.LocalDate,java.time.LocalDate)&quot;&gt;&lt;code&gt;Period.between(LocalDate, LocalDate)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;period#between(java.time.LocalDate,java.time.LocalDate)&quot;&gt; &lt;code&gt;Period.between(LocalDate, LocalDate)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c69dd529f917ee2a2e64e1fed358cbede056afdf" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;period#between-java.time.LocalDate-java.time.LocalDate-&quot;&gt;&lt;code&gt;Period.between(LocalDate, LocalDate)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;period#between-java.time.LocalDate-java.time.LocalDate-&quot;&gt; &lt;code&gt;Period.between(LocalDate, LocalDate)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9492b93e045a3bf79273fb130acffec66707289f" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;temporal/temporalunit#between(java.time.temporal.Temporal,java.time.temporal.Temporal)&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메서드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal/temporalunit#between(java.time.temporal.Temporal,java.time.temporal.Temporal)&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31b6839d92a1d7cc91a6f3682b7584519c917ea6" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7019f051004e11b6b00277ad3a368c81695ab5e" translate="yes" xml:space="preserve">
          <source>There are two forms for RMI connector addresses:</source>
          <target state="translated">RMI 커넥터 주소에는 두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53aaf7a78abd414d9fb78d865d3dc8bfb49f2f5" translate="yes" xml:space="preserve">
          <source>There are two general types of decoding errors. If the input byte sequence is not legal for this charset then the input is considered</source>
          <target state="translated">디코딩 오류에는 두 가지 일반적인 유형이 있습니다. 입력 바이트 순서가이 캐릭터 세트에 적합하지 않은 경우, 입력이 고려됩니다</target>
        </trans-unit>
        <trans-unit id="8736c93a7b7bb502b162e668f9dc8978cdb0b6fc" translate="yes" xml:space="preserve">
          <source>There are two general types of encoding errors. If the input character sequence is not a legal sixteen-bit Unicode sequence then the input is considered</source>
          <target state="translated">인코딩 오류에는 두 가지 일반적인 유형이 있습니다. 입력 문자 시퀀스가 ​​올바른 16 비트 유니 코드 시퀀스가 ​​아닌 경우 입력이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="bd7ebb4ee3bd1aaafa978527a6396c0b5c9c4cf7" translate="yes" xml:space="preserve">
          <source>There are two groups of cipher suites which you will need to know about when managing cipher suites:</source>
          <target state="translated">암호화 제품군을 관리 할 때 알아야 할 두 가지 암호화 제품군 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e94429dce8a0432578760912963aff83ad3eb1" translate="yes" xml:space="preserve">
          <source>There are two kinds of JNDI resource files: &lt;em&gt;provider&lt;/em&gt; and &lt;em&gt;application&lt;/em&gt;.</source>
          <target state="translated">JNDI 자원 파일에는 &lt;em&gt;provider&lt;/em&gt; 및 &lt;em&gt;application&lt;/em&gt; 의 두 가지 종류가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f62d3a9ac7482c31f4f464bf796548b98efcc186" translate="yes" xml:space="preserve">
          <source>There are two kinds of transformers, determined by the &lt;code&gt;canRetransform&lt;/code&gt; parameter of &lt;a href=&quot;instrumentation#addTransformer(java.lang.instrument.ClassFileTransformer,boolean)&quot;&gt;&lt;code&gt;Instrumentation.addTransformer(ClassFileTransformer,boolean)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;instrumentation#addTransformer(java.lang.instrument.ClassFileTransformer,boolean)&quot;&gt; &lt;code&gt;Instrumentation.addTransformer(ClassFileTransformer,boolean)&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;canRetransform&lt;/code&gt; 매개 변수에 의해 결정되는 두 종류의 변환기가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1f12fecd42a80e7f754001eddff6ff78d61515c" translate="yes" xml:space="preserve">
          <source>There are two kinds of transformers, determined by the &lt;code&gt;canRetransform&lt;/code&gt; parameter of &lt;a href=&quot;instrumentation#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-&quot;&gt;&lt;code&gt;Instrumentation.addTransformer(ClassFileTransformer,boolean)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;instrumentation#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-&quot;&gt; &lt;code&gt;Instrumentation.addTransformer(ClassFileTransformer,boolean)&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;canRetransform&lt;/code&gt; 매개 변수에 의해 결정되는 두 종류의 변환기가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad3d3d9ea7e13c7b9058e166fab62bea6cb7e20a" translate="yes" xml:space="preserve">
          <source>There are two levels of focus events: permanent and temporary. Permanent focus change events occur when focus is directly moved from one Component to another, such as through a call to requestFocus() or as the user uses the TAB key to traverse Components. Temporary focus change events occur when focus is temporarily lost for a Component as the indirect result of another operation, such as Window deactivation or a Scrollbar drag. In this case, the original focus state will automatically be restored once that operation is finished, or, for the case of Window deactivation, when the Window is reactivated. Both permanent and temporary focus events are delivered using the FOCUS_GAINED and FOCUS_LOST event ids; the level may be distinguished in the event using the isTemporary() method.</source>
          <target state="translated">초점 이벤트에는 영구 및 임시의 두 가지 수준이 있습니다. 영구 포커스 변경 이벤트는 requestFocus () 호출을 통해 또는 사용자가 TAB 키를 사용하여 구성 요소를 탐색하는 것과 같이 한 구성 요소에서 다른 구성 요소로 포커스가 직접 이동할 때 발생합니다. 임시 포커스 변경 이벤트는 창 비활성화 또는 스크롤바 드래그와 같은 다른 작업의 간접적 인 결과로 구성 요소에 대한 포커스가 일시적으로 손실 될 때 발생합니다. 이 경우 해당 작업이 완료되면 원래 포커스 상태가 자동으로 복원되거나, 창 비활성화의 경우 창이 다시 활성화 될 때 자동으로 복원됩니다. 영구 및 임시 초점 이벤트는 모두 FOCUS_GAINED 및 FOCUS_LOST 이벤트 ID를 사용하여 전달됩니다. isTemporary () 메소드를 사용하여 이벤트에서 레벨을 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80be071c6ecd97b5c0ebef1df8ee841bd2ad1fb8" translate="yes" xml:space="preserve">
          <source>There are two other possible locale sensitive service providers, i.e., &quot;CLDR&quot; which is a provider based on Unicode Consortium's &lt;a href=&quot;http://cldr.unicode.org/&quot;&gt;CLDR Project&lt;/a&gt;, and &quot;HOST&quot; which is a provider that reflects the user's custom settings in the underlying operating system. These two providers may not be available, depending on the Java Runtime Environment implementation. Specifying &quot;JRE,SPI&quot; is identical to the default behavior, which is compatibile with the prior releases.</source>
          <target state="translated">로케일에 민감한 다른 두 가지 서비스 공급자, 즉 유니 코드 컨소시엄의 &lt;a href=&quot;http://cldr.unicode.org/&quot;&gt;CLDR 프로젝트를&lt;/a&gt; 기반으로하는 공급자 인 &quot;CLDR&quot; 과 기본 운영 체제에서 사용자의 사용자 지정 설정을 반영하는 공급자 인 &quot;HOST&quot;가 있습니다. Java Runtime Environment 구현에 따라이 두 제공자를 사용하지 못할 수 있습니다. &quot;JRE, SPI&quot;를 지정하는 것은 이전 릴리스와 호환되는 기본 동작과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b2d65cf2e5d262a8fd810c74dbfbd680d4cae033" translate="yes" xml:space="preserve">
          <source>There are two places that the application can deliver an input source to the parser: as the argument to the Parser.parse method, or as the return value of the EntityResolver.resolveEntity method.</source>
          <target state="translated">애플리케이션이 Parser.parse 메서드에 대한 인수 또는 EntityResolver.resolveEntity 메서드의 반환 값으로 입력 소스를 파서에 전달할 수있는 두 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff12985c6611d7ceaf5b220dd6a1ef040dc0377c" translate="yes" xml:space="preserve">
          <source>There are two possible ways in which this decoder could deal with illegal strings. It could either leave illegal characters alone or it could throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;. Which approach the decoder takes is left to the implementation.</source>
          <target state="translated">이 디코더가 잘못된 문자열을 처리 할 수있는 두 가지 방법이 있습니다. 잘못된 문자를 그대로 두거나 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킬 수 있습니다. 디코더가 취하는 접근법은 구현에 맡겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e20791d947ecc2091a239d09f2588e3bea6ead94" translate="yes" xml:space="preserve">
          <source>There are two properties which deal with newlines. The system property, &lt;code&gt;line.separator&lt;/code&gt;, is defined to be platform-dependent, either &quot;\n&quot;, &quot;\r&quot;, or &quot;\r\n&quot;. There is also a property defined in &lt;code&gt;DefaultEditorKit&lt;/code&gt;, called &lt;a href=&quot;#EndOfLineStringProperty&quot;&gt;&lt;code&gt;EndOfLineStringProperty&lt;/code&gt;&lt;/a&gt;, which is defined automatically when a document is loaded, to be the first occurrence of any of the newline characters. When a document is loaded, &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; is set appropriately, and when the document is written back out, the &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; is used. But while the document is in memory, the &quot;\n&quot; character is used to define a newline, regardless of how the newline is defined when the document is on disk. Therefore, for searching purposes, &quot;\n&quot; should always be used. When a new document is created, and the &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; has not been defined, it will use the System property when writing out the document.</source>
          <target state="translated">개행 문자를 다루는 두 가지 속성이 있습니다. 시스템 속성 인 &lt;code&gt;line.separator&lt;/code&gt; 는 플랫폼에 따라 &quot;\ n&quot;, &quot;\ r&quot;또는 &quot;\ r \ n&quot;으로 정의됩니다. 또한 &lt;code&gt;DefaultEditorKit&lt;/code&gt; 에 정의 된 &lt;a href=&quot;#EndOfLineStringProperty&quot;&gt; &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; &lt;/a&gt; 라는 속성이 있습니다.이 속성 은 문서가로드 될 때 자동으로 정의되어 줄 바꿈 문자가 처음으로 나타납니다. 문서가로드되면 &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; 가 적절하게 설정되고 문서가 다시 쓰여지면 &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; 사용. 그러나 문서가 메모리에있는 동안 &quot;\ n&quot;문자는 문서가 디스크에있을 때 줄 바꿈이 정의되는 방식에 관계없이 줄 바꿈을 정의하는 데 사용됩니다. 따라서 검색을 위해 항상 &quot;\ n&quot;을 사용해야합니다. 새 문서가 생성되고 &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; 가 정의되지 않은 경우 문서를 작성할 때 System 속성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d91ceedcd52bc4240b139aedacb18606cb46b462" translate="yes" xml:space="preserve">
          <source>There are two separate trees of preference nodes, one for user preferences and one for system preferences. Each user has a separate user preference tree, and all users in a given system share the same system preference tree. The precise description of &quot;user&quot; and &quot;system&quot; will vary from implementation to implementation. Typical information stored in the user preference tree might include font choice, color choice, or preferred window location and size for a particular application. Typical information stored in the system preference tree might include installation configuration data for an application.</source>
          <target state="translated">환경 설정 노드에는 사용자 환경 설정과 시스템 환경 설정을위한 두 개의 별도 트리가 있습니다. 각 사용자에게는 별도의 사용자 기본 설정 트리가 있으며 지정된 시스템의 모든 사용자는 동일한 시스템 기본 설정 트리를 공유합니다. &quot;사용자&quot;및 &quot;시스템&quot;에 대한 정확한 설명은 구현마다 다릅니다. 사용자 기본 설정 트리에 저장된 일반적인 정보에는 특정 응용 프로그램의 글꼴 선택, 색상 선택 또는 기본 창 위치 및 크기가 포함될 수 있습니다. 시스템 환경 설정 트리에 저장된 일반 정보에는 응용 프로그램의 설치 구성 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6202432717df2ac02cb63931bf58fa0f63cab202" translate="yes" xml:space="preserve">
          <source>There are two situations where this query may return a non-zero period.</source>
          <target state="translated">이 쿼리가 0이 아닌 기간을 반환 할 수있는 두 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e75919a8d6dc8a964f582e10611fcfefe5d1d7" translate="yes" xml:space="preserve">
          <source>There are two types of filtering: filtering for basic language ranges (called &quot;basic filtering&quot;) and filtering for extended language ranges (called &quot;extended filtering&quot;). They may return different results by what kind of language ranges are included in the given Language Priority List. &lt;a href=&quot;locale.filteringmode&quot;&gt;&lt;code&gt;Locale.FilteringMode&lt;/code&gt;&lt;/a&gt; is a parameter to specify how filtering should be done.</source>
          <target state="translated">기본 언어 범위 필터링 ( &quot;기본 필터링&quot;)과 확장 언어 범위 필터링 ( &quot;확장 필터링&quot;)의 두 가지 필터링 유형이 있습니다. 주어진 언어 우선 순위 목록에 포함 된 언어 범위에 따라 다른 결과를 반환 할 수 있습니다. &lt;a href=&quot;locale.filteringmode&quot;&gt; &lt;code&gt;Locale.FilteringMode&lt;/code&gt; &lt;/a&gt; 는 필터링 방법을 지정하는 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="863bb4e82b05433afe02f4bff6c94f9fcbaf46be" translate="yes" xml:space="preserve">
          <source>There are two types of language ranges: basic and extended. In RFC 4647, the syntax of language ranges is expressed in &lt;a href=&quot;http://tools.ietf.org/html/rfc4234&quot;&gt;ABNF&lt;/a&gt; as follows:</source>
          <target state="translated">언어 범위에는 기본 및 확장의 두 가지 유형이 있습니다. RFC 4647에서 언어 범위의 구문은 다음과 같이 &lt;a href=&quot;http://tools.ietf.org/html/rfc4234&quot;&gt;ABNF&lt;/a&gt; 로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="03767c30c8b687a49d6fbdbfbb2ec538574b74af" translate="yes" xml:space="preserve">
          <source>There are two types of request controls:</source>
          <target state="translated">요청 제어에는 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58334da2a0286115ac83f8532c53ee33fc146ada" translate="yes" xml:space="preserve">
          <source>There are two typical uses of this class:</source>
          <target state="translated">이 클래스에는 두 가지 일반적인 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="be03833ce8f129d53ac2624902bf28a6a154a424" translate="yes" xml:space="preserve">
          <source>There are two ways for a &lt;code&gt;CachedRowSet&lt;/code&gt; object to specify which &lt;code&gt;SyncProvider&lt;/code&gt; object it will use.</source>
          <target state="translated">&lt;code&gt;CachedRowSet&lt;/code&gt; 객체 가 사용할 &lt;code&gt;SyncProvider&lt;/code&gt; 객체 를 지정하는 방법에는 두 가지 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="723bde258bb2a065ece49f2af6e47c912e129ae4" translate="yes" xml:space="preserve">
          <source>There are two ways for the SAX application to obtain information from the AttributeList. First, it can iterate through the entire list:</source>
          <target state="translated">SAX 애플리케이션이 AttributeList에서 정보를 얻는 방법에는 두 가지가 있습니다. 첫째, 전체 목록을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2fda0a5c05f0d77dfca57e037365613258cde0a" translate="yes" xml:space="preserve">
          <source>There are two ways in which a context instance gets its request controls:</source>
          <target state="translated">컨텍스트 인스턴스가 요청 제어를 얻는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="975a7b038db4eb6bf41059eceb7313d6dd42998b" translate="yes" xml:space="preserve">
          <source>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This subclass should override the &lt;code&gt;run&lt;/code&gt; method of class &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be allocated and started. For example, a thread that computes primes larger than a stated value could be written as follows:</source>
          <target state="translated">새로운 실행 스레드를 작성하는 두 가지 방법이 있습니다. 하나는 클래스를 &lt;code&gt;Thread&lt;/code&gt; 의 하위 클래스로 선언하는 것 입니다. 이 서브 클래스는 &lt;code&gt;Thread&lt;/code&gt; 클래스 의 &lt;code&gt;run&lt;/code&gt; 메소드를 대체해야합니다 . 그런 다음 서브 클래스의 인스턴스를 할당하고 시작할 수 있습니다. 예를 들어, 명시된 값보다 큰 소수를 계산하는 스레드는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e323c2ef38456a30754099b0b8f3942d493170" translate="yes" xml:space="preserve">
          <source>There are two ways to create an MBean. One is to construct a Java object that will be the MBean, then use the &lt;a href=&quot;mbeanserver#registerMBean(java.lang.Object,javax.management.ObjectName)&quot;&gt;&lt;code&gt;registerMBean&lt;/code&gt;&lt;/a&gt; method to register it in the MBean Server. The other is to create and register the MBean in a single operation using one of the &lt;a href=&quot;mbeanserver#createMBean(java.lang.String,javax.management.ObjectName)&quot;&gt;&lt;code&gt;createMBean&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">MBean을 생성하는 방법에는 두 가지가 있습니다. 하나는 MBean이 될 Java 객체를 생성 한 다음 &lt;a href=&quot;mbeanserver#registerMBean(java.lang.Object,javax.management.ObjectName)&quot;&gt; &lt;code&gt;registerMBean&lt;/code&gt; &lt;/a&gt; 메소드를 사용 하여 MBean 서버에 등록하는 것입니다. 다른 하나는 &lt;a href=&quot;mbeanserver#createMBean(java.lang.String,javax.management.ObjectName)&quot;&gt; &lt;code&gt;createMBean&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 사용하여 단일 조작으로 MBean을 작성하고 등록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="1130822317a86f6e57038bd5122e8e2e69d189a3" translate="yes" xml:space="preserve">
          <source>There are two ways to create an MBean. One is to construct a Java object that will be the MBean, then use the &lt;a href=&quot;mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt;&lt;code&gt;registerMBean&lt;/code&gt;&lt;/a&gt; method to register it in the MBean Server. The other is to create and register the MBean in a single operation using one of the &lt;a href=&quot;mbeanserver#createMBean-java.lang.String-javax.management.ObjectName-&quot;&gt;&lt;code&gt;createMBean&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">MBean을 작성하는 방법에는 두 가지가 있습니다. 하나는 MBean이 될 Java 객체를 구성한 다음 &lt;a href=&quot;mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt; &lt;code&gt;registerMBean&lt;/code&gt; &lt;/a&gt; 메소드를 사용 하여 MBean 서버에 등록하는 것입니다. 다른 하나는 &lt;a href=&quot;mbeanserver#createMBean-java.lang.String-javax.management.ObjectName-&quot;&gt; &lt;code&gt;createMBean&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 사용하여 단일 조작으로 MBean을 작성하고 등록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f02bb82aa08947d1c4db6345575e9a9a9391eb79" translate="yes" xml:space="preserve">
          <source>There are two ways to generate a key pair: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object:</source>
          <target state="translated">키 쌍을 생성하는 방법에는 알고리즘 독립적 방식과 알고리즘 특정 방식의 두 가지 방법이 있습니다. 이 둘의 유일한 차이점은 객체의 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="fc8284f153af11fa26dc2b9e2c9486fe94b0031e" translate="yes" xml:space="preserve">
          <source>There are two ways to generate a key: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object:</source>
          <target state="translated">키를 생성하는 방법에는 알고리즘 독립적 방식과 알고리즘 특정 방식의 두 가지가 있습니다. 이 둘의 유일한 차이점은 객체의 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="159241de6eb6c0aad925571d76835e03dc536a22" translate="yes" xml:space="preserve">
          <source>There are two ways to make a Java object that is an MBean with this management interface. One is for the object to be of a class that has exactly the same name as the Java interface but without the &lt;code&gt;MBean&lt;/code&gt; suffix. So in the example the object would be of the class &lt;code&gt;Configuration&lt;/code&gt;, in the same Java package as &lt;code&gt;ConfigurationMBean&lt;/code&gt;. The second way is to use the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">이 관리 인터페이스를 사용하여 MBean 인 Java 오브젝트를 작성하는 방법에는 두 가지가 있습니다. 하나는 객체가 Java 인터페이스와 이름은 같지만 &lt;code&gt;MBean&lt;/code&gt; 접미어가 없는 클래스가되는 것입니다 . 그래서 예에서 객체는 클래스의 것 &lt;code&gt;Configuration&lt;/code&gt; 과 같은 Java 패키지에, &lt;code&gt;ConfigurationMBean&lt;/code&gt; . 두 번째 방법은 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="90012bb7cf1245412cbc193a80e9ac8ba45df7dd" translate="yes" xml:space="preserve">
          <source>There are two ways to obtain an instance of the &lt;code&gt;Instrumentation&lt;/code&gt; interface:</source>
          <target state="translated">&lt;code&gt;Instrumentation&lt;/code&gt; 인터페이스 의 인스턴스를 얻는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="771a213e98d7cf68dc3b44a652ef624310ae5943" translate="yes" xml:space="preserve">
          <source>There are two ways to set a &lt;code&gt;Calendar&lt;/code&gt; to a date-time value. One is to set the instant parameter to a millisecond offset from the &lt;a href=&quot;calendar#Epoch&quot;&gt;Epoch&lt;/a&gt;. The other is to set individual field parameters, such as &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt;, to their desired values. These two ways can't be mixed. Trying to set both the instant and individual fields will cause an &lt;a href=&quot;../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; to be thrown. However, it is permitted to override previous values of the instant or field parameters.</source>
          <target state="translated">&lt;code&gt;Calendar&lt;/code&gt; 을 날짜-시간 값 으로 설정하는 방법에는 두 가지가 있습니다 . 하나는 instant 매개 변수를 &lt;a href=&quot;calendar#Epoch&quot;&gt;Epoch&lt;/a&gt; 에서 밀리 초 오프셋으로 설정하는 것 입니다. 다른 하나는 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 와 같은 개별 필드 매개 변수 를 원하는 값으로 설정하는 것입니다. 이 두 가지 방법은 섞을 수 없습니다. 인스턴트 필드와 개별 ​​필드를 모두 설정하려고하면 &lt;a href=&quot;../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 그러나 인스턴트 또는 필드 매개 변수의 이전 값을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c4aa4c3dad5442ad3148498e9b2b89e070dc8d" translate="yes" xml:space="preserve">
          <source>There are various ways to handle the conversion from a &lt;code&gt;LocalDateTime&lt;/code&gt;. One technique, using this method, would be:</source>
          <target state="translated">&lt;code&gt;LocalDateTime&lt;/code&gt; 에서 변환을 처리하는 방법에는 여러 가지가 있습니다 . 이 방법을 사용하는 한 가지 기술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3918cb605e7d0c3c6f2663575261375e1b19245" translate="yes" xml:space="preserve">
          <source>There are, however, some limited use cases where users believe they need to store and use dates in arbitrary calendar systems throughout the application. This is supported by &lt;a href=&quot;chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt;, however it is vital to read all the associated warnings in the Javadoc of that interface before using it. In summary, applications that require general interoperation between multiple calendar systems typically need to be written in a very different way to those only using the ISO calendar, thus most applications should just use ISO and avoid &lt;code&gt;ChronoLocalDate&lt;/code&gt;.</source>
          <target state="translated">그러나 사용자가 응용 프로그램 전체에서 임의의 달력 시스템에 날짜를 저장하고 사용해야한다고 생각하는 일부 사용 사례가 있습니다. 이것은 &lt;a href=&quot;chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 에서 지원 되지만 , 사용하기 전에 해당 인터페이스의 Javadoc에있는 모든 관련 경고를 읽어야합니다. 요약하면, 여러 달력 시스템간에 일반적인 상호 운용이 필요한 응용 프로그램은 일반적으로 ISO 달력을 사용하는 응용 프로그램과는 매우 다른 방식으로 작성해야하므로 대부분의 응용 프로그램은 ISO 만 사용하고 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 를 피해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="ad68c71cd005733d3d27a578116ef8c19e4d7ff1" translate="yes" xml:space="preserve">
          <source>There can be different implementations of &lt;code&gt;Name&lt;/code&gt;; for example, composite names, URLs, or namespace-specific compound names.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 의 다른 구현이있을 수 있습니다 . 예를 들어 복합 이름, URL 또는 네임 스페이스 별 복합 이름입니다.</target>
        </trans-unit>
        <trans-unit id="de8c4bc02482e28cffe1f4a7a174d6c99f5c155f" translate="yes" xml:space="preserve">
          <source>There can be only one full-screen window on a device at any time, so calling this method while there is an existing full-screen Window will cause the existing full-screen window to return to windowed mode.</source>
          <target state="translated">장치에는 항상 하나의 전체 화면 창이있을 수 있으므로 기존 전체 화면 창이있는 동안이 메서드를 호출하면 기존 전체 화면 창이 창 모드로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="ce433d14a2eedfbb470ac526e7184d30f9308adf" translate="yes" xml:space="preserve">
          <source>There exist different variants of these global identifiers. The methods of this class are for manipulating the Leach-Salz variant, although the constructors allow the creation of any variant of UUID (described below).</source>
          <target state="translated">이러한 전역 식별자에는 다양한 변형이 있습니다. 이 클래스의 메소드는 Leach-Salz 변형을 조작하기위한 것이지만 생성자는 UUID의 변형 (아래 설명 참조)을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00997846c1193c358f37824f2d009c61e62de2e2" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#Ipv4IPv6&quot;&gt;couple of System Properties&lt;/a&gt; affecting how IPv4 and IPv6 addresses are used.</source>
          <target state="translated">이 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#Ipv4IPv6&quot;&gt;시스템 등록 정보의 몇&lt;/a&gt; IPv4 및 IPv6 주소를 사용하는 방법에 영향을주지는.</target>
        </trans-unit>
        <trans-unit id="6074e75d203b0395cdf525ce296145ded214ba29" translate="yes" xml:space="preserve">
          <source>There is a JVM limit (classfile structural constraint): no method can call with more than 255 slots. This limits the number of static and dynamic arguments one can pass to bootstrap method. Since there are potential concatenation strategies that use &lt;code&gt;MethodHandle&lt;/code&gt; combinators, we need to reserve a few empty slots on the parameter lists to capture the temporal results. This is why bootstrap methods in this factory do not accept more than 200 argument slots. Users requiring more than 200 argument slots in concatenation are expected to split the large concatenation in smaller expressions.</source>
          <target state="translated">JVM 한계 (클래스 파일 구조적 제약)가 있습니다. 어떤 메소드도 255 개 이상의 슬롯으로 호출 할 수 없습니다. 이것은 부트 스트랩 메소드에 전달할 수있는 정적 및 동적 인수의 수를 제한합니다. &lt;code&gt;MethodHandle&lt;/code&gt; 결합자를 사용하는 잠재적 인 연결 전략이 있기 때문에 매개 변수 목록에 몇 개의 빈 슬롯을 예약하여 시간 결과를 캡처해야합니다. 이것이이 팩토리의 부트 스트랩 메소드가 200 개 이상의 인수 슬롯을 허용하지 않는 이유입니다. 연결에 200 개 이상의 인수 슬롯이 필요한 사용자는 큰 연결을 작은 식으로 분할해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbdeb2575b41cbcf1a0c50743f59d79e06e928f0" translate="yes" xml:space="preserve">
          <source>There is a buffer class for each non-boolean primitive type. Each class defines a family of</source>
          <target state="translated">부울이 아닌 기본 유형마다 버퍼 클래스가 있습니다. 각 클래스는</target>
        </trans-unit>
        <trans-unit id="e611c9ca26ee759c4b00b3f9330825ec933eabb1" translate="yes" xml:space="preserve">
          <source>There is a couple of System Properties affecting how IPv4 and IPv6 addresses are used.</source>
          <target state="translated">IPv4 및 IPv6 주소 사용 방법에 영향을주는 몇 가지 시스템 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="efc2c6b7e2736b91bfc3bf3c344c481fe814c808" translate="yes" xml:space="preserve">
          <source>There is a distinction between an attribute's Java language type, as returned by &lt;a href=&quot;../mbeanattributeinfo#getType()&quot;&gt;&lt;code&gt;getType()&lt;/code&gt;&lt;/a&gt;, and its &lt;code&gt;OpenType&lt;/code&gt;, as returned by &lt;a href=&quot;openmbeanparameterinfo#getOpenType()&quot;&gt;&lt;code&gt;getOpenType()&lt;/code&gt;&lt;/a&gt;. For example, if the Java language type is &lt;code&gt;java.lang.String&lt;/code&gt;, the &lt;code&gt;OpenType&lt;/code&gt; will be &lt;a href=&quot;simpletype#STRING&quot;&gt;&lt;code&gt;SimpleType.String&lt;/code&gt;&lt;/a&gt;. If the Java language type is &lt;a href=&quot;compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;OpenType&lt;/code&gt; will be a &lt;a href=&quot;compositetype&quot;&gt;&lt;code&gt;CompositeType&lt;/code&gt;&lt;/a&gt; that describes the items in the &lt;code&gt;CompositeData&lt;/code&gt; instances for the attribute.</source>
          <target state="translated">&lt;a href=&quot;../mbeanattributeinfo#getType()&quot;&gt; &lt;code&gt;getType()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 속성의 Java 언어 유형 과 &lt;a href=&quot;openmbeanparameterinfo#getOpenType()&quot;&gt; &lt;code&gt;getOpenType()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 해당 &lt;code&gt;OpenType&lt;/code&gt; 간에 차이가 있습니다. 예를 들어, Java 언어 유형이 &lt;code&gt;java.lang.String&lt;/code&gt; 이면 &lt;code&gt;OpenType&lt;/code&gt; 은 &lt;a href=&quot;simpletype#STRING&quot;&gt; &lt;code&gt;SimpleType.String&lt;/code&gt; 이&lt;/a&gt; 됩니다. Java 언어 유형이 &lt;a href=&quot;compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;OpenType&lt;/code&gt; 은 속성 에 대한 &lt;code&gt;CompositeData&lt;/code&gt; 인스턴스 의 항목을 설명 하는 &lt;a href=&quot;compositetype&quot;&gt; &lt;code&gt;CompositeType&lt;/code&gt; &lt;/a&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="e457efe2a17a4c04ee89e9b13d9382d5d98aca7c" translate="yes" xml:space="preserve">
          <source>There is a distinction between an attribute's Java language type, as returned by &lt;a href=&quot;../mbeanattributeinfo#getType--&quot;&gt;&lt;code&gt;getType()&lt;/code&gt;&lt;/a&gt;, and its &lt;code&gt;OpenType&lt;/code&gt;, as returned by &lt;a href=&quot;openmbeanparameterinfo#getOpenType--&quot;&gt;&lt;code&gt;getOpenType()&lt;/code&gt;&lt;/a&gt;. For example, if the Java language type is &lt;code&gt;java.lang.String&lt;/code&gt;, the &lt;code&gt;OpenType&lt;/code&gt; will be &lt;a href=&quot;simpletype#STRING&quot;&gt;&lt;code&gt;SimpleType.String&lt;/code&gt;&lt;/a&gt;. If the Java language type is &lt;a href=&quot;compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;OpenType&lt;/code&gt; will be a &lt;a href=&quot;compositetype&quot;&gt;&lt;code&gt;CompositeType&lt;/code&gt;&lt;/a&gt; that describes the items in the &lt;code&gt;CompositeData&lt;/code&gt; instances for the attribute.</source>
          <target state="translated">&lt;a href=&quot;../mbeanattributeinfo#getType--&quot;&gt; &lt;code&gt;getType()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 속성의 Java 언어 유형 과 &lt;a href=&quot;openmbeanparameterinfo#getOpenType--&quot;&gt; &lt;code&gt;getOpenType()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 &lt;code&gt;OpenType&lt;/code&gt; 사이에는 차이가 있습니다 . 예를 들어, Java 언어 유형이 &lt;code&gt;java.lang.String&lt;/code&gt; 인 경우 &lt;code&gt;OpenType&lt;/code&gt; 은 &lt;a href=&quot;simpletype#STRING&quot;&gt; &lt;code&gt;SimpleType.String&lt;/code&gt; &lt;/a&gt; 입니다. Java 언어 유형이 &lt;a href=&quot;compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;OpenType&lt;/code&gt; 은 속성 에 대한 &lt;code&gt;CompositeData&lt;/code&gt; 인스턴스 의 항목을 설명 하는 &lt;a href=&quot;compositetype&quot;&gt; &lt;code&gt;CompositeType&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="47ec9ff2dff4067d12469aae62647665afd970c0" translate="yes" xml:space="preserve">
          <source>There is a one-to-one mapping between keys and identities, and there can only be one copy of one key per scope. For example, suppose &lt;b&gt;Acme Software, Inc&lt;/b&gt; is a software publisher known to a user. Suppose it is an Identity, that is, it has a public key, and a set of associated certificates. It is named in the scope using the name &quot;Acme Software&quot;. No other named Identity in the scope has the same public key. Of course, none has the same name as well.</source>
          <target state="translated">키와 ID간에 ​​일대일 매핑이 있으며 범위 당 하나의 키 사본 만있을 수 있습니다. 예를 들어 &lt;b&gt;Acme Software, Inc&lt;/b&gt; 는 사용자에게 알려진 소프트웨어 게시자라고 가정 합니다. 아이덴티티, 즉 공개 키와 관련 인증서 세트가 있다고 가정하십시오. &quot;Acme Software&quot;라는 이름을 사용하여 범위에서 명명됩니다. 범위 내에서 이름이 지정된 다른 Identity는 동일한 공개 키를 갖지 않습니다. 물론 같은 이름을 가진 사람은 없습니다.</target>
        </trans-unit>
        <trans-unit id="78efa11c02a6f618b8cfe49957d8fd3c2e7e47c3" translate="yes" xml:space="preserve">
          <source>There is a one-to-one mapping between the distinguishable &lt;code&gt;BigDecimal&lt;/code&gt; values and the result of this conversion. That is, every distinguishable &lt;code&gt;BigDecimal&lt;/code&gt; value (unscaled value and scale) has a unique string representation as a result of using &lt;code&gt;toString&lt;/code&gt;. If that string representation is converted back to a &lt;code&gt;BigDecimal&lt;/code&gt; using the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor, then the original value will be recovered.</source>
          <target state="translated">구별 가능한 &lt;code&gt;BigDecimal&lt;/code&gt; 값과이 변환의 결과 사이에 일대일 맵핑 이 있습니다. 즉, 모든 구별 가능한 &lt;code&gt;BigDecimal&lt;/code&gt; 값 (비 스케일 값 및 스케일)은 &lt;code&gt;toString&lt;/code&gt; 을 사용한 결과로 고유 한 문자열 표현을 갖습니다 . 해당 문자열 표현은로 변환 다시 경우 &lt;code&gt;BigDecimal&lt;/code&gt; 은 Using &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 생성자는, 원의 값이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="54e8a1cf0a979c6bead49e4451cc625e0cb7132c" translate="yes" xml:space="preserve">
          <source>There is a one-to-one mapping between the distinguishable &lt;code&gt;BigDecimal&lt;/code&gt; values and the result of this conversion. That is, every distinguishable &lt;code&gt;BigDecimal&lt;/code&gt; value (unscaled value and scale) has a unique string representation as a result of using &lt;code&gt;toString&lt;/code&gt;. If that string representation is converted back to a &lt;code&gt;BigDecimal&lt;/code&gt; using the &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor, then the original value will be recovered.</source>
          <target state="translated">식별 가능한 &lt;code&gt;BigDecimal&lt;/code&gt; 값과이 변환 결과 사이에는 일대일 맵핑 이 있습니다. 즉, 식별 가능한 모든 &lt;code&gt;BigDecimal&lt;/code&gt; 값 (스케일링되지 않은 값 및 스케일)은 &lt;code&gt;toString&lt;/code&gt; 사용의 결과로 고유 한 문자열 표현을 갖습니다 . 해당 문자열 표현은로 변환 다시 경우 &lt;code&gt;BigDecimal&lt;/code&gt; 은 Using &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 생성자는, 원의 값이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="07a170e47ba1b28632f7de6a7126103d894a204e" translate="yes" xml:space="preserve">
          <source>There is a single global LogManager object that is used to maintain a set of shared state about Loggers and log services.</source>
          <target state="translated">로거 및 로그 서비스에 대한 공유 상태 세트를 유지 보수하는 데 사용되는 단일 글로벌 LogManager 오브젝트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f6696f8357f83f1e4bc66cdc5dac5cd0bb4624" translate="yes" xml:space="preserve">
          <source>There is a single global instance of the &lt;code&gt;LoggingMXBean&lt;/code&gt;. This instance is an &lt;a href=&quot;../../../javax/management/mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;logmanager#getLoggingMXBean--&quot;&gt;&lt;code&gt;LogManager.getLoggingMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMBeanServer--&quot;&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LoggingMXBean&lt;/code&gt; 의 단일 글로벌 인스턴스가 있습니다. 이 인스턴스는 &lt;a href=&quot;logmanager#getLoggingMXBean--&quot;&gt; &lt;code&gt;LogManager.getLoggingMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMBeanServer--&quot;&gt;플랫폼 &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 에서 확보 할 수 있는 &lt;a href=&quot;../../../javax/management/mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7f8fc35d9806679382a2134903e7a75c027df1ce" translate="yes" xml:space="preserve">
          <source>There is a single global instance of the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt;. The &lt;a href=&quot;managementfactory#getPlatformMXBean(java.lang.Class)&quot;&gt;&lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt;&lt;/a&gt; method can be used to obtain the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; object as follows:</source>
          <target state="translated">&lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 의 단일 글로벌 인스턴스가 있습니다. &lt;a href=&quot;managementfactory#getPlatformMXBean(java.lang.Class)&quot;&gt; &lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt; &lt;/a&gt; 방법은 취득 할 수 &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 다음 개체 :</target>
        </trans-unit>
        <trans-unit id="1db9183d0fe9302b767e7cc23a636f50f0a9febc" translate="yes" xml:space="preserve">
          <source>There is a single global instance of the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt;. The &lt;a href=&quot;managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt;&lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt;&lt;/a&gt; method can be used to obtain the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; object as follows:</source>
          <target state="translated">&lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 의 단일 글로벌 인스턴스가 있습니다. &lt;a href=&quot;managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt; &lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt; &lt;/a&gt; 방법은 취득 할 수 &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 다음 개체 :</target>
        </trans-unit>
        <trans-unit id="cdccdd64637cc92dadca7fef587f9c1a806a3e4a" translate="yes" xml:space="preserve">
          <source>There is also an option to supply an alternate parentTag and addTag. These will be checked for if there is no parentTag at offset.</source>
          <target state="translated">대체 parentTag 및 addTag를 제공하는 옵션도 있습니다. 오프셋에 parentTag가 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="658d1d725d598b21d0b29423aca52f884a5ab418" translate="yes" xml:space="preserve">
          <source>There is an asynchronous operation already outstanding.</source>
          <target state="translated">이미 해결되지 않은 비동기 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7a5bc5db07687d87e493216c4aa134192f8acdc" translate="yes" xml:space="preserve">
          <source>There is an exception for the second condition (the value of the &lt;code&gt;autoRequestFocus&lt;/code&gt; property). The property is not taken into account if the window is a modal dialog, which blocks the currently focused window.</source>
          <target state="translated">두 번째 조건 ( &lt;code&gt;autoRequestFocus&lt;/code&gt; 속성 값)에 대한 예외가 있습니다 . 창이 현재 포커스가있는 창을 차단하는 모달 대화 상자 인 경우 속성은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef852b41e85d5b8d7d0516574ed1e5208aad1805" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;unsetDestinationOffset&lt;/code&gt; method; simply call &lt;code&gt;setDestinationOffset(new Point(0, 0))&lt;/code&gt; to restore default values.</source>
          <target state="translated">&lt;code&gt;unsetDestinationOffset&lt;/code&gt; 메소드 는 없습니다 . 단순히 &lt;code&gt;setDestinationOffset(new Point(0, 0))&lt;/code&gt; 을 호출 하여 기본값을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="75fe41e0afde47fd04c96028c6e0c36054c90aa2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;unsetSourceProgressivePasses&lt;/code&gt; method; the same effect may be obtained by calling &lt;code&gt;setSourceProgressivePasses(0, Integer.MAX_VALUE)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsetSourceProgressivePasses&lt;/code&gt; 메소드 가 없습니다 . &lt;code&gt;setSourceProgressivePasses(0, Integer.MAX_VALUE)&lt;/code&gt; 호출하여 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb3c1caf12670f746761a1a308b04f8a646c8f65" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;unsetSourceSubsampling&lt;/code&gt; method; simply call &lt;code&gt;setSourceSubsampling(1, 1, 0, 0)&lt;/code&gt; to restore default values.</source>
          <target state="translated">&lt;code&gt;unsetSourceSubsampling&lt;/code&gt; 메소드 는 없습니다 . 간단히 &lt;code&gt;setSourceSubsampling(1, 1, 0, 0)&lt;/code&gt; 을 호출 하여 기본값을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="ee54f15ef2cec490cdcfa73e2f78c4e3b949be5c" translate="yes" xml:space="preserve">
          <source>There is no defined order among annotation elements. As a matter of style, the &lt;code&gt;since&lt;/code&gt; element should be placed first.</source>
          <target state="translated">주석 요소간에 정의 된 순서가 없습니다. 스타일의 문제로 &lt;code&gt;since&lt;/code&gt; 요소가 먼저 배치되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf4f6a6600ccefd5bc95c8181388c200994df259" translate="yes" xml:space="preserve">
          <source>There is no embedded flag character for enabling canonical equivalence.</source>
          <target state="translated">정식 등가를 가능하게하는 내장 플래그 문자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c437702dae33f4479582f804dd1b9271378f690" translate="yes" xml:space="preserve">
          <source>There is no embedded flag character for enabling literal parsing.</source>
          <target state="translated">리터럴 파싱을 활성화하기위한 내장 된 플래그 문자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="361c082d07aaf113aa3cccd8b88a0834688fd8ed" translate="yes" xml:space="preserve">
          <source>There is no guarantee about when the &lt;code&gt;MemoryMXBean&lt;/code&gt; will emit a threshold notification and when the notification will be delivered. When a notification listener is invoked, the memory usage of the memory pool may have crossed the usage threshold more than once. The &lt;a href=&quot;memorynotificationinfo#getCount()&quot;&gt;&lt;code&gt;MemoryNotificationInfo.getCount()&lt;/code&gt;&lt;/a&gt; method returns the number of times that the memory usage has crossed the usage threshold at the point in time when the notification was constructed. It can be compared with the current usage threshold count returned by the &lt;a href=&quot;#getUsageThresholdCount()&quot;&gt;&lt;code&gt;getUsageThresholdCount()&lt;/code&gt;&lt;/a&gt; method to determine if such situation has occurred.</source>
          <target state="translated">&lt;code&gt;MemoryMXBean&lt;/code&gt; 이 임계 값 알림을 내보내는시기와 알림이 전달되는 시기 에 대한 보장은 없습니다 . 알림 리스너가 호출되면 메모리 풀의 메모리 사용량이 사용량 임계 값을 두 번 이상 초과했을 수 있습니다. &lt;a href=&quot;memorynotificationinfo#getCount()&quot;&gt; &lt;code&gt;MemoryNotificationInfo.getCount()&lt;/code&gt; &lt;/a&gt; 메소드는, 통지가 구축되었을 때의 메모리 사용량이 시점에서 사용량 임계치를 넘은 회수를 돌려줍니다. &lt;a href=&quot;#getUsageThresholdCount()&quot;&gt; &lt;code&gt;getUsageThresholdCount()&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 현재 사용량 임계 값 수와 비교하여 이러한 상황이 발생했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2476cd0e3a3386674e0ed89def19edc4b13b242e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about when the &lt;code&gt;MemoryMXBean&lt;/code&gt; will emit a threshold notification and when the notification will be delivered. When a notification listener is invoked, the memory usage of the memory pool may have crossed the usage threshold more than once. The &lt;a href=&quot;memorynotificationinfo#getCount--&quot;&gt;&lt;code&gt;MemoryNotificationInfo.getCount()&lt;/code&gt;&lt;/a&gt; method returns the number of times that the memory usage has crossed the usage threshold at the point in time when the notification was constructed. It can be compared with the current usage threshold count returned by the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;getUsageThresholdCount()&lt;/code&gt;&lt;/a&gt; method to determine if such situation has occurred.</source>
          <target state="translated">&lt;code&gt;MemoryMXBean&lt;/code&gt; 이 임계 값 알림을 언제 내보내는 지, 알림이 언제 배달 되는지에 대해서는 보장 할 수 없습니다. 알림 리스너가 호출되면 메모리 풀의 메모리 사용량이 사용량 임계 값을 두 번 이상 초과했을 수 있습니다. &lt;a href=&quot;memorynotificationinfo#getCount--&quot;&gt; &lt;code&gt;MemoryNotificationInfo.getCount()&lt;/code&gt; &lt;/a&gt; 메소드는, 통지가 구축되었을 때의 메모리 사용량이 시점에서 사용량 임계치를 넘은 회수를 돌려줍니다. &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;getUsageThresholdCount()&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 현재 사용 임계 값 계수와 비교하여 이러한 상황이 발생했는지 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d60f97f9703f42d93a54253e7d22123ed3faa9b8" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the &lt;code&gt;asType&lt;/code&gt; call is actually made. If the JVM can predict the results of making the call, it may perform adaptations directly on the caller's arguments, and call the target method handle according to its own exact type.</source>
          <target state="translated">&lt;code&gt;asType&lt;/code&gt; 호출이 실제로 이루어 졌다는 보장은 없습니다 . JVM이 호출 결과를 예측할 수 있으면 호출자의 인수에 대해 직접 적응을 수행하고 고유 한 정확한 유형에 따라 대상 메소드 핸들을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="563bedb54b5f2fda07232672d28d980b59e9cdfa" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the name strings in the resulting array will appear in any specific order; they are not, in particular, guaranteed to appear in alphabetical order.</source>
          <target state="translated">결과 배열의 이름 문자열이 특정 순서로 나타날 것이라는 보장은 없습니다. 특히 알파벳 순서로 표시되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="046583b6eeaeb8b5922df31707e6fa286b439c21" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the notation declaration will be reported before any unparsed entities that use it.</source>
          <target state="translated">표기법 선언이이를 사용하는 구문 분석되지 않은 엔티티보다 먼저보고된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b5307904581616c49620a8afa65d4a7ad0b81a2" translate="yes" xml:space="preserve">
          <source>There is no limit on the amount of data that may be written, so use this with care.</source>
          <target state="translated">기록 될 수있는 데이터의 양에는 제한이 없으므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="caa61a6745a38d47cfa3d5d57583320bc8d9204d" translate="yes" xml:space="preserve">
          <source>There is no limit to integer digits set by this routine, since that is the typical end-user desire; use setMaximumInteger if you want to set a real value. For negative numbers, use a second pattern, separated by a semicolon</source>
          <target state="translated">이 루틴에 의해 설정된 정수 자릿수에는 제한이 없습니다. 이것이 일반적인 최종 사용자 요구이기 때문입니다. 실제 값을 설정하려면 setMaximumInteger를 사용하십시오. 음수의 경우 세미콜론으로 구분 된 두 번째 패턴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="998f9151c1110aaa94300df3294ecd2bb59d3edc" translate="yes" xml:space="preserve">
          <source>There is no pathname transformation, except that the system file separator is replaced by the JAR file separator '/'.</source>
          <target state="translated">시스템 파일 구분 기호가 JAR 파일 구분 기호 '/'로 대체되는 것을 제외하고는 경로 이름 변환이 없습니다.</target>
        </trans-unit>
        <trans-unit id="40cfd7dfadd3391c252abf3662f2ca699044a90b" translate="yes" xml:space="preserve">
          <source>There is no requirement for a compiler at runtime. However, if a default compiler is provided, it can be located using the &lt;a href=&quot;toolprovider&quot;&gt;ToolProvider&lt;/a&gt;, for example:</source>
          <target state="translated">런타임에는 컴파일러가 필요하지 않습니다. 그러나 기본 컴파일러가 제공되는 경우 &lt;a href=&quot;toolprovider&quot;&gt;ToolProvider를&lt;/a&gt; 사용하여 찾을 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="e86520d525eca5d9dc11030c4679128fdfa1c011" translate="yes" xml:space="preserve">
          <source>There is no requirement that a distinct result be returned each time the supplier is invoked.</source>
          <target state="translated">공급 업체가 호출 될 때마다 고유 한 결과가 반환 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="198941742d95f771d09454ad8b8b1eb431801562" translate="yes" xml:space="preserve">
          <source>There is no requirement that a new or distinct result be returned each time the supplier is invoked.</source>
          <target state="translated">공급 업체가 호출 될 때마다 새롭거나 고유 한 결과가 반환 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ac505bd21b647e3b0d66513534387f91f440e63" translate="yes" xml:space="preserve">
          <source>There is no requirement that a process represented by a &lt;code&gt;Process&lt;/code&gt; object execute asynchronously or concurrently with respect to the Java process that owns the &lt;code&gt;Process&lt;/code&gt; object.</source>
          <target state="translated">a로 표현하는 과정한다는 요구 사항이 없습니다 &lt;code&gt;Process&lt;/code&gt; 개체가 소유하는 Java 프로세스와 비동기 적으로 또는 동시에 실행 &lt;code&gt;Process&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="c16939470ebf7792b98ec8e5a304d0db0649596f" translate="yes" xml:space="preserve">
          <source>There is no requirement that a thread that releases a permit must have acquired that permit by calling &lt;a href=&quot;#acquire()&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt;. Correct usage of a semaphore is established by programming convention in the application.</source>
          <target state="translated">허가를 해제하는 스레드가 &lt;a href=&quot;#acquire()&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 허가를 획득 했어야한다는 요구 사항은 없습니다 . 세마포어의 올바른 사용은 응용 프로그램의 프로그래밍 규칙에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7d6e3be26ab58c8cff0d781adf4ccda3335e3f3e" translate="yes" xml:space="preserve">
          <source>There is no requirement that a thread that releases a permit must have acquired that permit by calling &lt;a href=&quot;#acquire()&quot;&gt;&lt;code&gt;acquire&lt;/code&gt;&lt;/a&gt;. Correct usage of a semaphore is established by programming convention in the application.</source>
          <target state="translated">권한을 해제하는 스레드가 &lt;a href=&quot;#acquire()&quot;&gt; &lt;code&gt;acquire&lt;/code&gt; &lt;/a&gt; 를 호출 하여 해당 권한을 획득해야한다는 요구 사항은 없습니다 . 세마포어의 올바른 사용은 응용 프로그램의 프로그래밍 규칙에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6bb1589cbaa1bcec5ff870e1e9b12d1f77370ebe" translate="yes" xml:space="preserve">
          <source>There is no requirement that a thread that releases a permit must have acquired that permit by calling &lt;a href=&quot;semaphore#acquire--&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt;. Correct usage of a semaphore is established by programming convention in the application.</source>
          <target state="translated">허가를 해제하는 스레드가 &lt;a href=&quot;semaphore#acquire--&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 해당 허가를 획득해야 할 필요는 없습니다 . 세마포어의 올바른 사용법은 응용 프로그램의 프로그래밍 규칙에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d19982f377f29e5caf430a892cc8364a3737d224" translate="yes" xml:space="preserve">
          <source>There is no requirement that a thread that releases a permit must have acquired that permit by calling &lt;a href=&quot;semaphore#acquire--&quot;&gt;&lt;code&gt;acquire&lt;/code&gt;&lt;/a&gt;. Correct usage of a semaphore is established by programming convention in the application.</source>
          <target state="translated">허가를 해제하는 스레드가 &lt;a href=&quot;semaphore#acquire--&quot;&gt; &lt;code&gt;acquire&lt;/code&gt; &lt;/a&gt; 를 호출 하여 해당 허가를 획득해야 할 필요는 없습니다 . 세마포어의 올바른 사용법은 응용 프로그램의 프로그래밍 규칙에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="097e8899c7da1936057fe5002a0dd8a4411bffdd" translate="yes" xml:space="preserve">
          <source>There is no requirement that the process represented by a &lt;code&gt;
 Process&lt;/code&gt; object execute asynchronously or concurrently with respect to the Java process that owns the &lt;code&gt;Process&lt;/code&gt; object.</source>
          <target state="translated">a로 표현하는 과정한다는 요구 사항이 없습니다 &lt;code&gt; Process&lt;/code&gt; 개체가 소유하는 Java 프로세스와 비동기 적으로 또는 동시에 실행 &lt;code&gt;Process&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="f87607fb5edefaad832093c1a18ed5623b9f0f26" translate="yes" xml:space="preserve">
          <source>There is no restriction on the number of client threads that may be simultaneously accessing the same doc. Therefore, all implementations of interface &lt;code&gt;Doc&lt;/code&gt; must be designed to be multiple thread safe.</source>
          <target state="translated">동일한 문서에 동시에 액세스 할 수있는 클라이언트 스레드 수에는 제한이 없습니다. 따라서 인터페이스 &lt;code&gt;Doc&lt;/code&gt; 의 모든 구현은 다중 스레드로부터 안전하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a1210cbd94c899524cbebe37d1b7a14d3758c7b6" translate="yes" xml:space="preserve">
          <source>There is no restriction on the number of client threads that may be simultaneously accessing the same doc. Therefore, all implementations of interface Doc must be designed to be multiple thread safe.</source>
          <target state="translated">동일한 문서에 동시에 액세스 할 수있는 클라이언트 스레드 수에는 제한이 없습니다. 따라서 Doc 인터페이스의 모든 구현은 다중 스레드 안전하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="54d1bdd3c5393ebf87fe28c474c4187eeec91d09" translate="yes" xml:space="preserve">
          <source>There is no restriction on the number of client threads that may be simultaneously accessing the same multidoc. Therefore, all implementations of interface MultiDoc must be designed to be multiple thread safe. In fact, a client thread could be adding docs to the end of the (conceptual) list while a Print Job thread is simultaneously obtaining docs from the beginning of the list; provided the multidoc object synchronizes the threads properly, the two threads will not interfere with each other</source>
          <target state="translated">동일한 멀티 도크에 동시에 액세스 할 수있는 클라이언트 스레드 수에는 제한이 없습니다. 따라서 MultiDoc 인터페이스의 모든 구현은 다중 스레드 안전하도록 설계되어야합니다. 실제로, 클라이언트 스레드는 (개념적) 목록의 끝에 문서를 추가하는 반면 인쇄 작업 스레드는 목록의 처음부터 문서를 동시에 가져옵니다. multidoc 객체가 스레드를 올바르게 동기화하면 두 스레드가 서로 간섭하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9957dc281beac2f6bbba1b838150d8a8101149b9" translate="yes" xml:space="preserve">
          <source>There is no restriction on the number of client threads that may be simultaneously accessing the same multidoc. Therefore, all implementations of interface MultiDoc must be designed to be multiple thread safe. In fact, a client thread could be adding docs to the end of the (conceptual) list while a Print Job thread is simultaneously obtaining docs from the beginning of the list; provided the multidoc object synchronizes the threads properly, the two threads will not interfere with each other.</source>
          <target state="translated">동일한 다중 문서에 동시에 액세스 할 수있는 클라이언트 스레드 수에는 제한이 없습니다. 따라서 MultiDoc 인터페이스의 모든 구현은 다중 스레드로부터 안전하도록 설계되어야합니다. 사실, 클라이언트 스레드는 (개념적) 목록 끝에 문서를 추가하고 인쇄 작업 스레드는 목록의 시작 부분에서 문서를 동시에 가져올 수 있습니다. multidoc 객체가 스레드를 올바르게 동기화하면 두 스레드가 서로 간섭하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b4a3972e1a2f7f3338a732047fe875411d8907" translate="yes" xml:space="preserve">
          <source>There is no restriction on the value of &lt;code&gt;fromIndex&lt;/code&gt;. If it is negative, it has the same effect as if it were zero: this entire string may be searched. If it is greater than the length of this string, it has the same effect as if it were equal to the length of this string: &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;fromIndex&lt;/code&gt; 값에는 제한이 없습니다 . 음수이면 0 인 것과 같은 효과를 갖습니다.이 전체 문자열을 검색 할 수 있습니다. 이 문자열의 길이보다 큰 경우이 문자열의 길이와 같은 효과를 갖습니다. &lt;code&gt;-1&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e340b37b39ba453a5230e865c6c6369e8aa4a836" translate="yes" xml:space="preserve">
          <source>There is no root in the tree</source>
          <target state="translated">나무에는 뿌리가 없다</target>
        </trans-unit>
        <trans-unit id="41d4b46878c902aebcab2313c7f766261a893b1b" translate="yes" xml:space="preserve">
          <source>There is one circumstance under which &lt;code&gt;putSpi, removeSpi and
 childSpi&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;putSpi, removeSpi and childSpi&lt;/code&gt; 에는 한 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="514e11614a5cff7c22ae4d822f5dd9cd11012a75" translate="yes" xml:space="preserve">
          <source>There is one subclass of this class for each non-boolean primitive type.</source>
          <target state="translated">부울이 아닌 기본 유형마다이 클래스의 서브 클래스가 하나씩 있습니다.</target>
        </trans-unit>
        <trans-unit id="633f37c2f9ed69daba67e576cc65222c3b761eee" translate="yes" xml:space="preserve">
          <source>There is only one Configuration object installed in the runtime at any given time. A Configuration object can be installed by calling the &lt;code&gt;setConfiguration&lt;/code&gt; method. The installed Configuration object can be obtained by calling the &lt;code&gt;getConfiguration&lt;/code&gt; method.</source>
          <target state="translated">주어진 시간에 런타임에 하나의 구성 오브젝트 만 설치됩니다. &lt;code&gt;setConfiguration&lt;/code&gt; 메소드 를 호출하여 구성 오브젝트를 설치할 수 있습니다 . &lt;code&gt;getConfiguration&lt;/code&gt; 메소드 를 호출하여 설치된 구성 오브젝트를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70c5e4ecda10caf422eac93731e929117c0b2433" translate="yes" xml:space="preserve">
          <source>There is only one Policy object installed in the runtime at any given time. A Policy object can be installed by calling the &lt;code&gt;setPolicy&lt;/code&gt; method. The installed Policy object can be obtained by calling the &lt;code&gt;getPolicy&lt;/code&gt; method.</source>
          <target state="translated">주어진 시간에 런타임에 하나의 Policy 오브젝트 만 설치됩니다. &lt;code&gt;setPolicy&lt;/code&gt; 메소드 를 호출하여 정책 오브젝트를 설치할 수 있습니다 . 설치된 Policy 오브젝트는 &lt;code&gt;getPolicy&lt;/code&gt; 메소드 를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e8219f9fa1e5ad5fd8b7ff9a0008b52bda96130" translate="yes" xml:space="preserve">
          <source>There is some nonnegative integer</source>
          <target state="translated">음이 아닌 정수가 있습니다</target>
        </trans-unit>
        <trans-unit id="d6aeefc5fc1e3b4b3221ed888ba5591b270dae86" translate="yes" xml:space="preserve">
          <source>There may be more than one method with a particular name and parameter types in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not. This increased flexibility in the virtual machine can be used to implement various language features. For example, covariant returns can be implemented with &lt;a href=&quot;reflect/method#isBridge()&quot;&gt;bridge methods&lt;/a&gt;; the bridge method and the overriding method would have the same signature but different return types.</source>
          <target state="translated">Java 언어는 클래스가 동일한 서명이지만 다른 리턴 유형으로 여러 메소드를 선언하는 것을 금지하지만 Java 가상 머신은 그렇지 않기 때문에 클래스에 특정 이름 및 매개 변수 유형을 가진 메소드가 둘 이상있을 수 있습니다. 가상 머신의 이러한 향상된 유연성을 사용하여 다양한 언어 기능을 구현할 수 있습니다. 예를 들어, 공변 반환은 &lt;a href=&quot;reflect/method#isBridge()&quot;&gt;브리지 메서드&lt;/a&gt; 로 구현 될 수 있습니다 . 브리지 메서드와 재정의 메서드는 동일한 서명을 가지지 만 반환 유형이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ba97abd4748de1b1cab09b1271aeb675d2d60a5d" translate="yes" xml:space="preserve">
          <source>There may be more than one method with matching name and parameter types in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not. This increased flexibility in the virtual machine can be used to implement various language features. For example, covariant returns can be implemented with &lt;a href=&quot;reflect/method#isBridge()&quot;&gt;bridge methods&lt;/a&gt;; the bridge method and the overriding method would have the same signature but different return types. This method would return the overriding method as it would have a more specific return type.</source>
          <target state="translated">Java 언어는 클래스가 동일한 서명이지만 다른 리턴 유형을 가진 여러 메소드를 선언하는 것을 금지하는 반면 Java 가상 머신은 그렇지 않기 때문에 클래스에 이름 및 매개 변수 유형이 일치하는 메소드가 둘 이상있을 수 있습니다. 가상 머신의 이러한 향상된 유연성을 사용하여 다양한 언어 기능을 구현할 수 있습니다. 예를 들어, 공변 반환은 &lt;a href=&quot;reflect/method#isBridge()&quot;&gt;브리지 메서드&lt;/a&gt; 로 구현 될 수 있습니다 . 브리지 메서드와 재정의 메서드는 동일한 서명을 가지지 만 반환 유형이 다릅니다. 이 메서드는보다 구체적인 반환 유형을 가지므로 재정의 메서드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2134dbfd5d5d90acff44e032a45a72212d5e15eb" translate="yes" xml:space="preserve">
          <source>There must be at least one non-omitted pred function.</source>
          <target state="translated">생략되지 않은 pred 함수가 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d456bd878e06fa4545ebcea4f3178823c1af57a" translate="yes" xml:space="preserve">
          <source>There should never be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable.</source>
          <target state="translated">&quot;xml&quot;접두사에 대한 start / endPrefixMapping 이벤트가 있어서는 안됩니다. 사전 선언되고 변경할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dd857f58606b9ccfec2f4438f9f07a8293a4e421" translate="yes" xml:space="preserve">
          <source>There will typically be one provider per platform, such as Windows or Linux, to support accessibility for screen readers and magnifiers. However, more than one service provider can be activated. For example, a test tool which provides visual results obtained by interrogating the Java Accessibility API can be activated along with the activation of the support for screen readers and screen magnifiers.</source>
          <target state="translated">일반적으로 화면 판독기 및 돋보기에 대한 접근성을 지원하기 위해 플랫폼 당 하나의 공급자 (예 : Windows 또는 Linux)가 있습니다. 그러나 둘 이상의 서비스 공급자를 활성화 할 수 있습니다. 예를 들어, Java Accessibility API를 조사하여 얻은 시각적 결과를 제공하는 테스트 도구는 화면 판독기 및 화면 돋보기 지원 활성화와 함께 활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2567bf148c60cd0704ecaf928436c03eebe56e55" translate="yes" xml:space="preserve">
          <source>There're various ways user can hook up his own HTTP cookie management behavior, e.g.</source>
          <target state="translated">사용자가 자신의 HTTP 쿠키 관리 동작을 연결하는 다양한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d7377bb136e7ab1b807921fa3bbfd29b224b919" translate="yes" xml:space="preserve">
          <source>Therefore, the predicate set on a &lt;code&gt;FilteredRowSet&lt;/code&gt; object must be considered as bi-directional and the set criterion as the gating mechanism for all views and updates to the &lt;code&gt;FilteredRowSet&lt;/code&gt; object. Any attempt to update the &lt;code&gt;FilteredRowSet&lt;/code&gt; that violates the criterion will result in a &lt;code&gt;SQLException&lt;/code&gt; object being thrown.</source>
          <target state="translated">따라서, 술어에 집합 &lt;code&gt;FilteredRowSet&lt;/code&gt; 목적은 양방향 및 모든 뷰 및 업데이트 게이팅 메커니즘 설정된 기준으로서 고려되어야 &lt;code&gt;FilteredRowSet&lt;/code&gt; 개체. &lt;code&gt;FilteredRowSet&lt;/code&gt; 을 위반 하는 FilteredRowSet 을 업데이트하려고 하면 &lt;code&gt;SQLException&lt;/code&gt; 객체가 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="508f2c406ee1e58b8f5ad1a09d306c653186d83b" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;SyncProvider&lt;/code&gt; implementations are bundled with the reference implementation, which makes them always available to &lt;code&gt;RowSet&lt;/code&gt; implementations. &lt;code&gt;SyncProvider&lt;/code&gt; implementations make themselves available by being registered with the &lt;code&gt;SyncFactory&lt;/code&gt; singleton. When a &lt;code&gt;RowSet&lt;/code&gt; object requests a provider, by specifying it in the constructor or as an argument to the &lt;code&gt;CachedRowSet&lt;/code&gt; method &lt;code&gt;setSyncProvider&lt;/code&gt;, the &lt;code&gt;SyncFactory&lt;/code&gt; singleton checks to see if the requested provider has been registered with it. If it has, the &lt;code&gt;SyncFactory&lt;/code&gt; creates an instance of it and passes it to the requesting &lt;code&gt;RowSet&lt;/code&gt; object. If the &lt;code&gt;SyncProvider&lt;/code&gt; implementation that is specified has not been registered, the &lt;code&gt;SyncFactory&lt;/code&gt; singleton causes a &lt;code&gt;SyncFactoryException&lt;/code&gt; object to be thrown. If no provider is specified, the &lt;code&gt;SyncFactory&lt;/code&gt; singleton will create an instance of the default provider implementation, &lt;code&gt;RIOptimisticProvider&lt;/code&gt;, and pass it to the requesting &lt;code&gt;RowSet&lt;/code&gt; object.</source>
          <target state="translated">이러한 &lt;code&gt;SyncProvider&lt;/code&gt; 구현은 참조 구현과 함께 번들로 제공되므로 &lt;code&gt;RowSet&lt;/code&gt; 구현에서 항상 사용할 수 있습니다 . &lt;code&gt;SyncProvider&lt;/code&gt; 구현은 &lt;code&gt;SyncFactory&lt;/code&gt; 싱글 톤 에 등록되어 사용 가능합니다 . 때 &lt;code&gt;RowSet&lt;/code&gt; 객체는 생성자 또는의 인수로서 지정함으로써, 제공을 요청 &lt;code&gt;CachedRowSet&lt;/code&gt; 메소드 &lt;code&gt;setSyncProvider&lt;/code&gt; 상기 &lt;code&gt;SyncFactory&lt;/code&gt; 에 요청 제공자가 등록되어 있는지 확인 싱글 표시한다. 있는 경우 &lt;code&gt;SyncFactory&lt;/code&gt; 는 인스턴스를 생성하여 요청하는 &lt;code&gt;RowSet&lt;/code&gt; 에 전달합니다.목적. 는 IF &lt;code&gt;SyncProvider&lt;/code&gt; 지정 구현이 등록되지 않은는 &lt;code&gt;SyncFactory&lt;/code&gt; 에 싱글은 원인 &lt;code&gt;SyncFactoryException&lt;/code&gt; 객체가 throw. 공급자가 지정되지 않은 경우 &lt;code&gt;SyncFactory&lt;/code&gt; 싱글 톤은 기본 공급자 구현 인 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 의 인스턴스를 만들고 요청하는 &lt;code&gt;RowSet&lt;/code&gt; 개체에 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="0fa6040eb2b02513907d3a38e0abe79567d2b28a" translate="yes" xml:space="preserve">
          <source>These APIs model declarations and types of the Java programming language, and define interfaces for tools such as compilers which can be invoked from a program.</source>
          <target state="translated">이러한 API는 Java 프로그래밍 언어의 선언 및 유형을 모델링하고 프로그램에서 호출 할 수있는 컴파일러와 같은 도구에 대한 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8405dc8d6e96295949c0c54f86ccd888ec7eea86" translate="yes" xml:space="preserve">
          <source>These IDs are the string form of a &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 ID는 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 의 문자열 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="631b878b0ebefad46a326de5071673b0a67c7ab6" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#algorithmparametergenerator-algorithms&quot;&gt; AlgorithmParameterGenerator section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#algorithmparametergenerator-algorithms&quot;&gt;AlgorithmParameterGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b4e71dfd3212a92bf027c0a518f7b889484ef7b" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#algorithmparameters-algorithms&quot;&gt; AlgorithmParameters section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#algorithmparameters-algorithms&quot;&gt;AlgorithmParameters 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f1ee4ebecb85d3bec7c2ace6256272d6386866" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#keyfactory-algorithms&quot;&gt; KeyFactory section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#keyfactory-algorithms&quot;&gt;KeyFactory 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c2c57df12cc4620800eb20ecc3f898adfb43697" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#keygenerator-algorithms&quot;&gt; KeyGenerator section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#keygenerator-algorithms&quot;&gt;KeyGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd46e1a239bac9d173c7fde28f7662e24c021745" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#keypairgenerator-algorithms&quot;&gt; KeyPairGenerator section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#keypairgenerator-algorithms&quot;&gt;KeyPairGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd271b39c88e6341c8b4f26677a469b412a58b57" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#mac-algorithms&quot;&gt; Mac section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#mac-algorithms&quot;&gt;Mac 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3825569337e6a25c5ecf05277da5594fd76ab773" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#messagedigest-algorithms&quot;&gt; MessageDigest section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;MessageDigest 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd691ad65238fef472ba79b9c93faa459d1b7590" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#secretkeyfactory-algorithms&quot;&gt; SecretKeyFactory section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#secretkeyfactory-algorithms&quot;&gt;SecretKeyFactory 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="263cf3bda54999e2ef74f653be2bb0b98dc6e03f" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#signature-algorithms&quot;&gt; Signature section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#signature-algorithms&quot;&gt;서명 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac6d107158b337a6c06b66cc752f623087b39c6" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameterGenerator&quot;&gt; AlgorithmParameterGenerator section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameterGenerator&quot;&gt;AlgorithmParameterGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2840e4cdcf1ea5e28eecc02068cd6e631114c12e" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameters&quot;&gt; AlgorithmParameters section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameters&quot;&gt;AlgorithmParameters 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7810b58cc40d92a27956a4ca52be2a76493d1bab" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt; KeyFactory section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt;KeyFactory 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a50f9efd915eeed3ad86d74499ef1250eabefdda" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyGenerator&quot;&gt; KeyGenerator section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyGenerator&quot;&gt;KeyGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="24c1f8a9dcc7a5506f057dba5d8bfbe7a8fd8ab2" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt; KeyPairGenerator section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;KeyPairGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="67fa782ff8eb29fae6354c59022ac3e4584f2bd2" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Mac&quot;&gt; Mac section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Mac&quot;&gt;Mac 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="df11e8427aa46377243a3bc2fdea20b313fc069f" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt; MessageDigest section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;MessageDigest 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5d0b5ae813100c512f39daa5af7097e9f5e4bc52" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecretKeyFactory&quot;&gt; SecretKeyFactory section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecretKeyFactory&quot;&gt;SecretKeyFactory 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fc5cf5ef0ceb706cddfb7a9b2c6fe158ff062a97" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Signature&quot;&gt; Signature section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Signature&quot;&gt;서명 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="10bbd31b59aad04b291f617b226c818f14f26a0a" translate="yes" xml:space="preserve">
          <source>These are &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007A'&lt;/code&gt;. If &lt;code&gt;radix&lt;/code&gt; is &lt;var&gt;N&lt;/var&gt;, then the first &lt;var&gt;N&lt;/var&gt; of these characters are used as radix-&lt;var&gt;N&lt;/var&gt; digits in the order shown. Thus, the digits for hexadecimal (radix 16) are &lt;code&gt;0123456789abcdef&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase()&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">이들은 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007A'&lt;/code&gt; 입니다. 경우 &lt;code&gt;radix&lt;/code&gt; 인 &lt;var&gt;N&lt;/var&gt; 을 한 후 제 &lt;var&gt;N&lt;/var&gt; 이 문자는 기수 -로서 사용되는 &lt;var&gt;N&lt;/var&gt; 에 도시 된 순서로 자리. 따라서 16 진수 (기수 16)의 숫자는 &lt;code&gt;0123456789abcdef&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에 대해 &lt;a href=&quot;string#toUpperCase()&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0bd70779c56b886df3b68e00d621608fc2cd850" translate="yes" xml:space="preserve">
          <source>These are &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007A'&lt;/code&gt;. If &lt;code&gt;radix&lt;/code&gt; is &lt;var&gt;N&lt;/var&gt;, then the first &lt;var&gt;N&lt;/var&gt; of these characters are used as radix-&lt;var&gt;N&lt;/var&gt; digits in the order shown. Thus, the digits for hexadecimal (radix 16) are &lt;code&gt;0123456789abcdef&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">이들은 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007A'&lt;/code&gt; 입니다. 경우 &lt;code&gt;radix&lt;/code&gt; 인 &lt;var&gt;N&lt;/var&gt; 을 한 후 제 &lt;var&gt;N&lt;/var&gt; 이 문자는 기수 -로서 사용되는 &lt;var&gt;N&lt;/var&gt; 에 도시 된 순서로 자리. 따라서 16 진 (기수 16)의 자릿수는 &lt;code&gt;0123456789abcdef&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에서 &lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a604fade3d0169b49ea521e11dcac00afe51a7" translate="yes" xml:space="preserve">
          <source>These are &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007a'&lt;/code&gt;. If &lt;code&gt;radix&lt;/code&gt; is &lt;var&gt;N&lt;/var&gt;, then the first &lt;var&gt;N&lt;/var&gt; of these characters are used as radix-&lt;var&gt;N&lt;/var&gt; digits in the order shown. Thus, the digits for hexadecimal (radix 16) are &lt;code&gt;0123456789abcdef&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase()&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">이들은 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007a'&lt;/code&gt; 입니다. 경우 &lt;code&gt;radix&lt;/code&gt; 인 &lt;var&gt;N&lt;/var&gt; 을 한 후 제 &lt;var&gt;N&lt;/var&gt; 이 문자는 기수 -로서 사용되는 &lt;var&gt;N&lt;/var&gt; 에 도시 된 순서로 자리. 따라서 16 진수 (기수 16)의 숫자는 &lt;code&gt;0123456789abcdef&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에 대해 &lt;a href=&quot;string#toUpperCase()&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce73c7a8bcb9b77ceb02b691c9f5e1120078896" translate="yes" xml:space="preserve">
          <source>These are &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007a'&lt;/code&gt;. If &lt;code&gt;radix&lt;/code&gt; is &lt;var&gt;N&lt;/var&gt;, then the first &lt;var&gt;N&lt;/var&gt; of these characters are used as radix-&lt;var&gt;N&lt;/var&gt; digits in the order shown. Thus, the digits for hexadecimal (radix 16) are &lt;code&gt;0123456789abcdef&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">이들은 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007a'&lt;/code&gt; 입니다. 경우 &lt;code&gt;radix&lt;/code&gt; 인 &lt;var&gt;N&lt;/var&gt; 을 한 후 제 &lt;var&gt;N&lt;/var&gt; 이 문자는 기수 -로서 사용되는 &lt;var&gt;N&lt;/var&gt; 에 도시 된 순서로 자리. 따라서 16 진 (기수 16)의 자릿수는 &lt;code&gt;0123456789abcdef&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에서 &lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1959b44b606d1297e43332ac44b1adaf84cdd4db" translate="yes" xml:space="preserve">
          <source>These are some of the Unicode characters for which this method returns &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">다음은이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 일부 유니 코드 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="fa0898612837a31f540bec1dccf10ba5ee8752d0" translate="yes" xml:space="preserve">
          <source>These are some of the points that must be considered before using this interface throughout an application.</source>
          <target state="translated">응용 프로그램 전체에서이 인터페이스를 사용하기 전에 고려해야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b003314e199b67286aa0a74af0f5fe08230f55" translate="yes" xml:space="preserve">
          <source>These are the characters &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0037'&lt;/code&gt;.</source>
          <target state="translated">문자 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0037'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3bd9664c12b4b82014197950bcb6a76aced5ea74" translate="yes" xml:space="preserve">
          <source>These are the characters &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u0066'&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase()&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">문자 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u0066'&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에 대해 &lt;a href=&quot;string#toUpperCase()&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08694341e216489e339c217c51678557a14dc442" translate="yes" xml:space="preserve">
          <source>These are the characters &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u0066'&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">문자 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u0066'&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에서 &lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b84747262f07da09c94e7a4dea245f9f7c3b81" translate="yes" xml:space="preserve">
          <source>These are the main advantages of using a &lt;code&gt;DataSource&lt;/code&gt; object to make a connection:</source>
          <target state="translated">다음은 &lt;code&gt;DataSource&lt;/code&gt; 개체를 사용하여 연결 하는 주요 이점입니다 .</target>
        </trans-unit>
        <trans-unit id="14bf67841c7333a36b970333f8654472760a62e1" translate="yes" xml:space="preserve">
          <source>These are the views that represent the child elements of the element this view represents (The logical view to translate to a physical view).</source>
          <target state="translated">이보기가 나타내는 요소의 하위 요소를 나타내는보기입니다 (물리적보기로 변환하는 논리적보기).</target>
        </trans-unit>
        <trans-unit id="0dc25ce5ef285fd983e7cc3db174ba44009404f3" translate="yes" xml:space="preserve">
          <source>These are the views that represent the child elements of the element this view represents (The logical view to translate to a physical view). These are not directly children of this view. These are either placed into the rows directly or used for the purpose of breaking into smaller chunks, to form the physical view.</source>
          <target state="translated">이보기가 나타내는 요소의 하위 요소를 나타내는보기입니다 (물리적보기로 변환하는 논리적보기). 이들은이 뷰의 직접적인 자식이 아닙니다. 이들은 행에 직접 배치되거나 물리적 뷰를 형성하기 위해 더 작은 청크로 분할 할 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99b100126a9566a5dfd6a5042da372581f55c4cf" translate="yes" xml:space="preserve">
          <source>These are used to set the initial settings for the initially displayed print service. Values which are not supported by the print service are ignored. As the user browses print services, attributes and values are copied to the new display. If a user browses a print service which does not support a particular attribute-value, the default for that service is used as the new value to be copied.</source>
          <target state="translated">처음에 표시되는 인쇄 서비스의 초기 설정을 설정하는 데 사용됩니다. 인쇄 서비스에서 지원하지 않는 값은 무시됩니다. 사용자가 인쇄 서비스를 탐색하면 속성 및 값이 새 디스플레이에 복사됩니다. 사용자가 특정 속성 값을 지원하지 않는 인쇄 서비스를 탐색하면 해당 서비스의 기본값이 복사 할 새 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="23359efff4d455ce40dbe667ac079776cbdfec68" translate="yes" xml:space="preserve">
          <source>These behaviours allow an application to directly pass the user settings returned from &lt;code&gt;printDialog(PrintRequestAttributeSet attributes&lt;/code&gt; to this print() method.</source>
          <target state="translated">이러한 비헤이비어를 통해 응용 프로그램은 &lt;code&gt;printDialog(PrintRequestAttributeSet attributes&lt;/code&gt; 에서 반환 된 사용자 설정 을이 print () 메서드 로 직접 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3be6610f951c812ed29655c7c3c7855bd120baa2" translate="yes" xml:space="preserve">
          <source>These bulk operations accept a &lt;code&gt;parallelismThreshold&lt;/code&gt; argument. Methods proceed sequentially if the current map size is estimated to be less than the given threshold. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; suppresses all parallelism. Using a value of &lt;code&gt;1&lt;/code&gt; results in maximal parallelism by partitioning into enough subtasks to fully utilize the &lt;a href=&quot;forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;&lt;/a&gt; that is used for all parallel computations. Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput.</source>
          <target state="translated">이러한 대량 작업은 &lt;code&gt;parallelismThreshold&lt;/code&gt; 인수를 허용합니다 . 현재 맵 크기가 주어진 임계 값보다 작은 것으로 추정되는 경우 메서드가 순차적으로 진행됩니다. &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값을 사용하면 모든 병렬 처리가 억제됩니다. 값 &lt;code&gt;1&lt;/code&gt; 을 사용하면 모든 병렬 계산에 사용되는 &lt;a href=&quot;forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; &lt;/a&gt; 을 완전히 활용하기에 충분한 하위 작업으로 분할하여 최대 병렬 처리가 발생합니다 . 일반적으로 처음에는 이러한 극단 값 중 하나를 선택한 다음 오버 헤드와 처리량을 상쇄하는 중간 값을 사용하여 성능을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="8e8017b0b68c1f6f870bc8aa6a50aadf98ce71b6" translate="yes" xml:space="preserve">
          <source>These bulk operations accept a &lt;code&gt;parallelismThreshold&lt;/code&gt; argument. Methods proceed sequentially if the current map size is estimated to be less than the given threshold. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; suppresses all parallelism. Using a value of &lt;code&gt;1&lt;/code&gt; results in maximal parallelism by partitioning into enough subtasks to fully utilize the &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;&lt;/a&gt; that is used for all parallel computations. Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput.</source>
          <target state="translated">이러한 대량 작업은 &lt;code&gt;parallelismThreshold&lt;/code&gt; 인수를 허용합니다 . 현재 맵 크기가 주어진 임계 값보다 작은 것으로 추정되면 방법이 순차적으로 진행됩니다. &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값을 사용하면 모든 병렬 처리가 억제됩니다. 값 &lt;code&gt;1&lt;/code&gt; 을 사용하면 모든 병렬 계산에 사용되는 &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; &lt;/a&gt; 을 완전히 활용할 수 있도록 충분한 하위 작업으로 분할하여 최대 병렬 처리가 가능합니다 . 일반적으로 처음에는 이러한 극단적 인 값 중 하나를 선택한 다음 오버 헤드와 처리량을 모두 상쇄하는 중간 값을 사용하여 성능을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="9b9c967868c87c3fa1c1eb6a72aaec7b24732e2f" translate="yes" xml:space="preserve">
          <source>These byte totals, as well as the &lt;a href=&quot;#getBytesRead()&quot;&gt;total bytes read&lt;/a&gt; and the &lt;a href=&quot;#getBytesWritten()&quot;&gt;total bytes written&lt;/a&gt; values, will be updated even in the event that a &lt;a href=&quot;dataformatexception&quot;&gt;&lt;code&gt;DataFormatException&lt;/code&gt;&lt;/a&gt; is thrown to reflect the amount of data consumed and produced before the exception occurred.</source>
          <target state="translated">이러한 &lt;a href=&quot;#getBytesRead()&quot;&gt;총 바이트 수&lt;/a&gt; 와 읽은 총 바이트 수 및 &lt;a href=&quot;#getBytesWritten()&quot;&gt;기록&lt;/a&gt; 된 총 바이트 값 은 예외가 발생하기 전에 소비되고 생성 된 데이터 양을 반영하기 위해 &lt;a href=&quot;dataformatexception&quot;&gt; &lt;code&gt;DataFormatException&lt;/code&gt; &lt;/a&gt; 이 발생 하는 경우에도 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="61e99440ec085de26d7fa6b38952f9639f22cdf5" translate="yes" xml:space="preserve">
          <source>These callbacks are used when the default rules for URL hostname verification fail.</source>
          <target state="translated">이러한 콜백은 URL 호스트 이름 확인에 대한 기본 규칙이 실패 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd87981d1c383695eeedcb97149451439e2b8d64" translate="yes" xml:space="preserve">
          <source>These can be long lived, and frequently correspond to an entire login session for some user. The session specifies a particular cipher suite which is being actively used by all connections in that session, as well as the identities of the session's client and server.</source>
          <target state="translated">이들은 오래 지속될 수 있으며 일부 사용자의 전체 로그인 세션에 해당합니다. 세션은 세션의 클라이언트 및 서버의 ID뿐만 아니라 해당 세션의 모든 연결에서 적극적으로 사용되는 특정 암호 스위트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="30905a97f0d453c12f6b8ea895f71cbb656d45d8" translate="yes" xml:space="preserve">
          <source>These certificates are managed and vouched for by &lt;em&gt;Certificate Authorities&lt;/em&gt; (CAs). CAs are services which create certificates by placing data in the X.509 standard format and then digitally signing that data. CAs act as trusted third parties, making introductions between principals who have no direct knowledge of each other. CA certificates are either signed by themselves, or by some other CA such as a &quot;root&quot; CA.</source>
          <target state="translated">이 인증서는 &lt;em&gt;인증 기관&lt;/em&gt; (CA)에서 관리하고 보증합니다 . CA는 X.509 표준 형식으로 데이터를 배치 한 다음 해당 데이터에 디지털 서명하여 인증서를 작성하는 서비스입니다. CA는 신뢰할 수있는 제 3 자 역할을하여 서로에 대한 직접적인 지식이없는 보안 주체를 소개합니다. CA 인증서는 자체적으로 또는 &quot;루트&quot;CA와 같은 다른 CA에 의해 서명됩니다.</target>
        </trans-unit>
        <trans-unit id="e7654f792c1fa0442a29a75f4478a4533c2aa670" translate="yes" xml:space="preserve">
          <source>These certificates are widely used to support authentication and other functionality in Internet security systems. Common applications include Privacy Enhanced Mail (PEM), Transport Layer Security (SSL), code signing for trusted software distribution, and Secure Electronic Transactions (SET).</source>
          <target state="translated">이 인증서는 인터넷 보안 시스템에서 인증 및 기타 기능을 지원하는 데 널리 사용됩니다. 일반적인 응용 프로그램으로는 PEM (Privacy Enhanced Mail), SSL (Transport Layer Security), 신뢰할 수있는 소프트웨어 배포를위한 코드 서명 및 SET (Secure Electronic Transactions)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcf252c78cf14eb2a837fd99fd0be8d1928c2eee" translate="yes" xml:space="preserve">
          <source>These choices are set in each implementation and are not directly managed by the &lt;code&gt;SecureRandom&lt;/code&gt; API. Check your DRBG provider's documentation to find an appropriate implementation for the situation.</source>
          <target state="translated">이러한 선택은 각 구현에서 설정되며 &lt;code&gt;SecureRandom&lt;/code&gt; API에 의해 직접 관리되지 않습니다 . 상황에 적합한 구현을 찾으려면 DRBG 제공 업체의 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9e42e0ff806cf170a11e36b37a054c3229ccff88" translate="yes" xml:space="preserve">
          <source>These classes are capable of formatting dates, numbers, and messages, parsing; searching and sorting strings; and iterating over characters, words, sentences, and line breaks. This package contains three main groups of classes and interfaces:</source>
          <target state="translated">이 클래스는 날짜, 숫자 및 메시지를 형식화하고 구문 분석 할 수 있습니다. 문자열 검색 및 정렬; 문자, 단어, 문장 및 줄 바꿈을 반복합니다. 이 패키지에는 세 가지 주요 클래스 및 인터페이스 그룹이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6318825cf21ef29caa7cfa108177774e36244df" translate="yes" xml:space="preserve">
          <source>These classes are designed to be used while the corresponding &lt;code&gt;LookAndFeel&lt;/code&gt; class has been installed (&lt;code&gt;UIManager.setLookAndFeel(new &lt;i&gt;XXX&lt;/i&gt;LookAndFeel())&lt;/code&gt;). Using them while a different &lt;code&gt;LookAndFeel&lt;/code&gt; is installed may produce unexpected results, including exceptions. Additionally, changing the &lt;code&gt;LookAndFeel&lt;/code&gt; maintained by the &lt;code&gt;UIManager&lt;/code&gt; without updating the corresponding &lt;code&gt;ComponentUI&lt;/code&gt; of any &lt;code&gt;JComponent&lt;/code&gt;s may also produce unexpected results, such as the wrong colors showing up, and is generally not encouraged.</source>
          <target state="translated">이러한 클래스는 해당 &lt;code&gt;LookAndFeel&lt;/code&gt; 클래스가 설치된 동안 사용하도록 설계되었습니다 ( &lt;code&gt;UIManager.setLookAndFeel(new &lt;i&gt;XXX&lt;/i&gt;LookAndFeel())&lt;/code&gt; ). 다른 &lt;code&gt;LookAndFeel&lt;/code&gt; 이 설치된 상태에서 사용하면 예외를 포함하여 예기치 않은 결과가 발생할 수 있습니다. 또한 &lt;code&gt;JComponent&lt;/code&gt; 의 해당 &lt;code&gt;ComponentUI&lt;/code&gt; 를 업데이트하지 않고 &lt;code&gt;UIManager&lt;/code&gt; 에서 유지 관리 하는 &lt;code&gt;LookAndFeel&lt;/code&gt; 을 변경하면 잘못된 색상이 표시되는 등 예기치 않은 결과가 발생할 수 있으며 일반적으로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca888f834a79bc5727a72955ff3d1e6b86d9c717" translate="yes" xml:space="preserve">
          <source>These classes are not general purpose replacements for &lt;code&gt;
 java.lang.Integer&lt;/code&gt; and related classes. They do &lt;em&gt;not&lt;/em&gt; define methods such as &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;
 compareTo&lt;/code&gt;. Because atomic variables are expected to be mutated, they are poor choices for hash table keys.</source>
          <target state="translated">이러한 클래스는 &lt;code&gt; java.lang.Integer&lt;/code&gt; 및 관련 클래스에 대한 범용 대체가 아닙니다 . &lt;code&gt;equals&lt;/code&gt; , &lt;code&gt;hashCode&lt;/code&gt; 및 &lt;code&gt; compareTo&lt;/code&gt; 와 같은 메소드 는 정의 하지 &lt;em&gt;않습니다&lt;/em&gt; . 원자 변수는 변경 될 것으로 예상되기 때문에 해시 테이블 키에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="536ba11d6da2845bb0c80905149fb7531b460122" translate="yes" xml:space="preserve">
          <source>These comments apply to gain controls in general, not just master gain controls. A line can have more than one gain control. For example, a mixer (which is itself a line) might have a master gain control, an auxiliary return control, a reverb return control, and, on each of its source lines, an individual aux send and reverb send.</source>
          <target state="translated">이 설명은 마스터 게인 컨트롤뿐만 아니라 일반적인 게인 컨트롤에도 적용됩니다. 라인은 하나 이상의 게인 컨트롤을 가질 수 있습니다. 예를 들어, 믹서 (그 자체가 라인 인)는 마스터 게인 컨트롤, 보조 리턴 컨트롤, 리버브 리턴 컨트롤 및 각 소스 라인에서 개별 보조 전송 및 리버브 전송을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="182525e92bb8eaa995d5c702244b1a4f1d994019" translate="yes" xml:space="preserve">
          <source>These conditions are tested against the character information from version 10.0 of the Unicode Standard.</source>
          <target state="translated">이러한 조건은 유니 코드 표준 버전 10.0의 문자 정보에 대해 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="51036f2530440491bfa4fee7adaeaacd963ca219" translate="yes" xml:space="preserve">
          <source>These constants &lt;b&gt;should&lt;/b&gt; be considered complementary to the grade constants. The default setting for the majority of grade settings requires that no data source locks remain when a &lt;code&gt;RowSet&lt;/code&gt; object is disconnected from its data source. The grades &lt;code&gt;GRADE_LOCK_WHEN_MODIFIED&lt;/code&gt; and &lt;code&gt;GRADE_LOCK_WHEN_LOADED&lt;/code&gt; allow a disconnected &lt;code&gt;RowSet&lt;/code&gt; object to have a fine-grained control over the degree of locking.</source>
          <target state="translated">이러한 상수 &lt;b&gt;는&lt;/b&gt; 등급 상수를 보완하는 것으로 간주 &lt;b&gt;되어야&lt;/b&gt; 합니다. 대부분의 성적 설정에 대한 기본 설정에서는 &lt;code&gt;RowSet&lt;/code&gt; 개체가 데이터 소스에서 연결이 끊어 질 때 데이터 소스 잠금이 남아 있지 않아야합니다 . &lt;code&gt;GRADE_LOCK_WHEN_MODIFIED&lt;/code&gt; 및 &lt;code&gt;GRADE_LOCK_WHEN_LOADED&lt;/code&gt; 등급을 사용하면 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체가 잠금 수준을 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b185b37a150dff33728e3a9f01c22ad788650779" translate="yes" xml:space="preserve">
          <source>These constants are explained in the preceding section (4.0).</source>
          <target state="translated">이러한 상수는 이전 섹션 (4.0)에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b94d3dafeba2df086880b1a2cf9128a4df924018" translate="yes" xml:space="preserve">
          <source>These constraints mean that a GUI application with time intensive computing needs at least two threads: 1) a thread to perform the lengthy task and 2) the</source>
          <target state="translated">이러한 제약은 시간 집약적 인 컴퓨팅을 사용하는 GUI 응용 프로그램에 최소 두 개의 스레드가 필요함을 의미합니다. 1) 긴 작업을 수행하는 스레드와 2)</target>
        </trans-unit>
        <trans-unit id="6863080fd292838b064091acab8ec4a7e59422e3" translate="yes" xml:space="preserve">
          <source>These constructors allow you to create a &lt;code&gt;Locale&lt;/code&gt; object with language, country and variant, but you cannot specify script or extensions.</source>
          <target state="translated">이러한 생성자를 사용하면 언어, 국가 및 변형이 있는 &lt;code&gt;Locale&lt;/code&gt; 객체 를 만들 수 있지만 스크립트 나 확장명을 지정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f834728921b0f3ab0a540e3f3bf6b14d71c7bcf" translate="yes" xml:space="preserve">
          <source>These different rule types can be expressed and queried.</source>
          <target state="translated">이러한 다른 규칙 유형을 표현하고 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7dc9733f213a93286a012b485967533fe72f014c" translate="yes" xml:space="preserve">
          <source>These encodings are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other encodings are supported.</source>
          <target state="translated">이러한 인코딩은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt;CertPath Encodings 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 인코딩이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f08e754a38dde7958ef1c6f1638768b615f3f1ca" translate="yes" xml:space="preserve">
          <source>These encodings are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other encodings are supported.</source>
          <target state="translated">이러한 인코딩은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt;CertPath 인코딩 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 인코딩이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b32f25bab2a6f9d22d42132cf2929dcee766e8c6" translate="yes" xml:space="preserve">
          <source>These fields are intended to be applicable in multiple calendar systems. For example, most non-ISO calendar systems define dates as a year, month and day, just with slightly different rules. The documentation of each field explains how it operates.</source>
          <target state="translated">이 필드는 여러 캘린더 시스템에 적용 할 수 있습니다. 예를 들어, 대부분의 비 ISO 캘린더 시스템은 약간 다른 규칙을 사용하여 날짜를 년, 월 및 일로 정의합니다. 각 필드의 설명서는 작동 방식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f71a58fc2f85a34846eba4205dc69caa813474de" translate="yes" xml:space="preserve">
          <source>These flags can be logically OR'ed together.</source>
          <target state="translated">이 플래그들은 논리적으로 함께 OR 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a00b200b8092958ccb95d52e492735fb5a88b33" translate="yes" xml:space="preserve">
          <source>These general methods allow polymorphic parsing and formatting of objects and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;. Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt; when no text in the required format is at the beginning of the input text.</source>
          <target state="translated">이러한 일반적인 방법은 객체의 다형성 구문 분석 및 서식 지정을 허용하며 예를 들어 &lt;code&gt;MessageFormat&lt;/code&gt; 에 의해 사용됩니다 . 서브 클래스는 종종 특정 입력 유형에 대한 추가 &lt;code&gt;format&lt;/code&gt; 메소드와 특정 결과 유형에 대한 &lt;code&gt;parse&lt;/code&gt; 메소드를 제공합니다. 모든 &lt;code&gt;parse&lt;/code&gt; 테이크하지 않는 방법 &lt;code&gt;ParsePosition&lt;/code&gt; 의의 인수는 던져해야 &lt;code&gt;ParseException&lt;/code&gt; 가를 요구 된 포맷의 텍스트가 입력 텍스트의 선두에없는 경우.</target>
        </trans-unit>
        <trans-unit id="111e337198ca6d68db33b84d5df6564b0dbbe13a" translate="yes" xml:space="preserve">
          <source>These hints can equally be applied when rendering to software images, but these images may not then be suitable for general export, as the text will have been rendered appropriately for a specific subpixel organisation. Also lossy images are not a good choice, nor image formats such as GIF which have limited colors. So unless the image is destined solely for rendering on a display device with the same configuration, some other text anti-aliasing hint such as &lt;a href=&quot;#VALUE_TEXT_ANTIALIAS_ON&quot;&gt;&lt;code&gt;VALUE_TEXT_ANTIALIAS_ON&lt;/code&gt;&lt;/a&gt; may be a better choice.</source>
          <target state="translated">이러한 힌트는 소프트웨어 이미지로 렌더링 할 때 동일하게 적용 할 수 있지만 텍스트가 특정 하위 픽셀 조직에 적합하게 렌더링되므로 이러한 이미지는 일반 내보내기에 적합하지 않을 수 있습니다. 또한 손실 이미지는 좋은 선택이 아니며 제한된 색상을 가진 GIF와 같은 이미지 형식도 아닙니다. 따라서 이미지가 동일한 구성의 디스플레이 장치에서 렌더링하기위한 용도로만 지정되지 않는 한 &lt;a href=&quot;#VALUE_TEXT_ANTIALIAS_ON&quot;&gt; &lt;code&gt;VALUE_TEXT_ANTIALIAS_ON&lt;/code&gt; &lt;/a&gt; 과 같은 다른 텍스트 앤티 앨리어싱 힌트 가 더 나은 선택 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76de812af34579a03375f04c3864f5f693151c31" translate="yes" xml:space="preserve">
          <source>These implementations all attempt to honor the same equations, but use different tradeoffs of integer and floating point math and reduced or full equations. To account for such differences, it is probably best to expect only that the premultiplied form of the results to match between implementations and image formats. In this case both answers, expressed in premultiplied form would equate to:</source>
          <target state="translated">이러한 구현은 모두 동일한 방정식을 따르려고 시도하지만 정수 및 부동 소수점 수학 및 축소 또는 전체 방정식의 서로 다른 절충안을 사용합니다. 이러한 차이점을 설명하기 위해 구현과 이미지 형식간에 일치하는 결과의 미리 곱하기 형식 만 기대하는 것이 가장 좋습니다. 이 경우 미리 곱하기 형식으로 표현 된 두 답변은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffa00cb1f134ab4340bd427dad46d11a43cd0f34" translate="yes" xml:space="preserve">
          <source>These implementations do not examine the status code, meaning the body is always accepted. They typically return an equivalently named &lt;code&gt;BodySubscriber&lt;/code&gt;. Alternatively, a custom handler can be used to examine the status code and headers, and return a different body subscriber, of the same type, as appropriate.</source>
          <target state="translated">이러한 구현은 상태 코드를 검사하지 않으므로 본문이 항상 허용됩니다. 일반적으로 동일한 이름의 &lt;code&gt;BodySubscriber&lt;/code&gt; 를 반환합니다 . 또는 사용자 지정 처리기를 사용하여 상태 코드 및 헤더를 검사하고 동일한 유형의 다른 본문 구독자를 적절하게 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab7b0e51c3bfdf0586a547fefddc0d8e955988f" translate="yes" xml:space="preserve">
          <source>These interfaces and classes are required as part of the Java&amp;trade; Platform, Standard Edition (Java SE), but there is no requirement to provide any tools implementing them.</source>
          <target state="translated">이러한 인터페이스 및 클래스는 Java SE (Java &amp;trade; Platform, Standard Edition)의 일부로 필요하지만이를 구현하는 도구를 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3302651ec6ecf4b0cac5d3b0e6afbf9434f88e14" translate="yes" xml:space="preserve">
          <source>These interfaces are used by the transaction manager; an application does not use them directly.</source>
          <target state="translated">이러한 인터페이스는 트랜잭션 관리자가 사용합니다. 응용 프로그램은이를 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b50b8c65fee1150bc034d27f94b24eb1e37abbb8" translate="yes" xml:space="preserve">
          <source>These interfaces correspond to the &lt;a href=&quot;http://www.reactive-streams.org/&quot;&gt; reactive-streams&lt;/a&gt; specification. They apply in both concurrent and distributed asynchronous settings: All (seven) methods are defined in &lt;code&gt;
 void&lt;/code&gt; &quot;one-way&quot; message style. Communication relies on a simple form of flow control (method &lt;a href=&quot;flow.subscription#request(long)&quot;&gt;&lt;code&gt;Flow.Subscription.request(long)&lt;/code&gt;&lt;/a&gt;) that can be used to avoid resource management problems that may otherwise occur in &quot;push&quot; based systems.</source>
          <target state="translated">이러한 인터페이스는 &lt;a href=&quot;http://www.reactive-streams.org/&quot;&gt;반응 스트림&lt;/a&gt; 사양에 해당합니다. 동시 및 분산 비동기 설정 모두에 적용됩니다. 모든 (7 개) 메서드는 &lt;code&gt; void&lt;/code&gt; &quot;단방향&quot;메시지 스타일 로 정의됩니다 . 통신은 &quot;푸시&quot;기반 시스템에서 발생할 수있는 리소스 관리 문제를 방지하는 데 사용할 수 있는 간단한 형태의 흐름 제어 ( &lt;a href=&quot;flow.subscription#request(long)&quot;&gt; &lt;code&gt;Flow.Subscription.request(long)&lt;/code&gt; &lt;/a&gt; 메서드)에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="69a3f32f3321c8dd0341d385f7705d3bdbb396b6" translate="yes" xml:space="preserve">
          <source>These kinds of protection are specified by a &quot;cipher suite&quot;, which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a cipher suite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged.</source>
          <target state="translated">이러한 종류의 보호는 지정된 암호 연결에 사용되는 암호화 알고리즘의 조합 인 &quot;암호 모음&quot;에 의해 지정됩니다. 협상 프로세스 동안 두 엔드 포인트는 두 환경에서 모두 사용 가능한 암호 스위트에 동의해야합니다. 공통적 인 제품군이 없으면 SSL 연결을 설정할 수 없으며 데이터를 교환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ff41a76c06a874e4c78ae8f4beb0185f7f249d3" translate="yes" xml:space="preserve">
          <source>These kinds of protection are specified by a &quot;cipher suite&quot;, which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a ciphersuite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged.</source>
          <target state="translated">이러한 종류의 보호는 지정된 암호 연결에 사용되는 암호화 알고리즘의 조합 인 &quot;암호 모음&quot;에 의해 지정됩니다. 협상 프로세스 동안 두 엔드 포인트는 두 환경 모두에서 사용 가능한 암호 스위트에 동의해야합니다. 공통적 인 제품군이 없으면 SSL 연결을 설정할 수 없으며 데이터를 교환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b9c276e86b40b1083fdf2a0734e76f5ff35e720" translate="yes" xml:space="preserve">
          <source>These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments. For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it. Attempts to create method handles with impossible method types lead to an &lt;a href=&quot;../illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;. In particular, a method handle&amp;rsquo;s type must not have an arity of the exact maximum 255.</source>
          <target state="translated">이러한 한계는 스택 된 인수에 대한 JVM 한계로 인해 특정 메소드 핸들을 작성할 수 없음을 의미합니다. 예를 들어, 정적 JVM 메소드가 정확히 255 개의 인수를 허용하면 메소드 핸들을 작성할 수 없습니다. 불가능한 메소드 유형으로 메소드 핸들을 작성하려고하면 &lt;a href=&quot;../illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. 특히, 메소드 핸들의 유형은 정확히 최대 255의 arity를 ​​가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2aef62f1a686aa612f7dadf32611ec60612d24e1" translate="yes" xml:space="preserve">
          <source>These linkage methods are designed to support the evaluation of &lt;em&gt;lambda expressions&lt;/em&gt; and &lt;em&gt;method references&lt;/em&gt; in the Java Language. For every lambda expressions or method reference in the source code, there is a target type which is a functional interface. Evaluating a lambda expression produces an object of its target type. The recommended mechanism for evaluating lambda expressions is to desugar the lambda body to a method, invoke an invokedynamic call site whose static argument list describes the sole method of the functional interface and the desugared implementation method, and returns an object (the lambda object) that implements the target type. (For method references, the implementation method is simply the referenced method; no desugaring is needed.)</source>
          <target state="translated">이러한 연결 방법은 Java 언어에서 &lt;em&gt;람다 식&lt;/em&gt; 및 &lt;em&gt;방법 참조&lt;/em&gt; 의 평가를 지원하도록 설계되었습니다 . 소스 코드의 모든 람다 식 또는 메서드 참조에는 기능 인터페이스 인 대상 유형이 있습니다. 람다 식을 평가하면 대상 유형의 객체가 생성됩니다. 람다 식을 평가하는 데 권장되는 메커니즘은 람다 본문을 메서드에 desugar, 정적 인수 목록이 기능 인터페이스의 단독 메서드 및 desugared 구현 메서드를 설명하는 invokedynamic 호출 ​​사이트를 호출하고 다음과 같은 개체 (람다 개체)를 반환하는 것입니다. 대상 유형을 구현합니다. (방법 참조의 경우 구현 방법은 단순히 참조 된 방법이며, 설탕 제거가 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="f76b936989514145bd202de1643f4d241fbb018e" translate="yes" xml:space="preserve">
          <source>These mechanisms are described in the &lt;a href=&quot;package-summary&quot;&gt;package specification&lt;/a&gt;.</source>
          <target state="translated">이러한 메커니즘은 &lt;a href=&quot;package-summary&quot;&gt;패키지 사양에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5618ab72a51ab91e8bc7984d97068e027245df5" translate="yes" xml:space="preserve">
          <source>These methods allow an application to add one &lt;code&gt;RowSet&lt;/code&gt; object at a time or to add multiple &lt;code&gt;RowSet&lt;/code&gt; objects at one time. In either case, the methods may specify the match column for each &lt;code&gt;RowSet&lt;/code&gt; object being added.</source>
          <target state="translated">이러한 메서드를 사용하면 응용 프로그램이 한 번에 하나의 &lt;code&gt;RowSet&lt;/code&gt; 개체를 추가하거나 한 번에 여러 &lt;code&gt;RowSet&lt;/code&gt; 개체 를 추가 할 수 있습니다 . 두 경우 모두 메서드는 추가되는 각 &lt;code&gt;RowSet&lt;/code&gt; 개체 에 대해 일치 열을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24ac5b741a325296e9f1f056304a110b8a722ad5" translate="yes" xml:space="preserve">
          <source>These methods are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications. The &lt;code&gt;park&lt;/code&gt; method is designed for use only in constructions of the form:</source>
          <target state="translated">이러한 방법은 높은 수준의 동기화 유틸리티를 만들기위한 도구로 사용되도록 고안되었으며 대부분의 동시성 제어 응용 프로그램에는 유용하지 않습니다. &lt;code&gt;park&lt;/code&gt; 메소드는 형태의 구조물에 사용하도록 설계되었습니다 :</target>
        </trans-unit>
        <trans-unit id="80b2b542cff995913a77f4654f407bd25dd4c1a4" translate="yes" xml:space="preserve">
          <source>These methods provide basic scripting functionality. Applications written to this simple interface are expected to work with minimal modifications in every implementation. It includes methods that execute scripts, and ones that set and get values.</source>
          <target state="translated">이러한 방법은 기본 스크립팅 기능을 제공합니다. 이 간단한 인터페이스로 작성된 응용 프로그램은 모든 구현에서 최소한의 수정으로 작동 할 것으로 예상됩니다. 스크립트를 실행하는 메소드와 값을 설정하고 얻는 메소드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2bd340a5cd3a9169090ae3d84cd382f6d6375a" translate="yes" xml:space="preserve">
          <source>These nodes can all be adopted. No specifics.</source>
          <target state="translated">이러한 노드는 모두 채택 될 수 있습니다. 세부 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="297752b6a18f573e9c56aa0c6689ca4f4e9ec102" translate="yes" xml:space="preserve">
          <source>These objects may only be accessed via the following public static final variables, and are the only &lt;code&gt;Class&lt;/code&gt; objects for which this method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이러한 객체는 다음의 공개 정적 최종 변수를 통해서만 액세스 할 수 있으며이 메서드가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 유일한 &lt;code&gt;Class&lt;/code&gt; 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="a96ccc8f3e2fd8fe4c1dbd6fc649068f34d0702f" translate="yes" xml:space="preserve">
          <source>These operations are exposed in the constructors and methods of this class as follows:</source>
          <target state="translated">이러한 작업은이 클래스의 생성자와 메서드에 다음과 같이 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="47cbaf1cf3b15e600a882f2b865f9a1538cc73da" translate="yes" xml:space="preserve">
          <source>These parameter rules are also applicable to the set rule methods, such as &lt;code&gt;setStartRule&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수 규칙은 &lt;code&gt;setStartRule&lt;/code&gt; 과 같은 설정된 규칙 메소드에도 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e28c1b9b8fb783d140150ed1d2b8973462224f2" translate="yes" xml:space="preserve">
          <source>These policies are explored in more detail in the &lt;a href=&quot;syncfactory&quot;&gt; &lt;code&gt;SyncFactory&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">이러한 정책은 &lt;a href=&quot;syncfactory&quot;&gt; &lt;code&gt;SyncFactory&lt;/code&gt; &lt;/a&gt; 클래스 에서 자세히 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="647770bcf1eb1a38d71a54bfe8c3e7ad6de8bd78" translate="yes" xml:space="preserve">
          <source>These properties are interpreted according to the following rules:</source>
          <target state="translated">이러한 속성은 다음 규칙에 따라 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="5d242321b38871e376bb238866bf118b57b125f0" translate="yes" xml:space="preserve">
          <source>These protocols are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#sslcontext-algorithms&quot;&gt; SSLContext section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 프로토콜은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#sslcontext-algorithms&quot;&gt;SSLContext 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 알고리즘이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d206af1d2dc412e81e7644b4cec4700275f97ba3" translate="yes" xml:space="preserve">
          <source>These purposes are served in this class by three related operations:</source>
          <target state="translated">이러한 목적은이 수업에서 세 가지 관련 작업으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e42b277937f8a596084eb371e31744be7cbbfdeb" translate="yes" xml:space="preserve">
          <source>These reduction operations can run safely in parallel with almost no modification:</source>
          <target state="translated">이러한 축소 작업은 거의 수정없이 안전하게 병렬로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="342157b7938368eea83fec1686ef1431f444180d" translate="yes" xml:space="preserve">
          <source>These requirements ensure that streams produced by the &lt;a href=&quot;#stream()&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parallelStream()&quot;&gt;&lt;code&gt;parallelStream()&lt;/code&gt;&lt;/a&gt; methods will reflect the contents of the collection as of initiation of the terminal stream operation.</source>
          <target state="translated">이러한 요구 사항은 &lt;a href=&quot;#stream()&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#parallelStream()&quot;&gt; &lt;code&gt;parallelStream()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성 된 스트림 이 터미널 스트림 작업이 시작될 때 컬렉션의 내용을 반영하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b5fe1b43768fd591f3bcb574e2cd4e802bb59264" translate="yes" xml:space="preserve">
          <source>These requirements ensure that streams produced by the &lt;a href=&quot;collection#stream--&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collection#parallelStream--&quot;&gt;&lt;code&gt;parallelStream()&lt;/code&gt;&lt;/a&gt; methods will reflect the contents of the collection as of initiation of the terminal stream operation.</source>
          <target state="translated">이러한 요구 사항은 &lt;a href=&quot;collection#stream--&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;collection#parallelStream--&quot;&gt; &lt;code&gt;parallelStream()&lt;/code&gt; &lt;/a&gt; 메서드로 생성 된 스트림 이 터미널 스트림 작업을 시작할 때 컬렉션의 내용을 반영하도록합니다.</target>
        </trans-unit>
        <trans-unit id="9ce6632fdcabd56179ddf7edadcea4b6aaa39c33" translate="yes" xml:space="preserve">
          <source>These requirements significantly reduce the scope of potential interference between mutations of the stream source and execution of stream pipelines. Streams based on spliterators with the desired characteristics, or those using the Supplier-based factory forms, are immune to modifications of the data source prior to commencement of the terminal operation (provided the behavioral parameters to the stream operations meet the required criteria for non-interference and statelessness). See &lt;a href=&quot;package-summary#NonInterference&quot;&gt;Non-Interference&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 요구 사항은 스트림 소스의 돌연변이와 스트림 파이프 라인 실행 간의 잠재적 인 간섭 범위를 크게 줄입니다. 원하는 특성을 가진 스플리터를 기반으로하는 스트림 또는 공급 업체 기반 팩토리 형식을 사용하는 스트림은 터미널 작업을 시작하기 전에 데이터 소스 수정에 영향을받지 않습니다 (스트림 매개 변수에 대한 동작 매개 변수가 간섭 및 무국적). 자세한 내용은 &lt;a href=&quot;package-summary#NonInterference&quot;&gt;비 간섭&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f76fe1fde2a58cf1420c28ae186dba0fd8cdb513" translate="yes" xml:space="preserve">
          <source>These response controls might have been generated by a successful or failed operation.</source>
          <target state="translated">이러한 응답 제어는 성공 또는 실패한 조작으로 생성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3133b61143c4a97991f32b65e594ea52115dd6e5" translate="yes" xml:space="preserve">
          <source>These rules imply that there is a one-to-one mapping between quoted and unquoted forms.</source>
          <target state="translated">이러한 규칙은 인용 양식과 인용되지 않은 양식간에 일대일 매핑이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="515dc9d95cc15e6e31346b7231f767f0ba0d486f" translate="yes" xml:space="preserve">
          <source>These rules mean that extra items can be added to a &lt;code&gt;
 CompositeData&lt;/code&gt; without making it invalid for a &lt;code&gt;CompositeType&lt;/code&gt; that does not have those items.</source>
          <target state="translated">이러한 규칙은 해당 항목 이없는 &lt;code&gt;CompositeType&lt;/code&gt; 에 대해 유효하지 않게 만들지 않고 추가 항목을 &lt;code&gt; CompositeData&lt;/code&gt; 에 추가 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="fef3e7eb79137df43be121f2de5aa7417409ab48" translate="yes" xml:space="preserve">
          <source>These rules mean that extra items can be added to a &lt;code&gt;CompositeData&lt;/code&gt; without making it invalid for a &lt;code&gt;CompositeType&lt;/code&gt; that does not have those items.</source>
          <target state="translated">이 규칙은 해당 항목 이없는 &lt;code&gt;CompositeType&lt;/code&gt; 에 대해 유효하지 않은 추가 항목을 &lt;code&gt;CompositeData&lt;/code&gt; 에 추가 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="93285ed9687ceae878834b3cc5f3c85f4529ac14" translate="yes" xml:space="preserve">
          <source>These scales are the ones used by the methods which return exact arithmetic results; except that an exact divide may have to use a larger scale since the exact result may have more digits. For example, &lt;code&gt;1/32&lt;/code&gt; is &lt;code&gt;0.03125&lt;/code&gt;.</source>
          <target state="translated">이 스케일은 정확한 산술 결과를 반환하는 메소드에서 사용되는 스케일입니다. 정확한 결과는 더 많은 자릿수를 가질 수 있으므로 정확한 나누기는 더 큰 스케일을 사용해야 할 수 있습니다. 예를 들어 &lt;code&gt;1/32&lt;/code&gt; 는 &lt;code&gt;0.03125&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e810c9cd3c3d10bac6318c77d76a5f66cc69714" translate="yes" xml:space="preserve">
          <source>These styles are used when obtaining a date-time style from configuration. See &lt;a href=&quot;datetimeformatter&quot;&gt;&lt;code&gt;DateTimeFormatter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetimeformatterbuilder&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt;&lt;/a&gt; for usage.</source>
          <target state="translated">이 스타일은 구성에서 날짜-시간 스타일을 가져올 때 사용됩니다. 사용법 은 &lt;a href=&quot;datetimeformatter&quot;&gt; &lt;code&gt;DateTimeFormatter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datetimeformatterbuilder&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47a31e4f1754b1fff887f8b5e25b8721c241aad1" translate="yes" xml:space="preserve">
          <source>These three types of nodes inheriting from &lt;code&gt;CharacterData&lt;/code&gt; copy their &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; attributes from those of the source node.Note that the &lt;code&gt;deep&lt;/code&gt; parameter has no effect on these types of nodes since they cannot have any children.</source>
          <target state="translated">&lt;code&gt;CharacterData&lt;/code&gt; 에서 상속 된이 세 가지 유형의 노드 는 소스 노드의 &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;length&lt;/code&gt; 속성을 복사 합니다. &lt;code&gt;deep&lt;/code&gt; 매개 변수는 자식을 가질 수 없기 때문에 이러한 유형의 노드에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc114217be17e6aa99adce30106bd9ef6d7477d8" translate="yes" xml:space="preserve">
          <source>These transformations are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#cipher-algorithm-names&quot;&gt; Cipher section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other transformations are supported.</source>
          <target state="translated">이러한 변환은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#cipher-algorithm-names&quot;&gt;Cipher 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 변환이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e707b74f1bd6747e77b6eba32772900f7b93a32" translate="yes" xml:space="preserve">
          <source>These transformations are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher&quot;&gt; Cipher section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other transformations are supported.</source>
          <target state="translated">이러한 변환은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher&quot;&gt;암호 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 문서를 참조하여 다른 변환이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="998abafd744dbc64c5eb0e4aa97e8d53ca3729ba" translate="yes" xml:space="preserve">
          <source>These two APIs provide callers the means to query the Policy for Principal-based Permission entries.</source>
          <target state="translated">이 두 API는 호출자에게 기본 기반 권한 항목에 대한 정책을 쿼리 할 수있는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a115f527807f7ad38aadc1251aabbfdf3dc66f31" translate="yes" xml:space="preserve">
          <source>These two properties may be specified on the command line to the &quot;java&quot; command, or as system property definitions passed to JNI_CreateJavaVM.</source>
          <target state="translated">이 두 특성은 명령 행에서 &quot;java&quot;명령에 지정되거나 JNI_CreateJavaVM에 전달 된 시스템 특성 정의로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="812eeb510b3ce50d4d154618d053e87caeed62d6" translate="yes" xml:space="preserve">
          <source>These two system properties may be specified on the command line to the &quot;java&quot; command, or as system property definitions passed to JNI_CreateJavaVM.</source>
          <target state="translated">이 두 시스템 속성은 &quot;java&quot;명령에 대한 명령 줄에서 지정하거나 JNI_CreateJavaVM에 전달 된 시스템 속성 정의로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996bd5dd03cf13a899ae43ea59349cc73d3d4dc4" translate="yes" xml:space="preserve">
          <source>These units are intended to be applicable in multiple calendar systems. For example, most non-ISO calendar systems define units of years, months and days, just with slightly different rules. The documentation of each unit explains how it operates.</source>
          <target state="translated">이 단위는 여러 달력 시스템에 적용 할 수 있도록 고안되었습니다. 예를 들어, 대부분의 비 ISO 캘린더 시스템은 약간 다른 규칙으로 년, 월 및 일 단위를 정의합니다. 각 장치의 설명서에는 장치 작동 방법이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dad5d8e9242a36a4adbe99a3c9514dc461d6647b" translate="yes" xml:space="preserve">
          <source>These will be silently expanded, with no indication of where the original entity boundaries were.</source>
          <target state="translated">이들은 원래 엔티티 경계가 어디에 있는지 표시하지 않고 조용히 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="28091910ad0d10b0849e0f9381c4be4de3c17165" translate="yes" xml:space="preserve">
          <source>They are &lt;a href=&quot;collection#unmodifiable&quot;&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Elements cannot be added or removed. Calling any mutator method on the Set will always cause &lt;code&gt;UnsupportedOperationException&lt;/code&gt; to be thrown. However, if the contained elements are themselves mutable, this may cause the Set to behave inconsistently or its contents to appear to change.</source>
          <target state="translated">그들은있다 &lt;a href=&quot;collection#unmodifiable&quot;&gt;&lt;i&gt;불가능한&lt;/i&gt;&lt;/a&gt; . 요소를 추가하거나 제거 할 수 없습니다. Set에서 mutator 메서드를 호출하면 항상 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 throw됩니다. 그러나 포함 된 요소 자체가 변경 가능하면 Set이 일관되지 않게 작동하거나 내용이 변경된 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b998929a3905fca757a882b2d4ecc129d2c53a" translate="yes" xml:space="preserve">
          <source>They are &lt;a href=&quot;collection#unmodifiable&quot;&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Elements cannot be added, removed, or replaced. Calling any mutator method on the List will always cause &lt;code&gt;UnsupportedOperationException&lt;/code&gt; to be thrown. However, if the contained elements are themselves mutable, this may cause the List's contents to appear to change.</source>
          <target state="translated">그들은있다 &lt;a href=&quot;collection#unmodifiable&quot;&gt;&lt;i&gt;불가능한&lt;/i&gt;&lt;/a&gt; . 요소는 추가, 제거 또는 교체 할 수 없습니다. List에서 mutator 메서드를 호출하면 항상 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 throw됩니다. 그러나 포함 된 요소 자체가 변경 가능한 경우 이로 인해 List의 내용이 변경된 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f86d7a552f2470ec8e231432dfa29a3a5256d6" translate="yes" xml:space="preserve">
          <source>They are &lt;a href=&quot;collection#unmodifiable&quot;&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Keys and values cannot be added, removed, or updated. Calling any mutator method on the Map will always cause &lt;code&gt;UnsupportedOperationException&lt;/code&gt; to be thrown. However, if the contained keys or values are themselves mutable, this may cause the Map to behave inconsistently or its contents to appear to change.</source>
          <target state="translated">그들은있다 &lt;a href=&quot;collection#unmodifiable&quot;&gt;&lt;i&gt;불가능한&lt;/i&gt;&lt;/a&gt; . 키와 값은 추가, 제거 또는 업데이트 할 수 없습니다. Map에서 mutator 메소드를 호출하면 항상 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다. 그러나 포함 된 키 또는 값 자체가 변경 가능한 경우 이로 인해 맵이 일관되지 않게 작동하거나 그 내용이 변경된 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d7dd3b65fdfdd51ffd291a28e90716ee658c1e" translate="yes" xml:space="preserve">
          <source>They are &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;. Callers should make no assumptions about the identity of the returned instances. Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (&lt;code&gt;==&lt;/code&gt;), identity hash code, and synchronization) are unreliable and should be avoided.</source>
          <target state="translated">그들은있는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;가치 기반&lt;/a&gt; . 호출자는 반환 된 인스턴스의 ID에 대해 가정하지 않아야합니다. 공장은 새 인스턴스를 생성하거나 기존 인스턴스를 재사용 할 수 있습니다. 따라서 이러한 인스턴스에서 ID에 민감한 작업 (참조 같음 ( &lt;code&gt;==&lt;/code&gt; ), ID 해시 코드 및 동기화)은 신뢰할 수 없으므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="4188161f84c01b1b343edf0e05caa723037593b5" translate="yes" xml:space="preserve">
          <source>They are &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;. Callers should make no assumptions about the identity of the returned instances. This method is free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (&lt;code&gt;==&lt;/code&gt;), identity hash code, and synchronization) are unreliable and should be avoided.</source>
          <target state="translated">그들은있는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;가치 기반&lt;/a&gt; . 호출자는 반환 된 인스턴스의 ID에 대해 가정하지 않아야합니다. 이 방법은 새 인스턴스를 생성하거나 기존 인스턴스를 재사용 할 수 있습니다. 따라서 이러한 인스턴스에서 ID에 민감한 작업 (참조 같음 ( &lt;code&gt;==&lt;/code&gt; ), ID 해시 코드 및 동기화)은 신뢰할 수 없으므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="5188a71bd0122eb574523ea50229e4ab1c0bae0a" translate="yes" xml:space="preserve">
          <source>They are not serializable.</source>
          <target state="translated">직렬화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd33cb623d9fc537ca2f0b0c7a02cd8a97161300" translate="yes" xml:space="preserve">
          <source>They are serializable if all elements are serializable.</source>
          <target state="translated">모든 요소가 직렬화 가능하면 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3cbbbf0e9f9a63e48e62a9bf1c9b334a297119f0" translate="yes" xml:space="preserve">
          <source>They are serializable if all keys and values are serializable.</source>
          <target state="translated">모든 키와 값이 직렬화 가능하면 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="44614328ee29e0917b45e28712b968a3c6a97d23" translate="yes" xml:space="preserve">
          <source>They are serialized as specified on the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/serialized-form.html#java.util.CollSer&quot;&gt;Serialized Form&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/serialized-form.html#java.util.CollSer&quot;&gt;직렬화 된 양식&lt;/a&gt; 페이지 에 지정된대로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="137c282e027f2a565e5c35e25834f4b959718861" translate="yes" xml:space="preserve">
          <source>They are unmodifiable. Calls to &lt;a href=&quot;map.entry#setValue(V)&quot;&gt;&lt;code&gt;Entry.setValue()&lt;/code&gt;&lt;/a&gt; on a returned &lt;code&gt;Entry&lt;/code&gt; result in &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">수정할 수 없습니다. 를 호출 &lt;a href=&quot;map.entry#setValue(V)&quot;&gt; &lt;code&gt;Entry.setValue()&lt;/code&gt; &lt;/a&gt; 반환에 &lt;code&gt;Entry&lt;/code&gt; 의 결과 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59b8e86d0e45fc55f0ca4da9ff149e4d1e68afb8" translate="yes" xml:space="preserve">
          <source>They disallow &lt;code&gt;null&lt;/code&gt; elements. Attempts to create them with &lt;code&gt;null&lt;/code&gt; elements result in &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 요소를 허용하지 않습니다 . &lt;code&gt;null&lt;/code&gt; 요소 를 사용하여 생성하려고하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="03b2e41bdbee0e4cf1f96bbf532d5cf2f0e69e8a" translate="yes" xml:space="preserve">
          <source>They disallow &lt;code&gt;null&lt;/code&gt; keys and values. Attempts to create them using a &lt;code&gt;null&lt;/code&gt; key or value result in &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 키와 값을 허용하지 않습니다 . &lt;code&gt;null&lt;/code&gt; 키 또는 값을 사용하여 생성하려고하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5399d0a7276917024969b25bd71b01ccd5d2784f" translate="yes" xml:space="preserve">
          <source>They disallow &lt;code&gt;null&lt;/code&gt; keys and values. Attempts to create them with &lt;code&gt;null&lt;/code&gt; keys or values result in &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 키와 값을 허용하지 않습니다 . &lt;code&gt;null&lt;/code&gt; 키 또는 값 을 사용하여 생성하려고 시도하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c5472c0639969a263b9f755acdf389e0d8c3da22" translate="yes" xml:space="preserve">
          <source>They have the same element type,</source>
          <target state="translated">그들은 같은 요소 유형을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdfeeb8a91a65cd73f75c6e587083ef66ea635a5" translate="yes" xml:space="preserve">
          <source>They have the same number of remaining elements, and</source>
          <target state="translated">그들은 같은 수의 나머지 요소를 가지고 있으며</target>
        </trans-unit>
        <trans-unit id="1b2edcdb089ab60cba21f42efe299c3451e3c185" translate="yes" xml:space="preserve">
          <source>They may be used to monitor both print services (such as printers going on-line &amp;amp; off-line), and the progress of a specific print job.</source>
          <target state="translated">인쇄 서비스 (예 : 온라인 및 오프라인 프린터) 및 특정 인쇄 작업의 진행률을 모니터링하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc920574d9a9e1b56f44e6dd778f5aac65049880" translate="yes" xml:space="preserve">
          <source>They reject duplicate elements at creation time. Duplicate elements passed to a static factory method result in &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">생성시 중복 요소를 거부합니다. 정적 팩토리 메소드에 전달 된 중복 요소는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="62810637d2fc3ba27fcf48e9c65badcc7e3fe251" translate="yes" xml:space="preserve">
          <source>They reject duplicate keys at creation time. Duplicate keys passed to a static factory method result in &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">생성시 중복 키를 거부합니다. 정적 팩토리 메소드에 중복 키가 전달되면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1fc25fcbcce0a6e736219b76a3c496a39fdfbfaf" translate="yes" xml:space="preserve">
          <source>Thickness of the border.</source>
          <target state="translated">테두리의 두께입니다.</target>
        </trans-unit>
        <trans-unit id="c9817dde9253443f7c2405ea71c3564c292de17d" translate="yes" xml:space="preserve">
          <source>Third parties may wish to provide value-add wrappers around the facility objects from this interface, for example a &lt;code&gt;Filer&lt;/code&gt; extension that allows multiple processors to coordinate writing out a single source file. To enable this, for processors running in a context where their side effects via the API could be visible to each other, the tool infrastructure must provide corresponding facility objects that are &lt;code&gt;.equals&lt;/code&gt;, &lt;code&gt;Filer&lt;/code&gt;s that are &lt;code&gt;.equals&lt;/code&gt;, and so on. In addition, the tool invocation must be able to be configured such that from the perspective of the running annotation processors, at least the chosen subset of helper classes are viewed as being loaded by the same class loader. (Since the facility objects manage shared state, the implementation of a wrapper class must know whether or not the same base facility object has been wrapped before.)</source>
          <target state="translated">타사는이 인터페이스에서 시설 개체 주위에 부가 가치 래퍼 (예 : 여러 프로세서가 단일 소스 파일 작성을 조정 하는 &lt;code&gt;Filer&lt;/code&gt; 확장)를 제공 할 수 있습니다. API를 통해 부작용이 서로 볼 수 수있는 곳 컨텍스트에서 실행중인 프로세서,이를 사용하려면,있는 시설 개체에 해당 제공해야하는 도구 인프라 &lt;code&gt;.equals&lt;/code&gt; , &lt;code&gt;Filer&lt;/code&gt; 이다의 &lt;code&gt;.equals&lt;/code&gt; 을, 등등. 또한 실행중인 주석 프로세서의 관점에서 최소한 선택된 헬퍼 클래스 서브 세트가 동일한 클래스 로더에 의해로드 된 것으로 간주되도록 도구 호출을 구성 할 수 있어야합니다. 기능 오브젝트가 공유 상태를 관리하므로 랩퍼 클래스의 구현은 동일한 기본 기능 오브젝트가 이전에 랩핑되었는지 여부를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="7af406c3aaa271300eedbb974c7a54d928cca6a4" translate="yes" xml:space="preserve">
          <source>This &lt;b&gt;&lt;i&gt;grant&lt;/i&gt;&lt;/b&gt; entry specifies that code from &quot;foo.com&quot;, signed by &quot;foo', and running as a &lt;code&gt;SolarisPrincipal&lt;/code&gt; with the name, duke, has one &lt;code&gt;Permission&lt;/code&gt;. This &lt;code&gt;Permission&lt;/code&gt; permits the executing code to read and write files in the directory, &quot;/home/duke&quot;.</source>
          <target state="translated">이 &lt;b&gt;&lt;i&gt;권한 부여&lt;/i&gt;&lt;/b&gt; 항목은 &quot;foo&quot;로 서명되고 duke라는 이름 으로 &lt;code&gt;SolarisPrincipal&lt;/code&gt; 로 실행되는 &quot;foo.com&quot;의 코드 가 하나의 &lt;code&gt;Permission&lt;/code&gt; 을갖도록 지정 합니다.이 &lt;code&gt;Permission&lt;/code&gt; 은 실행 코드가 디렉토리에서 파일을 읽고 쓸 수 있도록합니다 . &quot; / home / duke &quot;.</target>
        </trans-unit>
        <trans-unit id="a0574eaa19de0e15db5fdb797729f29466170c1f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;@Target&lt;/code&gt; meta-annotation indicates that the declared type is intended solely for use as a member type in complex annotation type declarations. It cannot be used to annotate anything directly:</source>
          <target state="translated">이 &lt;code&gt;@Target&lt;/code&gt; 메타 주석은 선언 된 유형이 복잡한 주석 유형 선언에서 멤버 유형으로 만 사용됨을 나타냅니다. 직접 주석을 달 수는 없습니다 :</target>
        </trans-unit>
        <trans-unit id="8937167eb448a8245dac8cda5d87eb347ac2e8b9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;AccessibleSelection&lt;/code&gt; interface provides the standard mechanism for an assistive technology to determine what the current selected children are, as well as modify the selection set.</source>
          <target state="translated">이 &lt;code&gt;AccessibleSelection&lt;/code&gt; 인터페이스는 현재 선택된 하위 항목이 무엇인지 결정하고 선택 세트를 수정하는 보조 기술에 대한 표준 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8fc559ee5afce2e599a7e2f487b65459918d2c3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;AccessibleSelection&lt;/code&gt; interface provides the standard mechanism for an assistive technology to determine what the current selected children are, as well as modify the selection set. Any object that has children that can be selected should support the &lt;code&gt;AccessibleSelection&lt;/code&gt; interface. Applications can determine if an object supports the &lt;code&gt;AccessibleSelection&lt;/code&gt; interface by first obtaining its &lt;code&gt;AccessibleContext&lt;/code&gt; (see &lt;a href=&quot;accessible&quot;&gt;&lt;code&gt;Accessible&lt;/code&gt;&lt;/a&gt;) and then calling the &lt;a href=&quot;accessiblecontext#getAccessibleSelection()&quot;&gt;&lt;code&gt;AccessibleContext.getAccessibleSelection()&lt;/code&gt;&lt;/a&gt; method. If the return value is not &lt;code&gt;null&lt;/code&gt;, the object supports this interface.</source>
          <target state="translated">이 &lt;code&gt;AccessibleSelection&lt;/code&gt; 인터페이스는 현재 선택된 하위 항목이 무엇인지 결정하고 선택 세트를 수정하는 보조 기술에 대한 표준 메커니즘을 제공합니다. 선택할 수있는 자식이있는 모든 개체는 &lt;code&gt;AccessibleSelection&lt;/code&gt; 인터페이스를 지원해야합니다 . 응용 프로그램은 먼저 &lt;code&gt;AccessibleContext&lt;/code&gt; ( &lt;a href=&quot;accessible&quot;&gt; &lt;code&gt;Accessible&lt;/code&gt; &lt;/a&gt; 참조 )를 가져온 다음 &lt;a href=&quot;accessiblecontext#getAccessibleSelection()&quot;&gt; &lt;code&gt;AccessibleContext.getAccessibleSelection()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 객체가 &lt;code&gt;AccessibleSelection&lt;/code&gt; 인터페이스를 지원하는지 확인할 수 있습니다 . 반환 값이 &lt;code&gt;null&lt;/code&gt; 이 아니면 객체는이 인터페이스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e4413fb83791c77b9384cc10020a41370edc8037" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;CachedRowSet&lt;/code&gt; object should lock until its contents and associated updates are fully cleared, thus preventing 'dirty' reads by other components that hold a reference to this &lt;code&gt;RowSet&lt;/code&gt; object. In addition, the contents cannot be released until all components reading this &lt;code&gt;CachedRowSet&lt;/code&gt; object have completed their reads. This &lt;code&gt;CachedRowSet&lt;/code&gt; object should be returned to normal behavior after firing the &lt;code&gt;rowSetChanged&lt;/code&gt; event.</source>
          <target state="translated">이 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체는 내용과 관련 업데이트가 완전히 지워질 때까지 잠 가야합니다. 따라서이 &lt;code&gt;RowSet&lt;/code&gt; 객체에 대한 참조를 보유하는 다른 구성 요소가 '더러운'읽기를 방지 합니다. 또한이 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체를 읽는 모든 구성 요소가 읽기를 완료 할 때까지 콘텐츠를 해제 할 수 없습니다 . 이 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체는 &lt;code&gt;rowSetChanged&lt;/code&gt; 이벤트가 발생한 후 정상적인 동작으로 반환되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="756e3bd12852d947c03b9c6314f75be46cd5c89f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;CaretPolicy&lt;/code&gt; is used when a policy is not specified by the client.</source>
          <target state="translated">이 &lt;code&gt;CaretPolicy&lt;/code&gt; 는 클라이언트가 정책을 지정하지 않은 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5b7a3673cda0021143e7a7de398440feb9b0f820" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;CaretPolicy&lt;/code&gt; is used when a policy is not specified by the client. With this policy, a hit on a character whose direction is the same as the line direction is stronger than a hit on a counterdirectional character. If the characters' directions are the same, a hit on the leading edge of a character is stronger than a hit on the trailing edge of a character.</source>
          <target state="translated">이 &lt;code&gt;CaretPolicy&lt;/code&gt; 는 클라이언트가 정책을 지정하지 않은 경우에 사용됩니다. 이 정책을 사용하면 방향이 라인 방향과 같은 캐릭터에 대한 히트가 역방향 캐릭터에 대한 히트보다 강합니다. 캐릭터의 방향이 같으면 캐릭터의 앞 가장자리에있는 히트가 캐릭터의 뒤 가장자리에있는 히트보다 더 강합니다.</target>
        </trans-unit>
        <trans-unit id="939142716b149e711b414ed3aa1cdb7ca70db881" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;ColorModel&lt;/code&gt; class supports two representations of pixel values. A pixel value can be a single 32-bit int or an array of primitive types. The Java(tm) Platform 1.0 and 1.1 APIs represented pixels as single &lt;code&gt;byte&lt;/code&gt; or single &lt;code&gt;int&lt;/code&gt; values. For purposes of the &lt;code&gt;ColorModel&lt;/code&gt; class, pixel value arguments were passed as ints. The Java(tm) 2 Platform API introduced additional classes for representing images. With &lt;a href=&quot;bufferedimage&quot;&gt;&lt;code&gt;BufferedImage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;renderedimage&quot;&gt;&lt;code&gt;RenderedImage&lt;/code&gt;&lt;/a&gt; objects, based on &lt;a href=&quot;raster&quot;&gt;&lt;code&gt;Raster&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;samplemodel&quot;&gt;&lt;code&gt;SampleModel&lt;/code&gt;&lt;/a&gt; classes, pixel values might not be conveniently representable as a single int. Consequently, &lt;code&gt;ColorModel&lt;/code&gt; now has methods that accept pixel values represented as arrays of primitive types. The primitive type used by a particular &lt;code&gt;ColorModel&lt;/code&gt; object is called its transfer type.</source>
          <target state="translated">이 &lt;code&gt;ColorModel&lt;/code&gt; 클래스는 픽셀 값의 두 가지 표현을 지원합니다. 픽셀 값은 단일 32 비트 int 또는 기본 유형의 배열 일 수 있습니다. Java (tm) Platform 1.0 및 1.1 API는 픽셀을 단일 &lt;code&gt;byte&lt;/code&gt; 또는 단일 &lt;code&gt;int&lt;/code&gt; 값으로 표시했습니다. &lt;code&gt;ColorModel&lt;/code&gt; 클래스의 목적을 위해 픽셀 값 인수는 int로 전달되었습니다. Java (tm) 2 Platform API는 이미지를 표현하기위한 추가 클래스를 도입했습니다. &lt;a href=&quot;raster&quot;&gt; &lt;code&gt;Raster&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;samplemodel&quot;&gt; &lt;code&gt;SampleModel&lt;/code&gt; &lt;/a&gt; 클래스를 기반으로하는 &lt;a href=&quot;bufferedimage&quot;&gt; &lt;code&gt;BufferedImage&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;renderedimage&quot;&gt; &lt;code&gt;RenderedImage&lt;/code&gt; &lt;/a&gt; 객체를 사용하면 픽셀 값이 단일 정수로 편리하게 표현되지 않을 수 있습니다. 결과적으로 &lt;code&gt;ColorModel&lt;/code&gt; 이제 기본 유형의 배열로 표시된 픽셀 값을 허용하는 메소드가 있습니다. 특정 &lt;code&gt;ColorModel&lt;/code&gt; 객체가 사용하는 기본 유형을 전송 유형이라고합니다.</target>
        </trans-unit>
        <trans-unit id="98f93f642c8589caf925501755e90c3a3667c633" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Configuration&lt;/code&gt; specifies that an application named, &quot;Login&quot;, requires users to first authenticate to the</source>
          <target state="translated">이 &lt;code&gt;Configuration&lt;/code&gt; 은 &quot;로그인&quot;이라는 응용 프로그램이 사용자에게 먼저 인증을 요구하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="45ca1aadc765e8a322d246f05d591b249f9cf18e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;DataFlavor&lt;/code&gt; has been &lt;b&gt;deprecated&lt;/b&gt; because:</source>
          <target state="translated">이 &lt;code&gt;DataFlavor&lt;/code&gt; 는 다음과 같은 이유로 &lt;b&gt;더 이상 사용되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a94761c9fc06aa6df0ec0f6c2e4b04e9a7754980" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;FileAttributeView&lt;/code&gt; provides a view of a file's user-defined attributes as a set of name/value pairs, where the attribute name is represented by a &lt;code&gt;String&lt;/code&gt;. An implementation may require to encode and decode from the platform or file system representation when accessing the attribute. The value has opaque content. This attribute view defines the &lt;a href=&quot;#read(java.lang.String,java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; methods to read the value into or write from a &lt;a href=&quot;../../bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;FileAttributeView&lt;/code&gt; is not intended for use where the size of an attribute value is larger than &lt;a href=&quot;../../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;FileAttributeView&lt;/code&gt; 는 파일의 사용자 정의 속성보기를 이름 / 값 쌍의 집합으로 제공합니다. 여기서 속성 이름은 &lt;code&gt;String&lt;/code&gt; 으로 표시됩니다 . 구현시 속성에 액세스 할 때 플랫폼 또는 파일 시스템 표현에서 인코딩 및 디코딩해야 할 수 있습니다. 값에 불투명 한 내용이 있습니다. 이 속성보기는 &lt;a href=&quot;../../bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; &lt;/a&gt; 에서 값을 읽거나 쓰기 위한 &lt;a href=&quot;#read(java.lang.String,java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 메소드를 정의합니다 . 이 &lt;code&gt;FileAttributeView&lt;/code&gt; 는 속성 값의 크기가 &lt;a href=&quot;../../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 보다 큰 경우 사용하기위한 것이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="e7dca1afa768c61eb8246089859bd808f78d59fc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;FileAttributeView&lt;/code&gt; provides a view of a file's user-defined attributes as a set of name/value pairs, where the attribute name is represented by a &lt;code&gt;String&lt;/code&gt;. An implementation may require to encode and decode from the platform or file system representation when accessing the attribute. The value has opaque content. This attribute view defines the &lt;a href=&quot;userdefinedfileattributeview#read-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; methods to read the value into or write from a &lt;a href=&quot;../../bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;FileAttributeView&lt;/code&gt; is not intended for use where the size of an attribute value is larger than &lt;a href=&quot;../../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;FileAttributeView&lt;/code&gt; 는 파일의 사용자 정의 속성보기를 이름 / 값 쌍 세트로 제공합니다. 여기서 속성 이름은 &lt;code&gt;String&lt;/code&gt; 으로 표시됩니다 . 구현시 속성에 액세스 할 때 플랫폼 또는 파일 시스템 표현에서 인코딩 및 디코딩해야 할 수 있습니다. 값에 불투명 한 내용이 있습니다. 이 속성보기는 &lt;a href=&quot;../../bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; &lt;/a&gt; 에서 값을 읽거나 쓸 수 있는 &lt;a href=&quot;userdefinedfileattributeview#read-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 메소드를 정의합니다 . 이 &lt;code&gt;FileAttributeView&lt;/code&gt; 는 속성 값의 크기가 &lt;a href=&quot;../../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 보다 큰 경우 사용하기위한 것이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="192cbe98cd1c85864afc298aebdfde8926cbabb4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Graphics2D&lt;/code&gt; class extends the &lt;a href=&quot;graphics&quot;&gt;&lt;code&gt;Graphics&lt;/code&gt;&lt;/a&gt; class to provide more sophisticated control over geometry, coordinate transformations, color management, and text layout.</source>
          <target state="translated">이 &lt;code&gt;Graphics2D&lt;/code&gt; 클래스는 &lt;a href=&quot;graphics&quot;&gt; &lt;code&gt;Graphics&lt;/code&gt; &lt;/a&gt; 클래스를 확장하여 기하학, 좌표 변환, 색상 관리 및 텍스트 레이아웃에 대한보다 정교한 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f61e08625365c2213c595965bea2c14367ca5f93" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Graphics2D&lt;/code&gt; class extends the &lt;a href=&quot;graphics&quot;&gt;&lt;code&gt;Graphics&lt;/code&gt;&lt;/a&gt; class to provide more sophisticated control over geometry, coordinate transformations, color management, and text layout. This is the fundamental class for rendering 2-dimensional shapes, text and images on the Java(tm) platform.</source>
          <target state="translated">이 &lt;code&gt;Graphics2D&lt;/code&gt; 클래스는 &lt;a href=&quot;graphics&quot;&gt; &lt;code&gt;Graphics&lt;/code&gt; &lt;/a&gt; 클래스를 확장하여 기하학, 좌표 변환, 색상 관리 및 텍스트 레이아웃에 대한보다 정교한 제어를 제공합니다. Java (tm) 플랫폼에서 2 차원 도형, 텍스트 및 이미지를 렌더링하기위한 기본 클래스입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
