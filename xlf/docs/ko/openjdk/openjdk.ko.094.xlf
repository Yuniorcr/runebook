<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="363aa2bf9bc4403e90b3304537b4850955de2d6f" translate="yes" xml:space="preserve">
          <source>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.</source>
          <target state="translated">이 버퍼에 맵핑 된 파일이 로컬 저장 장치에 상주하는 경우이 메소드가 리턴 할 때 버퍼가 작성된 이후 또는이 메소드가 마지막으로 호출 된 이후에 버퍼에 대한 모든 변경 사항이 해당 디바이스에 기록되었음을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="5d3f80a7c47e0dee8ff25771e1984095801d55de" translate="yes" xml:space="preserve">
          <source>If the file system and files remain static, then this method implements an equivalence relation for non-null &lt;code&gt;Paths&lt;/code&gt;.</source>
          <target state="translated">파일 시스템과 파일이 정적으로 유지되면이 메소드는 널이 아닌 &lt;code&gt;Paths&lt;/code&gt; 대한 등가 관계를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="bf2540a956606dd24c05d911dfb014b7471baead" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;#lastModifiedTime()&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 액세스 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메서드는 구현 특정 기본값 (일반적으로 &lt;a href=&quot;#lastModifiedTime()&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;FileTime&lt;/code&gt; )을 반환합니다. epoch를 나타내는 (1970-01-01T00 : 00 : 00Z).</target>
        </trans-unit>
        <trans-unit id="1cc09fc7cf4f903c9ad57909dbe23e700dcd6cfb" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 액세스 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값, 일반적으로 &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 신기원을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; (1970-01-01T00 : 00)을 리턴합니다 . 00Z).</target>
        </trans-unit>
        <trans-unit id="fa544bd520d9dcec26b2ece7f7dc9e779d24b413" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last modification then this method returns an implementation specific default value, typically a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 수정 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값 (일반적으로 신기원 (1970-01-01T00 : 00 : 00Z)을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; )을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="02f361be725f40f9d2cf1b1f7f87f23ccb88afbd" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;#lastModifiedTime()&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 파일이 생성 된 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메서드는 구현 특정 기본값 (일반적으로 &lt;a href=&quot;#lastModifiedTime()&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 epoch를 나타내는 &lt;code&gt;FileTime&lt;/code&gt; (1970-01-01T00 : 00 : 00Z).</target>
        </trans-unit>
        <trans-unit id="823bb3918b8c7dfd2716375b3397ec3520a2d6b4" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현에서 파일이 생성 된 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값, 일반적으로 &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 신기원 (1970-01-01T00)을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; 을 리턴합니다 . 00 : 00Z).</target>
        </trans-unit>
        <trans-unit id="cbaa60988de0c25a04ce29dd95934e886dae24fd" translate="yes" xml:space="preserve">
          <source>If the file system object identified by this object is currently registered with the watch service then the watch key, representing that registration, is returned after changing the event set or modifiers to those specified by the &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;modifiers&lt;/code&gt; parameters. Changing the event set does not cause pending events for the object to be discarded. Objects are automatically registered for the &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt;&lt;code&gt;OVERFLOW&lt;/code&gt;&lt;/a&gt; event. This event is not required to be present in the array of events.</source>
          <target state="translated">이 오브젝트에 의해 식별 된 파일 시스템 오브젝트가 현재 감시 서비스에 등록 된 경우, 이벤트 세트 또는 수정자를 &lt;code&gt;events&lt;/code&gt; 및 &lt;code&gt;modifiers&lt;/code&gt; 매개 변수에 의해 지정된 것으로 변경 한 후 해당 등록을 나타내는 감시 키가 리턴 됩니다. 이벤트 세트를 변경해도 오브젝트의 보류중인 이벤트가 삭제되지 않습니다. &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt; &lt;code&gt;OVERFLOW&lt;/code&gt; &lt;/a&gt; 이벤트에 객체가 자동으로 등록됩니다 . 이 이벤트는 이벤트 배열에 존재할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="459754495e8f2fc830a24baaf3d7fd1c98e3b5d4" translate="yes" xml:space="preserve">
          <source>If the file system supports &lt;a href=&quot;package-summary#links&quot;&gt;symbolic links&lt;/a&gt; then this method is used to read the target of the link, failing if the file is not a symbolic link. The target of the link need not exist. The returned &lt;code&gt;Path&lt;/code&gt; object will be associated with the same file system as &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">파일 시스템이 &lt;a href=&quot;package-summary#links&quot;&gt;기호 링크&lt;/a&gt; 를 지원하는 경우이 방법은 링크 대상을 읽는 데 사용되며 파일이 기호 링크가 아닌 경우 실패합니다. 링크의 대상이 없어도됩니다. 리턴 된 &lt;code&gt;Path&lt;/code&gt; 오브젝트는 &lt;code&gt;link&lt;/code&gt; 와 동일한 파일 시스템과 연관 됩니다.</target>
        </trans-unit>
        <trans-unit id="fb0c8d3a8a398a77e00455877d296ebfc50c2a10" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions()&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">파일 시스템이 다른 보안 관련 파일 속성 (예 : 파일 &lt;a href=&quot;posixfileattributes#permissions()&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt; 을 지원하는 경우 액세스 제어 목록을 업데이트하면 이러한 보안 관련 속성도 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7347290370c35baf47e41039a48176f518ba6b9" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">파일 시스템이 다른 보안 관련 파일 속성 (예 : 파일 &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt; 등)을 지원 하는 경우 액세스 제어 목록을 업데이트하면 이러한 보안 관련 속성도 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67de7dc4816dc3dd80c82da2f81ec2067ab1b35e" translate="yes" xml:space="preserve">
          <source>If the filter returns &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt;&lt;code&gt;Status.REJECTED&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;null&lt;/code&gt; or throws a &lt;a href=&quot;../lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;, the active &lt;code&gt;readObject&lt;/code&gt; or &lt;code&gt;readUnshared&lt;/code&gt; throws &lt;a href=&quot;invalidclassexception&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;, otherwise deserialization continues uninterrupted.</source>
          <target state="translated">필터가 &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt; &lt;code&gt;Status.REJECTED&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;null&lt;/code&gt; 을 반환 하거나 &lt;a href=&quot;../lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; 을&lt;/a&gt; throw 하면 활성 &lt;code&gt;readObject&lt;/code&gt; 또는 &lt;code&gt;readUnshared&lt;/code&gt; 가 &lt;a href=&quot;invalidclassexception&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; 을&lt;/a&gt; throw 하고 그렇지 않으면 deserialization이 중단없이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9f05868501904493829d0907142a7754fe1122ce" translate="yes" xml:space="preserve">
          <source>If the filter returns a value, the target must accept that value as its argument in position &lt;code&gt;pos&lt;/code&gt;, preceded and/or followed by any arguments not passed to the filter. If the filter returns void, the target must accept all arguments not passed to the filter. No arguments are reordered, and a result returned from the filter replaces (in order) the whole subsequence of arguments originally passed to the adapter.</source>
          <target state="translated">필터가 값을 반환하는 경우 대상은 해당 값을 위치 &lt;code&gt;pos&lt;/code&gt; 의 인수로, 필터에 전달되지 않은 인수 앞에 와야합니다. 필터가 void를 반환하면 대상은 필터에 전달되지 않은 모든 인수를 허용해야합니다. 다시 정렬 된 인수는 없으며 필터에서 리턴 된 결과는 원래 어댑터로 전달 된 인수의 전체 서브 시퀀스를 (순서대로) 대체합니다.</target>
        </trans-unit>
        <trans-unit id="4842b7ba908041edda9019cd8af48573f8706e76" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of bytes actually read.</source>
          <target state="translated">기본 스트림 의 첫 번째 &lt;code&gt;read&lt;/code&gt; 에서 파일 끝을 나타 내기 위해 &lt;code&gt;-1&lt;/code&gt; 을 반환 하면 이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 그렇지 않으면이 메소드는 실제로 읽은 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="33b359247ef4ee2d114342c7c506f4ed4d411b51" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of characters actually read.</source>
          <target state="translated">기본 스트림 의 첫 번째 &lt;code&gt;read&lt;/code&gt; 에서 파일 끝을 나타 내기 위해 &lt;code&gt;-1&lt;/code&gt; 을 반환 하면 이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 그렇지 않으면이 메소드는 실제로 읽은 문자 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ce60218f2510c7e7fddf8a7ccb70e4c23d7ed409" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN and the second argument is nonzero, then the result is NaN.</source>
          <target state="translated">첫 번째 인수가 NaN이고 두 번째 인수가 0이 아닌 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="8870d606c771442922f1503139366f1c5f6ffb42" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN, NaN is returned.</source>
          <target state="translated">첫 번째 인수가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9089269bb48d32b9328e7c9f2b5e776cab13b138" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and less than zero</source>
          <target state="translated">첫 번째 인수가 유한하고 0보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="40390f7aa327fdf0e7159e3c2ee52c76dda4cc5d" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and the second argument is infinite, then the result is the same as the first argument.</source>
          <target state="translated">첫 번째 인수가 유한하고 두 번째 인수가 무한하면 결과는 첫 번째 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="c79e66b15f81ddc9a951871c47a016d3318d1439" translate="yes" xml:space="preserve">
          <source>If the first argument is infinite, then an infinity of the same sign is returned.</source>
          <target state="translated">첫 번째 인수가 무한대이면 동일한 부호의 무한대가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7d4927f7484d5a09a609cfa4c9572e1d2c7f45" translate="yes" xml:space="preserve">
          <source>If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음수이고 두 번째 인수가 양수 0 또는 음수 0이거나 첫 번째 인수가 음의 무한대이고 두 번째 인수가 유한이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="c8e4a59b27a1fe3d520aae3637f149a7db9573ea" translate="yes" xml:space="preserve">
          <source>If the first argument is negative infinity and the second argument is positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음의 무한대이고 두 번째 인수가 양의 무한대이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="82b10d31a7012b44b539ae72f08e4e4c13a206b9" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음수이고 두 번째 인수가 음수이거나 첫 번째 인수가 음수이고 유한하며 두 번째 인수가 음수 무한대이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="8e475337333e7011c577f6dfd579b80f0f2ae245" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero.</source>
          <target state="translated">첫 번째 인수가 음수 0이고 두 번째 인수가 양수이거나 첫 번째 인수가 음수이고 유한하며 두 번째 인수가 양수 무한대이면 결과는 음의 0입니다.</target>
        </trans-unit>
        <trans-unit id="e71c64d3bcd633902a2d641246fcfc98d2800c74" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus character &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002D'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">첫 번째 인수가 음수이면 결과의 첫 번째 요소는 ASCII 빼기 문자 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002D'&lt;/code&gt; )입니다. 첫 번째 인수가 음수가 아닌 경우 결과에 부호 문자가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f757bab2a5b1e8678119d7c70a633d7f48cfbb1b" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus sign &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">첫 번째 인수가 음수이면 결과의 첫 번째 요소는 ASCII 빼기 기호 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002d'&lt;/code&gt; )입니다. 첫 번째 인수가 음수가 아닌 경우 결과에 부호 문자가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be73a6c34da2b109aed6beaf3902ff7b8fa1d76b" translate="yes" xml:space="preserve">
          <source>If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">첫 번째 인수가 양수이고 두 번째 인수가 양수 0 또는 음수 0이거나 첫 번째 인수가 양의 무한대이고 두 번째 인수가 유한이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="ebb6e09520d0766b54210b09e064a33ea2e4b570" translate="yes" xml:space="preserve">
          <source>If the first argument is positive infinity and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to 3*</source>
          <target state="translated">첫 번째 인수가 양의 무한대이고 두 번째 인수가 음의 무한대이면 결과는 3 *에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="a545d4a869ce0070ee3a2c5a7bd5c19feeb5e959" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">첫 번째 인수가 양수 0이고 두 번째 인수가 음수이거나 첫 번째 인수가 양수이고 유한하며 두 번째 인수가 음수 무한대이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="2b99cd366559b0aa882f76d5433c550ae23a29d2" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero.</source>
          <target state="translated">첫 번째 인수가 양수 0이고 두 번째 인수가 양수이거나 첫 번째 인수가 양수이고 유한하며 두 번째 인수가 양수 무한대이면 결과는 양수 0입니다.</target>
        </trans-unit>
        <trans-unit id="90dbabf1b114fed471b1a3cd65fc77c1740f1756" translate="yes" xml:space="preserve">
          <source>If the first argument is zero, then a zero of the same sign is returned.</source>
          <target state="translated">첫 번째 인수가 0이면 동일한 부호의 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a1663731875dc28dccca70ad4bb3ad9c2ee28bff" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;0xxxxxxx&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; means &quot;may be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;&quot;), then the group consists of just that byte. The byte is zero-extended to form a character.</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;0xxxxxxx&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; 는 &quot; &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 일 수 있음&quot;을 의미 함) 와 일치하면 그룹은 해당 바이트 로만 구성됩니다. 바이트는 0 확장되어 문자를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="43977f5f9b49b5f068ba277caf7c1c9b82cc82fa" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;110xxxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and a second byte &lt;code&gt;b&lt;/code&gt;. If there is no byte &lt;code&gt;b&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was the last of the bytes to be read), or if byte &lt;code&gt;b&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;110xxxxx&lt;/code&gt; 와 일치 하면 그룹은 해당 바이트 &lt;code&gt;a&lt;/code&gt; 와 두 번째 바이트 &lt;code&gt;b&lt;/code&gt; 로 구성 됩니다. 더 바이트가없는 경우 &lt;code&gt;b&lt;/code&gt; 를 (바이트 때문에 &lt;code&gt;a&lt;/code&gt; 읽을 수 바이트의 마지막), 또는 바이트의 경우 &lt;code&gt;b&lt;/code&gt; 는 비트 패턴과 일치하지 않는 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 , 다음 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생합니다. 그렇지 않으면 그룹이 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e5e1a187c24e47368e1814e48c4f2e5999e848" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;1110xxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and two more bytes &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. If there is no byte &lt;code&gt;c&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was one of the last two of the bytes to be read), or either byte &lt;code&gt;b&lt;/code&gt; or byte &lt;code&gt;c&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;1110xxxx&lt;/code&gt; 와 일치하면 그룹은 해당 바이트 &lt;code&gt;a&lt;/code&gt; 와 2 개 이상의 바이트 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 로 구성 됩니다. 아무 바이트 없으면 &lt;code&gt;c&lt;/code&gt; (바이트 때문에 &lt;code&gt;a&lt;/code&gt; 판독 될 바이트의 마지막 2 중 하나), 또는 두 바이트 &lt;code&gt;b&lt;/code&gt; 또는 바이트 &lt;code&gt;c&lt;/code&gt; 비트 패턴에 일치하지 않는 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 당시로서는, &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생합니다. 그렇지 않으면 그룹이 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b4205a0b70ecc18a1f7d17bb4cefe1ef7847e2c" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the pattern &lt;code&gt;1111xxxx&lt;/code&gt; or the pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown.</source>
          <target state="translated">그룹의 선두 바이트는 패턴과 일치하는 경우 &lt;code&gt;1111xxxx&lt;/code&gt; 또는 패턴 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 당시로서는, &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="de12fa584ec591ad89fe529ab99890cef05ff7df" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 첫 번째 문자 가 &lt;code&gt;'/'&lt;/code&gt; (절대 경로 이름을 나타냄) 인 경우이 기본 설정 노드의 잠금은 &lt;code&gt;path&lt;/code&gt; 를 토큰으로 나누기 전에 삭제 되며이 메서드는 루트에서 시작하는 경로를 반복적으로 탐색합니다 (이 노드에서 시작하지 않음). 그렇지 않으면 순회는 상대 경로 이름에 대해 설명 된 것과 동일합니다. &lt;a href=&quot;#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt; 따라 교착 상태의 가능성을 방지하려면 루트 노드에서 순회를 시작하기 전에이 노드에서 잠금을 삭제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fe4bd2bc924f289ce5e3e243830c506290c8bfa3" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;abstractpreferences#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 첫 번째 문자 가 &lt;code&gt;'/'&lt;/code&gt; (절대 경로 이름을 나타냄) 인 경우 &lt;code&gt;path&lt;/code&gt; 를 토큰으로 나누기 전에이 환경 설정 노드의 잠금이 삭제 되고이 메소드는 루트에서 시작하여 (이 노드에서 시작하지 않고) 경로를 재귀 적으로 탐색합니다. 통과는 상대 경로 이름에 대해 설명한 것과 동일합니다. 루트 노드에서 순회를 시작하기 전에이 노드에서 잠금을 삭제하는 것은 &lt;a href=&quot;abstractpreferences#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt; 따라 교착 상태의 가능성을 피하기 위해 필수적입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="de6a756f5a999d243dc3d549609d91cce131f2d6" translate="yes" xml:space="preserve">
          <source>If the first letter of the property defined by a getter is a capital, then this handler will look first for an item in the &lt;code&gt;CompositeData&lt;/code&gt; beginning with a capital, then, if that is not found, for an item beginning with the corresponding lowercase letter or code point. For a getter called &lt;code&gt;getNumber()&lt;/code&gt;, the handler will first look for an item called &lt;code&gt;Number&lt;/code&gt;, then for &lt;code&gt;number&lt;/code&gt;. If the getter is called &lt;code&gt;getnumber()&lt;/code&gt;, then the item must be called &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">getter에 의해 정의 된 속성의 첫 글자가 대문자 인 경우,이 핸들러는 먼저 &lt;code&gt;CompositeData&lt;/code&gt; 에서 대문자로 시작하는 항목을 찾은 다음 찾지 못하면 해당 소문자로 시작하는 항목 또는 코드 포인트. &lt;code&gt;getNumber()&lt;/code&gt; 라는 getter의 경우 핸들러는 먼저 &lt;code&gt;Number&lt;/code&gt; 라는 항목을 찾은 다음 &lt;code&gt;number&lt;/code&gt; 를 찾습니다 . getter가 &lt;code&gt;getnumber()&lt;/code&gt; 이면 항목을 &lt;code&gt;number&lt;/code&gt; 라고해야합니다. .</target>
        </trans-unit>
        <trans-unit id="c5b9fdddf990174b0c1bb31fd056338ffdb9f842" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C++-style comments are not treated specially.</source>
          <target state="translated">플래그 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 C ++ 스타일 주석은 특별히 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b755352a37aefb0ddd22fcf4ddac56889ee380f" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C-style comments are not treated specially.</source>
          <target state="translated">플래그 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 C 스타일 주석은 특별히 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed5b11ba23b450c90177463610accda7b5ef8311" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then the &lt;code&gt;sval&lt;/code&gt; field is not modified.</source>
          <target state="translated">flag 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우, &lt;code&gt;sval&lt;/code&gt; 필드는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a51b936e9c60259867a0c6a0a1415a7006e73bc6" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;false&lt;/code&gt;, delimiter characters serve to separate tokens. A token is a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">플래그가 &lt;code&gt;false&lt;/code&gt; 인 경우 구분 문자는 토큰을 분리하는 데 사용됩니다. 토큰은 분리 문자가 아닌 최대 연속 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="243de70bc00db3702139f3dd218555f6b229e223" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;true&lt;/code&gt;, delimiter characters are themselves considered to be tokens. A token is thus either one delimiter character, or a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">플래그가 &lt;code&gt;true&lt;/code&gt; 인 경우 구분 문자 자체는 토큰으로 간주됩니다. 따라서 토큰은 하나의 분리 문자이거나 분리 문자가 아닌 연속 된 최대 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="b5b0bc25b0d262fecfa18b60166faf5e2347e80f" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;true&lt;/code&gt;, this text component becomes user editable. If the flag is set to &lt;code&gt;false&lt;/code&gt;, the user cannot change the text of this text component. By default, non-editable text components have a background color of SystemColor.control. This default can be overridden by calling setBackground.</source>
          <target state="translated">플래그가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우이 텍스트 구성 요소는 사용자가 편집 할 수 있습니다. 플래그가 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 사용자는이 텍스트 구성 요소의 텍스트를 변경할 수 없습니다. 기본적으로 편집 할 수없는 텍스트 구성 요소의 배경색은 SystemColor.control입니다. 이 기본값은 setBackground를 호출하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57f350c5b50d157976b5f5f9a315e16106f5450" translate="yes" xml:space="preserve">
          <source>If the focused Window is a Frame or a Dialog it is also the active Window. Otherwise, the active Window is the first Frame or Dialog that is an owner of the focused Window.</source>
          <target state="translated">초점이 맞춰진 창이 프레임 또는 대화 상자이면 활성 창이기도합니다. 그렇지 않으면 활성 창은 포커스가있는 창의 소유자 인 첫 번째 프레임 또는 대화 상자입니다.</target>
        </trans-unit>
        <trans-unit id="56c6279667d7868f05ad4fddd3dde243109f6834" translate="yes" xml:space="preserve">
          <source>If the font is &lt;code&gt;null&lt;/code&gt; or a &lt;code&gt;UIResource&lt;/code&gt;, the defaults table is queried with the key &lt;code&gt;fontKey&lt;/code&gt;. All of &lt;code&gt;UIDefault's&lt;/code&gt; get methods throw a &lt;code&gt;
 NullPointerException&lt;/code&gt; if passed in &lt;code&gt;null&lt;/code&gt;. As such, unless otherwise noted each of the various install methods of &lt;code&gt;
 LookAndFeel&lt;/code&gt; throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the current value is &lt;code&gt;null&lt;/code&gt; or a &lt;code&gt;UIResource&lt;/code&gt; and the supplied defaults key is &lt;code&gt;null&lt;/code&gt;. In addition, unless otherwise specified all of the &lt;code&gt;install&lt;/code&gt; methods throw a &lt;code&gt;NullPointerException&lt;/code&gt; if a &lt;code&gt;null&lt;/code&gt; component is passed in.</source>
          <target state="translated">글꼴이 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;UIResource&lt;/code&gt; 인 경우 defaults 테이블은 &lt;code&gt;fontKey&lt;/code&gt; 키로 쿼리됩니다 . &lt;code&gt;UIDefault's&lt;/code&gt; 모든 get 메소드 는 &lt;code&gt;null&lt;/code&gt; 로 전달되면 &lt;code&gt; NullPointerException&lt;/code&gt; 을 발생 시킵니다. 따라서, 그렇지 않으면 여러 각각 언급하지 않는 방법 설치 &lt;code&gt; LookAndFeel&lt;/code&gt; 던져 &lt;code&gt;NullPointerException&lt;/code&gt; 이 전류 값 인 경우에는 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;UIResource&lt;/code&gt; 인터페이스 및 제공된 디폴트 키는 &lt;code&gt;null&lt;/code&gt; . 또한 별도로 지정하지 않는 한 모든 &lt;code&gt;install&lt;/code&gt; 메서드 는 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;NullPointerException&lt;/code&gt; 을 throw합니다. 구성 요소가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f77a5cbbfc5e7d2a5c0ad6a18e49115f1c49efaa" translate="yes" xml:space="preserve">
          <source>If the format of an argument loses information, such as with a choice format where a large number formats to &quot;many&quot;.</source>
          <target state="translated">인수 형식이 정보를 잃는 경우 (예 : 다수가 &quot;많은&quot;형식 인 선택 형식).</target>
        </trans-unit>
        <trans-unit id="0dcd3261c6e6bc40c628cfcd3ed02c38b9a8ba09" translate="yes" xml:space="preserve">
          <source>If the format specifier contains a width or precision with an invalid value or which is otherwise unsupported, then a &lt;a href=&quot;illegalformatwidthexception&quot;&gt;&lt;code&gt;IllegalFormatWidthException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; respectively will be thrown.</source>
          <target state="translated">형식 지정자가 유효하지 않은 값을 가진 너비 또는 정밀도를 포함하거나 지원되지 않는 경우 &lt;a href=&quot;illegalformatwidthexception&quot;&gt; &lt;code&gt;IllegalFormatWidthException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 각각 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="23d86bd64d57a83827a905eb3f62752e01b0a38e" translate="yes" xml:space="preserve">
          <source>If the formatter parses the same field more than once with different values, the result will be an error.</source>
          <target state="translated">포맷터가 다른 값으로 동일한 필드를 두 번 이상 구문 분석하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db3731fc2aa4a3e087228df78b6ed03888b9aa5c" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하면 매핑이 기록되지 않습니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 매핑이 기록되지 않습니다. 가장 일반적인 사용법은 다음과 같이 초기 매핑 값 또는 메모 결과로 제공되는 새 객체를 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="144af7e618eb46c9529d1d33c26d53810f2167da" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하는 경우 하면 매핑이 제거됩니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26f473bb6caf3da04b1285866c6a28b1b984ef5f" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 매핑이 제거됩니다 (또는 처음에없는 경우 부재 상태로 유지됨). 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91e50d7000baf56cbe84741a636dedc280c25287" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 매핑이 제거됩니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="926782c512e4f063b419e0421193c8c7a7433138" translate="yes" xml:space="preserve">
          <source>If the function succeeds, instrument &lt;code&gt;from&lt;/code&gt; is unloaded.</source>
          <target state="translated">기능이 성공하면 계측기 &lt;code&gt;from&lt;/code&gt; 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="253e6025d142f63cd0c731b35e5e54635921bd1e" translate="yes" xml:space="preserve">
          <source>If the function to map a module name to class loader throws an error or runtime exception then it is propagated to the caller of this method.</source>
          <target state="translated">모듈 이름을 클래스 로더에 매핑하는 함수가 오류 또는 런타임 예외를 throw하면이 메서드의 호출자에게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="32a91e07ee88bec0b9954a59c4de099b9aa8f328" translate="yes" xml:space="preserve">
          <source>If the garbage collector determines at a certain point in time that the referent of a phantom reference is &lt;a href=&quot;package-summary#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that time or at some later time it will enqueue the reference.</source>
          <target state="translated">가비지 콜렉터가 특정 시점에서 팬텀 참조의 참조가 &lt;a href=&quot;package-summary#reachability&quot;&gt;팬텀에 도달 할 수&lt;/a&gt; 있다고 판단하는 경우 해당 시간 또는 나중에 나중에 참조를 큐에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="53adf0e26e84566de9caa7cabb62afdabd38f865" translate="yes" xml:space="preserve">
          <source>If the gauge difference mode is used, the value of the derived gauge is calculated as the difference between the observed gauge values for two successive observations.</source>
          <target state="translated">게이지 차이 모드를 사용하는 경우 파생 게이지 값은 두 개의 연속 관측치에 대한 관측 게이지 값의 차이로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f36edc06d9e8ab3918e6499129015f8c141e7e54" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, an unchecked exception is thrown from &lt;code&gt;parallelSetAll&lt;/code&gt; and the array is left in an indeterminate state.</source>
          <target state="translated">생성기 함수에서 예외가 발생하면 &lt;code&gt;parallelSetAll&lt;/code&gt; 에서 검사되지 않은 예외가 발생 하고 배열이 미확인 상태로 남습니다.</target>
        </trans-unit>
        <trans-unit id="9d8173ed15e9b7709fd7094f05762f38b139637d" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</source>
          <target state="translated">생성기 함수에서 예외가 발생하면 호출자에게 릴레이되고 배열은 알 수없는 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="76782efd69d7292ec1741cf01ee5b2215277c044" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, This attribute will be set to &lt;a href=&quot;../../../../java.base/java/lang/thread#NORM_PRIORITY&quot;&gt;&lt;code&gt;Thread.NORM_PRIORITY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 에이 속성이 포함되지 않은 경우이 속성은 &lt;a href=&quot;../../../../java.base/java/lang/thread#NORM_PRIORITY&quot;&gt; &lt;code&gt;Thread.NORM_PRIORITY&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a37afbef057d6ba837b305b1cd9bad125d8e146" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, the &lt;code&gt;LockInfo&lt;/code&gt; object will be constructed from the value of the &lt;code&gt;lockName&lt;/code&gt; attribute.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 가이 속성을 포함하지 않는 경우, &lt;code&gt;LockInfo&lt;/code&gt; 오브젝트는 &lt;code&gt;lockName&lt;/code&gt; 속성 의 값에서 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e232e6d08b2921ecd51a0928548c7d20fb389fec" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, this attribute will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 에이 속성이 포함되지 않은 경우이 속성은 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1400b3eda5d304390a2540e7c1391b9930fe93a9" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, this attribute will be set to an empty array.</source>
          <target state="translated">주어진 &lt;code&gt;CompositeData&lt;/code&gt; 에이 속성이 포함되지 않은 경우이 속성은 빈 배열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0db7828d6899e244beb39f64663230573a2ea5f3" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;ProtectionDomain&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a default protection domain will be assigned to the class as specified in the documentation for &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int)&lt;/code&gt;&lt;/a&gt;. Before the class can be used it must be resolved.</source>
          <target state="translated">지정된 &lt;code&gt;ProtectionDomain&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이면&lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int)&lt;/code&gt; &lt;/a&gt; 문서에 지정된대로 기본 보호 도메인이 클래스에 할당됩니다 . 클래스를 사용하려면 먼저 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f34fbb4cfa40d33b09699390aae3ac53e8ab2c4" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;instant&lt;/code&gt; represents a point on the time-line too far in the future or past to fit in a &lt;code&gt;long&lt;/code&gt; milliseconds and nanoseconds adjustment, then an &lt;code&gt;ArithmeticException&lt;/code&gt; will be thrown.</source>
          <target state="translated">주어진 &lt;code&gt;instant&lt;/code&gt; 이 &lt;code&gt;long&lt;/code&gt; 밀리 초 및 나노초 조정 에 맞기에는 너무 먼 미래 또는 과거의 타임 라인 지점을 나타내는 경우 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15c5a383f51c24f8825b786eaae7ec8e4fc3e1be" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;module&lt;/code&gt; is an unnamed module, then this method is equivalent to calling &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;getBundle(baseName, targetLocale, module.getClassLoader()&lt;/code&gt;&lt;/a&gt; to load resource bundles that are visible to the class loader of the given unnamed module. Custom &lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt;&lt;code&gt;ResourceBundleControlProvider&lt;/code&gt;&lt;/a&gt; implementations, if present, will only be invoked if the specified module is an unnamed module.</source>
          <target state="translated">지정된 &lt;code&gt;module&lt;/code&gt; 이 이름이 지정되지 않은 모듈 인 경우이 메서드는 &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;getBundle(baseName, targetLocale, module.getClassLoader()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 지정된 이름이 지정되지 않은 모듈의 클래스 로더에 표시되는 리소스 번들을로드 하는 것과 동일 합니다. 사용자 지정 &lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt; &lt;code&gt;ResourceBundleControlProvider&lt;/code&gt; &lt;/a&gt; 구현 (있는 경우) , 지정된 모듈이 이름이없는 모듈 인 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0e16e73e1c388c5bcfaf11ed9189d8791a0ccfd7" translate="yes" xml:space="preserve">
          <source>If the given &lt;var&gt;inModelMBeanInfo&lt;/var&gt; does not contain any &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;GENERIC&lt;/code&gt; or &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; notifications, then the RequiredModelMBean will supply its own default &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt;s for those missing notifications.</source>
          <target state="translated">주어진 &lt;var&gt;inModelMBeanInfo&lt;/var&gt; 에 &lt;code&gt;GENERIC&lt;/code&gt; 또는 &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; 알림에 대한 &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; &lt;/a&gt; 가 포함되어 있지 않은 경우 RequiredModelMBean은 자체 기본 &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; 를 제공합니다.&lt;/a&gt; 누락 된 알림에 대해 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf86ec019e6dc9802020d9a480bb2d423505a7f3" translate="yes" xml:space="preserve">
          <source>If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">주어진 Collection이 &lt;a href=&quot;#unmodifiable&quot;&gt;수정 불가능한 List 인&lt;/a&gt; 경우 copyOf를 호출하면 일반적으로 복사본이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f10d628399ffa67f965f7a348c67ac7f2b5b2030" translate="yes" xml:space="preserve">
          <source>If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable Set&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">주어진 Collection이 &lt;a href=&quot;#unmodifiable&quot;&gt;수정 불가능한 Set 인&lt;/a&gt; 경우 copyOf를 호출하면 일반적으로 복사본이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d42f41fcf7ca04751155bf461b15402f39209e6a" translate="yes" xml:space="preserve">
          <source>If the given Map is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable Map&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">지정된 Map이 &lt;a href=&quot;#unmodifiable&quot;&gt;수정할 수없는 Map 인&lt;/a&gt; 경우 copyOf를 호출하면 일반적으로 복사본이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="871cb4309703aec2bc0023c758d9cf428cebc74f" translate="yes" xml:space="preserve">
          <source>If the given URI has an authority component then the new URI's authority and path are taken from the given URI.</source>
          <target state="translated">제공된 URI에 권한 구성 요소가 있으면 새 URI의 권한 및 경로가 지정된 URI에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e06d94bd934ab4eadeb7ce0dca1e7e7222d58665" translate="yes" xml:space="preserve">
          <source>If the given URI is already absolute, or if this URI is opaque, then the given URI is returned.</source>
          <target state="translated">제공된 URI가 이미 절대적이거나이 URI가 불투명 한 경우 지정된 URI가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2430c525f00d8a5ecee224a7a5b81e9aae39e412" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">지정된 URI의 조각 구성 요소가 정의되고 해당 경로 구성 요소가 비어 있고 해당 구성표, 권한 및 쿼리 구성 요소가 정의되지 않은 경우 지정된 조각이 있지만 다른 모든 구성 요소가이 URI의 구성 요소와 동일한 URI가 반환됩니다. 이를 통해 &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt; 와 같은 독립형 조각 참조를 나타내는 URI를 기본 URI에 대해 유용하게 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="409ab55de149be7ee7466f039641cd5cdd79e97a" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">주어진 URI의 조각 구성 요소가 정의되고 경로 구성 요소가 비어 있고 스키마, 권한 및 쿼리 구성 요소가 정의되지 않은 경우 주어진 조각이 있지만 다른 모든 구성 요소가이 URI의 구성 요소와 동일한 URI가 반환됩니다. 이렇게하면 &lt;code&gt;&quot;#foo&quot;&lt;/code&gt; 와 같은 독립형 조각 참조를 나타내는 URI가 기본 URI에 대해 유용하게 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c849fb5cce341a58fea462c01a105441e0cc9602" translate="yes" xml:space="preserve">
          <source>If the given URI's path is absolute then the new URI's path is taken from the given URI.</source>
          <target state="translated">주어진 URI의 경로가 절대적이면 새로운 URI의 경로는 주어진 URI에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="14f7899ffb21b582de61406576d434576cfac581" translate="yes" xml:space="preserve">
          <source>If the given address includes a JNDI directory URL as specified in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;, then this &lt;code&gt;RMIConnectorServer&lt;/code&gt; will bootstrap by binding the &lt;code&gt;RMIServerImpl&lt;/code&gt; to the given address.</source>
          <target state="translated">지정된 주소에 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt; 패키지 문서에 지정된 JNDI 디렉토리 URL이 포함되어있는 경우, 이 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 는 &lt;code&gt;RMIServerImpl&lt;/code&gt; 을 지정된 주소 에 바인딩하여 부트 스트랩 합니다.</target>
        </trans-unit>
        <trans-unit id="ca814afbdb188e0d8eb604c68dacd59c7bf69539" translate="yes" xml:space="preserve">
          <source>If the given alias already exists, the keystore information associated with it is overridden by the given key (and possibly certificate chain).</source>
          <target state="translated">지정된 별명이 이미 존재하면, 해당 별명과 연관된 키 저장소 정보는 제공된 키 (및 인증서 체인)에 의해 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3a595a56aadbb88b4114693edc5c1ee01ec9f96d" translate="yes" xml:space="preserve">
          <source>If the given alias identifies an existing entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, the trusted certificate in the existing entry is overridden by the given certificate.</source>
          <target state="translated">지정된 별명 식별 기존를 호출 해 작성된 엔트리 경우 &lt;code&gt;setCertificateEntry&lt;/code&gt; 의 호출에 의해, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A를 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 를 기존 항목에서 신뢰할 수있는 인증서는 지정된 증명서에 의해 오버라이드 (override)됩니다.</target>
        </trans-unit>
        <trans-unit id="5db25da879a6c8a2469a9ffa221b439cce428d7c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, then the trusted certificate contained in that entry is returned.</source>
          <target state="translated">지정된 별명 이름을 식별하는를 호출 해 작성된 엔트리 경우 &lt;code&gt;setCertificateEntry&lt;/code&gt; 의 호출에 의해, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A를 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 를이 다음 신뢰할 수있는 인증서가 해당 항목에 포함 된 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d4d7d88c3b4df9575339dccffaf79058f1c8930" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry (if a chain exists) is returned.</source>
          <target state="translated">경우 지정된 별명 식별하는 호출에 의해 생성 된 입력 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 , 그 엔트리의 인증서 체인의 다음의 첫 번째 요소는 (a 체인이 존재하는 경우)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="c2ed3e7db9906e449ddb9d356b3252474de4e64c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry is returned.</source>
          <target state="translated">주어진 별명 식별하는 호출에 의해 생성 된 진입하면 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 , 그 항목의 인증서 체인의 첫 번째 요소가 반환된다.</target>
        </trans-unit>
        <trans-unit id="80577b628d04d07146a4c8598f72bfad40ed28b3" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;#implConfigureBlocking(boolean)&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">주어진 차단 모드가 현재 차단 모드와 다른 &lt;a href=&quot;#implConfigureBlocking(boolean)&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt; 메서드는 모드를 변경하기 위해 적절한 잠금을 유지하면서 implConfigureBlocking 메서드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a7044af5535fc0b80bc9e6eb2af416837a93528e" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">주어진 차단 모드가 현재 차단 모드와 다른 &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt; 메소드는 모드를 변경하기 위해 적절한 잠금을 유지하면서 implConfigureBlocking 메소드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="099ac9d14ce6f3a8c241c4173bc2f3c060d37fae" translate="yes" xml:space="preserve">
          <source>If the given index is outside the list's range of cells, this method results in nothing.</source>
          <target state="translated">주어진 인덱스가 목록의 셀 범위를 벗어나면이 메서드는 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef47fccc5a72a56e061d58ffbc98135bb15f0e3b" translate="yes" xml:space="preserve">
          <source>If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">제공된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd6f94d655e9cba018e02791b4d2bafeaf0cd16b" translate="yes" xml:space="preserve">
          <source>If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only the base bundle as the resulting resource bundle.</source>
          <target state="translated">지정된 로케일이 동일한 경우 &lt;code&gt;Locale.ROOT&lt;/code&gt; (루트 로케일)하는 &lt;code&gt;List&lt;/code&gt; 만을 루트 포함 된 &lt;code&gt;Locale&lt;/code&gt; 반환해야합니다. 이 경우 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 팩토리 메소드는 기본 번들 만 결과 자원 번들로로드합니다.</target>
        </trans-unit>
        <trans-unit id="d78ff521c3166afea2224a7e827c542012a19f6e" translate="yes" xml:space="preserve">
          <source>If the given location is either a module oriented location, or an output location containing multiple modules, and no explicit modules prefix is given, a suitable module is inferred. If a suitable module cannot be inferred &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference.</source>
          <target state="translated">주어진 위치가 모듈 지향 위치이거나 여러 모듈을 포함하는 출력 위치이고 명시적인 모듈 접두사가 제공되지 않으면 적절한 모듈이 유추됩니다. 적합한 모듈을 유추 할 수없는 경우 &lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 구현은 추론의 일부로 주석 처리 도구의 구성에 대한 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd86b458fa6c5cb798c0359d6978ebb6799d62aa" translate="yes" xml:space="preserve">
          <source>If the given location is neither a &lt;a href=&quot;../../tools/javafilemanager.location#isModuleOrientedLocation()&quot;&gt;module oriented location&lt;/a&gt;, nor an &lt;a href=&quot;../../tools/javafilemanager.location#isOutputLocation()&quot;&gt;output location containing multiple modules&lt;/a&gt;, and the explicit module prefix is given, &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">지정된 위치가 &lt;a href=&quot;../../tools/javafilemanager.location#isModuleOrientedLocation()&quot;&gt;모듈 지향 위치&lt;/a&gt; 도 아니고 &lt;a href=&quot;../../tools/javafilemanager.location#isOutputLocation()&quot;&gt;여러 모듈을 포함&lt;/a&gt; 하는 출력 위치 도 아니고 명시 적 모듈 접두사가 제공되면 &lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a722054d6a8a85985b6af9a7f074ff6c9d6c5114" translate="yes" xml:space="preserve">
          <source>If the given method to be invoked, together with the provided signature, matches one of RequiredModelMbean accessible methods, this one will be call. Otherwise the call to the given method will be tried on the managed resource.</source>
          <target state="translated">제공된 서명과 함께 제공된 메소드가 RequiredModelMbean 액세스 가능 메소드 중 하나와 일치하면이 메소드가 호출됩니다. 그렇지 않으면 지정된 메소드에 대한 호출이 관리 자원에서 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="5903b5c68713e17c01106dc0242d392ba3fd13a3" translate="yes" xml:space="preserve">
          <source>If the given modality type is not supported, &lt;code&gt;MODELESS&lt;/code&gt; is used. You may want to call &lt;code&gt;getModalityType()&lt;/code&gt; after calling this method to ensure that the modality type has been set.</source>
          <target state="translated">주어진 모달 유형이 지원되지 않으면 &lt;code&gt;MODELESS&lt;/code&gt; 가 사용됩니다. 당신은 전화를 할 수 있습니다 &lt;code&gt;getModalityType()&lt;/code&gt; 모달 형식이 설정되어 있는지 확인하기 위해이 방법을 호출 한 후.</target>
        </trans-unit>
        <trans-unit id="7cf0a900811cd6f2b34fd3e614d21d91355d860b" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;ModuleDescriptor&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module descriptors are equal if each of their corresponding components is equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;ModuleDescriptor&lt;/code&gt; 가 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 각 해당 구성 요소가 같으면 두 모듈 설명자가 같습니다.</target>
        </trans-unit>
        <trans-unit id="265ee67148fb3d461cae1321c492c06ad8be4305" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Provides&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;Provides&lt;/code&gt; objects are equal if the service type is equal and the list of providers is equal.</source>
          <target state="translated">제공된 객체가 &lt;code&gt;Provides&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 서비스 유형이 같고 공급자 목록이 같으면 두 개의 &lt;code&gt;Provides&lt;/code&gt; 개체가 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9dc4b5ba6652e7ccce8cb26463d690c4e101f15" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Requires&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module dependence objects are equal if the module names are equal, set of modifiers are equal, and the compiled version of both modules is equal or not recorded for both modules.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Requires&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 모듈 이름이 같고 수정 자 집합이 같고 두 모듈의 컴파일 된 버전이 두 모듈에 대해 같거나 기록되지 않은 경우 두 모듈 종속성 개체는 같습니다.</target>
        </trans-unit>
        <trans-unit id="087eec123268666bb5ff587f9f3824a68696a44d" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;ResolvedModule&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;ResolvedModule&lt;/code&gt; objects are equal if they are in the same configuration and have equal references to the module content.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;ResolvedModule&lt;/code&gt; 이 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 &lt;code&gt;ResolvedModule&lt;/code&gt; 개체가 동일한 구성에 있고 모듈 콘텐츠에 대한 동일한 참조가 있으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cfd682a1d142327e25c86e6fd36c7f41a2a41ad9" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Version&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module version are equal if their corresponding components are equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Version&lt;/code&gt; 이 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 해당 구성 요소가 같으면 두 모듈 버전이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a79eac791e4b86cfc10aabf01a42570af6907767" translate="yes" xml:space="preserve">
          <source>If the given object is not a Path, or is a Path associated with a different &lt;code&gt;FileSystem&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 Path가 아니거나 다른 &lt;code&gt;FileSystem&lt;/code&gt; 에 관련한 Path 인 경우 ,이 메소드는 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="ab44b435bce5e6d0dd0d4400904c04dd1b50093c" translate="yes" xml:space="preserve">
          <source>If the given object is not a URI then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 URI가 아닌 경우,이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="dab849a2dfb627f012f49b202b71d39af39c2224" translate="yes" xml:space="preserve">
          <source>If the given object is not a URL then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 URL이 아닌 경우,이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="51317f50e868ccac84e6251d8aade86da12219ac" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;AclEntry&lt;/code&gt; then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 &lt;code&gt;AclEntry&lt;/code&gt; 가 아닌 경우, 이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="deee112803ae8aa28ebe1e7b06cce4d2e7efea17" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;Exports&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module exports objects are equal if their set of modifiers is equal, the package names are equal and the set of target module names is equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Exports&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 모듈 내보내기 객체는 수정 자 집합이 같고 패키지 이름이 같고 대상 모듈 이름 집합이 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ff01ba4aa3f9066a3a4d258504eb98e093cb3dd4" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;HttpHeaders&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two HTTP headers are equal if each of their corresponding &lt;a href=&quot;#map()&quot;&gt;maps&lt;/a&gt; are equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;HttpHeaders&lt;/code&gt; 가 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 각각의 해당 &lt;a href=&quot;#map()&quot;&gt;맵&lt;/a&gt; 이 동일 하면 두 개의 HTTP 헤더가 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2dc78364f9dc2b13b28a620cc038ded7d1559bd8" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;HttpRequest&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two HTTP requests are equal if their URI, method, and headers fields are all equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;HttpRequest&lt;/code&gt; 가 아니면이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 HTTP 요청은 URI, 메소드 및 헤더 필드가 모두 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a08bc86883e9dc33f9a3477bb9b5d3ab9ca49cb6" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;Opens&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;Opens&lt;/code&gt; objects are equal if their set of modifiers is equal, the package names are equal and the set of target module names is equal.</source>
          <target state="translated">주어진 객체가 &lt;code&gt;Opens&lt;/code&gt; 가 아닌 경우이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 두 개의 &lt;code&gt;Opens&lt;/code&gt; 오브젝트는 수정 자 세트가 같고 패키지 이름이 같고 대상 모듈 이름 세트가 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5067d1933a7fb6de041c489427ed9f038cbf2e5d" translate="yes" xml:space="preserve">
          <source>If the given path has &lt;em&gt;N&lt;/em&gt; elements, and no root component, and this path has &lt;em&gt;N&lt;/em&gt; or more elements, then this path ends with the given path if the last &lt;em&gt;N&lt;/em&gt; elements of each path, starting at the element farthest from the root, are equal.</source>
          <target state="translated">주어진 경로에 &lt;em&gt;N 개의&lt;/em&gt; 요소가 있고 루트 구성 요소가 &lt;em&gt;없고이&lt;/em&gt; 경로에 &lt;em&gt;N&lt;/em&gt; 개 이상의 요소가있는 경우 루트에서 가장 먼 요소에서 시작하여 각 경로 의 마지막 &lt;em&gt;N 개&lt;/em&gt; 요소가 동일한 경우이 경로는 제공된 경로로 끝납니다. .</target>
        </trans-unit>
        <trans-unit id="fe7eaf75c5ca09e9dc37afa7038d8c228c398461" translate="yes" xml:space="preserve">
          <source>If the given path has a root component then this path ends with the given path if the root component of this path &lt;em&gt;ends with&lt;/em&gt; the root component of the given path, and the corresponding elements of both paths are equal. Whether or not the root component of this path ends with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not end with the given path.</source>
          <target state="translated">지정된 경로에 루트 구성 요소가있는 경우이 경로의 루트 구성 요소가 지정된 경로의 루트 구성 요소로 &lt;em&gt;끝나고&lt;/em&gt; 두 경로의 해당 요소가 동일한 경우이 경로 &lt;em&gt;는&lt;/em&gt; 지정된 경로 로 &lt;em&gt;끝납니다&lt;/em&gt; . 이 경로의 루트 구성 요소가 주어진 경로의 루트 구성 요소로 끝나는 지 여부는 파일 시스템에 따라 다릅니다. 이 경로에 루트 구성 요소가없고 지정된 경로에 루트 구성 요소가 있으면이 경로는 지정된 경로로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fdc1f0bd8bdd66110dc3f031d4817dcf3caed63" translate="yes" xml:space="preserve">
          <source>If the given path is associated with a different &lt;code&gt;FileSystem&lt;/code&gt; to this path then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">주어진 경로 가이 경로 와 다른 &lt;code&gt;FileSystem&lt;/code&gt; 과 연관되어 있으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4b2bf60e5452de4ddf9870cafed442c49431cf97" translate="yes" xml:space="preserve">
          <source>If the given provider is installed at the requested position, the provider that used to be at that position, and all providers with a position greater than &lt;code&gt;position&lt;/code&gt;, are shifted up one position (towards the end of the list of installed providers).</source>
          <target state="translated">지정된 프로 바이더가 요구 된 위치에 설치되어있는 경우, 그 위치에 있던 프로 바이더와보다 위치보다 모든 업체 &lt;code&gt;position&lt;/code&gt; , (인스톨되고있는 프로 바이더의리스트의 끝으로) 한 위치를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="0348730345bae0d2545ea8b21da48cf025a26fbe" translate="yes" xml:space="preserve">
          <source>If the given row number is negative, the cursor moves to an absolute row position with respect to the end of the result set. For example, calling the method &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row; calling the method &lt;code&gt;absolute(-2)&lt;/code&gt; moves the cursor to the next-to-last row, and so on.</source>
          <target state="translated">주어진 행 번호가 음수이면 커서는 결과 세트의 끝을 기준으로 절대 행 위치로 이동합니다. 예를 들어 &lt;code&gt;absolute(-1)&lt;/code&gt; 메서드를 호출 하면 커서가 마지막 행에 배치됩니다. &lt;code&gt;absolute(-2)&lt;/code&gt; 메서드를 호출하면 커서가 마지막 행으로 이동하는 식입니다.</target>
        </trans-unit>
        <trans-unit id="ebbca2e71ca391fdcf53f907a578f53411598fa7" translate="yes" xml:space="preserve">
          <source>If the given runnable attempts to make any mutations in this implementation, a deadlock will occur. There is no tracking of individual rendering threads to enable detecting this situation, but a subclass could incur the overhead of tracking them and throwing an error.</source>
          <target state="translated">주어진 runnable이이 구현에서 변형을 시도하면 교착 상태가 발생합니다. 이 상황을 감지 할 수 있도록 개별 렌더링 스레드를 추적하지는 않지만 하위 클래스는이를 추적하고 오류를 발생시키는 오버 헤드를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be7b3561a355e78f18cdeae419abf0ee5e2ea933" translate="yes" xml:space="preserve">
          <source>If the given size is less than the current size then the entity is truncated, discarding any bytes beyond the new end. If the given size is greater than or equal to the current size then the entity is not modified. In either case, if the current position is greater than the given size then it is set to that size.</source>
          <target state="translated">주어진 크기가 현재 크기보다 작 으면 엔터티가 잘리고 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 현재 크기보다 크거나 같으면 엔티티가 수정되지 않습니다. 두 경우 모두 현재 위치가 지정된 크기보다 큰 경우 해당 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aaefbc3d9c612129c52e3733260c322198b61ac6" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified.</source>
          <target state="translated">지정된 크기가 파일의 현재 크기보다 작 으면 파일이 잘리고 파일의 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 파일의 현재 크기보다 크거나 같으면 파일이 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87ded65bf156680a79571d8a9d909a68f908630c" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified. In either case, if this channel's file position is greater than the given size then it is set to that size.</source>
          <target state="translated">주어진 크기가 파일의 현재 크기보다 작 으면 파일이 잘리고 파일의 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 파일의 현재 크기보다 크거나 같으면 파일이 수정되지 않습니다. 두 경우 모두이 채널의 파일 위치가 지정된 크기보다 큰 경우 해당 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7dd1419e3ad877e5832a2e55c7efd5daa5e8f3e6" translate="yes" xml:space="preserve">
          <source>If the given type is not supported, &lt;code&gt;NO_EXCLUDE&lt;/code&gt; is used.</source>
          <target state="translated">지정된 유형이 지원되지 않으면 &lt;code&gt;NO_EXCLUDE&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee541dacfad38286ca16f7b64502c1de0394dbf6" translate="yes" xml:space="preserve">
          <source>If the gradient and graphics rendering transforms are uniformly scaled and the user sets the focus so that it coincides with the center of the circle, the gradient color proportions are equal for any line drawn from the center. The following figure shows the distances AB, BC, AD, and DE. They are all equal.</source>
          <target state="translated">그라디언트 및 그래픽 렌더링 변환이 균일하게 조정되고 사용자가 초점을 원의 중심과 일치하도록 설정하면 중심에서 그린 모든 선에 대해 그라디언트 색상 비율이 동일합니다. 다음 그림은 거리 AB, BC, AD 및 DE를 보여줍니다. 그들은 모두 동등합니다.</target>
        </trans-unit>
        <trans-unit id="0dd273a96dc30568917e48986c0b9215f521962c" translate="yes" xml:space="preserve">
          <source>If the gradient is acyclic then points on the P1 side of the segment have the constant &lt;code&gt;Color&lt;/code&gt; C1 while points on the P2 side have the constant &lt;code&gt;Color&lt;/code&gt; C2.</source>
          <target state="translated">그래디언트가 비순환이면 세그먼트의 P1 측에있는 점 은 일정한 &lt;code&gt;Color&lt;/code&gt; C1을 가지며 P2 측에있는 점은 일정한 &lt;code&gt;Color&lt;/code&gt; C2를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="896c9bfd563344965e7bce74bae30d109938cbeb" translate="yes" xml:space="preserve">
          <source>If the gradient is cyclic then the points on the extended P1, P2 connecting line cycle back and forth between the colors C1 and C2.</source>
          <target state="translated">그래디언트가 순환 적이면 확장 된 P1, P2 연결 선의 점이 색상 C1과 C2 사이를 앞뒤로 순환합니다.</target>
        </trans-unit>
        <trans-unit id="677a4e88376df9d9470bda35c5236fc7e5c9051a" translate="yes" xml:space="preserve">
          <source>If the group class name specified in the &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method will behave as if the group descriptor contained the name of the default activation group implementation class.</source>
          <target state="translated">&lt;code&gt;ActivationGroupDesc&lt;/code&gt; 에 지정된 그룹 클래스 이름 이 &lt;code&gt;null&lt;/code&gt; 이면이 메소드는 그룹 디스크립터에 기본 활성 그룹 구현 클래스의 이름이 포함 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f0b0bf2a45ec36e583f47ca33513286c575ec604" translate="yes" xml:space="preserve">
          <source>If the handler is not null and there is a security manager, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; permission. This may result in a SecurityException. No validation of the inputs is performed by this constructor.</source>
          <target state="translated">핸들러가 널이 아니고 보안 관리자가있는 &lt;code&gt;checkPermission&lt;/code&gt; , 보안 관리자의 checkPermission 메소드는 &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 SecurityException이 발생할 수 있습니다. 이 생성자는 입력의 유효성 검증을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd5ef3ee310fe9a2a0784c9212a810e58ed3a94b" translate="yes" xml:space="preserve">
          <source>If the history buffer is then rolled back (i.e. the last UndoableEdit undone), a DocumentEvent is sent to both views, causing both of them to reflect the undone mutation to the document (that is, the removal of the right component's mutation). If the history buffer again rolls back another change, another DocumentEvent is sent to both views, causing them to reflect the undone mutation to the document -- that is, the removal of the left component's mutation.</source>
          <target state="translated">그런 다음 히스토리 버퍼가 롤백되면 (즉, 마지막 UndoableEdit 실행 취소) DocumentEvent가 두보기 모두에 전송되어 두보기 모두 문서에 실행 취소 된 변형 (즉, 오른쪽 구성 요소의 변형 제거)이 반영됩니다. 히스토리 버퍼가 다른 변경 사항을 다시 롤백하면 다른 DocumentEvent가 두 뷰 모두에 전송되어 문서에 대한 실행 취소 된 변형, 즉 왼쪽 구성 요소의 변형이 제거 된 것을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="a7b208411b1f838553bd26f17a98bd6ecf12f387" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length()&lt;/code&gt; is equal to zero, then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">호스트가 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;host.length()&lt;/code&gt; 가 0이면 루프백 인터페이스의 주소를 나타내는 &lt;code&gt;InetAddress&lt;/code&gt; 가 반환됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; 섹션 2 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; 섹션 2.5.3을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82294cea404b457d7895b5f7849b8f8cdabef00b" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">호스트 인 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt;InetAddress&lt;/code&gt; 루프백 인터페이스의 주소를 나타내는가 반환됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; 섹션 2 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; 섹션 2.5.3을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13f82f51386e3d3d93037591572aea8cb88f6868" translate="yes" xml:space="preserve">
          <source>If the icon doesn't load, the border area is painted gray.</source>
          <target state="translated">아이콘이로드되지 않으면 테두리 영역이 회색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c743eca5b6b4b9d617040308e1ee27a4b7c6393" translate="yes" xml:space="preserve">
          <source>If the identity is marked as &quot;trusted&quot;, this allows an attacker to introduce a different public key (e.g., its own) that is not trusted by the system's identity scope, thereby granting applet or application code signed with that public key privileges that would have been denied otherwise.</source>
          <target state="translated">ID가 &quot;신뢰 됨&quot;으로 표시되면 공격자는 시스템의 ID 범위에서 신뢰하지 않는 다른 공개 키 (예 : 자체)를 도입하여 해당 공개 키 권한으로 서명 된 애플릿 또는 응용 프로그램 코드를 부여 할 수 있습니다. 그렇지 않으면 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="75b8821b16ad8c4bce7f71ae9f2499e34e968953" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default height.</source>
          <target state="translated">이미지를 사용자 지정 크기로 렌더링 할 수 있으면이 메서드는 기본 높이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4a58cc703a9db33b11b3faf9dca4d8e83b20a1f" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default width.</source>
          <target state="translated">이미지를 사용자 지정 크기로 렌더링 할 수 있으면이 메서드는 기본 너비를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="38702f2cc1d6bfec3cbebca538696adacba267f7" translate="yes" xml:space="preserve">
          <source>If the image has completely loaded and its pixels are no longer being changed, then &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and as more of the image becomes available or it is time to draw another frame of animation, the process that loads the image notifies the specified image observer.</source>
          <target state="translated">이미지가 완전히로드되고 픽셀이 더 이상 변경되지 않으면 &lt;code&gt;drawImage&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;drawImage&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 더 많은 이미지를 사용할 수있게되거나 다른 애니메이션 프레임을 그릴 때가되면 이미지를로드하는 프로세스가 지정된 이미지 관찰자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="a0b05514b8f5d731608326b087f332a040bf4271" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values.</source>
          <target state="translated">이미지를 임의의 크기로 렌더링 할 수있는 경우 소스 너비와 높이를 제공된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1e4e52ec311e9e75dd4cc081567f1eae9e6bf20f" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values. Note that the values returned from the &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; methods on &lt;code&gt;ImageReader&lt;/code&gt; are not affected by this method; they will continue to return the default size for the image. Similarly, if the image is also tiled the tile width and height are given in terms of the default size.</source>
          <target state="translated">이미지를 임의의 크기로 렌더링 할 수 있으면 소스 너비와 높이를 제공된 값으로 설정하십시오. &lt;code&gt;ImageReader&lt;/code&gt; 의 &lt;code&gt;getWidth&lt;/code&gt; 및 &lt;code&gt;getHeight&lt;/code&gt; 메소드에서 리턴 된 값 은이 메소드의 영향을받지 않습니다. 이미지의 기본 크기를 계속 반환합니다. 마찬가지로 이미지가 타일링 된 경우 타일 너비와 높이는 기본 크기와 관련하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3b13126a7b6fc1071a110411ef949559c81f856f" translate="yes" xml:space="preserve">
          <source>If the image represents an animated image, it will be animated automatically.</source>
          <target state="translated">이미지가 애니메이션 이미지를 나타내는 경우 자동으로 애니메이션됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a7ef1905b7717e6534c8262beb9af466dbbe75" translate="yes" xml:space="preserve">
          <source>If the image type is TYPE_BYTE_BINARY, the number of entries in the color model is used to determine whether the image should have 1, 2, or 4 bits per pixel. If the color model has 1 or 2 entries, the image will have 1 bit per pixel. If it has 3 or 4 entries, the image with have 2 bits per pixel. If it has between 5 and 16 entries, the image will have 4 bits per pixel. Otherwise, an IllegalArgumentException will be thrown.</source>
          <target state="translated">이미지 유형이 TYPE_BYTE_BINARY 인 경우 색상 모델의 항목 수를 사용하여 이미지에 픽셀 당 1, 2 또는 4 비트가 있어야하는지 여부를 결정합니다. 색상 모델에 1 개 또는 2 개의 항목이있는 경우 이미지에는 픽셀 당 1 비트가 있습니다. 항목이 3 개 또는 4 개인 경우 이미지는 픽셀 당 2 비트입니다. 항목이 5 개에서 16 개 사이 인 경우 이미지는 픽셀 당 4 비트를 갖습니다. 그렇지 않으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d7ce886e7cf517b9dd1b8e4bf3972fb87acfaf11" translate="yes" xml:space="preserve">
          <source>If the implementation can supply a value for one of the queries listed in the if statement of the default implementation, then it must do so. For example, an application-defined &lt;code&gt;HourMin&lt;/code&gt; class storing the hour and minute must override this method as follows:</source>
          <target state="translated">구현이 기본 구현의 if 문에 나열된 쿼리 중 하나에 대한 값을 제공 할 수 있으면 그렇게해야합니다. 예를 들어, 시간과 분을 저장 하는 응용 프로그램 정의 &lt;code&gt;HourMin&lt;/code&gt; 클래스는 다음과 같이이 메서드를 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">구현이 요청 된 유형의 객체 또는 작업을 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="8ab19508e52ba992a5a553d39a65472031820996" translate="yes" xml:space="preserve">
          <source>If the implementation of this class does not support persistence, an &lt;a href=&quot;../mbeanexception&quot;&gt;&lt;code&gt;MBeanException&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;../servicenotfoundexception&quot;&gt;&lt;code&gt;ServiceNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 클래스의 구현이 지속성을 지원하지 않는 경우 &lt;a href=&quot;../mbeanexception&quot;&gt; &lt;code&gt;MBeanException&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../servicenotfoundexception&quot;&gt; &lt;code&gt;ServiceNotFoundException&lt;/code&gt; 를&lt;/a&gt; 랩핑 MBeanException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="05e9c8575bf962e5c616ffc00d01915b9381d7c7" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시키면 MBean 서버는 각각 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부에서이를 다시 발생 시킵니다. 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외가 발생 하더라도 MBean의 상태는 변경되지 않습니다. MBean은 이미 성공적으로 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b030ce654ec4888a547056d4d3abf6da997ebc0c" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시키면 MBean 서버는 각각 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부에서이를 다시 발생 시킵니다. 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외를 던지면 MBean의 상태가 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="61497ea0a67eb203673d203a0f2b5369b019bf33" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 &lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;각각 RuntimeErrorException. 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외를 던져도MBean의 상태가 변경되지는 않습니다. MBean이 이미 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b96b5c5ec491812d30a354e2cb6f11721b2e2b1d" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 각각 &lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부의 것을 Throw합니다 . 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외가 발생합니다. MBean의 상태는 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4535342913d52819782cb269ae901b36379460f0" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 각각 . 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외를 던져도 MBean의 상태가 변경되지는 않습니다. MBean이 이미 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="76763841aca1fa1b12ea5b878cc85e9f7cde9edb" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 각각 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부의 것을 Throw합니다 . 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외를 던져도 MBean의 상태는 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1a75de9cc725b96c1261a9ca528b8f0bb1b31691" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the &lt;code&gt;PROCESSING&lt;/code&gt; or &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the &lt;code&gt;PROCESSING&lt;/code&gt; or &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the &lt;code&gt;CANCELED&lt;/code&gt; or &lt;code&gt;ABORTED&lt;/code&gt; job states.</source>
          <target state="translated">구현시 &lt;code&gt;PROCESSING&lt;/code&gt; 또는 &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; 작업 상태 에서 작업을 취소하는 데 측정 가능한 시간이 필요한 경우 프린터는이 이유를 사용하여 작업이 &lt;code&gt;PROCESSING&lt;/code&gt; 또는 &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; 상태 에있는 동안 프린터가 여전히 작업에 대해 일부 작업을 수행하고 있음을 나타내야합니다 . 모든 작업의 ​​작업 설명 속성이 증가를 중지하면 프린터는 작업을 PROCESSING 상태에서 &lt;code&gt;CANCELED&lt;/code&gt; 또는 &lt;code&gt;ABORTED&lt;/code&gt; 작업 상태로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e5a527012aa1181404e26ff9eba79c5215c6617c" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the PROCESSING or PROCESSING_STOPPED job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the PROCESSING or PROCESSING_STOPPED state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the CANCELED or ABORTED job states.</source>
          <target state="translated">구현이 PROCESSING 또는 PROCESSING_STOPPED 작업 상태에서 작업을 취소하는 데 측정 가능한 시간이 필요한 경우, 프린터는이 이유를 사용하여 작업이 PROCESSING 또는 PROCESSING_STOPPED 상태에있는 동안 프린터가 여전히 작업에 대해 일부 조치를 수행하고 있음을 표시해야합니다. 모든 작업의 ​​작업 설명 속성 증가가 중지 된 후 프린터는 작업을 처리 중 상태에서 취소 또는 중단 된 작업 상태로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="21a96789298a278046ce067991e2d31d04c7cbd4" translate="yes" xml:space="preserve">
          <source>If the implementation supports</source>
          <target state="translated">구현이 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="9c61e0dd2f97968224ba5bded184eb2a44d95c79" translate="yes" xml:space="preserve">
          <source>If the implementation supports a history mechanism, a reference to an Edit implementation will be returned, otherwise null.</source>
          <target state="translated">구현이 히스토리 메커니즘을 지원하는 경우 편집 구현에 대한 참조가 반환되고 그렇지 않으면 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="35f873dd7c2035b38202cda19f7fef9dd8dbdb3b" translate="yes" xml:space="preserve">
          <source>If the implementing method determines that no transformations are needed, it should return &lt;code&gt;null&lt;/code&gt;. Otherwise, it should create a new &lt;code&gt;byte[]&lt;/code&gt; array, copy the input &lt;code&gt;classfileBuffer&lt;/code&gt; into it, along with all desired transformations, and return the new array. The input &lt;code&gt;classfileBuffer&lt;/code&gt; must not be modified.</source>
          <target state="translated">구현 방법이 변환이 필요하지 않다고 판단하면 &lt;code&gt;null&lt;/code&gt; 을 반환해야합니다 . 그렇지 않으면, 새로운 &lt;code&gt;byte[]&lt;/code&gt; 배열을 생성하고 , 원하는 모든 변환과 함께 입력 &lt;code&gt;classfileBuffer&lt;/code&gt; 를 복사 하고 새로운 배열을 반환해야합니다. 입력 &lt;code&gt;classfileBuffer&lt;/code&gt; 를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="81ca206f6782401fcc1f26d127affa8acd0e136d" translate="yes" xml:space="preserve">
          <source>If the implementing object is an instance of java.beans.beancontext.BeanContext, or a subinterface thereof, then that BeanContext should fire a PropertyChangeEvent, to its registered BeanContextMembershipListeners, with parameters:</source>
          <target state="translated">구현 객체가 java.beans.beancontext.BeanContext의 인스턴스 또는 그 하위 인터페이스 인 경우 해당 BeanContext는 매개 변수를 사용하여 등록 된 BeanContextMembershipListeners에 PropertyChangeEvent를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="36b6757dd0b7b9698143f2e5d681dfa198ff7d6d" translate="yes" xml:space="preserve">
          <source>If the incoming object does not implement any additional interfaces known to the writer, the writer has no choice but to access it via the standard &lt;code&gt;IIOMetadata&lt;/code&gt; interfaces such as the tree view provided by &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt;. In this case, there is likely to be significant loss of information.</source>
          <target state="translated">수신 객체가 작가로 알려진 추가 인터페이스를 구현하지 않는 경우, 작가는 선택의 여지가 있지만, 표준 통한 액세스를로 &lt;code&gt;IIOMetadata&lt;/code&gt; 에서 제공하는 트리보기와 같은 인터페이스 &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt; . 이 경우 정보가 크게 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e436d84bd4232b4579b6124cd808ff4918e211d5" translate="yes" xml:space="preserve">
          <source>If the inherited channel is a datagram-oriented socket then a &lt;a href=&quot;../datagramchannel&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt; is returned. The datagram channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">상속 된 채널이 데이터 그램 지향 소켓이면 &lt;a href=&quot;../datagramchannel&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 데이터 그램 채널은 적어도 초기에 차단 모드에 있으며 소켓 주소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3073a336a578c76af3c2fae533b0dcd45d01e490" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented connected socket then a &lt;a href=&quot;../socketchannel&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The socket channel is, at least initially, in blocking mode, bound to a socket address, and connected to a peer.</source>
          <target state="translated">상속 된 채널이 스트림 지향 연결 소켓을 나타내는 경우 &lt;a href=&quot;../socketchannel&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 소켓 채널은 적어도 초기에 블로킹 모드에 있으며 소켓 주소에 바인딩되어 있고 피어에 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="875d948792bb0df4386ddee7ed26751e7f15e361" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented listening socket then a &lt;a href=&quot;../serversocketchannel&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The server-socket channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">상속 된 채널이 스트림 지향 청취 소켓을 나타내는 경우 &lt;a href=&quot;../serversocketchannel&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다. 서버 소켓 채널은 적어도 초기에는 차단 모드에 있으며 소켓 주소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="046cd8116ea31a7deaa92b344ddffcaddc10e57f" translate="yes" xml:space="preserve">
          <source>If the input byte array is not in valid Base64 encoding scheme then some bytes may have been written to the output byte array before IllegalargumentException is thrown.</source>
          <target state="translated">입력 바이트 배열이 유효한 Base64 인코딩 체계가 아닌 경우 IllegalargumentException이 발생하기 전에 일부 바이트가 출력 바이트 배열에 기록되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44c010f5bf051b0a98a728de40056665c0f4201b" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information,  Kerberos Requirements</source>
          <target state="translated">입력 이름에 영역이 없으면 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 특성을 통해 지정할 수 있습니다. 자세한 내용은 Kerberos 요구 사항</target>
        </trans-unit>
        <trans-unit id="e2258789d44cebf2e677dac1a6ecd85ab5667fdc" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see  Kerberos Requirements.</source>
          <target state="translated">입력 이름에 영역이 없으면 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 특성을 통해 지정할 수 있습니다. 자세한 내용은 Kerberos 요구 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a73e715c93a5e0127bac80ed71051dc7af6a5b8" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos Requirements&lt;/a&gt;. Additionally, if a security manager is installed, a &lt;a href=&quot;servicepermission&quot;&gt;&lt;code&gt;ServicePermission&lt;/code&gt;&lt;/a&gt; must be granted and the service principal of the permission must minimally be inside the &lt;code&gt;KerberosPrincipal&lt;/code&gt;'s realm. For example, if the result of &lt;code&gt;new KerberosPrincipal(&quot;user&quot;)&lt;/code&gt; is &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt;, then a &lt;code&gt;ServicePermission&lt;/code&gt; with service principal &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (and any action) must be granted.</source>
          <target state="translated">입력 이름에 영역이 포함되지 않은 경우 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 속성을 통해 지정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos 요구 사항을&lt;/a&gt; 참조하십시오 . 또한 보안 관리자가 설치된 경우 &lt;a href=&quot;servicepermission&quot;&gt; &lt;code&gt;ServicePermission&lt;/code&gt; &lt;/a&gt; 을 부여해야하며 권한의 서비스 주체는 최소한 &lt;code&gt;KerberosPrincipal&lt;/code&gt; 영역 내에 있어야합니다 . 예를 들어 &lt;code&gt;new KerberosPrincipal(&quot;user&quot;)&lt;/code&gt; 의 결과 가 &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt; 이면 서비스 주체가 &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (및 모든 작업) 인 &lt;code&gt;ServicePermission&lt;/code&gt; 을 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="72db9a55602aeaacd8d06804f6747b4e1ec98ac6" translate="yes" xml:space="preserve">
          <source>If the input sequence is mutable, it must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">입력 시퀀스가 ​​변경 가능한 경우 터미널 스트림 작업을 실행하는 동안 입력 시퀀스가 ​​일정하게 유지되어야합니다. 그렇지 않으면 터미널 스트림 작업의 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc4fd432cad2c0de1cfdac5a329f31d55c9e12d" translate="yes" xml:space="preserve">
          <source>If the inserted character is '-', it is accepted.</source>
          <target state="translated">삽입 된 문자가 '-'이면 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d3dcf4d36e88edd9ce623dd444c8f85abfe0b1" translate="yes" xml:space="preserve">
          <source>If the inserted character matches the mask for the next non-literal character, it is accepted at the new location.</source>
          <target state="translated">삽입 된 문자가 리터럴이 아닌 다음 문자의 마스크와 일치하면 새 위치에서 승인됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcd5cc0d6714ef6dfe7ad5151f92554586e46cb" translate="yes" xml:space="preserve">
          <source>If the intended destination of this stream is an abstraction provided by the underlying operating system, for example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed to the operating system for writing; it does not guarantee that they are actually written to a physical device such as a disk drive.</source>
          <target state="translated">이 스트림의 의도 된 목적지가 기본 운영 체제 (예 : 파일)에 의해 제공되는 추상화 인 경우, 스트림을 비우면 이전에 스트림에 기록 된 바이트 만 운영 체제로 전달되어 기록됩니다. 디스크 드라이브와 같은 실제 장치에 실제로 기록되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6dbed2351bbf5adacbd2e790b9255ca10dfcf5cc" translate="yes" xml:space="preserve">
          <source>If the internal frame is already closed, this method does nothing and returns immediately. Otherwise, this method begins by firing an &lt;code&gt;INTERNAL_FRAME_CLOSING&lt;/code&gt; event. Then this method sets the &lt;code&gt;closed&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; unless a listener vetoes the property change. This method finishes by making the internal frame invisible and unselected, and then firing an &lt;code&gt;INTERNAL_FRAME_CLOSED&lt;/code&gt; event.</source>
          <target state="translated">내부 프레임이 이미 닫힌 경우이 메서드는 아무 작업도 수행하지 않고 즉시 반환합니다. 그렇지 않으면이 메서드는 &lt;code&gt;INTERNAL_FRAME_CLOSING&lt;/code&gt; 이벤트 를 발생시켜 시작됩니다 . 그런 다음이 메서드는 리스너가 속성 변경을 거부하지 않는 한 &lt;code&gt;closed&lt;/code&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정합니다 . 이 메서드는 내부 프레임을 표시하지 않고 선택 취소 한 다음 &lt;code&gt;INTERNAL_FRAME_CLOSED&lt;/code&gt; 이벤트 를 발생시켜 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="81483551df6d9559fcbeffe5f6509d97a94497cc" translate="yes" xml:space="preserve">
          <source>If the internal frame is not visible, brings the internal frame to the front, makes it visible, and attempts to select it.</source>
          <target state="translated">내부 프레임이 보이지 않으면 내부 프레임을 앞으로 가져 와서 표시 한 다음 선택을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5939dca1837b7f5c342938c51c20c51e55fd3d33" translate="yes" xml:space="preserve">
          <source>If the internal frame is not visible, brings the internal frame to the front, makes it visible, and attempts to select it. The first time the internal frame is made visible, this method also fires an &lt;code&gt;INTERNAL_FRAME_OPENED&lt;/code&gt; event. This method does nothing if the internal frame is already visible. Invoking this method has the same result as invoking &lt;code&gt;setVisible(true)&lt;/code&gt;.</source>
          <target state="translated">내부 프레임이 보이지 않으면 내부 프레임을 앞으로 가져 와서 표시 한 다음 선택을 시도합니다. 내부 프레임이 처음 표시 될 때이 메서드는 &lt;code&gt;INTERNAL_FRAME_OPENED&lt;/code&gt; 이벤트 도 발생합니다 . 이 메서드는 내부 프레임이 이미 표시되어 있으면 아무 작업도 수행하지 않습니다. 이 메서드를 호출하는 것은 &lt;code&gt;setVisible(true)&lt;/code&gt; 를 호출하는 것과 동일한 결과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="881b9ec107691ccb0574603b5fa37effa233e5be" translate="yes" xml:space="preserve">
          <source>If the invoked method completes normally, the value it returns is copied in the &lt;code&gt;value&lt;/code&gt; property. Note that the &lt;code&gt;value&lt;/code&gt; property is set to &lt;code&gt;null&lt;/code&gt;, if the return type of the underlying method is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">호출 된 메소드가 정상적으로 완료되면 리턴 된 &lt;code&gt;value&lt;/code&gt; 이 value 특성에 복사됩니다 . 점을 유의 &lt;code&gt;value&lt;/code&gt; 속성으로 설정된 &lt;code&gt;null&lt;/code&gt; 기본 메소드의 리턴 타입 인 경우, &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55fa409a4b17ed3350505c8e7edb658e38fe64b1" translate="yes" xml:space="preserve">
          <source>If the invoking thread is interrupted while waiting to acquire the lock then its interrupt status will be set and a &lt;a href=&quot;filelockinterruptionexception&quot;&gt;&lt;code&gt;FileLockInterruptionException&lt;/code&gt;&lt;/a&gt; will be thrown. If the invoker's interrupt status is set when this method is invoked then that exception will be thrown immediately; the thread's interrupt status will not be changed.</source>
          <target state="translated">잠금 획득을 기다리는 동안 호출 스레드가 인터럽트되면 해당 인터럽트 상태가 설정되고 &lt;a href=&quot;filelockinterruptionexception&quot;&gt; &lt;code&gt;FileLockInterruptionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 이 메소드를 호출 할 때 호출자의 인터럽트 상태가 설정되면 해당 예외가 즉시 발생합니다. 스레드의 인터럽트 상태는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b769fc50fe26f32efef5297788dde55385ed9b56" translate="yes" xml:space="preserve">
          <source>If the item at the specified index is not selected, then the operation is ignored.</source>
          <target state="translated">지정된 인덱스의 항목을 선택하지 않으면 작업이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="609b6cb5da70d41c83a3aac10202e485bae19735" translate="yes" xml:space="preserve">
          <source>If the item is the first one being added to the choice, then the item becomes selected. Otherwise, if the selected item was one of the items shifted, the first item in the choice becomes the selected item. If the selected item was no among those shifted, it remains the selected item.</source>
          <target state="translated">항목이 선택 항목에 추가되는 첫 번째 항목이면 항목이 선택됩니다. 그렇지 않고 선택한 항목이 이동 된 항목 중 하나 인 경우 선택 항목의 첫 번째 항목이 선택한 항목이됩니다. 이동 한 항목 중 선택한 항목이 없으면 선택한 항목이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2c303e208ec2fac91ffa790d4de069ee4e7cc5" translate="yes" xml:space="preserve">
          <source>If the iteration variable type &lt;code&gt;V&lt;/code&gt; is dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">반복 변수 유형 &lt;code&gt;V&lt;/code&gt; 가 내부 매개 변수 목록에서 삭제되면 결과로 생성되는 더 짧은 목록 &lt;code&gt;(A...)&lt;/code&gt; &lt;em&gt;외부 매개 변수 목록&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="677df4c5c3a72284b193dc3046a802a47d947204" translate="yes" xml:space="preserve">
          <source>If the iteration variable types &lt;code&gt;(V I)&lt;/code&gt; are dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">반복 변수 유형 &lt;code&gt;(V I)&lt;/code&gt; 이 내부 매개 변수 목록에서 삭제되면 결과로 생성되는 더 짧은 목록 &lt;code&gt;(A...)&lt;/code&gt; &lt;em&gt;외부 매개 변수 목록&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="3b2f8ee14f1a5134aa879886d0c902676ccbfafd" translate="yes" xml:space="preserve">
          <source>If the iteration variable types &lt;code&gt;(V T)&lt;/code&gt; are dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">반복 변수 유형 &lt;code&gt;(V T)&lt;/code&gt; 이 내부 매개 변수 목록에서 삭제되면 결과로 생성되는 더 짧은 목록 &lt;code&gt;(A...)&lt;/code&gt; &lt;em&gt;외부 매개 변수 목록&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="ace7c9d0c03c5a8591ce4f875b6cfb21a9fe43d8" translate="yes" xml:space="preserve">
          <source>If the jar file is on the class path, VendorJavaCompiler can be located using code like this:</source>
          <target state="translated">jar 파일이 클래스 경로에있는 경우 VendorJavaCompiler는 다음과 같은 코드를 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05798c7b9d831dc45d92f33b15f7f3c7a9524b15" translate="yes" xml:space="preserve">
          <source>If the key agreement algorithm requires random bytes, it gets them from the given source of randomness, &lt;code&gt;random&lt;/code&gt;. However, if the underlying algorithm implementation does not require any random bytes, &lt;code&gt;random&lt;/code&gt; is ignored.</source>
          <target state="translated">키 합의 알고리즘에 임의의 바이트가 필요한 경우, 임의의 지정된 &lt;code&gt;random&lt;/code&gt; 소스 random로부터 가져옵니다 . 그러나 기본 알고리즘 구현에 임의 바이트가 필요하지 않은 경우 &lt;code&gt;random&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ba2d545a01554992fedf0cb983cad56e6a2aca" translate="yes" xml:space="preserve">
          <source>If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.</source>
          <target state="translated">키가 하드웨어 장치에 저장된 경우 해당 사양에는 장치의 키를 식별하는 데 도움이되는 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9af549a3a519458df47c4c31dbda4adcd0e3257" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, This method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어에 다른 형식의 서식과 독립 실행 형 사용이 필요한 경우이 메서드는 짧은 달 이름을 서식 형식으로 반환합니다. 예를 들어, 1 월 카탈로니아 어로 선호되는 약어는 &lt;em&gt;degen입니다. &lt;/em&gt;&lt;em&gt;gen&lt;/em&gt; 형식 인 동안 서식 형식으로 독립형으로. 이 메소드는 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 리턴합니다 . 이 경우 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;LDML (Unicode Locale Data Markup Language) 사양&lt;/a&gt; 의 달력 요소 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93f027224547b6049ea9e0bfa7e65c576dd00372" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns month names in the formatting form. For example, the preferred month name for January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어에 다른 형식의 서식과 독립 실행 형 사용이 필요한 경우이 메서드는 서식 형식으로 월 이름을 반환합니다. 예를 들어, 체코 어로 1 월에 선호하는 월 이름 은 형식화 형식으로 &lt;em&gt;ledna&lt;/em&gt; 이고 독립형 형식으로 &lt;em&gt;leden&lt;/em&gt; 입니다. 이 경우이 메소드는 &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; 를 리턴합니다 . 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;LDML (Unicode Locale Data Markup Language) 사양&lt;/a&gt; 의 달력 요소 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4df908f1fac23c580aff4bb5a5d73c49f92ce060" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어가 형식화 및 독립 실행 형 사용을 위해 다른 형식을 요구하는 경우이 메서드는 형식화 형식에 짧은 월 이름을 반환합니다. 예를 들어, 카탈루냐어에서 1 월에 선호되는 약어는 &lt;em&gt;de gen입니다. &lt;/em&gt;형식화 형식이지만 &lt;em&gt;gen입니다. &lt;/em&gt;독립형 형태로. 이 메서드는 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 반환합니다 . 이 경우. 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode Locale Data Markup Language (LDML) 사양&lt;/a&gt; 의 캘린더 요소 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="f1bf4283a4aed636a8a304bb68dccc18d01e161c" translate="yes" xml:space="preserve">
          <source>If the layout manager uses a per-component string, adds the component &lt;code&gt;comp&lt;/code&gt; to the layout, associating it with the string specified by &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">레이아웃 관리자가 컴포넌트 별 문자열을 사용하는 경우 컴포넌트 &lt;code&gt;comp&lt;/code&gt; 를 레이아웃에 추가하여 &lt;code&gt;name&lt;/code&gt; 으로 지정된 문자열과 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="721e40fbee0b627fcc6ccf4dd39ef80c9c24cc65" translate="yes" xml:space="preserve">
          <source>If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 의 길이 가 0이면 바이트를 읽지 않고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 적어도 1 바이트를 읽으려고합니다. 스트림이 파일의 끝에 있기 때문에 사용 가능한 바이트가 없으면 값 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 적어도 하나의 바이트를 읽고 &lt;code&gt;b&lt;/code&gt; 에 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="945b37877bd5c51ba536e667136d3b4286b64c37" translate="yes" xml:space="preserve">
          <source>If the length of the argument string is &lt;code&gt;0&lt;/code&gt;, then this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence that is the concatenation of the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object and the character sequence represented by the argument string.</source>
          <target state="translated">인수 문자열의 길이가 &lt;code&gt;0&lt;/code&gt; 이면이 &lt;code&gt;String&lt;/code&gt; 객체가 반환됩니다. 그렇지 않으면, &lt;code&gt;String&lt;/code&gt; 객체는 문자 시퀀스의 연결이로 표시되는 문자 순서 나타내 반환되는 &lt;code&gt;String&lt;/code&gt; 오브젝트 인수의 캐릭터 라인이 나타내는 문자 순서를.</target>
        </trans-unit>
        <trans-unit id="0940fb46aa425a706a545b01258cef980fd6db8a" translate="yes" xml:space="preserve">
          <source>If the length of the specified &lt;code&gt;CharSequence&lt;/code&gt; is less than or equal to zero, then an empty buffer of capacity &lt;code&gt;16&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 &lt;code&gt;CharSequence&lt;/code&gt; 의 길이 가 0보다 작거나 같은 경우 용량 &lt;code&gt;16&lt;/code&gt; 의 빈 버퍼 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="383b812813a9ca054e67e8d7ed50b33281ee93ba" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open(javax.sound.sampled.AudioFormat)&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">행이 열려 있지 않고 열지 않은 경우 기본 형식을 반환합니다. 기본 형식은 구현 특정 오디오 형식이거나, 이 &lt;code&gt;DataLine&lt;/code&gt; 을 검색하는 데 사용 된 &lt;code&gt;DataLine.Info&lt;/code&gt; 개체가 하나 이상의 정규화 된 오디오 형식을 지정하는 경우 마지막 형식이 기본 형식으로 사용됩니다. 특정 오디오 형식 (예 : &lt;a href=&quot;sourcedataline#open(javax.sound.sampled.AudioFormat)&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt; ) 으로 라인을 열면 기본 형식이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="009a7b082a7f277c626ca216eb6dd0590efc9900" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">줄이 열려 있지 않고 열리지 않은 경우 기본 형식을 반환합니다. 기본 형식은 구현 별 오디오 형식이거나, 이 &lt;code&gt;DataLine&lt;/code&gt; 을 검색하는 데 사용 된 &lt;code&gt;DataLine.Info&lt;/code&gt; 객체가 하나 이상의 정규화 된 오디오 형식을 지정하는 경우 마지막 형식이 기본 형식으로 사용됩니다. 특정 오디오 형식으로 라인을 열면 (예 : &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt; ) 기본 형식을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="7863f26128f8bba0e665024d8f8516c082ac4867" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">목록이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에 목록보다 많은 요소가있는 경우) 컬렉션의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다. . (이것은 목록의 길이를 결정하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="9d2a9e6acfe01f48880cc127c76590e8af39df2a" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">목록이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에 목록보다 많은 요소가있는 경우) 목록의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . (이것은 목록의 길이를 결정하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="e2a6a2c57017a029e9ebb7681d955085f7ded61a" translate="yes" xml:space="preserve">
          <source>If the list is an instance of &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; then the default implementation creates a spliterator that traverses elements by invoking the method &lt;a href=&quot;#get(int)&quot;&gt;&lt;code&gt;get(int)&lt;/code&gt;&lt;/a&gt;. If such invocation results or would result in an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; then the spliterator will &lt;em&gt;fail-fast&lt;/em&gt; and throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. If the list is also an instance of &lt;a href=&quot;abstractlist&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt; then the spliterator will use the list's &lt;a href=&quot;abstractlist#modCount&quot;&gt;&lt;code&gt;modCount&lt;/code&gt;&lt;/a&gt; field to provide additional &lt;em&gt;fail-fast&lt;/em&gt; behavior.</source>
          <target state="translated">목록이 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 의 인스턴스 인 경우 기본 구현은 &lt;a href=&quot;#get(int)&quot;&gt; &lt;code&gt;get(int)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 요소를 순회하는 분할자를 만듭니다 . 이러한 호출이 발생하거나 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 이 &lt;em&gt;발생&lt;/em&gt; 하는 경우 분할자는 &lt;em&gt;실패 속도를&lt;/em&gt; 내고 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 를 . 목록이 &lt;a href=&quot;abstractlist&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt; 의 인스턴스이기도 한 경우 스플리터는 목록의 &lt;a href=&quot;abstractlist#modCount&quot;&gt; &lt;code&gt;modCount&lt;/code&gt; &lt;/a&gt; 필드를 사용하여 추가 &lt;em&gt;페일&lt;/em&gt; 패스 동작 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1566f18ef0180d3aac88323daa9341914ba885e6" translate="yes" xml:space="preserve">
          <source>If the list's list-iterator does not support the &lt;code&gt;set&lt;/code&gt; operation then an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown when replacing the first element.</source>
          <target state="translated">리스트의리스트 반복자가 &lt;code&gt;set&lt;/code&gt; 조작을 지원하지 않는 경우는 최초의 요소를 교체 할 때 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae175c3216a75f24ee407fdf582572db3c498ef" translate="yes" xml:space="preserve">
          <source>If the listener is registered more than once, perhaps with different filters or callbacks, this method will remove all those registrations.</source>
          <target state="translated">리스너가 다른 필터 또는 콜백으로 두 번 이상 등록 된 경우이 메소드는 모든 등록을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="54b665bbf8eb506dbbe12fdda9847f03e69a163c" translate="yes" xml:space="preserve">
          <source>If the literal is empty, nothing is added to the formatter.</source>
          <target state="translated">리터럴이 비어 있으면 포맷터에 아무것도 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5586e5fb737ecf0129eedcffc9670c2876a5d020" translate="yes" xml:space="preserve">
          <source>If the load average is not available, a negative value is returned.</source>
          <target state="translated">로드 평균을 사용할 수 없으면 음수 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="612e3af41a7467295225df330e80d3aa55f31393" translate="yes" xml:space="preserve">
          <source>If the loading of the content handler class would be performed by a classloader that is outside of the delegation chain of the caller, the JVM will need the RuntimePermission &quot;getClassLoader&quot;.</source>
          <target state="translated">컨텐츠 핸들러 클래스의로드가 호출자의 위임 체인 외부에있는 클래스 로더에 의해 수행되는 경우 JVM에는 RuntimePermission &quot;getClassLoader&quot;가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1001411e7601e30ddd0e0c79cdc5159c320dbf60" translate="yes" xml:space="preserve">
          <source>If the local part is &lt;code&gt;null&lt;/code&gt; an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. A local part of &quot;&quot; is allowed to preserve compatible behavior with QName 1.0.</source>
          <target state="translated">로컬 부분 인 경우 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다. &quot;&quot;의 로컬 부분은 QName 1.0과 호환되는 동작을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a740773690bece4f01892057f26d0f5a3505d90" translate="yes" xml:space="preserve">
          <source>If the locale contains &quot;nu&quot; (numbers) and/or &quot;rg&quot; (region override) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the decimal digits, and/or the country used for formatting are overridden. If both &quot;nu&quot; and &quot;rg&quot; are specified, the decimal digits from the &quot;nu&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">로케일에 &quot;nu&quot;(숫자) 및 / 또는 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우 10 진수 및 / 또는 서식 지정에 사용 된 국가가 재정의됩니다. &quot;nu&quot;와 &quot;rg&quot;가 모두 지정되면 &quot;nu&quot;확장의 10 진수가 &quot;rg&quot;확장의 암시 적 숫자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="cfd944ef78cfcaae58d9f89252c3afdb5b581936" translate="yes" xml:space="preserve">
          <source>If the locale contains &quot;rg&quot; (region override) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbols are overridden for the designated region.</source>
          <target state="translated">로케일에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우 기호는 지정된 지역에 대해 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd82e30f2bfd2487deb48a3cd1ca525cc48b4ce" translate="yes" xml:space="preserve">
          <source>If the locale contains the &quot;rg&quot; (region override) &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the formatting pattern is overridden with the one appropriate for the region.</source>
          <target state="translated">로케일에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;유니 코드 확장이&lt;/a&gt; 포함되어 있으면 해당 지역에 적합한 형식으로 서식 지정 패턴이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5d4e75ab16c0169470cb2e36bf63130f893a3f1a" translate="yes" xml:space="preserve">
          <source>If the locale contains the time zone with &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, and time zone hasn't been given explicitly, time zone in the locale is used.</source>
          <target state="translated">로케일에 &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장자&lt;/a&gt; 가있는 시간대가 포함되어 있고 시간대가 명시 적으로 지정되지 않은 경우 로케일의 시간대가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13aecb53d0af72473665627440df7f59b9fad86f" translate="yes" xml:space="preserve">
          <source>If the locale contains the time zone with &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, that time zone is used instead.</source>
          <target state="translated">로케일에 &quot;tz&quot;가있는 시간대가 포함 된 경우 &lt;a href=&quot;locale#def_locale_extension&quot;&gt; 유니 코드 확장자&lt;/a&gt; 시간대가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb7426e4160f2b1fe5d7220ffa07b99d6ba7024b" translate="yes" xml:space="preserve">
          <source>If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is followed.</source>
          <target state="translated">로케일이 정확히 &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; 인 경우 먼저 &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; 로 변환됩니다. 다음 위의 절차를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c64c3966e3d4abb3a14f499628ce198c1164f906" translate="yes" xml:space="preserve">
          <source>If the lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">현재 스레드에서 잠금을 획득하면 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="822233d82712d166731e9dcca011715ab8bbe1d8" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the lock hold count is set to one.</source>
          <target state="translated">잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴되고 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="243ddf2fd70f54733945fc92a2c6210895bc2219" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e267ec383786f22b490efc4cbeb5a239987b49eb" translate="yes" xml:space="preserve">
          <source>If the lock is available this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">잠금이 사용 가능한 경우이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="3b3629e1c7a434db3fa94e4624595c63c91c3763" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="bc3fb57c41848bc377b297ddabc5e3ff9216fa1a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="9a8c566c06708381b95a076b6d0a7ff9c3dd5f9a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 잠금이 확보 될 때까지 휴면 상태가되어 잠금 보유 계수가 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d853278a5b45d2ebee3420faecb6ce65095ece12" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the write lock has been acquired, at which time the write lock hold count is set to one.</source>
          <target state="translated">잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 쓰기 잠금이 확보 될 때까지 휴면 상태가되며,이 때 쓰기 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="918d784e15001f2097233989116a220695ba3605" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다른 thread에 의해 락이 보관 유지되고있는 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="85233bd93c41bf81d5bd16d44009dd4101f01d92" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링을 위해 비활성화되며 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcde55af63c37dc1d170326de90648dbad927ec" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</source>
          <target state="translated">잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 잠금을 획득 할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="98452bdc04ba24a75162b80592faf24a66256700" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp.</source>
          <target state="translated">잠금 상태가 주어진 스탬프와 일치하면 원자 적으로 스탬프가 잠금을 유지하고 있음을 나타내면 잠금을 해제하고 관찰 스탬프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9531444c267d5feba915ddbb6e8e98d082819147" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">잠금 상태가 주어진 스탬프와 일치하면 원자 적으로 스탬프가 잠금을 유지하고 있음을 나타내면 잠금을 해제하고 관찰 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 유효성이 확인되면 반환합니다. 이 메서드는 다른 모든 경우에 0을 반환하므로 &quot;tryUnlock&quot;형식으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a09e194cce7b274be7295eeba5f7cce4ea171773" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">잠금 상태가 주어진 스탬프와 일치하면 스탬프가 잠금 유지를 나타내는 경우 잠금을 해제하고 관찰 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 유효성이 검증 된 경우이를 읽습니다. 이 메소드는 다른 모든 경우에 0을 리턴하므로 &quot;tryUnlock&quot;의 양식으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02dbead9b54aba8193788d721d9f35fe265e8ac" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 작업 중 하나를 원자 적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c68f8e544ee0dc6483d80e98a4e234377462da50" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 작업 중 하나를 원자 적으로 수행합니다. 스탬프가 쓰기 잠금을 유지하고 있음을 나타내면이를 해제하고 읽기 잠금을 얻습니다. 또는 읽기 잠금 인 경우 반환합니다. 또는 낙관적 읽기 인 경우 읽기 잠금을 획득하고 즉시 사용 가능한 경우에만 읽기 스탬프를 반환합니다. 이 메서드는 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4406ed634a16a7a2fc6a312ac7fcd3088591c18" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 작업 중 하나를 원자 적으로 수행합니다. 스탬프가 쓰기 잠금을 유지하고 있음을 나타내면 반환합니다. 또는 읽기 잠금이있는 경우 쓰기 잠금을 사용할 수있는 경우 읽기 잠금을 해제하고 쓰기 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 즉시 사용 가능한 경우에만 쓰기 스탬프를 반환합니다. 이 메서드는 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eefa68914d354c4eea9a7f9d2e87edb5b5d3616c" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 조치 중 하나를 수행하십시오. 스탬프가 쓰기 잠금 보유를 나타내는 경우 해제하여 읽기 잠금을 얻습니다. 또는 읽기 잠금 인 경우이를 리턴합니다. 또는 낙관적 읽기 인 경우 읽기 잠금을 획득하고 즉시 사용 가능한 경우에만 읽기 스탬프를 반환합니다. 이 방법은 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3fe6cd5b7f1314dfe53912057e75419a458d6c46" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 조치 중 하나를 수행하십시오. 스탬프가 쓰기 잠금 유지를 나타내는 경우 반환합니다. 또는 읽기 잠금 인 경우 쓰기 잠금이 사용 가능한 경우 읽기 잠금을 해제하고 쓰기 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 즉시 사용 가능한 경우에만 쓰기 스탬프를 반환합니다. 이 방법은 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14a53c83eff403dc5c623bd9e147872ed3ff94fc" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the corresponding mode of the lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 해당 잠금 모드를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3114f1897355cfbc96b7a2b2a9909376a9675347" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the exclusive lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 독점 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4a3ebac76180e9eaa8e069fe7a9c0cce392315b8" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the non-exclusive lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 비 독점 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e004c7523986b5ecc4e1749a86febcd1a6784511" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 CONFIG 메시지 레벨에 대해 사용 가능한 경우 지정된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2480ae012f96dc55272b45f972094f52d29f7772" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 CONFIG 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f74f4184b1114d21694c20083bffeca6773ddbdc" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINE 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ef129fafed8fea9b1b19398062aeaf0403caccda" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINE 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5c488b5e8261b0b9f6a94d2c335e06b774d3e4c2" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINER 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="400e0c53967d73d6073541aa2955ecfaedacc619" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINER 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c08c72ddfcb02350456ab868e8db332930e255e4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINEST 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="776e22483061c922dbf981169c45b199faadcb6b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINEST 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3de4bfb7369cf5faf7dd1122bdabc955fddf2e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 INFO 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c2334c2c90239d4c59ec8c7a0e4b1e0b78f35b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 INFO 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ab7e0ed2e38d83c57cfc908b346ba953ba01ea6e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 SEVERE 메시지 레벨에 대해 사용 가능한 경우, 주어진 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8e167659c676fd6a76d1a8ff361acf900cf2dee4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 SEVERE 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="700de6b174ae4293a822d7062908049e15243b9c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 WARNING 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8548b61ec8126b5ee81ca57df60b3e51531c5a8a" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 WARNING 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5a707ce3f0ebdced7855946db27b8b7e46bf0539" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message &lt;code&gt;level&lt;/code&gt; then a corresponding &lt;code&gt;LogRecord&lt;/code&gt; is created and forwarded to all the registered output &lt;code&gt;Handler&lt;/code&gt; objects.</source>
          <target state="translated">로거가 현재 주어진 메시지 &lt;code&gt;level&lt;/code&gt; 대해 활성화 된 경우 해당 &lt;code&gt;LogRecord&lt;/code&gt; 가 생성되어 등록 된 모든 출력 &lt;code&gt;Handler&lt;/code&gt; 전달됩니다. 객체로 .</target>
        </trans-unit>
        <trans-unit id="b378f215976c2e18ee9b57b56cfaa682e43ca7e1" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message &lt;code&gt;level&lt;/code&gt; then the given arguments are stored in a &lt;code&gt;LogRecord&lt;/code&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 &lt;code&gt;level&lt;/code&gt; 대해 활성화되어있는 경우 지정된 인수는 등록 된 모든 출력 핸들러로 전달 되는 &lt;code&gt;LogRecord&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="2998fe288d20db38f6f02724d9a3e1e03f44693c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 해당 LogRecord가 작성되어 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5672874e662c52b70bec899dedf5a6f7d4107f79" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 인수는 LogRecord에 저장되며 등록 된 모든 출력 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0a20e1ab3ef4c4dda5575d5b6fbf96f00af911a8" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord's message is set to &quot;THROW&quot;.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 인수는 LogRecord에 저장되며 등록 된 모든 출력 핸들러로 전달됩니다. LogRecord의 메시지가 &quot;THROW&quot;로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="325dfec7a72934c84f66843540d89c8f3769035b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우, 주어진 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="09b15fa7220dfe741c8baffb5087e302fb89c908" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지를 구성하고 등록 된 모든 출력 핸들러 오브젝트로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c33be9e7edb44141d7868af8327eb0567ce6ec4f" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 주어진 메시지 수준에 대해 활성화되어있는 경우 제공된 공급자 기능을 호출하여 메시지가 구성됩니다. 그러면 메시지와 주어진 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 에&lt;/a&gt; 저장됩니다. 등록 된 모든 출력 핸들러로 전달 .</target>
        </trans-unit>
        <trans-unit id="72eff8884364ee54a875323cb549fca604cb4b7b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지를 구성합니다. 그런 다음 메시지와 지정된 &lt;a href=&quot;../../lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 에&lt;/a&gt; 저장되며 등록 된 모든 출력 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="df68511496b32d8949f42994423a12d97c5a37a3" translate="yes" xml:space="preserve">
          <source>If the looked-up method has a &lt;a href=&quot;methodhandle#maxarity&quot;&gt;very large arity&lt;/a&gt;, the method handle creation may fail, due to the method handle type having too many parameters.</source>
          <target state="translated">조회 된 메소드의 특성이 &lt;a href=&quot;methodhandle#maxarity&quot;&gt;매우 큰&lt;/a&gt; 경우 메소드 핸들 유형에 매개 변수가 너무 많아 메소드 핸들 작성에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a1d5c49aae5cb26d9965efa2b543eb65306a01" translate="yes" xml:space="preserve">
          <source>If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character.</source>
          <target state="translated">크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면, 크기 표현의 첫 번째 문자는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e2b282ebf7062ed0ca134866fb50f5fe7dd48ced" translate="yes" xml:space="preserve">
          <source>If the main task must later await termination, it may re-register and then execute a similar loop:</source>
          <target state="translated">주 작업이 나중에 종료를 기다려야하는 경우 다시 등록한 후 비슷한 루프를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="531cc08b857c4e56e257070320ab4f3d2accadae" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (에 따른 중복 된 경우 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있을 수있는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="088f14da8d2c154179e131d3ed238aa448ab02fb" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys might have duplicates, use &lt;a href=&quot;#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (에 따른 중복 된 경우 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있을 수있는 경우 대신 &lt;a href=&quot;#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a291cf6a416b3035d499691d19d66c91e9db3e1a" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys might have duplicates, use &lt;a href=&quot;#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toUnmodifiableMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; to handle merging of the values.</source>
          <target state="translated">맵핑 된 키 (에 따른 중복 된 경우 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있을 수있는 경우 &lt;a href=&quot;#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toUnmodifiableMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 을 사용하여 값 병합을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b1373a2f67fea002749155a531d7ee46df51febf" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">매핑 된 키에 중복 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 포함 된 경우 ( Object.equals (Object) 에 따라 ) ) 값 매핑 함수는 각 동일한 요소에 적용되고 결과는 제공된 병합 함수를 사용하여 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ebb09d651c50d7a498fdb18d45eddf7b8ceeeb" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">매핑 된 키에 중복 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 포함 된 경우 ( Object.equals (Object) 에 따라 ) 값 매핑 함수는 각 동일한 요소에 적용되고 결과는 제공된 병합 함수를 사용하여 병합됩니다. &lt;code&gt;ConcurrentMap&lt;/code&gt; 제공된 공급 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="2e75e6f9c272bcc58cd0a4bb014e176c452d721a" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">매핑 된 키에 중복 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 포함 된 경우 ( Object.equals (Object) 에 따라 ) 값 매핑 함수는 각 동일한 요소에 적용되고 결과는 제공된 병합 함수를 사용하여 병합됩니다. &lt;code&gt;Map&lt;/code&gt; 제공된 공급 업체의 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="91601953e386bbcbf0a6b2f49eca2d05544c99f8" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (따른 중복 포함 된 경우 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키가 중복 된 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="42bc70fbf81ca2e8ef91fd72811c9886f9c29e43" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (따른 중복 포함 된 경우 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있는 경우 대신 &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ebd1a935a059b20128bc5042763d4c45de22fb0b" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab1f12a020b33fa5cdaa6c8e92a327756ecc141" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다. &lt;code&gt;ConcurrentMap&lt;/code&gt; 제공된 공급 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="5d55abd598d0098b46d878c1a82407a1edf09085" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다. &lt;code&gt;Map&lt;/code&gt; 제공된 공급 업체의 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="6776bff4be9d5889c77b053d4d78e203a02dda2b" translate="yes" xml:space="preserve">
          <source>If the mapping function returns &lt;code&gt;null&lt;/code&gt;, no mapping is recorded. If the mapping function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">매핑 함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하면 매핑이 기록되지 않습니다. 매핑 함수 자체가 (확인되지 ​​않은) 예외를 throw하면 예외가 다시 throw되고 매핑이 기록되지 않습니다. 가장 일반적인 사용법은 다음과 같이 초기 매핑 된 값 또는 메모 된 결과로 제공되는 새 개체를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb025d3bf5eb9ce361d77c9eec5cc70908428bf7" translate="yes" xml:space="preserve">
          <source>If the mapping function returns a &lt;code&gt;null&lt;/code&gt; result then this method returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">매핑 함수가 &lt;code&gt;null&lt;/code&gt; 결과를 반환하면이 메서드는 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="12d75596707c6333177ca57803e56fd8714ec021" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;#find()&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">일치가 성공하면 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메서드 를 통해 더 많은 정보를 얻을 수 있으며 &lt;a href=&quot;#find()&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 메서드 의 후속 호출은 이 일치와 일치하지 않는 첫 번째 문자에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="38fcc3a9324656c7f62d52adcd0bcdf26f23941f" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;matcher#find--&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">일치가 성공하면 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메소드 를 통해 추가 정보를 얻을 수 있으며 &lt;a href=&quot;matcher#find--&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 메소드 의 후속 호출은 이 일치와 일치하지 않는 첫 번째 문자에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e45d30a935b4cf0dbcaf8698457f96e2ee71e0db" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods.</source>
          <target state="translated">일치하는 경우 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메소드 를 통해 추가 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4646f11996bf69cea5464367c1335e753c401c2e" translate="yes" xml:space="preserve">
          <source>If the match was successful but the group specified failed to match any part of the input sequence, then &lt;code&gt;null&lt;/code&gt; is returned. Note that some groups, for example &lt;code&gt;(a*)&lt;/code&gt;, match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.</source>
          <target state="translated">일치는했지만 지정된 그룹이 입력 순서의 일부와 일치하지 않으면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다. 예를 들어 &lt;code&gt;(a*)&lt;/code&gt; 와 같은 일부 그룹 은 빈 문자열과 일치합니다. 이 메소드는 해당 그룹이 입력의 빈 문자열과 성공적으로 일치하면 빈 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7978619400e787b4fa09d19e22379298e6ddd77a" translate="yes" xml:space="preserve">
          <source>If the matcher is to be used for further matching operations after the terminal stream operation completes then it should be first reset.</source>
          <target state="translated">터미널 스트림 작업이 완료된 후 추가 매칭 작업에 matcher를 사용하려면 먼저 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e27c63987af47673a3557d130f21afb577235397" translate="yes" xml:space="preserve">
          <source>If the maximum number of integer digits is greater than their minimum number and greater than 1, it forces the exponent to be a multiple of the maximum number of integer digits, and the minimum number of integer digits to be interpreted as 1. The most common use of this is to generate &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three, e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345 formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.</source>
          <target state="translated">최대 정수 자릿수가 최소 자릿수보다 크고 1보다 큰 경우 지수는 최대 정수 자릿수의 배수가되고 최소 정수 자릿수가 1로 해석됩니다. 이것의 사용은 &lt;em&gt;공학 표기법&lt;/em&gt; 을 생성 하는 것인데, 지수는 &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt; 과 같이 3의 배수입니다 . 이 패턴을 사용하면 숫자 12345는 &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt; 으로 , 123456은 &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt; 으로 포맷됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc02abf9ff2a8cfb39d93ed0d23fa96b285931bc" translate="yes" xml:space="preserve">
          <source>If the maximum packet size is too small to hold a minimal record, an implementation may attempt to generate as minimal records as possible. However, this may cause a generated packet to be larger than the maximum packet size.</source>
          <target state="translated">최대 패킷 크기가 너무 작아 최소 레코드를 보유 할 수없는 경우 구현시 가능한 한 최소 레코드를 생성하려고 할 수 있습니다. 그러나 이로 인해 생성 된 패킷이 최대 패킷 크기보다 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b7136459975c689cb618446a7775563184c4f97" translate="yes" xml:space="preserve">
          <source>If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">최대 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="86b3b7a5e5f22c1bf8fae091e74834fd7dca174e" translate="yes" xml:space="preserve">
          <source>If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getMaximumSize&lt;/code&gt; method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">최대 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다. UI 델리게이트의 &lt;code&gt;getMaximumSize&lt;/code&gt; 메서드가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값을 반환하면 해당 값을 반환합니다. 그렇지 않으면 구성 요소의 레이아웃 관리자를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a8ec7f18e844715a365255a5c9ce58a9ea8cde37" translate="yes" xml:space="preserve">
          <source>If the maximum value is different from the previous maximum, all change listeners are notified.</source>
          <target state="translated">최대 값이 이전 최대 값과 다른 경우 모든 변경 리스너에게 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="838dcf4d5b32bbaaf6507ff34ec3b9a39315ea1c" translate="yes" xml:space="preserve">
          <source>If the mechanism has an initial response, the library invokes &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge and to get initial response. Protocols such as IMAP4, which do not include an initial response with their first authentication command to the server, initiates the authentication without first calling &lt;code&gt;hasInitialResponse()&lt;/code&gt; or &lt;code&gt;evaluateChallenge()&lt;/code&gt;. When the server responds to the command, it sends an initial challenge. For a SASL mechanism in which the client sends data first, the server should have issued a challenge with no data. This will then result in a call (on the client) to &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge.</source>
          <target state="translated">메커니즘에 초기 응답이있는 경우 라이브러리는 비어있는 시도로 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 호출 하고 초기 응답을받습니다. 서버에 대한 첫 번째 인증 명령으로 초기 응답을 포함하지 않는 IMAP4와 같은 프로토콜은 &lt;code&gt;hasInitialResponse()&lt;/code&gt; 또는 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 먼저 호출하지 않고 인증을 시작합니다 . 서버가 명령에 응답하면 초기 챌린지를 보냅니다. 클라이언트가 데이터를 먼저 보내는 SASL 메커니즘의 경우 서버는 데이터없이 챌린지를 발행해야합니다. 그러면 빈 챌린지 로 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 평가 하기 위해 ( 클라이언트에서) 호출이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4583d5e7e45e0fa2e945cb9ac4db80337ed6eff8" translate="yes" xml:space="preserve">
          <source>If the membership key represents a membership to receive all datagrams then the membership is dropped and the channel will no longer receive any datagrams sent to the group. If the membership key is source-specific then the channel will no longer receive datagrams sent to the group from that source address.</source>
          <target state="translated">멤버쉽 키가 모든 데이터 그램을 수신하는 멤버쉽을 나타내는 경우 멤버쉽이 삭제되고 채널은 더 이상 그룹으로 전송 된 데이터 그램을 수신하지 않습니다. 멤버쉽 키가 소스에 특정한 경우 채널은 더 이상 해당 소스 주소에서 그룹으로 전송 된 데이터 그램을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6001952d56f121e245b493dc6d0d725d39114278" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">메타 데이터에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 에 지정된 테이블 이 무시됩니다. 또한 테이블 집합이 작성되면 메타 데이터의 테이블 만 동일한 스트림 또는 다른 스트림에 대한 후속 쓰기를 위해이를 재정의 할 수 있습니다. 이 클래스를 사용하여 새 테이블을 지정 하려면 writer 의 &lt;a href=&quot;../../imagewriter#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="578b6c8818072cd3e8eeb57e000ffbfdfb02eb42" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">메타 데이터에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 에 제공된 테이블 이 무시됩니다. 또한 일단 테이블 세트가 작성된 후에는 동일한 스트림이든 다른 스트림이든간에 메타 데이터의 테이블 만 후속 쓰기를 위해이를 대체 할 수 있습니다. 이 클래스를 사용하여 새 테이블을 지정 하려면 기록기 의 &lt;a href=&quot;../../imagewriter#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad0276650305bd3de8e01175bff74048c2dfe026" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;mark&lt;/code&gt; has not been called since the stream was created, or the number of bytes read from the stream since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument to &lt;code&gt;mark&lt;/code&gt; at that last call, then an &lt;code&gt;IOException&lt;/code&gt; might be thrown.</source>
          <target state="translated">스트림이 작성된 후 메소드 &lt;code&gt;mark&lt;/code&gt; 가 호출되지 않았거나 &lt;code&gt;mark&lt;/code&gt; 가 마지막으로 호출 된 이후 스트림에서 읽은 바이트 수가 해당 마지막 호출에서 &lt;code&gt;mark&lt;/code&gt; 하기위한 인수보다 큰 경우 &lt;code&gt;IOException&lt;/code&gt; 이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd81035982e12d53ca7e2f58a6ad2d674721fd8" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then:</source>
          <target state="translated">&lt;code&gt;markSupported&lt;/code&gt; 메소드 가 &lt;code&gt;false&lt;/code&gt; 를 돌려주는 경우 :</target>
        </trans-unit>
        <trans-unit id="864c00c6cb70175672417e9637771a48ccc4d334" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">이 방법은 경우 &lt;code&gt;markSupported&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 다음 :</target>
        </trans-unit>
        <trans-unit id="257969b0bfbf03841c2811e4e4900ba062f566de" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필터 또는 리스너의 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; 을&lt;/a&gt; throw하는 경우 해당 예외는 다른 리스너가 호출되는 것을 방지하지 않습니다. 그러나 필터, &lt;code&gt;Executor.execute&lt;/code&gt; 또는 &lt;code&gt;handleNotification&lt;/code&gt; ( &lt;code&gt;Excecutor&lt;/code&gt; 가 지정 되지 않은 경우)의 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; 를&lt;/a&gt; 던지면 해당 &lt;code&gt;Error&lt;/code&gt; 가 &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; 호출자에게 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a268179b4de151a916f950d2bb56b82b6124706" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">필터 또는 리스너의 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 을 발생시키는 경우 해당 예외는 다른 리스너가 호출되는 것을 방지하지 않아야합니다. 그러나 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; 를&lt;/a&gt; 던지면 해당 지점에서 알림 처리를 중지하는 것이 좋으며 알림 발신자에게 &lt;code&gt;Error&lt;/code&gt; 를 전파 할 수있는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="eaea82c9a23067ef7f772f7e498b434c683c927b" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필터 또는 리스너의 메소드 호출에서 &lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 이 발생하면 해당 예외로 인해 다른 리스너가 호출되지 않습니다. 또는 필터의 메소드 호출 그러나 &lt;code&gt;Executor.execute&lt;/code&gt; 또는 &lt;code&gt;handleNotification&lt;/code&gt; (어떤 경우 &lt;code&gt;Excecutor&lt;/code&gt; 가 지정되지 않은)이 발생 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; , 그 &lt;code&gt;Error&lt;/code&gt; 호출자에게 전달된다 &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="267719667d5da83b9f20baec6b480b3574e95dc7" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">필터 또는 리스너의 메소드 호출에서 &lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 이 발생하면 해당 예외로 인해 다른 리스너가 호출되지 않아야합니다. 그러나 메소드 호출에서 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생하면 해당 시점에서 알림 처리를 중지하고 &lt;code&gt;Error&lt;/code&gt; 를 알림 발신자 에게 전파 할 수있는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f5c827066a55f3bfdaa44e5351bcaf2001cab9a" translate="yes" xml:space="preserve">
          <source>If the method completes normally, the value it returns is returned to the caller of invoke; if the value has a primitive type, it is first appropriately wrapped in an object. However, if the value has the type of an array of a primitive type, the elements of the array are</source>
          <target state="translated">메소드가 정상적으로 완료되면 리턴하는 값이 호출자에게 리턴됩니다. 값에 프리미티브 유형이있는 경우 먼저 오브젝트에 적절하게 랩핑됩니다. 그러나 값에 기본 유형의 배열 유형이있는 경우 배열의 요소는</target>
        </trans-unit>
        <trans-unit id="b17c4dd6d3aeaac2e8381aefcb1bb96824a4c8a8" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;../../../../java.base/java/lang/reflect/invocationhandler#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;
   CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;
   CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;
   equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">주어진 방법 않으면 &lt;a href=&quot;../../../../java.base/java/lang/reflect/invocationhandler#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 메소드이다 &lt;code&gt;boolean equals(Object)&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 다음과 같은 경우 true를 반환 할 것이다 인수는 경우에만 &lt;code&gt;Proxy&lt;/code&gt; 누구 &lt;code&gt;InvocationHandler&lt;/code&gt; 도이다 &lt;code&gt; CompositeDataInvocationHandler&lt;/code&gt; 및 그 백업 &lt;code&gt; CompositeData&lt;/code&gt; 동일한 (동일한 필요는 없다)된다에 이 개체의. &lt;code&gt;invoke&lt;/code&gt; 에 주어진 메서드 가 &lt;code&gt;Object&lt;/code&gt; 에서 상속 된 &lt;code&gt;int hashCode()&lt;/code&gt; 메서드 인 경우이 &lt;code&gt; equals&lt;/code&gt; 정의와 일치하는 값을 반환합니다 . 두 개체가 같음에 따라 &lt;code&gt;equals&lt;/code&gt; , 그러면 동일한 &lt;code&gt;hashCode&lt;/code&gt; 를 갖게됩니다 .</target>
        </trans-unit>
        <trans-unit id="16a48723a8d9e2801b89e415c711042c7335165b" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">주어진 방법 않으면 &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 메소드이다 &lt;code&gt;boolean equals(Object)&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 다음과 같은 경우 true를 반환 할 것이다 인수는 경우에만 &lt;code&gt;Proxy&lt;/code&gt; 누구 &lt;code&gt;InvocationHandler&lt;/code&gt; 도이다 &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; 및 그 백업 &lt;code&gt;CompositeData&lt;/code&gt; 동일한 (동일한 필요는 없다)된다에 이 객체. 주어진 경우에있어서 &lt;code&gt;invoke&lt;/code&gt; 메소드이다 &lt;code&gt;int hashCode()&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 그것은의 정의와 일치하는 값을 반환 &lt;code&gt;equals&lt;/code&gt; 두 개체에있어서 동일한 경우 &lt;code&gt;equals&lt;/code&gt; 그러면 동일한 &lt;code&gt;hashCode&lt;/code&gt; 를 갖게됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c8dd855a596d9b3681ae2a62cc0d2f6c52ee22d" translate="yes" xml:space="preserve">
          <source>If the method shows the window then the window is also made focused under the following conditions:</source>
          <target state="translated">메소드가 창을 표시하면 다음 조건에서도 창에 초점이 맞춰집니다.</target>
        </trans-unit>
        <trans-unit id="2b6f07a7fdaf466e246e416a6d8be9d141006087" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions.</source>
          <target state="translated">메소드가 확인되지 않은 예외를 발생시키는 경우 EJB가 예외를 처리 할 수있는 EJB의 경우를 제외하고는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7f5b04deb2b9061789f4f81f1da0be43e66b30" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them.</source>
          <target state="translated">메소드가 검사되지 않은 예외를 발생시키는 경우 EJB가 예외를 처리하고 예외로부터 복구 할 수있는 EJB의 경우를 제외하고는 클래스를 서비스에 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="71fad1ecc8a08eac94d160de9bd1bcb1628402e9" translate="yes" xml:space="preserve">
          <source>If the methods that return configuration information about the annotation processor return &lt;code&gt;null&lt;/code&gt;, return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.</source>
          <target state="translated">어노테이션 프로세서에 대한 구성 정보를 리턴하는 메소드가 &lt;code&gt;null&lt;/code&gt; 을 리턴하거나 다른 유효하지 않은 입력을 리턴하거나 예외를 발생시키는 경우 도구 인프라는이를 오류 조건으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d9250ed3bc9c6d4ff0b925cf3b480e2220dbd67" translate="yes" xml:space="preserve">
          <source>If the mimeType is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">mimeType이 &quot;application / x-java-serialized-object; class = &amp;lt;representation class&amp;gt;&quot;인 경우 결과는 &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="645cb7d243c1be249a152ed3e295457a416dfa10" translate="yes" xml:space="preserve">
          <source>If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">최소 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8876db76229cee3d170e10fbb666ffa91c4f625e" translate="yes" xml:space="preserve">
          <source>If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getMinimumSize&lt;/code&gt; method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">최소 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다. UI 델리게이트의 &lt;code&gt;getMinimumSize&lt;/code&gt; 메서드가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값을 반환하면 해당 값을 반환합니다. 그렇지 않으면 구성 요소의 레이아웃 관리자를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="34725787b80a4ac3e39668b42bbcaa23889b0833" translate="yes" xml:space="preserve">
          <source>If the minimum value is different from the previous minimum, all change listeners are notified.</source>
          <target state="translated">최소값이 이전 최소값과 다른 경우 모든 변경 리스너에게 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="691404a8b3e5b3eda8e1acec57c701c9733bf667" translate="yes" xml:space="preserve">
          <source>If the model isn't empty, the width is the preferred size's width, typically the width of the widest list element. The height is the height of the cell with index 0 multiplied by the &lt;code&gt;visibleRowCount&lt;/code&gt;, plus the list's vertical insets.</source>
          <target state="translated">모델이 비어 있지 않은 경우 너비는 기본 크기의 너비이며 일반적으로 가장 넓은 목록 요소의 너비입니다. 높이는 index 0에 &lt;code&gt;visibleRowCount&lt;/code&gt; 를 곱한 셀의 높이와 목록의 수직 인세 트입니다.</target>
        </trans-unit>
        <trans-unit id="0b88a0b55b2b80ffaa036b69fe4a0d5c5dc0f38c" translate="yes" xml:space="preserve">
          <source>If the module name consists of one identifier, then this method returns that identifier, which is deemed to be module's fully qualified name despite not being in qualified form. If the module name consists of more than one identifier, then this method returns the entire name.</source>
          <target state="translated">모듈 이름이 하나의 식별자로 구성된 경우이 메서드는 해당 식별자를 반환합니다.이 식별자는 정규화 된 형식이 아니더라도 모듈의 정규화 된 이름으로 간주됩니다. 모듈 이름이 둘 이상의 식별자로 구성된 경우이 메서드는 전체 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7fafdcfebc35bea4dd094bd5605e29e57f9bd44" translate="yes" xml:space="preserve">
          <source>If the module name consists of one identifier, then this method returns that identifier. If the module name consists of more than one identifier, then this method returns the rightmost such identifier, which is deemed to be the module's simple name.</source>
          <target state="translated">모듈 이름이 하나의 식별자로 구성된 경우이 메서드는 해당 식별자를 반환합니다. 모듈 이름이 둘 이상의 식별자로 구성되어 있으면이 메서드는 모듈의 단순 이름으로 간주되는 가장 오른쪽에있는 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d5473331af759f2d8229027168bed280516c881" translate="yes" xml:space="preserve">
          <source>If the module reader can determine that the name locates a directory then the resulting URI will end with a slash ('/').</source>
          <target state="translated">모듈 판독기가 이름이 디렉토리를 찾는 것을 확인할 수있는 경우 결과 URI는 슬래시 ( '/')로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="504335c7ed6dbcdfc8abf3c7edbaa85154a6e4d7" translate="yes" xml:space="preserve">
          <source>If the mouse is pressed above the &quot;thumb&quot; component then reduce the scrollbars value by one page (&quot;page up&quot;), otherwise increase it by one page.</source>
          <target state="translated">&quot;thumb&quot;구성 요소 위에서 마우스를 누르면 스크롤 막대 값을 한 페이지 줄이고 ( &quot;page up&quot;) 그렇지 않으면 한 페이지 늘립니다.</target>
        </trans-unit>
        <trans-unit id="ba4fc2c0db235b256084eb10160b50a98ca67f0a" translate="yes" xml:space="preserve">
          <source>If the mouse is pressed above the &quot;thumb&quot; component then reduce the scrollbars value by one page (&quot;page up&quot;), otherwise increase it by one page. If there is no thumb then page up if the mouse is in the upper half of the track.</source>
          <target state="translated">&quot;thumb&quot;구성 요소 위에서 마우스를 누르면 스크롤 막대 값을 한 페이지 줄이고 ( &quot;page up&quot;) 그렇지 않으면 한 페이지 늘립니다. 엄지가 없으면 마우스가 트랙의 위쪽 절반에 있으면 페이지 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d66f64c9f7d27c9865a5a830293bbaacc7ca8be1" translate="yes" xml:space="preserve">
          <source>If the name matches the regular expression &lt;code&gt;
         &quot;-(\\d+(\\.|$))&quot;&lt;/code&gt; then the module name will be derived from the subsequence preceding the hyphen of the first occurrence. The subsequence after the hyphen is parsed as a &lt;a href=&quot;moduledescriptor.version&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; and ignored if it cannot be parsed as a &lt;code&gt;Version&lt;/code&gt;.</source>
          <target state="translated">If the name matches the regular expression &lt;code&gt; &quot;-(\\d+(\\.|$))&quot;&lt;/code&gt; then the module name will be derived from the subsequence preceding the hyphen of the first occurrence. The subsequence after the hyphen is parsed as a &lt;a href=&quot;moduledescriptor.version&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; and ignored if it cannot be parsed as a &lt;code&gt;Version&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c345ae50909ad753edc18ff3d914c0995558637" translate="yes" xml:space="preserve">
          <source>If the named Logger already exists and does not yet have a localization resource bundle then the given resource bundle name is used. If the named Logger already exists and has a different resource bundle name then an IllegalArgumentException is thrown.</source>
          <target state="translated">이름 지정된 로거가 이미 존재하고 아직 현지화 자원 번들이없는 경우 제공된 자원 번들 이름이 사용됩니다. 이름이 지정된 Logger가 이미 존재하고 다른 자원 번들 이름이 있으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68506597c2f99be04b0f47ace8cfa88608b7a8be" translate="yes" xml:space="preserve">
          <source>If the named class is not a top-level class, this invocation will have no effect on the actual assertion status of any class.</source>
          <target state="translated">명명 된 클래스가 최상위 클래스가 아닌 경우이 호출은 클래스의 실제 어설 션 상태에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482df42008c5e582c9e2d80de4a8c2c7a964f035" translate="yes" xml:space="preserve">
          <source>If the named file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">명명 된 파일이 존재하지 않거나 일반 파일이 아닌 디렉토리이거나 다른 이유로 읽을 수없는 경우 &lt;code&gt;FileNotFoundException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95905c4bd2793861fb30aaa68b18d361d2c40205" translate="yes" xml:space="preserve">
          <source>If the named object is not a DirContext, search only the object. If the named object is a DirContext, search the subtree rooted at the named object, including the named object itself.</source>
          <target state="translated">명명 된 개체가 DirContext가 아닌 경우 개체 만 검색하십시오. 명명 된 객체가 DirContext 인 경우, 명명 된 객체 자체를 포함하여 명명 된 객체를 기반으로하는 하위 트리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="c355566b5306844a932460e0a37f46753cb3dc74" translate="yes" xml:space="preserve">
          <source>If the namespace-prefixes feature (see above) is &lt;var&gt;false&lt;/var&gt;, access by qualified name may not be available; if the &lt;code&gt;http://xml.org/sax/features/namespaces&lt;/code&gt; feature is &lt;var&gt;false&lt;/var&gt;, access by Namespace-qualified names may not be available.</source>
          <target state="translated">If the namespace-prefixes feature (see above) is &lt;var&gt;false&lt;/var&gt; , access by qualified name may not be available; if the &lt;code&gt;http://xml.org/sax/features/namespaces&lt;/code&gt; feature is &lt;var&gt;false&lt;/var&gt; , access by Namespace-qualified names may not be available.</target>
        </trans-unit>
        <trans-unit id="a797ab321ba29b078906111b6a9d36444e539b67" translate="yes" xml:space="preserve">
          <source>If the nano-of-second is zero or not available then the format is complete.</source>
          <target state="translated">나노초가 0이거나 사용할 수없는 경우 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="5582ab669009a8a27be652376823390e57a44c93" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;Node&lt;/code&gt; replaces an existing node the replaced &lt;code&gt;Node&lt;/code&gt; is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">If the new &lt;code&gt;Node&lt;/code&gt; replaces an existing node the replaced &lt;code&gt;Node&lt;/code&gt; is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</target>
        </trans-unit>
        <trans-unit id="2bc796f960d0884f7fa3798155b8968a45c48d83" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;TransferHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method removes the drop target.</source>
          <target state="translated">If the new &lt;code&gt;TransferHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; , this method removes the drop target.</target>
        </trans-unit>
        <trans-unit id="1dda90377648f98704c19dc7bb65377bbe60c5ed" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;TransferHandler&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, this method also installs a &lt;b&gt;new&lt;/b&gt;&lt;code&gt;DropTarget&lt;/code&gt; on the component to activate drop handling through the &lt;code&gt;TransferHandler&lt;/code&gt; and activate any built-in support (such as calculating and displaying potential drop locations). If you do not wish for this component to respond in any way to drops, you can disable drop support entirely either by removing the drop target (&lt;code&gt;setDropTarget(null)&lt;/code&gt;) or by de-activating it (&lt;code&gt;getDropTaget().setActive(false)&lt;/code&gt;).</source>
          <target state="translated">If the new &lt;code&gt;TransferHandler&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; , this method also installs a &lt;b&gt;new&lt;/b&gt; &lt;code&gt;DropTarget&lt;/code&gt; on the component to activate drop handling through the &lt;code&gt;TransferHandler&lt;/code&gt; and activate any built-in support (such as calculating and displaying potential drop locations). If you do not wish for this component to respond in any way to drops, you can disable drop support entirely either by removing the drop target ( &lt;code&gt;setDropTarget(null)&lt;/code&gt; ) or by de-activating it ( &lt;code&gt;getDropTaget().setActive(false)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0388ea5e05300452be6a29d74452f310aa91ce94" translate="yes" xml:space="preserve">
          <source>If the new extent value is different from the previous extent value, all change listeners are notified.</source>
          <target state="translated">If the new extent value is different from the previous extent value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="18bffcd626a18ef77083ada33a312e98a304ff4c" translate="yes" xml:space="preserve">
          <source>If the new level is null, it means that this node should inherit its level from its nearest ancestor with a specific (non-null) level value.</source>
          <target state="translated">새 레벨이 널인 경우,이 노드는 특정 (널이 아닌) 레벨 값으로 가장 가까운 조상으로부터 레벨을 상속해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e9cd03b46165de5658cfad6de7730a3839030abf" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one then &lt;code&gt;UNCONDITIONAL&lt;/code&gt; is lost.</source>
          <target state="translated">If the new lookup class differs from the old one then &lt;code&gt;UNCONDITIONAL&lt;/code&gt; is lost.</target>
        </trans-unit>
        <trans-unit id="bc536a2662e091e215ec8f641a7473d3709fe706" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">새 조회 클래스가 이전 클래스와 다르면 상속을 통해 보호 된 멤버에 액세스 할 수 없습니다. (패키지 공유로 인해 보호 된 구성원이 계속 액세스 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="60f2db2d23a3b70ce0836cac49cb47c5b9f6353f" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible.</source>
          <target state="translated">새 조회 클래스가 이전 조회 클래스와 다른 패키지에 있으면 보호 및 기본 (패키지) 멤버에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca96aa918a0139c5241a9be60ea7a47fde358969" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not accessible to the old lookup class, then no members, not even public members, will be accessible. (In all other cases, public members will continue to be accessible.)</source>
          <target state="translated">이전 조회 클래스에서 새 조회 클래스에 액세스 할 수 없으면 공개 멤버가 아닌 멤버는 액세스 할 수 없습니다. (다른 모든 경우에도 공개 멤버는 계속 액세스 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="46f23def278f0153e203621371a62fdba4471bd7" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</target>
        </trans-unit>
        <trans-unit id="1a7e98a2066ab4c0cf93405953a8d0cbcca7cb64" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible.</source>
          <target state="translated">새 조회 클래스가 이전 클래스와 동일한 패키지 멤버 내에 있지 않으면 개인 멤버는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cacfac52fe886f7cd2e9a3abcbc070941615f373" translate="yes" xml:space="preserve">
          <source>If the new maximum value is different from the previous maximum value, all change listeners are notified.</source>
          <target state="translated">If the new maximum value is different from the previous maximum value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="86bb426f7dca2fb9a6984cb3ba264576f8178a89" translate="yes" xml:space="preserve">
          <source>If the new minimum value is different from the previous minimum value, all change listeners are notified.</source>
          <target state="translated">If the new minimum value is different from the previous minimum value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="5c61d4985d9e12a6258d359254a6ef98f882749e" translate="yes" xml:space="preserve">
          <source>If the new value is different from the previous value, all change listeners are notified.</source>
          <target state="translated">If the new value is different from the previous value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="dd3bd21f414045efb5b6e0572af661119b6ef82c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; constructor.</target>
        </trans-unit>
        <trans-unit id="070950b6983687a52f5c8a4982aa2eebcfd77d61" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 모든 그룹 구분 기호를 제거하고 ASCII가 아닌 숫자를 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 ASCII 숫자로 매핑 하고 결과 문자열을 &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 전달하는 것처럼 토큰이 &lt;code&gt;BigDecimal&lt;/code&gt; 값으로 변환됩니다. (문자열) 생성자.</target>
        </trans-unit>
        <trans-unit id="efd903809d871bfd2261f9bb7c6f8847849f99dc" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt; as appropriate.</target>
        </trans-unit>
        <trans-unit id="e2b55b595ce54b4c7a0ff65ce30ecb0da6b4383c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII가 아닌 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;double&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 추가하고 결과 문자열을 &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; 로&lt;/a&gt; 전달하십시오 . 토큰이 지역화 된 NaN 또는 무한대 문자열과 일치하면 &quot;Nan&quot;또는 &quot;Infinity&quot;가 &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt; 에 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="3eb97346bea3b5a1c66d1ff73d9a7571c94316bf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt; as appropriate.</target>
        </trans-unit>
        <trans-unit id="6a79c16b442949a70d19c9e0f0f3c3e6d85edf9f" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;float&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에두고 결과 문자열을 &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; 로&lt;/a&gt; 전달합니다 . 토큰이 지역화 된 NaN 또는 무한대 문자열과 일치하면 &quot;Nan&quot;또는 &quot;Infinity&quot;가 &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt; 에 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d2ff6a2387c543b478a622ed06f1bb7df0d7421" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt; constructor with the specified radix.</target>
        </trans-unit>
        <trans-unit id="1a4727cf6304247402307e6eaca3eff6d0258644" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 모든 그룹 구분 기호를 제거하고 ASCII가 아닌 숫자를 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 ASCII 숫자로 맵핑 하고 결과 문자열을 &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt; 전달하는 것처럼 토큰이 &lt;code&gt;BigInteger&lt;/code&gt; 값으로 변환됩니다. 기수가 지정된 (String, int) 생성자</target>
        </trans-unit>
        <trans-unit id="fac93df718c735e73535bc4d3d4b9324ef4c5caf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte(java.lang.String,int)&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte(java.lang.String,int)&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="12b289473a0cfbe9016bed30eea7221cdd374181" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII가 아닌 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;byte&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="3589f798ea949bb8459c5766611ecd61d78cc6ed" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong(java.lang.String,int)&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong(java.lang.String,int)&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="b349deb1d290eaa1752d8feff84d8af8caefc093" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;long&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="b68e5822216b2d7fa77ca18249aad6224e4ec92a" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort(java.lang.String,int)&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort(java.lang.String,int)&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="cde2372e3435e6554a5b5741f761096f7eea5fcf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;short&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부와 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="d5aa82aacf2b2fd955865f9e55427bb7ea1a38f3" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="e2e6b9af16a7a0f10ca898c5788d2527ee4c8561" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;int&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="50647ef6cfa173ffb331678172077c93b906dc08" translate="yes" xml:space="preserve">
          <source>If the number is followed by a colon, it is regarded as an hour, unless an hour has already been recognized, in which case it is regarded as a minute.</source>
          <target state="translated">숫자 뒤에 콜론이 오는 경우, 시간이 이미 인식되지 않은 경우 1 시간으로 간주되며,이 경우 1 분으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2185b02dab1b8be5d039095147b6a86e141a45f4" translate="yes" xml:space="preserve">
          <source>If the number is followed by a slash, it is regarded as a month (it is decreased by 1 to produce a number in the range &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;11&lt;/code&gt;), unless a month has already been recognized, in which case it is regarded as a day of the month.</source>
          <target state="translated">숫자 뒤에 슬래시가 있으면 , 한 달이 이미 인식되지 않은 한, 한 달로 간주됩니다 ( &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;11&lt;/code&gt; 사이 의 숫자를 생성하기 위해 1 씩 감소됨 ). 이달의.</target>
        </trans-unit>
        <trans-unit id="24c204655d0c4e49fdb27ee92ac3fcb02b0bfac3" translate="yes" xml:space="preserve">
          <source>If the number is followed by whitespace, a comma, a hyphen, or end of string, then if an hour has been recognized but not a minute, it is regarded as a minute; otherwise, if a minute has been recognized but not a second, it is regarded as a second; otherwise, it is regarded as a day of the month.</source>
          <target state="translated">숫자 다음에 공백, 쉼표, 하이픈 또는 문자열 끝이 오는 경우 시간이 인식되었지만 1 분이 아닌 경우 1 분으로 간주됩니다. 그렇지 않으면 1 분이 인식되었지만 1 초가 인식되지 않으면 1 초로 간주됩니다. 그렇지 않으면 월의 일로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6291ad948edcd3847ce9e2ff7d5cea133a2c5935" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;.</source>
          <target state="translated">If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28b1d7370c2a1b58a891d34fad7ee082b38756d3" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;. Otherwise, this method uses the superclass's definition which returns true if the classes of the two instances are equal.</source>
          <target state="translated">지정된 생성자의 인수 수가 0이 &lt;code&gt;oldInstance&lt;/code&gt; 클래스가 명시 적으로 &quot;equals&quot;메소드를 선언하면이 메소드는 &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; 의 값을 리턴합니다 . 그렇지 않은 경우,이 메소드는 슈퍼 클래스 정의를 사용하여 두 인스턴스의 클래스가 동일한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c24fe213e64505f30b52e8476bd73dee9a4a91ca" translate="yes" xml:space="preserve">
          <source>If the number of bands is more than one, the SampleModel will be a SinglePixelPackedSampleModel, with each band having bitsPerBand bits. In either case, the requirements on dataType and bitsPerBand imposed by the corresponding SampleModel must be met.</source>
          <target state="translated">If the number of bands is more than one, the SampleModel will be a SinglePixelPackedSampleModel, with each band having bitsPerBand bits. In either case, the requirements on dataType and bitsPerBand imposed by the corresponding SampleModel must be met.</target>
        </trans-unit>
        <trans-unit id="d4af9d2d4726a8f3ade67f849e06bc1d1ab1564a" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying constructor is 0, the supplied &lt;code&gt;initargs&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">기본 생성자가 요구하는 형식 매개 변수의 수가 0 인 경우 제공된 &lt;code&gt;initargs&lt;/code&gt; 배열의 길이는 0이거나 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a45750d8cf5475f9813ae9cb718f088a466add3" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying method is 0, the supplied &lt;code&gt;args&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">기본이되는 메소드에 필요한 형식 매개 변수의 수가 0 인 경우, 제공된 &lt;code&gt;args&lt;/code&gt; 배열의 길이는 0이거나 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6aa952eaa67d2b3ae4ac72907b831466314c9b3" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;
     SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;#applyPattern(java.lang.String)&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown when constructing a &lt;code&gt; SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;#applyPattern(java.lang.String)&quot;&gt;applying a pattern&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="aecea4a5924a64f71d7845e41d1c3b018c067a01" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">패턴 문자 수가 4 개 이상인 경우 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 을 구성 하거나 &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;패턴을 적용&lt;/a&gt; 할 때 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="40ebc6195d83e88d053f6b7f4d083dcca34d15e6" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts.</source>
          <target state="translated">판독기 수가 이제 0이면 쓰기 잠금 시도에 잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57761664428c22b67f54914f3d10f06ea9626ec9" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts. If the current thread does not hold this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">If the number of readers is now zero then the lock is made available for write lock attempts. If the current thread does not hold this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="9539dfa1e1c4ed8a395e2b48d8e6f0bcbf6c71d0" translate="yes" xml:space="preserve">
          <source>If the object does not have a requested attribute, that nonexistent attribute will be ignored. Those requested attributes that the object does have will be returned.</source>
          <target state="translated">객체에 요청 된 속성이 없으면 존재하지 않는 속성은 무시됩니다. 객체가 요청한 속성이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba188f9b3d08b409858ffc14dad0538d6c066ad5" translate="yes" xml:space="preserve">
          <source>If the object does not have an attribute specified, the directory will ignore the nonexistent attribute and return those requested attributes that the object does have.</source>
          <target state="translated">객체에 속성이 지정되어 있지 않으면 디렉토리는 존재하지 않는 속성을 무시하고 해당 객체에 요청 된 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d2b3a1e7cd5b23b39d1f5133dc5c01a091b5bb9" translate="yes" xml:space="preserve">
          <source>If the object does not have the attribute specified, the directory will ignore the nonexistent attribute and return the requested attributes that the object does have.</source>
          <target state="translated">오브젝트에 속성이 지정되지 않은 경우 디렉토리는 존재하지 않는 속성을 무시하고 오브젝트에있는 요청 된 속성을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f7640b018347f47539ec443ff012615b370426e4" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;PropertyChangeListener&lt;/code&gt; and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">객체에 &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; 메소드 가있는 경우 리턴 된 배열은 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 및 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 객체 의 혼합 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3efaaa6db916f5e8dd0c50701e6e2af84aea78e5" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;VetoableChangeListener&lt;/code&gt; and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">객체에 &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; 메소드 가있는 경우 반환 된 배열은 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 및 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 객체 의 혼합 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0000bd104b2da8f8fad009e5ad16ebe1912acd0" translate="yes" xml:space="preserve">
          <source>If the object has a custom mapping (is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;), the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it to the SQL data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">If the object has a custom mapping (is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt; ), the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it to the SQL data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt; , &lt;code&gt;Blob&lt;/code&gt; , &lt;code&gt;Clob&lt;/code&gt; , &lt;code&gt;NClob&lt;/code&gt; , &lt;code&gt;Struct&lt;/code&gt; , &lt;code&gt;java.net.URL&lt;/code&gt; , or &lt;code&gt;Array&lt;/code&gt; , the driver should pass it to the database as a value of the corresponding SQL type.</target>
        </trans-unit>
        <trans-unit id="c633f6da7ab2fee69bd882fac3b3abc472fa5a8a" translate="yes" xml:space="preserve">
          <source>If the object is a &lt;code&gt;DirContext&lt;/code&gt;, any existing attributes associated with the name are replaced with those of the object. Otherwise, any existing attributes associated with the name remain unchanged.</source>
          <target state="translated">객체가 &lt;code&gt;DirContext&lt;/code&gt; 인 경우, 이름과 연관된 기존 속성 이 객체 의 속성으로 대체됩니다. 그렇지 않으면 이름과 연관된 기존 속성은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80b22f0afff8183f235d7fd8ee96b05798cb0cf3" translate="yes" xml:space="preserve">
          <source>If the object is of a class implementing &lt;code&gt;SQLData&lt;/code&gt;, the rowset should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to an &lt;code&gt;SQLOutput&lt;/code&gt; data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">If the object is of a class implementing &lt;code&gt;SQLData&lt;/code&gt; , the rowset should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to an &lt;code&gt;SQLOutput&lt;/code&gt; data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt; , &lt;code&gt;Blob&lt;/code&gt; , &lt;code&gt;Clob&lt;/code&gt; , &lt;code&gt;NClob&lt;/code&gt; , &lt;code&gt;Struct&lt;/code&gt; , &lt;code&gt;java.net.URL&lt;/code&gt; , or &lt;code&gt;Array&lt;/code&gt; , the driver should pass it to the database as a value of the corresponding SQL type.</target>
        </trans-unit>
        <trans-unit id="4f5b3142d8650d58dfbe46a9e556320ac2bd2e7d" translate="yes" xml:space="preserve">
          <source>If the offset is not available then the format is complete.</source>
          <target state="translated">오프셋을 사용할 수 없으면 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="2519e323e000b11bce96906bcfd196efd2dc89f9" translate="yes" xml:space="preserve">
          <source>If the offset is not available to format or parse then the format is complete.</source>
          <target state="translated">오프셋을 포맷하거나 파싱 할 수없는 경우 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="83f30839a17edd7cfbb33b3121aaa65bc609378b" translate="yes" xml:space="preserve">
          <source>If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call &lt;a href=&quot;#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; to empty the current configuration, before calling &lt;code&gt;updateConfiguration&lt;/code&gt;.</source>
          <target state="translated">If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call &lt;a href=&quot;#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; to empty the current configuration, before calling &lt;code&gt;updateConfiguration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ff0a2d4c9016d9ad590b91ba476d4fd341c512" translate="yes" xml:space="preserve">
          <source>If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed.</source>
          <target state="translated">If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed.</target>
        </trans-unit>
        <trans-unit id="6272ea50e04f5a7acc04b3b46505bc6dc3d28d4e" translate="yes" xml:space="preserve">
          <source>If the old lookup class is in a &lt;a href=&quot;../module#isNamed()&quot;&gt;&lt;code&gt;named&lt;/code&gt;&lt;/a&gt; module, and the new lookup class is in a different module &lt;code&gt;M&lt;/code&gt;, then no members, not even public members in &lt;code&gt;M&lt;/code&gt;'s exported packages, will be accessible. The exception to this is when this lookup is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt;&lt;code&gt;publicLookup&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;PUBLIC&lt;/code&gt; access is not lost.</source>
          <target state="translated">If the old lookup class is in a &lt;a href=&quot;../module#isNamed()&quot;&gt; &lt;code&gt;named&lt;/code&gt; &lt;/a&gt; module, and the new lookup class is in a different module &lt;code&gt;M&lt;/code&gt; , then no members, not even public members in &lt;code&gt;M&lt;/code&gt; 's exported packages, will be accessible. The exception to this is when this lookup is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt; &lt;code&gt;publicLookup&lt;/code&gt; &lt;/a&gt;, in which case &lt;code&gt;PUBLIC&lt;/code&gt; access is not lost.</target>
        </trans-unit>
        <trans-unit id="befd5d850eccad70e74cebb655eecf125efcc787" translate="yes" xml:space="preserve">
          <source>If the old lookup class is in an unnamed module, and the new lookup class is a different module then &lt;a href=&quot;#MODULE&quot;&gt;&lt;code&gt;MODULE&lt;/code&gt;&lt;/a&gt; access is lost.</source>
          <target state="translated">If the old lookup class is in an unnamed module, and the new lookup class is a different module then &lt;a href=&quot;#MODULE&quot;&gt; &lt;code&gt;MODULE&lt;/code&gt; &lt;/a&gt; access is lost.</target>
        </trans-unit>
        <trans-unit id="4c280c860cb9f7effbb5d1573c9db972ff6dade1" translate="yes" xml:space="preserve">
          <source>If the opaque representation of a key (see &lt;a href=&quot;../key&quot;&gt;&lt;code&gt;Key&lt;/code&gt;&lt;/a&gt;) can be transformed (see &lt;a href=&quot;../keyfactory&quot;&gt;&lt;code&gt;KeyFactory&lt;/code&gt;&lt;/a&gt;) into this key specification (or a subclass of it), &lt;code&gt;getFormat&lt;/code&gt; called on the opaque key returns the same value as the &lt;code&gt;getFormat&lt;/code&gt; method of this key specification.</source>
          <target state="translated">키 (볼의 불투명 표현하면 &lt;a href=&quot;../key&quot;&gt; &lt;code&gt;Key&lt;/code&gt; &lt;/a&gt; ) (참조 변형 될 수 &lt;a href=&quot;../keyfactory&quot;&gt; &lt;code&gt;KeyFactory&lt;/code&gt; 에가&lt;/a&gt; 이 키 지정 (또는 서브 클래스)으로) &lt;code&gt;getFormat&lt;/code&gt; 는 AS 동일한 값 불투명 키 복귀 호출 &lt;code&gt;getFormat&lt;/code&gt; 이 키 지정 방법.</target>
        </trans-unit>
        <trans-unit id="26d2d84804d4a76528e348ab91515fb0509d099f" translate="yes" xml:space="preserve">
          <source>If the operating system does not support the creation of processes, an &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">If the operating system does not support the creation of processes, an &lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="7608927d8184c584cd9d11cef0e073e1bb7bf926" translate="yes" xml:space="preserve">
          <source>If the operation is a &lt;code&gt;draw(Shape)&lt;/code&gt; operation, then the &lt;a href=&quot;stroke#createStrokedShape(java.awt.Shape)&quot;&gt;&lt;code&gt;createStrokedShape&lt;/code&gt;&lt;/a&gt; method on the current &lt;a href=&quot;stroke&quot;&gt;&lt;code&gt;Stroke&lt;/code&gt;&lt;/a&gt; attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context is used to construct a new &lt;code&gt;Shape&lt;/code&gt; object that contains the outline of the specified &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">If the operation is a &lt;code&gt;draw(Shape)&lt;/code&gt; operation, then the &lt;a href=&quot;stroke#createStrokedShape(java.awt.Shape)&quot;&gt; &lt;code&gt;createStrokedShape&lt;/code&gt; &lt;/a&gt; method on the current &lt;a href=&quot;stroke&quot;&gt; &lt;code&gt;Stroke&lt;/code&gt; &lt;/a&gt; attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context is used to construct a new &lt;code&gt;Shape&lt;/code&gt; object that contains the outline of the specified &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a6f1065b50c79f203f06252e6050cc498ea0ba" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">원래의 타입과 새로운 타입이 같은 경우는 &lt;code&gt;this&lt;/code&gt; 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="15d571df526b560a24fbbc6f542b12d585fc4182" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns target.</source>
          <target state="translated">원래 형식과 새 형식이 같으면 target을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d132531fc669e517a82a3d82919ac097d06f2259" translate="yes" xml:space="preserve">
          <source>If the other &lt;code&gt;StringJoiner&lt;/code&gt; is using a different delimiter, then elements from the other &lt;code&gt;StringJoiner&lt;/code&gt; are concatenated with that delimiter and the result is appended to this &lt;code&gt;StringJoiner&lt;/code&gt; as a single element.</source>
          <target state="translated">다른 경우 &lt;code&gt;StringJoiner&lt;/code&gt; 가 다른 구분자를 사용하고 다른 쪽의 요소 &lt;code&gt;StringJoiner&lt;/code&gt; 은 그 분리와 연결되며, 그 결과이 추가된다 &lt;code&gt;StringJoiner&lt;/code&gt; 단일 요소로.</target>
        </trans-unit>
        <trans-unit id="613b81a7888d7292adb45fa99af137ae84272f3b" translate="yes" xml:space="preserve">
          <source>If the output is an &lt;code&gt;ImageOutputStream&lt;/code&gt;, the existing contents of the output prior to the current seek position are flushed, and need not be readable or writable. If the format requires that &lt;code&gt;endWriteSequence&lt;/code&gt; be able to rewind to patch up the header information, such as for a sequence of images in a single TIFF file, then the metadata written by this method must remain in a writable portion of the stream. Other formats may flush the stream after this method and after each image.</source>
          <target state="translated">출력이 &lt;code&gt;ImageOutputStream&lt;/code&gt; 인 경우, 현재 탐색 위치 이전의 기존 출력 내용이 플러시되므로 읽을 수 있거나 쓸 수 없습니다. 형식에서 &lt;code&gt;endWriteSequence&lt;/code&gt; 가 단일 TIFF 파일의 이미지 시퀀스와 같이 헤더 정보를 패치하기 위해 되감기를 필요로하는 경우이 방법으로 작성된 메타 데이터는 스트림의 쓰기 가능한 부분에 남아 있어야합니다. 이 방법 이후와 각 이미지 후에 다른 형식으로 스트림을 플러시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08f1019969adaf9147a2917277718270a6117c0e" translate="yes" xml:space="preserve">
          <source>If the overall view is represented by many pieces (which is the best situation if one want to be able to change the view and write the least amount of new code), it would be impractical to have a huge number of &lt;code&gt;DocumentListener&lt;/code&gt;s. If each view listened to the model, only a few would actually be interested in the changes broadcasted at any given time. Since the model has no knowledge of views, it has no way to filter the broadcast of change information. The view hierarchy itself is instead responsible for propagating the change information. At any level in the view hierarchy, that view knows enough about its children to best distribute the change information further. Changes are therefore broadcasted starting from the root of the view hierarchy. The methods for doing this are:</source>
          <target state="translated">If the overall view is represented by many pieces (which is the best situation if one want to be able to change the view and write the least amount of new code), it would be impractical to have a huge number of &lt;code&gt;DocumentListener&lt;/code&gt; s. If each view listened to the model, only a few would actually be interested in the changes broadcasted at any given time. Since the model has no knowledge of views, it has no way to filter the broadcast of change information. The view hierarchy itself is instead responsible for propagating the change information. At any level in the view hierarchy, that view knows enough about its children to best distribute the change information further. Changes are therefore broadcasted starting from the root of the view hierarchy. The methods for doing this are:</target>
        </trans-unit>
        <trans-unit id="78a74da7cebb7ba0feae1474dc321fbaaddcde66" translate="yes" xml:space="preserve">
          <source>If the owner document of the &lt;code&gt;DOMStructure&lt;/code&gt; is different than the target document of an &lt;code&gt;XMLSignature&lt;/code&gt;, the &lt;a href=&quot;../dsig/xmlsignature#sign(javax.xml.crypto.dsig.XMLSignContext)&quot;&gt;&lt;code&gt;XMLSignature.sign(XMLSignContext)&lt;/code&gt;&lt;/a&gt; method imports the node into the target document before generating the signature.</source>
          <target state="translated">If the owner document of the &lt;code&gt;DOMStructure&lt;/code&gt; is different than the target document of an &lt;code&gt;XMLSignature&lt;/code&gt; , the &lt;a href=&quot;../dsig/xmlsignature#sign(javax.xml.crypto.dsig.XMLSignContext)&quot;&gt; &lt;code&gt;XMLSignature.sign(XMLSignContext)&lt;/code&gt; &lt;/a&gt; method imports the node into the target document before generating the signature.</target>
        </trans-unit>
        <trans-unit id="fa93ae60cb7452d1a5da6932448d22165c4af9a2" translate="yes" xml:space="preserve">
          <source>If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;EntityReference&lt;/code&gt; nodes are serialized as an entity reference of the form &quot; &lt;code&gt;&amp;amp;entityName;&lt;/code&gt;&quot; in the output. Child nodes (the expansion) of the entity reference are ignored. If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;false&lt;/code&gt;, only the children of the entity reference are serialized. &lt;code&gt;EntityReference&lt;/code&gt; nodes with no children (no corresponding &lt;code&gt;Entity&lt;/code&gt; node or the corresponding &lt;code&gt;Entity&lt;/code&gt; nodes have no children) are always serialized.</source>
          <target state="translated">If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;EntityReference&lt;/code&gt; nodes are serialized as an entity reference of the form &quot; &lt;code&gt;&amp;amp;entityName;&lt;/code&gt; &quot; in the output. Child nodes (the expansion) of the entity reference are ignored. If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;false&lt;/code&gt; , only the children of the entity reference are serialized. &lt;code&gt;EntityReference&lt;/code&gt; nodes with no children (no corresponding &lt;code&gt;Entity&lt;/code&gt; node or the corresponding &lt;code&gt;Entity&lt;/code&gt; nodes have no children) are always serialized.</target>
        </trans-unit>
        <trans-unit id="bb3ac957b69da27cb19dfba9a08e05602d603ed4" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method declares the specified attribute to be a user-determined ID attribute .</source>
          <target state="translated">If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; , this method declares the specified attribute to be a user-determined ID attribute .</target>
        </trans-unit>
        <trans-unit id="41c4967bfb211978283a04544f0d61d21594df4d" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method declares the specified attribute to be a user-determined ID attribute . This affects the value of &lt;code&gt;Attr.isId&lt;/code&gt; and the behavior of &lt;code&gt;Document.getElementById&lt;/code&gt;, but does not change any schema that may be in use, in particular this does not affect the &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt; of the specified &lt;code&gt;Attr&lt;/code&gt; node. Use the value &lt;code&gt;false&lt;/code&gt; for the parameter &lt;code&gt;isId&lt;/code&gt; to undeclare an attribute for being a user-determined ID attribute.</source>
          <target state="translated">If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; , this method declares the specified attribute to be a user-determined ID attribute . This affects the value of &lt;code&gt;Attr.isId&lt;/code&gt; and the behavior of &lt;code&gt;Document.getElementById&lt;/code&gt; , but does not change any schema that may be in use, in particular this does not affect the &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt; of the specified &lt;code&gt;Attr&lt;/code&gt; node. Use the value &lt;code&gt;false&lt;/code&gt; for the parameter &lt;code&gt;isId&lt;/code&gt; to undeclare an attribute for being a user-determined ID attribute.</target>
        </trans-unit>
        <trans-unit id="170b05155c2fff91755b761f2183540c80aa9948" translate="yes" xml:space="preserve">
          <source>If the parameter does not have a user-defined or &lt;code&gt;REF&lt;/code&gt; type, the given &lt;code&gt;typeName&lt;/code&gt; parameter is ignored.</source>
          <target state="translated">If the parameter does not have a user-defined or &lt;code&gt;REF&lt;/code&gt; type, the given &lt;code&gt;typeName&lt;/code&gt; parameter is ignored.</target>
        </trans-unit>
        <trans-unit id="18c245a7f9ecfcc3d829455a0e0abe420832d2a6" translate="yes" xml:space="preserve">
          <source>If the parameter is negative or beyond the length of the document, the caret is placed at the beginning or at the end, respectively.</source>
          <target state="translated">If the parameter is negative or beyond the length of the document, the caret is placed at the beginning or at the end, respectively.</target>
        </trans-unit>
        <trans-unit id="8249c3394f9981a5c6710331cd767e75fd4509a3" translate="yes" xml:space="preserve">
          <source>If the parameters exist in XML form, the &lt;a href=&quot;#init(javax.xml.crypto.XMLStructure,javax.xml.crypto.XMLCryptoContext)&quot;&gt;&lt;code&gt;init(XMLStructure, XMLCryptoContext)&lt;/code&gt;&lt;/a&gt; method should be used to initialize the &lt;code&gt;TransformService&lt;/code&gt;.</source>
          <target state="translated">If the parameters exist in XML form, the &lt;a href=&quot;#init(javax.xml.crypto.XMLStructure,javax.xml.crypto.XMLCryptoContext)&quot;&gt; &lt;code&gt;init(XMLStructure, XMLCryptoContext)&lt;/code&gt; &lt;/a&gt; method should be used to initialize the &lt;code&gt;TransformService&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a23d99be271523bb82052d907e3db3f2dbe428c3" translate="yes" xml:space="preserve">
          <source>If the parent is specified as &lt;code&gt;null&lt;/code&gt; (for the bootstrap class loader) then there is no guarantee that all platform classes are visible.</source>
          <target state="translated">If the parent is specified as &lt;code&gt;null&lt;/code&gt; (for the bootstrap class loader) then there is no guarantee that all platform classes are visible.</target>
        </trans-unit>
        <trans-unit id="a54204b2e99d7d060bb6235389e37beb7f049e32" translate="yes" xml:space="preserve">
          <source>If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.</source>
          <target state="translated">텍스트의 전체 길이를 읽지 않고 구문 분석이 완료되거나 구문 분석 또는 병합 중에 문제가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="966672a90f95f435f932b758ca1be0521185c7b2" translate="yes" xml:space="preserve">
          <source>If the parsed set of schemas includes error(s) as specified in the section 5.1 of the XML Schema spec, then the error must be reported to the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the parsed set of schemas includes error(s) as specified in the section 5.1 of the XML Schema spec, then the error must be reported to the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1ec9adbbdbd63160216787347e59341d3fd1989d" translate="yes" xml:space="preserve">
          <source>If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommendation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</source>
          <target state="translated">If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommendation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</target>
        </trans-unit>
        <trans-unit id="951efcf89e37dc37c87ce691e02e23742bc9d33e" translate="yes" xml:space="preserve">
          <source>If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommentation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</source>
          <target state="translated">If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommentation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</target>
        </trans-unit>
        <trans-unit id="ee0a795fb5ae860545c1f74e1564f3e8fc66414d" translate="yes" xml:space="preserve">
          <source>If the parser or application needs to include information about a specific location in an XML document, it should use the &lt;a href=&quot;saxparseexception&quot;&gt;&lt;code&gt;SAXParseException&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">If the parser or application needs to include information about a specific location in an XML document, it should use the &lt;a href=&quot;saxparseexception&quot;&gt; &lt;code&gt;SAXParseException&lt;/code&gt; &lt;/a&gt; subclass.</target>
        </trans-unit>
        <trans-unit id="27392b4b5ae25c2878c249c3152c3d3160b5375b" translate="yes" xml:space="preserve">
          <source>If the partialReturn property on the txt parameter is false, the data returned in the Segment will be the entire length requested and may or may not be a copy depending upon how the data was stored. If the partialReturn property is true, only the amount of text that can be returned without creating a copy is returned. Using partial returns will give better performance for situations where large parts of the document are being scanned. The following is an example of using the partial return to access the entire document:</source>
          <target state="translated">If the partialReturn property on the txt parameter is false, the data returned in the Segment will be the entire length requested and may or may not be a copy depending upon how the data was stored. If the partialReturn property is true, only the amount of text that can be returned without creating a copy is returned. Using partial returns will give better performance for situations where large parts of the document are being scanned. The following is an example of using the partial return to access the entire document:</target>
        </trans-unit>
        <trans-unit id="5ed75a33bb4145623122f20c780e9bac95e43865" translate="yes" xml:space="preserve">
          <source>If the path is relative, and if its first segment contains a colon character (&lt;code&gt;':'&lt;/code&gt;), then a &lt;code&gt;&quot;.&quot;&lt;/code&gt; segment is prepended. This prevents a relative URI with a path such as &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; from later being re-parsed as an opaque URI with a scheme of &lt;code&gt;&quot;a&quot;&lt;/code&gt; and a scheme-specific part of &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt;. &lt;b&gt;&lt;i&gt;(Deviation from RFC 2396)&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">경로가 상대 경로이고 첫 번째 세그먼트에 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; ) 가 포함 된 경우 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 세그먼트가 앞에 붙습니다. 이렇게하면 &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; 와 같은 경로가있는 상대 URI가 나중에 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 체계와 &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt; 체계가있는 불투명 URI로 다시 구문 분석되지 않습니다. . &lt;b&gt;&lt;i&gt;(RFC 2396에서 벗어남)&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd2e4303923c73137d6318c7fb1a6ecc2cd9b62d" translate="yes" xml:space="preserve">
          <source>If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the module name; if the module name matches the module name of the class then the remaining pattern is matched with the class name. If there is no &quot;/&quot;, the module name is not compared.</source>
          <target state="translated">If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the module name; if the module name matches the module name of the class then the remaining pattern is matched with the class name. If there is no &quot;/&quot;, the module name is not compared.</target>
        </trans-unit>
        <trans-unit id="47d65275395c58dc9640d193b6ab38182a27d80c" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a prefix.</source>
          <target state="translated">If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a prefix.</target>
        </trans-unit>
        <trans-unit id="2b99798368562eadf341b3140c731a962ac17514" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;.*&quot; it matches any class in the package.</source>
          <target state="translated">If the pattern ends with &quot;.*&quot; it matches any class in the package.</target>
        </trans-unit>
        <trans-unit id="64908fcc581dd6ae74cbec11495eb53bd054a169" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;.**&quot; it matches any class in the package and all subpackages.</source>
          <target state="translated">If the pattern ends with &quot;.**&quot; it matches any class in the package and all subpackages.</target>
        </trans-unit>
        <trans-unit id="d4631732bf01387295ef2c9727234cf63af52f66" translate="yes" xml:space="preserve">
          <source>If the pattern is equal to the class name, it matches.</source>
          <target state="translated">If the pattern is equal to the class name, it matches.</target>
        </trans-unit>
        <trans-unit id="72a8f0cca7462c028e15e68df7691503088ae3a6" translate="yes" xml:space="preserve">
          <source>If the pattern letter is 'v' the output provides the zone name ignoring daylight savings time. If the count of letters is one, then the short name is output. If the count of letters is four, then the full name is output. Two, three and five or more letters throw &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">If the pattern letter is 'v' the output provides the zone name ignoring daylight savings time. If the count of letters is one, then the short name is output. If the count of letters is four, then the full name is output. Two, three and five or more letters throw &lt;code&gt;IllegalArgumentException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2047fa1b9e42f9c7566436cd904af026a1d6b5e2" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &quot;!&quot;, the class is rejected if the remaining pattern is matched; otherwise the class is allowed if the pattern matches.</source>
          <target state="translated">If the pattern starts with &quot;!&quot;, the class is rejected if the remaining pattern is matched; otherwise the class is allowed if the pattern matches.</target>
        </trans-unit>
        <trans-unit id="87a4c8fb790be59120806baf097d003e2948d992" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, (atomically) decrements it.</source>
          <target state="translated">보류 카운트가 0이 아닌 경우 (원자 적으로) 감소합니다.</target>
        </trans-unit>
        <trans-unit id="8ad7048ac80247a957da8eeed8a41a5f37a54c39" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</source>
          <target state="translated">If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</target>
        </trans-unit>
        <trans-unit id="e572cb5e5dee791d5b39d6f57ac77915682e21a1" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</source>
          <target state="translated">보류 카운트가 0이 아닌 경우 카운트를 감소시킵니다. 그렇지 않으면 &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; 호출 한 다음이 작업의 완료자를 작성하려고 시도합니다 (있는 경우). 그렇지 않으면 이 작업을 완료된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bc17ec5f581dec30fa586e110a04b1eaf5b5b327" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</source>
          <target state="translated">허가가있는 경우 허가가 소비되고 즉시 전화가 반환됩니다. 그렇지 않으면 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다음 4 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d4223a7d1829a5930922236b794117f0ecfa3ef5" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">허가가있는 경우 허가가 소비되고 즉시 전화가 반환됩니다. 그렇지 않으면 현재 스레드는 스레드 예약 목적으로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c7072c32b05b6fd0de10d7da5998d3dbfa5ec38" translate="yes" xml:space="preserve">
          <source>If the permits are acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">허가가 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4cea382e9b6e94d448d8b5b7931ce98c85d158e1" translate="yes" xml:space="preserve">
          <source>If the persist field of the attribute's descriptor is not null then Persistence policy from the attribute descriptor is used to guide storing the attribute in a persistent store.</source>
          <target state="translated">속성 설명 자의 지속 필드가 널이 아닌 경우 속성 설명 자의 지속성 정책이 속성을 영구 저장소에 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4b331cf13e540556f5aca90f86b4e8ad5c60f9" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle image metadata, null should be returned.</source>
          <target state="translated">플러그인이 이미지 메타 데이터를 처리하지 않으면 널이 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="aab4c0c381c1b7fcd5929e45b451378e4a93f9be" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle metadata, null should be returned.</source>
          <target state="translated">플러그인이 메타 데이터를 처리하지 않으면 널이 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06277a1c71d67301bd303d6a030fc9040d866b9c" translate="yes" xml:space="preserve">
          <source>If the point is colinear with the line segment, but not between the end points, then the value will be -1 if the point lies &quot;beyond &lt;code&gt;(x1,y1)&lt;/code&gt;&quot; or 1 if the point lies &quot;beyond &lt;code&gt;(x2,y2)&lt;/code&gt;&quot;.</source>
          <target state="translated">If the point is colinear with the line segment, but not between the end points, then the value will be -1 if the point lies &quot;beyond &lt;code&gt;(x1,y1)&lt;/code&gt; &quot; or 1 if the point lies &quot;beyond &lt;code&gt;(x2,y2)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="566f0e2c0058f212146ef4067827ea84b517258f" translate="yes" xml:space="preserve">
          <source>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;#getKeepAliveTime(java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt;&lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;#setKeepAliveTime(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;setKeepAliveTime(long,
 TimeUnit)&lt;/code&gt;&lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt;&lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;&lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads, but method &lt;a href=&quot;#allowCoreThreadTimeOut(boolean)&quot;&gt;&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;&lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</source>
          <target state="translated">If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;#getKeepAliveTime(java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt; &lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;#setKeepAliveTime(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;setKeepAliveTime(long, TimeUnit)&lt;/code&gt; &lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt; &lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads, but method &lt;a href=&quot;#allowCoreThreadTimeOut(boolean)&quot;&gt; &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; &lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</target>
        </trans-unit>
        <trans-unit id="5bf226ccbe41713d478e11aab7ab361a597353a7" translate="yes" xml:space="preserve">
          <source>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt;&lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;setKeepAliveTime(long,
 TimeUnit)&lt;/code&gt;&lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt;&lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;&lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads. But method &lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt;&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;&lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</source>
          <target state="translated">풀에 현재 corePoolSize 스레드보다 많은 스레드가 있으면 keepAliveTime 이상 동안 유휴 상태 인 경우 초과 스레드가 종료됩니다 ( &lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt; &lt;/a&gt; 참조 ). 이는 풀을 적극적으로 사용하지 않을 때 리소스 소비를 줄이는 수단을 제공합니다. 풀이 나중에 더 활성화되면 새 스레드가 구성됩니다. 이 매개 변수는 &lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;setKeepAliveTime(long, TimeUnit)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 동적으로 변경할 수도 있습니다 . &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값을 사용하면 &lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt; 는&lt;/a&gt; 종료 전에 유휴 스레드가 종료되지 않도록 효과적으로 비활성화합니다. 기본적으로 연결 유지 정책은 corePoolSize 스레드보다 많은 경우에만 적용됩니다. 그러나 &lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt; &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; &lt;/a&gt; 메소드 keepAliveTime 값이 0이 아닌 한이 시간 제한 정책을 코어 스레드에도 적용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3ff33f4d5e297ea7ec3916317d36251a2ccb95" translate="yes" xml:space="preserve">
          <source>If the prefix is &quot;GMT&quot;, &quot;UTC&quot;, or &quot;UT&quot; a &lt;code&gt;ZoneId&lt;/code&gt; with the prefix and the non-zero offset is returned. If the prefix is empty &lt;code&gt;&quot;&quot;&lt;/code&gt; the &lt;code&gt;ZoneOffset&lt;/code&gt; is returned.</source>
          <target state="translated">접두사가 &quot;GMT&quot;, &quot;UTC&quot;또는 &quot;UT&quot; 이면 접두사가 있고 0이 아닌 오프셋이 있는 &lt;code&gt;ZoneId&lt;/code&gt; 가 반환됩니다. 접두사가 비어 있으면 &lt;code&gt;&quot;&quot;&lt;/code&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a88d71fc9f54022eac4890ef06a233fa0844cac0" translate="yes" xml:space="preserve">
          <source>If the prefix is &lt;code&gt;null&lt;/code&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Use &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt; to explicitly indicate that no prefix is present or the prefix is not relevant.</source>
          <target state="translated">If the prefix is &lt;code&gt;null&lt;/code&gt; , an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Use &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt; to explicitly indicate that no prefix is present or the prefix is not relevant.</target>
        </trans-unit>
        <trans-unit id="2958ef27e71136debb4afdbdf265b117d00e567e" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is greater than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be truncated. In this case, if the file offset as returned by the &lt;code&gt;getFilePointer&lt;/code&gt; method is greater than &lt;code&gt;newLength&lt;/code&gt; then after this method returns the offset will be equal to &lt;code&gt;newLength&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 메소드가 리턴 한 파일의 현재 길이가 &lt;code&gt;newLength&lt;/code&gt; 인수 보다 크면 파일이 잘립니다. 이 경우, &lt;code&gt;getFilePointer&lt;/code&gt; 메소드에 의해 리턴 된 파일 오프셋 이 &lt;code&gt;newLength&lt;/code&gt; 보다 큰 경우 , 이 메소드가 리턴 된 후 오프셋은 &lt;code&gt;newLength&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9cef2b80409c01c0c853b230c56f0ff2824529e5" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is smaller than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be extended. In this case, the contents of the extended portion of the file are not defined.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 메소드에 의해 리턴 된 파일의 현재 길이가 &lt;code&gt;newLength&lt;/code&gt; 인수 보다 작 으면 파일이 확장됩니다. 이 경우 파일의 확장 부분 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="087d7d53cb32d81d4bb2e8d37c5e0f4bd813cb56" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, the constructor reads the value of the system property:</source>
          <target state="translated">If the previous step fails to find a protocol handler, the constructor reads the value of the system property:</target>
        </trans-unit>
        <trans-unit id="c6c92eb74a9e692df342c2385a09b40d4ef27afc" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, then the constructor tries to load a built-in protocol handler. If this class does not exist, or if the class exists but it is not a subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt;, then a &lt;code&gt;MalformedURLException&lt;/code&gt; is thrown.</source>
          <target state="translated">If the previous step fails to find a protocol handler, then the constructor tries to load a built-in protocol handler. If this class does not exist, or if the class exists but it is not a subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt; , then a &lt;code&gt;MalformedURLException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="dec7b0fc3a3fa3565bc2b4d09d4d15db4b1e4a93" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, then the constructor tries to load from a system default package.</source>
          <target state="translated">이전 단계에서 프로토콜 핸들러를 찾지 못하면 생성자가 시스템 기본 패키지에서로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6585f9f7ecc69964ba3abd119ebdf439ff37f98d" translate="yes" xml:space="preserve">
          <source>If the previous step has found no resource bundle, proceed to Step 6. If a bundle has been found that is a base bundle (a bundle for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle has been found that is a base bundle, but the candidate locale list contained locales other than Locale(&quot;&quot;), put the bundle on hold and proceed to Step 6. If a bundle has been found that is not a base bundle, proceed to Step 7.</source>
          <target state="translated">이전 단계에서 자원 번들을 찾지 못한 경우 6 단계로 진행하십시오. 기본 번들 ( &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; 의 번들) 인 번들이 발견 되고 후보 로케일 목록에 &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; 만 포함 된 경우 , 번들을 호출자에게 리턴하십시오. 기본 번들 인 번들이 발견되었지만 후보 로케일 목록에 Locale ( &quot;&quot;) 이외의 다른 로케일이 포함 된 경우 번들을 보류하고 6 단계로 진행하십시오. 기본 번들이 아닌 번들이 발견 된 경우 7 단계로 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="6778bed4bae7f4aceabe96f43a91b258db12e0c7" translate="yes" xml:space="preserve">
          <source>If the print data is a stream, or a print job requests data as a stream, then &lt;code&gt;SimpleDoc&lt;/code&gt; does not monitor if the service properly closes the stream after data transfer completion or job termination. Clients may prefer to use provide their own implementation of doc that adds a listener to monitor job completion and to validate that resources such as streams are freed (ie closed).</source>
          <target state="translated">인쇄 데이터가 스트림이거나 인쇄 작업이 데이터를 스트림으로 요청하면 &lt;code&gt;SimpleDoc&lt;/code&gt; 은 데이터 전송 완료 또는 작업 종료 후 서비스가 스트림을 올바르게 닫는 지 여부를 모니터링하지 않습니다. 클라이언트는 작업 완료를 모니터하고 스트림과 같은 자원이 해제 (즉, 닫힘)되었는지 확인하기 위해 리스너를 추가하는 고유 한 doc 구현을 사용하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bebb66852f6964b9bd2e3cea1ce8a7ef48446b3a" translate="yes" xml:space="preserve">
          <source>If the process has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">If the process has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt; . If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c209a5eafb6c3fed5697bfbb41d0d1e8b8dc27" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</target>
        </trans-unit>
        <trans-unit id="88bf35bed53cf1a7b9c25c4c647bfc4d663ad0d2" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 경우 주석과 동일한 문자열 세트로 수정할 수없는 세트를 리턴하십시오. 클래스에 주석이없는 경우 빈 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f41793fe3304ceb1d00d62771a4aa39cb3d71ae7" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned. If the &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt;&lt;code&gt;source
 version&lt;/code&gt;&lt;/a&gt; does not support modules, in other words if it is less than or equal to &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt;&lt;code&gt;RELEASE_8&lt;/code&gt;&lt;/a&gt;, then any leading &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt;&lt;code&gt;module prefixes&lt;/code&gt;&lt;/a&gt; are stripped from the names.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned. If the &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt; &lt;code&gt;source version&lt;/code&gt; &lt;/a&gt; does not support modules, in other words if it is less than or equal to &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt; &lt;code&gt;RELEASE_8&lt;/code&gt; &lt;/a&gt;, then any leading &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt; &lt;code&gt;module prefixes&lt;/code&gt; &lt;/a&gt; are stripped from the names.</target>
        </trans-unit>
        <trans-unit id="d3f67fa776d861f7bdbdce342363185f87f166e6" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt;&lt;code&gt;SupportedOptions&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt; &lt;code&gt;SupportedOptions&lt;/code&gt; &lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</target>
        </trans-unit>
        <trans-unit id="09f9046e5ee10b9263ce6a07905ea1779eccbaa9" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt;&lt;code&gt;SupportedOptions&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedoptions&quot;&gt; &lt;code&gt;SupportedOptions&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 경우 주석과 동일한 문자열 세트로 수정할 수없는 세트를 리턴하십시오. 클래스에 주석이없는 경우 빈 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b36cf0c2beb0dbdd953aff6325943dc74920fe4e" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt;&lt;code&gt;SupportedSourceVersion&lt;/code&gt;&lt;/a&gt;, return the source version in the annotation.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt; &lt;code&gt;SupportedSourceVersion&lt;/code&gt; &lt;/a&gt;, return the source version in the annotation.</target>
        </trans-unit>
        <trans-unit id="7003e770420135c1df12e09d555ca6780cff43c6" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt;&lt;code&gt;SupportedSourceVersion&lt;/code&gt;&lt;/a&gt;, return the source version in the annotation. If the class is not so annotated, &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt;&lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedsourceversion&quot;&gt; &lt;code&gt;SupportedSourceVersion&lt;/code&gt; &lt;/a&gt; 으로 주석이 달린 경우 주석 에서 소스 버전을 리턴하십시오. 클래스에 주석이없는 경우 &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt; &lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="31cac7c5487d20649f40e4f99c36175d92d8d730" translate="yes" xml:space="preserve">
          <source>If the profile represents the TRC for the corresponding component as a table rather than a single gamma value, an exception is thrown. In this case the actual table can be obtained through the &lt;a href=&quot;#getTRC(int)&quot;&gt;&lt;code&gt;getTRC(int)&lt;/code&gt;&lt;/a&gt; method. When using a gamma value, the linear component (R, G, or B) is computed as follows:</source>
          <target state="translated">If the profile represents the TRC for the corresponding component as a table rather than a single gamma value, an exception is thrown. In this case the actual table can be obtained through the &lt;a href=&quot;#getTRC(int)&quot;&gt; &lt;code&gt;getTRC(int)&lt;/code&gt; &lt;/a&gt; method. When using a gamma value, the linear component (R, G, or B) is computed as follows:</target>
        </trans-unit>
        <trans-unit id="2a28ee9e20388a55d35f948cd48fff9c84de8808" translate="yes" xml:space="preserve">
          <source>If the program doesn't explicitly hide or dispose the window while processing this event, the window close operation is canceled.</source>
          <target state="translated">If the program doesn't explicitly hide or dispose the window while processing this event, the window close operation is canceled.</target>
        </trans-unit>
        <trans-unit id="b31e3a1fd2087ce273c8b857c1c713db2fbc7119" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate appropriate credentials.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 AuthenticationException을 명시 적으로 포착해야합니다. AuthenticationException을 발견 한 후, 프로그램은 분석 된 컨텍스트의 환경 특성을 적절한 적절한 신임 정보로 업데이트하여 인증을 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c285b45955c2c11ff3e733840c81852c7f62aeb" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate credentials.</source>
          <target state="translated">If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate credentials.</target>
        </trans-unit>
        <trans-unit id="6f2dc297aa51d5849276a390a4e74ee5aecc6575" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationNotSupportedException explicitly before attempting to catch NamingException. After catching &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt;, the program could reattempt the authentication using a different authentication flavor by updating the resolved context's environment properties accordingly.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 AuthenticationNotSupportedException을 명시 적으로 포착해야합니다. &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt; 을 포착 한 후 , 프로그램은 이에 따라 해결 된 컨텍스트의 환경 특성을 업데이트하여 다른 인증 플레이버를 사용하여 인증을 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa89d5f48713a94a294fbe63d3a7465ee70153d" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch CannotProceedException explicitly before attempting to catch NamingException.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 CannotProceedException을 명시 적으로 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8620b756848fd740f3151a464311aed319d8483" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch ContextNotEmptyException explicitly before attempting to catch NamingException. For example, after catching ContextNotEmptyException, the program might try to remove the contents of the context before reattempting the destroy.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 ContextNotEmptyException을 명시 적으로 포착해야합니다. 예를 들어, ContextNotEmptyException을 발견 한 후 프로그램은 삭제를 재 시도하기 전에 컨텍스트의 컨텐츠를 제거하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="895af51843785805eb993f6b245e3c37e050b292" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch NamingSecurityException explicitly before attempting to catch NamingException. A program might want to do this, for example, if it wants to treat security-related exceptions specially from other sorts of naming exception.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 NamingSecurityException을 명시 적으로 포착해야합니다. 예를 들어, 다른 종류의 명명 예외에서 보안 관련 예외를 처리하려는 경우 프로그램이이를 수행하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb41eee27e4dcb52452672c25f0afd9d73a6363a" translate="yes" xml:space="preserve">
          <source>If the properties for this image are not yet known, this method returns &lt;code&gt;null&lt;/code&gt;, and the &lt;code&gt;ImageObserver&lt;/code&gt; object is notified later.</source>
          <target state="translated">If the properties for this image are not yet known, this method returns &lt;code&gt;null&lt;/code&gt; , and the &lt;code&gt;ImageObserver&lt;/code&gt; object is notified later.</target>
        </trans-unit>
        <trans-unit id="c6f5f7560de8700736d8932ba9b65417b272c5ae" translate="yes" xml:space="preserve">
          <source>If the property editor class has a public constructor that takes an Object argument then it will be invoked using the bean parameter as the argument. Otherwise, the default constructor will be invoked.</source>
          <target state="translated">특성 편집기 클래스에 Object 인수를 사용하는 공용 생성자가 있으면 Bean 매개 변수를 인수로 사용하여 호출됩니다. 그렇지 않으면 기본 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0db0c19ce124c9165b021df450a93e7c1b610d" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; with radix 8.</target>
        </trans-unit>
        <trans-unit id="b2f66e3274b70113dec5b6e974df0367593c3c3b" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">특성 값이 ASCII 문자 &lt;code&gt;0&lt;/code&gt; 으로 시작하고 그 뒤에 다른 문자가 오는 경우 기수 8을 사용 하는 &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일하게 8 진 정수로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d846b960ac8982dfe609a8cc87db59aceb1d4596" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">특성 값이 ASCII 문자 &lt;code&gt;0&lt;/code&gt; 으로 시작하고 그 뒤에 다른 문자가 오는 경우 기수 8을 사용 하는 &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일하게 8 진 정수로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="f31812e2389a3fbd5e06ae57741d1eba9e8ae01c" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt; , not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; with radix 16.</target>
        </trans-unit>
        <trans-unit id="0c2a7d82245ca935ebfab36515f8332c15126b95" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">등록 정보 값이 두 개의 ASCII 문자 &lt;code&gt;0x&lt;/code&gt; 또는 ASCII 문자 &lt;code&gt;#&lt;/code&gt; 로 시작하고 그 뒤에 빼기 부호가 없으면 나머지 값은 &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 16 진 정수로 구문 분석됩니다. 기수 16.</target>
        </trans-unit>
        <trans-unit id="3e08b19ba4e6b5c03dd249dfcc97aa3c284ebfc6" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt; , not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; with radix 16.</target>
        </trans-unit>
        <trans-unit id="b9750c4a61406d17de53527d1fc84ece847954d5" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">특성 값이 두 개의 ASCII 문자 &lt;code&gt;0x&lt;/code&gt; 또는 ASCII 문자 &lt;code&gt;#&lt;/code&gt; 로 시작하고 그 뒤에 빼기 부호가 없으면 나머지 값은 &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 16 진 정수로 구문 분석됩니다. 기수 16.</target>
        </trans-unit>
        <trans-unit id="9341abc5c400faccf17a3a07de7fac11536f5e5a" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tag values.</source>
          <target state="translated">If the property value must be one of a set of known tagged values, then this method should return an array of the tag values.</target>
        </trans-unit>
        <trans-unit id="6bfe54e945e0b7d817f4c40688004d1c3e18c1e7" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tag values. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value.</source>
          <target state="translated">속성 값이 알려진 태그 값 집합 중 하나 여야하는 경우이 메서드는 태그 값의 배열을 반환해야합니다. 열거 형 값을 나타내는 데 사용할 수 있습니다 (예 :). PropertyEditor가 태그를 지원하는 경우 값을 설정하는 방법으로 태그 값과 함께 setAsText 사용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cd73dc02e49fa592dbe8e15dd72558ce6881cfe" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tags.</source>
          <target state="translated">If the property value must be one of a set of known tagged values, then this method should return an array of the tags.</target>
        </trans-unit>
        <trans-unit id="ef546a8769cb06ecdb14394d21b131483d0cbdbf" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tags. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value and the use of getAsText to identify the current value.</source>
          <target state="translated">속성 값이 알려진 태그 값 집합 중 하나 여야하는 경우이 메서드는 태그 배열을 반환해야합니다. 열거 형 값을 나타내는 데 사용할 수 있습니다 (예 :). PropertyEditor가 태그를 지원하는 경우 값을 설정하고 getAsText를 사용하여 현재 값을 식별하는 방법으로 태그 값과 함께 setAsText 사용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d4476facb38f8ef6d3eac0b77402edf9355a984" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">보호 된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8efe5ceae64e694176e05313f25266d8f3110e7f" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key. If the underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt; must be encoded as an &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.</source>
          <target state="translated">보호 된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다. 기본 스토어 구현 형의 경우 &lt;code&gt;jks&lt;/code&gt; , &lt;code&gt;key&lt;/code&gt; 로서 부호화해야 &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; 는 PKCS # 8 표준에서 정의 된 바와 같다.</target>
        </trans-unit>
        <trans-unit id="1e8fade5fe2a933f005d764f4f99cdb58a44ddd5" translate="yes" xml:space="preserve">
          <source>If the protocol is &quot;file&quot; and there is an authority component, then permission to connect to and accept connections from that authority may be granted. If the protocol is &quot;file&quot; and the path specifies a file, then permission to read that file is granted. If protocol is &quot;file&quot; and the path is a directory, permission is granted to read all files and (recursively) all files and subdirectories contained in that directory.</source>
          <target state="translated">프로토콜이 &quot;파일&quot;이고 권한 구성 요소가있는 경우 해당 권한에 대한 연결 및 연결 권한이 부여 될 수 있습니다. 프로토콜이 &quot;file&quot;이고 경로가 파일을 지정하면 해당 파일을 읽을 수있는 권한이 부여됩니다. 프로토콜이 &quot;file&quot;이고 경로가 디렉토리 인 경우 해당 디렉토리에 포함 된 모든 파일과 모든 파일 및 하위 디렉토리를 읽을 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5e9c9f7d7d328c23292e6a5e585815516946f8" translate="yes" xml:space="preserve">
          <source>If the protocol is not &quot;file&quot;, then permission to connect to and accept connections from the URL's host is granted.</source>
          <target state="translated">프로토콜이 &quot;파일&quot;이 아닌 경우 URL 호스트에 연결하고 연결을 수락 할 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="40b1f09001ad2f74e8788b23bbde2accb73745d9" translate="yes" xml:space="preserve">
          <source>If the protocol of this URL is &quot;jar&quot;, then the permission granted is based on the permission that is required by the URL of the Jar file.</source>
          <target state="translated">이 URL의 프로토콜이 &quot;jar&quot;인 경우 부여 된 권한은 Jar 파일의 URL에 필요한 권한을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="2f6b4c1a7017bece1784e1294dd82a4357362b10" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMidiDeviceInfo()&quot;&gt;&lt;code&gt;getMidiDeviceInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</source>
          <target state="translated">If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMidiDeviceInfo()&quot;&gt; &lt;code&gt;getMidiDeviceInfo()&lt;/code&gt; &lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="f7aff0ef21850924145fd8d1eef710a0152583e2" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt;&lt;code&gt;getMidiDeviceInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</source>
          <target state="translated">공급자 클래스가 지정되고 설치된 공급자에서 성공적으로 검색 할 수있는 경우 공급자에서 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체 목록 이 검색됩니다. 그렇지 않은 경우 또는 이러한 장치가 후속 일치 항목을 제공하지 않으면 사용 가능한 모든 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 객체 를 포함하도록 &lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt; &lt;code&gt;getMidiDeviceInfo()&lt;/code&gt; &lt;/a&gt; 에서 목록을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="4f695eb9c45a7476a06cdea16f6e7dbf1118f942" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMixerInfo()&quot;&gt;&lt;code&gt;getMixerInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</source>
          <target state="translated">If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMixerInfo()&quot;&gt; &lt;code&gt;getMixerInfo()&lt;/code&gt; &lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="0e695a51fa3964ae1c7613ee0169a232ee920a9d" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt;&lt;code&gt;getMixerInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</source>
          <target state="translated">공급자 클래스가 지정되고 설치된 공급자에서 성공적으로 검색 할 수있는 경우 Provider에서 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체 목록 이 검색됩니다. 그렇지 않은 경우 또는 이러한 믹서가 후속 일치 항목을 제공하지 않으면 사용 가능한 모든 &lt;code&gt;Mixer.Info&lt;/code&gt; 오브젝트 를 포함하기 위해 &lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt; &lt;code&gt;getMixerInfo()&lt;/code&gt; &lt;/a&gt; 에서 목록이 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="60186988e7792b549f33f598eb6796ff82e377be" translate="yes" xml:space="preserve">
          <source>If the provider implementation is dynamic, then the flag gives the option of preventing the returned rules from being cached in &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;. When the flag is true, the provider is permitted to return null, where null will prevent the rules from being cached in &lt;code&gt;ZoneId&lt;/code&gt;. When the flag is false, the provider must return non-null rules.</source>
          <target state="translated">제공자 구현이 동적 인 경우 플래그는 리턴 된 규칙이 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 에 캐시되지 않도록하는 옵션을 제공합니다 . 플래그가 true 인 경우 공급자는 null을 반환 할 수 있습니다. 여기서 null은 규칙이 &lt;code&gt;ZoneId&lt;/code&gt; 에 캐시되지 않도록합니다 . 플래그가 false이면 제공자는 널이 아닌 규칙을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="e445a3443a37b81ff119acc67b2ad73cb5fb6432" translate="yes" xml:space="preserve">
          <source>If the provider implementation is not dynamic, then the result of the method must be the non-null set of rules selected by the ID.</source>
          <target state="translated">제공자 구현이 동적이 아닌 경우 메소드의 결과는 ID에 의해 선택된 널이 아닌 규칙 세트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="17253c90de92aa58bc36b4a773f197b6ca04e1e5" translate="yes" xml:space="preserve">
          <source>If the provider package list exists and is not empty, then for each element &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; of the list, the factory will attempt to load the class</source>
          <target state="translated">공급자 패키지 목록이 존재하고 비어 있지 않은 경우 목록의 각 요소 &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; 에 대해 팩토리는 클래스를로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="622b60c7279314ec79406efe2e9c7dcfd8abc786" translate="yes" xml:space="preserve">
          <source>If the proxy could not be created, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt;&lt;code&gt;StubNotFoundException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">If the proxy could not be created, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt; &lt;code&gt;StubNotFoundException&lt;/code&gt; &lt;/a&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="d01e7ab79ccc797c94edb821e2001a4b21858cc0" translate="yes" xml:space="preserve">
          <source>If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">큐에 여유 공간이있는 지정된 배열에 큐가 적합하면 (즉, 배열에 큐보다 많은 요소가있는 경우) 콜렉션의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a336b114f09759ab0e34346b42e3f6b6437e8fc" translate="yes" xml:space="preserve">
          <source>If the radix is less than &lt;a href=&quot;../lang/character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;../lang/character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">If the radix is less than &lt;a href=&quot;../lang/character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt; or greater than &lt;a href=&quot;../lang/character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="99b3e8d45f37070b6c7a53d21e9f356902e9580a" translate="yes" xml:space="preserve">
          <source>If the radix is less than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or greater than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">기수가 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 보다 작은 지, &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; 보다 큰 경우 는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="a648ff4273d99de4e1bc95f12a1486f421ca4054" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the character is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">기수가 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 범위 에 있지 않거나 문자가 지정된 기수의 유효한 숫자가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 다음 중 하나 이상에 해당하면 문자는 유효한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="d4a1e7fa070e5bd8bde88ce903f985156a6f1b0d" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the value of &lt;code&gt;ch&lt;/code&gt; is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">기수가 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 범위 에 있지 않거나 &lt;code&gt;ch&lt;/code&gt; 값이 지정된 기수의 유효한 숫자가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 다음 중 하나 이상에 해당하면 문자는 유효한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="671d0d109c8316ebaf1f99c9e9a6b5ad599bcdb9" translate="yes" xml:space="preserve">
          <source>If the radix is smaller than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or larger than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then the radix &lt;code&gt;10&lt;/code&gt; is used instead.</source>
          <target state="translated">기수 미만이면 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 보다 이상 &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; 후 기수 &lt;code&gt;10&lt;/code&gt; 대신 사용된다.</target>
        </trans-unit>
        <trans-unit id="88c548789120cc039a2be678f91a294c4a57446d" translate="yes" xml:space="preserve">
          <source>If the read lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">읽기 잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1de0197561ab1c42739d318716c6da06cb232ac" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown regardless of whether an input source has been set or whether the indices are in bounds.</source>
          <target state="translated">리더가 썸네일을 지원하지 않으면 ( &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ) 입력 소스가 설정되었는지 또는 인덱스가 범위 내에 있는지에 관계없이 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb2451c0113cb8c1e0775121dff8874d947bd15f" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">리더가 썸네일을 지원하지 않으면 ( &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환 ) &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79b35d0dc9d2895dea0c8a3b110254c91b6bdc53" translate="yes" xml:space="preserve">
          <source>If the receiver is laying its &lt;code&gt;View&lt;/code&gt;s along the &lt;code&gt;Y_AXIS&lt;/code&gt;, this will return the value from invoking the same method on the &lt;code&gt;View&lt;/code&gt; responsible for rendering &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt;. Otherwise this will return false.</source>
          <target state="translated">If the receiver is laying its &lt;code&gt;View&lt;/code&gt; s along the &lt;code&gt;Y_AXIS&lt;/code&gt; , this will return the value from invoking the same method on the &lt;code&gt;View&lt;/code&gt; responsible for rendering &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt; . Otherwise this will return false.</target>
        </trans-unit>
        <trans-unit id="00cde4cc70dae1cb495d031cb9acb67bc8abef24" translate="yes" xml:space="preserve">
          <source>If the recognized year number is less than 100, it is interpreted as an abbreviated year relative to a century of which dates are within 80 years before and 19 years after the time when the Date class is initialized. After adjusting the year number, 1900 is subtracted from it. For example, if the current year is 1999 then years in the range 19 to 99 are assumed to mean 1919 to 1999, while years from 0 to 18 are assumed to mean 2000 to 2018. Note that this is slightly different from the interpretation of years less than 100 that is used in &lt;a href=&quot;../text/simpledateformat&quot;&gt;&lt;code&gt;SimpleDateFormat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인식 된 연도 수가 100보다 작은 경우 Date 클래스가 초기화 된 시간의 80 년 전과 19 년 후 날짜가 세기를 기준으로 약식 연도로 해석됩니다. 연도 번호를 조정 한 후 1900을 뺍니다. 예를 들어, 현재 연도가 1999 인 경우 19-99 범위의 연도는 1919-1999를 의미하고 0-18은 연도는 2000-2018을 의미한다고 가정합니다. 이는 연도 해석과 약간 다릅니다. 적은 100보다 그에서 사용 &lt;a href=&quot;../text/simpledateformat&quot;&gt; &lt;code&gt;SimpleDateFormat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="010a039d9be90452e6c238ffa1c527f615bc99fe" translate="yes" xml:space="preserve">
          <source>If the recorded values contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</source>
          <target state="translated">If the recorded values contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</target>
        </trans-unit>
        <trans-unit id="fcacf666045f97e91725b22bc1de0a3b50a4cbe3" translate="yes" xml:space="preserve">
          <source>If the recorded values contain infinities of opposite sign, the sum will be NaN.</source>
          <target state="translated">If the recorded values contain infinities of opposite sign, the sum will be NaN.</target>
        </trans-unit>
        <trans-unit id="75c49e5b2d7ecad5d026c07a5fdde433fcf5271a" translate="yes" xml:space="preserve">
          <source>If the recorded values contain one or more infinities, the sum will be infinite or NaN.</source>
          <target state="translated">If the recorded values contain one or more infinities, the sum will be infinite or NaN.</target>
        </trans-unit>
        <trans-unit id="57ad84aa4b7a2b33d920b4d445e6eaeb418fc1cc" translate="yes" xml:space="preserve">
          <source>If the region is such that this width is zero, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">영역이이 폭이 0이되면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c3b8b1f31e8b1eb0578d0596a852433e7405f3a" translate="yes" xml:space="preserve">
          <source>If the relation is represented by an MBean (created by the user and added as a relation in the Relation Service), returns the ObjectName of the MBean.</source>
          <target state="translated">관계가 MBean으로 표시되면 (사용자가 작성하고 관계 서비스에서 관계로 추가 된 경우) MBean의 ObjectName을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a4fea0cc0a062ac6f4b44054eaf08ec5f2eead20" translate="yes" xml:space="preserve">
          <source>If the relationship between nested types is expressed directly through the &lt;code&gt;NestHost&lt;/code&gt; and &lt;code&gt;NestMembers&lt;/code&gt; attributes (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29), then the associated &lt;code&gt;Lookup&lt;/code&gt; object provides direct access to the lookup class and all of its nestmates (see &lt;a href=&quot;../class#getNestHost()&quot;&gt;&lt;code&gt;Class.getNestHost&lt;/code&gt;&lt;/a&gt;). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C.D.E&lt;/code&gt;, or &lt;code&gt;C.B&lt;/code&gt;, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to access those private members. A workaround for this limitation is the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</source>
          <target state="translated">If the relationship between nested types is expressed directly through the &lt;code&gt;NestHost&lt;/code&gt; and &lt;code&gt;NestMembers&lt;/code&gt; attributes (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29), then the associated &lt;code&gt;Lookup&lt;/code&gt; object provides direct access to the lookup class and all of its nestmates (see &lt;a href=&quot;../class#getNestHost()&quot;&gt; &lt;code&gt;Class.getNestHost&lt;/code&gt; &lt;/a&gt;). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt; , &lt;code&gt;C.D.E&lt;/code&gt; , or &lt;code&gt;C.B&lt;/code&gt; , but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to access those private members. A workaround for this limitation is the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</target>
        </trans-unit>
        <trans-unit id="16b1911621b01dde472303d885688d4202ac98fc" translate="yes" xml:space="preserve">
          <source>If the remapping function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">If the remapping function returns &lt;code&gt;null&lt;/code&gt; , the mapping is removed (or remains absent if initially absent). If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</target>
        </trans-unit>
        <trans-unit id="eed62fa294d3e85832e433cc3d47b46c67241064" translate="yes" xml:space="preserve">
          <source>If the remapping function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">If the remapping function returns &lt;code&gt;null&lt;/code&gt; , the mapping is removed. If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</target>
        </trans-unit>
        <trans-unit id="6c90ca0b52fc5c89008817da193bca78cfc36ed6" translate="yes" xml:space="preserve">
          <source>If the remote MBean Server is 1.2</source>
          <target state="translated">리모트 MBean 서버가 1.2 인 경우</target>
        </trans-unit>
        <trans-unit id="03cc18ab3cabbd8e48236da939259f3b987d3f83" translate="yes" xml:space="preserve">
          <source>If the remote destination to which the socket is connected does not exist, or is otherwise unreachable, and if an ICMP destination unreachable packet has been received for that address, then a subsequent call to send or receive may throw a PortUnreachableException. Note, there is no guarantee that the exception will be thrown.</source>
          <target state="translated">소켓이 연결된 원격 대상이 존재하지 않거나 도달 할 수없는 경우 해당 주소에 대해 ICMP 대상 도달 불가능 패킷이 수신 된 경우, 후속 송신 또는 수신 호출에서 PortUnreachableException이 발생할 수 있습니다. 예외가 발생한다고 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="57098f4ee262627cd7b01db63d1f7f1265d43afa" translate="yes" xml:space="preserve">
          <source>If the requested attribute is not in the list, this is a no-op.</source>
          <target state="translated">If the requested attribute is not in the list, this is a no-op.</target>
        </trans-unit>
        <trans-unit id="018a97b62ca2a70069aed6a1c61c5a920e8d9cac" translate="yes" xml:space="preserve">
          <source>If the requested opacity value is less than &lt;code&gt;1.0f&lt;/code&gt;, and any of the above conditions are not met, the window opacity will not change, and the &lt;code&gt;IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the requested opacity value is less than &lt;code&gt;1.0f&lt;/code&gt; , and any of the above conditions are not met, the window opacity will not change, and the &lt;code&gt;IllegalComponentStateException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="1d89a1cc49adab461bf1f01dc66545d017f8bacb" translate="yes" xml:space="preserve">
          <source>If the requested option is binary, it can be set using this method by a java.lang.Boolean:</source>
          <target state="translated">요청 된 옵션이 이진 인 경우 java.lang.Boolean에서이 메소드를 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ce1c03b79a7b89afd15d63c7ba902df5495593" translate="yes" xml:space="preserve">
          <source>If the requested permission is allowed, this method returns quietly. If denied, a SecurityException is raised.</source>
          <target state="translated">요청 된 권한이 허용되면이 메소드는 자동으로 리턴합니다. 거부되면 SecurityException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2e93c0c542e53839669b61ae87dd1ffe992a629" translate="yes" xml:space="preserve">
          <source>If the requested shape is not &lt;code&gt;null&lt;/code&gt;, and any of the above conditions are not met, the shape of this window will not change, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt;
 IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the requested shape is not &lt;code&gt;null&lt;/code&gt; , and any of the above conditions are not met, the shape of this window will not change, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt; IllegalComponentStateException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="4c37b9290b4ade460cdf802abd93f12770f8d7f0" translate="yes" xml:space="preserve">
          <source>If the required access and argument checks succeed and the instantiation will proceed, the constructor's declaring class is initialized if it has not already been initialized.</source>
          <target state="translated">필요한 액세스 및 인수 확인이 성공하고 인스턴스화가 진행되면 생성자의 선언 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="0f30dad69df088eb0e8a01273d14f832b9a0aeff" translate="yes" xml:space="preserve">
          <source>If the required properties have not been set, an exception is thrown. If this method is successful, the current contents of the rowset are discarded and the rowset's metadata is also (re)set. If there are outstanding updates, they are ignored.</source>
          <target state="translated">If the required properties have not been set, an exception is thrown. If this method is successful, the current contents of the rowset are discarded and the rowset's metadata is also (re)set. If there are outstanding updates, they are ignored.</target>
        </trans-unit>
        <trans-unit id="1eeec4d99736a2aab560f80ec43309d2f90d3ed3" translate="yes" xml:space="preserve">
          <source>If the resolver argument is null, the URIResolver value will be cleared and the transformer will no longer have a resolver.</source>
          <target state="translated">If the resolver argument is null, the URIResolver value will be cleared and the transformer will no longer have a resolver.</target>
        </trans-unit>
        <trans-unit id="fa7d4a7621c617404117d28c394ccda5b256dfa2" translate="yes" xml:space="preserve">
          <source>If the resource manager did not commit the transaction and the paramether onePhase is set to true, the resource manager may throw one of the XA_RB* exceptions. Upon return, the resource manager has rolled back the branch's work and has released all held resources.</source>
          <target state="translated">If the resource manager did not commit the transaction and the paramether onePhase is set to true, the resource manager may throw one of the XA_RB* exceptions. Upon return, the resource manager has rolled back the branch's work and has released all held resources.</target>
        </trans-unit>
        <trans-unit id="03e08a40eb5811e25250f7c549a9fd7b28757670" translate="yes" xml:space="preserve">
          <source>If the resource name ends with &quot;&lt;code&gt;.class&lt;/code&gt;&quot; then it is not encapsulated.</source>
          <target state="translated">If the resource name ends with &quot; &lt;code&gt;.class&lt;/code&gt; &quot; then it is not encapsulated.</target>
        </trans-unit>
        <trans-unit id="62e2c41caf4aaf142a44a8c6c165f53c1d68b4be" translate="yes" xml:space="preserve">
          <source>If the result of this method is used to access the event source, for example, to look up the object or get its attributes, then it needs to be locked because implementations of &lt;code&gt;Context&lt;/code&gt; are not guaranteed to be thread-safe (and &lt;code&gt;EventContext&lt;/code&gt; is a subinterface of &lt;code&gt;Context&lt;/code&gt;). See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">이 메소드의 결과가 예를 들어 오브젝트를 찾거나 속성을 얻는 등의 이벤트 소스에 액세스하는 데 사용되는 경우 &lt;code&gt;Context&lt;/code&gt; 구현은 스레드로부터 안전하지 않기 때문에 잠겨 야 합니다 (그리고 &lt;code&gt;EventContext&lt;/code&gt; 는 &lt;code&gt;Context&lt;/code&gt; 의 하위 인터페이스 ). 스레딩 문제에 대한 자세한 내용은 &lt;a href=&quot;package-summary#THREADING&quot;&gt;패키지 설명&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da3549687bea03167816a9b17ffaee344e82b496" translate="yes" xml:space="preserve">
          <source>If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown. The time and offset do not affect the calculation and will be the same in the result.</source>
          <target state="translated">결과 &lt;code&gt;OffsetDateTime&lt;/code&gt; 이 유효하지 않으면 예외가 발생합니다. 시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="35a287431d52af9ee48c2d5a75b9272669222ecb" translate="yes" xml:space="preserve">
          <source>If the resulting &lt;code&gt;Rectangle&lt;/code&gt; would have a dimension too large to be expressed as an &lt;code&gt;int&lt;/code&gt;, the result will have a dimension of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; along that dimension.</source>
          <target state="translated">If the resulting &lt;code&gt;Rectangle&lt;/code&gt; would have a dimension too large to be expressed as an &lt;code&gt;int&lt;/code&gt; , the result will have a dimension of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; along that dimension.</target>
        </trans-unit>
        <trans-unit id="1d921983024b3a73fd6c36177cb6aac0894e7d34" translate="yes" xml:space="preserve">
          <source>If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary.</source>
          <target state="translated">If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary.</target>
        </trans-unit>
        <trans-unit id="587aeb87194f308dfa93440ba8ff79e1c3891aa4" translate="yes" xml:space="preserve">
          <source>If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary.</source>
          <target state="translated">If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary.</target>
        </trans-unit>
        <trans-unit id="8a3d11d3b73e216be8517618d151d35e100edd64" translate="yes" xml:space="preserve">
          <source>If the resulting date is invalid, an exception is thrown.</source>
          <target state="translated">결과 날짜가 유효하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ca351660a2dc03d4cb71b7bc124559d23a4db29" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown.</source>
          <target state="translated">결과 날짜-시간이 유효하지 않은 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44ca6bebbc9287dfb9c1097c7e056b162daf7bcb" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown. The time does not affect the calculation and will be the same in the result.</source>
          <target state="translated">결과 날짜-시간이 유효하지 않은 경우 예외가 발생합니다. 시간은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4f6dc2bf2873abab7867f3b616c93e4b15b446fa" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a primitive, a zero value is introduced.</source>
          <target state="translated">리턴 유형 &lt;em&gt;T0&lt;/em&gt; 이 void이고 &lt;em&gt;T1&lt;/em&gt; 이 기본이면 0 값이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="f822d109dcf5c55256ad0bbca3b4f4180ce12367" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a reference, a null value is introduced.</source>
          <target state="translated">리턴 유형 &lt;em&gt;T0&lt;/em&gt; 이 void이고 &lt;em&gt;T1&lt;/em&gt; 이 참조이면 널값이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="22bfe5b1532d3b1937f6f097fa6b7e18ec35a472" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T1&lt;/em&gt; is marked as void, any returned value is discarded</source>
          <target state="translated">반환 유형 &lt;em&gt;T1&lt;/em&gt; 이 void로 표시되면 반환 된 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8a413e6168d2b6897adbb71ca65aa2bb806445d1" translate="yes" xml:space="preserve">
          <source>If the return type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">리턴 유형이 매개 변수화 된 유형 인 경우 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="c790d87847b61c0198be1f5880f62ee8cbf59f42" translate="yes" xml:space="preserve">
          <source>If the return type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">리턴 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="29af74f5a09429dcfd9193c144c392b2c8199600" translate="yes" xml:space="preserve">
          <source>If the return type of any of the methods is a primitive type or void, then all of the methods must have that same return type.</source>
          <target state="translated">메소드의 리턴 유형이 기본 유형이거나 void 인 경우 모든 메소드는 동일한 리턴 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="a5a546d9693c1042591033e7eb00ca2f2a455047" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;code&gt;non-null&lt;/code&gt;, all attributes in the returned set are unsupported with this &lt;code&gt;DocFlavor&lt;/code&gt;. The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</source>
          <target state="translated">If the return value is &lt;code&gt;non-null&lt;/code&gt; , all attributes in the returned set are unsupported with this &lt;code&gt;DocFlavor&lt;/code&gt; . The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</target>
        </trans-unit>
        <trans-unit id="17d771c49fde9fd06df899fa732fea09b1398c4a" translate="yes" xml:space="preserve">
          <source>If the return value is non-null, all attributes in the returned set are unsupported with this DocFlavor. The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</source>
          <target state="translated">리턴 값이 널이 아닌 경우, 리턴 된 세트의 모든 속성이이 DocFlavor에서 지원되지 않습니다. 리턴 된 세트는 지원되지 않는 속성 값과 지원되지 않는 속성 카테고리를 구별하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5779215ae457d29d8170805afb88e18c9cd73378" translate="yes" xml:space="preserve">
          <source>If the returned VarHandle is operated on, the declaring class will be initialized, if it has not already been initialized.</source>
          <target state="translated">If the returned VarHandle is operated on, the declaring class will be initialized, if it has not already been initialized.</target>
        </trans-unit>
        <trans-unit id="eccb50eb8fca6c917cb62a8ea7ba110f808e9efb" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked with a &lt;code&gt;null&lt;/code&gt; array reference, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the returned method handle is invoked with a &lt;code&gt;null&lt;/code&gt; array reference, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="a121ca0e7664dd7a93409420197145f4f87f1e39" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked with a negative array size, a &lt;code&gt;NegativeArraySizeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the returned method handle is invoked with a negative array size, a &lt;code&gt;NegativeArraySizeException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="d67afcae574c0dadec33d0948d30e110523b788e" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the constructor's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 생성자의 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="bba8a24f154f8c33c7318be4afad7cbac85009fd" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 필드의 클래스가 아직 초기화되지 않은 경우 필드 클래스가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="51fb639a4d11801aea7b926f5d54285fffc4a0fb" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the method's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 메소드의 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="062c7a8a96f0cd16df82fd6a3d7ef90b21f0c525" translate="yes" xml:space="preserve">
          <source>If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the &lt;code&gt;flush&lt;/code&gt; method is called on the returned node (or one of its ancestors or descendants).</source>
          <target state="translated">이 호출 이전에 리턴 된 노드가 존재하지 않으면이 노드와이 호출로 작성된 상위 노드는 리턴 된 노드 (또는 상위 또는 하위 항목 중 하나) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 영구적으로 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31845fc89c4f6a02a974ef2eb4b2ee1fabe487a0" translate="yes" xml:space="preserve">
          <source>If the returned object represents a &lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;source&lt;/a&gt; or &lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;class&lt;/a&gt; file, it must be an instance of &lt;a href=&quot;javafileobject&quot;&gt;&lt;code&gt;JavaFileObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 오브젝트가 &lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;소스&lt;/a&gt; 또는 &lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;클래스&lt;/a&gt; 파일을 나타내는 경우 &lt;a href=&quot;javafileobject&quot;&gt; &lt;code&gt;JavaFileObject&lt;/code&gt; &lt;/a&gt; 의 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="730234ede727312ada9b756fde5db3279ce11863" translate="yes" xml:space="preserve">
          <source>If the root node isn't visible, it is generally a good to make this value true. Otherwise, the tree looks exactly like a list, and users may not know that the &quot;list entries&quot; are actually tree nodes.</source>
          <target state="translated">If the root node isn't visible, it is generally a good to make this value true. Otherwise, the tree looks exactly like a list, and users may not know that the &quot;list entries&quot; are actually tree nodes.</target>
        </trans-unit>
        <trans-unit id="5ec11db983f71de1343f50235b7b5724bd516b85" translate="yes" xml:space="preserve">
          <source>If the row number is positive, the cursor moves to the given row number with respect to the beginning of the result set. The first row is row 1, the second is row 2, and so on.</source>
          <target state="translated">If the row number is positive, the cursor moves to the given row number with respect to the beginning of the result set. The first row is row 1, the second is row 2, and so on.</target>
        </trans-unit>
        <trans-unit id="dca61f9ccb26f5859e93cf51aef9999003d9187e" translate="yes" xml:space="preserve">
          <source>If the row number specified is zero, the cursor is moved to before the first row.</source>
          <target state="translated">If the row number specified is zero, the cursor is moved to before the first row.</target>
        </trans-unit>
        <trans-unit id="6e65e674c2c9738a67b46cbdff85eddf6bd7d6d6" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the cutover might occur, then this method returns the day-of-week that the month-day will be adjusted to. If the day is positive then the adjustment is later. If the day is negative then the adjustment is earlier.</source>
          <target state="translated">규칙이 컷 오버가 발생할 수있는 주를 정의하면이 방법은 월이 조정될 요일을 반환합니다. 일이 양수이면 나중에 조정됩니다. 일이 음수이면 조정이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ab9f1126ac23de664120eeb0433d59deaee2f7bd" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the day defines either the start of the end of the transition week.</source>
          <target state="translated">규칙에서 전환이 발생할 수있는 주를 정의하면 해당 요일은 전환 주 끝의 시작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="89f95b53b5119c06e7c28d0a4953b38d65679d33" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the month if the month of either the earliest or latest possible date of the cutover.</source>
          <target state="translated">규칙에서 전환이 발생할 수있는 주를 정의하는 경우 컷 오버의 가장 빠른 날짜 또는 가장 최근 달인 월입니다.</target>
        </trans-unit>
        <trans-unit id="c5876d137cd994c7ad4a664d7beaa1b898954c4d" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the day is the month of that date.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 그 날짜는 해당 날짜의 월입니다.</target>
        </trans-unit>
        <trans-unit id="7a405331c7ddef3021a3335c00454f67145186ff" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the month is the month of that date.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 해당 월이 해당 날짜의 월입니다.</target>
        </trans-unit>
        <trans-unit id="5034d0b228d4988928265c1d8ac1f628685a4b7f" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then this returns null.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="188251de9eebdf9999e55d3130ae4d68d97ee026" translate="yes" xml:space="preserve">
          <source>If the same &lt;code&gt;Action&lt;/code&gt; is used with menus and buttons you'll typically specify both a &lt;code&gt;SMALL_ICON&lt;/code&gt; and a &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;. The menu will use the &lt;code&gt;SMALL_ICON&lt;/code&gt; and the button the &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;.</source>
          <target state="translated">같은 경우 &lt;code&gt;Action&lt;/code&gt; 메뉴와 버튼을 사용하면 일반적으로 모두 지정해야 &lt;code&gt;SMALL_ICON&lt;/code&gt; 과 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 를 . 메뉴는 사용 &lt;code&gt;SMALL_ICON&lt;/code&gt; 과 버튼 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="77685adc8a0c8449f2dc16b0f092c4e3cf760fa3" translate="yes" xml:space="preserve">
          <source>If the same &lt;code&gt;Action&lt;/code&gt; is used with menus and buttons you'll typically specify both a &lt;code&gt;SMALL_ICON&lt;/code&gt; and a &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;. The menu will use the &lt;code&gt;SMALL_ICON&lt;/code&gt; and the button will use the &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;.</source>
          <target state="translated">같은 경우 &lt;code&gt;Action&lt;/code&gt; 메뉴와 버튼을 사용하면 일반적으로 모두 지정해야 &lt;code&gt;SMALL_ICON&lt;/code&gt; 과 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 를 . 메뉴는 &lt;code&gt;SMALL_ICON&lt;/code&gt; 을 사용하고 버튼은 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2f0e91ac8cea622cd628a97cacbf583516eb1203" translate="yes" xml:space="preserve">
          <source>If the same MXBean were registered under two different &lt;code&gt;ObjectName&lt;/code&gt;s, a reference to that MXBean from another MXBean would be ambiguous. Therefore, if an MXBean object is already registered in an MBean Server and an attempt is made to register it in the same MBean Server under another name, the result is an &lt;a href=&quot;instancealreadyexistsexception&quot;&gt;&lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt;&lt;/a&gt;. Registering the same MBean object under more than one name is discouraged in general, notably because it does not work well for MBeans that are &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">동일한 MXBean이 두 개의 다른 &lt;code&gt;ObjectName&lt;/code&gt; 아래에 등록 된 경우 다른 MXBean에서 해당 MXBean에 대한 참조가 모호합니다. 따라서 MXBean 객체가 이미 MBean 서버에 등록되어 있고 다른 이름으로 동일한 MBean 서버에 등록하려고하면 결과는 &lt;a href=&quot;instancealreadyexistsexception&quot;&gt; &lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt; &lt;/a&gt; 입니다. 하나 이상의 이름으로 동일한 MBean 객체를 등록하는 것은 일반적으로 권장되지 않습니다. 특히 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 인&lt;/a&gt; MBean에서는 제대로 작동하지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="50eb773388c08998af191260a43e85de5e2d0eab" translate="yes" xml:space="preserve">
          <source>If the same listener is added more than once, it is considered as many times as it was added. It is often useful to add the same listener with different filters or handback objects.</source>
          <target state="translated">동일한 리스너가 두 번 이상 추가되면 추가 된 횟수만큼 간주됩니다. 필터 나 핸드백 객체가 다른 동일한 리스너를 추가하는 것이 유용한 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="a530990bfaa8ba340ab7814bcb938600df0674e3" translate="yes" xml:space="preserve">
          <source>If the same listener was added more than once, it will be notified one less time after being removed. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or was never added, no exception is thrown and no action is taken.</source>
          <target state="translated">동일한 리스너가 두 번 이상 추가 된 경우 제거 된 후 한 번 덜 알림을받습니다. 경우 &lt;code&gt;listener&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 또는 추가되지 않았다, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a2f1faa361a4f239eecfaa4480ce58bb66c8e63" translate="yes" xml:space="preserve">
          <source>If the scale is greater than or equal to zero and the adjusted exponent is greater than or equal to &lt;code&gt;-6&lt;/code&gt;, the number will be converted to a character form without using exponential notation. In this case, if the scale is zero then no decimal point is added and if the scale is positive a decimal point will be inserted with the scale specifying the number of characters to the right of the decimal point. &lt;code&gt;'0'&lt;/code&gt; characters are added to the left of the converted unscaled value as necessary. If no character precedes the decimal point after this insertion then a conventional &lt;code&gt;'0'&lt;/code&gt; character is prefixed.</source>
          <target state="translated">스케일이 0보다 크거나 조정 된 지수가 &lt;code&gt;-6&lt;/code&gt; 보다 크거나 같은 경우 , 지수 표기법을 사용하지 않고 숫자가 문자 형식으로 변환됩니다. 이 경우 스케일이 0이면 소수점이 추가되지 않고 스케일이 양수이면 소수점 오른쪽에 문자 수를 지정하는 스케일과 함께 소수점이 삽입됩니다. 필요에 따라 변환 된 스케일링되지 않은 값의 왼쪽에 &lt;code&gt;'0'&lt;/code&gt; 문자가 추가됩니다. 이 삽입 후 소수점 앞에 문자가 없으면 일반적인 &lt;code&gt;'0'&lt;/code&gt; 문자가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="b6699480c9af01ef59363f0886670fc80f9f3dd6" translate="yes" xml:space="preserve">
          <source>If the scheme component is defined in the given spec and does not match the scheme of the context, then the new URL is created as an absolute URL based on the spec alone. Otherwise the scheme component is inherited from the context URL.</source>
          <target state="translated">스킴 구성 요소가 지정된 스펙에 정의되어 있고 컨텍스트의 스킴과 일치하지 않으면 스펙 만 기반으로 새 URL이 절대 URL로 작성됩니다. 그렇지 않으면 스킴 구성 요소가 컨텍스트 URL에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="0f6fbda65188dadd280d2d62127e7bf188917970" translate="yes" xml:space="preserve">
          <source>If the screens configuration does not allow the window to be moved from one screen to another, then the window is only placed at the location determined according to the above conditions and its &lt;code&gt;GraphicsConfiguration&lt;/code&gt; is not changed.</source>
          <target state="translated">화면 구성에서 창을 한 화면에서 다른 화면으로 이동할 수없는 경우 창은 위의 조건에 따라 결정된 위치에만 배치되고 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dcb8547b15783f8929c319cccddbb69b3b6cf00" translate="yes" xml:space="preserve">
          <source>If the scrollbar display policy is defined as &quot;never&quot;, then the scrollpane can still be programmatically scrolled using the setScrollPosition() method and the scrollpane will move and clip the child's contents appropriately. This policy is useful if the program needs to create and manage its own adjustable controls.</source>
          <target state="translated">스크롤바 표시 정책이 &quot;never&quot;로 정의되어있는 경우 setScrollPosition () 메서드를 사용하여 스크롤 창을 프로그래밍 방식으로 계속 스크롤 할 수 있으며 스크롤 창은 자식의 콘텐츠를 적절하게 이동하고 클립합니다. 이 정책은 프로그램이 자체 조정 가능한 컨트롤을 만들고 관리해야하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="481d140f57a30b2cc9e64db972e10c648c8a2a3b" translate="yes" xml:space="preserve">
          <source>If the scrollpane has a non-&lt;code&gt;null&lt;/code&gt;&lt;code&gt;viewportBorder&lt;/code&gt;, then space is allocated for that.</source>
          <target state="translated">scrollpane에 &lt;code&gt;null&lt;/code&gt; 이 아닌 &lt;code&gt;viewportBorder&lt;/code&gt; 가 있으면 공간이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="6ccd5d8778f5d88a5474e8c59978eccee5689a2e" translate="yes" xml:space="preserve">
          <source>If the second argument is 1.0, then the result is the same as the first argument.</source>
          <target state="translated">두 번째 인수가 1.0이면 결과는 첫 번째 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8344687c76c61e184619d725d0545c562c31518" translate="yes" xml:space="preserve">
          <source>If the second argument is NaN, then the result is NaN.</source>
          <target state="translated">두 번째 인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="728f5c52b29916aebc4c06ac0928425a83bcd984" translate="yes" xml:space="preserve">
          <source>If the second argument is an &lt;code&gt;InputStream&lt;/code&gt; then the stream must contain number of bytes specified by scaleOrLength. If the second argument is a &lt;code&gt;Reader&lt;/code&gt; then the reader must contain the number of characters specified by scaleOrLength. If these conditions are not true the driver will generate a &lt;code&gt;SQLException&lt;/code&gt; when the statement is executed.</source>
          <target state="translated">두 번째 인수가 &lt;code&gt;InputStream&lt;/code&gt; 이면 스트림에는 scaleOrLength로 지정된 바이트 수가 포함되어야합니다. 두 번째 인수가 &lt;code&gt;Reader&lt;/code&gt; 인 경우 판독기는 scaleOrLength로 지정된 문자 수를 포함해야합니다. 이러한 조건이 참이 아닌 경우 드라이버는 명령문이 실행될 때 &lt;code&gt;SQLException&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="5e66ea14e901f2694aafe98690642d15fedd9f3e" translate="yes" xml:space="preserve">
          <source>If the second argument is an &lt;code&gt;InputStream&lt;/code&gt; then the stream must contain the number of bytes specified by scaleOrLength. If the second argument is a &lt;code&gt;Reader&lt;/code&gt; then the reader must contain the number of characters specified by scaleOrLength. If these conditions are not true the driver will generate a &lt;code&gt;SQLException&lt;/code&gt; when the statement is executed.</source>
          <target state="translated">두 번째 인수가 &lt;code&gt;InputStream&lt;/code&gt; 이면 스트림에는 scaleOrLength로 지정된 바이트 수가 포함되어야합니다. 두 번째 인수가 &lt;code&gt;Reader&lt;/code&gt; 인 경우 판독기는 scaleOrLength로 지정된 문자 수를 포함해야합니다. 이러한 조건이 참이 아닌 경우 드라이버는 명령문이 실행될 때 &lt;code&gt;SQLException&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="83af07e72de969c0ada685452a5155bf504024e7" translate="yes" xml:space="preserve">
          <source>If the second argument is positive or negative zero, then the result is 1.0.</source>
          <target state="translated">두 번째 인수가 양수 또는 음수 0이면 결과는 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="9b941ca67a1b9bc33a6bb0d7bf06f63dc95c2df8" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then jump to the next space.</source>
          <target state="translated">초를 사용할 수 없으면 다음 공간으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="6ea372174aa5c23af0c1777c675872adacfad266" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then the format is complete.</source>
          <target state="translated">초를 사용할 수 없으면 형식이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0ca0c8f14e74d6e3c35517091b31f9d9d7a6b0c" translate="yes" xml:space="preserve">
          <source>If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any &lt;code&gt;Date&lt;/code&gt; value &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">초 필드가 밀리 초 순서보다 많은 자릿수를 전달하는 경우 해당 숫자는 단순히 버려집니다 (즉, 0으로 반올림됩니다.). 예를 들어, &lt;code&gt;Date&lt;/code&gt; 값 &lt;code&gt;x&lt;/code&gt; 의 경우 ,</target>
        </trans-unit>
        <trans-unit id="6762d0d3f73a120d76591aa7109ff493352a5101" translate="yes" xml:space="preserve">
          <source>If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any Calendar value &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">초 필드가 밀리 초 순서보다 많은 숫자를 전달하는 경우 해당 숫자는 단순히 버려집니다 (즉, 0으로 반올림됩니다.). 예를 들어, 달력 값 &lt;code&gt;x&lt;/code&gt; 의 경우 ,</target>
        </trans-unit>
        <trans-unit id="5653b3f59b63219b61535639dd8eec29f7dad782" translate="yes" xml:space="preserve">
          <source>If the security property is set to the fully qualified name of a &lt;code&gt;CallbackHandler&lt;/code&gt; implementation class, then a &lt;code&gt;LoginContext&lt;/code&gt; will load the specified &lt;code&gt;CallbackHandler&lt;/code&gt; and pass it to the underlying LoginModules. The &lt;code&gt;LoginContext&lt;/code&gt; only loads the default handler if it was not provided one.</source>
          <target state="translated">보안 특성이 &lt;code&gt;CallbackHandler&lt;/code&gt; 구현 클래스 의 완전한 이름으로 설정 되면 &lt;code&gt;LoginContext&lt;/code&gt; 는 지정된 &lt;code&gt;CallbackHandler&lt;/code&gt; 를로드 하여 기본 LoginModules에 전달합니다. &lt;code&gt;LoginContext&lt;/code&gt; 만 하나를 제공하지 않은 경우 기본 핸들러를로드합니다.</target>
        </trans-unit>
        <trans-unit id="d64a3fa99372fe6ed29fb93b51136151680efc81" translate="yes" xml:space="preserve">
          <source>If the selection includes the leftmost (topmost) position, the selection is extended to the left (top) of &lt;code&gt;bounds&lt;/code&gt;. If the selection includes the rightmost (bottommost) position, the selection is extended to the right (bottom) of the bounds. The height (width on vertical lines) of the selection is always extended to &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">선택 항목에 가장 왼쪽 (맨 위) 위치가 포함 된 경우 선택 항목은 &lt;code&gt;bounds&lt;/code&gt; 의 왼쪽 (맨 위)으로 확장됩니다 . 선택 항목에 맨 오른쪽 (맨 아래) 위치가 포함 된 경우 선택 영역이 경계의 오른쪽 (맨 아래)으로 확장됩니다. 선택 항목의 높이 (수직선 너비)는 항상 &lt;code&gt;bounds&lt;/code&gt; 로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c6ce13905c3b53f290f1fe802b6aed3d33f0e9f" translate="yes" xml:space="preserve">
          <source>If the selection mode is &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt;, and adding the new paths would make the selection discontiguous. Then two things can result: if the TreePaths in &lt;code&gt;paths&lt;/code&gt; are contiguous, then the selection becomes these TreePaths, otherwise the TreePaths aren't contiguous and the selection becomes the first TreePath in &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">선택 모드가 &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt; 이고 새 경로를 추가하면 선택이 불 연속적으로됩니다. 그러면 두 가지 결과가 발생할 수 있습니다. &lt;code&gt;paths&lt;/code&gt; 의 TreePath 가 연속적이면 선택 항목이 이러한 TreePath가되고 그렇지 않으면 TreePath가 연속적이지 않고 선택 항목이 &lt;code&gt;paths&lt;/code&gt; 의 첫 번째 TreePath가됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e2c6505b616998dc824a56fb69330d1ffe1a66c" translate="yes" xml:space="preserve">
          <source>If the selection mode is &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt; and more than one TreePath is selected, the selection is reset to contain the first path currently selected.</source>
          <target state="translated">선택 모드가 &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt; 이고 둘 이상의 TreePath를 선택한 경우 현재 선택한 첫 번째 경로를 포함하도록 선택 항목이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a9329c3f6f88e34510974b909e266bf49fd3da54" translate="yes" xml:space="preserve">
          <source>If the selection range includes the first logical character, the selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; before the start of this &lt;code&gt;TextLayout&lt;/code&gt;. If the range includes the last logical character, the selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; after the end of this &lt;code&gt;TextLayout&lt;/code&gt;. The height (width on vertical lines) of the selection is always extended to &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">선택 범위에 첫 번째 논리 문자가 포함 된 경우 선택 영역은 이 &lt;code&gt;TextLayout&lt;/code&gt; 시작 전 &lt;code&gt;bounds&lt;/code&gt; 부분까지 확장됩니다 . 범위에 마지막 논리 문자가 포함 된 경우 선택 &lt;code&gt;bounds&lt;/code&gt; 은이 &lt;code&gt;TextLayout&lt;/code&gt; 끝 이후 의 경계 부분까지 확장됩니다 . 선택 항목의 높이 (수직선 너비)는 항상 &lt;code&gt;bounds&lt;/code&gt; 로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6707140df46f6eb04938367483bc2c365bdb2e5" translate="yes" xml:space="preserve">
          <source>If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the &lt;a href=&quot;#implCloseSelector()&quot;&gt;&lt;code&gt;implCloseSelector&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">선택기가 이미 닫힌 경우이 메서드는 즉시 반환됩니다. 그렇지 않으면 선택기를 닫힌 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;#implCloseSelector()&quot;&gt; &lt;code&gt;implCloseSelector&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="08dd4228bba4510d42bc79e395b01540dece6a1f" translate="yes" xml:space="preserve">
          <source>If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the &lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt;&lt;code&gt;implCloseSelector&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">선택기가 이미 닫혀 있으면이 메서드는 즉시 반환됩니다. 그렇지 않으면 선택기를 닫은 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt; &lt;code&gt;implCloseSelector&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ad935cdc55d4a107502fb1347aaf4da85ef291" translate="yes" xml:space="preserve">
          <source>If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.</source>
          <target state="translated">선택기 자체가 닫히면 채널이 등록 취소되고 등록을 나타내는 키가 추가 지연없이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="527b7c6f507b87aa21ddf93053b13e95205bb2c8" translate="yes" xml:space="preserve">
          <source>If the sequence is mutated while the stream is being read, the result is undefined.</source>
          <target state="translated">스트림을 읽는 동안 시퀀스가 ​​변경되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68365060e1fd3c2daf69dad059677cfed6352297" translate="yes" xml:space="preserve">
          <source>If the sequence of characters is already available as a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor.</source>
          <target state="translated">문자 시퀀스가 ​​이미 문자 배열로 사용 가능한 경우이 생성자를 사용하는 것이 &lt;code&gt;char&lt;/code&gt; 배열을 문자열 로 변환 하고 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 생성자를 사용하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="44599ce71e2e538b01fd695f05e20f34c21d8951" translate="yes" xml:space="preserve">
          <source>If the sequence of characters is already available within a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor.</source>
          <target state="translated">문자 배열 내에서 문자 시퀀스를 이미 사용할 수있는 경우이 생성자를 사용하는 것이 &lt;code&gt;char&lt;/code&gt; 배열을 문자열 로 변환 하고 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 생성자를 사용하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="905718a38e6e40a4a44a638dd8e38175f57a597e" translate="yes" xml:space="preserve">
          <source>If the service provider declares a provider method, then the service loader invokes that method to obtain an instance of the service provider. A provider method is a public static method named &quot;provider&quot; with no formal parameters and a return type that is assignable to the service's interface or class.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하면 서비스 로더는 해당 메서드를 호출하여 서비스 공급자의 인스턴스를 얻습니다. 공급자 메서드는 서비스의 인터페이스 또는 클래스에 할당 할 수있는 반환 형식과 형식 매개 변수가없는 &quot;provider&quot;라는 이름의 공용 정적 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="3b23056cdaee0c387d69777057adce2233310c89" translate="yes" xml:space="preserve">
          <source>If the service provider does not declare a provider method, then the service provider is instantiated directly, via its provider constructor. A provider constructor is a public constructor with no formal parameters.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하지 않으면 서비스 공급자는 공급자 생성자를 통해 직접 인스턴스화됩니다. 공급자 생성자는 형식 매개 변수가없는 공용 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="96cc80cb5c49589843f4c152dbe187b0d7672c14" translate="yes" xml:space="preserve">
          <source>If the set contains &lt;code&gt;null&lt;/code&gt; or elements that are not of type &lt;code&gt;PosixFilePermission&lt;/code&gt; then these elements are ignored.</source>
          <target state="translated">집합에 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;PosixFilePermission&lt;/code&gt; 유형이 아닌 요소가 포함 된 경우 이러한 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bdd7ddd5abc6f06de4935b22a2b32f438818b4c2" translate="yes" xml:space="preserve">
          <source>If the set is modified after the iterator is created, in any way except by invoking the iterator's own &lt;a href=&quot;../../util/iterator#remove()&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method, then a &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">반복자가 생성 된 후 집합이 수정되면 반복기의 자체 &lt;a href=&quot;../../util/iterator#remove()&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하는 것을 제외하고 는 &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a2fc5c10d29d945ad7e76e24ac30350f31297ef" translate="yes" xml:space="preserve">
          <source>If the set is modified after the iterator is created, in any way except by invoking the iterator's own &lt;a href=&quot;../../util/iterator#remove--&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method, then a &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">반복자의 고유 한 &lt;a href=&quot;../../util/iterator#remove--&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것을 제외하고, 반복자가 작성된 후에 세트가 수정 되면 &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d6f544e9f4637d730c544f2df049efe3bc2241c9" translate="yes" xml:space="preserve">
          <source>If the signs of arguments are unknown and a positive modulus is needed it can be computed as &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt;.</source>
          <target state="translated">인수의 부호를 알 수없고 양의 계수가 필요한 경우 &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt; 로 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d63f4df1fec01d153e077a0cd492720daea9604" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the quotient is negative and &lt;code&gt;floorDiv&lt;/code&gt; returns the integer less than or equal to the quotient and the &lt;code&gt;/&lt;/code&gt; operator returns the integer closest to zero.</source>
          <target state="translated">인수의 부호가 다른 경우 몫은 음수이고 &lt;code&gt;floorDiv&lt;/code&gt; 는 몫 보다 작거나 같은 정수를 반환하고 &lt;code&gt;/&lt;/code&gt; 연산자는 0에 가장 가까운 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b3eddbc3f191c883b4734fcd232862a579d8785" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the results differ from the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">인수의 부호가 다른 경우 결과는 &lt;code&gt;%&lt;/code&gt; 연산자 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8893f46ae7c980fbb6e68ff03e7cfa2f4485e10e" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorDiv&lt;/code&gt; and the &lt;code&gt;/&lt;/code&gt; operator are the same.</source>
          <target state="translated">인수의 부호가 동일하면 &lt;code&gt;floorDiv&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 연산자 의 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e7d5446141374acaa0bf3d68df3adaaf0963a7c6" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorMod&lt;/code&gt; and the &lt;code&gt;%&lt;/code&gt; operator are the same.</source>
          <target state="translated">인수의 부호가 동일하면 &lt;code&gt;floorMod&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자 의 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7c0c3191c882ae94e067ec4dbb9ae1efa5c18a6b" translate="yes" xml:space="preserve">
          <source>If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased. Increasing the number of buckets (&quot;rehashing&quot;) may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size. On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage.</source>
          <target state="translated">맵 크기 (키-값 매핑 수)가 예상 최대 크기를 충분히 초과하면 버킷 수가 늘어납니다. 버킷 수를 늘리면 ( &quot;리 해싱&quot;) 비용이 상당히 많이들 수 있으므로 예상되는 최대 크기가 충분히 큰 ID 해시 맵을 만드는 데 비용이 듭니다. 반면 컬렉션 뷰에 대한 반복에는 해시 테이블의 버킷 수에 비례 한 시간이 필요하므로 반복 성능이나 메모리 사용과 관련하여 예상되는 최대 크기를 너무 높게 설정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="49af0f5d2c34bab8d6d7bf3a55a636eed438a349" translate="yes" xml:space="preserve">
          <source>If the smaller index is outside the list's range of cells, this method returns &lt;code&gt;null&lt;/code&gt;. If the smaller index is valid, but the larger index is outside the list's range, the bounds of just the first index is returned. Otherwise, the bounds of the valid range is returned.</source>
          <target state="translated">더 작은 인덱스가 목록의 셀 범위 밖에 있으면이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 더 작은 인덱스가 유효하지만 더 큰 인덱스가 목록의 범위를 벗어난 경우 첫 번째 인덱스의 경계 만 반환됩니다. 그렇지 않으면 유효한 범위의 경계가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b48f7eb14ba4fe0ba8d12278087b9bd58de5fe30" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우이 메서드는 계속해서 반환합니다. &lt;code&gt;true&lt;/code&gt; 소켓이 닫힌 후에도 true 합니다 .</target>
        </trans-unit>
        <trans-unit id="c08afa2dd83781248a8b6598b34ddd6bd609cd7b" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the address of the endpoint after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 끝점의 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ef9dc97922014b6a635ad3f24d3c2f309797f78" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local address after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 계속해서 로컬 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="795364986502a26fa06bf27ac780aeadecd43628" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 계속해서 로컬 포트 ​​번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22d427b6f3e432eb55922847295296fb762a16b8" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ca2d090f17022dd5e73b01197f1d6848c079ffd" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓을 닫은 후에도 계속 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="59679157176f257978bbe9def3e0740bb5fb205a" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the address of the endpoint after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 엔드 포인트의 주소를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e21984f9cc07335c38e61e8524fe85a27b1d410" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local address after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 로컬 주소를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="763b9cd171c3cff366fd68dad3b49caafc1fe527" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 포트 번호를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd6141b5241054244025e22ff3d73a0248d5fc8c" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후에도 로컬 포트 ​​번호를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6e9dae5be20db8da3e58f51cd7b51d1fb85b6fbf" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 되었다면 이 메서드는 계속해서 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 소켓이 닫힌 후에도 .</target>
        </trans-unit>
        <trans-unit id="917ebef9402f85a9edd81896ca3483affe543bd7" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 되었다면 이 메서드는 소켓이 닫힌 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1204ee019c4cde4f66441dc7934326b11df3ec43" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 되었다면 이 메서드는 소켓이 닫힌 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fc8e1670126679859d5c660bcdcb0e5c4dce29e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결된 경우 소켓이 닫힌 후에도이 메소드는 계속 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="eded3cce47a4f9690c31a1eee5141c639e63658a" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3d182eb3854cd39ce3f790ae76cf8abf4ec7f3e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac6a556c1933db902b091802b19407a613fc41d9" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abfab3eeb26c13c0835e0da8c32c95bf0e46c4ed" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca2d424b7fdfc2a79a2dfc6c0453d110b7859bc0" translate="yes" xml:space="preserve">
          <source>If the source is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard input of a subprocess can be written to using the output stream returned by &lt;a href=&quot;process#getOutputStream()&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt;. If the source is set to any other value, then &lt;a href=&quot;process#getOutputStream()&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">소스가 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값)이면 &lt;a href=&quot;process#getOutputStream()&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 반환 된 출력 스트림을 사용하여 하위 프로세스의 표준 입력을 쓸 수 있습니다 . 소스가 다른 값으로 설정된 경우 &lt;a href=&quot;process#getOutputStream()&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-input&quot;&gt;null 출력 스트림을&lt;/a&gt; 반환 합니다. .</target>
        </trans-unit>
        <trans-unit id="c74e08fa061f46bcfc74bd1ceb1c899db939f1d9" translate="yes" xml:space="preserve">
          <source>If the source is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard input of a subprocess can be written to using the output stream returned by &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt;. If the source is set to any other value, then &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">소스가 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 리턴 한 출력 스트림을 사용하여 서브 프로세스의 표준 입력을 쓸 수 있습니다 . 소스가 다른 값으로 설정되면 &lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-input&quot;&gt;null 출력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="f6c84516f9aebb90d613c9f7eb26a5e9fd1dca09" translate="yes" xml:space="preserve">
          <source>If the source is a BufferedImage with premultiplied alpha, the color components are divided by the alpha component before color conversion. If the destination is a BufferedImage with premultiplied alpha, the color components are multiplied by the alpha component after conversion. Rasters are treated as having no alpha channel, i.e. all bands are color bands.</source>
          <target state="translated">소스가 알파가 미리 곱해진 BufferedImage 인 경우 색상 구성 요소는 색상 변환 전에 알파 구성 요소로 나뉩니다. 대상이 알파가 미리 곱해진 BufferedImage 인 경우 변환 후 색상 구성 요소에 알파 구성 요소가 곱해집니다. 래스터는 알파 채널이없는 것으로 처리됩니다. 즉, 모든 밴드는 색상 밴드입니다.</target>
        </trans-unit>
        <trans-unit id="1c6d739298af4f4dfdbeb07ff847cfc9d3c6a7a7" translate="yes" xml:space="preserve">
          <source>If the source of the PropertyChangeEvent &lt;code&gt;e&lt;/code&gt; equals the optionPane and is one of the ICON_PROPERTY, MESSAGE_PROPERTY, OPTIONS_PROPERTY or INITIAL_VALUE_PROPERTY, validateComponent is invoked.</source>
          <target state="translated">PropertyChangeEvent &lt;code&gt;e&lt;/code&gt; 의 소스가 optionPane과 같고 ICON_PROPERTY, MESSAGE_PROPERTY, OPTIONS_PROPERTY 또는 INITIAL_VALUE_PROPERTY 중 하나이면 validateComponent가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="661f6402b0c9208e67543bc3982626f5f2502c0a" translate="yes" xml:space="preserve">
          <source>If the source of the notification is a reference to an MBean object, the MBean server will replace it by that MBean's ObjectName. Otherwise the source is unchanged.</source>
          <target state="translated">통지의 소스가 MBean 객체에의 참조 인 경우, MBean 서버는 그것을 MBean의 ObjectName로 교체합니다. 그렇지 않으면 소스가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc0afb74deac5658d35d1df20daa373ddaf8091c" translate="yes" xml:space="preserve">
          <source>If the spec's path component begins with a slash character &quot;/&quot; then the path is treated as absolute and the spec path replaces the context path.</source>
          <target state="translated">스펙의 경로 구성 요소가 슬래시 문자 &quot;/&quot;로 시작하면 경로는 절대 경로로 취급되고 스펙 경로는 컨텍스트 경로를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="9a4f4b68138d4550ce0ad6e021c29ead94a8e3ad" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the data transfer subsystem and the data transfer subsystem is unable to translate this &lt;code&gt;DataFlavor&lt;/code&gt; to any existing native, then invoking this method will establish a mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt; and an encoded version of its MIME type as its native.</source>
          <target state="translated">지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 가 이전에 데이터 전송 하위 시스템에 알려지지 않았고 데이터 전송 하위 시스템이이 &lt;code&gt;DataFlavor&lt;/code&gt; 를 기존 네이티브 로 변환 할 수없는 경우이 메서드를 호출하면 지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 와 해당 MIME의 인코딩 된 버전 간에 양방향 매핑이 설정됩니다. 네이티브로 입력합니다.</target>
        </trans-unit>
        <trans-unit id="ec28138e6077c419b066b58918bda314e27771f9" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;locale&lt;/code&gt; contains &quot;cu&quot; and/or &quot;rg&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the instance returned from this method reflects the values specified with those extensions. If both &quot;cu&quot; and &quot;rg&quot; are specified, the currency from the &quot;cu&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">지정된 &lt;code&gt;locale&lt;/code&gt; 에 &quot;cu&quot;및 / 또는 &quot;rg&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우이 메서드에서 반환 된 인스턴스는 해당 확장으로 지정된 값을 반영합니다. &quot;cu&quot;와 &quot;rg&quot;가 모두 지정되면 &quot;cu&quot;확장의 통화가 &quot;rg&quot;확장의 암시 적 통화를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e385849f938ca3e361afb2eab43ee21415cbd43e" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;locale&lt;/code&gt; contains &quot;rg&quot; (region override) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbol returned from this method reflects the value specified with that extension.</source>
          <target state="translated">지정된 &lt;code&gt;locale&lt;/code&gt; 에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우이 메서드에서 반환 된 기호는 해당 확장으로 지정된 값을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="257aba8bf323b9c1c989b22a9946ac7416be5538" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;name&lt;/code&gt; begins with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, it can only be defined by the &lt;a href=&quot;#getPlatformClassLoader()&quot;&gt;platform class loader&lt;/a&gt; or its ancestors; otherwise &lt;code&gt;SecurityException&lt;/code&gt; will be thrown. If &lt;code&gt;name&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be equal to the &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class specified by the byte array &lt;code&gt;b&lt;/code&gt;, otherwise a &lt;a href=&quot;noclassdeffounderror&quot;&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">지정된 &lt;code&gt;name&lt;/code&gt; 이 &quot; &lt;code&gt;java.&lt;/code&gt; &quot;로 시작 하는 경우 &lt;a href=&quot;#getPlatformClassLoader()&quot;&gt;플랫폼 클래스 로더&lt;/a&gt; 또는 해당 조상에 의해서만 정의 될 수 있습니다 . 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다. 경우 &lt;code&gt;name&lt;/code&gt; 없는 &lt;code&gt;null&lt;/code&gt; , 상기 동일해야 &lt;a href=&quot;#binary-name&quot;&gt;진 이름&lt;/a&gt; 바이트 배열에 의해 특정 클래스 &lt;code&gt;b&lt;/code&gt; 달리, &lt;a href=&quot;noclassdeffounderror&quot;&gt; &lt;code&gt;NoClassDefFoundError&lt;/code&gt; &lt;/a&gt; 발생한다.</target>
        </trans-unit>
        <trans-unit id="97c03df7f79f779f19dbd94c565abdfcc104d7ca" translate="yes" xml:space="preserve">
          <source>If the specified IP address is bound to multiple network interfaces it is not defined which network interface is returned.</source>
          <target state="translated">지정된 IP 주소가 여러 네트워크 인터페이스에 바인딩 된 경우 어떤 네트워크 인터페이스가 반환되는지 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c68f935629df479cecc1daf2323805432c7c1f" translate="yes" xml:space="preserve">
          <source>If the specified amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must have the same chronology as this period. Implementations may choose to accept or reject other &lt;code&gt;TemporalAmount&lt;/code&gt; implementations.</source>
          <target state="translated">지정된 금액이 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인 경우이 기간과 동일한 연대기를 가져야합니다. 구현시 다른 &lt;code&gt;TemporalAmount&lt;/code&gt; 구현 을 수락하거나 거부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09cff20bf42b9ad1e7365bfddfe3a021913c702f" translate="yes" xml:space="preserve">
          <source>If the specified calendar doesn't support week dates, the &lt;a href=&quot;#build()&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method will throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 달력이 주 날짜를 지원하지 않는 경우 &lt;a href=&quot;#build()&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="aeb138890341e49f448dcdb19a0436d6eccb12fa" translate="yes" xml:space="preserve">
          <source>If the specified calendar doesn't support week dates, the &lt;a href=&quot;calendar.builder#build--&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method will throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 달력이 주 날짜를 지원하지 않는 경우, &lt;a href=&quot;calendar.builder#build--&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="21d5a2365b7e2ef9cdf719d377a83491e9b996d8" translate="yes" xml:space="preserve">
          <source>If the specified comment is &lt;code&gt;null&lt;/code&gt; then no comment will be stored in the document.</source>
          <target state="translated">지정된 주석이 &lt;code&gt;null&lt;/code&gt; 이면 주석이 문서에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c00aef2c14db555263f047e1c32a11c40196454" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">지정된 비교자가 &lt;code&gt;null&lt;/code&gt; 인 경우, 이 목록의 모든 요소는 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야 하며 요소의 &lt;a href=&quot;../../lang/comparable&quot;&gt;자연 순서를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aefe2d484ac87a9f75945af0a56cb6b62891cb32" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">지정된 비교자가 &lt;code&gt;null&lt;/code&gt; 인 경우, 이 목록의 모든 요소는 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야 하며 요소의 &lt;a href=&quot;../lang/comparable&quot;&gt;자연 순서를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a543a9a4c58a21fee89ee30e3c66f4521a79acb" translate="yes" xml:space="preserve">
          <source>If the specified component is already a child of this then we don't bother doing anything - stacking order doesn't matter for cell renderer components (CellRendererPane doesn't paint anyway).</source>
          <target state="translated">지정된 구성 요소가 이미 이것의 자식이면 아무 작업도 수행하지 않습니다. 스택 순서는 셀 렌더러 구성 요소에 대해 중요하지 않습니다 (CellRendererPane은 어쨌든 페인트하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="1142a4e571e7e45e0126c1fa376f4b7549ff134a" translate="yes" xml:space="preserve">
          <source>If the specified date-time has already passed, the job must be a candidate for processing immediately. Thus, one way to make the job immediately become a candidate for processing is to specify a &lt;code&gt;JobHoldUntil&lt;/code&gt; attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT):</source>
          <target state="translated">지정된 날짜-시간이 이미 지난 경우 작업은 즉시 처리 할 후보 여야합니다. 따라서 작업을 즉시 처리 후보로 만드는 한 가지 방법은 다음 과 같이 구성된 &lt;code&gt;JobHoldUntil&lt;/code&gt; 속성 을 지정하는 것입니다 (1970 년 1 월 1 일, 00:00:00 GMT를 나타냄).</target>
        </trans-unit>
        <trans-unit id="e90b9efbdd73e57fac8cf7dcbd6a9324c80a3a89" translate="yes" xml:space="preserve">
          <source>If the specified date-time has already passed, the job must be a candidate for processing immediately. Thus, one way to make the job immediately become a candidate for processing is to specify a JobHoldUntil attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT):</source>
          <target state="translated">지정된 날짜-시간이 이미 지난 경우 작업은 즉시 처리 할 수 ​​있어야합니다. 따라서 작업을 즉시 처리 후보로 만드는 한 가지 방법은 다음과 같이 구성된 JobHoldUntil 속성을 지정하는 것입니다 (1970 년 1 월 1 일 00:00:00 GMT 표시).</target>
        </trans-unit>
        <trans-unit id="7cc62287dac9dd3318ff0227906bfc56c107c2f1" translate="yes" xml:space="preserve">
          <source>If the specified driver is not found in the list of registered drivers, then no action is taken. If the driver was found, it will be removed from the list of registered drivers.</source>
          <target state="translated">지정된 드라이버가 등록 된 드라이버 목록에 없으면 아무 조치도 취하지 않습니다. 드라이버가 발견되면 등록 된 드라이버 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9579f0c52418214efdc0671f46a3ff5e4527ea42" translate="yes" xml:space="preserve">
          <source>If the specified field is present, this method returns a non-null non-negative &lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object that represents its value. If it is not present, return null. For YEARS, MONTHS, DAYS, HOURS, and MINUTES, this method returns a &lt;a href=&quot;../../../../java.base/java/math/biginteger&quot;&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/a&gt; object. For SECONDS, this method returns a &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 필드가있는 경우이 메서드는 해당 값을 나타내는 Null이 아닌 음수가 아닌 &lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 개체를 반환 합니다. 존재하지 않으면 null을 반환합니다. YEARS, MONTHS, DAYS, HOURS 및 MINUTES의 경우이 메서드는 &lt;a href=&quot;../../../../java.base/java/math/biginteger&quot;&gt; &lt;code&gt;BigInteger&lt;/code&gt; &lt;/a&gt; 개체를 반환 합니다. SECONDS의 경우이 메서드는 &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab27614aa1a1e159b8f3228af15f24fff13239ec" translate="yes" xml:space="preserve">
          <source>If the specified file is a directory, the file manager of the current platform is launched to open it.</source>
          <target state="translated">지정된 파일이 디렉토리이면 현재 플랫폼의 파일 관리자가 실행되어 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="6ddc595a62cbea355de55b31675b042692a29bee" translate="yes" xml:space="preserve">
          <source>If the specified host is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as &lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt;&lt;code&gt;InetAddress.getByName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(null)&lt;/code&gt;. In other words, it is equivalent to specifying an address of the loopback interface.</source>
          <target state="translated">지정된 호스트가 &lt;code&gt;null&lt;/code&gt; 인 경우 주소를 &lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt; &lt;code&gt;InetAddress.getByName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(null)&lt;/code&gt; 으로 지정하는 것과 동일 합니다. 즉, 루프백 인터페이스의 주소를 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2496623a004f15dd4819ee54aa8493f7e338eba3" translate="yes" xml:space="preserve">
          <source>If the specified host is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt;&lt;code&gt;InetAddress.getByName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(null)&lt;/code&gt;. In other words, it is equivalent to specifying an address of the loopback interface.</source>
          <target state="translated">지정된 호스트가 &lt;code&gt;null&lt;/code&gt; 의 경우, 주소를 &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt; &lt;code&gt;InetAddress.getByName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(null)&lt;/code&gt; 로 지정하는 것과 같습니다 . 즉, 루프백 인터페이스의 주소를 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c33d8531f7d2499b880c450b0b37d9ef3fa77c82" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a (non-null) value, associates it with the given value.</source>
          <target state="translated">지정된 키가 (null이 아닌) 값과 아직 연결되지 않은 경우 지정된 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="900d04445ca5a80f48077470ed1101681577ef82" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.</source>
          <target state="translated">지정된 키가 (널이 아닌) 값과 아직 연결되지 않은 경우 지정된 값과 연결합니다. 그렇지 않으면, 값을 제공된 다시 매핑 함수의 결과로 바꾸거나 if &lt;code&gt;null&lt;/code&gt; 을 제거합니다 . 전체 메소드 호출은 원자 적으로 수행됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 단순해야하며이 맵의 다른 매핑을 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="327e72df9ef84db72836c87a15ef8d4fb475f995" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;) associates it with the given value and returns &lt;code&gt;null&lt;/code&gt;, else returns the current value.</source>
          <target state="translated">지정된 키가 값과 아직 연결되어 있지 않거나 &lt;code&gt;null&lt;/code&gt; 에 매핑 된 경우 해당 키를 지정된 값과 연결하고 &lt;code&gt;null&lt;/code&gt; 을 반환하면 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b0beef1230b8f936ac0be883b146508d29a805b" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;), attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 키가 값에 아직 연결되어 있지 않은 경우 (또는 &lt;code&gt;null&lt;/code&gt; 에 매핑 된 경우) 지정된 매핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 .</target>
        </trans-unit>
        <trans-unit id="59de12c4feb8699041392433808d90a4be2dd1b8" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.</source>
          <target state="translated">지정된 키가 아직 값과 연결되어 있지 않거나 null과 연결되어있는 경우 해당 키를 지정된 null이 아닌 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="50fe8f5b029680a754d045deccf54d554f1ecb50" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is &lt;code&gt;null&lt;/code&gt;. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a &lt;code&gt;String msg&lt;/code&gt; to a value mapping:</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않았거나 널과 연관되어 있으면 제공된 널이 아닌 값과 연관시킵니다. 그렇지 않으면 관련 값을 지정된 다시 매핑 기능의 결과로 바꾸거나 결과가 다음과 같은 경우 제거합니다. &lt;code&gt;null&lt;/code&gt; 인 . 이 방법은 키에 대해 여러 개의 매핑 된 값을 결합 할 때 사용할 수 있습니다. 예를 들어, &lt;code&gt;String msg&lt;/code&gt; 를 작성하거나 값 맵핑에 추가 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ec2236aaf5d6e4455671d55125f8980e4fa9768d" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given value.</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않았거나 null과 연결되어 있으면 지정된 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="07aab8862177972b392beb8f0bf5c9cd52e38ac3" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않았거나 널과 연관되어 있으면 주어진 값과 연관시킵니다. 그렇지 않으면 값을 지정된 다시 매핑 함수의 결과로 바꾸거나 결과가 null 인 경우 제거합니다. 이 방법은 키에 대해 여러 개의 매핑 된 값을 결합 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4925c79cda2f9aaf0050cbbfb1bd9cb1cde5984" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associate it with the given value. This is equivalent to</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 지정된 값과 연관 시키십시오. 이것은</target>
        </trans-unit>
        <trans-unit id="d4876e55c0474ed2aee75208b622ba1f147600e9" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value.</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않은 경우 지정된 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="df5a13cc298f2e36b4088599af2bf52a36c46112" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 지정된 값과 연관시킵니다. 그렇지 않으면, 값을 제공된 다시 매핑 함수의 결과로 바꾸거나 if &lt;code&gt;null&lt;/code&gt; 을 제거합니다 . 이 기능은 원자 적으로 한 번만 적용되는 것은 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e0e2aa4c62a637c17a37f4738b005d30fd80554c" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value. This is equivalent to, for this &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않은 경우 지정된 값과 연결합니다. 이 &lt;code&gt;map&lt;/code&gt; 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6107b4d5266bf408264e8a734eb446c3449b2b14" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않은 경우 지정된 매핑 함수를 사용하여 값을 계산하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 .</target>
        </trans-unit>
        <trans-unit id="551c906c1bb44aa217c725bb3e6835b67419ea34" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 제공된 맵핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 . 전체 메소드 호출은 원자 적으로 수행되므로 함수는 키당 최대 한 번 적용됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 단순해야하며이 맵의 다른 매핑을 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="199aa69d5cf4c4d157c5d05ec7094035a1890fc8" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only if the value is not present.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 제공된 맵핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 . 함수가된다 &lt;em&gt;NOT&lt;/em&gt; 한번 원자 적 가치가 존재하지 않는 경우에만 적용 보장.</target>
        </trans-unit>
        <trans-unit id="ac522be26b00567361a746d74b58f7524d15d7ee" translate="yes" xml:space="preserve">
          <source>If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to &lt;a href=&quot;locale.builder#setLanguageTag(java.lang.String)&quot;&gt;&lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; which throws an exception in this case.</source>
          <target state="translated">지정된 언어 태그에 형식이 잘못된 하위 태그가 포함 된 경우 이러한 첫 번째 하위 태그와 모든 후속 하위 태그는 무시됩니다. 이 경우 예외를 발생시키는 &lt;a href=&quot;locale.builder#setLanguageTag(java.lang.String)&quot;&gt; &lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="74ec46a56735923288ea9182f5be9a7235b7c574" translate="yes" xml:space="preserve">
          <source>If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; which throws an exception in this case.</source>
          <target state="translated">지정된 언어 태그에 잘못된 형식의 하위 태그가 포함 된 경우 첫 번째 하위 태그와 다음 하위 태그는 모두 무시됩니다. 이 경우 예외를 발생시키는 &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="495384335ab36e262e909f5285ee42e18f9010ef" translate="yes" xml:space="preserve">
          <source>If the specified list is small or implements the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the &lt;code&gt;RandomAccess&lt;/code&gt; interface, this implementation breaks the list into two sublist views around index &lt;code&gt;-distance mod size&lt;/code&gt;. Then the &lt;a href=&quot;#reverse(java.util.List)&quot;&gt;&lt;code&gt;reverse(List)&lt;/code&gt;&lt;/a&gt; method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's</source>
          <target state="translated">지정된 목록이 작거나 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 경우이 구현은 첫 번째 요소를 이동해야하는 위치로 교환 한 다음 대체 된 요소가 첫 번째 요소로 교체 될 때까지 이동해야하는 위치로 대체 된 요소를 반복적으로 교환합니다. 필요한 경우 회전이 완료 될 때까지 두 번째 및 연속 요소에서 프로세스가 반복됩니다. 지정된 목록이 크고 &lt;code&gt;RandomAccess&lt;/code&gt; 인터페이스를 구현하지 않는 경우이 구현은 목록을 index- &lt;code&gt;-distance mod size&lt;/code&gt; 주위의 두 개의 하위 목록보기로 나눕니다 . 그런 다음 &lt;a href=&quot;#reverse(java.util.List)&quot;&gt; &lt;code&gt;reverse(List)&lt;/code&gt; &lt;/a&gt;메서드는 각 하위 목록보기에서 호출되고 마지막으로 전체 목록에서 호출됩니다. 두 알고리즘에 대한 자세한 설명은 Jon Bentley의 섹션 2.3을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="29e16cfca3f81f7f2c484ea21572aa935aba3557" translate="yes" xml:space="preserve">
          <source>If the specified list is small or implements the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the &lt;code&gt;RandomAccess&lt;/code&gt; interface, this implementation breaks the list into two sublist views around index &lt;code&gt;-distance mod size&lt;/code&gt;. Then the &lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt;&lt;code&gt;reverse(List)&lt;/code&gt;&lt;/a&gt; method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's</source>
          <target state="translated">지정된리스트가 작거나 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 경우 ,이 구현은 첫 번째 요소를 이동해야하는 위치로 교환 한 다음, 대체 된 요소를 이동 된 요소가 첫 번째 요소로 교체 될 때까지 이동해야하는 위치로 반복적으로 교환합니다. 필요한 경우 회전이 완료 될 때까지 두 번째 및 연속 요소에서 프로세스가 반복됩니다. 지정된리스트가 크고 &lt;code&gt;RandomAccess&lt;/code&gt; 인터페이스를 구현하지 않는 경우 ,이 구현은리스트를 index- &lt;code&gt;-distance mod size&lt;/code&gt; 주위의 두 개의 서브 리스트보기로 나눕니다 . 그런 다음 &lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt; &lt;code&gt;reverse(List)&lt;/code&gt; &lt;/a&gt;메소드는 각 서브리스트보기에서 호출되고 마지막으로 전체 목록에서 호출됩니다. 두 알고리즘에 대한 자세한 설명은 Jon Bentley 's 2.3 단원을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a34d2ff62cb9dee92bc87d570b5cda8f97027ea5" translate="yes" xml:space="preserve">
          <source>If the specified local address is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as the AnyLocal address (see &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">지정된 로컬 주소가 &lt;code&gt;null&lt;/code&gt; 이면 주소를 AnyLocal 주소로 지정하는 것과 동일합니다 ( &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e207478f4c307f8daec04a1eb43edfa1b56c4337" translate="yes" xml:space="preserve">
          <source>If the specified local address is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as the AnyLocal address (see &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">지정된 로컬 주소가 &lt;code&gt;null&lt;/code&gt; 인 경우 주소를 AnyLocal 주소로 지정하는 것과 같습니다 ( &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e20d600ab6dd5dfc2718408c731259b979d97003" translate="yes" xml:space="preserve">
          <source>If the specified locale contains &quot;ca&quot; (calendar), &quot;rg&quot; (region override), and/or &quot;tz&quot; (timezone) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the calendar, the country and/or the time zone for formatting are overridden. If both &quot;ca&quot; and &quot;rg&quot; are specified, the calendar from the &quot;ca&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">지정된 로케일에 &quot;ca&quot;(캘린더), &quot;rg&quot;(지역 재정의) 및 / 또는 &quot;tz&quot;(시간대) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우 달력, 국가 및 / 또는 서식 지정을위한 표준 시간대가 재정의됩니다. &quot;ca&quot;와 &quot;rg&quot;가 모두 지정되면 &quot;ca&quot;확장의 달력이 &quot;rg&quot;확장의 암시 적 달력을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3bb4277707fb1b363f377904ef8a00ae80162edc" translate="yes" xml:space="preserve">
          <source>If the specified name is already in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">지정된 이름이 이미 사용 가능한 속성 이름 목록에 있으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fdd0b3e89e1f58df16acb73daa9598c19a8c783" translate="yes" xml:space="preserve">
          <source>If the specified name is not in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">지정된 이름이 사용 가능한 속성 이름 목록에 없으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="06d84325d01c60c6779f1c995e33cf0b305c715d" translate="yes" xml:space="preserve">
          <source>If the specified native is not a properly encoded native and the mappings for this native have not been altered with &lt;code&gt;setFlavorsForNative&lt;/code&gt;, then the contents of the &lt;code&gt;List&lt;/code&gt; is platform dependent, but &lt;code&gt;null&lt;/code&gt; cannot be returned.</source>
          <target state="translated">지정된 네이티브가 적절하게 인코딩 된 네이티브가 &lt;code&gt;setFlavorsForNative&lt;/code&gt; 네이티브에 대한 매핑이 setFlavorsForNative 로 변경되지 않은 경우 &lt;code&gt;List&lt;/code&gt; 의 콘텐츠 는 플랫폼에 따라 다르지만 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25d850bc5c8154fd5a609c44324b0fd903372382" translate="yes" xml:space="preserve">
          <source>If the specified native is previously unknown to the data transfer subsystem, and that native has been properly encoded, then invoking this method will establish a mapping in both directions between the specified native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded version of the native.</source>
          <target state="translated">지정된 네이티브가 이전에 데이터 전송 하위 시스템에 알려지지 않았고 해당 네이티브가 적절하게 인코딩 된 경우이 메서드를 호출하면 지정된 네이티브와 MIME 유형이 네이티브의 디코딩 된 버전 인 &lt;code&gt;DataFlavor&lt;/code&gt; 간의 양방향 매핑이 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="92b923f20f66bacef4d2ff1b575298d2082a6d3b" translate="yes" xml:space="preserve">
          <source>If the specified object is an instance of &lt;code&gt;Throwable&lt;/code&gt;, it becomes the</source>
          <target state="translated">지정된 객체가 &lt;code&gt;Throwable&lt;/code&gt; 의 인스턴스 인 경우는</target>
        </trans-unit>
        <trans-unit id="f07c1a027ba244740b1e94181579aafe6b9799f7" translate="yes" xml:space="preserve">
          <source>If the specified prefix is already in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">지정된 접두사가 이미 사용 가능한 알림 유형 목록에있는 경우이 방법은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35c19bfb0ddf95e53e5300c7d5d437ccd663d657" translate="yes" xml:space="preserve">
          <source>If the specified prefix is not in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">지정된 접두사가 사용 가능한 알림 유형 목록에없는 경우이 방법은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f43c50810daae04d0ace6639274dabc1168944f9" translate="yes" xml:space="preserve">
          <source>If the specified property is not defined for a particular file format, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 속성이 특정 파일 형식에 대해 정의되어 있지 않으면이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0dde80edd4786d58af9002dd456373854e678d38" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or cannot be parsed as an integer then the &lt;code&gt;Color&lt;/code&gt; specified by the second argument is returned instead.</source>
          <target state="translated">지정된 속성을 찾을 수 없거나 정수로 구문 분석 할 수없는 경우 두 번째 인수로 지정된 &lt;code&gt;Color&lt;/code&gt; 가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bdabf1d6b2382f70866806891245d3b01a4f4527" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or could not be parsed as an integer then &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 속성을 찾을 수 없거나 정수로 구문 분석 할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d802140ffd78fd804cf7b1fd2b7295c7e5afc88" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or could not be parsed as an integer then the integer value &lt;code&gt;v&lt;/code&gt; is used instead, and is converted to a &lt;code&gt;Color&lt;/code&gt; object.</source>
          <target state="translated">지정된 속성을 찾을 수 없거나 정수로 구문 분석 할 수없는 경우 정수 값 &lt;code&gt;v&lt;/code&gt; 가 대신 사용되며 &lt;code&gt;Color&lt;/code&gt; 개체 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4834c64d62740309c88f771524fdcb223e3fc7b" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a &lt;code&gt;DOMString&lt;/code&gt;.</source>
          <target state="translated">지정된 텍스트 범위가 &lt;code&gt;DOMString&lt;/code&gt; 에 맞지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="caa74ec04f197f8793bb6217e9a34e0badeccd71" translate="yes" xml:space="preserve">
          <source>If the specified system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the DOM implementation will attempt to resolve the relative URI with the &lt;code&gt;baseURI&lt;/code&gt; as the base, if that fails, the behavior is implementation dependent.</source>
          <target state="translated">지정된 시스템 ID가 상대 URI 참조 ([ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]의 섹션 5 참조 ) 인 경우 DOM 구현은 &lt;code&gt;baseURI&lt;/code&gt; 를 기준으로하는 상대 URI를 확인하려고 시도 합니다. 실패하면 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1954d35e1a8126307e2b4392ca7004d2cfa54884" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then &lt;a href=&quot;timeoutexception&quot;&gt;&lt;code&gt;TimeoutException&lt;/code&gt;&lt;/a&gt; is thrown. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;a href=&quot;timeoutexception&quot;&gt; &lt;code&gt;TimeoutException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="310c63f9de70d34cca02c16171cb0b3c368911f0" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bdd6bad6b7c4c04adc8addbdd6baac39622961b" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 반환됩니다. 시간이 0보다 작거나 같으면 메서드는 전혀 기다리지 않습니다. 이 스레드에 할당 될 모든 허가는 마치 &lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출로 허가를 사용할 수있는 것처럼 허가를 얻으려는 다른 스레드에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="229ff9ac1c41d305f35a7c0608935889e0aaec6b" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다. 이 스레드에 할당 된 모든 허가는 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출에 의해 허용 된 것처럼 허가를 획득하려는 다른 스레드에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d2fa8250cbec1b974164fdd92ff3bc201feb96b" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect other than validating its argument.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 추적이 &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;쓰기 가능하지 않은&lt;/a&gt; 경우이 메서드를 호출해도 인수를 확인하는 것 외에 다른 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d793547d8065207a7a2a3b64f74bfbae2f70956" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 추적이 &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;쓰기 가능하지 않은&lt;/a&gt; 경우이 메서드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3dda73785392b01747ad72630377e93ff7ebd123" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect other than validating its argument.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 트레이스가 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;쓰기 가능하지 않은 경우&lt;/a&gt; ,이 메소드를 호출해도 인수의 유효성을 검사하는 것 외에 다른 효과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f140d470f07fad292b66fc6ee306ae6d2a54ab2a" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 트레이스가 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;쓰기 가능하지 않은 경우&lt;/a&gt; ,이 메소드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a0c7fbb44b44d8e097852c8b27b45e37f7b8b9c" translate="yes" xml:space="preserve">
          <source>If the standard error of the process has been redirected using &lt;a href=&quot;processbuilder#redirectError(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;processbuilder#redirectErrorStream(boolean)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder#redirectError(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;processbuilder#redirectErrorStream(boolean)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt; &lt;/a&gt; 을 사용하여 프로세스의 표준 오류가 리디렉션 된 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="077ba9a63c85f3c79b6472adbd6bd273ed829948" translate="yes" xml:space="preserve">
          <source>If the standard error of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt; &lt;/a&gt; 을 사용하여 하위 프로세스의 표준 오류를 리디렉션 한 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="68b1b68d307d6ca1fc6a760c2ae878282f015b92" translate="yes" xml:space="preserve">
          <source>If the standard input of the process has been redirected using &lt;a href=&quot;processbuilder#redirectInput(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">프로세스의 표준 입력 이 &lt;a href=&quot;processbuilder#redirectInput(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt; &lt;/a&gt; 을 사용하여 리디렉션 된 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null 출력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="86430b03fbc71403519b5c3b7220021c3f6618a7" translate="yes" xml:space="preserve">
          <source>If the standard input of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스의 표준 입력 이 &lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt; &lt;/a&gt; 을 사용하여 경로 재 지정된 경우이 메소드는 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;널 출력 스트림을&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="3193a3f874d9883f06995425c57bb9f49f95c498" translate="yes" xml:space="preserve">
          <source>If the standard output of the process has been redirected using &lt;a href=&quot;processbuilder#redirectOutput(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder#redirectOutput(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt; &lt;/a&gt; 을 사용하여 프로세스의 표준 출력이 리디렉션 된 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="7075f6432f67c8c99f417e3aed9f9abd4674447d" translate="yes" xml:space="preserve">
          <source>If the standard output of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스의 표준 출력 이 &lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt; &lt;/a&gt; 을 사용하여 경로 재 지정된 경우이 메소드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;널 입력 스트림을&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef7d1e9b0031ea83269d5adfbd99e3c687130e6f" translate="yes" xml:space="preserve">
          <source>If the state of this check box is &lt;code&gt;true&lt;/code&gt; and the new group already has a check box selected, this check box's state is changed to &lt;code&gt;false&lt;/code&gt;. If the state of this check box is &lt;code&gt;true&lt;/code&gt; and the new group has no check box selected, this check box becomes the selected checkbox for the new group and its state is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 확인란의 상태가 &lt;code&gt;true&lt;/code&gt; 이고 새 그룹에 이미 확인란이 선택되어 있으면이 확인란의 상태가 &lt;code&gt;false&lt;/code&gt; 로 변경됩니다 . 이 확인란의 상태가 &lt;code&gt;true&lt;/code&gt; 이고 새 그룹에 선택된 확인란이없는 경우이 확인란은 새 그룹에 대해 선택된 확인란이되고 상태는 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d366f3eb6bf9e4d636eed0b8ad01a318338322f7" translate="yes" xml:space="preserve">
          <source>If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it creates a datagram socket.</source>
          <target state="translated">stream 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 스트림 소켓이 작성됩니다. stream 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 데이터 그램 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="92109724254a6a952d63389232984fc4b39d101f" translate="yes" xml:space="preserve">
          <source>If the stream is parallel, and the &lt;code&gt;Collector&lt;/code&gt; is &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt;&lt;code&gt;concurrent&lt;/code&gt;&lt;/a&gt;, and either the stream is unordered or the collector is &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt;&lt;code&gt;unordered&lt;/code&gt;&lt;/a&gt;, then a concurrent reduction will be performed (see &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; for details on concurrent reduction.)</source>
          <target state="translated">스트림이 병렬이고 &lt;code&gt;Collector&lt;/code&gt; 가 &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt; &lt;code&gt;concurrent&lt;/code&gt; &lt;/a&gt; 이고 스트림이 정렬되지 않거나 수집기가 &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt; &lt;code&gt;unordered&lt;/code&gt; &lt;/a&gt; 경우 동시 축소가 수행됩니다 ( 동시 축소에 대한 자세한 내용 은 &lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="649cf82f464f662aa965403c73cf99d556fea581" translate="yes" xml:space="preserve">
          <source>If the subprocess has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">서브 프로세스가 이미 종료 된 경우이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 프로세스가 종료되지 않고 시간 종료 값이 0보다 작거나 같은 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1b0a8ba1234c9978531ae814a7cbb1dae0a3c230" translate="yes" xml:space="preserve">
          <source>If the superclass is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types. If this &lt;code&gt;Class&lt;/code&gt; represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the &lt;code&gt;Class&lt;/code&gt; object representing the &lt;code&gt;Object&lt;/code&gt; class is returned.</source>
          <target state="translated">수퍼 클래스가 매개 변수화 된 유형 인 경우, 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다. 슈퍼 클래스를 나타내는 매개 변수화 된 유형은 이전에 작성되지 않은 경우 작성됩니다. 매개 변수화 된 유형에 대한 작성 프로세스의 시맨틱에 대해서는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 선언을 참조하십시오 . 이 &lt;code&gt;Class&lt;/code&gt; 가 &lt;code&gt;Object&lt;/code&gt; 클래스, 인터페이스, 프리미티브 유형 또는 void를 나타내는 경우 널이 리턴됩니다. 이 객체가 배열 클래스를 나타내는 경우, &lt;code&gt;Object&lt;/code&gt; 클래스를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="702061aae71a7b0bc29035519b62837f0bf9ee3d" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains optional setting values not supported by this reader (</source>
          <target state="translated">제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에이 리더에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="a6062faf5608aab9b4601cbc2c84f0f96e088fa9" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not supported by this writer (</source>
          <target state="translated">제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 에이 라이터에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="e0ec08c9bcf3ded436efba803a4101d1da6386d3" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not understood by this writer or transcoder, they will be ignored.</source>
          <target state="translated">제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 에이 기록 기나 트랜스 코더가 이해할 수없는 선택적 설정 값이 포함되어 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="83332eaf39cb8bfd82ea83337e6eefff71ef19fb" translate="yes" xml:space="preserve">
          <source>If the support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use only the following standard button masks: &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt;.</source>
          <target state="translated">확장 마우스 버튼에 대한 지원 이 Java에 의해 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; 된 경우 다음 표준 버튼 마스크 만 사용할 수 있습니다. &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96b9d55f1b2271749505c66ce5e0fd46a6ed130f" translate="yes" xml:space="preserve">
          <source>If the support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use the standard button masks and masks for existing extended mouse buttons, if the mouse has more then three buttons. In that way, it is allowed to use the button masks corresponding to the buttons in the range from 1 to &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장 마우스 단추 지원이 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에 의해 된 경우 마우스에 3 개 이상의 버튼이있는 경우 기존 확장 마우스 버튼에 대한 표준 버튼 마스크 및 마스크를 사용할 수 있습니다. 이렇게하면 1부터 &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt; 까지의 범위에서 버튼에 해당하는 버튼 마스크를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c7431ea9b95b75172bde5cfc89a8c0841e0ed59" translate="yes" xml:space="preserve">
          <source>If the system ID is a URL, it will be fully resolved.</source>
          <target state="translated">시스템 ID가 URL이면 완전히 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5818c71edba95dbdcbbbe03f31b7344a7f8756" translate="yes" xml:space="preserve">
          <source>If the system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the behavior is implementation dependent.</source>
          <target state="translated">시스템 ID가 상대 URI 참조 인 경우 ([&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt; IETF RFC 2396&lt;/a&gt; ]의 ) 인 경우 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="11c8152472d911028fe75c0272d12bdc08e6d5e4" translate="yes" xml:space="preserve">
          <source>If the system does not support environment variables, an empty map is returned.</source>
          <target state="translated">시스템이 환경 변수를 지원하지 않으면 빈 맵이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="06f52e1b071eac0948a9acca87880e3e4138c05f" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it must be fully resolved (it may not be a relative URL).</source>
          <target state="translated">시스템 식별자가 URL 인 경우 완전히 확인되어야합니다 (상대 URL이 아닐 수도 있음).</target>
        </trans-unit>
        <trans-unit id="702582a6612c4020970698031381ca0b9cdc6250" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it must be fully resolved by the application before it is passed to the parser.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 파서로 전달되기 전에 응용 프로그램에서 완전히 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1141b9ff132e9f64996b3e44968c6f92596158e" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it will have been resolved fully.</source>
          <target state="translated">시스템 식별자가 URL이면 완전히 확인 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="69c62c9017d4450e514b7c2160989710e82b3ed0" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the SAX parser must resolve it fully before reporting it to the application.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 SAX 구문 분석기는 응용 프로그램에보고하기 전에이를 완전히 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="84493bb7e50a00814aa34c277d5716aea3301f50" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the parser must resolve it fully before passing it to the application.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 파서는 응용 프로그램에 전달하기 전에이를 완전히 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="63e187f8aea2b4eaa14f670a85e3ec3f6d417906" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the parser must resolve it fully before passing it to the application. For example, a file name must always be provided as a &lt;em&gt;file:...&lt;/em&gt; URL, and other kinds of relative URI are also resolved against their bases.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 파서는 응용 프로그램에 전달하기 전에이를 완전히 확인해야합니다. 예를 들어 파일 이름은 항상 파일로 제공되어야합니다 &lt;em&gt;....&lt;/em&gt; URL 하며 다른 종류의 상대 URI도 해당 기반에 대해 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="98fa5298bfbc9c3dc738e30b2cfbc794eda77505" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;java.system.class.loader&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.</source>
          <target state="translated">이 메소드가 처음 호출 될 때 시스템 특성 &quot; &lt;code&gt;java.system.class.loader&lt;/code&gt; &quot;가 정의 된 경우 해당 특성의 값은 시스템 클래스 로더로 리턴 될 클래스의 이름이됩니다. 클래스는 기본 시스템 클래스 로더를 사용하여로드 되며 위임 상위로 사용되는 &lt;code&gt;ClassLoader&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 공용 생성자를 정의해야합니다 . 그런 다음 기본 시스템 클래스 로더를 매개 변수로 사용하여이 생성자를 사용하여 인스턴스가 작성됩니다. 결과 클래스 로더는 시스템 클래스 로더로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="72daeec5943fe704e6b6f79f778edda5bb93a7be" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;java.system.class.loader&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader. During construction, the class loader should take great care to avoid calling &lt;code&gt;getSystemClassLoader()&lt;/code&gt;. If circular initialization of the system class loader is detected then an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 메소드가 처음 호출 될 때 시스템 특성 &quot; &lt;code&gt;java.system.class.loader&lt;/code&gt; &quot;가 정의 된 경우 해당 특성의 값은 시스템 클래스 로더로 리턴 될 클래스의 이름이됩니다. 클래스는 기본 시스템 클래스 로더를 사용하여로드 되며 위임 부모로 사용되는 &lt;code&gt;ClassLoader&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 공용 생성자를 정의해야합니다 . 그런 다음 기본 시스템 클래스 로더를 매개 변수로 사용하여이 생성자를 사용하여 인스턴스가 작성됩니다. 결과 클래스 로더는 시스템 클래스 로더로 정의됩니다. 생성 중에 클래스 로더는 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생 하지 않도록주의해야합니다 . &lt;code&gt;getSystemClassLoader()&lt;/code&gt; . 시스템 클래스 로더의 순환 초기화가 감지되면</target>
        </trans-unit>
        <trans-unit id="b99d8bdd490b40a5b7b3869d55b18d0b463d68ae" translate="yes" xml:space="preserve">
          <source>If the system property &lt;a href=&quot;#DEFAULT_PROPERTY_NAME&quot;&gt;&lt;code&gt;DEFAULT_PROPERTY_NAME&lt;/code&gt;&lt;/a&gt; + &quot;:uri&quot; is present, where uri is the parameter to this method, then its value is read as a class name. The method will try to create a new instance of this class by using the class loader, and returns it if it is successfully created.</source>
          <target state="translated">시스템 속성 &lt;a href=&quot;#DEFAULT_PROPERTY_NAME&quot;&gt; &lt;code&gt;DEFAULT_PROPERTY_NAME&lt;/code&gt; &lt;/a&gt; + &quot;: uri&quot;가있는 경우, 여기서 uri는이 메서드에 대한 매개 변수이며 해당 값은 클래스 이름으로 읽습니다. 메서드는 클래스 로더를 사용하여이 클래스의 새 인스턴스를 만들려고 시도하고 성공적으로 만들어진 경우 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07bb24fbcfd01038cb271accdc3621d725d60279" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&quot;javax.xml.validation.SchemaFactory:&amp;lt;i&amp;gt;schemaLanguage&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; is present (where</source>
          <target state="translated">시스템 속성 &lt;code&gt;&quot;javax.xml.validation.SchemaFactory:&amp;lt;i&amp;gt;schemaLanguage&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; 가있는 경우 (여기서</target>
        </trans-unit>
        <trans-unit id="eecf6f38d2140ba1e50010cc6e9645ed8e47e5a9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;awt.dnd.drag.threshold&lt;/code&gt; is set to a positive integer, this method returns the value of the system property; otherwise if a pertinent desktop property is available and supported by the implementation of the Java platform, this method returns the value of that property; otherwise this method returns some default value. The pertinent desktop property can be queried using &lt;code&gt;java.awt.Toolkit.getDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;)&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;awt.dnd.drag.threshold&lt;/code&gt; 가 양의 정수로 설정된 경우이 메서드는 시스템 속성의 값을 반환합니다. 그렇지 않으면 관련 데스크탑 속성이 사용 가능하고 Java 플랫폼 구현에서 지원되는 경우이 메서드는 해당 속성의 값을 반환합니다. 그렇지 않으면이 메서드는 일부 기본값을 반환합니다. 적절한 데스크톱 속성은 &lt;code&gt;java.awt.Toolkit.getDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;)&lt;/code&gt; 를 사용하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="5504ea1f8b0b864e39c0da5d0938dff7d5fce0a6" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt; is missing or has the value &lt;code&gt;true&lt;/code&gt;, the image is incrementally drawn. If the system property has any other value, then the image is not drawn until it has been completely loaded.</source>
          <target state="translated">시스템 속성 &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt; 가 누락되었거나 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 이미지가 증분 적으로 그려집니다. 시스템 속성에 다른 값이 있으면 이미지가 완전히로드 될 때까지 그려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a82eebeff03c982f8a2c8e7b92fff81f4e06e38" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 가 정의되면 콘크리트 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52c1afd219c316bf40da492c932d1f909b2e0fe8" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 가 정의되면 콘크리트 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5093af58ccd31e98a4f37d4eff5d606412ea6ad9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme &lt;code&gt;&quot;file&quot;&lt;/code&gt;. Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to &lt;code&gt;&quot;file&quot;&lt;/code&gt; then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be &lt;code&gt;&quot;file&quot;&lt;/code&gt;. The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its &lt;code&gt;
 getFileSystem&lt;/code&gt; method is invoked with the URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; to get a reference to the default file system.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; 가 정의 된 경우 URI 스킴 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 로 식별되는 하나 이상의 완전한 제공자 클래스 이름 목록이 됩니다 . 속성이 둘 이상의 이름 목록 인 경우 이름은 쉼표로 구분됩니다. 각 클래스는 시스템 클래스 로더를 사용하여로드되고 형식 매개 변수 유형이 &lt;code&gt;FileSystemProvider&lt;/code&gt; 인 하나의 인수 생성자를 호출하여 인스턴스화됩니다 . 공급자는 속성에 나열된 순서대로로드되고 인스턴스화됩니다. 이 프로세스가 실패하거나 제공자의 계획이 다음과 같지 않은 경우 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 그러면 지정되지 않은 오류가 발생합니다. URI 체계는 일반적으로 대소 문자에 관계없이 비교되지만 기본 공급자의 경우 체계는 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 이어야 합니다 . 첫 번째 공급자 클래스는 시스템 기본 공급자에 대한 참조로 호출하여 인스턴스화됩니다. 두 번째 공급자 클래스는 첫 번째 공급자 인스턴스에 대한 참조를 사용하여 호출하여 인스턴스화됩니다. 세 번째 공급자 클래스는 두 번째 인스턴스에 대한 참조로 호출하여 인스턴스화됩니다. 인스턴스화 할 마지막 공급자가 기본 공급자가됩니다. 그 &lt;code&gt; getFileSystem&lt;/code&gt; 의 방법은 URI를 호출 &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; 기본 파일 시스템에 대한 참조를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3d062ab7060d9b3ee095375a8de4d829bd4225b" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme &lt;code&gt;&quot;file&quot;&lt;/code&gt;. Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to &lt;code&gt;&quot;file&quot;&lt;/code&gt; then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be &lt;code&gt;&quot;file&quot;&lt;/code&gt;. The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its &lt;code&gt;getFileSystem&lt;/code&gt; method is invoked with the URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; to get a reference to the default file system.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; 인 가 정의 된 경우 URI 스킴 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 로 식별되는 구체적 제공자 클래스의 하나 이상의 완전한 이름 목록으로 간주 됩니다 . 특성이 둘 이상의 이름 목록 인 경우 이름은 쉼표로 구분됩니다. 각 클래스는 시스템 클래스 로더를 사용하여로드되며 형식 매개 변수 유형이 &lt;code&gt;FileSystemProvider&lt;/code&gt; 인 하나의 인수 생성자를 호출하여 인스턴스화됩니다 . 제공자는 속성에 나열된 순서대로로드 및 인스턴스화됩니다. 이 프로세스가 실패하거나 공급자의 체계가 같지 않은 경우 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 지정되지 않은 오류가 발생합니다. URI 스킴은 일반적으로 대소 문자와 상관없이 비교되지만 기본 제공자의 경우 스킴은 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 이어야 합니다 . 첫 번째 제공자 클래스는 시스템 기본 제공자에 대한 참조로 호출하여 인스턴스화됩니다. 두 번째 공급자 클래스는 첫 번째 공급자 인스턴스에 대한 참조로 호출하여 인스턴스화됩니다. 세 번째 공급자 클래스는 두 번째 인스턴스 등에 대한 참조로 호출하여 인스턴스화됩니다. 인스턴스화 할 마지막 공급자가 기본 공급자가됩니다. 그 &lt;code&gt;getFileSystem&lt;/code&gt; 의 방법은 URI를 호출 &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; 기본 파일 시스템에 대한 참조를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b65db3ac8212073211f72ace037edb568ab174" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; is defined, then if its value equals the string &lt;code&gt;&quot;default&quot;&lt;/code&gt;, the provider instance will be the value returned by an invocation of the &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt;&lt;code&gt;getDefaultProviderInstance()&lt;/code&gt;&lt;/a&gt; method, and for any other value, if a class named with the value of the property can be loaded by the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;) and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the property is defined but any other of those conditions are not true, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">시스템 속성 &lt;code&gt;java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; 가 정의 된 경우 해당 값이 문자열 &lt;code&gt;&quot;default&quot;&lt;/code&gt; 와 같으면 공급자 인스턴스는 &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt; &lt;code&gt;getDefaultProviderInstance()&lt;/code&gt; &lt;/a&gt; 메서드 호출에 의해 반환 된 값이되고 다른 값의 경우 속성 값으로 명명 된 클래스는 시스템 클래스 로더 ( &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt; 참조)에 의해로드 될 수 있으며 해당 클래스는 &lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; 에&lt;/a&gt; 할당 할 수 있고 인수가없는 공용 생성자를 가지고 있습니다. 그러면 해당 생성자가 호출되어 공급자 인스턴스. 속성이 정의되었지만 다른 조건이 참이 아닌 경우 사용을 시도하는 코드에 지정되지 않은 &lt;code&gt;Error&lt;/code&gt; 가 발생합니다. &lt;code&gt;RMIClassLoader&lt;/code&gt; , 공급자 인스턴스를 가져 오지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f46166d5f46be810080dff80c8423bab7a1101a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then the &lt;a href=&quot;#%3Cinit%3E()&quot;&gt;&lt;code&gt;ObjID()&lt;/code&gt;&lt;/a&gt; constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; (대소 문자 구분 안 함)와 같도록 정의 된 경우 &lt;a href=&quot;#%3Cinit%3E()&quot;&gt; &lt;code&gt;ObjID()&lt;/code&gt; &lt;/a&gt; 생성자는 암호화 된 강력한 난수 생성기를 사용하여 반환 된 &lt;code&gt;ObjID&lt;/code&gt; 의 개체 번호를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="8d2fee9a69da418ea608c03885c80bf1ca4b886c" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then this constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; (대소 문자 구분 안 함)와 같도록 정의 된 경우이 생성자는 암호화 된 강력한 난수 생성기를 사용하여 반환 된 &lt;code&gt;ObjID&lt;/code&gt; 의 개체 번호를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="dd24e048fc15e059868d56f4f568438df6b0caf5" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Packer. This class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 속성이 &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; 가 정의 된 경우 값은 구체적인 구현 클래스의 완전한 이름으로 간주되며 Packer를 구현해야합니다. 이 클래스는로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="45a9607a9147c5f0b3360c97b95442bd171c997a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Unpacker. The class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 프로퍼티 &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; 인 경우 가 정의 된 경우 값은 Unpacker를 구현해야하는 구체적 구현 클래스의 완전한 이름이됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e75189cd7136093b1d6f408091c23d0de22eb446" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; is defined, then it is taken to be the fully-qualified name of a class implementing the &lt;code&gt;PreferencesFactory&lt;/code&gt; interface. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 가 정의 된 경우 &lt;code&gt;PreferencesFactory&lt;/code&gt; 인터페이스를 구현하는 클래스의 완전한 이름으로 간주 됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7e27f744d6efd52e983b8075a0c2febcea34f65" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.management.builder.initial&lt;/code&gt; is set, the platform &lt;code&gt;MBeanServer&lt;/code&gt; creation will be done by the specified &lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt;&lt;code&gt;MBeanServerBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.management.builder.initial&lt;/code&gt; 이 설정되면, 플랫폼 &lt;code&gt;MBeanServer&lt;/code&gt; 작성은 지정된 &lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt; &lt;code&gt;MBeanServerBuilder&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d066e5cdc048829a2f626bea353ff4aba240c230" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; 가 지정된 경우 &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt; 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 암호화 제품군의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9cdd13fa82f3ac48193dd93680807e448f9971c6" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; 가 지정된 경우이 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 암호화 제품군의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e3beb140976a34dd92e43f005e5cdc896cbf0e59" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; 가 지정된 경우 &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt; 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 프로토콜 버전의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2c1710dbf416654c2b07f01e4c116984afd32006" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; 가 지정된 경우이 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 프로토콜 버전의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d37a20fcf5fe426fc5b5a1c3bcefbc944d6b8689" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default receiver. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 가 정의되어 있거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 수신기를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cde7239c70f83bff85e4440c46d6384691316ad" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default receiver. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If a suitable MIDI port is not available, the Receiver is retrieved from an installed synthesizer.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 수신자를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 적합한 MIDI 포트를 사용할 수 없으면 설치된 신시사이저에서 수신기를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="91d3c314661dc26f163d797ffb58967de288f2ac" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default sequencer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 시퀀서를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00dcdd9d0bce1154db11492279afceeca3e08d7a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default synthesizer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 신시사이저를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30df19d74bec068b077f43c95c9174eacf908696" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default transmitter. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 송신기를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db720e9cdab4ebfc9f02a35fbd8f738bb2171b1" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default clip. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 클립을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="878cc5542428544d5bac13085b41e0430d054903" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default source data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 소스 데이터 라인을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d607cde38af381ba0dfdab64a53303e271b212" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default target data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 대상 데이터 라인을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d07239e369381a0fb6e04b89573dbf0f8758c57d" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;org.xml.sax.driver&lt;/code&gt; has a value, that is used as an XMLReader class name.</source>
          <target state="translated">시스템 속성 &lt;code&gt;org.xml.sax.driver&lt;/code&gt; 에 값이 있으면 XMLReader 클래스 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7eb7d836f2f43aa70bd878289c523ee9226c1901" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;suppressSwingDropSupport&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default) and the current drop target on this component is either &lt;code&gt;null&lt;/code&gt; or not a user-set drop target, this method will change the drop target as follows: If &lt;code&gt;newHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; it will clear the drop target. If not &lt;code&gt;null&lt;/code&gt; it will install a new &lt;code&gt;DropTarget&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;suppressSwingDropSupport&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; (기본값)이고이 구성 요소의 현재 놓기 대상이 &lt;code&gt;null&lt;/code&gt; 이거나 사용자가 설정 한 놓기 대상이 아닌 경우이 메서드는 놓기 대상을 다음과 같이 변경합니다. &lt;code&gt;newHandler&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 삭제를 지 웁니다. 표적. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 이 새로운 설치합니다 &lt;code&gt;DropTarget&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="d7708124db0ebabf9cd252ce976d692ad91505f5" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;swing.defaultlaf&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt;, use its value as the default look and feel class name.</source>
          <target state="translated">시스템 속성 &lt;code&gt;swing.defaultlaf&lt;/code&gt; 가 &lt;code&gt;non-null&lt;/code&gt; 이 아닌 경우 해당 값을 기본 룩앤필 클래스 이름으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8ff71830cbe5c28d3e3792ef57a69165cfffa083" translate="yes" xml:space="preserve">
          <source>If the system property is not set or the getInstance() call fails for any reason, the system defaults to an implementation specific default type and TerminalFactory.</source>
          <target state="translated">시스템 속성이 설정되지 않았거나 어떤 이유로 든 getInstance () 호출이 실패하면 시스템은 기본적으로 구현 특정 기본 유형과 TerminalFactory로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="de8593fcec2e6dbf96521d87b6c0f3273e22eb58" translate="yes" xml:space="preserve">
          <source>If the system property specified by &lt;a href=&quot;#DATATYPEFACTORY_PROPERTY&quot;&gt;&lt;code&gt;DATATYPEFACTORY_PROPERTY&lt;/code&gt;&lt;/a&gt;, &quot;&lt;code&gt;javax.xml.datatype.DatatypeFactory&lt;/code&gt;&quot;, exists, a class with the name of the property value is instantiated. Any Exception thrown during the instantiation process is wrapped as a &lt;a href=&quot;datatypeconfigurationexception&quot;&gt;&lt;code&gt;DatatypeConfigurationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DATATYPEFACTORY_PROPERTY&quot;&gt; &lt;code&gt;DATATYPEFACTORY_PROPERTY&lt;/code&gt; 로&lt;/a&gt; 지정된 시스템 속성 인 &quot; &lt;code&gt;javax.xml.datatype.DatatypeFactory&lt;/code&gt; &quot;가 존재하면 속성 값의 이름을 가진 클래스가 인스턴스화됩니다. 인스턴스화 프로세스 중에 발생한 모든 예외는 &lt;a href=&quot;datatypeconfigurationexception&quot;&gt; &lt;code&gt;DatatypeConfigurationException&lt;/code&gt; 으로&lt;/a&gt; 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="6af05deaf58fe154a4b75ce321753672bae18f99" translate="yes" xml:space="preserve">
          <source>If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.</source>
          <target state="translated">대상 파일이 존재하면 비어 있지 않은 디렉토리가 아닌 경우 대상 파일이 대체됩니다. 대상 파일이 존재하고 심볼릭 링크 인 경우 링크 대상이 아닌 심볼릭 링크 자체가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="ac457e75b3f1b21e3f75382a66191d55b4a52e0f" translate="yes" xml:space="preserve">
          <source>If the target is _parent, then it deletes the parent element, which is a &amp;lt;FRAMESET&amp;gt; element, and inserts a new &amp;lt;FRAME&amp;gt; element, and sets its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute to have a value equal to the destination URL and fire a &lt;code&gt;RemovedUpdate&lt;/code&gt; and &lt;code&gt;InsertUpdate&lt;/code&gt;.</source>
          <target state="translated">대상이 _parent 인 경우 &amp;lt;FRAMESET&amp;gt; 요소 인 상위 요소를 삭제하고 새 &amp;lt;FRAME&amp;gt; 요소를 삽입하고 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 속성을 대상 URL과 동일한 값으로 설정하고 실행합니다. &lt;code&gt;RemovedUpdate&lt;/code&gt; 및 &lt;code&gt;InsertUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf1de5041cbc9489101a1efbb3aa93f8e3747f64" translate="yes" xml:space="preserve">
          <source>If the target is _top, this method does nothing. In the implementation of the view for a frame, namely the &lt;code&gt;FrameView&lt;/code&gt;, the processing of _top is handled. Given that _top implies replacing the entire document, it made sense to handle this outside of the document that it will replace.</source>
          <target state="translated">대상이 _top이면이 메서드는 아무 작업도 수행하지 않습니다. 프레임에 대한 뷰, 즉 &lt;code&gt;FrameView&lt;/code&gt; 구현 에서 _top 처리가 처리됩니다. _top이 전체 문서를 대체하는 것을 의미하므로 대체 할 문서 외부에서이를 처리하는 것이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="05419b4ed8480b175c0a67be127a4f47601c6536" translate="yes" xml:space="preserve">
          <source>If the target is a named frame, then the element hierarchy is searched for an element with a name equal to the target, its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute is updated and a &lt;code&gt;ChangedUpdate&lt;/code&gt; event is fired.</source>
          <target state="translated">대상이 명명 된 프레임이면 요소 계층 구조에서 대상과 이름이 같은 요소를 검색하고 해당 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 속성이 업데이트되고 &lt;code&gt;ChangedUpdate&lt;/code&gt; 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c180e88e82b133d4c219bf7bc995901410956a4" translate="yes" xml:space="preserve">
          <source>If the target method handle consumes no arguments besides than the result (if any) of the filter &lt;code&gt;coll&lt;/code&gt;, then &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt;. If the filter method handle &lt;code&gt;coll&lt;/code&gt; consumes one argument and produces a non-void result, then &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt;. Other equivalences are possible but would require argument permutation.</source>
          <target state="translated">대상있어서 핸들 필터들 (있는 경우) 또한 결과보다 인수를 소모하지 않으면 &lt;code&gt;coll&lt;/code&gt; 후, &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; 동등 &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt; . 필터 메소드 핸들 &lt;code&gt;coll&lt;/code&gt; 이 하나의 인수를 사용하고 무효가 아닌 결과를 생성하는 경우 &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; 는 &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt; . 다른 동등성도 가능하지만 인수 치환이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="458e499fec0b734951e6d53ad84671bd6e68d6c5" translate="yes" xml:space="preserve">
          <source>If the target method handle has variable arity, and the argument list is longer than that arity, the excess arguments, starting at the position of the trailing array argument, will be gathered (if possible, as if by &lt;code&gt;asType&lt;/code&gt; conversions) into an array of the appropriate type, and invocation will proceed on the shortened argument list. In this way, &lt;em&gt;jumbo argument lists&lt;/em&gt; which would spread into more than 254 slots can still be processed uniformly.</source>
          <target state="translated">대상 메서드 핸들에 가변 arity가 있고 인수 목록이 해당 arity보다 길면 후행 배열 인수의 위치에서 시작하는 초과 인수가 수집됩니다 (가능한 경우 &lt;code&gt;asType&lt;/code&gt; 변환에 의한 것처럼 ). 적절한 유형을 선택하면 단축 된 인수 목록에서 호출이 진행됩니다. 이러한 방식으로 254 개 이상의 슬롯으로 확산되는 &lt;em&gt;점보 인수 목록&lt;/em&gt; 은 여전히 ​​균일하게 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a6410dfb8cfd393874164170a840502005c25ad" translate="yes" xml:space="preserve">
          <source>If the target returns a value, the filter must accept that value as its only argument. If the target returns void, the filter must accept no arguments.</source>
          <target state="translated">대상이 값을 반환하면 필터는 해당 값을 유일한 인수로 허용해야합니다. 대상이 void를 반환하면 필터는 인수를 허용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="933efa6315f31837fd252efc9f236faa4bf2d497" translate="yes" xml:space="preserve">
          <source>If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as an integer that should be one of the legal values for the &lt;code&gt;StyleConstants.Alignment&lt;/code&gt; attribute.</source>
          <target state="translated">대상 텍스트 구성 요소가 ActionEvent의 소스로 지정되고 명령 문자열이있는 경우 명령 문자열은 &lt;code&gt;StyleConstants.Alignment&lt;/code&gt; 속성 의 유효한 값 중 하나 여야하는 정수로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad7689e60ae1c9939383833d9772f90e200fa26d" translate="yes" xml:space="preserve">
          <source>If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as the foreground color. It will be interpreted by called &lt;code&gt;Color.decode&lt;/code&gt;, and should therefore be legal input for that method.</source>
          <target state="translated">대상 텍스트 구성 요소가 ActionEvent의 소스로 지정되고 명령 문자열이있는 경우 명령 문자열은 전경색으로 해석됩니다. 이것은 &lt;code&gt;Color.decode&lt;/code&gt; 라는 이름으로 해석 되므로 해당 메서드에 대한 올바른 입력이어야합니다.</target>
        </trans-unit>
        <trans-unit id="60ff5ddff7c5d899dfe402e4472a1b9b2a332d25" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain a date, but does contain one or more &lt;code&gt;ChronoField&lt;/code&gt; date fields, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override chronology is added to the temporal, replacing any previous chronology, but without changing the date/time.</source>
          <target state="translated">임시 개체에 날짜가 포함되어 있지 않지만 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 필드 가 하나 이상 포함 된 경우 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다. 다른 모든 경우에는 날짜 / 시간을 변경하지 않고 재정의 연대기를 시간에 추가하여 이전 연대기를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="dd85e14ed75c47c84beea3f122d891fc9308e690" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain an instant, but does contain an offset then an additional check is made. If the normalized override zone is an offset that differs from the offset of the temporal, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override zone is added to the temporal, replacing any previous zone, but without changing the date/time.</source>
          <target state="translated">임시 객체에 순간이 포함되어 있지 않지만 오프셋이 포함되어 있으면 추가 검사가 수행됩니다. 정규화 된 재정의 영역이 시간의 오프셋과 다른 오프셋 인 경우 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다. 다른 모든 경우에는 재정의 영역이 시간에 추가되어 이전 영역을 대체하지만 날짜 / 시간을 변경하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c09abaae8508d70028ba67cefa61277b54360a6" translate="yes" xml:space="preserve">
          <source>If the thread argument is a system thread (belongs to the thread group with a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission. If the thread argument is</source>
          <target state="translated">스레드 인수가 시스템 스레드 인 경우 ( 부모 가 &lt;code&gt;null&lt;/code&gt; 인 스레드 그룹에 속함 )이 메소드 는 &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; 와 함께 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다. 권한으로 . 스레드 인수가</target>
        </trans-unit>
        <trans-unit id="956a4caf473783d2c99b96d529421cc001582508" translate="yes" xml:space="preserve">
          <source>If the thread group argument is the system thread group ( has a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission. If the thread group argument is</source>
          <target state="translated">스레드 그룹 인수가 시스템 스레드 그룹 인 경우 ( 부모 가 &lt;code&gt;null&lt;/code&gt; 인 경우)이 메소드 는 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 . 스레드 그룹 인수가</target>
        </trans-unit>
        <trans-unit id="2851f30724641ecca099288cb8621aaa00615fd6" translate="yes" xml:space="preserve">
          <source>If the thread is alive but suspended, it is resumed and is permitted to make progress in its execution.</source>
          <target state="translated">스레드가 활성 상태이지만 일시 중단 된 경우 스레드가 재개되고 실행 진행이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d129983d6e8dc28983c9eb2cd579ed898cf687" translate="yes" xml:space="preserve">
          <source>If the thread is alive, it is suspended and makes no further progress unless and until it is resumed.</source>
          <target state="translated">스레드가 활성 상태 인 경우 스레드가 일시 중단되고 다시 시작하지 않는 한 계속 진행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95f23b0ab1d9ecd54f0d7d1cfdcbc8a705f2c602" translate="yes" xml:space="preserve">
          <source>If the thread of the specified ID is not alive or does not exist, this method returns &lt;code&gt;-1&lt;/code&gt;. If CPU time measurement is disabled, this method returns &lt;code&gt;-1&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">지정된 ID의 스레드가 존재하지 않거나 존재하지 않으면이 메소드는 &lt;code&gt;-1&lt;/code&gt; 을 리턴합니다 . CPU 시간 측정이 비활성화 된 경우이 방법은 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다. . 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="97aef73764a8b235d11df488cc792228726de005" translate="yes" xml:space="preserve">
          <source>If the time '23:59:60' is received, then a simple conversion is applied, replacing the second-of-minute of 60 with 59. This query can be used on the parse result to determine if the leap-second adjustment was made. The query will return &lt;code&gt;true&lt;/code&gt; if it did adjust to remove the leap-second, and &lt;code&gt;false&lt;/code&gt; if not. Note that applying a leap-second smoothing mechanism, such as UTC-SLS, is the responsibility of the application, as follows:</source>
          <target state="translated">'23 : 59 : 60 '시간이 수신되면 간단한 변환이 적용되어 분의 초를 60으로 59로 바꿉니다.이 쿼리는 구문 분석 결과에 사용되어 윤초 조정이 만든. 쿼리는 윤초를 제거하도록 조정 한 경우 &lt;code&gt;true&lt;/code&gt; 를 반환하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. UTC-SLS와 같은 윤초 평활 메커니즘을 적용하는 것은 다음과 같이 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="6ae6878cfd3b1d0ceb5a94fe0301dc8e364dcc4f" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">시간 초과 한계가 't'초로 설정되면, 세션은 작성 시간 후 시간 초과 한계 't'초를 초과합니다. 세션에 대한 시간 종료 제한이 초과되면 &lt;code&gt;SSLSession&lt;/code&gt; 오브젝트가 무효화되고 이후 연결에서 세션을 재개하거나 다시 참여할 수 없습니다. 이 &lt;code&gt;SSLSessionContext&lt;/code&gt; 의 제한 시간이 변경 될 때마다 제한 시간을 초과하는 세션을 점검합니다 .</target>
        </trans-unit>
        <trans-unit id="ad1adddf8356c433278ef7cd10d12a5f2bd6c761" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout limit is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">시간 초과 한계가 't'초로 설정되면, 세션은 작성 시간 후 시간 초과 한계 't'초를 초과합니다. 세션에 대한 시간 종료 한계가 초과되면 &lt;code&gt;SSLSession&lt;/code&gt; 오브젝트가 무효화되고 이후 연결에서 세션을 재개하거나 다시 참여할 수 없습니다. 이 &lt;code&gt;SSLSessionContext&lt;/code&gt; 에 대해 시간 종료 한계가 변경 될 때마다 시간 종료 한계를 초과하는 세션이 즉시 점검됩니다 .</target>
        </trans-unit>
        <trans-unit id="44775d676f01ccf28f57333e6fb89f1c12f0cfd6" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date and the notification is delivered immediately.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 동작하며 알림이 즉시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8056b6ccedf3aca7fb9d63268e271ee88e090cd9" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 메서드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f7ed1fef67b3c31fe3734b8ae38aa892bb880b72" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date. The first notification is delivered immediately and the subsequent ones are spaced as specified by the period parameter.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 메서드가 작동합니다. 첫 번째 알림은 즉시 전달되고 후속 알림은 period 매개 변수에 지정된 간격으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="38b2e2e16267baf4e1e54405bd70137ca888e8ed" translate="yes" xml:space="preserve">
          <source>If the timer's task execution thread terminates unexpectedly, for example, because its &lt;code&gt;stop&lt;/code&gt; method is invoked, any further attempt to schedule a task on the timer will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;, as if the timer's &lt;code&gt;cancel&lt;/code&gt; method had been invoked.</source>
          <target state="translated">예를 들어, &lt;code&gt;stop&lt;/code&gt; 메소드가 호출 되어 타이머의 태스크 실행 스레드가 예기치 않게 종료되면 타이머에서 태스크 를 스케줄하려고 하면 타이머의 &lt;code&gt;cancel&lt;/code&gt; 메소드가 호출 된 것처럼 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac3591693d15d3e4209a0731ba617c073e32bb40" translate="yes" xml:space="preserve">
          <source>If the transformer throws an exception (which it doesn't catch), subsequent transformers will still be called and the load, redefine or retransform will still be attempted. Thus, throwing an exception has the same effect as returning &lt;code&gt;null&lt;/code&gt;. To prevent unexpected behavior when unchecked exceptions are generated in transformer code, a transformer can catch &lt;code&gt;Throwable&lt;/code&gt;. If the transformer believes the &lt;code&gt;classFileBuffer&lt;/code&gt; does not represent a validly formatted class file, it should throw an &lt;code&gt;IllegalClassFormatException&lt;/code&gt;; while this has the same effect as returning null. it facilitates the logging or debugging of format corruptions.</source>
          <target state="translated">변압기에 예외가 발생하더라도 (포착되지 않는) 후속 변압기가 계속 호출되고로드, 재정의 또는 재 변환이 계속 시도됩니다. 따라서 예외를 throw하면 &lt;code&gt;null&lt;/code&gt; 을 반환하는 것과 같은 효과가 있습니다. 확인되지 않은 예외가 변환기 코드에서 생성 될 때 예기치 않은 동작을 방지하기 위해 변환기는 &lt;code&gt;Throwable&lt;/code&gt; 을 포착 할 수 있습니다 . 변환기가 &lt;code&gt;classFileBuffer&lt;/code&gt; 가 올바른 형식의 클래스 파일을 나타내지 않는다고 생각 하면 &lt;code&gt;IllegalClassFormatException&lt;/code&gt; 을 발생 시켜야합니다. . null을 반환하는 것과 같은 효과가 있습니다. 형식 손상의 로깅 또는 디버깅을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="b2202f39f213e519d8a6a914b9451df18b3b6cd6" translate="yes" xml:space="preserve">
          <source>If the traversal key has not been explicitly set for this Window, then this Window's parent's traversal key is returned. If the traversal key has not been explicitly set for any of this Window's ancestors, then the current KeyboardFocusManager's default traversal key is returned.</source>
          <target state="translated">순회 키가이 Window에 대해 명시 적으로 설정되지 않은 경우,이 Window의 부모 순회 키가 반환됩니다. 이 Window의 조상에 대해 순회 키가 명시 적으로 설정되지 않은 경우 현재 KeyboardFocusManager의 기본 순회 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="10849c037dd8bc1c2fc1c741b858e266697ece21" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements of type &lt;code&gt;T&lt;/code&gt; at an index &lt;code&gt;i&lt;/code&gt; within the respective arrays that is the prefix length, as if by:</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 다음과 같이 접두사 길이 인 각 배열 내의 인덱스 &lt;code&gt;i&lt;/code&gt; 에서 유형 &lt;code&gt;T&lt;/code&gt; 의 두 요소를 비교 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="b155792f2e510e17ec8d253fc3a0fb59ca79f8dd" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt;&lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(boolean%5B%5D,boolean%5B%5D)&quot;&gt;&lt;code&gt;mismatch(boolean[], boolean[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt; &lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt; &lt;/a&gt; 에서처럼 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( &lt;a href=&quot;#mismatch(boolean%5B%5D,boolean%5B%5D)&quot;&gt; &lt;code&gt;mismatch(boolean[], boolean[])&lt;/code&gt; &lt;/a&gt; 일반적이고 적절한 접두사의 정의는 를 .)</target>
        </trans-unit>
        <trans-unit id="57243fdb8f978c78fb76c986d30f96d7bf6d4774" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt;&lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt;&lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt; &lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt; &lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="efbf4a94c94fc3222d7e00ab8ab0707b70f1d4e9" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt;&lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt;&lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt; &lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt; &lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="4e8abaf672daa90f27c4a28744cf3bffbed58f1b" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt;&lt;code&gt;Character.compare(char, char)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(char%5B%5D,char%5B%5D)&quot;&gt;&lt;code&gt;mismatch(char[], char[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 마치 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt; &lt;code&gt;Character.compare(char, char)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(char%5B%5D,char%5B%5D)&quot;&gt; &lt;code&gt;mismatch(char[], char[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a1fa6e3b313e74e85610c3d66b8ff693e012d72d" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt;&lt;code&gt;Double.compare(double, double)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(double%5B%5D,double%5B%5D)&quot;&gt;&lt;code&gt;mismatch(double[], double[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt; &lt;code&gt;Double.compare(double, double)&lt;/code&gt; &lt;/a&gt; 에서처럼 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(double%5B%5D,double%5B%5D)&quot;&gt; &lt;code&gt;mismatch(double[], double[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1c4f63f453b8509aa4d20ab07035dc58ee1cb446" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt;&lt;code&gt;Float.compare(float, float)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(float%5B%5D,float%5B%5D)&quot;&gt;&lt;code&gt;mismatch(float[], float[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt; &lt;code&gt;Float.compare(float, float)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(float%5B%5D,float%5B%5D)&quot;&gt; &lt;code&gt;mismatch(float[], float[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3a6dc406fb7fd94c09e0c48b3ba97eeaadc82d2f" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt;&lt;code&gt;Integer.compare(int, int)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt;&lt;code&gt;mismatch(int[], int[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt; &lt;code&gt;Integer.compare(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt; &lt;code&gt;mismatch(int[], int[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="f49296e451be67acc72ebac21d6d5d2ab335c399" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt;&lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt;&lt;code&gt;mismatch(int[], int[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt; &lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt; &lt;code&gt;mismatch(int[], int[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b63db0f74eabd287280b9ce88e153dd64850efd0" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt;&lt;code&gt;Long.compare(long, long)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt;&lt;code&gt;mismatch(long[], long[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt; &lt;code&gt;Long.compare(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt; &lt;code&gt;mismatch(long[], long[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1bcb7cd8bec0f1fcffe21770a5583ac7e1aa23a1" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt;&lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt;&lt;code&gt;mismatch(long[], long[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt; &lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt; &lt;code&gt;mismatch(long[], long[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3d148b2dafd16e299cfcc608fd7bc9a2b486aed0" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt;&lt;code&gt;Short.compare(short, short)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt;&lt;code&gt;mismatch(short[], short[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt; &lt;code&gt;Short.compare(short, short)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt; &lt;code&gt;mismatch(short[], short[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="10bcf2ff1ce53653290b9af98721a6b69481041d" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt;&lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt;&lt;code&gt;mismatch(short[], short[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt; &lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt; &lt;code&gt;mismatch(short[], short[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9b48c79397e666c5c9e58c00b0300c3f32625780" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;mismatch(Object[], Object[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 지정된 비교 자와 두 요소를 비교 한 결과입니다. 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;mismatch(Object[], Object[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="751f847fc7eff31ed05d5e61dc95a845161d2ad3" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch.</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 반환 된 색인은 공통 접두사의 길이이며 각 배열 내에서 해당 색인의 두 요소간에 불일치가 발생합니다. 한 배열이 다른 배열의 적절한 접두사 인 경우 반환 된 인덱스는 더 작은 배열의 길이이며 인덱스는 더 큰 배열에 대해서만 유효합니다. 그렇지 않으면 불일치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e2839946586ddeda4b1002deade56dce2c14f22" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements of type &lt;code&gt;T&lt;/code&gt; at a relative index &lt;code&gt;i&lt;/code&gt; within the respective arrays that is the prefix length, as if by:</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 다음과 같이 접두사 길이 인 각 배열 내 상대 색인 &lt;code&gt;i&lt;/code&gt; 에서 유형 &lt;code&gt;T&lt;/code&gt; 의 두 요소를 비교 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="f3f948cd0dc8d1832d6c7cda8991ab71dcb99b17" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt;&lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(boolean[], int, int, boolean[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt; &lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(boolean[], int, int, boolean[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="a6e94f75faa2282739b4f3b904d2d252589549dd" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt;&lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt; &lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="d99ad3f23655df7e4fbd277c7e8afb3093422df6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt;&lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt; &lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="689546c82dfde445df7cb6060f65882dc0abca33" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt;&lt;code&gt;Character.compare(char, char)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(char[], int, int, char[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt; &lt;code&gt;Character.compare(char, char)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(char[], int, int, char[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="33f0cf3594f25f4cb36a42269d56adb60385fdc6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt;&lt;code&gt;Double.compare(double, double)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(double[], int, int, double[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt; &lt;code&gt;Double.compare(double, double)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(double[], int, int, double[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="96dc20aff5dbee21053cf86a2f97932e6e113e17" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt;&lt;code&gt;Float.compare(float, float)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(float[], int, int, float[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt; &lt;code&gt;Float.compare(float, float)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(float[], int, int, float[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="efb772271b892ca76f0e7c60394b0c3288a55976" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt;&lt;code&gt;Integer.compare(int, int)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt; &lt;code&gt;Integer.compare(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="fc1abfae5f6bec827afbe78092dd5076cbb73043" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt;&lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt; &lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="3f390c1a0173f067f002963d99ec1e933697624f" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt;&lt;code&gt;Long.compare(long, long)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에 걸쳐 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt; &lt;code&gt;Long.compare(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="acdbd4d409077318826faeff1066f127d79d2e03" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt;&lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt; &lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="165852849eadb60efdc65ee7e29e23a132211a7c" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt;&lt;code&gt;Short.compare(short, short)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt; &lt;code&gt;Short.compare(short, short)&lt;/code&gt; &lt;/a&gt; 길이 인 각 배열 내의 상대 색인에서 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="92a13ef6017334f61c5516d921592620158e34a6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt;&lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 마치 &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt; &lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt; &lt;/a&gt; 가 길이 인 각 배열 내의 상대 색인에서 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="0adc08ed767ba5fcac736354cc12489898dcbc7c" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at a relative index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(Object[], int, int, Object[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 지정된 범위에 걸쳐 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 상대 색인에서 지정된 비교 자와 두 요소를 비교 한 결과입니다. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(Object[], int, int, Object[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="de179b6b61556777afe0f0139dc8277c77218327" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch.</source>
          <target state="translated">지정된 범위에 걸쳐 두 배열이 공통 접두사를 공유하는 경우 반환 된 상대 색인은 공통 접두사의 길이이며 각 배열 내 해당 상대 색인의 두 요소간에 불일치가 발생합니다. 한 배열이 지정된 범위에서 다른 배열의 적절한 접두사 인 경우 반환 된 상대 인덱스는 더 작은 범위의 길이이며 상대 인덱스는 더 큰 범위의 배열에만 유효합니다. 그렇지 않으면 불일치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ff68f92a851855ba68fbc7ed3f7e692a3962b65" translate="yes" xml:space="preserve">
          <source>If the two buffers share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two buffers at that index within the respective buffers. If one buffer is a proper prefix of the other then the returned index is the smaller of the remaining elements in each buffer, and it follows that the index is only valid for the buffer with the larger number of remaining elements. Otherwise, there is no mismatch.</source>
          <target state="translated">두 버퍼가 공통 접두사를 공유하는 경우 반환 된 인덱스는 공통 접두사의 길이이며 각 버퍼 내 해당 인덱스의 두 버퍼간에 불일치가 발생합니다. 한 버퍼가 다른 버퍼의 적절한 접두사 인 경우 반환 된 인덱스는 각 버퍼의 나머지 요소 중 더 작으며 나머지 요소 수가 많은 버퍼에 대해서만 인덱스가 유효합니다. 그렇지 않으면 불일치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="051c9daf6b939af50cb443665c610f27abeb1722" translate="yes" xml:space="preserve">
          <source>If the two interfaces are mixed (including serialization), Unicode range values are mapped to their counterparts where such mapping is possible, such as &lt;code&gt;NumericShaper.Range.ARABIC&lt;/code&gt; from/to &lt;code&gt;NumericShaper.ARABIC&lt;/code&gt;. If any unmappable range values are specified, such as &lt;code&gt;NumericShaper.Range.BALINESE&lt;/code&gt;, those ranges are ignored.</source>
          <target state="translated">두 인터페이스가 혼합 된 경우 (직렬화 포함) 유니 코드 범위 값은 &lt;code&gt;NumericShaper.Range.ARABIC&lt;/code&gt; from / to &lt;code&gt;NumericShaper.ARABIC&lt;/code&gt; 과 같이 이러한 매핑이 가능한 해당 대응 항목에 매핑됩니다 . 매핑 할 수없는 범위 값 (예 : &lt;code&gt;NumericShaper.Range.BALINESE&lt;/code&gt; ) 이 지정된 경우 해당 범위는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cac1823b4d109a58d8c15953a4c53e9282211329" translate="yes" xml:space="preserve">
          <source>If the type is &lt;code&gt;null&lt;/code&gt;, a shared internal persistence delegate is returned that encodes &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">유형 인 경우 &lt;code&gt;null&lt;/code&gt; , 공유 내부의 지속적인 위양은 인코딩 것을 반환 &lt;code&gt;null&lt;/code&gt; 값 됩니다.</target>
        </trans-unit>
        <trans-unit id="24624d93ce0bd52bd62b61c2d340c4e06907a0dd" translate="yes" xml:space="preserve">
          <source>If the type is a &lt;code&gt;enum&lt;/code&gt; declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names.</source>
          <target state="translated">형식이 &lt;code&gt;enum&lt;/code&gt; 선언 인 경우이 열거의 상수를 이름으로 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="17c7dfdd306d9dca345cd59fbb286fb56494c02b" translate="yes" xml:space="preserve">
          <source>If the type is a primitive type or the corresponding wrapper, a shared internal persistence delegate is returned that encodes values of the given type.</source>
          <target state="translated">유형이 기본 유형 또는 해당 랩퍼 인 경우, 주어진 유형의 값을 인코딩하는 공유 내부 지속성 대리자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e83ddcadc497b3ac8c423eb1d1497d6d589d42af" translate="yes" xml:space="preserve">
          <source>If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt;&lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유형이 프록시 인 경우 &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt; &lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt; &lt;/a&gt; 를 사용하여 프록시 인스턴스를 인코딩하는 공유 내부 지속성 위임이 리턴됩니다. ) 방법.</target>
        </trans-unit>
        <trans-unit id="7266e7d4fe52b4f4bd2947e2022cc33489854699" translate="yes" xml:space="preserve">
          <source>If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the &lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt;&lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유형이 프록시 인 경우 &lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt; &lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt; &lt;/a&gt; 를 사용하여 프록시 인스턴스를 인코딩하는 공유 내부 지속성 위임이 리턴됩니다. ) 방법.</target>
        </trans-unit>
        <trans-unit id="7d57cd67c4f9b115595d9ab402c68b98705b5fc3" translate="yes" xml:space="preserve">
          <source>If the type is an &lt;code&gt;enum&lt;/code&gt; declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names.</source>
          <target state="translated">형식이 &lt;code&gt;enum&lt;/code&gt; 선언이면이 열거 형의 상수를 이름으로 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6d791c963ef8e6e2b0fde7ef89bca6d1754b00b4" translate="yes" xml:space="preserve">
          <source>If the type is an array, a shared internal persistence delegate is returned that encodes an array of the appropriate type and length, and each of its elements as if they are properties.</source>
          <target state="translated">유형이 배열 인 경우 적절한 유형 및 길이의 배열과 각 요소가 마치 속성 인 것처럼 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0b2e4d1a1790e1526fd1d7230bad3ff1e34601cd" translate="yes" xml:space="preserve">
          <source>If the type of an object is incompatible with the expected type of the parameter associated to the object.</source>
          <target state="translated">개체 유형이 개체에 연결된 매개 변수의 예상 유형과 호환되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="99f690abde7ac9507cafcabd4eb11b9f675436cc" translate="yes" xml:space="preserve">
          <source>If the type of the underlying field is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">기본 필드의 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="66b62dfc82fc14777b26e50687d5b79596a57206" translate="yes" xml:space="preserve">
          <source>If the underlying class is an array class, then its &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; modifiers are the same as those of its component type. If this &lt;code&gt;Class&lt;/code&gt; represents a primitive type or void, its &lt;code&gt;public&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt;, and its &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; modifiers are always &lt;code&gt;false&lt;/code&gt;. If this object represents an array class, a primitive type or void, then its &lt;code&gt;final&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt; and its interface modifier is always &lt;code&gt;false&lt;/code&gt;. The values of its other modifiers are not determined by this specification.</source>
          <target state="translated">기본 클래스가 배열 클래스 인 경우 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 수정자는 해당 구성 요소 유형과 동일합니다. 이 &lt;code&gt;Class&lt;/code&gt; 가 원시적 형 또는 void를 나타내는 경우, 그 &lt;code&gt;public&lt;/code&gt; 수식자는 항상 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 수식자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 이 객체가 배열 클래스, 기본 유형 또는 void를 나타내는 경우, &lt;code&gt;final&lt;/code&gt; 수정자는 항상 &lt;code&gt;true&lt;/code&gt; 이고 인터페이스 수정자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 다른 수정 자의 값은이 사양에 의해 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6635d2c90407f220bf7ecba5d59930986096dac" translate="yes" xml:space="preserve">
          <source>If the underlying field is a static field, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">기본 필드가 정적 필드 인 경우 &lt;code&gt;obj&lt;/code&gt; 인수는 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e60b6593bad05aa260e774035853633abadd33" translate="yes" xml:space="preserve">
          <source>If the underlying field is final, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt; unless &lt;code&gt;setAccessible(true)&lt;/code&gt; has succeeded for this &lt;code&gt;Field&lt;/code&gt; object and the field is non-static. Setting a final field in this way is meaningful only during deserialization or reconstruction of instances of classes with blank final fields, before they are made available for access by other parts of a program. Use in any other context may have unpredictable effects, including cases in which other parts of a program continue to use the original value of this field.</source>
          <target state="translated">기본이되는 필드가 final의 경우, 이 &lt;code&gt;Field&lt;/code&gt; 오브젝트에 대해 &lt;code&gt;setAccessible(true)&lt;/code&gt; 가 성공 해 필드가 static이 아닌 경우 , 메소드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 Throw합니다 . 이 방법으로 최종 필드를 설정하는 것은 프로그램의 다른 부분에서 액세스 할 수 있기 전에 빈 최종 필드가있는 클래스의 인스턴스를 역 직렬화 또는 재구성하는 동안에 만 의미가 있습니다. 다른 상황에서 사용하면 프로그램의 다른 부분이이 필드의 원래 값을 계속 사용하는 경우를 포함하여 예측할 수없는 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ffdb31707c7c6f0d8ea54510f297f85f678ae3" translate="yes" xml:space="preserve">
          <source>If the underlying field is of a primitive type, an unwrapping conversion is attempted to convert the new value to a value of a primitive type. If this attempt fails, the method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">기본 필드가 기본 유형 인 경우 랩핑 해제 변환은 새 값을 기본 유형의 값으로 변환하려고 시도합니다. 이 시도가 실패하면, 메소드는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 던집니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="35c398b7568f2f6829527a1ee4e8ad05ab589757" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">기본이되는 필드가 정적 인 경우, &lt;code&gt;obj&lt;/code&gt; 인수는 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79473e9ad073a8c2b30d02714d81cdc8e02b2e5d" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the class that declared the field is initialized if it has not already been initialized.</source>
          <target state="translated">기본 필드가 정적 인 경우 필드를 선언 한 클래스는 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="884f8872373909a62519ac7ae071245b57ecb411" translate="yes" xml:space="preserve">
          <source>If the underlying method is &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;caller sensitive&lt;/a&gt;, the direct method handle will have been &quot;bound&quot; to a particular caller class, the &lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;lookup class&lt;/a&gt; of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like &lt;code&gt;Class.forName&lt;/code&gt;).</source>
          <target state="translated">기본 메서드가 &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;호출자에 민감한&lt;/a&gt; 경우 직접 메서드 핸들은 특정 호출자 클래스, 이를 생성하는 데 사용 된 조회 개체 의 &lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;조회 클래스&lt;/a&gt; 에 &quot;바인딩&quot;됩니다 . 다른 조회 클래스로이 메서드 핸들을 크래킹하면 기본 메서드가 공용 (예 : &lt;code&gt;Class.forName&lt;/code&gt; ) 인 경우에도 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5c2e8ba35ddb7d491a4530be7e2d58c63b91b804" translate="yes" xml:space="preserve">
          <source>If the underlying method is &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;caller sensitive&lt;/a&gt;, the direct method handle will have been &quot;bound&quot; to a particular caller class, the &lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;lookup class&lt;/a&gt; of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like &lt;code&gt;Class.forName&lt;/code&gt;).</source>
          <target state="translated">기본 메소드가 &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;호출자 구분&lt;/a&gt; 인 경우 직접 메소드 핸들은 특정 호출자 클래스, 이를 작성하는 데 사용되는 찾아보기 오브젝트 의 찾아 &lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;보기 클래스&lt;/a&gt; 에 &quot;바인드&quot;됩니다 . 기본 메소드가 공용 인 경우에도 ( &lt;code&gt;Class.forName&lt;/code&gt; 과 같은 ) 다른 조회 클래스로이 메소드 핸들을 크래킹하면 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="315e1d5687f0be0717ab38a86bf5bdc38d92fd67" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, Second Edition, section 15.12.4.4; in particular, overriding based on the runtime type of the target object will occur.</source>
          <target state="translated">기본 메소드가 인스턴스 메소드 인 경우 The Java Language Specification, Second Edition, 섹션 15.12.4.4에 설명 된대로 동적 메소드 조회를 사용하여 호출됩니다. 특히 대상 객체의 런타임 유형에 따라 재정의가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5b1ed6ee8640dbbd801323bd87c98b861047134d" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, section 15.12.4.4; in particular, overriding based on the runtime type of the target object may occur.</source>
          <target state="translated">기본 메서드가 인스턴스 메서드 인 경우 Java 언어 사양, 섹션 15.12.4.4에 설명 된대로 동적 메서드 조회를 사용하여 호출됩니다. 특히 대상 개체의 런타임 유형에 따라 재정의가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fdc5865953923b940ef228e2839e6291e6d1529" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, the class that declared the method is initialized if it has not already been initialized.</source>
          <target state="translated">기본 메소드가 정적 인 경우 메소드를 선언 한 클래스는 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5417f1946175b0c601b43e5b5d82e2dfa1a39a1f" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, then the specified &lt;code&gt;obj&lt;/code&gt; argument is ignored. It may be null.</source>
          <target state="translated">기본 메소드가 정적이면 지정된 &lt;code&gt;obj&lt;/code&gt; 인수가 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baee3bb7bafb1339b8300d582f80c05c628c3c7f" translate="yes" xml:space="preserve">
          <source>If the underlying model of the &lt;code&gt;RowSorter&lt;/code&gt; differs from that of this &lt;code&gt;JTable&lt;/code&gt; undefined behavior will result.</source>
          <target state="translated">&lt;code&gt;RowSorter&lt;/code&gt; 의 기본 모델 이이 &lt;code&gt;JTable&lt;/code&gt; 의 모델 과 다른 경우 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dae88d15741d2fff1d10727455001428453c69fc" translate="yes" xml:space="preserve">
          <source>If the underlying model structure changes (the &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by column, current sort order, and whether each column is sortable. The default sort order is natural (the same as the model), and columns are sortable by default.</source>
          <target state="translated">기본 모델 구조가 변경되면 ( &lt;code&gt;modelStructureChanged&lt;/code&gt; 메서드가 호출 됨) 다음이 기본값으로 재설정됩니다. &lt;code&gt;Comparator&lt;/code&gt; s by column, current sort order, and whether each column is sortable. 기본 정렬 순서는 자연스럽고 (모델과 동일) 기본적으로 열을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9883703230204600dade0bca3c6ef6ed2362790c" translate="yes" xml:space="preserve">
          <source>If the underlying model structure changes (the &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by column, current sort order, and whether each column is sortable. To find the default &lt;code&gt;Comparator&lt;/code&gt;s, see the concrete implementation (for example, &lt;a href=&quot;table/tablerowsorter&quot;&gt;&lt;code&gt;TableRowSorter&lt;/code&gt;&lt;/a&gt;). The default sort order is unsorted (the same as the model), and columns are sortable by default.</source>
          <target state="translated">기본 모델 구조가 변경되면 ( &lt;code&gt;modelStructureChanged&lt;/code&gt; 메서드가 호출 됨) 다음이 기본값으로 재설정됩니다. &lt;code&gt;Comparator&lt;/code&gt; s by column, current sort order, and whether each column is sortable. 기본 &lt;code&gt;Comparator&lt;/code&gt; 를 찾으려면 구체적인 구현 (예 : &lt;a href=&quot;table/tablerowsorter&quot;&gt; &lt;code&gt;TableRowSorter&lt;/code&gt; &lt;/a&gt; ) 을 참조하십시오 . 기본 정렬 순서는 정렬되지 않으며 (모델과 동일) 기본적으로 열을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9921e56a78b932a99ec7c118f676e37975b2d1c9" translate="yes" xml:space="preserve">
          <source>If the underlying platform has a &quot;native&quot; look and feel, and this is an implementation of it, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기본 플랫폼에 &quot;기본&quot;모양과 느낌이 있고 이것이 구현 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="afbbef7a28945de7e4c59f1f0a920532651223f3" translate="yes" xml:space="preserve">
          <source>If the underlying platform has a &quot;native&quot; look and feel, and this is an implementation of it, return &lt;code&gt;true&lt;/code&gt;. For example, when the underlying platform is Solaris running CDE a CDE/Motif look and feel implementation would return &lt;code&gt;
 true&lt;/code&gt;.</source>
          <target state="translated">기본 플랫폼에 &quot;기본&quot;모양과 느낌이 있고 이것이 구현 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 예를 들어, 기본 플랫폼이 CDE를 실행하는 Solaris 인 경우 CDE / Motif 룩앤필 구현은 &lt;code&gt; true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2221ca8e8e96c757d1acb4e9dea9f2b5398db497" translate="yes" xml:space="preserve">
          <source>If the unit is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported units are:</source>
          <target state="translated">단위가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. 지원되는 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd8d281301aa1d20e9a67171d9933765d4124562" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; ,이 방법의 결과를 호출하는 것에 의해 획득된다 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 전달하는 &lt;code&gt;this&lt;/code&gt; 첫번째 인자로.</target>
        </trans-unit>
        <trans-unit id="6f71bc9db5b6219e1ae283e954d88ba321dd8591" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument and the converted input temporal as the second argument.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; 호출함으로써 얻어지는,이 방법의 다음 결과 &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; 통과하는 &lt;code&gt;this&lt;/code&gt; 첫번째 인수와 두 번째 인수로 변환 된 입력 시간있다.</target>
        </trans-unit>
        <trans-unit id="66bc82b1dd235049a5511719d85e81950af05fd7" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the unit is supported is determined by the unit.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 하여 인수로 . 장치가 지원되는지 여부는 장치에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="906c58bb1f6e7950ac3b30334d2bb84e89a6b83b" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The characters &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;) and &lt;code&gt;
 '1'&lt;/code&gt; (&lt;code&gt;'\u0031'&lt;/code&gt;) are used as binary digits.</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자가 0 문자가 아닙니다. 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; ) 및 &lt;code&gt; '1'&lt;/code&gt; ( &lt;code&gt;'\u0031'&lt;/code&gt; )은 이진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20661569ddc05848e0dfeb41e06e5676e4ccca6a" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The characters &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;) and &lt;code&gt;'1'&lt;/code&gt; (&lt;code&gt;'\u0031'&lt;/code&gt;) are used as binary digits.</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; ) 및 &lt;code&gt;'1'&lt;/code&gt; ( &lt;code&gt;'\u0031'&lt;/code&gt; )은 이진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c10c42689b734462a910f9cd90fb2d17103287f1" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as hexadecimal digits:</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 문자는 16 진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f07ca050a4a81c4b683387f3c53d9089c379035d" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as octal digits:</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 문자는 8 진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ffd8f31b308ededd50592fa98b7b8942dd2be329" translate="yes" xml:space="preserve">
          <source>If the user cancels the dialog, the returned attributes will not reflect any changes made by the user.</source>
          <target state="translated">사용자가 대화 상자를 취소하면 반환 된 속성은 사용자가 변경 한 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb6714e942d1212dc9686ac25a627707c330ee39" translate="yes" xml:space="preserve">
          <source>If the user cancels the dialog, the returned attributes will not reflect any changes made by the user. A typical basic usage of this method may be :</source>
          <target state="translated">사용자가 대화 상자를 취소하면 반환 된 속성에 사용자가 변경 한 내용이 반영되지 않습니다. 이 방법의 일반적인 기본 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7208f9f9b8096f5bc1e213faa64052c112ef12fa" translate="yes" xml:space="preserve">
          <source>If the user cancels the file dialog, then the method returns an empty array.</source>
          <target state="translated">사용자가 파일 대화 상자를 취소하면 메서드는 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="de0b9944a16bfd19e85e0670561c553ba7b1eeb4" translate="yes" xml:space="preserve">
          <source>If the user doesn't select a drop action, the set of &lt;code&gt;DnDConstants&lt;/code&gt; that represents the set of drop actions supported by the drag source is searched for &lt;code&gt;DnDConstants.ACTION_MOVE&lt;/code&gt;, then for &lt;code&gt;DnDConstants.ACTION_COPY&lt;/code&gt;, then for &lt;code&gt;DnDConstants.ACTION_LINK&lt;/code&gt; and the</source>
          <target state="translated">사용자가 드롭 액션을 선택하지 않는 경우, 세트 &lt;code&gt;DnDConstants&lt;/code&gt; 어떤 드래그 소스로 지원되고있는 일련의 드롭 액션을 나타내는를 검색합니다 &lt;code&gt;DnDConstants.ACTION_MOVE&lt;/code&gt; 다음에, &lt;code&gt;DnDConstants.ACTION_COPY&lt;/code&gt; , 다음에 대한 &lt;code&gt;DnDConstants.ACTION_LINK&lt;/code&gt; 가 와</target>
        </trans-unit>
        <trans-unit id="93c5fdab4572abcb9f84bc6e6f772f374b7d5ea5" translate="yes" xml:space="preserve">
          <source>If the user has previously selected an input method or keyboard layout for the requested locale from the user interface, then the most recently selected such input method or keyboard layout is reselected.</source>
          <target state="translated">사용자가 이전에 사용자 인터페이스에서 요청 된 로케일에 대한 입력 방법 또는 키보드 레이아웃을 선택한 경우 가장 최근에 선택한 해당 입력 방법 또는 키보드 레이아웃이 다시 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3ff22bd71bfe0f9cb8dffa032e252c7a72a011" translate="yes" xml:space="preserve">
          <source>If the user provides an &lt;code&gt;RMIServerImpl&lt;/code&gt; rather than a &lt;code&gt;JMXServiceURL&lt;/code&gt;, then the generated &lt;code&gt;JMXServiceURL&lt;/code&gt; will have the local host name in its &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; part and no &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 가 &lt;code&gt;JMXServiceURL&lt;/code&gt; 대신 &lt;code&gt;RMIServerImpl&lt;/code&gt; 을 제공하면 생성 된 &lt;code&gt;JMXServiceURL&lt;/code&gt; 의 &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; 부분 에 로컬 호스트 이름이 있고 &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; 없습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c751f889067dd8cb1ad34d217d14ea94b60a4ea0" translate="yes" xml:space="preserve">
          <source>If the user selects a drop action, the</source>
          <target state="translated">사용자가 놓기 동작을 선택하면</target>
        </trans-unit>
        <trans-unit id="790177d5a2da0339061b07b0e2796a63d5c7bba4" translate="yes" xml:space="preserve">
          <source>If the user wants to represent more complex relations, involving properties and/or methods, he has to provide his own class implementing the Relation interface. This can be achieved either by inheriting from RelationSupport class, or by implementing the interface (fully or delegation to a RelationSupport object member).</source>
          <target state="translated">사용자가 속성 및 / 또는 메서드와 관련된보다 복잡한 관계를 나타내려면 Relation 인터페이스를 구현하는 고유 한 클래스를 제공해야합니다. RelationSupport 클래스에서 상속하거나 인터페이스를 구현하거나 (RelationSupport 개체 멤버에게 완전 또는 위임) 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e426a67bb1131fd615e1eb1f3e1e7dddce68bf0" translate="yes" xml:space="preserve">
          <source>If the value at the anchor index is not selected, do the same thing in reverse selecting values in the old range and deselecting values in the new one.</source>
          <target state="translated">앵커 인덱스의 값이 선택되지 않은 경우 이전 범위의 값을 반대로 선택하고 새 범위의 값을 선택 취소하는 것과 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2d22c3736384d8f57852c160122995e97ee6f65b" translate="yes" xml:space="preserve">
          <source>If the value cannot be obtained then an exception will be thrown. If the value is negative an exception will be thrown. If the field does not have a fixed set of valid values then an exception will be thrown. If the field value in the date-time to be printed is invalid it cannot be printed and an exception will be thrown.</source>
          <target state="translated">값을 얻을 수 없으면 예외가 발생합니다. 값이 음수이면 예외가 발생합니다. 필드에 고정 된 유효한 값 세트가 없으면 예외가 발생합니다. 인쇄 할 날짜-시간의 필드 값이 유효하지 않으면 인쇄 할 수 없으며 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ee0cd8b8e0f022dac140b1064202354f2993085" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.</source>
          <target state="translated">지정된 키의 값이 존재하고 널이 아닌 경우 키와 현재 맵핑 된 값이 주어지면 새 맵핑을 계산하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ecdf413c04b1da892ae0fa943003fe90e373d5c1" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value.</source>
          <target state="translated">지정된 키의 값이있는 경우 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4b761882d9981acf5026d5923e5e847a58120eb7" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">지정된 키의 값이 있으면 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산하려고 시도합니다. 전체 메소드 호출은 원자 적으로 수행됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 단순해야하며이 맵의 다른 매핑을 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f3db5a9e74f7891f194526ea0f347239e63fa2ef" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">지정된 키의 값이 있으면 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산하려고 시도합니다. 기능이 &lt;em&gt;아닙니다&lt;/em&gt; 원자 적으로 한 번만 적용되는 .</target>
        </trans-unit>
        <trans-unit id="c5e8a168b387e1a676dd90915381d221d843a6ab" translate="yes" xml:space="preserve">
          <source>If the value in the designated column has a custom mapping, this method returns the name of the class that implements &lt;code&gt;SQLData&lt;/code&gt;. When the method &lt;code&gt;ResultSet.getObject&lt;/code&gt; is called to retrieve a value from the designated column, it will create an instance of this class or one of its subclasses.</source>
          <target state="translated">지정된 열의 값에 사용자 지정 매핑이있는 경우이 메서드는 &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스의 이름을 반환합니다 . 지정된 열에서 값을 검색하기 위해 &lt;code&gt;ResultSet.getObject&lt;/code&gt; 메소드 가 호출 되면 이 클래스 또는 하위 클래스 중 하나의 인스턴스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="76a62dcfb0cff96625fd935bd1e2f63de3a120f6" translate="yes" xml:space="preserve">
          <source>If the value is 0, this means to wait indefinitely.</source>
          <target state="translated">값이 0이면 무기한 대기한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="0de4492c54d50e85bf0da62b3577996044c41c74" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;non-null&lt;/code&gt;, it is returned. If the value of the default &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and the value of the default &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt;, an &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created and populated. Population is done by iterating over each of the elements of the &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; array, and invoking &lt;code&gt;createAudioAction()&lt;/code&gt; to create an &lt;code&gt;
 Action&lt;/code&gt; for each element. The resulting &lt;code&gt;Action&lt;/code&gt; is placed in the &lt;code&gt;ActionMapUIResource&lt;/code&gt;, using the array element as the key. For example, if the &lt;code&gt;
 &quot;AuditoryCues.cueList&quot;&lt;/code&gt; array contains a single-element, &lt;code&gt;
 &quot;audioKey&quot;&lt;/code&gt;, the &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created, then populated by way of &lt;code&gt;actionMap.put(cueList[0],
 createAudioAction(cueList[0]))&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;non-null&lt;/code&gt; 이 아닌 경우 반환됩니다. 기본 값 경우 &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 과 기본 값 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 입니다 &lt;code&gt;non-null&lt;/code&gt; AN, &lt;code&gt;ActionMapUIResource&lt;/code&gt; 가 작성되고 채워집니다. 채우기는 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 배열 의 각 요소를 반복하고 &lt;code&gt;createAudioAction()&lt;/code&gt; 을 호출 하여 각 요소에 대한 &lt;code&gt; Action&lt;/code&gt; 을 생성하여 수행 됩니다. 결과 &lt;code&gt;Action&lt;/code&gt; 은 배열 요소를 키로 사용하여 &lt;code&gt;ActionMapUIResource&lt;/code&gt; 에 배치됩니다 . 예를 들어 경우 &lt;code&gt; &quot;AuditoryCues.cueList&quot;&lt;/code&gt; 배열은 단일 요소 &lt;code&gt; &quot;audioKey&quot;&lt;/code&gt; , &lt;code&gt;ActionMapUIResource&lt;/code&gt; 가 생성 된 다음 &lt;code&gt;actionMap.put(cueList[0], createAudioAction(cueList[0]))&lt;/code&gt; 을 통해 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="301076cf0d84829c80ed3ada45bc0a362fb8a4d9" translate="yes" xml:space="preserve">
          <source>If the value is NaN or infinite, the literal strings &quot;NaN&quot; or &quot;Infinity&quot;, respectively, will be output.</source>
          <target state="translated">값이 NaN 또는 무한이면 리터럴 문자열 &quot;NaN&quot;또는 &quot;Infinity&quot;가 각각 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="ab06ef8615a9271c661fe8e0122f8b8d95f1110e" translate="yes" xml:space="preserve">
          <source>If the value is NaN or positive infinity the literal strings &quot;NaN&quot; or &quot;Infinity&quot; respectively, will be output. If the value is negative infinity, then the output will be &quot;(Infinity)&quot; if the &lt;code&gt;'('&lt;/code&gt; flag is given otherwise the output will be &quot;-Infinity&quot;. These values are not localized.</source>
          <target state="translated">값이 NaN 또는 양의 무한대 인 경우 리터럴 문자열 &quot;NaN&quot;또는 &quot;Infinity&quot;가 각각 출력됩니다. 값이 음의 무한대이면 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공 되면 출력은 &quot;(무한대)&quot;가되고 그렇지 않으면 출력은 &quot;-무한대&quot;가됩니다 .이 값은 현지화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0835f0832141e69a77792c43ed4cdb23fe77095b" translate="yes" xml:space="preserve">
          <source>If the value is a URN, the &lt;code&gt;href&lt;/code&gt; attribute is recognized as a &lt;code&gt;publicId&lt;/code&gt;, and used to search &lt;code&gt;public&lt;/code&gt; entries. If the value is a URI, it is taken as a &lt;code&gt;systemId&lt;/code&gt;, and used to search both &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;uri&lt;/code&gt; entries.</source>
          <target state="translated">값이 URN 인 경우 &lt;code&gt;href&lt;/code&gt; 속성은 &lt;code&gt;publicId&lt;/code&gt; 로 인식되고 &lt;code&gt;public&lt;/code&gt; 항목 을 검색하는 데 사용됩니다 . 값이 URI이면 &lt;code&gt;systemId&lt;/code&gt; 로 간주 되며 &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;uri&lt;/code&gt; 항목을 모두 검색하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8386f5e063110a495ec4902ded50dbabab418fe" translate="yes" xml:space="preserve">
          <source>If the value is negative (or floating-point negative zero) and &lt;code&gt;'('&lt;/code&gt; flag is not given, then a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;) is prepended.</source>
          <target state="translated">값이 음수 (또는 부동 소수점 음수 0)이고 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공되지 않은 경우 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002d'&lt;/code&gt; )가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="6f6d817a3f4c5b41b572c9b2e4daf5c4281d9fee" translate="yes" xml:space="preserve">
          <source>If the value is negative and the &lt;code&gt;'('&lt;/code&gt; flag is given, then a &lt;code&gt;'('&lt;/code&gt; (&lt;code&gt;'\u0028'&lt;/code&gt;) is prepended and a &lt;code&gt;')'&lt;/code&gt; (&lt;code&gt;'\u0029'&lt;/code&gt;) is appended.</source>
          <target state="translated">값이 음수이고 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공되면 &lt;code&gt;'('&lt;/code&gt; ( &lt;code&gt;'\u0028'&lt;/code&gt; )이 앞에 붙고 &lt;code&gt;')'&lt;/code&gt; ( &lt;code&gt;'\u0029'&lt;/code&gt; )이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="79c5db2353984efc6cb7e1c18940f5eb527e5ef9" translate="yes" xml:space="preserve">
          <source>If the value is negative, then it represents the number of days back from the end of the month where &lt;code&gt;-1&lt;/code&gt; is the last day of the month. In this case, the day identified is the latest possible date that the transition can be.</source>
          <target state="translated">값이 음수 &lt;code&gt;-1&lt;/code&gt; 은 달 의 마지막 날인 달의 끝에서 되돌아온 일 수를 나타냅니다 . 이 경우 식별 된 날짜는 전환이 가능한 최신 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="a221fc4de816cd6c7effceee4131da4c33e0f4df" translate="yes" xml:space="preserve">
          <source>If the value is not of the proper type, the attribute will be ignored.</source>
          <target state="translated">값이 적절한 유형이 아니면 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a89c880bd0c92196eb9e203f110acd320c2580c9" translate="yes" xml:space="preserve">
          <source>If the value is positive, then it represents a normal day-of-month, and is the earliest possible date that the transition can be. The date may refer to 29th February which should be treated as 1st March in non-leap years.</source>
          <target state="translated">값이 양수이면 정상 일을 나타내며 전환이 가능한 가장 빠른 날짜입니다. 날짜는 2 월 29 일을 의미 할 수 있으며 이는 윤년이 아닌 경우 3 월 1 일로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3334ef34b1cd3c138c012c02960e8363c7beb397" translate="yes" xml:space="preserve">
          <source>If the value is set to &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e02310a0ea5559eabc6294ef56491025a14c4eb6" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; is beyond the bounds of the text, it is ignored. When &lt;code&gt;setAction&lt;/code&gt; is called, if the value from the &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the displayed mnemonic index is not updated. In any subsequent changes to &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is treated as -1.</source>
          <target state="translated">&lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; 의 값이 텍스트의 범위를 벗어나면 무시됩니다. &lt;code&gt;setAction&lt;/code&gt; 이 호출 될 때 &lt;code&gt;Action&lt;/code&gt; 의 값 이 &lt;code&gt;null&lt;/code&gt; 이면 표시된 니모닉 인덱스가 업데이트되지 않습니다. &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; 에 대한 후속 변경 에서 &lt;code&gt;null&lt;/code&gt; 은 -1로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="22c60f3a7542e4a41034dd5216a61c3aba7c36d9" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Border&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Border&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eba252138c8090a37a788c71e19e8a3cb0276356" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Color&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Color&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="367d8e2f0ca28a2ea644636137ef64c997bec18b" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Dimension&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Dimension&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2be0d9b17a5e47e7e93a2913690292ed9a69b7ff" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Font&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Font&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c67916533b9dbb5dc83f598e1e6382427cd552f9" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;String&lt;/code&gt; 반환 그것은 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d2bfc7c723ba35a6fcf6c4b6137b4f780a0b3de" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Icon&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; 입니다 &lt;code&gt;Icon&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab2d62c2054fc3fa0f8b523b4eab33e78eb557e0" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Insets&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; 입니다 &lt;code&gt;Insets&lt;/code&gt; 반환, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0260b2e58bbf30b3665cb0865cc9a91961481c68" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Integer&lt;/code&gt; return its integer value, otherwise return 0.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; 있는 &lt;code&gt;Integer&lt;/code&gt; , 그렇지 않으면 0을 반환, 그 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6474e2edb69dbe8cb6a10bd386064bfd71534a0" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is boolean, return the boolean value, otherwise return false.</source>
          <target state="translated">주어진 &lt;code&gt;Locale&lt;/code&gt; 의 &lt;code&gt;key&lt;/code&gt; 값 이 부울이면 부울 값을 반환하고 그렇지 않으면 거짓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b6d5bd5fca8a25f1dd49217534639ed2ffe7fe4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Border&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Border&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3be018e83c846fe1b30aea1f6bf6ccf6c10c541" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Color&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Color&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8b42e483eff7d7568eb7eb3163a2f5cbbf4c96" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Dimension&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Dimension&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5785760f42f1977942d08aa328b366f8fc0db0e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Font&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Font&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4141012d327f30dfb544d88d4209e96defccecb8" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;String&lt;/code&gt; 반환 그것은 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ba848583bb0ce0d7c9675fd82c19e9dbc0309d4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Icon&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 입니다 &lt;code&gt;Icon&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eba09aea4ed9d543ab5701573b6ee8091b5b8904" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Insets&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 입니다 &lt;code&gt;Insets&lt;/code&gt; 반환, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5234ac47786667f30dde0ed0ff67d97ce01bff63" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Integer&lt;/code&gt; return its integer value, otherwise return 0.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 입니다 &lt;code&gt;Integer&lt;/code&gt; 는 그 정수 값을 반환, 그렇지 않은 경우는 0을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="f45a7d95af981044e17417d792efc75f1ad87858" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is boolean, return the boolean value, otherwise return false.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 값 이 부울이면 부울 값을 반환하고 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="43c44811372338e5d89625fd7f4ec1fe65b36ee4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;load&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this method starts loading any images that are not yet being loaded.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 값 이 &lt;code&gt;true&lt;/code&gt; 이면 이 메서드는 아직로드되지 않은 이미지로드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f6fe9c920cf87a3961283663010d0cc7faf04891" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;LOAD&lt;/code&gt;, then the file dialog is finding a file to read, and the files shown are those in the current directory. If the value of &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;SAVE&lt;/code&gt;, the file dialog is finding a place to write a file.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 값 이 &lt;code&gt;LOAD&lt;/code&gt; 이면 파일 대화 상자가 읽을 파일을 찾고 표시된 파일은 현재 디렉토리에있는 파일입니다. &lt;code&gt;mode&lt;/code&gt; 값 이 &lt;code&gt;SAVE&lt;/code&gt; 이면 파일 대화 상자가 파일을 쓸 위치를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a25b68c044cd0c1ec4edc8c60c29d6185e1c049" translate="yes" xml:space="preserve">
          <source>If the value of a field is not a String, then the toString() method will be called on it and the returned value, enclosed in parentheses, used as the value for the field in the returned array. If the value of a field is null, then the value of the field in the returned array will be empty. If the descriptor is empty, you will get an empty array.</source>
          <target state="translated">필드의 값이 문자열이 아니면 toString () 메소드가 호출되고 괄호로 묶인 리턴 값이 리턴 된 배열의 필드 값으로 사용됩니다. 필드 값이 null이면 반환 된 배열의 필드 값이 비어 있습니다. 디스크립터가 비어 있으면 빈 배열을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="3c88da9b0c956884891afc187b29ac9d1d3914af" translate="yes" xml:space="preserve">
          <source>If the value of that system property is not &lt;code&gt;null&lt;/code&gt;, it is interpreted as a list of packages separated by a vertical slash character '&lt;code&gt;|&lt;/code&gt;'. The constructor tries to load the class named:</source>
          <target state="translated">이 시스템 프로퍼티의 값이없는 경우 &lt;code&gt;null&lt;/code&gt; 패키지 목록은 수직 슬래시 문자 '로 구분으로,이 해석 &lt;code&gt;|&lt;/code&gt; '. 생성자는 다음과 같은 이름의 클래스를로드하려고합니다.</target>
        </trans-unit>
        <trans-unit id="189b2a483106b850cb5a3377c0425a501b7adcff" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;len&lt;/code&gt; parameter is negative then no characters are written. This is contrary to the specification of this method in the &lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;superclass&lt;/a&gt;, which requires that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 매개 변수 의 값 이 음수이면 문자가 기록되지 않습니다. 이것은 &lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;수퍼 클래스&lt;/a&gt; 에서이 메소드의 스펙과 상반 되므로 &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; &lt;/a&gt; 이 발생 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8a175ebc49437ed81722116dff77ef058a7b66c3" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;load&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then this method starts loading any images that are not yet being loaded.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 플래그 의 값 이 &lt;code&gt;true&lt;/code&gt; 이면 이 메서드는 아직로드되지 않은 이미지로드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b153c1760d762182820a11651725f26d981a5d3a" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;preferredWidth&lt;/code&gt; property is less than the new minimum width, this method sets that property to the new minimum width.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;preferredWidth&lt;/code&gt; 속성 값이 새 최소 너비보다 작 으면이 메서드는 해당 속성을 새 최소 너비로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d3222faa7f28cca7505e3db00febf3a73dfdf614" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;preferredWidth&lt;/code&gt; property is more than the new maximum width, this method sets that property to the new maximum width.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;preferredWidth&lt;/code&gt; 속성 값이 새 최대 너비보다 크면이 메서드는 해당 속성을 새 최대 너비로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1faf4afd4927c3eff93f389c43a673f5145f1898" translate="yes" xml:space="preserve">
          <source>If the value of the default &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and the value of the default &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, an empty &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created.</source>
          <target state="translated">기본 값 경우 &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 과 기본 값 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 빈, &lt;code&gt;ActionMapUIResource&lt;/code&gt; 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="677e23258402aae540c1aad5d995a866d4b392f9" translate="yes" xml:space="preserve">
          <source>If the value of the system property is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt; is converted to a &lt;a href=&quot;../nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; object named &lt;code&gt;npath&lt;/code&gt; after &lt;a href=&quot;../nio/file/path#normalize()&quot;&gt;&lt;code&gt;normalization&lt;/code&gt;&lt;/a&gt;. No canonicalization is performed which means the underlying file system is not accessed. If an &lt;a href=&quot;../nio/file/invalidpathexception&quot;&gt;&lt;code&gt;InvalidPathException&lt;/code&gt;&lt;/a&gt; is thrown during the conversion, this &lt;code&gt;FilePermission&lt;/code&gt; will be labeled as invalid.</source>
          <target state="translated">시스템 속성의 값이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 &lt;code&gt;path&lt;/code&gt; 는 &lt;a href=&quot;../nio/file/path#normalize()&quot;&gt; &lt;code&gt;normalization&lt;/code&gt; &lt;/a&gt; 후 &lt;code&gt;npath&lt;/code&gt; 라는 이름 의 &lt;a href=&quot;../nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 개체 로 변환됩니다 . 정규화가 수행되지 않으므로 기본 파일 시스템에 액세스 할 수 없습니다. 는 IF &lt;a href=&quot;../nio/file/invalidpathexception&quot;&gt; &lt;code&gt;InvalidPathException&lt;/code&gt; 가&lt;/a&gt; 변환하는 동안 발생합니다,이 &lt;code&gt;FilePermission&lt;/code&gt; 를 1 개씩 무효로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3cf19c572562cc39301cdc9457c2f8ef2d7a44" translate="yes" xml:space="preserve">
          <source>If the value of the system property is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt; is canonicalized and stored as a String object named &lt;code&gt;cpath&lt;/code&gt;. This means a relative path is converted to an absolute path, a Windows DOS-style 8.3 path is expanded to a long path, and a symbolic link is resolved to its target, etc.</source>
          <target state="translated">시스템 속성 값이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 &lt;code&gt;path&lt;/code&gt; 가 정규화되고 &lt;code&gt;cpath&lt;/code&gt; 라는 문자열 개체로 저장됩니다 . 이것은 상대 경로가 절대 경로로 변환되고 Windows DOS 스타일 8.3 경로가 긴 경로로 확장되고 심볼릭 링크가 대상으로 확인된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9bbd078cde15abb1e52c1f5b43c7ab7eadad9320" translate="yes" xml:space="preserve">
          <source>If the value of this attribute specifies a date-time that is in the future, the printer should add the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, must move the job to the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, and must not schedule the job for printing until the specified date-time arrives.</source>
          <target state="translated">이 속성 값이 미래의 날짜-시간을 지정하는 경우 프린터는 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; 를 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가하고 작업을 &lt;code&gt;PENDING_HELD&lt;/code&gt; 상태 로 이동해야 하며 다음 날짜 까지 인쇄 작업을 예약하지 않아야합니다. 지정된 날짜-시간이 도착합니다.</target>
        </trans-unit>
        <trans-unit id="3351a4cf5b5a7a09cdd906eb6fad0d706861c179" translate="yes" xml:space="preserve">
          <source>If the value of this attribute specifies a date-time that is in the future, the printer should add the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of JOB_HOLD_UNTIL_SPECIFIED to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, must move the job to the PENDING_HELD state, and must not schedule the job for printing until the specified date-time arrives.</source>
          <target state="translated">이 속성 값이 미래의 날짜 시간을 지정하는 경우 프린터는 JOB_HOLD_UNTIL_SPECIFIED 의 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 값을 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가하고 작업을 PENDING_HELD 상태로 이동해야하며 인쇄 작업을 예약하지 않아야합니다. 지정된 날짜-시간이 도착합니다.</target>
        </trans-unit>
        <trans-unit id="48a7960d847d0c7897f06eee9795f35f60cafa1b" translate="yes" xml:space="preserve">
          <source>If the value property of this instance is not already set, this method dynamically finds the method with the specified methodName on this target with these arguments and calls it.</source>
          <target state="translated">이 인스턴스의 값 속성이 아직 설정되지 않은 경우이 메서드는 이러한 인수를 사용하여이 대상에서 지정된 methodName을 가진 메서드를 동적으로 찾아 호출합니다.</target>
        </trans-unit>
        <trans-unit id="fa55bedef91ce7d9c1fec0b52fe91e9615e15668" translate="yes" xml:space="preserve">
          <source>If the value property of this instance is not already set, this method dynamically finds the method with the specified methodName on this target with these arguments and calls it. The result of the method invocation is first copied into the value property of this expression and then returned as the result of &lt;code&gt;getValue&lt;/code&gt;. If the value property was already set, either by a call to &lt;code&gt;setValue&lt;/code&gt; or a previous call to &lt;code&gt;getValue&lt;/code&gt; then the value property is returned without either looking up or calling the method.</source>
          <target state="translated">이 인스턴스의 value 속성이 아직 설정되지 않은 경우이 메서드는이 인수를 사용하여이 대상에서 지정된 methodName이있는 메서드를 동적으로 찾아 호출합니다. 메소드 호출의 결과는 &lt;code&gt;getValue&lt;/code&gt; 표현식의 value 특성에 복사 된 후 getValue 의 결과로 리턴됩니다 . &lt;code&gt;setValue&lt;/code&gt; 에 대한 호출 또는 &lt;code&gt;getValue&lt;/code&gt; 에 대한 이전 호출에 의해 값 특성이 이미 설정된 경우 값 특성은 메소드를 찾거나 호출하지 않고 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f8f305677180b918ee9ef198861d8afd741517" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; of names. Each name is a &lt;code&gt;String&lt;/code&gt; or a byte array representing a distinguished name (in RFC 2253 or ASN.1 DER encoded form, respectively). Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names.</source>
          <target state="translated">반환 값이 &lt;code&gt;null&lt;/code&gt; 가 아닌 경우는 이름 의 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 이름은 고유 이름을 나타내는 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열입니다 (각각 RFC 2253 또는 ASN.1 DER로 인코딩 된 형식). 반환 된 &lt;code&gt;Collection&lt;/code&gt; 에 중복 된 이름이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d32dd70eeac4617e75643e7232c7906050d5b2bd" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the pathToNames criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 , 이는 pathToNames 기준에 포함 할 각 이름에 대해 하나의 항목 이있는 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 같은 유형의 이름이 여러 개있을 수 있습니다. 반환 된 &lt;code&gt;Collection&lt;/code&gt; 은 중복 된 이름 (동일한 이름과 이름 유형)을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d26bd3763c8755d23c2f1916d343c204ac5aaffe" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the subject alternative name criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, 주제 대체 이름 기준에 포함 할 각 이름에 대해 하나의 항목 이있는 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 같은 유형의 이름이 여러 개있을 수 있습니다. 반환 된 &lt;code&gt;Collection&lt;/code&gt; 은 중복 된 이름 (동일한 이름과 이름 유형)을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="174489e8b5c4498b78d97a375b5ea6bab3a43a71" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="06d0b31d05f2e63feb86aed4d9a330fd81f56f90" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setSubject(byte%5B%5D)&quot;&gt;&lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setSubject(byte%5B%5D)&quot;&gt; &lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2adc8f493111a0124aaa2df328143a9d50bda6b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, X.501에 정의 된 단일 DER 인코딩 식별 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 문서에 제공되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5bfe0070c603a52728ff84ece5362c0b7ddae9b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt;&lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, X.501에 정의 된 단일 DER 인코딩 식별 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt; &lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce45de7cc21b8ac51cf0ba8fa224985e1d61a9e9" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a distinguished name, in RFC 2253 format.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우는 RFC 2253 형식의 식별 명입니다.</target>
        </trans-unit>
        <trans-unit id="5b8d5b4ce751bcbd27dc2db355066e723ecb44dc" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a unmodifiable &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X500Principal&lt;/code&gt;s.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 가 아닌 경우, 수정 불가능한 &lt;code&gt;X500Principal&lt;/code&gt; &lt;code&gt;Collection&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="6566f72aa07086a575c5856c5262b23d64492e56" translate="yes" xml:space="preserve">
          <source>If the value specified to this method is greater than the maximum length for the property the driver may either truncate the value and generate a warning or generate a &lt;code&gt;SQLClientInfoException&lt;/code&gt;. If the driver generates a &lt;code&gt;SQLClientInfoException&lt;/code&gt;, the value specified was not set on the connection.</source>
          <target state="translated">이 메서드에 지정된 값이 속성의 최대 길이보다 큰 경우 드라이버는 값을 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 경고를 생성하거나 SQLClientInfoException을 생성 할 수 있습니다. 드라이버가 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 을 생성하면 지정된 값이 연결에 설정되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="751e6d0216d0808c1e052a74a279b7c68e16f026" translate="yes" xml:space="preserve">
          <source>If the value supplied is less than the current &lt;code&gt;minimum&lt;/code&gt; or greater than the current &lt;code&gt;maximum - visibleAmount&lt;/code&gt;, then either &lt;code&gt;minimum&lt;/code&gt; or &lt;code&gt;maximum - visibleAmount&lt;/code&gt; is substituted, as appropriate.</source>
          <target state="translated">주어진 값 이하이면 현재보다 &lt;code&gt;minimum&lt;/code&gt; 전류보다 큰 또는 &lt;code&gt;maximum - visibleAmount&lt;/code&gt; , 다음 중 &lt;code&gt;minimum&lt;/code&gt; 또는 &lt;code&gt;maximum - visibleAmount&lt;/code&gt; 적절히 치환된다.</target>
        </trans-unit>
        <trans-unit id="12fe3656fcca79e989b3edac8aeb79cce5390758" translate="yes" xml:space="preserve">
          <source>If the value supplied is less than the current minimum or greater than the current maximum, then one of those values is substituted, as appropriate.</source>
          <target state="translated">제공된 값이 현재 최소값보다 작거나 현재 최대 값보다 큰 경우 해당 값 중 하나가 적절하게 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ab17023ef639bf29e49c32902183016851239f29" translate="yes" xml:space="preserve">
          <source>If the values of the width and height arguments are both &lt;code&gt;-1&lt;/code&gt;, this method prepares the image for rendering on the default screen; otherwise, this method prepares an image for rendering on the default screen at the specified width and height.</source>
          <target state="translated">너비 및 높이 인수의 값이 모두 &lt;code&gt;-1&lt;/code&gt; 이면이 메서드는 기본 화면에서 렌더링 할 이미지를 준비합니다. 그렇지 않으면이 메서드는 지정된 너비와 높이로 기본 화면에 렌더링 할 이미지를 준비합니다.</target>
        </trans-unit>
        <trans-unit id="062fc19b785fff8baef488c9df986bc3034c7cd8" translate="yes" xml:space="preserve">
          <source>If the values of the width and height arguments are both &lt;code&gt;-1&lt;/code&gt;, this method returns the construction status of a screen representation of the specified image in this toolkit. Otherwise, this method returns the construction status of a scaled representation of the image at the specified width and height.</source>
          <target state="translated">너비 및 높이 인수의 값이 모두 &lt;code&gt;-1&lt;/code&gt; 이면이 메서드는이 툴킷에서 지정된 이미지의 화면 표현 구성 상태를 반환합니다. 그렇지 않으면이 메서드는 지정된 너비와 높이에서 이미지의 크기가 조정 된 표현의 구성 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31962e30b961885e15e6a668db59bf31ea069bcf" translate="yes" xml:space="preserve">
          <source>If the variable type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">변수 유형이 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 인 경우 원자 업데이트 액세스 모드는 비트 표현을 사용하여 값을 비교합니다 &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt; 각각 &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt; 및 Double.doubleToRawLongBits (double) 참조 ).</target>
        </trans-unit>
        <trans-unit id="f203f0949cc7b918d1e2d216ac08216e57175fa4" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical AND is performed instead of a bitwise AND.</source>
          <target state="translated">변수 유형이 정수가 아닌 &lt;code&gt;boolean&lt;/code&gt; 유형이면 비트 AND 대신 논리 AND가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="317918488b3cba82b42ec854abe818df328b4867" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical OR is performed instead of a bitwise OR.</source>
          <target state="translated">변수 유형이 정수가 아닌 &lt;code&gt;boolean&lt;/code&gt; 유형이면 비트 OR 대신 논리 OR이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f69ebca5baf035e2d13b6c96c1a80a913bdc9ac" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical XOR is performed instead of a bitwise XOR.</source>
          <target state="translated">변수 유형이 정수가 아닌 &lt;code&gt;boolean&lt;/code&gt; 유형이면 비트 단위 XOR 대신 논리 XOR이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="49f80850c03dac4ccd69fe704a52eb909e453d10" translate="yes" xml:space="preserve">
          <source>If the view component of this layer implements &lt;a href=&quot;scrollable&quot;&gt;&lt;code&gt;Scrollable&lt;/code&gt;&lt;/a&gt;, this method delegates its implementation to the view component.</source>
          <target state="translated">이 레이어의 뷰 구성 요소가 &lt;a href=&quot;scrollable&quot;&gt; &lt;code&gt;Scrollable&lt;/code&gt; 을&lt;/a&gt; 구현하는 경우이 메서드는 해당 구현을 뷰 구성 요소에 위임합니다.</target>
        </trans-unit>
        <trans-unit id="e6056598d7fc6e1f9bab9fde45ff4e85d32b9431" translate="yes" xml:space="preserve">
          <source>If the view implements &lt;code&gt;Scrollable&lt;/code&gt; a combination of &lt;code&gt;getPreferredScrollableViewportSize&lt;/code&gt;, &lt;code&gt;getScrollableTracksViewportWidth&lt;/code&gt; and &lt;code&gt;getScrollableTracksViewportHeight&lt;/code&gt;is used, otherwise</source>
          <target state="translated">보기가 &lt;code&gt;Scrollable&lt;/code&gt; 을 구현 하는 경우 &lt;code&gt;getPreferredScrollableViewportSize&lt;/code&gt; , &lt;code&gt;getScrollableTracksViewportWidth&lt;/code&gt; 및 &lt;code&gt;getScrollableTracksViewportHeight&lt;/code&gt; 가 사용됩니다. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="6e8e8c7689ef325d78e889713b9aed6e71529da2" translate="yes" xml:space="preserve">
          <source>If the view's size hasn't been explicitly set, return the preferred size, otherwise return the view's current size.</source>
          <target state="translated">보기의 크기가 명시 적으로 설정되지 않은 경우 선호하는 크기를 반환하고 그렇지 않으면보기의 현재 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15a76a9f42e8b551caa02ec901e3cd32d7b99d18" translate="yes" xml:space="preserve">
          <source>If the view's size hasn't been explicitly set, return the preferred size, otherwise return the view's current size. If there is no view, return 0,0.</source>
          <target state="translated">보기의 크기가 명시 적으로 설정되지 않은 경우 선호하는 크기를 반환하고 그렇지 않으면보기의 현재 크기를 반환합니다. 보기가 없으면 0,0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80fb55d57fa2a3783b757491a0aafb1381a47c58" translate="yes" xml:space="preserve">
          <source>If the viewport is obscured by an ancestor, stop and repaint the whole viewport.</source>
          <target state="translated">If the viewport is obscured by an ancestor, stop and repaint the whole viewport.</target>
        </trans-unit>
        <trans-unit id="ac85a1b5c14ea33446482faac76a04c937a42f22" translate="yes" xml:space="preserve">
          <source>If the visible amount supplied is less than &lt;code&gt;one&lt;/code&gt; or greater than the current &lt;code&gt;maximum - minimum&lt;/code&gt;, then either &lt;code&gt;one&lt;/code&gt; or &lt;code&gt;maximum - minimum&lt;/code&gt; is substituted, as appropriate.</source>
          <target state="translated">If the visible amount supplied is less than &lt;code&gt;one&lt;/code&gt; or greater than the current &lt;code&gt;maximum - minimum&lt;/code&gt; , then either &lt;code&gt;one&lt;/code&gt; or &lt;code&gt;maximum - minimum&lt;/code&gt; is substituted, as appropriate.</target>
        </trans-unit>
        <trans-unit id="c974944a24bc22bfa54c303b025a9e590bd03f10" translate="yes" xml:space="preserve">
          <source>If the visible row count is &amp;lt;= 0, the preferred height is dictated by the number of columns, which will be as many as can fit in the width of the &lt;code&gt;JList&lt;/code&gt; (width / max cell width), with at least one column. The preferred height then becomes the model size / number of columns * maximum cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</source>
          <target state="translated">If the visible row count is &amp;lt;= 0, the preferred height is dictated by the number of columns, which will be as many as can fit in the width of the &lt;code&gt;JList&lt;/code&gt; (width / max cell width), with at least one column. The preferred height then becomes the model size / number of columns * maximum cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</target>
        </trans-unit>
        <trans-unit id="5f5fba29ff007e49901e18f55046f0713af8526d" translate="yes" xml:space="preserve">
          <source>If the visible row count is greater than zero, the preferredHeight is the maximum cell height * adjustedRowCount. Where visibleRowCount is used to determine the number of columns. Because this lays out horizontally the number of rows is then determined from the column count. For example, lets say you have a model with 10 items and the visible row count is 8. The number of columns needed to display this is 2, but you no longer need 8 rows to display this, you only need 5, thus the adjustedRowCount is 5.</source>
          <target state="translated">If the visible row count is greater than zero, the preferredHeight is the maximum cell height * adjustedRowCount. Where visibleRowCount is used to determine the number of columns. Because this lays out horizontally the number of rows is then determined from the column count. For example, lets say you have a model with 10 items and the visible row count is 8. The number of columns needed to display this is 2, but you no longer need 8 rows to display this, you only need 5, thus the adjustedRowCount is 5.</target>
        </trans-unit>
        <trans-unit id="af8f2aafa2c4ff83395f11d4e625de90952dbebf" translate="yes" xml:space="preserve">
          <source>If the visible row count is greater than zero, the preferredHeight is the maximum cell height * visibleRowCount. If the visible row count is &amp;lt;= 0, the preferred height is either the current height of the list, or the maximum cell height, whichever is bigger. The preferred width is than the maximum cell width * number of columns needed. Where the number of columns needs is list.height / max cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</source>
          <target state="translated">If the visible row count is greater than zero, the preferredHeight is the maximum cell height * visibleRowCount. If the visible row count is &amp;lt;= 0, the preferred height is either the current height of the list, or the maximum cell height, whichever is bigger. The preferred width is than the maximum cell width * number of columns needed. Where the number of columns needs is list.height / max cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</target>
        </trans-unit>
        <trans-unit id="bde030a57b155127406abe290ea916c308394ff9" translate="yes" xml:space="preserve">
          <source>If the voice is not currently processing a MIDI note, it is considered inactive. A voice is inactive when it has been given no note-on commands, or when every note-on command received has been terminated by a corresponding note-off (or by an &quot;all notes off&quot; message). For example, this happens when a synthesizer capable of playing 16 simultaneous notes is told to play a four-note chord; only four voices are active in this case (assuming no earlier notes are still playing). Usually, a voice whose status is reported as active is producing audible sound, but this is not always true; it depends on the details of the instrument (that is, the synthesis algorithm) and how long the note has been going on. For example, a voice may be synthesizing the sound of a single hand-clap. Because this sound dies away so quickly, it may become inaudible before a note-off message is received. In such a situation, the voice is still considered active even though no sound is currently being produced.</source>
          <target state="translated">음성이 현재 MIDI 음표를 처리하지 않으면 비활성 상태로 간주됩니다. 음성 명령에 메모 명령이 없거나 수신 된 모든 메모 명령이 해당 메모에 의해 (또는 &quot;모든 메모 꺼짐&quot;메시지에 의해 종료 된 경우) 음성이 비활성화됩니다. 예를 들어, 16 개의 동시 음을 연주 할 수있는 신시사이저에 4 음 코드를 연주하도록 지시 할 때 발생합니다. 이 경우 4 개의 음색 만 활성화됩니다 (이전의 음표가 여전히 재생되지 않는다고 가정). 일반적으로 상태가 활성으로보고 된 음성은 소리를 내고 있지만 항상 그런 것은 아닙니다. 악기의 세부 사항 (즉, 합성 알고리즘)과 음이 얼마나 오래 지속되었는지에 따라 다릅니다. 예를 들어, 음성은 단일 핸드 박수 소리를 합성 할 수 있습니다. 이 소리가 너무 빨리 사라 지므로메모 메시지가 수신되기 전에들을 수 없습니다. 이러한 상황에서 소리가 현재 생성되지 않더라도 음성은 여전히 ​​활성 상태로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b51ec0e550c0c529f4869085fbe1c6f15be1a3" translate="yes" xml:space="preserve">
          <source>If the waiting thread wakes up without dispatching the event, the &lt;code&gt;isDispatched()&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;while&lt;/code&gt; loop executes once more, thus, causing the awakened thread to revert to the waiting mode.</source>
          <target state="translated">If the waiting thread wakes up without dispatching the event, the &lt;code&gt;isDispatched()&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; , and the &lt;code&gt;while&lt;/code&gt; loop executes once more, thus, causing the awakened thread to revert to the waiting mode.</target>
        </trans-unit>
        <trans-unit id="eea99a16ca9472ba7577a6286f0c99175c71b6e9" translate="yes" xml:space="preserve">
          <source>If the window and/or its owner are not displayable yet, both of them are made displayable before calculating the preferred size. The Window is validated after its size is being calculated.</source>
          <target state="translated">If the window and/or its owner are not displayable yet, both of them are made displayable before calculating the preferred size. The Window is validated after its size is being calculated.</target>
        </trans-unit>
        <trans-unit id="99602aee7fccb8c26815c6abd3610a017f32754c" translate="yes" xml:space="preserve">
          <source>If the window is secure, then &lt;code&gt;getWarningString&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;. If the window is insecure, this method checks for the system property &lt;code&gt;awt.appletWarning&lt;/code&gt; and returns the string value of that property.</source>
          <target state="translated">If the window is secure, then &lt;code&gt;getWarningString&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt; . If the window is insecure, this method checks for the system property &lt;code&gt;awt.appletWarning&lt;/code&gt; and returns the string value of that property.</target>
        </trans-unit>
        <trans-unit id="5a7732dc7a32e7541fda0d87428f498a5f17066e" translate="yes" xml:space="preserve">
          <source>If the windowing system supports the &lt;a href=&quot;graphicsdevice.windowtranslucency#PERPIXEL_TRANSLUCENT&quot;&gt;&lt;code&gt;PERPIXEL_TRANSLUCENT&lt;/code&gt;&lt;/a&gt; translucency, the alpha component of the given background color may effect the mode of operation for this window: it indicates whether this window must be opaque (alpha equals &lt;code&gt;1.0f&lt;/code&gt;) or per-pixel translucent (alpha is less than &lt;code&gt;1.0f&lt;/code&gt;). If the given background color is &lt;code&gt;null&lt;/code&gt;, the window is considered completely opaque.</source>
          <target state="translated">If the windowing system supports the &lt;a href=&quot;graphicsdevice.windowtranslucency#PERPIXEL_TRANSLUCENT&quot;&gt; &lt;code&gt;PERPIXEL_TRANSLUCENT&lt;/code&gt; &lt;/a&gt; translucency, the alpha component of the given background color may effect the mode of operation for this window: it indicates whether this window must be opaque (alpha equals &lt;code&gt;1.0f&lt;/code&gt; ) or per-pixel translucent (alpha is less than &lt;code&gt;1.0f&lt;/code&gt; ). If the given background color is &lt;code&gt;null&lt;/code&gt; , the window is considered completely opaque.</target>
        </trans-unit>
        <trans-unit id="653f1f40cfb615ca17661dd80259d388f697bee1" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">현재 스레드가 쓰기 잠금을 획득하면 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0805140ae31a0f4050f9a4cfea06b4f470819eca" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the write lock hold count is set to one.</source>
          <target state="translated">쓰기 잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴되고 쓰기 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a07048d034065274e4ede5c8a84bad27f47aabea" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="74ef7c44b070eb1cc369e6589e8a1122f0468708" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="4fbef50e47f6976d0537a04edb35c78320ba5006" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the read lock has been acquired.</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 읽기 잠금이 획득 될 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="30ab94fb63654ae631cd1d744ae39fbebb43dde7" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다른 스레드가 쓰기 잠금을 보유한 경우이 메소드는 값 &lt;code&gt;false&lt;/code&gt; 와 함께 즉시 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7ef816b7e6153a6a58cc075b78ddfa153cbea13c" translate="yes" xml:space="preserve">
          <source>If the writer only offers a single, mandatory form of compression, it is not necessary to provide any named compression types. Named compression types should only be used where the user is able to make a meaningful choice between different schemes.</source>
          <target state="translated">기록기가 단일의 필수 압축 형식 만 제공하는 경우 명명 된 압축 유형을 제공 할 필요가 없습니다. 명명 된 압축 유형은 사용자가 다른 체계 중에서 의미있는 선택을 할 수있는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d7d2702baf6e372c2fd974b9ceb0e8765e0573d" translate="yes" xml:space="preserve">
          <source>If the years field is present, return its value as an &lt;code&gt;int&lt;/code&gt;, else return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">If the years field is present, return its value as an &lt;code&gt;int&lt;/code&gt; , else return &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb2436b74f4b1b03e972c41f1699a7b257b5b16" translate="yes" xml:space="preserve">
          <source>If the zone ID consists of a single letter, the zone ID is invalid and &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">영역 ID가 단일 문자로 구성된 경우 영역 ID가 유효하지 않고 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06d35c94a78d00be0bce80775b09f94dc2815e57" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a &lt;code&gt;ZoneId&lt;/code&gt; with the same ID and rules equivalent to &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'GMT', 'UTC'또는 'UT'인 경우 결과는 동일한 ID 및 규칙 이 &lt;code&gt;ZoneId&lt;/code&gt; 와 동일한 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7be309d5b31d6d9fd94ee00c0bd12eacb646dab8" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'Z', the result is &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'Z'인 경우 결과는 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87e6092693d13cc8dfc7ff32db6b3e49ec91630a" translate="yes" xml:space="preserve">
          <source>If the zone ID is a &lt;a href=&quot;zoneoffset&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;, then the result always has a time of midnight.</source>
          <target state="translated">영역 ID가 &lt;a href=&quot;zoneoffset&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt; 이면 결과는 항상 자정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="4b48da9c9e601217a4f5ae92f654428afda6e1aa" translate="yes" xml:space="preserve">
          <source>If the zone ID is not available or is a &lt;code&gt;ZoneOffset&lt;/code&gt; then the format is complete.</source>
          <target state="translated">영역 ID를 사용할 수 없거나 &lt;code&gt;ZoneOffset&lt;/code&gt; 인 경우 형식이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb96bf777d809e7b3490ab730d9c70ee13ec5673" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt;&lt;code&gt;ZoneOffset.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt; &lt;code&gt;ZoneOffset.of(String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="87677aa24c82d7da48f53ccb0c5b3d24a805cbe9" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">'-'영역 ID는 '+'또는 시작하는 경우,이 ID로서 해석된다 &lt;code&gt;ZoneOffset&lt;/code&gt; 하여 &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset.of(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="602223c8f8d238b617198cc90ea4b499d3a80171" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId()&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId()&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1780773eff7ca92ecd4ba03a3e8ea655fd0b8589" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'UTC +', 'UTC-', 'GMT +', 'GMT-', 'UT +'또는 'UT-'로 시작하면 ID는 접두사 오프셋 기반 ID입니다. ID는 2 개 또는 3 개의 문자 접두사와 부호로 시작하는 접미사와 함께 2 개로 분할됩니다. 접미사는 &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; 으로&lt;/a&gt; 구문 분석됩니다 . 결과는 것이다 &lt;code&gt;ZoneId&lt;/code&gt; 따라 지정된 UTC / GMT / UT 프리픽스 및 정규화 옵셋 ID와 &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt; . 반환 된 &lt;code&gt;ZoneId&lt;/code&gt; 의 규칙은 구문 분석 된 &lt;code&gt;ZoneOffset&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="41b8bc898e51c548630ae4313953f5a0179fbf8d" translate="yes" xml:space="preserve">
          <source>If the zone cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">영역을 구문 분석 할 수없는 경우 포맷터 섹션이 선택 사항이 아닌 한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="716de69875ef09bdf51d065ceec30a6b7a11919e" translate="yes" xml:space="preserve">
          <source>If the zone defines daylight savings into the future, then the list will normally be of size two and hold information about entering and exiting daylight savings. If the zone does not have daylight savings, or information about future changes is uncertain, then the list will be empty.</source>
          <target state="translated">영역이 일광 절약 시간을 미래로 정의하는 경우 일반적으로 목록의 크기는 2이며 일광 절약 입력 및 종료에 대한 정보를 보유합니다. 영역에 일광 절약 시간이 없거나 향후 변경에 대한 정보가 확실하지 않은 경우 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a223a21923ebbbeb7ae1d7b22472f2e489ded7a7" translate="yes" xml:space="preserve">
          <source>If there are any calendar fields whose values haven't been set in the selected field combination, &lt;code&gt;Calendar&lt;/code&gt; uses their default values. The default value of each field may vary by concrete calendar systems. For example, in &lt;code&gt;GregorianCalendar&lt;/code&gt;, the default of a field is the same as that of the start of the Epoch: i.e., &lt;code&gt;YEAR = 1970&lt;/code&gt;, &lt;code&gt;MONTH =
 JANUARY&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt;, etc.</source>
          <target state="translated">그 선택한 필드의 편성으로 값이 설정되어 있지 않은 달력 필드가있는 경우, &lt;code&gt;Calendar&lt;/code&gt; 기본 값을 사용합니다. 각 필드의 기본값은 구체적인 달력 시스템에 따라 달라질 수 있습니다. 예를 들어, &lt;code&gt;GregorianCalendar&lt;/code&gt; 에서 필드의 기본값은 Epoch의 시작과 동일합니다 (예 : &lt;code&gt;YEAR = 1970&lt;/code&gt; , &lt;code&gt;MONTH = JANUARY&lt;/code&gt; , &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="2f3668df86278c8a1e88d94210aa98ee6165c605" translate="yes" xml:space="preserve">
          <source>If there are any previously existing preferences that conflict with the preference being set here, then the GSSManager should ignore this request.</source>
          <target state="translated">If there are any previously existing preferences that conflict with the preference being set here, then the GSSManager should ignore this request.</target>
        </trans-unit>
        <trans-unit id="74ff37baa980c0a61132f301ce21852b4bc130d4" translate="yes" xml:space="preserve">
          <source>If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt;. If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; or &lt;code&gt;
 IOException&lt;/code&gt; then it may do so after some, but not all, bytes have been read from the input stream. It is strongly recommended that the stream be promptly closed and discarded if an exception occurs.</source>
          <target state="translated">If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; . If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; or &lt;code&gt; IOException&lt;/code&gt; then it may do so after some, but not all, bytes have been read from the input stream. It is strongly recommended that the stream be promptly closed and discarded if an exception occurs.</target>
        </trans-unit>
        <trans-unit id="92b113a4ce2494a131747fc911a67441d1d05a57" translate="yes" xml:space="preserve">
          <source>If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt;. If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; then it may do so after some, but not all, bytes have been read.</source>
          <target state="translated">If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; . If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; then it may do so after some, but not all, bytes have been read.</target>
        </trans-unit>
        <trans-unit id="e1f64fb5716e07724c0a7d48c0a02647c58da231" translate="yes" xml:space="preserve">
          <source>If there are conflicts or overlaps between the information provided by different &lt;code&gt;BeanInfo&lt;/code&gt; objects, the current &lt;code&gt;BeanInfo&lt;/code&gt; object takes priority over the additional &lt;code&gt;BeanInfo&lt;/code&gt; objects. Array elements with higher indices take priority over the elements with lower indices.</source>
          <target state="translated">다른 &lt;code&gt;BeanInfo&lt;/code&gt; 객체가 제공하는 정보간에 충돌이 있거나 겹치는 경우 현재 &lt;code&gt;BeanInfo&lt;/code&gt; 객체가 추가 &lt;code&gt;BeanInfo&lt;/code&gt; 객체 보다 우선 합니다. 지수가 높은 배열 요소는 지수가 낮은 요소보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="530a00d062bd6f003dc671b04ddaa979158f274f" translate="yes" xml:space="preserve">
          <source>If there are different resources for different countries, you can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for the German language (de) in Switzerland (CH). If you want to only modify some of the resources in the specialization, you can do so.</source>
          <target state="translated">국가별로 다른 리소스가있는 경우 전문화를 수행 할 수 있습니다. 예를 들어 &quot;MyResources_de_CH&quot;에는 스위스 (CH)의 독일어 (de)에 대한 개체가 포함되어 있습니다. 전문화 과정에서 일부 리소스 만 수정하려는 경우 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43c5f52ef558689fc38e846808ccf12921cc7008" translate="yes" xml:space="preserve">
          <source>If there are mnemonic names to be associated with the legal data values for the tag, &lt;a href=&quot;#addValueName(int,java.lang.String)&quot;&gt;&lt;code&gt;addValueName()&lt;/code&gt;&lt;/a&gt; should be called on the new instance for each name. Mnemonic names apply only to tags which have integral data type.</source>
          <target state="translated">If there are mnemonic names to be associated with the legal data values for the tag, &lt;a href=&quot;#addValueName(int,java.lang.String)&quot;&gt; &lt;code&gt;addValueName()&lt;/code&gt; &lt;/a&gt; should be called on the new instance for each name. Mnemonic names apply only to tags which have integral data type.</target>
        </trans-unit>
        <trans-unit id="0a003779b8a649ef8cb40c3f51dd00ab52590b8c" translate="yes" xml:space="preserve">
          <source>If there are more arguments than format specifiers, the extra arguments are ignored.</source>
          <target state="translated">형식 지정자보다 많은 인수가 있으면 추가 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="deb195b2b9fae2539cd1155fb241509f69b8a781" translate="yes" xml:space="preserve">
          <source>If there are multiple compression types but none has been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">여러 압축 유형이 있지만 설정되지 않은 경우 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="768dcb3e70295dbb108fd5dd725293766667ea22" translate="yes" xml:space="preserve">
          <source>If there are multiple runs of text, information about the runs can be accessed by indexing to get the start, limit, and level of a run. The level represents both the direction and the 'nesting level' of a directional run. Odd levels are right-to-left, while even levels are left-to-right. So for example level 0 represents left-to-right text, while level 1 represents right-to-left text, and level 2 represents left-to-right text embedded in a right-to-left run.</source>
          <target state="translated">여러 개의 텍스트 실행이있는 경우 인덱스를 통해 실행에 대한 정보에 액세스하여 실행의 시작, 한계 및 레벨을 얻을 수 있습니다. 레벨은 방향 달리기의 방향과 '중첩 레벨'을 모두 나타냅니다. 홀수 레벨은 오른쪽에서 왼쪽이며, 짝수 레벨은 왼쪽에서 오른쪽입니다. 예를 들어, 레벨 0은 왼쪽에서 오른쪽으로 텍스트를 나타내고, 레벨 1은 오른쪽에서 왼쪽으로 텍스트를 나타내며, 레벨 2는 오른쪽에서 왼쪽으로 실행에 포함 된 왼쪽에서 오른쪽으로 텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95fa2c7c9d03744e4ab294e05332429d827cf658" translate="yes" xml:space="preserve">
          <source>If there are multiple text directions present in the associated document, a flag indicating the caret bias will be rendered. This will occur only if the associated document is a subclass of AbstractDocument and there are multiple bidi levels present in the bidi element structure (i.e. the text has multiple directions associated with it).</source>
          <target state="translated">If there are multiple text directions present in the associated document, a flag indicating the caret bias will be rendered. This will occur only if the associated document is a subclass of AbstractDocument and there are multiple bidi levels present in the bidi element structure (i.e. the text has multiple directions associated with it).</target>
        </trans-unit>
        <trans-unit id="91aa0c8a84bbac8b5804b3100754fe9bb7d1dcbe" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3fd8782c948e6644afcfe2c7b88c23640ca646b" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">소켓에 버퍼링 된 바이트가없고 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; 를&lt;/a&gt; 사용하여 소켓을 닫지 않은 경우 &lt;a href=&quot;../io/inputstream#available--&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="899f5685138aa94e92de9d02a27528d96a112601" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="70808ff13ea15a635fe9933aa430b40622465ff0" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓에 버퍼링 된 바이트가 없거나 모든 버퍼링 된 바이트가 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 에 의해 소비 된 경우 , 모든 후속 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출 은 &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d97fea5e3b07fef354727bb8ea01358071cedc12" translate="yes" xml:space="preserve">
          <source>If there are no fields in the descriptor, then an empty String is returned.</source>
          <target state="translated">디스크립터에 필드가 없으면 빈 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a5d1f0a062afbc6cda49f87f90c8e9a1acb2dd5c" translate="yes" xml:space="preserve">
          <source>If there are no fini functions, the loop return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">If there are no fini functions, the loop return type is &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="452463b6bb8122e8d19b3e5165c3baa6dd891166" translate="yes" xml:space="preserve">
          <source>If there are no originating elements, none need to be passed. This information may be used in an incremental environment to determine the need to rerun processors or remove generated files. Non-incremental environments may ignore the originating element information.</source>
          <target state="translated">원래 요소가 없으면 전달할 필요가 없습니다. 이 정보는 증분 환경에서 프로세서를 다시 실행하거나 생성 된 파일을 제거해야 할 필요성을 판별하는 데 사용될 수 있습니다. 비 증분 환경은 원래 요소 정보를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1b6e296a2b77ef070997fd74f624d1c0686a93" translate="yes" xml:space="preserve">
          <source>If there are no parameters, no formatter is used.</source>
          <target state="translated">매개 변수가 없으면 포맷터가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="256816c6b5677c8691bdb94b6765ccbc5f24a09f" translate="yes" xml:space="preserve">
          <source>If there are several such threads, the bootstrap method may be invoked in several threads concurrently. Therefore, bootstrap methods which access global application data must take the usual precautions against race conditions. In any case, every &lt;code&gt;invokedynamic&lt;/code&gt; instruction is either unlinked or linked to a unique &lt;code&gt;CallSite&lt;/code&gt; object.</source>
          <target state="translated">그러한 스레드가 여러 개인 경우 부트 스트랩 메소드가 여러 스레드에서 동시에 호출 될 수 있습니다. 따라서 전역 응용 프로그램 데이터에 액세스하는 부트 스트랩 방법은 경쟁 조건에 대해 일반적인 예방 조치를 취해야합니다. 어쨌든 모든 &lt;code&gt;invokedynamic&lt;/code&gt; 명령어는 연결이 해제되거나 고유 한 &lt;code&gt;CallSite&lt;/code&gt; 객체에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="19df7c3245481a0b870f8b690f97116f667d21a7" translate="yes" xml:space="preserve">
          <source>If there are specialization prefixes for all arguments, the arity prefix may be left out (as in &lt;a href=&quot;objintconsumer&quot;&gt;&lt;code&gt;ObjIntConsumer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">모든 인수에 특수 접두사가있는 경우, &lt;a href=&quot;objintconsumer&quot;&gt; &lt;code&gt;ObjIntConsumer&lt;/code&gt; &lt;/a&gt; 에서와 같이 arity 접 두부가 생략 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5496a27b9238a94964b622c624cac4a711b3706d" translate="yes" xml:space="preserve">
          <source>If there are two sets of quotes, a specific begin-quote must be matched by its corresponding end-quote.</source>
          <target state="translated">인용 부호가 두 개인 경우 특정 시작 인용 부호를 해당 종료 인용 부호와 일치시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="f6d2e2287b3f940a2108e0447a31bf2c4dae6c7e" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;linkageerror&quot;&gt;linkage error&lt;/a&gt; accessing the nest host, or if this class or interface is not enumerated as a member of the nest by the nest host, then it is considered to belong to its own nest and &lt;code&gt;this&lt;/code&gt; is returned as the host.</source>
          <target state="translated">If there is a &lt;a href=&quot;linkageerror&quot;&gt;linkage error&lt;/a&gt; accessing the nest host, or if this class or interface is not enumerated as a member of the nest by the nest host, then it is considered to belong to its own nest and &lt;code&gt;this&lt;/code&gt; is returned as the host.</target>
        </trans-unit>
        <trans-unit id="60fe5e1f14261b51420b2f4800ed45295f2b7b43" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Filter&lt;/code&gt;, its &lt;code&gt;isLoggable&lt;/code&gt; method is called to check if the given log record is loggable. If not we return. Otherwise the given record is copied into an internal circular buffer. Then the record's level property is compared with the &lt;code&gt;pushLevel&lt;/code&gt;. If the given level is greater than or equal to the &lt;code&gt;pushLevel&lt;/code&gt; then &lt;code&gt;push&lt;/code&gt; is called to write all buffered records to the target output &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filter&lt;/code&gt; 가있는 경우, 주어진 로그 레코드가 로그 가능한지 확인하기 위해 &lt;code&gt;isLoggable&lt;/code&gt; 메소드가 호출됩니다. 그렇지 않으면 우리는 돌아온다. 그렇지 않으면 주어진 레코드가 내부 순환 버퍼에 복사됩니다. 그런 다음 레코드의 레벨 특성이 &lt;code&gt;pushLevel&lt;/code&gt; 과 비교됩니다 . 주어진 레벨이 이상인 경우 &lt;code&gt;pushLevel&lt;/code&gt; 다음 &lt;code&gt;push&lt;/code&gt; 목표 출력 버퍼 된 모든 레코드를 작성라고 &lt;code&gt;Handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5dab46b4549ff2feda5be50fc66d249aaffc422" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the current value to a String, this will set the text to an empty String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being in an invalid state.</source>
          <target state="translated">If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the current value to a String, this will set the text to an empty String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being in an invalid state.</target>
        </trans-unit>
        <trans-unit id="8264923428e93189de3d9488f3d02a8d83fd11ec" translate="yes" xml:space="preserve">
          <source>If there is a character stream specified, the SAX parser will ignore any byte stream and will not attempt to open a URI connection to the system identifier.</source>
          <target state="translated">문자 스트림이 지정된 경우 SAX 파서는 바이트 스트림을 무시하고 시스템 식별자에 대한 URI 연결을 열려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41cf28f3b00327296b2da5a55e1ed9b510e74f92" translate="yes" xml:space="preserve">
          <source>If there is a charset definition specified as a parameter of the content type specification, it will be used when loading input streams using the associated &lt;code&gt;EditorKit&lt;/code&gt;. For example if the type is specified as &lt;code&gt;text/html; charset=EUC-JP&lt;/code&gt; the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for &lt;code&gt;text/html&lt;/code&gt; and the Reader provided to the &lt;code&gt;EditorKit&lt;/code&gt; to load unicode into the document will use the &lt;code&gt;EUC-JP&lt;/code&gt; charset for translating to unicode. If the type is not recognized, the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for plain text, &lt;code&gt;text/plain&lt;/code&gt;.</source>
          <target state="translated">If there is a charset definition specified as a parameter of the content type specification, it will be used when loading input streams using the associated &lt;code&gt;EditorKit&lt;/code&gt; . For example if the type is specified as &lt;code&gt;text/html; charset=EUC-JP&lt;/code&gt; the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for &lt;code&gt;text/html&lt;/code&gt; and the Reader provided to the &lt;code&gt;EditorKit&lt;/code&gt; to load unicode into the document will use the &lt;code&gt;EUC-JP&lt;/code&gt; charset for translating to unicode. If the type is not recognized, the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for plain text, &lt;code&gt;text/plain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a6d33db9099e5da02b63b1c08b711314ed1070" translate="yes" xml:space="preserve">
          <source>If there is a current output stream then the &lt;code&gt;Formatter&lt;/code&gt;'s tail string is written and the stream is flushed and closed. Then the output stream is replaced with the new output stream.</source>
          <target state="translated">현재 출력 스트림이 있으면 &lt;code&gt;Formatter&lt;/code&gt; 의 꼬리 문자열이 기록되고 스트림이 플러시되고 닫힙니다. 그런 다음 출력 스트림이 새 출력 스트림으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="360eb0e694f70b9c0d8a6d2539b8b95168589f9b" translate="yes" xml:space="preserve">
          <source>If there is a language tag which matches completely to a language range above, the language tag is returned.</source>
          <target state="translated">위의 언어 범위와 완전히 일치하는 언어 태그가 있으면 언어 태그가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe9d5f4f323a99adea908fdeaf0c559a2234dc4" translate="yes" xml:space="preserve">
          <source>If there is a positive entry that grants a principal a particular permission, and a negative entry that denies the principal the same permission, the result is as though the permission was never granted or denied.</source>
          <target state="translated">주체에게 특정 권한을 부여하는 긍정적 인 항목과 주체에게 동일한 권한을 거부하는 부정적 항목이 있으면 결과는 권한이 부여되거나 거부되지 않은 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b820edb0cd4651acfa98bad6a1adbcc5b12aee0a" translate="yes" xml:space="preserve">
          <source>If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt;, it is returned as an instance of that class (ex: a &lt;code&gt;SignatureProperties&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;signatureproperties&quot;&gt;&lt;code&gt;SignatureProperties&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt; , it is returned as an instance of that class (ex: a &lt;code&gt;SignatureProperties&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;signatureproperties&quot;&gt; &lt;code&gt;SignatureProperties&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="9a0ac9d4b223e6ba398b5c03bdbdea908d2e6008" translate="yes" xml:space="preserve">
          <source>If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt;, it is returned as an instance of that class (ex: an &lt;code&gt;X509Data&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;x509data&quot;&gt;&lt;code&gt;X509Data&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt; , it is returned as an instance of that class (ex: an &lt;code&gt;X509Data&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;x509data&quot;&gt; &lt;code&gt;X509Data&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="7d2642219ae6689a90935a889cec5cc47e6b73a4" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; permission to ensure it's ok to replace the existing security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 이미 설치되어있는 경우이 메소드는 먼저 기존 보안 관리자를 대체 할 수 있도록 &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출합니다 . 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34d939280196d74fc1d1d34c5817d26280f87f75" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; permission to ensure the calling thread has permission to create a new security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 이미 설치되어있는 경우이 메소드는 먼저 &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 호출 스레드에 새 보안 관리자를 작성할 수있는 권한이 있는지 확인합니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5672428ce2d0310db13a3f85f67e993338e8598a" translate="yes" xml:space="preserve">
          <source>If there is a security manager and &lt;code&gt;host&lt;/code&gt; is not null and &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">보안 관리자가 있고 &lt;code&gt;host&lt;/code&gt; 가 널이 &lt;code&gt;host.length() &lt;/code&gt; 가 0이 아닌 경우, 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호스트 이름 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 조작이 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fd5ff852f368770ab762748f1c19d1dda73aa1db" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, it can forbid the lookup on various grounds (&lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;see below&lt;/a&gt;). By contrast, the &lt;code&gt;ldc&lt;/code&gt; instruction on a &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constant is not subject to security manager checks.</source>
          <target state="translated">보안 관리자가 설치되어 있으면 다양한 이유로 조회를 금지 할 수 있습니다 ( &lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;아래 참조&lt;/a&gt; ). 반대로 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수 의 &lt;code&gt;ldc&lt;/code&gt; 명령어 는 보안 관리자 검사를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b156cc02a90506f8eb9b81ce87ad4e2f4f5e01f7" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with &lt;code&gt;this&lt;/code&gt; as its argument. This may result in a &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).</source>
          <target state="translated">설치 보안 매니저가 존재하는 경우, 그 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출되어 &lt;code&gt;this&lt;/code&gt; 인수로. 이로 인해 현재 스레드에서 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5128105dcb411eeec7bd98eb31dc6c9f32f36396" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">보안 관리자가 설치되어있는 경우이 메소드는 먼저 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 서브 클래 싱을 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="31761f6c70fa775cd9eb51012f53c8d7db6b5b68" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">보안 관리자가 설치되어있는 경우,이 메소드는 먼저 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 서브 클래 싱을 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5e92b1005890b8e36b5a3e3ec1d22670527621dc" translate="yes" xml:space="preserve">
          <source>If there is a security manager set then its &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked to check that the caller has been granted &lt;a href=&quot;../runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;accessSystemModules&quot;)&lt;/code&gt;&lt;/a&gt; to access the system modules.</source>
          <target state="translated">If there is a security manager set then its &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; method is invoked to check that the caller has been granted &lt;a href=&quot;../runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;accessSystemModules&quot;)&lt;/code&gt; &lt;/a&gt; to access the system modules.</target>
        </trans-unit>
        <trans-unit id="b86d00a2babbd52f7023cffa0fd1499e014ec134" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, it is invoked to check &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt;. If that check fails with a &lt;code&gt;SecurityException&lt;/code&gt; then a warning banner is created.</source>
          <target state="translated">If there is a security manager set, it is invoked to check &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt; . If that check fails with a &lt;code&gt;SecurityException&lt;/code&gt; then a warning banner is created.</target>
        </trans-unit>
        <trans-unit id="64d3f1b6faeb8fe10d38810363c8cc48f8921c9d" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port of the channel's socket is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address and the local port of the channel's socket is returned.</target>
        </trans-unit>
        <trans-unit id="efeea28b8db5bdbdbe7665022456615ea9a2a02a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port of the channel's socket is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소와 채널 소켓의 로컬 포트를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="314e1e1967331821237d640541c5b0e1313b59bd" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which the socket is bound is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address and the local port to which the socket is bound is returned.</target>
        </trans-unit>
        <trans-unit id="c7de07e801ccd99c1e04407e222cb2fc9764b11a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which this socket is bound is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address and the local port to which this socket is bound is returned.</target>
        </trans-unit>
        <trans-unit id="bd4504e52760544f5802fe95b384c420e8994a88" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which the socket is bound is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소와 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 와 소켓이 바인딩 된 로컬 포트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e9d7c04bc4d0c36452207dc47930704ce6c96d6" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which this socket is bound is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 와이 소켓이 바인딩 된 로컬 포트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d707ade497c4fb2f188d76f169d44a01ba531e6e" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address is returned as the implementation address.</target>
        </trans-unit>
        <trans-unit id="d2186903b27dd0e412d3c41bc56df02edfa54b96" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;InetAddress&lt;/code&gt; 가 구현 주소로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7859548d6fe21c1371c700ba9e5a16a116554b8" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address is returned.</target>
        </trans-unit>
        <trans-unit id="e5eea39d0bafa27479de1740d6a3bd033e70cc0a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c4393236d40a93051b0ea6d79cd37ab06006e55e" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called to check &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager then its &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; method is called to check &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd0ea8c723035f1f68d96d6ce02d00d5e694624" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method if first called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</source>
          <target state="translated">If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method if first called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</target>
        </trans-unit>
        <trans-unit id="975b403d7a17640c61b22b1fe12733ab70ac0406" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</source>
          <target state="translated">If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</target>
        </trans-unit>
        <trans-unit id="70274ada9a62f6bd34849b3ea45696f8033443f7" translate="yes" xml:space="preserve">
          <source>If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</source>
          <target state="translated">If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</target>
        </trans-unit>
        <trans-unit id="f21f2cb00e18158e239acee5b75d0e9108e9c70d" translate="yes" xml:space="preserve">
          <source>If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</source>
          <target state="translated">If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</target>
        </trans-unit>
        <trans-unit id="501526fb9b9e2e222246e9cd9786ee96d321d66c" translate="yes" xml:space="preserve">
          <source>If there is a security manager, a packet cannot be received if the security manager's &lt;code&gt;checkAccept&lt;/code&gt; method does not allow it.</source>
          <target state="translated">보안 관리자가있는 경우 보안 관리자의 &lt;code&gt;checkAccept&lt;/code&gt; 메소드가 허용하지 않으면 패킷을 수신 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dfbfad4dd09ad7ea7b2126cee4029ecba6ab2815" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and &lt;code&gt;host&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to determine if the operation is allowed.</source>
          <target state="translated">If there is a security manager, and &lt;code&gt;host&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to determine if the operation is allowed.</target>
        </trans-unit>
        <trans-unit id="78bc0f4a72c52e6defa54f26456df6b6bfdcd359" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and the socket is not currently connected to a remote address, this method first performs some security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; is true, this method calls the security manager's &lt;code&gt;checkMulticast&lt;/code&gt; method with &lt;code&gt;p.getAddress()&lt;/code&gt; as its argument. If the evaluation of that expression is false, this method instead calls the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method with arguments &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method could result in a SecurityException if the operation is not allowed.</source>
          <target state="translated">보안 관리자가 있고 소켓이 현재 원격 주소에 연결되어 있지 않은 경우이 방법은 먼저 일부 보안 검사를 수행합니다. 먼저 &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; 가 true 인 경우이 메소드는 &lt;code&gt;p.getAddress()&lt;/code&gt; 를 인수로 사용 하여 보안 관리자의 &lt;code&gt;checkMulticast&lt;/code&gt; 메소드를 호출합니다 . 해당 표현식의 평가가 false 인 경우이 메소드는 대신 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; 및 &lt;code&gt;p.getPort()&lt;/code&gt; 인수로 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드를 호출합니다 . 조작이 허용되지 않으면 보안 관리자 메소드를 호출 할 때마다 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f2dc991bc054662c9aaf92a4f81920cc42b0299" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and this thread is not the current thread, then the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; permission to see if it's ok to get the stack trace.</source>
          <target state="translated">보안 관리자가 &lt;code&gt;checkPermission&lt;/code&gt; 스레드가 현재 스레드가 아닌 경우 보안 관리자의 checkPermission 메소드가 &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; 권한으로 호출되어 스택 추적을 가져 오기에 적합한 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d1b98d766cc337fb9898419e46a662c7d8de062a" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess(java.lang.ThreadGroup)&quot;&gt;&lt;code&gt;checkAccess&lt;/code&gt;&lt;/a&gt; method is invoked with the ThreadGroup as its argument.</source>
          <target state="translated">If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess(java.lang.ThreadGroup)&quot;&gt; &lt;code&gt;checkAccess&lt;/code&gt; &lt;/a&gt; method is invoked with the ThreadGroup as its argument.</target>
        </trans-unit>
        <trans-unit id="9414114a34df41ef68dcd065db4f4c005b486dbe" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt;&lt;code&gt;checkAccess&lt;/code&gt;&lt;/a&gt; method is invoked with the ThreadGroup as its argument.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt; &lt;code&gt;checkAccess&lt;/code&gt; &lt;/a&gt; 메소드가 ThreadGroup을 인수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd4592e446f7faba341b06f36e03f193c3eabf7" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader()&quot;&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/a&gt; method is invoked. This may result in a security exception.</source>
          <target state="translated">If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader()&quot;&gt; &lt;code&gt;checkCreateClassLoader&lt;/code&gt; &lt;/a&gt; method is invoked. This may result in a security exception.</target>
        </trans-unit>
        <trans-unit id="3533ff6ee33a3d65c462d1050b52aa5438f30879" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt;&lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method is invoked. This may result in a security exception.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt; &lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 보안 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dd5e5d0112178d816deaa79996ddbde5d42d22e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; being thrown.</target>
        </trans-unit>
        <trans-unit id="85a1e97c5d37987df52e3f2db8dd957eb6a2e0a1" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드가이 오브젝트 &lt;code&gt;command&lt;/code&gt; 배열 의 첫 번째 구성 요소를 인수로 사용하여 호출됩니다. 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c30beb89be73a967106d6bb017cc3341325b7e4" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가있는 경우이 스레드를 인수로 사용 하여 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="959b09fe0d2c452907b0520da6e28a90c4ae65f9" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread group as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가있는 경우이 스레드 그룹을 인수로 사용 하여 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c17150f3dc1fd1d9a170113f445867d696c2b24" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Enumeration. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt;&lt;code&gt;NetPermission&lt;/code&gt;&lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</source>
          <target state="translated">보안 관리자가있는 경우 각 InetAddress에 대해 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다. &lt;code&gt;checkConnect&lt;/code&gt; 가 SecurityException을 발생시키지 않는 InetAddresses 만 Enumeration에 반환됩니다. 그러나 호출자에게 &lt;a href=&quot;netpermission&quot;&gt; &lt;code&gt;NetPermission&lt;/code&gt; &lt;/a&gt; ( &quot;getNetworkInformation&quot;) 권한 이 있으면 모든 InetAddresses가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="58541a971b5c4b55ce89f0aa08744fea81192c9b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Stream. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt;&lt;code&gt;NetPermission&lt;/code&gt;&lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Stream. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt; &lt;code&gt;NetPermission&lt;/code&gt; &lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</target>
        </trans-unit>
        <trans-unit id="16d27bea720609eee04166dfd76b88b456132798" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with &lt;code&gt;host.getHostAddress()&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 &lt;code&gt;host.getHostAddress()&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 를 인수로 사용하여 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43c71e671e00781339f5ba759f2bcd61a8b7a34b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the InetAddress for each InterfaceAddress. Only InterfaceAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the List.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;checkConnect&lt;/code&gt; 메소드는 각 InterfaceAddress에 대해 InetAddress와 함께 호출됩니다. &lt;code&gt;checkConnect&lt;/code&gt; 가 SecurityException을 발생시키지 않는 인터페이스 주소 만 목록에 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="78af07133b038dacb150089b40e78b0ca1d3d753" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host address and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우 호스트 주소와 &lt;code&gt;port&lt;/code&gt; 를 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다 . 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d2ddb66aff693ec81fe7a3cff9c33e416a967ed" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host name as its argument to check the permission to resolve it. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드는 호스트 이름을 인수로하여이를 해결하기위한 권한을 점검합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01ae3cd02649f51bc3641c7c81a3016b88a1579b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local host name and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an InetAddress representing the loopback address is returned.</source>
          <target state="translated">보안 관리자가있는 경우 로컬 호스트 이름과 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용 하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 루프백 주소를 나타내는 InetAddress가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d128c55ea8e46338a04c172173181318ab739b7" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the proxy host address and port number as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우 프록시 호스트 주소 및 포트 번호를 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bca28a5046aedb2445dad871f1870c7cd86fe222" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the host address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 먼저 호스트 주소와 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 호출되어 조작이 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fd69bfacd3a48bd3c84ffe11c3502373bc1b717d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, it will return the textual representation of the IP address.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 먼저 호스트 이름과 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 IP 주소의 텍스트 표현이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19b8451790374e638a897d576809e75ff26e4bdc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkExit&lt;/code&gt; method is first called with 0 as its argument to ensure the exit is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkExit&lt;/code&gt; 메소드는 먼저 엑시트가 허용되도록 인수로 0을 사용하여 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad778e38f7a8fa1a04c66c84bec80348990751b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84eacac097d36c19fe75054afbaa3ba99bf8985e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다. &lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같은 경우, 구현 고유의 디폴트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7696a640bf74fb64021433fe004320c4e69fec7e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with 0 as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드는 조작이 허용되도록 인수로 0을 사용하여 먼저 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d8bb6cd4c61d496d648276b50f92f3feba88b5" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 먼저 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2550b60768f930b8dee700df520c5f4176ce28d3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the SocketAddress port as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드는 조작이 허용되도록 인수로 SocketAddress 포트와 함께 먼저 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a229539b4a28c2f5ec8ded7c3825ecf64243199f" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the port from the socket address as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 먼저 소켓 주소의 포트를 인수로 호출하여 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="526f451df552a77dd63ebe02272aee894aeec911" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called to check &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called to check &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1362fabcddab928d786a66dfafce71193c90bbd3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; permission before the default locale is changed.</source>
          <target state="translated">보안 관리자가있는 경우 기본 로케일이 변경되기 전에 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; 권한 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a19d07ab57d6d32ab3bfc3854e57cbabaa6348e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">보안 관리자가 있으면 해당 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2046cd2160f064fcca12b8ed464d009e531b209f" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;watchMousePointer&quot;)&lt;/code&gt; permission before creating and returning a &lt;code&gt;PointerInfo&lt;/code&gt; object. This may result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;watchMousePointer&quot;)&lt;/code&gt; permission before creating and returning a &lt;code&gt;PointerInfo&lt;/code&gt; object. This may result in a &lt;code&gt;SecurityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="023c7b6fa6e64e85c534968cd82b886f189f68e0" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with the &lt;code&gt;AWTPermission(&quot;setAppletStub&quot;)&lt;/code&gt; permission if a stub has already been set.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with the &lt;code&gt;AWTPermission(&quot;setAppletStub&quot;)&lt;/code&gt; permission if a stub has already been set.</target>
        </trans-unit>
        <trans-unit id="a5901e8f5f3e827f7dec190acb7b2c680e3d8a12" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called to check &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called to check &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba736daa95eab79c3e9ec30a15feed15b6f2153e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</target>
        </trans-unit>
        <trans-unit id="b73ff7cd0749e2fe69c0f2fcc0421edecf259b2d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e19a3d6b18c7f288973d4faca480e353d3119ae" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;java.util.logging.LoggingPermission(&quot;control&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;java.util.logging.LoggingPermission(&quot;control&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb05ace85aa7a9edcb040bdd423405912174b9c" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b812e22f1f04741048de016813ab27b17900ad4d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가있는 &lt;code&gt;checkPropertiesAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61ad58a3688694c18343d625b7add7843909f0fc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's &lt;code&gt;checkWrite&lt;/code&gt; method is also called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if write access to the file is allowed.</source>
          <target state="translated">보안 관리자가있는 경우 파일에 대한 읽기 액세스가 허용되는지 확인하기 위해 &lt;code&gt;checkRead&lt;/code&gt; 메소드가 &lt;code&gt;name&lt;/code&gt; 인수 와 함께 인수로 호출됩니다 . 모드 가 쓰기를 허용하는 경우 파일에 대한 쓰기 액세스가 허용되는지 확인하기 위해 &lt;code&gt;name&lt;/code&gt; 인수를 인수로 사용 하여 보안 관리자의 &lt;code&gt;checkWrite&lt;/code&gt; 메소드도 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8440e06fb5641cd0bbb2e4e19fe4021dbf3d258" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; as its argument to see if it's ok to read the file descriptor. If read access is denied to the file descriptor a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">보안 관리자가있는 경우 파일 디스크립터 &lt;code&gt;fdObj&lt;/code&gt; 를 인수로 하여 &lt;code&gt;checkRead&lt;/code&gt; 메소드를 호출하여 파일 디스크립터 를 읽을 수 있는지 확인합니다. 파일 디스크립터에 대한 읽기 액세스가 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
